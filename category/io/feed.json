{
    "version": "https://jsonfeed.org/version/1",
    "title": "记录“美食”每刻 • All posts by \"io\" category",
    "description": "记录“美食”每刻",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/2022/10/07/%E7%AC%AC12%E7%AB%A0IO/",
            "url": "http://example.com/2022/10/07/%E7%AC%AC12%E7%AB%A0IO/",
            "title": "第12章IO",
            "date_published": "2022-10-06T16:00:00.000Z",
            "content_html": "<h1 id=\"12-IO流\"><a href=\"#12-IO流\" class=\"headerlink\" title=\"12 IO流\"></a>12 IO流</h1><h1 id=\"File类\"><a href=\"#File类\" class=\"headerlink\" title=\"File类\"></a>File类</h1><h2 id=\"1-对文件进行操作\"><a href=\"#1-对文件进行操作\" class=\"headerlink\" title=\"1 对文件进行操作\"></a>1 对文件进行操作</h2><pre><code class=\"java\">public class Test01 &#123;\n    //这是一个main方法，是程序的入口：\n    public static void main(String[] args) throws IOException &#123;\n        //将文件封装为一个File类的对象：\n        File f = new File(&quot;d:\\\\test.txt&quot;);\n        File f1 = new File(&quot;d:\\\\test.txt&quot;);\n        File f2 = new File(&quot;d:/test.txt&quot;);\n        //File.separator属性帮我们获取当前操作系统的路径拼接符号\n       //在windows，dos下，系统默认用“\\”作为路径分隔符 ，在unix，url中，使用“/”作为路径分隔符。\n        File f3 = new File(&quot;d:&quot;+File.separator+&quot;test.txt&quot;);//建议使用这种\n        //常用方法：\n        System.out.println(&quot;文件是否可读：&quot;+f.canRead());\n        System.out.println(&quot;文件是否可写：&quot;+f.canWrite());\n        System.out.println(&quot;文件的名字：&quot;+f.getName());\n        System.out.println(&quot;上级目录：&quot;+f.getParent());\n        System.out.println(&quot;是否是一个目录：&quot;+f.isDirectory());\n        System.out.println(&quot;是否是一个文件：&quot;+f.isFile());\n        System.out.println(&quot;是否隐藏：&quot;+f.isHidden());\n        System.out.println(&quot;文件的大小：&quot;+f.length());\n        System.out.println(&quot;是否存在：&quot;+f.exists());\n        /*if(f.exists())&#123;//如果文件存在，将文件删除操作\n            f.delete();\n        &#125;else&#123;//如果不存在，就创建这个文件\n            f.createNewFile();\n        &#125;*/\n        System.out.println(f == f1);//比较两个对象的地址\n        System.out.println(f.equals(f1));//比较两个对象对应的文件的路径\n        //跟路径相关的：\n        System.out.println(&quot;绝对路径：&quot;+f.getAbsolutePath());\n        System.out.println(&quot;相对路径：&quot;+f.getPath());\n        System.out.println(&quot;toString:&quot;+f.toString());\n        System.out.println(&quot;----------------------&quot;);\n        File f5 = new File(&quot;demo.txt&quot;);\n        if(!f5.exists())&#123;\n            f5.createNewFile();\n        &#125;\n        //绝对路径指的就是：真实的一个精准的，完整的路径\n        System.out.println(&quot;绝对路径：&quot;+f5.getAbsolutePath());\n        //相对路径：有一个参照物，相对这个参照物的路径。\n        //在main方法中，相对位置指的就是：D:\\IDEA_workspace\\TestJavaSE\n        //在junit的测试方法中，相对路径指的就是模块位置\n        System.out.println(&quot;相对路径：&quot;+f5.getPath());\n        //toString的效果永远是  相对路径\n        System.out.println(&quot;toString:&quot;+f5.toString());\n        File f6 = new File(&quot;a/b/c/demo.txt&quot;);\n        if(!f5.exists())&#123;\n            f5.createNewFile();\n        &#125;\n        System.out.println(&quot;绝对路径：&quot;+f6.getAbsolutePath());\n        System.out.println(&quot;相对路径：&quot;+f6.getPath());\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"2-对目录进行操作\"><a href=\"#2-对目录进行操作\" class=\"headerlink\" title=\"2 对目录进行操作\"></a>2 对目录进行操作</h2><pre><code class=\"java\">public class Test02 &#123;\n    //这是一个main方法，是程序的入口：\n    public static void main(String[] args) &#123;\n        //将目录封装为File类的对象：\n        File f = new File(&quot;D:\\\\IDEA_workspace&quot;);\n        System.out.println(&quot;文件是否可读：&quot;+f.canRead());\n        System.out.println(&quot;文件是否可写：&quot;+f.canWrite());\n        System.out.println(&quot;文件的名字：&quot;+f.getName());\n        System.out.println(&quot;上级目录：&quot;+f.getParent());\n        System.out.println(&quot;是否是一个目录：&quot;+f.isDirectory());\n        System.out.println(&quot;是否是一个文件：&quot;+f.isFile());\n        System.out.println(&quot;是否隐藏：&quot;+f.isHidden());\n        System.out.println(&quot;文件的大小：&quot;+f.length());\n        System.out.println(&quot;是否存在：&quot;+f.exists());\n        System.out.println(&quot;绝对路径：&quot;+f.getAbsolutePath());\n        System.out.println(&quot;相对路径：&quot;+f.getPath());\n        System.out.println(&quot;toString:&quot;+f.toString());\n        //跟目录相关的方法：\n        File f2 = new File(&quot;D:\\\\a\\\\b\\\\c&quot;);\n        //创建目录：\n        //f2.mkdir();//创建单层目录\n        //f2.mkdirs();//创建多层目录\n        //删除：如果是删除目录的话，只会删除一层，并且前提：这层目录是空的，里面没有内容，如果内容就不会被删除\n        f2.delete();\n        //查看：\n        String[] list = f.list();//文件夹下目录/文件对应的名字的数组\n        for(String s:list)&#123;\n            System.out.println(s);\n        &#125;\n        System.out.println(&quot;=========================&quot;);\n        File[] files = f.listFiles();//作用更加广泛\n        for(File file:files)&#123;\n            System.out.println(file.getName()+&quot;,&quot;+file.getAbsolutePath());\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<h1 id=\"IO流\"><a href=\"#IO流\" class=\"headerlink\" title=\"IO流\"></a>IO流</h1><h2 id=\"1-引入\"><a href=\"#1-引入\" class=\"headerlink\" title=\"1 引入\"></a>1 引入</h2><p>【1】File类：封装文件&#x2F;目录的各种信息，对目录&#x2F;文件进行操作，但是我们不可以获取到文件&#x2F;目录中的内容。<br>【2】引入：IO流：<br>I&#x2F;O ： Input&#x2F;Output的缩写，用于处理设备之间的数据的传输。<br>【3】形象理解：IO流 当做一根 “管”：</p>\n<img data-src=\"/2022/10/07/%E7%AC%AC12%E7%AB%A0IO/image-20220618184436805.png\" class=\"\">\n\n\n\n\n\n<p>【4】IO流的体系结构：</p>\n<img data-src=\"/2022/10/07/%E7%AC%AC12%E7%AB%A0IO/image-20220618184443031.png\" class=\"\">\n\n\n\n\n\n\n<h2 id=\"2-案例：通过java程序完成文件的复制操作\"><a href=\"#2-案例：通过java程序完成文件的复制操作\" class=\"headerlink\" title=\"2 案例：通过java程序完成文件的复制操作\"></a>2 案例：通过java程序完成文件的复制操作</h2><h3 id=\"功能分解1：文件–》程序：FileReader\"><a href=\"#功能分解1：文件–》程序：FileReader\" class=\"headerlink\" title=\"功能分解1：文件–》程序：FileReader\"></a>功能分解1：文件–》程序：FileReader</h3><p>一个字符一个字符的将文件中的内容读取到程序中了：</p>\n<pre><code class=\"java\">public class Test01 &#123;\n    //这是一个main方法，是程序的入口：\n    public static void main(String[] args) throws IOException &#123;\n        //文件--》程序：\n        //1.有一个文件：----》创建一个File类的对象\n        File f = new File(&quot;d:\\\\Test.txt&quot;);\n        //2.利用FileReader这个流，这个“管”怼到源文件上去   ---》创建一个FileReader的流的对象\n        FileReader fr = new FileReader(f);\n        //3.进行操作“吸”的动作  ---》读取动作\n        /*下面的代码我们验证了：如果到了文件的结尾处，那么读取的内容为-1\n        int n1 = fr.read();\n        int n2 = fr.read();\n        int n3 = fr.read();\n        int n4 = fr.read();\n        int n5 = fr.read();\n        int n6 = fr.read();\n        System.out.println(n1);\n        System.out.println(n2);\n        System.out.println(n3);\n        System.out.println(n4);\n        System.out.println(n5);\n        System.out.println(n6);*/\n        //方式1：\n        /*int n = fr.read();\n        while(n!=-1)&#123;\n            System.out.println(n);\n            n = fr.read();\n        &#125;*/\n        //方式2：\n        int n;\n        while((n = fr.read())!=-1)&#123;\n            System.out.println((char)n);\n        &#125;\n        //4.“管”不用了，就要关闭  ---》关闭流\n        //流，数据库，网络资源，靠jvm本身没有办法帮我们关闭，此时必须程序员手动关闭：\n        fr.close();\n    &#125;\n&#125;\n</code></pre>\n<p>想一次性读取五个字符，不够的话下次再读五个字符：</p>\n<pre><code class=\"java\">public class Test02 &#123;\n    //这是一个main方法，是程序的入口：\n    public static void main(String[] args) throws IOException &#123;\n        //文件--》程序：\n        //1.创建一个File类的对象\n        File f = new File(&quot;d:\\\\Test.txt&quot;);\n        //2.创建一个FileReader的流的对象\n        FileReader fr = new FileReader(f);\n        //3.读取动作\n        //引入一个“快递员的小车”，这个“小车”一次拉5个快递：\n        char[] ch = new char[5];//缓冲数组\n        int len = fr.read(ch);//一次读取五个:返回值是这个数组中 的有效长度\n        while(len!=-1)&#123;\n            //System.out.println(len);\n            //错误方式：\n            /*for (int i = 0 ;i &lt; ch.length;i++)&#123;\n                System.out.println(ch[i]);\n            &#125;*/\n            //正确方式：\n            /*for (int i = 0 ;i &lt; len;i++)&#123;\n                System.out.println(ch[i]);\n            &#125;*/\n            //正确方式2：将数组转为String：\n            String str = new String(ch,0,len);\n            System.out.print(str);\n            len = fr.read(ch);\n        &#125;\n        //4.关闭流\n        fr.close();\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"功能分解2：程序–》文件：FileWriter\"><a href=\"#功能分解2：程序–》文件：FileWriter\" class=\"headerlink\" title=\"功能分解2：程序–》文件：FileWriter\"></a>功能分解2：程序–》文件：FileWriter</h3><p>一个字符一个字符的向外输出：</p>\n<pre><code class=\"java\">public class Test03 &#123;\n    //这是一个main方法，是程序的入口：\n    public static void main(String[] args) throws IOException &#123;\n        //1.有个目标文件：\n        File f = new File(&quot;d:\\\\demo.txt&quot;);\n        //2.FileWriter管怼到文件上去：\n        FileWriter fw = new FileWriter(f);\n        //3.开始动作：输出动作：\n        //一个字符一个字符的往外输出：\n        String str = &quot;hello你好&quot;;\n        for (int i = 0 ;i &lt; str.length();i++)&#123;\n            fw.write(str.charAt(i));\n        &#125;\n        //4.关闭流：\n        fw.close();\n    &#125;\n&#125;\n</code></pre>\n<p>发现：<br>如果目标文件不存在的话，那么会自动创建此文件。<br>如果目标文件存在的话：<br>new FileWriter(f)   相当于对原文件进行覆盖操作。<br>new FileWriter(f,false)  相当于对源文件进行覆盖操作。不是追加。<br>new FileWriter(f,true)   对原来的文件进行追加，而不是覆盖。</p>\n<p><strong>利用缓冲数组：向外输出（利用缓冲数组：）</strong></p>\n<pre><code class=\"java\">public class Test03 &#123;\n    //这是一个main方法，是程序的入口：\n    public static void main(String[] args) throws IOException &#123;\n        //1.有个目标文件：\n        File f = new File(&quot;d:\\\\demo.txt&quot;);\n        //2.FileWriter管怼到文件上去：\n        FileWriter fw = new FileWriter(f,true);\n        //3.开始动作：输出动作：\n        //一个字符一个字符的往外输出：\n        String str = &quot;你好中国&quot;;\n        char[] chars = str.toCharArray();\n        fw.write(chars);\n        //4.关闭流：\n        fw.close();\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"功能分解3：利用FileReader，FileWriter文件复制\"><a href=\"#功能分解3：利用FileReader，FileWriter文件复制\" class=\"headerlink\" title=\"功能分解3：利用FileReader，FileWriter文件复制\"></a>功能分解3：利用FileReader，FileWriter文件复制</h3><pre><code class=\"java\">public class Test04 &#123;\n    //这是一个main方法，是程序的入口：\n    public static void main(String[] args) throws IOException &#123;\n        //1.有一个源文件\n        File f1 = new File(&quot;d:\\\\Test.txt&quot;);\n        //2.有一个目标文件：\n        File f2 = new File(&quot;d:\\\\Demo.txt&quot;);\n        //3.搞一个输入的管 怼到源文件上：\n        FileReader fr = new FileReader(f1);\n        //4.搞一个输出的管，怼到目标文件上：\n        FileWriter fw = new FileWriter(f2);\n        //5.开始动作：\n        //方式1：一个字符一个字符的复制：\n        /*int n = fr.read();\n        while(n!=-1)&#123;\n            fw.write(n);\n            n = fr.read();\n        &#125;*/\n        //方式2：利用缓冲字符数组：\n        /*char[] ch = new char[5];\n        int len = fr.read(ch);\n        while(len!=-1)&#123;\n            fw.write(ch,0,len);//将缓冲数组中有效长度写出\n            len = fr.read(ch);\n        &#125;*/\n        //方式3：利用缓冲字符数组，将数组转为String写出。\n        char[] ch = new char[5];\n        int len = fr.read(ch);\n        while(len!=-1)&#123;\n            String s = new String(ch,0,len);\n            fw.write(s);\n            len = fr.read(ch);\n        &#125;\n        //6.关闭流：(关闭流的时候，倒着关闭，后用先关)\n        fw.close();\n        fr.close();\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"3-警告：不要用字符流去操作非文本文件\"><a href=\"#3-警告：不要用字符流去操作非文本文件\" class=\"headerlink\" title=\"3 警告：不要用字符流去操作非文本文件\"></a>3 警告：不要用字符流去操作非文本文件</h2><p>文本文件：.txt   .java  .c  .cpp  —》建议使用字符流操作<br>非文本文件：.jpg,  .mp3  ,   .mp4 , .doc  , .ppt  —》建议使用字节流操作</p>\n<h2 id=\"4-用try-catch-finally处理异常方式\"><a href=\"#4-用try-catch-finally处理异常方式\" class=\"headerlink\" title=\"4 用try-catch-finally处理异常方式\"></a>4 用try-catch-finally处理异常方式</h2><pre><code class=\"java\">public class Test04 &#123;\n    //这是一个main方法，是程序的入口：\n    public static void main(String[] args)  &#123;\n        //1.有一个源文件\n        File f1 = new File(&quot;d:\\\\Test.txt&quot;);\n        //2.有一个目标文件：\n        File f2 = new File(&quot;d:\\\\Demo.txt&quot;);\n        //3.搞一个输入的管 怼到源文件上：\n        FileReader fr = null;\n        FileWriter fw = null;\n        try &#123;\n            fr = new FileReader(f1);\n            //4.搞一个输出的管，怼到目标文件上：\n            fw = new FileWriter(f2);\n            //5.开始动作：\n            char[] ch = new char[5];\n            int len = fr.read(ch);\n            while(len!=-1)&#123;\n                String s = new String(ch,0,len);\n                fw.write(s);\n                len = fr.read(ch);\n            &#125;\n        &#125; catch (FileNotFoundException e) &#123;\n            e.printStackTrace();\n        &#125; catch (IOException e) &#123;\n            e.printStackTrace();\n        &#125; finally &#123;\n            //6.关闭流：(关闭流的时候，倒着关闭，后用先关)\n            try &#123;\n                if(fw!=null)&#123;//防止空指针异常\n                    fw.close();\n                &#125;\n            &#125; catch (IOException e) &#123;\n                e.printStackTrace();\n            &#125;\n            try &#123;\n                if(fr!=null)&#123;\n                    fr.close();\n                &#125;\n            &#125; catch (IOException e) &#123;\n                e.printStackTrace();\n            &#125;\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"5-FileInputStream读取文件中内容\"><a href=\"#5-FileInputStream读取文件中内容\" class=\"headerlink\" title=\"5 FileInputStream读取文件中内容\"></a>5 FileInputStream读取文件中内容</h2><p>【1】读取文本文件：</p>\n<pre><code class=\"java\">public class Test01 &#123;\n    //这是一个main方法，是程序的入口：\n    public static void main(String[] args) throws IOException &#123;\n        //功能：利用字节流将文件中内容读到程序中来：\n        //1.有一个源文件：\n        File f = new File(&quot;D:\\\\Test.txt&quot;);\n        //2.将一个字节流这个管 怼  到 源文件上：\n        FileInputStream fis = new FileInputStream(f);\n        //3.开始读取动作\n        /*\n        细节1：\n        文件是utf-8进行存储的，所以英文字符 底层实际占用1个字节\n        但是中文字符，底层实际占用3个字节。\n        细节2：\n        如果文件是文本文件，那么就不要使用字节流读取了，建议使用字符流。\n        细节3：\n        read()读取一个字节，但是你有没有发现返回值是 int类型，而不是byte类型？\n        read方法底层做了处理，让返回的数据都是“正数”\n        就是为了避免如果字节返回的是-1的话，那到底是读入的字节，还是到文件结尾呢。\n         */\n        int n = fis.read();\n        while(n!=-1)&#123;\n            System.out.println(n);\n            n = fis.read();\n        &#125;\n        //4.关闭流：\n        fis.close();\n    &#125;\n&#125;\n</code></pre>\n<p>【2】利用字节流读取非文本文件：（以图片为案例：）–》一个字节一个字节的读取：</p>\n<pre><code class=\"java\">public class Test02 &#123;\n    //这是一个main方法，是程序的入口：\n    public static void main(String[] args) throws IOException &#123;\n        //功能：利用字节流将文件中内容读到程序中来：\n        //1.有一个源文件：\n        File f = new File(&quot;D:\\\\LOL.jpg&quot;);\n        //2.将一个字节流这个管 怼  到 源文件上：\n        FileInputStream fis = new FileInputStream(f);\n        //3.开始读取动作\n        int count = 0;//定义一个计数器，用来计读入的字节的个数\n        int n = fis.read();\n        while(n!=-1)&#123;\n            count++;\n            System.out.println(n);\n            n = fis.read();\n        &#125;\n        System.out.println(&quot;count=&quot;+count);\n        //4.关闭流：\n        fis.close();\n    &#125;\n&#125;\n</code></pre>\n<p>【3】利用字节类型的缓冲数组：</p>\n<pre><code class=\"java\">public class Test03 &#123;\n    //这是一个main方法，是程序的入口：\n    public static void main(String[] args) throws IOException &#123;\n        //功能：利用字节流将文件中内容读到程序中来：\n        //1.有一个源文件：\n        File f = new File(&quot;D:\\\\LOL.jpg&quot;);\n        //2.将一个字节流这个管 怼  到 源文件上：\n        FileInputStream fis = new FileInputStream(f);\n        //3.开始读取动作\n        //利用缓冲数组：（快递员的小车）\n        byte[] b = new byte[1024*6];\n        int len = fis.read(b);//len指的就是读取的数组中的有效长度\n        while(len!=-1)&#123;\n            //System.out.println(len);\n            for(int i = 0;i&lt;len;i++)&#123;\n                System.out.println(b[i]);\n            &#125;\n            len = fis.read(b);\n        &#125;\n        //4.关闭流：\n        fis.close();\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"6-FileInputStream-FileOutputStream完成非文本文件的复制\"><a href=\"#6-FileInputStream-FileOutputStream完成非文本文件的复制\" class=\"headerlink\" title=\"6 FileInputStream,FileOutputStream完成非文本文件的复制\"></a>6 FileInputStream,FileOutputStream完成非文本文件的复制</h2><p>【1】读入一个字节，写出一个字节：</p>\n<pre><code class=\"java\">public class Test04 &#123;\n    //这是一个main方法，是程序的入口：\n    public static void main(String[] args) throws IOException &#123;\n        //功能：完成图片的复制：\n        //1.有一个源图片\n        File f1 = new File(&quot;d:\\\\LOL.jpg&quot;);\n        //2.有一个目标图片：\n        File f2 = new File(&quot;d:\\\\LOL2.jpg&quot;);\n        //3.有一个输入的管道 怼 到 源文件：\n        FileInputStream fis = new FileInputStream(f1);\n        //4.有一个输出的管道 怼到  目标文件上：\n        FileOutputStream fos = new FileOutputStream(f2);\n        //5.开始复制：（边读边写）\n        int n = fis.read();\n        while(n!=-1)&#123;\n            fos.write(n);\n            n = fis.read();\n        &#125;\n        //6.关闭流：(倒着关闭流，先用后关)\n        fos.close();\n        fis.close();\n    &#125;\n&#125;\n</code></pre>\n<p>【2】利用缓冲字节数组：</p>\n<pre><code class=\"java\">public class Test05 &#123;\n    //这是一个main方法，是程序的入口：\n    public static void main(String[] args) throws IOException &#123;\n        //功能：完成图片的复制：\n        //1.有一个源图片\n        File f1 = new File(&quot;d:\\\\LOL.jpg&quot;);\n        //2.有一个目标图片：\n        File f2 = new File(&quot;d:\\\\LOL2.jpg&quot;);\n        //3.有一个输入的管道 怼 到 源文件：\n        FileInputStream fis = new FileInputStream(f1);\n        //4.有一个输出的管道 怼到  目标文件上：\n        FileOutputStream fos = new FileOutputStream(f2);\n        //5.开始复制：（边读边写）\n        //利用缓冲数组：\n        byte[] b = new byte[1024*8];\n        int len = fis.read(b);\n        while(len!=-1)&#123;\n            fos.write(b,0,len);\n            len = fis.read(b);\n        &#125;\n        //6.关闭流：(倒着关闭流，先用后关)\n        fos.close();\n        fis.close();\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"7-缓冲字节流-处理流-BufferedInputStream-BufferedOutputStream\"><a href=\"#7-缓冲字节流-处理流-BufferedInputStream-BufferedOutputStream\" class=\"headerlink\" title=\"7 缓冲字节流(处理流)-BufferedInputStream ,BufferedOutputStream\"></a>7 缓冲字节流(处理流)-BufferedInputStream ,BufferedOutputStream</h2><p>【1】读入一个字节，写出一个字节：</p>\n<p>【2】利用缓冲字节数组：</p>\n<p>【3】利用缓冲区：</p>\n<p>想要完成上面的效果，单纯的靠FileInputStream,FileOutputStream是不可以完成的，这个时候就需要功能的加强，<br>这个加强就需要引入新的流（在FileInputStream,FileOutputStream外面再套一层流）：BufferedInputStream ,BufferedOutputStream. —–&gt;处理流</p>\n<p>代码：</p>\n<pre><code class=\"java\">public class Test06 &#123;\n    //这是一个main方法，是程序的入口：\n    public static void main(String[] args) throws IOException &#123;\n        //1.有一个源图片\n        File f1 = new File(&quot;d:\\\\LOL.jpg&quot;);\n        //2.有一个目标图片：\n        File f2 = new File(&quot;d:\\\\LOL2.jpg&quot;);\n        //3.有一个输入的管道 怼 到 源文件：\n        FileInputStream fis = new FileInputStream(f1);\n        //4.有一个输出的管道 怼到  目标文件上：\n        FileOutputStream fos = new FileOutputStream(f2);\n        //5.功能加强，在FileInputStream外面套一个管：BufferedInputStream:\n        BufferedInputStream bis = new BufferedInputStream(fis);\n        //6.功能加强，在FileOutputStream外面套一个管：BufferedOutputStream:\n        BufferedOutputStream bos = new BufferedOutputStream(fos);\n        //7.开始动作 ：\n        byte[] b = new byte[1024*6];\n        int len = bis.read(b);\n        while(len!=-1)&#123;\n            bos.write(b,0,len);\n           /* bos.flush(); 底层已经帮我们做了刷新缓冲区的操作，不用我们手动完成：底层调用flushBuffer()*/\n            len = bis.read(b);\n        &#125;\n        //8.关闭流：\n        //倒着关：\n        //如果处理流包裹着节点流的话，那么其实只要关闭高级流（处理流），那么里面的字节流也会随之被关闭。\n        bos.close();\n        bis.close();\n        /*fos.close();\n        fis.close();*/\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"8-比对非文本文件复制的三种方法的效率\"><a href=\"#8-比对非文本文件复制的三种方法的效率\" class=\"headerlink\" title=\"8 比对非文本文件复制的三种方法的效率\"></a>8 比对非文本文件复制的三种方法的效率</h2><p>【1】读入一个字节，写出一个字节：</p>\n<img data-src=\"/2022/10/07/%E7%AC%AC12%E7%AB%A0IO/image-20220618184948658.png\" class=\"\">\n\n\n<p>【2】利用缓冲字节数组：</p>\n<img data-src=\"/2022/10/07/%E7%AC%AC12%E7%AB%A0IO/image-20220618184953685.png\" class=\"\">\n\n\n<p>【3】利用缓冲区：</p>\n<img data-src=\"/2022/10/07/%E7%AC%AC12%E7%AB%A0IO/image-20220618184958715.png\" class=\"\">\n\n\n<p>代码：</p>\n<pre><code class=\"java\">public class Test06 &#123;\n    //这是一个main方法，是程序的入口：\n    public static void main(String[] args) throws IOException &#123;\n        //1.有一个源图片\n        File f1 = new File(&quot;d:\\\\LOL.jpg&quot;);\n        //2.有一个目标图片：\n        File f2 = new File(&quot;d:\\\\LOL2.jpg&quot;);\n        //3.有一个输入的管道 怼 到 源文件：\n        FileInputStream fis = new FileInputStream(f1);\n        //4.有一个输出的管道 怼到  目标文件上：\n        FileOutputStream fos = new FileOutputStream(f2);\n        //5.功能加强，在FileInputStream外面套一个管：BufferedInputStream:\n        BufferedInputStream bis = new BufferedInputStream(fis);\n        //6.功能加强，在FileOutputStream外面套一个管：BufferedOutputStream:\n        BufferedOutputStream bos = new BufferedOutputStream(fos);\n        //7.开始动作 ：\n        long startTime = System.currentTimeMillis();\n        byte[] b = new byte[1024];\n        int len = bis.read(b);\n        while(len!=-1)&#123;\n            bos.write(b,0,len);\n           /* bos.flush(); 底层已经帮我们做了刷新缓冲区的操作，不用我们手动完成：底层调用flushBuffer()*/\n            len = bis.read(b);\n        &#125;\n        long endTime = System.currentTimeMillis();\n        System.out.println(&quot;复制完成的时间为：&quot;+(endTime-startTime));\n        //8.关闭流：\n        //倒着关：\n        //如果处理流包裹着节点流的话，那么其实只要关闭高级流（处理流），那么里面的字节流也会随之被关闭。\n        bos.close();\n        bis.close();\n        /*fos.close();\n        fis.close();*/\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"9-缓冲字符流-处理流-BufferedReader-BufferedWriter完成文本文件的复制\"><a href=\"#9-缓冲字符流-处理流-BufferedReader-BufferedWriter完成文本文件的复制\" class=\"headerlink\" title=\"9 缓冲字符流(处理流)-BufferedReader,BufferedWriter完成文本文件的复制\"></a>9 缓冲字符流(处理流)-BufferedReader,BufferedWriter完成文本文件的复制</h2><pre><code class=\"java\">public class Test07 &#123;\n    //这是一个main方法，是程序的入口：\n    public static void main(String[] args) throws IOException &#123;\n        //1.有一个源文件：\n        File f1 = new File(&quot;d:\\\\Test.txt&quot;);\n        //2.有一个目标文件：\n        File f2 = new File(&quot;d:\\\\Demo.txt&quot;);\n        //3.需要一个管 怼到 源文件：\n        FileReader fr = new FileReader(f1);\n        //4.需要一根管怼到目标文件：\n        FileWriter fw = new FileWriter(f2);\n        //5.套一根管在输入字符流外面：\n        BufferedReader br = new BufferedReader(fr);\n        //6.套一根管在输出字符流外面：\n        BufferedWriter bw = new BufferedWriter(fw);\n        //7.开始动作：\n        //方式1：读取一个字符，输出一个字符：\n        /*int n = br.read();\n        while(n!=-1)&#123;\n            bw.write(n);\n            n = br.read();\n        &#125;*/\n        //方式2:利用缓冲数组：\n        /*char[] ch = new char[30];\n        int len = br.read(ch);\n        while(len!=-1)&#123;\n            bw.write(ch,0,len);\n            len = br.read(ch);\n        &#125;*/\n        //方式3：读取String：\n        String str = br.readLine();//每次读取文本文件中一行，返回字符串\n        while(str!=null)&#123;\n            bw.write(str);\n            //在文本文件中应该再写出一个换行：\n            bw.newLine();//新起一行\n            str = br.readLine();\n        &#125;\n        //8.关闭流\n        bw.close();\n        br.close();\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"10-转换流-InputStreamReader-OutputStreamWriter\"><a href=\"#10-转换流-InputStreamReader-OutputStreamWriter\" class=\"headerlink\" title=\"10 转换流-InputStreamReader,OutputStreamWriter\"></a>10 转换流-InputStreamReader,OutputStreamWriter</h2><p>【1】转换流：作用：将字节流和字符流进行转换。<br>【2】转换流  属于 字节流还是字符流？属于字符流<br>InputStreamReader  ：字节输入流 —》字符的输入流<br>OutputStreamWriter  ： 字符输出流 –》字节的输出流</p>\n<p>【3】图解：</p>\n<img data-src=\"/2022/10/07/%E7%AC%AC12%E7%AB%A0IO/image-20220618185049182.png\" class=\"\">\n\n\n<p>【4】将输入的字节流转换为输入的字符流，然后完成文件–》程序 ：</p>\n<pre><code class=\"java\">public class Test01 &#123;\n    //这是一个main方法，是程序的入口：\n    public static void main(String[] args) throws IOException &#123;\n        //文件---》程序：\n        //1.有一个源文件：\n        File f = new File(&quot;d:\\\\Test.txt&quot;);\n        //2.需要一个输入的字节流接触文件：\n        FileInputStream fis = new FileInputStream(f);\n        //3.加入一个转换流，将字节流转换为字符流：（转换流属于一个处理流）\n        //将字节转换为字符的时候，需要指定一个编码，这个编码跟文件本身的编码格式统一\n        //如果编码格式不统一的话，那么在控制台上展示的效果就会出现乱码\n        //InputStreamReader isr = new InputStreamReader(fis,&quot;utf-8&quot;);\n        //获取程序本身的编码--》utf-8\n        InputStreamReader isr = new InputStreamReader(fis);\n        //4.开始动作，将文件中内容显示在控制台：\n        char[] ch = new char[20];\n        int len = isr.read(ch);\n        while(len!=-1)&#123;\n            //将缓冲数组转为字符串在控制台上打印出来\n            System.out.print(new String(ch,0,len));\n            len = isr.read(ch);\n        &#125;\n        //5.关闭流：\n        isr.close();\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"11-转换流-InputStreamReader-OutputStreamWriter实现文本文件的复制\"><a href=\"#11-转换流-InputStreamReader-OutputStreamWriter实现文本文件的复制\" class=\"headerlink\" title=\"11 转换流-InputStreamReader,OutputStreamWriter实现文本文件的复制\"></a>11 转换流-InputStreamReader,OutputStreamWriter实现文本文件的复制</h2><pre><code class=\"java\">public class Test02 &#123;\n    //这是一个main方法，是程序的入口：\n    public static void main(String[] args) throws IOException &#123;\n        //1.有一个源文件\n        File f1 = new File(&quot;d:\\\\Test.txt&quot;);\n        //2.有一个目标文件：\n        File f2 = new File(&quot;d:\\\\Demo.txt&quot;);\n        //3.输入方向：\n        FileInputStream fis = new FileInputStream(f1);\n        InputStreamReader isr = new InputStreamReader(fis,&quot;utf-8&quot;);\n        //4.输出方向：\n        FileOutputStream fos = new FileOutputStream(f2);\n        OutputStreamWriter osw = new OutputStreamWriter(fos,&quot;gbk&quot;);\n        //5.开始动作：\n        char[] ch = new char[20];\n        int len = isr.read(ch);\n        while(len!=-1)&#123;\n            osw.write(ch,0,len);\n            len = isr.read(ch);\n        &#125;\n        //6.关闭流：\n        osw.close();\n        isr.close();\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"12-System类对IO流的支持\"><a href=\"#12-System类对IO流的支持\" class=\"headerlink\" title=\"12 System类对IO流的支持\"></a>12 System类对IO流的支持</h2><p>【1】System的属性：<br>System.in  : “标准”输入流。—》默认情况下  从键盘输入<br>System.out  :“标准”输出流。 —》默认情况下，输出到控制台。</p>\n<p>【2】System.in ：“标准”输入流。—》默认情况下  从键盘输入</p>\n<pre><code class=\"java\">public class Test01 &#123;\n    //这是一个main方法，是程序的入口：\n    public static void main(String[] args) throws IOException &#123;\n        //得到的是标准的输入流：--》从键盘输入：\n        //InputStream in = System.in;\n        //调用方法：\n        //int n = in.read();//read方法等待键盘的录入，所以这个方法是一个阻塞方法。\n        //System.out.println(n);\n        //以前案例：从键盘录入一个int类型的数据：\n        //从上面的代码证明，键盘录入实际上是：System.in\n        //形象的理解：System.in管，这个管怼到键盘上去了，所以你从键盘录入的话，就从这个管到程序中了\n        //Scanner的作用：扫描器：起扫描作用的，扫键盘的从这根管出来的数据\n        /*Scanner sc = new Scanner(System.in);\n        int i = sc.nextInt();\n        System.out.println(i);*/\n        //既然Scanner是扫描的作用，不一定非得扫 System.in进来的东西，还可以扫描其他管的内容：\n        Scanner sc = new Scanner(new FileInputStream(new File(&quot;d:\\\\Test.txt&quot;)));\n        while(sc.hasNext())&#123;\n            System.out.println(sc.next());\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>【3】System.out  : 返回的输出流 、 打印流（PrintStream）</p>\n<pre><code class=\"java\">public class Test02 &#123;\n    //这是一个main方法，是程序的入口：\n    public static void main(String[] args) &#123;\n        //写到控制台：\n        PrintStream out = System.out;\n        //调用方法：\n        out.print(&quot;你好1&quot;);//直接在控制台写出，但是不换行\n        out.print(&quot;你好2&quot;);\n        out.print(&quot;你好3&quot;);\n        out.print(&quot;你好4&quot;);\n        out.println(&quot;我是中国人1&quot;);//直接在控制台写出，并且换行操作\n        out.println(&quot;我是中国人2&quot;);\n        out.println(&quot;我是中国人3&quot;);\n        out.println(&quot;我是中国人4&quot;);\n        System.out.println(&quot;你是&quot;);\n        System.out.print(&quot;中国人&quot;);\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"13-练习：键盘录入内容输出到文件中\"><a href=\"#13-练习：键盘录入内容输出到文件中\" class=\"headerlink\" title=\"13 练习：键盘录入内容输出到文件中\"></a>13 练习：键盘录入内容输出到文件中</h2><p>【1】解决思路：</p>\n<img data-src=\"/2022/10/07/%E7%AC%AC12%E7%AB%A0IO/image-20220618185310964.png\" class=\"\">\n\n\n<p>【2】代码：</p>\n<pre><code class=\"java\">public class Test03 &#123;\n    //这是一个main方法，是程序的入口：\n    public static void main(String[] args) throws IOException &#123;\n        //1.先准备输入方向：\n        //键盘录入：\n        InputStream in = System.in;//属于字节流\n        //字节流--》字符流：\n        InputStreamReader isr = new InputStreamReader(in);\n        //在isr外面再套一个缓冲流：\n        BufferedReader br = new BufferedReader(isr);\n        //2.再准备输出方向：\n        //准备目标文件\n        File f = new File(&quot;d:\\\\Demo1.txt&quot;);\n        FileWriter fw = new FileWriter(f);\n        BufferedWriter bw = new BufferedWriter(fw);\n        //3.开始动作：\n        String s = br.readLine();\n        while(!s.equals(&quot;exit&quot;))&#123;\n            bw.write(s);\n            bw.newLine();//文件中换行\n            s = br.readLine();\n        &#125;\n        //4.关闭流：\n        bw.close();\n        br.close();\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"14-数据流-DataInputStream-DataOutputStream\"><a href=\"#14-数据流-DataInputStream-DataOutputStream\" class=\"headerlink\" title=\"14 数据流-DataInputStream,DataOutputStream\"></a>14 数据流-DataInputStream,DataOutputStream</h2><p>【1】数据流：用来操作基本数据类型和字符串的<br>【2】<br>DataInputStream:将文件中存储的基本数据类型和字符串  写入  内存的变量中<br>DataOutputStream:  将内存中的基本数据类型和字符串的变量 写出  文件中</p>\n<p>【3】代码：</p>\n<p>利用DataOutputStream向外写出变量：</p>\n<pre><code class=\"java\">public class Test01 &#123;\n    //这是一个main方法，是程序的入口：\n    public static void main(String[] args) throws IOException &#123;\n        //DataOutputStream:  将内存中的基本数据类型和字符串的变量 写出  文件中\n        /*File f = new File(&quot;d:\\\\Demo2.txt&quot;);\n        FileOutputStream fos = new FileOutputStream(f);\n        DataOutputStream dos = new DataOutputStream(fos);*/\n        DataOutputStream dos = new DataOutputStream(new FileOutputStream(new File(&quot;d:\\\\Demo2.txt&quot;)));\n        //向外将变量写到文件中去：\n        dos.writeUTF(&quot;你好&quot;);\n        dos.writeBoolean(false);\n        dos.writeDouble(6.9);\n        dos.writeInt(82);\n        //关闭流：\n        dos.close();\n    &#125;\n&#125;\n</code></pre>\n<p>在Demo2.txt文件中，我们看到：</p>\n<img data-src=\"/2022/10/07/%E7%AC%AC12%E7%AB%A0IO/image-20220618185411994.png\" class=\"\">\n\n\n\n\n\n<p>发现：这个内容我们看不懂，是给程序看的</p>\n<p>所以下面我们开始读取的程序：</p>\n<pre><code class=\"java\">public class Test02 &#123;\n    //这是一个main方法，是程序的入口：\n    public static void main(String[] args) throws IOException &#123;\n        //DataInputStream:将文件中存储的基本数据类型和字符串  写入  内存的变量中\n        DataInputStream dis = new DataInputStream(new FileInputStream(new File(&quot;d:\\\\Demo2.txt&quot;)));\n        //将文件中内容读取到程序中来：\n        System.out.println(dis.readUTF());\n        System.out.println(dis.readBoolean());\n        System.out.println(dis.readDouble());\n        System.out.println(dis.readInt());\n        //关闭流：\n        dis.close();\n    &#125;\n&#125;\n</code></pre>\n<img data-src=\"/2022/10/07/%E7%AC%AC12%E7%AB%A0IO/image-20220618185431650.png\" class=\"\">\n\n\n<p>验证：那个文件，我们看不懂，程序看得懂<br>要求：<br>写出的类型跟读入的类型 必须 要匹配！</p>\n<h2 id=\"15-对象流-ObjectInputStream-ObjectOutputStream\"><a href=\"#15-对象流-ObjectInputStream-ObjectOutputStream\" class=\"headerlink\" title=\"15 对象流-ObjectInputStream,ObjectOutputStream\"></a>15 对象流-ObjectInputStream,ObjectOutputStream</h2><p>【1】对象流：ObjectInputStream，ObjectInputStream<br>用于存储和读取基本数据类型数据或对象的处理流。<br>它的强大之处就是可以把Java中的对象写入到数据源中，也能把对象从数据源中还原回来。</p>\n<p>【2】序列化和反序列化：<br>ObjectOutputStream 类 ： 把内存中的Java对象转换成平台无关的二进制数据，从而允许把这种二进制数据持久地保存在磁盘上，或通过网络将这种二进制数据传输到另一个网络节点。—-》序列化<br>用ObjectInputStream类 ： 当其它程序获取了这种二进制数据，就可以恢复成原来的Java对象。—-》反序列化</p>\n<p>【3】代码：操作字符串对象：<br>首先将一个字符串对象写到文件中去：—-》序列化</p>\n<pre><code class=\"java\">public class Test01 &#123;\n    //这是一个main方法，是程序的入口：\n    public static void main(String[] args) throws IOException &#123;\n        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(new File(&quot;d:\\\\Demo3.txt&quot;)));\n        //将内存中的字符串写出到文件中：\n        oos.writeObject(&quot;你好&quot;);\n        //关闭流：\n        oos.close();\n    &#125;\n&#125;\n</code></pre>\n<p>查看文件：</p>\n<img data-src=\"/2022/10/07/%E7%AC%AC12%E7%AB%A0IO/image-20220618185509008.png\" class=\"\">\n\n\n<p>我们看不懂文件的内容，但是程序是可以看懂的，所以可以写一个程序读文件中内容：—-》反序列化</p>\n<pre><code class=\"java\">public class Test02 &#123;\n    //这是一个main方法，是程序的入口：\n    public static void main(String[] args) throws IOException, ClassNotFoundException &#123;\n        //将文件中保存的字符串 读入到 内存：\n        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(new File(&quot;d:\\\\Demo3.txt&quot;)));\n        //读取：\n        String s = (String)(ois.readObject());\n        System.out.println(s);\n        //关闭流：\n        ois.close();\n    &#125;\n&#125;\n</code></pre>\n<img data-src=\"/2022/10/07/%E7%AC%AC12%E7%AB%A0IO/image-20220618185547246.png\" class=\"\">\n\n\n<p>【4】代码：操作自定义类的对象：<br>自定义的Person类：</p>\n<pre><code class=\"java\">public class Person &#123;\n    private String name;\n    private int age;\n    public String getName() &#123;\n        return name;\n    &#125;\n    public void setName(String name) &#123;\n        this.name = name;\n    &#125;\n    public int getAge() &#123;\n        return age;\n    &#125;\n    public void setAge(int age) &#123;\n        this.age = age;\n    &#125;\n    public Person() &#123;\n    &#125;\n    public Person(String name, int age) &#123;\n        this.name = name;\n        this.age = age;\n    &#125;\n&#125;\n</code></pre>\n<p>测试类：</p>\n<pre><code class=\"java\">public class Test01 &#123;\n    //这是一个main方法，是程序的入口：\n    public static void main(String[] args) throws IOException &#123;\n        //序列化：将内存中对象 ---》 文件：\n        //有一个对象：\n        Person p = new Person(&quot;lili&quot;,19);\n        //有对象流：\n        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(new File(&quot;d:\\\\Demo4.txt&quot;)));\n        //向外写：\n        oos.writeObject(p);\n        //关闭流：\n        oos.close();\n    &#125;\n&#125;\n</code></pre>\n<p>运行的时候发现出现异常：</p>\n<img data-src=\"/2022/10/07/%E7%AC%AC12%E7%AB%A0IO/image-20220618185638520.png\" class=\"\">\n\n\n<p>出现异常的原因：</p>\n<img data-src=\"/2022/10/07/%E7%AC%AC12%E7%AB%A0IO/image-20220618185644074.png\" class=\"\">\n\n\n<p>起到标识作用，标识什么呢？只要实现这个接口的类的对象才能序列化，否则不可以。</font></p>\n<p>解决办法：将Person 实现这个标识接口就可以：</p>\n<pre><code class=\"java\">public class Person implements Serializable &#123;\n    private String name;\n    private int age;\n    public String getName() &#123;\n        return name;\n    &#125;\n    public void setName(String name) &#123;\n        this.name = name;\n    &#125;\n    public int getAge() &#123;\n        return age;\n    &#125;\n    public void setAge(int age) &#123;\n        this.age = age;\n    &#125;\n    public Person() &#123;\n    &#125;\n    public Person(String name, int age) &#123;\n        this.name = name;\n        this.age = age;\n    &#125;\n&#125;\n</code></pre>\n<p>测试：发现序列化成功，Person具备了序列化的能力。</p>\n<img data-src=\"/2022/10/07/%E7%AC%AC12%E7%AB%A0IO/image-20220618185843749.png\" class=\"\">\n\n\n<p>这个二进制数据我们看不懂，但是程序可以看懂，所以我们可以用程序实现 反序列化操作：<br>将这个对象 恢复到内存中来：</p>\n<pre><code class=\"java\">public class Test02 &#123;\n    //这是一个main方法，是程序的入口：\n    public static void main(String[] args) throws IOException, ClassNotFoundException &#123;\n        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(new File(&quot;d:\\\\Demo4.txt&quot;)));\n        //读入内存：\n        Person p = (Person)(ois.readObject());\n        System.out.println(p/*.toString()*/);\n        //关闭流：\n        ois.close();\n    &#125;\n&#125;\n</code></pre>\n<p>结果：<br>因为我们没有重写toString方法，所以结果为：</p>\n<img data-src=\"/2022/10/07/%E7%AC%AC12%E7%AB%A0IO/image-20220618185906147.png\" class=\"\">\n\n\n<p>证明了反序列化成功：   将二进制数据 –》内存</p>\n<p>【5】serialVersionUID：<br>凡是实现Serializable接口（标识接口）的类都有一个表示序列化版本标识符的静态常量:<br>➢private static final long serialVersionUID;<br>➢serialVersionUID用来表明类的不同版本间的兼容性。简言之，其目的是以序列化对象进行版本控制，有关各版本反序加化时是否兼容。<br>➢如果类没有显示定义这个静态变量，它的值是Java运行时环境根据类的内部细节自动生成的。若类的实例变量做了修改，serialVersionUID 可能发生变化。故建议，显式声明。</p>\n<p>➢简单来说，Java的序列化机制是通过在运行时判断类的serialVersionUID来验证版本一致性的。在进行反序列化时，JVM会把传来的字节流中的serialVersionUID与本地相应实体类的serialVersionUID进行比较，如果相同就认为是一致的，可以进行反序列化，否则就会出现序列化版本不一致的异常。(InvalidCastException)</p>\n<p>我现在在Person类中加入toString方法：</p>\n<pre><code class=\"java\">public class Person implements Serializable &#123;\n    private String name;\n    private int age;\n    public String getName() &#123;\n        return name;\n    &#125;\n    public void setName(String name) &#123;\n        this.name = name;\n    &#125;\n    public int getAge() &#123;\n        return age;\n    &#125;\n    public void setAge(int age) &#123;\n        this.age = age;\n    &#125;\n    public Person() &#123;\n    &#125;\n    public Person(String name, int age) &#123;\n        this.name = name;\n        this.age = age;\n    &#125;\n    @Override\n    public String toString() &#123;\n        return &quot;Person&#123;&quot; +\n                &quot;name=&#39;&quot; + name + &#39;\\&#39;&#39; +\n                &quot;, age=&quot; + age +\n                &#39;&#125;&#39;;\n    &#125;\n&#125;\n</code></pre>\n<p>再次运行测试类：<br>出现异常：</p>\n<img data-src=\"/2022/10/07/%E7%AC%AC12%E7%AB%A0IO/image-20220618193403947.png\" class=\"\">\n\n\n\n<p>出现异常的原因：</p>\n<p>解决：给这个类 加入一个 序列号：serialVersionUID</p>\n<img data-src=\"/2022/10/07/%E7%AC%AC12%E7%AB%A0IO/image-20220618193411439.png\" class=\"\">\n\n\n\n\n<p>【6】IDEA中配置序列化版本号：</p>\n<img data-src=\"/2022/10/07/%E7%AC%AC12%E7%AB%A0IO/image-20220618193419904.png\" class=\"\">\n\n\n\n\n<p>在Person类上：alt+enter:</p>\n<img data-src=\"/2022/10/07/%E7%AC%AC12%E7%AB%A0IO/image-20220618193429703.png\" class=\"\">\n\n\n<p>回车即可生成</p>\n<img data-src=\"/2022/10/07/%E7%AC%AC12%E7%AB%A0IO/image-20220618193434654.png\" class=\"\">\n\n\n<p>【7】序列化细节：<br>（1）被序列化的类的内部的所有属性，必须是可序列化的 （基本数据类型都是可序列化的）</p>\n<img data-src=\"/2022/10/07/%E7%AC%AC12%E7%AB%A0IO/image-20220618193446336.png\" class=\"\">\n\n\n\n<p>（2）static，transient修饰的属性 不可以被序列化。</p>\n<pre><code class=\"java\">public class Person implements Serializable &#123;\n    private static final long serialVersionUID = 8027651838638826533L;\n    private transient String name;\n    private static int age;\n    private Famaily f = new Famaily();\n    public String getName() &#123;\n        return name;\n    &#125;\n    public void setName(String name) &#123;\n        this.name = name;\n    &#125;\n    public int getAge() &#123;\n        return age;\n    &#125;\n    public void setAge(int age) &#123;\n        this.age = age;\n    &#125;\n    public Person() &#123;\n    &#125;\n    @Override\n    public String toString() &#123;\n        return &quot;Person&#123;&quot; +\n                &quot;name=&#39;&quot; + name + &#39;\\&#39;&#39; +\n                &quot;, f=&quot; + f + &quot;,age=&quot; + age +\n                &#39;&#125;&#39;;\n    &#125;\n&#125;\n</code></pre>\n<img data-src=\"/2022/10/07/%E7%AC%AC12%E7%AB%A0IO/image-20220618193501694.png\" class=\"\">\n\n\n\n\n",
            "tags": [
                "JavaSE"
            ]
        }
    ]
}