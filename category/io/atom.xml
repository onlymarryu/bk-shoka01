<?xml version="1.0"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>http://example.com</id>
    <title>记录“美食”每刻 • Posts by &#34;io&#34; category</title>
    <link href="http://example.com" />
    <updated>2022-10-06T16:00:00.000Z</updated>
    <category term="博客" />
    <category term="环境搭建" />
    <category term="分布式" />
    <category term="Dubbo" />
    <category term="FastDFS" />
    <category term="MySQL" />
    <category term="数据库基础" />
    <category term="数据库基本知识" />
    <category term="数据库" />
    <category term="框架" />
    <category term="ORM" />
    <category term="RPC" />
    <category term="中间件" />
    <category term="RabbitMQ" />
    <category term="Solr" />
    <category term="快速搜索" />
    <category term="Redis基础" />
    <category term="NoSQL数据库" />
    <category term="Spring" />
    <category term="SpringBoot" />
    <category term="SpringMVC" />
    <category term="SpringSecurity" />
    <category term="JavaSE" />
    <category term="-JavaSE" />
    <entry>
        <id>http://example.com/2022/10/07/%E7%AC%AC12%E7%AB%A0IO/</id>
        <title>第12章IO</title>
        <link rel="alternate" href="http://example.com/2022/10/07/%E7%AC%AC12%E7%AB%A0IO/"/>
        <content type="html">&lt;h1 id=&#34;12-IO流&#34;&gt;&lt;a href=&#34;#12-IO流&#34; class=&#34;headerlink&#34; title=&#34;12 IO流&#34;&gt;&lt;/a&gt;12 IO流&lt;/h1&gt;&lt;h1 id=&#34;File类&#34;&gt;&lt;a href=&#34;#File类&#34; class=&#34;headerlink&#34; title=&#34;File类&#34;&gt;&lt;/a&gt;File类&lt;/h1&gt;&lt;h2 id=&#34;1-对文件进行操作&#34;&gt;&lt;a href=&#34;#1-对文件进行操作&#34; class=&#34;headerlink&#34; title=&#34;1 对文件进行操作&#34;&gt;&lt;/a&gt;1 对文件进行操作&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;public class Test01 &amp;#123;
    //这是一个main方法，是程序的入口：
    public static void main(String[] args) throws IOException &amp;#123;
        //将文件封装为一个File类的对象：
        File f = new File(&amp;quot;d:\\test.txt&amp;quot;);
        File f1 = new File(&amp;quot;d:\\test.txt&amp;quot;);
        File f2 = new File(&amp;quot;d:/test.txt&amp;quot;);
        //File.separator属性帮我们获取当前操作系统的路径拼接符号
       //在windows，dos下，系统默认用“\”作为路径分隔符 ，在unix，url中，使用“/”作为路径分隔符。
        File f3 = new File(&amp;quot;d:&amp;quot;+File.separator+&amp;quot;test.txt&amp;quot;);//建议使用这种
        //常用方法：
        System.out.println(&amp;quot;文件是否可读：&amp;quot;+f.canRead());
        System.out.println(&amp;quot;文件是否可写：&amp;quot;+f.canWrite());
        System.out.println(&amp;quot;文件的名字：&amp;quot;+f.getName());
        System.out.println(&amp;quot;上级目录：&amp;quot;+f.getParent());
        System.out.println(&amp;quot;是否是一个目录：&amp;quot;+f.isDirectory());
        System.out.println(&amp;quot;是否是一个文件：&amp;quot;+f.isFile());
        System.out.println(&amp;quot;是否隐藏：&amp;quot;+f.isHidden());
        System.out.println(&amp;quot;文件的大小：&amp;quot;+f.length());
        System.out.println(&amp;quot;是否存在：&amp;quot;+f.exists());
        /*if(f.exists())&amp;#123;//如果文件存在，将文件删除操作
            f.delete();
        &amp;#125;else&amp;#123;//如果不存在，就创建这个文件
            f.createNewFile();
        &amp;#125;*/
        System.out.println(f == f1);//比较两个对象的地址
        System.out.println(f.equals(f1));//比较两个对象对应的文件的路径
        //跟路径相关的：
        System.out.println(&amp;quot;绝对路径：&amp;quot;+f.getAbsolutePath());
        System.out.println(&amp;quot;相对路径：&amp;quot;+f.getPath());
        System.out.println(&amp;quot;toString:&amp;quot;+f.toString());
        System.out.println(&amp;quot;----------------------&amp;quot;);
        File f5 = new File(&amp;quot;demo.txt&amp;quot;);
        if(!f5.exists())&amp;#123;
            f5.createNewFile();
        &amp;#125;
        //绝对路径指的就是：真实的一个精准的，完整的路径
        System.out.println(&amp;quot;绝对路径：&amp;quot;+f5.getAbsolutePath());
        //相对路径：有一个参照物，相对这个参照物的路径。
        //在main方法中，相对位置指的就是：D:\IDEA_workspace\TestJavaSE
        //在junit的测试方法中，相对路径指的就是模块位置
        System.out.println(&amp;quot;相对路径：&amp;quot;+f5.getPath());
        //toString的效果永远是  相对路径
        System.out.println(&amp;quot;toString:&amp;quot;+f5.toString());
        File f6 = new File(&amp;quot;a/b/c/demo.txt&amp;quot;);
        if(!f5.exists())&amp;#123;
            f5.createNewFile();
        &amp;#125;
        System.out.println(&amp;quot;绝对路径：&amp;quot;+f6.getAbsolutePath());
        System.out.println(&amp;quot;相对路径：&amp;quot;+f6.getPath());
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;2-对目录进行操作&#34;&gt;&lt;a href=&#34;#2-对目录进行操作&#34; class=&#34;headerlink&#34; title=&#34;2 对目录进行操作&#34;&gt;&lt;/a&gt;2 对目录进行操作&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;public class Test02 &amp;#123;
    //这是一个main方法，是程序的入口：
    public static void main(String[] args) &amp;#123;
        //将目录封装为File类的对象：
        File f = new File(&amp;quot;D:\\IDEA_workspace&amp;quot;);
        System.out.println(&amp;quot;文件是否可读：&amp;quot;+f.canRead());
        System.out.println(&amp;quot;文件是否可写：&amp;quot;+f.canWrite());
        System.out.println(&amp;quot;文件的名字：&amp;quot;+f.getName());
        System.out.println(&amp;quot;上级目录：&amp;quot;+f.getParent());
        System.out.println(&amp;quot;是否是一个目录：&amp;quot;+f.isDirectory());
        System.out.println(&amp;quot;是否是一个文件：&amp;quot;+f.isFile());
        System.out.println(&amp;quot;是否隐藏：&amp;quot;+f.isHidden());
        System.out.println(&amp;quot;文件的大小：&amp;quot;+f.length());
        System.out.println(&amp;quot;是否存在：&amp;quot;+f.exists());
        System.out.println(&amp;quot;绝对路径：&amp;quot;+f.getAbsolutePath());
        System.out.println(&amp;quot;相对路径：&amp;quot;+f.getPath());
        System.out.println(&amp;quot;toString:&amp;quot;+f.toString());
        //跟目录相关的方法：
        File f2 = new File(&amp;quot;D:\\a\\b\\c&amp;quot;);
        //创建目录：
        //f2.mkdir();//创建单层目录
        //f2.mkdirs();//创建多层目录
        //删除：如果是删除目录的话，只会删除一层，并且前提：这层目录是空的，里面没有内容，如果内容就不会被删除
        f2.delete();
        //查看：
        String[] list = f.list();//文件夹下目录/文件对应的名字的数组
        for(String s:list)&amp;#123;
            System.out.println(s);
        &amp;#125;
        System.out.println(&amp;quot;=========================&amp;quot;);
        File[] files = f.listFiles();//作用更加广泛
        for(File file:files)&amp;#123;
            System.out.println(file.getName()+&amp;quot;,&amp;quot;+file.getAbsolutePath());
        &amp;#125;
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;IO流&#34;&gt;&lt;a href=&#34;#IO流&#34; class=&#34;headerlink&#34; title=&#34;IO流&#34;&gt;&lt;/a&gt;IO流&lt;/h1&gt;&lt;h2 id=&#34;1-引入&#34;&gt;&lt;a href=&#34;#1-引入&#34; class=&#34;headerlink&#34; title=&#34;1 引入&#34;&gt;&lt;/a&gt;1 引入&lt;/h2&gt;&lt;p&gt;【1】File类：封装文件&amp;#x2F;目录的各种信息，对目录&amp;#x2F;文件进行操作，但是我们不可以获取到文件&amp;#x2F;目录中的内容。&lt;br&gt;【2】引入：IO流：&lt;br&gt;I&amp;#x2F;O ： Input&amp;#x2F;Output的缩写，用于处理设备之间的数据的传输。&lt;br&gt;【3】形象理解：IO流 当做一根 “管”：&lt;/p&gt;
&lt;img data-src=&#34;/2022/10/07/%E7%AC%AC12%E7%AB%A0IO/image-20220618184436805.png&#34; class=&#34;&#34;&gt;





&lt;p&gt;【4】IO流的体系结构：&lt;/p&gt;
&lt;img data-src=&#34;/2022/10/07/%E7%AC%AC12%E7%AB%A0IO/image-20220618184443031.png&#34; class=&#34;&#34;&gt;






&lt;h2 id=&#34;2-案例：通过java程序完成文件的复制操作&#34;&gt;&lt;a href=&#34;#2-案例：通过java程序完成文件的复制操作&#34; class=&#34;headerlink&#34; title=&#34;2 案例：通过java程序完成文件的复制操作&#34;&gt;&lt;/a&gt;2 案例：通过java程序完成文件的复制操作&lt;/h2&gt;&lt;h3 id=&#34;功能分解1：文件–》程序：FileReader&#34;&gt;&lt;a href=&#34;#功能分解1：文件–》程序：FileReader&#34; class=&#34;headerlink&#34; title=&#34;功能分解1：文件–》程序：FileReader&#34;&gt;&lt;/a&gt;功能分解1：文件–》程序：FileReader&lt;/h3&gt;&lt;p&gt;一个字符一个字符的将文件中的内容读取到程序中了：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;public class Test01 &amp;#123;
    //这是一个main方法，是程序的入口：
    public static void main(String[] args) throws IOException &amp;#123;
        //文件--》程序：
        //1.有一个文件：----》创建一个File类的对象
        File f = new File(&amp;quot;d:\\Test.txt&amp;quot;);
        //2.利用FileReader这个流，这个“管”怼到源文件上去   ---》创建一个FileReader的流的对象
        FileReader fr = new FileReader(f);
        //3.进行操作“吸”的动作  ---》读取动作
        /*下面的代码我们验证了：如果到了文件的结尾处，那么读取的内容为-1
        int n1 = fr.read();
        int n2 = fr.read();
        int n3 = fr.read();
        int n4 = fr.read();
        int n5 = fr.read();
        int n6 = fr.read();
        System.out.println(n1);
        System.out.println(n2);
        System.out.println(n3);
        System.out.println(n4);
        System.out.println(n5);
        System.out.println(n6);*/
        //方式1：
        /*int n = fr.read();
        while(n!=-1)&amp;#123;
            System.out.println(n);
            n = fr.read();
        &amp;#125;*/
        //方式2：
        int n;
        while((n = fr.read())!=-1)&amp;#123;
            System.out.println((char)n);
        &amp;#125;
        //4.“管”不用了，就要关闭  ---》关闭流
        //流，数据库，网络资源，靠jvm本身没有办法帮我们关闭，此时必须程序员手动关闭：
        fr.close();
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;想一次性读取五个字符，不够的话下次再读五个字符：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;public class Test02 &amp;#123;
    //这是一个main方法，是程序的入口：
    public static void main(String[] args) throws IOException &amp;#123;
        //文件--》程序：
        //1.创建一个File类的对象
        File f = new File(&amp;quot;d:\\Test.txt&amp;quot;);
        //2.创建一个FileReader的流的对象
        FileReader fr = new FileReader(f);
        //3.读取动作
        //引入一个“快递员的小车”，这个“小车”一次拉5个快递：
        char[] ch = new char[5];//缓冲数组
        int len = fr.read(ch);//一次读取五个:返回值是这个数组中 的有效长度
        while(len!=-1)&amp;#123;
            //System.out.println(len);
            //错误方式：
            /*for (int i = 0 ;i &amp;lt; ch.length;i++)&amp;#123;
                System.out.println(ch[i]);
            &amp;#125;*/
            //正确方式：
            /*for (int i = 0 ;i &amp;lt; len;i++)&amp;#123;
                System.out.println(ch[i]);
            &amp;#125;*/
            //正确方式2：将数组转为String：
            String str = new String(ch,0,len);
            System.out.print(str);
            len = fr.read(ch);
        &amp;#125;
        //4.关闭流
        fr.close();
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;功能分解2：程序–》文件：FileWriter&#34;&gt;&lt;a href=&#34;#功能分解2：程序–》文件：FileWriter&#34; class=&#34;headerlink&#34; title=&#34;功能分解2：程序–》文件：FileWriter&#34;&gt;&lt;/a&gt;功能分解2：程序–》文件：FileWriter&lt;/h3&gt;&lt;p&gt;一个字符一个字符的向外输出：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;public class Test03 &amp;#123;
    //这是一个main方法，是程序的入口：
    public static void main(String[] args) throws IOException &amp;#123;
        //1.有个目标文件：
        File f = new File(&amp;quot;d:\\demo.txt&amp;quot;);
        //2.FileWriter管怼到文件上去：
        FileWriter fw = new FileWriter(f);
        //3.开始动作：输出动作：
        //一个字符一个字符的往外输出：
        String str = &amp;quot;hello你好&amp;quot;;
        for (int i = 0 ;i &amp;lt; str.length();i++)&amp;#123;
            fw.write(str.charAt(i));
        &amp;#125;
        //4.关闭流：
        fw.close();
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;发现：&lt;br&gt;如果目标文件不存在的话，那么会自动创建此文件。&lt;br&gt;如果目标文件存在的话：&lt;br&gt;new FileWriter(f)   相当于对原文件进行覆盖操作。&lt;br&gt;new FileWriter(f,false)  相当于对源文件进行覆盖操作。不是追加。&lt;br&gt;new FileWriter(f,true)   对原来的文件进行追加，而不是覆盖。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;利用缓冲数组：向外输出（利用缓冲数组：）&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;public class Test03 &amp;#123;
    //这是一个main方法，是程序的入口：
    public static void main(String[] args) throws IOException &amp;#123;
        //1.有个目标文件：
        File f = new File(&amp;quot;d:\\demo.txt&amp;quot;);
        //2.FileWriter管怼到文件上去：
        FileWriter fw = new FileWriter(f,true);
        //3.开始动作：输出动作：
        //一个字符一个字符的往外输出：
        String str = &amp;quot;你好中国&amp;quot;;
        char[] chars = str.toCharArray();
        fw.write(chars);
        //4.关闭流：
        fw.close();
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;功能分解3：利用FileReader，FileWriter文件复制&#34;&gt;&lt;a href=&#34;#功能分解3：利用FileReader，FileWriter文件复制&#34; class=&#34;headerlink&#34; title=&#34;功能分解3：利用FileReader，FileWriter文件复制&#34;&gt;&lt;/a&gt;功能分解3：利用FileReader，FileWriter文件复制&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;public class Test04 &amp;#123;
    //这是一个main方法，是程序的入口：
    public static void main(String[] args) throws IOException &amp;#123;
        //1.有一个源文件
        File f1 = new File(&amp;quot;d:\\Test.txt&amp;quot;);
        //2.有一个目标文件：
        File f2 = new File(&amp;quot;d:\\Demo.txt&amp;quot;);
        //3.搞一个输入的管 怼到源文件上：
        FileReader fr = new FileReader(f1);
        //4.搞一个输出的管，怼到目标文件上：
        FileWriter fw = new FileWriter(f2);
        //5.开始动作：
        //方式1：一个字符一个字符的复制：
        /*int n = fr.read();
        while(n!=-1)&amp;#123;
            fw.write(n);
            n = fr.read();
        &amp;#125;*/
        //方式2：利用缓冲字符数组：
        /*char[] ch = new char[5];
        int len = fr.read(ch);
        while(len!=-1)&amp;#123;
            fw.write(ch,0,len);//将缓冲数组中有效长度写出
            len = fr.read(ch);
        &amp;#125;*/
        //方式3：利用缓冲字符数组，将数组转为String写出。
        char[] ch = new char[5];
        int len = fr.read(ch);
        while(len!=-1)&amp;#123;
            String s = new String(ch,0,len);
            fw.write(s);
            len = fr.read(ch);
        &amp;#125;
        //6.关闭流：(关闭流的时候，倒着关闭，后用先关)
        fw.close();
        fr.close();
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;3-警告：不要用字符流去操作非文本文件&#34;&gt;&lt;a href=&#34;#3-警告：不要用字符流去操作非文本文件&#34; class=&#34;headerlink&#34; title=&#34;3 警告：不要用字符流去操作非文本文件&#34;&gt;&lt;/a&gt;3 警告：不要用字符流去操作非文本文件&lt;/h2&gt;&lt;p&gt;文本文件：.txt   .java  .c  .cpp  —》建议使用字符流操作&lt;br&gt;非文本文件：.jpg,  .mp3  ,   .mp4 , .doc  , .ppt  —》建议使用字节流操作&lt;/p&gt;
&lt;h2 id=&#34;4-用try-catch-finally处理异常方式&#34;&gt;&lt;a href=&#34;#4-用try-catch-finally处理异常方式&#34; class=&#34;headerlink&#34; title=&#34;4 用try-catch-finally处理异常方式&#34;&gt;&lt;/a&gt;4 用try-catch-finally处理异常方式&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;public class Test04 &amp;#123;
    //这是一个main方法，是程序的入口：
    public static void main(String[] args)  &amp;#123;
        //1.有一个源文件
        File f1 = new File(&amp;quot;d:\\Test.txt&amp;quot;);
        //2.有一个目标文件：
        File f2 = new File(&amp;quot;d:\\Demo.txt&amp;quot;);
        //3.搞一个输入的管 怼到源文件上：
        FileReader fr = null;
        FileWriter fw = null;
        try &amp;#123;
            fr = new FileReader(f1);
            //4.搞一个输出的管，怼到目标文件上：
            fw = new FileWriter(f2);
            //5.开始动作：
            char[] ch = new char[5];
            int len = fr.read(ch);
            while(len!=-1)&amp;#123;
                String s = new String(ch,0,len);
                fw.write(s);
                len = fr.read(ch);
            &amp;#125;
        &amp;#125; catch (FileNotFoundException e) &amp;#123;
            e.printStackTrace();
        &amp;#125; catch (IOException e) &amp;#123;
            e.printStackTrace();
        &amp;#125; finally &amp;#123;
            //6.关闭流：(关闭流的时候，倒着关闭，后用先关)
            try &amp;#123;
                if(fw!=null)&amp;#123;//防止空指针异常
                    fw.close();
                &amp;#125;
            &amp;#125; catch (IOException e) &amp;#123;
                e.printStackTrace();
            &amp;#125;
            try &amp;#123;
                if(fr!=null)&amp;#123;
                    fr.close();
                &amp;#125;
            &amp;#125; catch (IOException e) &amp;#123;
                e.printStackTrace();
            &amp;#125;
        &amp;#125;
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;5-FileInputStream读取文件中内容&#34;&gt;&lt;a href=&#34;#5-FileInputStream读取文件中内容&#34; class=&#34;headerlink&#34; title=&#34;5 FileInputStream读取文件中内容&#34;&gt;&lt;/a&gt;5 FileInputStream读取文件中内容&lt;/h2&gt;&lt;p&gt;【1】读取文本文件：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;public class Test01 &amp;#123;
    //这是一个main方法，是程序的入口：
    public static void main(String[] args) throws IOException &amp;#123;
        //功能：利用字节流将文件中内容读到程序中来：
        //1.有一个源文件：
        File f = new File(&amp;quot;D:\\Test.txt&amp;quot;);
        //2.将一个字节流这个管 怼  到 源文件上：
        FileInputStream fis = new FileInputStream(f);
        //3.开始读取动作
        /*
        细节1：
        文件是utf-8进行存储的，所以英文字符 底层实际占用1个字节
        但是中文字符，底层实际占用3个字节。
        细节2：
        如果文件是文本文件，那么就不要使用字节流读取了，建议使用字符流。
        细节3：
        read()读取一个字节，但是你有没有发现返回值是 int类型，而不是byte类型？
        read方法底层做了处理，让返回的数据都是“正数”
        就是为了避免如果字节返回的是-1的话，那到底是读入的字节，还是到文件结尾呢。
         */
        int n = fis.read();
        while(n!=-1)&amp;#123;
            System.out.println(n);
            n = fis.read();
        &amp;#125;
        //4.关闭流：
        fis.close();
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;【2】利用字节流读取非文本文件：（以图片为案例：）–》一个字节一个字节的读取：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;public class Test02 &amp;#123;
    //这是一个main方法，是程序的入口：
    public static void main(String[] args) throws IOException &amp;#123;
        //功能：利用字节流将文件中内容读到程序中来：
        //1.有一个源文件：
        File f = new File(&amp;quot;D:\\LOL.jpg&amp;quot;);
        //2.将一个字节流这个管 怼  到 源文件上：
        FileInputStream fis = new FileInputStream(f);
        //3.开始读取动作
        int count = 0;//定义一个计数器，用来计读入的字节的个数
        int n = fis.read();
        while(n!=-1)&amp;#123;
            count++;
            System.out.println(n);
            n = fis.read();
        &amp;#125;
        System.out.println(&amp;quot;count=&amp;quot;+count);
        //4.关闭流：
        fis.close();
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;【3】利用字节类型的缓冲数组：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;public class Test03 &amp;#123;
    //这是一个main方法，是程序的入口：
    public static void main(String[] args) throws IOException &amp;#123;
        //功能：利用字节流将文件中内容读到程序中来：
        //1.有一个源文件：
        File f = new File(&amp;quot;D:\\LOL.jpg&amp;quot;);
        //2.将一个字节流这个管 怼  到 源文件上：
        FileInputStream fis = new FileInputStream(f);
        //3.开始读取动作
        //利用缓冲数组：（快递员的小车）
        byte[] b = new byte[1024*6];
        int len = fis.read(b);//len指的就是读取的数组中的有效长度
        while(len!=-1)&amp;#123;
            //System.out.println(len);
            for(int i = 0;i&amp;lt;len;i++)&amp;#123;
                System.out.println(b[i]);
            &amp;#125;
            len = fis.read(b);
        &amp;#125;
        //4.关闭流：
        fis.close();
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;6-FileInputStream-FileOutputStream完成非文本文件的复制&#34;&gt;&lt;a href=&#34;#6-FileInputStream-FileOutputStream完成非文本文件的复制&#34; class=&#34;headerlink&#34; title=&#34;6 FileInputStream,FileOutputStream完成非文本文件的复制&#34;&gt;&lt;/a&gt;6 FileInputStream,FileOutputStream完成非文本文件的复制&lt;/h2&gt;&lt;p&gt;【1】读入一个字节，写出一个字节：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;public class Test04 &amp;#123;
    //这是一个main方法，是程序的入口：
    public static void main(String[] args) throws IOException &amp;#123;
        //功能：完成图片的复制：
        //1.有一个源图片
        File f1 = new File(&amp;quot;d:\\LOL.jpg&amp;quot;);
        //2.有一个目标图片：
        File f2 = new File(&amp;quot;d:\\LOL2.jpg&amp;quot;);
        //3.有一个输入的管道 怼 到 源文件：
        FileInputStream fis = new FileInputStream(f1);
        //4.有一个输出的管道 怼到  目标文件上：
        FileOutputStream fos = new FileOutputStream(f2);
        //5.开始复制：（边读边写）
        int n = fis.read();
        while(n!=-1)&amp;#123;
            fos.write(n);
            n = fis.read();
        &amp;#125;
        //6.关闭流：(倒着关闭流，先用后关)
        fos.close();
        fis.close();
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;【2】利用缓冲字节数组：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;public class Test05 &amp;#123;
    //这是一个main方法，是程序的入口：
    public static void main(String[] args) throws IOException &amp;#123;
        //功能：完成图片的复制：
        //1.有一个源图片
        File f1 = new File(&amp;quot;d:\\LOL.jpg&amp;quot;);
        //2.有一个目标图片：
        File f2 = new File(&amp;quot;d:\\LOL2.jpg&amp;quot;);
        //3.有一个输入的管道 怼 到 源文件：
        FileInputStream fis = new FileInputStream(f1);
        //4.有一个输出的管道 怼到  目标文件上：
        FileOutputStream fos = new FileOutputStream(f2);
        //5.开始复制：（边读边写）
        //利用缓冲数组：
        byte[] b = new byte[1024*8];
        int len = fis.read(b);
        while(len!=-1)&amp;#123;
            fos.write(b,0,len);
            len = fis.read(b);
        &amp;#125;
        //6.关闭流：(倒着关闭流，先用后关)
        fos.close();
        fis.close();
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;7-缓冲字节流-处理流-BufferedInputStream-BufferedOutputStream&#34;&gt;&lt;a href=&#34;#7-缓冲字节流-处理流-BufferedInputStream-BufferedOutputStream&#34; class=&#34;headerlink&#34; title=&#34;7 缓冲字节流(处理流)-BufferedInputStream ,BufferedOutputStream&#34;&gt;&lt;/a&gt;7 缓冲字节流(处理流)-BufferedInputStream ,BufferedOutputStream&lt;/h2&gt;&lt;p&gt;【1】读入一个字节，写出一个字节：&lt;/p&gt;
&lt;p&gt;【2】利用缓冲字节数组：&lt;/p&gt;
&lt;p&gt;【3】利用缓冲区：&lt;/p&gt;
&lt;p&gt;想要完成上面的效果，单纯的靠FileInputStream,FileOutputStream是不可以完成的，这个时候就需要功能的加强，&lt;br&gt;这个加强就需要引入新的流（在FileInputStream,FileOutputStream外面再套一层流）：BufferedInputStream ,BufferedOutputStream. —–&amp;gt;处理流&lt;/p&gt;
&lt;p&gt;代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;public class Test06 &amp;#123;
    //这是一个main方法，是程序的入口：
    public static void main(String[] args) throws IOException &amp;#123;
        //1.有一个源图片
        File f1 = new File(&amp;quot;d:\\LOL.jpg&amp;quot;);
        //2.有一个目标图片：
        File f2 = new File(&amp;quot;d:\\LOL2.jpg&amp;quot;);
        //3.有一个输入的管道 怼 到 源文件：
        FileInputStream fis = new FileInputStream(f1);
        //4.有一个输出的管道 怼到  目标文件上：
        FileOutputStream fos = new FileOutputStream(f2);
        //5.功能加强，在FileInputStream外面套一个管：BufferedInputStream:
        BufferedInputStream bis = new BufferedInputStream(fis);
        //6.功能加强，在FileOutputStream外面套一个管：BufferedOutputStream:
        BufferedOutputStream bos = new BufferedOutputStream(fos);
        //7.开始动作 ：
        byte[] b = new byte[1024*6];
        int len = bis.read(b);
        while(len!=-1)&amp;#123;
            bos.write(b,0,len);
           /* bos.flush(); 底层已经帮我们做了刷新缓冲区的操作，不用我们手动完成：底层调用flushBuffer()*/
            len = bis.read(b);
        &amp;#125;
        //8.关闭流：
        //倒着关：
        //如果处理流包裹着节点流的话，那么其实只要关闭高级流（处理流），那么里面的字节流也会随之被关闭。
        bos.close();
        bis.close();
        /*fos.close();
        fis.close();*/
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;8-比对非文本文件复制的三种方法的效率&#34;&gt;&lt;a href=&#34;#8-比对非文本文件复制的三种方法的效率&#34; class=&#34;headerlink&#34; title=&#34;8 比对非文本文件复制的三种方法的效率&#34;&gt;&lt;/a&gt;8 比对非文本文件复制的三种方法的效率&lt;/h2&gt;&lt;p&gt;【1】读入一个字节，写出一个字节：&lt;/p&gt;
&lt;img data-src=&#34;/2022/10/07/%E7%AC%AC12%E7%AB%A0IO/image-20220618184948658.png&#34; class=&#34;&#34;&gt;


&lt;p&gt;【2】利用缓冲字节数组：&lt;/p&gt;
&lt;img data-src=&#34;/2022/10/07/%E7%AC%AC12%E7%AB%A0IO/image-20220618184953685.png&#34; class=&#34;&#34;&gt;


&lt;p&gt;【3】利用缓冲区：&lt;/p&gt;
&lt;img data-src=&#34;/2022/10/07/%E7%AC%AC12%E7%AB%A0IO/image-20220618184958715.png&#34; class=&#34;&#34;&gt;


&lt;p&gt;代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;public class Test06 &amp;#123;
    //这是一个main方法，是程序的入口：
    public static void main(String[] args) throws IOException &amp;#123;
        //1.有一个源图片
        File f1 = new File(&amp;quot;d:\\LOL.jpg&amp;quot;);
        //2.有一个目标图片：
        File f2 = new File(&amp;quot;d:\\LOL2.jpg&amp;quot;);
        //3.有一个输入的管道 怼 到 源文件：
        FileInputStream fis = new FileInputStream(f1);
        //4.有一个输出的管道 怼到  目标文件上：
        FileOutputStream fos = new FileOutputStream(f2);
        //5.功能加强，在FileInputStream外面套一个管：BufferedInputStream:
        BufferedInputStream bis = new BufferedInputStream(fis);
        //6.功能加强，在FileOutputStream外面套一个管：BufferedOutputStream:
        BufferedOutputStream bos = new BufferedOutputStream(fos);
        //7.开始动作 ：
        long startTime = System.currentTimeMillis();
        byte[] b = new byte[1024];
        int len = bis.read(b);
        while(len!=-1)&amp;#123;
            bos.write(b,0,len);
           /* bos.flush(); 底层已经帮我们做了刷新缓冲区的操作，不用我们手动完成：底层调用flushBuffer()*/
            len = bis.read(b);
        &amp;#125;
        long endTime = System.currentTimeMillis();
        System.out.println(&amp;quot;复制完成的时间为：&amp;quot;+(endTime-startTime));
        //8.关闭流：
        //倒着关：
        //如果处理流包裹着节点流的话，那么其实只要关闭高级流（处理流），那么里面的字节流也会随之被关闭。
        bos.close();
        bis.close();
        /*fos.close();
        fis.close();*/
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;9-缓冲字符流-处理流-BufferedReader-BufferedWriter完成文本文件的复制&#34;&gt;&lt;a href=&#34;#9-缓冲字符流-处理流-BufferedReader-BufferedWriter完成文本文件的复制&#34; class=&#34;headerlink&#34; title=&#34;9 缓冲字符流(处理流)-BufferedReader,BufferedWriter完成文本文件的复制&#34;&gt;&lt;/a&gt;9 缓冲字符流(处理流)-BufferedReader,BufferedWriter完成文本文件的复制&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;public class Test07 &amp;#123;
    //这是一个main方法，是程序的入口：
    public static void main(String[] args) throws IOException &amp;#123;
        //1.有一个源文件：
        File f1 = new File(&amp;quot;d:\\Test.txt&amp;quot;);
        //2.有一个目标文件：
        File f2 = new File(&amp;quot;d:\\Demo.txt&amp;quot;);
        //3.需要一个管 怼到 源文件：
        FileReader fr = new FileReader(f1);
        //4.需要一根管怼到目标文件：
        FileWriter fw = new FileWriter(f2);
        //5.套一根管在输入字符流外面：
        BufferedReader br = new BufferedReader(fr);
        //6.套一根管在输出字符流外面：
        BufferedWriter bw = new BufferedWriter(fw);
        //7.开始动作：
        //方式1：读取一个字符，输出一个字符：
        /*int n = br.read();
        while(n!=-1)&amp;#123;
            bw.write(n);
            n = br.read();
        &amp;#125;*/
        //方式2:利用缓冲数组：
        /*char[] ch = new char[30];
        int len = br.read(ch);
        while(len!=-1)&amp;#123;
            bw.write(ch,0,len);
            len = br.read(ch);
        &amp;#125;*/
        //方式3：读取String：
        String str = br.readLine();//每次读取文本文件中一行，返回字符串
        while(str!=null)&amp;#123;
            bw.write(str);
            //在文本文件中应该再写出一个换行：
            bw.newLine();//新起一行
            str = br.readLine();
        &amp;#125;
        //8.关闭流
        bw.close();
        br.close();
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;10-转换流-InputStreamReader-OutputStreamWriter&#34;&gt;&lt;a href=&#34;#10-转换流-InputStreamReader-OutputStreamWriter&#34; class=&#34;headerlink&#34; title=&#34;10 转换流-InputStreamReader,OutputStreamWriter&#34;&gt;&lt;/a&gt;10 转换流-InputStreamReader,OutputStreamWriter&lt;/h2&gt;&lt;p&gt;【1】转换流：作用：将字节流和字符流进行转换。&lt;br&gt;【2】转换流  属于 字节流还是字符流？属于字符流&lt;br&gt;InputStreamReader  ：字节输入流 —》字符的输入流&lt;br&gt;OutputStreamWriter  ： 字符输出流 –》字节的输出流&lt;/p&gt;
&lt;p&gt;【3】图解：&lt;/p&gt;
&lt;img data-src=&#34;/2022/10/07/%E7%AC%AC12%E7%AB%A0IO/image-20220618185049182.png&#34; class=&#34;&#34;&gt;


&lt;p&gt;【4】将输入的字节流转换为输入的字符流，然后完成文件–》程序 ：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;public class Test01 &amp;#123;
    //这是一个main方法，是程序的入口：
    public static void main(String[] args) throws IOException &amp;#123;
        //文件---》程序：
        //1.有一个源文件：
        File f = new File(&amp;quot;d:\\Test.txt&amp;quot;);
        //2.需要一个输入的字节流接触文件：
        FileInputStream fis = new FileInputStream(f);
        //3.加入一个转换流，将字节流转换为字符流：（转换流属于一个处理流）
        //将字节转换为字符的时候，需要指定一个编码，这个编码跟文件本身的编码格式统一
        //如果编码格式不统一的话，那么在控制台上展示的效果就会出现乱码
        //InputStreamReader isr = new InputStreamReader(fis,&amp;quot;utf-8&amp;quot;);
        //获取程序本身的编码--》utf-8
        InputStreamReader isr = new InputStreamReader(fis);
        //4.开始动作，将文件中内容显示在控制台：
        char[] ch = new char[20];
        int len = isr.read(ch);
        while(len!=-1)&amp;#123;
            //将缓冲数组转为字符串在控制台上打印出来
            System.out.print(new String(ch,0,len));
            len = isr.read(ch);
        &amp;#125;
        //5.关闭流：
        isr.close();
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;11-转换流-InputStreamReader-OutputStreamWriter实现文本文件的复制&#34;&gt;&lt;a href=&#34;#11-转换流-InputStreamReader-OutputStreamWriter实现文本文件的复制&#34; class=&#34;headerlink&#34; title=&#34;11 转换流-InputStreamReader,OutputStreamWriter实现文本文件的复制&#34;&gt;&lt;/a&gt;11 转换流-InputStreamReader,OutputStreamWriter实现文本文件的复制&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;public class Test02 &amp;#123;
    //这是一个main方法，是程序的入口：
    public static void main(String[] args) throws IOException &amp;#123;
        //1.有一个源文件
        File f1 = new File(&amp;quot;d:\\Test.txt&amp;quot;);
        //2.有一个目标文件：
        File f2 = new File(&amp;quot;d:\\Demo.txt&amp;quot;);
        //3.输入方向：
        FileInputStream fis = new FileInputStream(f1);
        InputStreamReader isr = new InputStreamReader(fis,&amp;quot;utf-8&amp;quot;);
        //4.输出方向：
        FileOutputStream fos = new FileOutputStream(f2);
        OutputStreamWriter osw = new OutputStreamWriter(fos,&amp;quot;gbk&amp;quot;);
        //5.开始动作：
        char[] ch = new char[20];
        int len = isr.read(ch);
        while(len!=-1)&amp;#123;
            osw.write(ch,0,len);
            len = isr.read(ch);
        &amp;#125;
        //6.关闭流：
        osw.close();
        isr.close();
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;12-System类对IO流的支持&#34;&gt;&lt;a href=&#34;#12-System类对IO流的支持&#34; class=&#34;headerlink&#34; title=&#34;12 System类对IO流的支持&#34;&gt;&lt;/a&gt;12 System类对IO流的支持&lt;/h2&gt;&lt;p&gt;【1】System的属性：&lt;br&gt;System.in  : “标准”输入流。—》默认情况下  从键盘输入&lt;br&gt;System.out  :“标准”输出流。 —》默认情况下，输出到控制台。&lt;/p&gt;
&lt;p&gt;【2】System.in ：“标准”输入流。—》默认情况下  从键盘输入&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;public class Test01 &amp;#123;
    //这是一个main方法，是程序的入口：
    public static void main(String[] args) throws IOException &amp;#123;
        //得到的是标准的输入流：--》从键盘输入：
        //InputStream in = System.in;
        //调用方法：
        //int n = in.read();//read方法等待键盘的录入，所以这个方法是一个阻塞方法。
        //System.out.println(n);
        //以前案例：从键盘录入一个int类型的数据：
        //从上面的代码证明，键盘录入实际上是：System.in
        //形象的理解：System.in管，这个管怼到键盘上去了，所以你从键盘录入的话，就从这个管到程序中了
        //Scanner的作用：扫描器：起扫描作用的，扫键盘的从这根管出来的数据
        /*Scanner sc = new Scanner(System.in);
        int i = sc.nextInt();
        System.out.println(i);*/
        //既然Scanner是扫描的作用，不一定非得扫 System.in进来的东西，还可以扫描其他管的内容：
        Scanner sc = new Scanner(new FileInputStream(new File(&amp;quot;d:\\Test.txt&amp;quot;)));
        while(sc.hasNext())&amp;#123;
            System.out.println(sc.next());
        &amp;#125;
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;【3】System.out  : 返回的输出流 、 打印流（PrintStream）&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;public class Test02 &amp;#123;
    //这是一个main方法，是程序的入口：
    public static void main(String[] args) &amp;#123;
        //写到控制台：
        PrintStream out = System.out;
        //调用方法：
        out.print(&amp;quot;你好1&amp;quot;);//直接在控制台写出，但是不换行
        out.print(&amp;quot;你好2&amp;quot;);
        out.print(&amp;quot;你好3&amp;quot;);
        out.print(&amp;quot;你好4&amp;quot;);
        out.println(&amp;quot;我是中国人1&amp;quot;);//直接在控制台写出，并且换行操作
        out.println(&amp;quot;我是中国人2&amp;quot;);
        out.println(&amp;quot;我是中国人3&amp;quot;);
        out.println(&amp;quot;我是中国人4&amp;quot;);
        System.out.println(&amp;quot;你是&amp;quot;);
        System.out.print(&amp;quot;中国人&amp;quot;);
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;13-练习：键盘录入内容输出到文件中&#34;&gt;&lt;a href=&#34;#13-练习：键盘录入内容输出到文件中&#34; class=&#34;headerlink&#34; title=&#34;13 练习：键盘录入内容输出到文件中&#34;&gt;&lt;/a&gt;13 练习：键盘录入内容输出到文件中&lt;/h2&gt;&lt;p&gt;【1】解决思路：&lt;/p&gt;
&lt;img data-src=&#34;/2022/10/07/%E7%AC%AC12%E7%AB%A0IO/image-20220618185310964.png&#34; class=&#34;&#34;&gt;


&lt;p&gt;【2】代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;public class Test03 &amp;#123;
    //这是一个main方法，是程序的入口：
    public static void main(String[] args) throws IOException &amp;#123;
        //1.先准备输入方向：
        //键盘录入：
        InputStream in = System.in;//属于字节流
        //字节流--》字符流：
        InputStreamReader isr = new InputStreamReader(in);
        //在isr外面再套一个缓冲流：
        BufferedReader br = new BufferedReader(isr);
        //2.再准备输出方向：
        //准备目标文件
        File f = new File(&amp;quot;d:\\Demo1.txt&amp;quot;);
        FileWriter fw = new FileWriter(f);
        BufferedWriter bw = new BufferedWriter(fw);
        //3.开始动作：
        String s = br.readLine();
        while(!s.equals(&amp;quot;exit&amp;quot;))&amp;#123;
            bw.write(s);
            bw.newLine();//文件中换行
            s = br.readLine();
        &amp;#125;
        //4.关闭流：
        bw.close();
        br.close();
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;14-数据流-DataInputStream-DataOutputStream&#34;&gt;&lt;a href=&#34;#14-数据流-DataInputStream-DataOutputStream&#34; class=&#34;headerlink&#34; title=&#34;14 数据流-DataInputStream,DataOutputStream&#34;&gt;&lt;/a&gt;14 数据流-DataInputStream,DataOutputStream&lt;/h2&gt;&lt;p&gt;【1】数据流：用来操作基本数据类型和字符串的&lt;br&gt;【2】&lt;br&gt;DataInputStream:将文件中存储的基本数据类型和字符串  写入  内存的变量中&lt;br&gt;DataOutputStream:  将内存中的基本数据类型和字符串的变量 写出  文件中&lt;/p&gt;
&lt;p&gt;【3】代码：&lt;/p&gt;
&lt;p&gt;利用DataOutputStream向外写出变量：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;public class Test01 &amp;#123;
    //这是一个main方法，是程序的入口：
    public static void main(String[] args) throws IOException &amp;#123;
        //DataOutputStream:  将内存中的基本数据类型和字符串的变量 写出  文件中
        /*File f = new File(&amp;quot;d:\\Demo2.txt&amp;quot;);
        FileOutputStream fos = new FileOutputStream(f);
        DataOutputStream dos = new DataOutputStream(fos);*/
        DataOutputStream dos = new DataOutputStream(new FileOutputStream(new File(&amp;quot;d:\\Demo2.txt&amp;quot;)));
        //向外将变量写到文件中去：
        dos.writeUTF(&amp;quot;你好&amp;quot;);
        dos.writeBoolean(false);
        dos.writeDouble(6.9);
        dos.writeInt(82);
        //关闭流：
        dos.close();
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在Demo2.txt文件中，我们看到：&lt;/p&gt;
&lt;img data-src=&#34;/2022/10/07/%E7%AC%AC12%E7%AB%A0IO/image-20220618185411994.png&#34; class=&#34;&#34;&gt;





&lt;p&gt;发现：这个内容我们看不懂，是给程序看的&lt;/p&gt;
&lt;p&gt;所以下面我们开始读取的程序：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;public class Test02 &amp;#123;
    //这是一个main方法，是程序的入口：
    public static void main(String[] args) throws IOException &amp;#123;
        //DataInputStream:将文件中存储的基本数据类型和字符串  写入  内存的变量中
        DataInputStream dis = new DataInputStream(new FileInputStream(new File(&amp;quot;d:\\Demo2.txt&amp;quot;)));
        //将文件中内容读取到程序中来：
        System.out.println(dis.readUTF());
        System.out.println(dis.readBoolean());
        System.out.println(dis.readDouble());
        System.out.println(dis.readInt());
        //关闭流：
        dis.close();
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;img data-src=&#34;/2022/10/07/%E7%AC%AC12%E7%AB%A0IO/image-20220618185431650.png&#34; class=&#34;&#34;&gt;


&lt;p&gt;验证：那个文件，我们看不懂，程序看得懂&lt;br&gt;要求：&lt;br&gt;写出的类型跟读入的类型 必须 要匹配！&lt;/p&gt;
&lt;h2 id=&#34;15-对象流-ObjectInputStream-ObjectOutputStream&#34;&gt;&lt;a href=&#34;#15-对象流-ObjectInputStream-ObjectOutputStream&#34; class=&#34;headerlink&#34; title=&#34;15 对象流-ObjectInputStream,ObjectOutputStream&#34;&gt;&lt;/a&gt;15 对象流-ObjectInputStream,ObjectOutputStream&lt;/h2&gt;&lt;p&gt;【1】对象流：ObjectInputStream，ObjectInputStream&lt;br&gt;用于存储和读取基本数据类型数据或对象的处理流。&lt;br&gt;它的强大之处就是可以把Java中的对象写入到数据源中，也能把对象从数据源中还原回来。&lt;/p&gt;
&lt;p&gt;【2】序列化和反序列化：&lt;br&gt;ObjectOutputStream 类 ： 把内存中的Java对象转换成平台无关的二进制数据，从而允许把这种二进制数据持久地保存在磁盘上，或通过网络将这种二进制数据传输到另一个网络节点。—-》序列化&lt;br&gt;用ObjectInputStream类 ： 当其它程序获取了这种二进制数据，就可以恢复成原来的Java对象。—-》反序列化&lt;/p&gt;
&lt;p&gt;【3】代码：操作字符串对象：&lt;br&gt;首先将一个字符串对象写到文件中去：—-》序列化&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;public class Test01 &amp;#123;
    //这是一个main方法，是程序的入口：
    public static void main(String[] args) throws IOException &amp;#123;
        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(new File(&amp;quot;d:\\Demo3.txt&amp;quot;)));
        //将内存中的字符串写出到文件中：
        oos.writeObject(&amp;quot;你好&amp;quot;);
        //关闭流：
        oos.close();
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;查看文件：&lt;/p&gt;
&lt;img data-src=&#34;/2022/10/07/%E7%AC%AC12%E7%AB%A0IO/image-20220618185509008.png&#34; class=&#34;&#34;&gt;


&lt;p&gt;我们看不懂文件的内容，但是程序是可以看懂的，所以可以写一个程序读文件中内容：—-》反序列化&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;public class Test02 &amp;#123;
    //这是一个main方法，是程序的入口：
    public static void main(String[] args) throws IOException, ClassNotFoundException &amp;#123;
        //将文件中保存的字符串 读入到 内存：
        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(new File(&amp;quot;d:\\Demo3.txt&amp;quot;)));
        //读取：
        String s = (String)(ois.readObject());
        System.out.println(s);
        //关闭流：
        ois.close();
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;img data-src=&#34;/2022/10/07/%E7%AC%AC12%E7%AB%A0IO/image-20220618185547246.png&#34; class=&#34;&#34;&gt;


&lt;p&gt;【4】代码：操作自定义类的对象：&lt;br&gt;自定义的Person类：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;public class Person &amp;#123;
    private String name;
    private int age;
    public String getName() &amp;#123;
        return name;
    &amp;#125;
    public void setName(String name) &amp;#123;
        this.name = name;
    &amp;#125;
    public int getAge() &amp;#123;
        return age;
    &amp;#125;
    public void setAge(int age) &amp;#123;
        this.age = age;
    &amp;#125;
    public Person() &amp;#123;
    &amp;#125;
    public Person(String name, int age) &amp;#123;
        this.name = name;
        this.age = age;
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;测试类：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;public class Test01 &amp;#123;
    //这是一个main方法，是程序的入口：
    public static void main(String[] args) throws IOException &amp;#123;
        //序列化：将内存中对象 ---》 文件：
        //有一个对象：
        Person p = new Person(&amp;quot;lili&amp;quot;,19);
        //有对象流：
        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(new File(&amp;quot;d:\\Demo4.txt&amp;quot;)));
        //向外写：
        oos.writeObject(p);
        //关闭流：
        oos.close();
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行的时候发现出现异常：&lt;/p&gt;
&lt;img data-src=&#34;/2022/10/07/%E7%AC%AC12%E7%AB%A0IO/image-20220618185638520.png&#34; class=&#34;&#34;&gt;


&lt;p&gt;出现异常的原因：&lt;/p&gt;
&lt;img data-src=&#34;/2022/10/07/%E7%AC%AC12%E7%AB%A0IO/image-20220618185644074.png&#34; class=&#34;&#34;&gt;


&lt;p&gt;起到标识作用，标识什么呢？只要实现这个接口的类的对象才能序列化，否则不可以。&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;解决办法：将Person 实现这个标识接口就可以：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;public class Person implements Serializable &amp;#123;
    private String name;
    private int age;
    public String getName() &amp;#123;
        return name;
    &amp;#125;
    public void setName(String name) &amp;#123;
        this.name = name;
    &amp;#125;
    public int getAge() &amp;#123;
        return age;
    &amp;#125;
    public void setAge(int age) &amp;#123;
        this.age = age;
    &amp;#125;
    public Person() &amp;#123;
    &amp;#125;
    public Person(String name, int age) &amp;#123;
        this.name = name;
        this.age = age;
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;测试：发现序列化成功，Person具备了序列化的能力。&lt;/p&gt;
&lt;img data-src=&#34;/2022/10/07/%E7%AC%AC12%E7%AB%A0IO/image-20220618185843749.png&#34; class=&#34;&#34;&gt;


&lt;p&gt;这个二进制数据我们看不懂，但是程序可以看懂，所以我们可以用程序实现 反序列化操作：&lt;br&gt;将这个对象 恢复到内存中来：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;public class Test02 &amp;#123;
    //这是一个main方法，是程序的入口：
    public static void main(String[] args) throws IOException, ClassNotFoundException &amp;#123;
        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(new File(&amp;quot;d:\\Demo4.txt&amp;quot;)));
        //读入内存：
        Person p = (Person)(ois.readObject());
        System.out.println(p/*.toString()*/);
        //关闭流：
        ois.close();
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;结果：&lt;br&gt;因为我们没有重写toString方法，所以结果为：&lt;/p&gt;
&lt;img data-src=&#34;/2022/10/07/%E7%AC%AC12%E7%AB%A0IO/image-20220618185906147.png&#34; class=&#34;&#34;&gt;


&lt;p&gt;证明了反序列化成功：   将二进制数据 –》内存&lt;/p&gt;
&lt;p&gt;【5】serialVersionUID：&lt;br&gt;凡是实现Serializable接口（标识接口）的类都有一个表示序列化版本标识符的静态常量:&lt;br&gt;➢private static final long serialVersionUID;&lt;br&gt;➢serialVersionUID用来表明类的不同版本间的兼容性。简言之，其目的是以序列化对象进行版本控制，有关各版本反序加化时是否兼容。&lt;br&gt;➢如果类没有显示定义这个静态变量，它的值是Java运行时环境根据类的内部细节自动生成的。若类的实例变量做了修改，serialVersionUID 可能发生变化。故建议，显式声明。&lt;/p&gt;
&lt;p&gt;➢简单来说，Java的序列化机制是通过在运行时判断类的serialVersionUID来验证版本一致性的。在进行反序列化时，JVM会把传来的字节流中的serialVersionUID与本地相应实体类的serialVersionUID进行比较，如果相同就认为是一致的，可以进行反序列化，否则就会出现序列化版本不一致的异常。(InvalidCastException)&lt;/p&gt;
&lt;p&gt;我现在在Person类中加入toString方法：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;public class Person implements Serializable &amp;#123;
    private String name;
    private int age;
    public String getName() &amp;#123;
        return name;
    &amp;#125;
    public void setName(String name) &amp;#123;
        this.name = name;
    &amp;#125;
    public int getAge() &amp;#123;
        return age;
    &amp;#125;
    public void setAge(int age) &amp;#123;
        this.age = age;
    &amp;#125;
    public Person() &amp;#123;
    &amp;#125;
    public Person(String name, int age) &amp;#123;
        this.name = name;
        this.age = age;
    &amp;#125;
    @Override
    public String toString() &amp;#123;
        return &amp;quot;Person&amp;#123;&amp;quot; +
                &amp;quot;name=&amp;#39;&amp;quot; + name + &amp;#39;\&amp;#39;&amp;#39; +
                &amp;quot;, age=&amp;quot; + age +
                &amp;#39;&amp;#125;&amp;#39;;
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;再次运行测试类：&lt;br&gt;出现异常：&lt;/p&gt;
&lt;img data-src=&#34;/2022/10/07/%E7%AC%AC12%E7%AB%A0IO/image-20220618193403947.png&#34; class=&#34;&#34;&gt;



&lt;p&gt;出现异常的原因：&lt;/p&gt;
&lt;p&gt;解决：给这个类 加入一个 序列号：serialVersionUID&lt;/p&gt;
&lt;img data-src=&#34;/2022/10/07/%E7%AC%AC12%E7%AB%A0IO/image-20220618193411439.png&#34; class=&#34;&#34;&gt;




&lt;p&gt;【6】IDEA中配置序列化版本号：&lt;/p&gt;
&lt;img data-src=&#34;/2022/10/07/%E7%AC%AC12%E7%AB%A0IO/image-20220618193419904.png&#34; class=&#34;&#34;&gt;




&lt;p&gt;在Person类上：alt+enter:&lt;/p&gt;
&lt;img data-src=&#34;/2022/10/07/%E7%AC%AC12%E7%AB%A0IO/image-20220618193429703.png&#34; class=&#34;&#34;&gt;


&lt;p&gt;回车即可生成&lt;/p&gt;
&lt;img data-src=&#34;/2022/10/07/%E7%AC%AC12%E7%AB%A0IO/image-20220618193434654.png&#34; class=&#34;&#34;&gt;


&lt;p&gt;【7】序列化细节：&lt;br&gt;（1）被序列化的类的内部的所有属性，必须是可序列化的 （基本数据类型都是可序列化的）&lt;/p&gt;
&lt;img data-src=&#34;/2022/10/07/%E7%AC%AC12%E7%AB%A0IO/image-20220618193446336.png&#34; class=&#34;&#34;&gt;



&lt;p&gt;（2）static，transient修饰的属性 不可以被序列化。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;public class Person implements Serializable &amp;#123;
    private static final long serialVersionUID = 8027651838638826533L;
    private transient String name;
    private static int age;
    private Famaily f = new Famaily();
    public String getName() &amp;#123;
        return name;
    &amp;#125;
    public void setName(String name) &amp;#123;
        this.name = name;
    &amp;#125;
    public int getAge() &amp;#123;
        return age;
    &amp;#125;
    public void setAge(int age) &amp;#123;
        this.age = age;
    &amp;#125;
    public Person() &amp;#123;
    &amp;#125;
    @Override
    public String toString() &amp;#123;
        return &amp;quot;Person&amp;#123;&amp;quot; +
                &amp;quot;name=&amp;#39;&amp;quot; + name + &amp;#39;\&amp;#39;&amp;#39; +
                &amp;quot;, f=&amp;quot; + f + &amp;quot;,age=&amp;quot; + age +
                &amp;#39;&amp;#125;&amp;#39;;
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;img data-src=&#34;/2022/10/07/%E7%AC%AC12%E7%AB%A0IO/image-20220618193501694.png&#34; class=&#34;&#34;&gt;




</content>
        <category term="JavaSE" />
        <updated>2022-10-06T16:00:00.000Z</updated>
    </entry>
</feed>
