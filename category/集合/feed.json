{
    "version": "https://jsonfeed.org/version/1",
    "title": "雾都博客 • All posts by \"集合\" category",
    "description": "记录美食每刻",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/",
            "url": "http://example.com/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/",
            "title": "第11章集合",
            "date_published": "2022-10-06T16:00:00.000Z",
            "content_html": "<h1 id=\"11-集合\"><a href=\"#11-集合\" class=\"headerlink\" title=\"11 集合\"></a>11 集合</h1><img data-src=\"/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618180112196.png\" class=\"\">\n\n\n\n\n<img data-src=\"/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618170703735.png\" class=\"\">\n\n\n\n\n<h1 id=\"Colletion接口\"><a href=\"#Colletion接口\" class=\"headerlink\" title=\"Colletion接口\"></a>Colletion接口</h1><h2 id=\"1-1-常用方法\"><a href=\"#1-1-常用方法\" class=\"headerlink\" title=\"1.1 常用方法\"></a>1.1 常用方法</h2><pre><code class=\"java\">package com.msb.test01;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.List;\n/**\n * @author : msb-zhaoss\n */\npublic class Test01 &#123;\n    //这是main方法，程序的入口\n    public static void main(String[] args) &#123;\n        /*\n        Collection接口的常用方法：\n        增加：add(E e) addAll(Collection&lt;? extends E&gt; c)\n        删除：clear() remove(Object o)\n        修改：\n        查看：iterator() size()\n        判断：contains(Object o)  equals(Object o) isEmpty()\n         */\n        //创建对象：接口不能创建对象，利用实现类创建对象：\n        Collection col = new ArrayList();\n        //调用方法：\n        //集合有一个特点：只能存放引用数据类型的数据，不能是基本数据类型\n        //基本数据类型自动装箱，对应包装类。int---&gt;Integer\n        col.add(18);\n        col.add(12);\n        col.add(11);\n        col.add(17);\n        System.out.println(col/*.toString()*/);\n        List list = Arrays.asList(new Integer[]&#123;11, 15, 3, 7, 1&#125;);\n        col.addAll(list);//将另一个集合添加入col中\n        System.out.println(col);\n        //col.clear();清空集合\n        System.out.println(col);\n        System.out.println(&quot;集合中元素的数量为：&quot;+col.size());\n        System.out.println(&quot;集合是否为空：&quot;+col.isEmpty());\n        boolean isRemove = col.remove(15);\n        System.out.println(col);\n        System.out.println(&quot;集合中数据是否被删除：&quot;+isRemove);\n        Collection col2 = new ArrayList();\n        col2.add(18);\n        col2.add(12);\n        col2.add(11);\n        col2.add(17);\n        Collection col3 = new ArrayList();\n        col3.add(18);\n        col3.add(12);\n        col3.add(11);\n        col3.add(17);\n        System.out.println(col2.equals(col3));\n        System.out.println(col2==col3);//地址一定不相等  false\n        System.out.println(&quot;是否包含元素：&quot;+col3.contains(117));\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"1-2-Collection集合的遍历\"><a href=\"#1-2-Collection集合的遍历\" class=\"headerlink\" title=\"1.2 Collection集合的遍历\"></a>1.2 Collection集合的遍历</h2><pre><code class=\"java\">迭代器简要原理图：\n\n\n\npackage com.msb.test01;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Iterator;\n/**\n * @author : msb-zhaoss\n */\npublic class Test02 &#123;\n    //这是main方法，程序的入口\n    public static void main(String[] args) &#123;\n        Collection col = new ArrayList();\n        col.add(18);\n        col.add(12);\n        col.add(11);\n        col.add(17);\n        col.add(&quot;abc&quot;);\n        col.add(9.8);\n        //对集合遍历（对集合中元素进行查看）\n        //方式1：普通for循环\n        /*for(int i= 0;i&lt;col.size();i++)&#123;\n            col.\n        &#125;*/\n        //方式2：增强for循环\n        for(Object o:col)&#123;\n            System.out.println(o);\n        &#125;\n        System.out.println(&quot;------------------------&quot;);\n        //方式3：iterator()\n        Iterator it = col.iterator();\n        while(it.hasNext())&#123;\n            System.out.println(it.next());\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"2-List接口\"><a href=\"#2-List接口\" class=\"headerlink\" title=\"2 List接口\"></a>2 List接口</h2><h3 id=\"2-1-常用方法和遍历方式\"><a href=\"#2-1-常用方法和遍历方式\" class=\"headerlink\" title=\"2.1 常用方法和遍历方式\"></a>2.1 常用方法和遍历方式</h3><pre><code class=\"java\">package com.msb.test01;\nimport com.sun.org.apache.xerces.internal.dom.PSVIAttrNSImpl;\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\n/**\n * @author : msb-zhaoss\n */\npublic class Test03 &#123;\n    //这是main方法，程序的入口\n    public static void main(String[] args) &#123;\n        /*\n        List接口中常用方法：\n        增加：add(int index, E element)\n        删除：remove(int index)  remove(Object o)\n        修改：set(int index, E element)\n        查看：get(int index)\n        判断：\n         */\n        List list = new ArrayList();\n        list.add(13);\n        list.add(17);\n        list.add(6);\n        list.add(-1);\n        list.add(2);\n        list.add(&quot;abc&quot;);\n        System.out.println(list);\n        list.add(3,66);\n        System.out.println(list);\n        list.set(3,77);\n        System.out.println(list);\n        list.remove(2);//在集合中存入的是Integer类型数据的时候，调用remove方法调用的是：remove(int index)\n        System.out.println(list);\n        list.remove(&quot;abc&quot;);\n        System.out.println(list);\n        Object o = list.get(0);\n        System.out.println(o);\n        //List集合 遍历：\n        //方式1：普通for循环：\n        System.out.println(&quot;---------------------&quot;);\n        for(int i = 0;i&lt;list.size();i++)&#123;\n            System.out.println(list.get(i));\n        &#125;\n        //方式2：增强for循环：\n        System.out.println(&quot;---------------------&quot;);\n        for(Object obj:list)&#123;\n            System.out.println(obj);\n        &#125;\n        //方式3：迭代器：\n        System.out.println(&quot;---------------------&quot;);\n        Iterator it = list.iterator();\n        while(it.hasNext())&#123;\n            System.out.println(it.next());\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"2-2-ArrayList实现类（JDK1-7）\"><a href=\"#2-2-ArrayList实现类（JDK1-7）\" class=\"headerlink\" title=\"2.2 ArrayList实现类（JDK1.7）\"></a>2.2 ArrayList实现类（JDK1.7）</h3><p>底层重要属性：</p>\n<img data-src=\"/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618172028655.png\" class=\"\">\n\n\n<p>在JDK1.7中：在调用构造器的时候给底层数组elementData初始化，<font color=#FF0000>数组初始化长度为10</font>：</p>\n<img data-src=\"/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618172107247.png\" class=\"\">\n\n\n<p>对应内存：</p>\n<img data-src=\"/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618172121579.png\" class=\"\">\n\n\n<p>调用add方法：</p>\n<pre><code class=\"java\">         ArrayList al = new ArrayList();\n        System.out.println(al.add(&quot;abc&quot;));\n        System.out.println(al.add(&quot;def&quot;));\n</code></pre>\n<img data-src=\"/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618172152471.png\" class=\"\">\n\n\n<p>当数组中的10个位置都满了的时候就开始进行数组的扩容，扩容长度为 <font color=#FF0000>原数组的1.5倍</font>：</p>\n<img data-src=\"/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618172227199.png\" class=\"\">\n\n\n<img data-src=\"/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618172231517.png\" class=\"\">\n\n\n<img data-src=\"/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618172235705.png\" class=\"\">\n\n\n\n\n\n\n\n\n<h3 id=\"2-3-ArrayList实现类（JDK1-8）\"><a href=\"#2-3-ArrayList实现类（JDK1-8）\" class=\"headerlink\" title=\"2.3 ArrayList实现类（JDK1.8）\"></a>2.3 ArrayList实现类（JDK1.8）</h3><p>【1】JDK1.8底层依旧是Object类型的数组，size:数组中有效长度：</p>\n<img data-src=\"/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618172252320.png\" class=\"\">\n\n\n<p>【2】ArrayList al &#x3D; new ArrayList();调用空构造器：</p>\n<img data-src=\"/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618172303832.png\" class=\"\">\n\n\n<p>【3】add方法：</p>\n<img data-src=\"/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618172316929.png\" class=\"\">\n\n\n<img data-src=\"/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618172324585.png\" class=\"\">\n\n\n<img data-src=\"/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618172335841.png\" class=\"\">\n\n\n<img data-src=\"/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618172340839.png\" class=\"\">\n\n\n\n\n<h3 id=\"2-4-Vector实现类\"><a href=\"#2-4-Vector实现类\" class=\"headerlink\" title=\"2.4 Vector实现类\"></a>2.4 Vector实现类</h3><p>【1】底层Object数组，int类型属性表示数组中有效长度：</p>\n<img data-src=\"/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618172455343.png\" class=\"\">\n\n\n\n<p>【2】Vector v&#x3D;new Vector();调用构造器：</p>\n<p>【3】add方法：</p>\n<img data-src=\"/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618172507015.png\" class=\"\">\n\n\n\n\n<h3 id=\"2-5-泛型\"><a href=\"#2-5-泛型\" class=\"headerlink\" title=\"2.5 泛型\"></a>2.5 泛型</h3><p>【1】什么是泛型（Generic）：<br>泛型就相当于标签<br>形式：&lt;&gt;<br>集合容器类在设计阶段&#x2F;声明阶段不能确定这个容器到底实际存的是什么类型的对象，所以在JDK1.5之前只能把元素类型设计为Object，<br>JDK1.5之 后使用泛型来解决。因为这个时候除了元素的类型不确定，其他的部分是确定的，例如关于这个元素如何保存，如何管理等是确定的，因此此时把元素的类型设计成一个参数，这个类型参数叫做泛型。<br>Collection<E>, List<E>， ArrayList<E> 这个<E>就是类型参数，即泛型。</p>\n<p>【2】没有泛型的时候使用集合：</p>\n<pre><code class=\"java\">package com.msb.test01;\nimport java.util.ArrayList;\n/**\n * @author : msb-zhaoss\n */\npublic class Test01 &#123;\n    //这是main方法，程序的入口\n    public static void main(String[] args) &#123;\n        //创建一个ArrayList集合，向这个集合中存入学生的成绩：\n        ArrayList al = new ArrayList();\n        al.add(98);\n        al.add(18);\n        al.add(39);\n        al.add(60);\n        al.add(83);\n        al.add(&quot;丽丽&quot;);\n        //对集合遍历查看：\n        for(Object obj:al)&#123;\n            System.out.println(obj);\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>如果不使用泛型的话，有缺点：<br>一般我们在使用的时候基本上往集合中存入的都是相同类型的数据–》便于管理，所以现在什么引用数据类型都可以存入集合，不方便！</p>\n<p>【3】JDK1.5以后开始使用泛型，集合中使用泛型：</p>\n<pre><code class=\"java\">package com.msb.test01;\nimport java.util.ArrayList;\n/**\n * @author : msb-zhaoss\n */\npublic class Test01 &#123;\n    //这是main方法，程序的入口\n    public static void main(String[] args) &#123;\n        //创建一个ArrayList集合，向这个集合中存入学生的成绩：\n        //加入泛型的优点：在编译时期就会对类型进行检查，不是泛型对应的类型就不可以添加入这个集合。\n        ArrayList&lt;Integer&gt; al = new ArrayList&lt;Integer&gt;();\n        al.add(98);\n        al.add(18);\n        al.add(39);\n        al.add(60);\n        al.add(83);\n        /*al.add(&quot;丽丽&quot;);\n        al.add(9.8);*/\n        //对集合遍历查看：\n        /*for(Object obj:al)&#123;\n            System.out.println(obj);\n        &#125;*/\n        for(Integer i:al)&#123;\n            System.out.println(i);\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>【4】泛型总结：<br>（1）JDK1.5以后<br>（2）泛型实际就是 一个&lt;&gt;引起来的 参数类型，这个参数类型  具体在使用的时候才会确定具体的类型。</p>\n<img data-src=\"/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618172646571.png\" class=\"\">\n\n\n<p>（3）使用了泛型以后，可以确定集合中存放数据的类型，在编译时期就可以检查出来。<br>（4）使用泛型你可能觉得麻烦，实际使用了泛型才会简单，后续的遍历等操作简单。<br>（5）泛型的类型：都是引用数据类型，不能是基本数据类型。<br>（6）ArrayList<Integer> al &#x3D; new ArrayList<Integer>();在JDK1.7以后可以写为：<br>ArrayList<Integer> al &#x3D; new ArrayList&lt;&gt;();  –&lt;&gt;  —钻石运算符</p>\n<h4 id=\"2-5-1-自定义泛型结构\"><a href=\"#2-5-1-自定义泛型结构\" class=\"headerlink\" title=\"2.5.1 自定义泛型结构\"></a>2.5.1 自定义泛型结构</h4><p>泛型类，泛型接口</p>\n<p>【1】泛型类的定义和实例化：</p>\n<pre><code class=\"java\">package com.msb.test02;\n/**\n * @author : msb-zhaoss\n * GenericTes就是一个普通的类\n * GenericTest&lt;E&gt; 就是一个泛型类\n * &lt;&gt;里面就是一个参数类型，但是这个类型是什么呢？这个类型现在是不确定的，相当于一个占位\n * 但是现在确定的是这个类型一定是一个引用数据类型，而不是基本数据类型\n */\npublic class GenericTest&lt;E&gt; &#123;\n    int age;\n    String name;\n    E sex;\n    public void a(E n)&#123;\n    &#125;\n    public void b(E[] m)&#123;\n    &#125;\n&#125;\nclass Test&#123;\n    //这是main方法，程序的入口\n    public static void main(String[] args) &#123;\n        //GenericTest进行实例化：\n        //(1)实例化的时候不指定泛型：如果实例化的时候不明确的指定类的泛型，那么认为此泛型为Object类型\n        GenericTest gt1 = new GenericTest();\n        gt1.a(&quot;abc&quot;);\n        gt1.a(17);\n        gt1.a(9.8);\n        gt1.b(new String[]&#123;&quot;a&quot;,&quot;b&quot;,&quot;c&quot;&#125;);\n        //（2）实例化的时候指定泛型：---》推荐方式\n        GenericTest&lt;String&gt; gt2 = new GenericTest&lt;&gt;();\n        gt2.sex = &quot;男&quot;;\n        gt2.a(&quot;abc&quot;);\n        gt2.b(new String[]&#123;&quot;a&quot;,&quot;b&quot;,&quot;c&quot;&#125;);\n        \n    &#125;\n&#125;\n</code></pre>\n<p>【2】继承情况：<br>（1）父类指定泛型：</p>\n<pre><code class=\"java\">class SubGenericTest extends GenericTest&lt;Integer&gt;&#123;\n&#125;\nclass Demo&#123;\n    //这是main方法，程序的入口\n    public static void main(String[] args) &#123;\n        //指定父类泛型，那么子类就不需要再指定泛型了，可以直接使用\n        SubGenericTest sgt = new SubGenericTest();\n        sgt.a(19);\n    &#125;\n&#125;\n</code></pre>\n<p>（2）父类不指定泛型：<br>如果父类不指定泛型，那么子类也会变成一个泛型类，那这个E的类型可以在创建子类对象的时候确定：</p>\n<pre><code class=\"java\">class SubGenericTest2&lt;E&gt; extends GenericTest&lt;E&gt;&#123;\n&#125;\n\nclass Demo2&#123;\n    //这是main方法，程序的入口\n    public static void main(String[] args) &#123;\n        SubGenericTest2&lt;String&gt; s = new  SubGenericTest2&lt;&gt;();\n        s.a(&quot;abc&quot;);\n        s.sex = &quot;女&quot;;\n    &#125;\n&#125;\n</code></pre>\n<p>【3】应用场合：</p>\n<img data-src=\"/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618173037582.png\" class=\"\">\n\n\n<p>【4】细节：<br>（1）泛型类可以定义多个参数类型</p>\n<img data-src=\"/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618173045431.png\" class=\"\">\n\n\n<p>（2）泛型类的构造器的写法：</p>\n<img data-src=\"/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618173057556.png\" class=\"\">\n\n\n<p>（3）不同的泛型的引用类型不可以相互赋值：</p>\n<img data-src=\"/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618173104251.png\" class=\"\">\n\n\n<p>（4）泛型如果不指定，那么就会被擦除，反应对应的类型为Object类型：</p>\n<img data-src=\"/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618173116539.png\" class=\"\">\n\n\n<p>（5）反省类中的静态方法不能使用类的泛型：</p>\n<img data-src=\"/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618173123924.png\" class=\"\">\n\n\n<p>（6）不能直接使用E[]的创建：</p>\n<img data-src=\"/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618173130213.png\" class=\"\">\n\n\n<h4 id=\"2-5-2-泛型方法\"><a href=\"#2-5-2-泛型方法\" class=\"headerlink\" title=\"2.5.2 泛型方法\"></a>2.5.2 泛型方法</h4><pre><code class=\"java\">package com.msb.test04;\n/**\n * @author : msb-zhaoss\n * 1.什么是泛型方法：\n * 不是带泛型的方法就是泛型方法\n * 泛型方法有要求：这个方法的泛型的参数类型要和当前的类的泛型无关\n * 换个角度：\n * 泛型方法对应的那个泛型参数类型 和  当前所在的这个类 是否是泛型类，泛型是啥  无关\n * 2.泛型方法定义的时候，前面要加上&lt;T&gt;\n *     原因：如果不加的话，会把T当做一种数据类型，然而代码中没有T类型那么就会报错\n * 3.T的类型是在调用方法的时候确定的\n * 4.泛型方法可否是静态方法？可以是静态方法\n */\npublic class TestGeneric&lt;E&gt; &#123;\n    //不是泛型方法 （不能是静态方法）\n    public static void a(E e)&#123;\n    &#125;\n    //是泛型方法\n    public static &lt;T&gt;  void b(T t)&#123;\n    &#125;\n&#125;\nclass Demo&#123;\n    //这是main方法，程序的入口\n    public static void main(String[] args) &#123;\n        TestGeneric&lt;String&gt; tg = new TestGeneric&lt;&gt;();\n        tg.a(&quot;abc&quot;);\n        tg.b(&quot;abc&quot;);\n        tg.b(19);\n        tg.b(true);\n    &#125;\n&#125;\n</code></pre>\n<h4 id=\"2-5-3-泛型参数存在继承关系的情况\"><a href=\"#2-5-3-泛型参数存在继承关系的情况\" class=\"headerlink\" title=\"2.5.3 泛型参数存在继承关系的情况\"></a>2.5.3 泛型参数存在继承关系的情况</h4><img data-src=\"/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618173213265.png\" class=\"\">\n\n\n<h4 id=\"2-5-4-通配符\"><a href=\"#2-5-4-通配符\" class=\"headerlink\" title=\"2.5.4 通配符\"></a>2.5.4 通配符</h4><p>【1】在没有通配符的时候：<br>下面的a方法，相当于方法的重复定义，报错</p>\n<pre><code class=\"java\">public class Test &#123;\n    /*public void a(List&lt;Object&gt; list)&#123;\n    &#125;\n    public void a(List&lt;String&gt; list)&#123;\n    &#125;\n    public void a(List&lt;Integer&gt; list)&#123;\n    &#125;*/\n&#125;\n</code></pre>\n<p>【2】引入通配符：</p>\n<pre><code class=\"java\">public class Demo &#123;\n    //这是main方法，程序的入口\n    public static void main(String[] args) &#123;\n        List&lt;Object&gt; list1 = new ArrayList&lt;&gt;();\n        List&lt;String&gt; list2 = new ArrayList&lt;&gt;();\n        List&lt;Integer&gt; list3 = new ArrayList&lt;&gt;();\n        List&lt;?&gt; list = null;\n        list = list1;\n        list = list2;\n        list = list3;\n    &#125;\n&#125;\n</code></pre>\n<p>发现： A 和 B是子类父类的关系，G<A>和G<B>不存在子类父类关系，是并列的<br>加入通配符？后，G&lt;?&gt;就变成了 G<A>和G<B>的父类</p>\n<p>【3】使用通配符：</p>\n<pre><code class=\"java\">package com.msb.test06;\nimport java.util.ArrayList;\nimport java.util.List;\n/**\n * @author : msb-zhaoss\n */\npublic class Test &#123;\n    /*public void a(List&lt;Object&gt; list)&#123;\n    &#125;\n    public void a(List&lt;String&gt; list)&#123;\n    &#125;\n    public void a(List&lt;Integer&gt; list)&#123;\n    &#125;*/\n    public void a(List&lt;?&gt; list)&#123;\n        //内部遍历的时候用Object即可，不用？\n        for(Object a:list)&#123;\n            System.out.println(a);\n        &#125;\n    &#125;\n&#125;\nclass T&#123;\n    //这是main方法，程序的入口\n    public static void main(String[] args) &#123;\n        Test t = new Test();\n        t.a(new ArrayList&lt;Integer&gt;());\n        t.a(new ArrayList&lt;String&gt;());\n        t.a(new ArrayList&lt;Object&gt;());\n    &#125;\n&#125;\n</code></pre>\n<p>【4】查看API中应用位置：</p>\n<img data-src=\"/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618173333503.png\" class=\"\">\n\n\n<h4 id=\"2-5-5-使用通配符后的细节\"><a href=\"#2-5-5-使用通配符后的细节\" class=\"headerlink\" title=\"2.5.5 使用通配符后的细节\"></a>2.5.5 使用通配符后的细节</h4><pre><code class=\"java\">public class Test &#123;\n    public void a(List&lt;?&gt; list)&#123;\n        //1.遍历：\n        for(Object a:list)&#123;\n            System.out.println(a);\n        &#125;\n        //2.数据的写入操作 ：\n        //list.add(&quot;abc&quot;);--&gt;出错，不能随意的添加数据\n        list.add(null);\n        //3.数据的读取操作：\n        Object s = list.get(0);\n    &#125;\n&#125;\nclass T&#123;\n    //这是main方法，程序的入口\n    public static void main(String[] args) &#123;\n        Test t = new Test();\n        t.a(new ArrayList&lt;Integer&gt;());\n        t.a(new ArrayList&lt;String&gt;());\n        t.a(new ArrayList&lt;Object&gt;());\n    &#125;\n&#125;\n</code></pre>\n<h4 id=\"2-5-6-泛型受限\"><a href=\"#2-5-6-泛型受限\" class=\"headerlink\" title=\"2.5.6 泛型受限\"></a>2.5.6 泛型受限</h4><pre><code class=\"java\">package com.msb.test07;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Test &#123;\n    //这是main方法，程序的入口\n    public static void main(String[] args) &#123;\n        //a,b,c三个集合是并列的关系：\n        List&lt;Object&gt; a = new ArrayList&lt;&gt;();\n        List&lt;Person&gt; b = new ArrayList&lt;&gt;();\n        List&lt;Student&gt; c = new ArrayList&lt;&gt;();\n        /*开始使用泛型受限：泛型的上限\n        List&lt;? extends Person&gt;:\n        就相当于：\n        List&lt;? extends Person&gt;是List&lt;Person&gt;的父类，是List&lt;Person的子类&gt;的父类\n         */\n        List&lt;? extends Person&gt; list1 = null;\n        /*list1 = a;\n        list1 = b;\n        list1 = c;*/\n        /*开始使用泛型受限：泛型的下限\n        List&lt;? super Person&gt;\n        就相当于：\n        List&lt;? super Person&gt;是List&lt;Person&gt;的父类，是List&lt;Person的父类&gt;的父类\n         */\n        List&lt;? super Person&gt; list2 = null;\n        list2 = a;\n        list2 = b;\n        list3 = c;\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"2-6-LinkedList实现类\"><a href=\"#2-6-LinkedList实现类\" class=\"headerlink\" title=\"2.6 LinkedList实现类\"></a>2.6 LinkedList实现类</h3><h4 id=\"2-6-1-基本方法使用\"><a href=\"#2-6-1-基本方法使用\" class=\"headerlink\" title=\"2.6.1 基本方法使用\"></a>2.6.1 基本方法使用</h4><pre><code class=\"java\">package com.msb.test04;\nimport java.util.Iterator;\nimport java.util.LinkedList;\n/**\n * @author : msb-zhaoss\n */\npublic class Test &#123;\n    //这是main方法，程序的入口\n    public static void main(String[] args) &#123;\n        /*\n        LinkedList常用方法：\n        增加 addFirst(E e) addLast(E e)\n             offer(E e) offerFirst(E e) offerLast(E e)\n        删除 poll()\n            pollFirst() pollLast()  ---》JDK1.6以后新出的方法，提高了代码的健壮性\n            removeFirst() removeLast()\n        修改\n        查看 element()\n             getFirst()  getLast()\n             indexOf(Object o)   lastIndexOf(Object o)\n             peek()\n             peekFirst() peekLast()\n        判断\n         */\n        //创建一个LinkedList集合对象：\n        LinkedList&lt;String&gt; list = new LinkedList&lt;&gt;();\n        list.add(&quot;aaaaa&quot;);\n        list.add(&quot;bbbbb&quot;);\n        list.add(&quot;ccccc&quot;);\n        list.add(&quot;ddddd&quot;);\n        list.add(&quot;eeeee&quot;);\n        list.add(&quot;bbbbb&quot;);\n        list.add(&quot;fffff&quot;);\n        list.addFirst(&quot;jj&quot;);\n        list.addLast(&quot;hh&quot;);\n        list.offer(&quot;kk&quot;);//添加元素在尾端\n        list.offerFirst(&quot;pp&quot;);\n        list.offerLast(&quot;rr&quot;);\n        System.out.println(list);//LinkedList可以添加重复数据\n        System.out.println(list.poll());//删除头上的元素并且将元素输出\n        System.out.println(list.pollFirst());\n        System.out.println(list.pollLast());\n        System.out.println(list.removeFirst());\n        System.out.println(list.removeLast());\n        System.out.println(list);//LinkedList可以添加重复数据\n        /*list.clear();//清空集合\n        System.out.println(list);*/\n        /*System.out.println(list.pollFirst());*/\n        /*System.out.println(list.removeFirst());报错：Exception in thread &quot;main&quot; java.util.NoSuchElementException*/\n        //集合的遍历：\n        System.out.println(&quot;---------------------&quot;);\n        //普通for循环：\n        for(int i = 0;i&lt;list.size();i++)&#123;\n            System.out.println(list.get(i));\n        &#125;\n        System.out.println(&quot;---------------------&quot;);\n        //增强for：\n        for(String s:list)&#123;\n            System.out.println(s);\n        &#125;\n        System.out.println(&quot;---------------------&quot;);\n        //迭代器：\n        /*Iterator&lt;String&gt; it = list.iterator();\n        while(it.hasNext())&#123;\n            System.out.println(it.next());\n        &#125;*/\n        //下面这种方式好，节省内存\n        for(Iterator&lt;String&gt; it = list.iterator();it.hasNext();)&#123;\n            System.out.println(it.next());\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<h4 id=\"2-6-2-简要底层原理图\"><a href=\"#2-6-2-简要底层原理图\" class=\"headerlink\" title=\"2.6.2 简要底层原理图\"></a>2.6.2 简要底层原理图</h4><img data-src=\"/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618173515599.png\" class=\"\">\n\n\n<h4 id=\"2-6-3-模拟LinkedList源码\"><a href=\"#2-6-3-模拟LinkedList源码\" class=\"headerlink\" title=\"2.6.3 模拟LinkedList源码\"></a>2.6.3 模拟LinkedList源码</h4><pre><code class=\"java\">package com.msb.test05;\n/**\n * @author : msb-zhaoss\n */\npublic class MyLinkedList &#123;\n    //链中一定有一个首节点：\n    Node first;\n    //链中一定有一个尾节点：\n    Node last;\n    //计数器：\n    int count = 0;\n    //提供一个构造器：\n    public MyLinkedList()&#123;\n    &#125;\n    //添加元素方法：\n    public void add(Object o)&#123;\n        if(first == null)&#123;//证明你添加的元素是第一个节点：\n            //将添加的元素封装为一个Node对象：\n            Node n = new Node();\n            n.setPre(null);\n            n.setObj(o);\n            n.setNext(null);\n            //当前链中第一个节点变为n\n            first = n;\n            //当前链中最后一个节点变为n\n            last = n;\n        &#125;else&#123;//证明已经不是链中第一个节点了\n            //将添加的元素封装为一个Node对象：\n            Node n = new Node();\n            n.setPre(last);//n的上一个节点一定是当前链中的最后一个节点last\n            n.setObj(o);\n            n.setNext(null);\n            //当前链中的最后一个节点的下一个元素 要指向n\n            last.setNext(n);\n            //将最后一个节点变为n\n            last = n;\n        &#125;\n        //链中元素数量加1\n        count++;\n    &#125;\n    //得到集合中元素的数量：\n    public int getSize()&#123;\n        return count;\n    &#125;\n    //通过下标得到元素：\n    public Object get(int index)&#123;\n        //获取链表的头元素：\n        Node n = first;\n        //一路next得到想要的元素\n        for(int i=0;i&lt;index;i++)&#123;\n            n = n.getNext();\n        &#125;\n        return n.getObj();\n    &#125;\n&#125;\nclass Test&#123;\n    //这是main方法，程序的入口\n    public static void main(String[] args) &#123;\n        //创建一个MyLinkedList集合对象：\n        MyLinkedList ml = new MyLinkedList();\n        ml.add(&quot;aa&quot;);\n        ml.add(&quot;bb&quot;);\n        ml.add(&quot;cc&quot;);\n        System.out.println(ml.getSize());\n        System.out.println(ml.get(0));\n    &#125;\n&#125;\n</code></pre>\n<h4 id=\"2-6-4-LinkedList源码解析\"><a href=\"#2-6-4-LinkedList源码解析\" class=\"headerlink\" title=\"2.6.4 LinkedList源码解析\"></a>2.6.4 LinkedList源码解析</h4><p>【1】JDK1.7和JDK1.8的LinkedList的源码是一致的<br>【2】源码：</p>\n<pre><code class=\"java\">public class LinkedList&lt;E&gt;&#123;//E是一个泛型，具体的类型要在实例化的时候才会最终确定\n        transient int size = 0;//集合中元素的数量\n        //Node的内部类\n        private static class Node&lt;E&gt; &#123;\n        E item;//当前元素\n        Node&lt;E&gt; next;//指向下一个元素地址\n        Node&lt;E&gt; prev;//上一个元素地址\n        Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;\n            this.item = element;\n            this.next = next;\n            this.prev = prev;\n        &#125;\n    &#125;\n        transient Node&lt;E&gt; first;//链表的首节点\n        transient Node&lt;E&gt; last;//链表的尾节点\n        //空构造器：\n        public LinkedList() &#123;\n    &#125;\n        //添加元素操作：\n        public boolean add(E e) &#123;\n        linkLast(e);\n        return true;\n    &#125;\n        void linkLast(E e) &#123;//添加的元素e\n        final Node&lt;E&gt; l = last;//将链表中的last节点给l 如果是第一个元素的话 l为null\n                //将元素封装为一个Node具体的对象：\n        final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null);\n                //将链表的last节点指向新的创建的对象：\n        last = newNode;\n                \n        if (l == null)//如果添加的是第一个节点\n            first = newNode;//将链表的first节点指向为新节点\n        else//如果添加的不是第一个节点 \n            l.next = newNode;//将l的下一个指向为新的节点\n        size++;//集合中元素数量加1操作\n        modCount++;\n    &#125;\n        //获取集合中元素数量\n        public int size() &#123;\n        return size;\n    &#125;\n        //通过索引得到元素：\n        public E get(int index) &#123;\n        checkElementIndex(index);//健壮性考虑\n        return node(index).item;\n    &#125;\n        \n    Node&lt;E&gt; node(int index) &#123;\n        //如果index在链表的前半段，那么从前往后找\n        if (index &lt; (size &gt;&gt; 1)) &#123;\n            Node&lt;E&gt; x = first;\n            for (int i = 0; i &lt; index; i++)\n                x = x.next;\n            return x;\n        &#125; else &#123;//如果index在链表的后半段，那么从后往前找\n            Node&lt;E&gt; x = last;\n            for (int i = size - 1; i &gt; index; i--)\n                x = x.prev;\n            return x;\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"面试题：\"><a href=\"#面试题：\" class=\"headerlink\" title=\"面试题：\"></a>面试题：</h3><blockquote>\n<p>iterator(),Iterator,Iterable关系</p>\n</blockquote>\n<p>【1】面试题：对应的关系：</p>\n<img data-src=\"/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618173707713.png\" class=\"\">\n\n\n<p>【2】hasNext(),next()的具体实现：</p>\n<img data-src=\"/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618173654976.png\" class=\"\">\n\n\n<p>ListIterator迭代器</p>\n<p>【1】加入字符串：</p>\n<pre><code class=\"java\">package com.msb.test06;\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\n/**\n * @author : msb-zhaoss\n */\npublic class Test2 &#123;\n    //这是main方法，程序的入口\n    public static void main(String[] args) &#123;\n        ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();\n        list.add(&quot;aa&quot;);\n        list.add(&quot;bb&quot;);\n        list.add(&quot;cc&quot;);\n        list.add(&quot;dd&quot;);\n        list.add(&quot;ee&quot;);\n        //在&quot;cc&quot;之后添加一个字符串&quot;kk&quot;\n        Iterator&lt;String&gt; it = list.iterator();\n        while(it.hasNext())&#123;\n            if(&quot;cc&quot;.equals(it.next()))&#123;\n                list.add(&quot;kk&quot;);\n            &#125;\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>发现报错：</p>\n<img data-src=\"/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618173818117.png\" class=\"\">\n\n\n<p>出错原因：就是迭代器和list同时对集合进行操作：</p>\n<img data-src=\"/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618173826503.png\" class=\"\">\n\n\n<p>解决办法：事情让一个“人”做 –》引入新的迭代器：ListIterator<br>迭代和添加操作都是靠ListIterator来完成的：</p>\n<pre><code class=\"java\">package com.msb.test06;\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.ListIterator;\n/**\n * @author : msb-zhaoss\n */\npublic class Test2 &#123;\n    //这是main方法，程序的入口\n    public static void main(String[] args) &#123;\n        ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();\n        list.add(&quot;aa&quot;);\n        list.add(&quot;bb&quot;);\n        list.add(&quot;cc&quot;);\n        list.add(&quot;dd&quot;);\n        list.add(&quot;ee&quot;);\n        //在&quot;cc&quot;之后添加一个字符串&quot;kk&quot;\n        ListIterator&lt;String&gt; it = list.listIterator();\n        while(it.hasNext())&#123;\n            if(&quot;cc&quot;.equals(it.next()))&#123;\n                it.add(&quot;kk&quot;);\n            &#125;\n        &#125;\n        System.out.println(it.hasNext());\n        System.out.println(it.hasPrevious());\n        //逆向遍历：\n        while(it.hasPrevious())&#123;\n            System.out.println(it.previous());\n        &#125;\n        System.out.println(it.hasNext());\n        System.out.println(it.hasPrevious());\n        System.out.println(list);\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"3-Set接口\"><a href=\"#3-Set接口\" class=\"headerlink\" title=\"3 Set接口\"></a>3 Set接口</h2><h3 id=\"3-1-HashSet实现类的使用\"><a href=\"#3-1-HashSet实现类的使用\" class=\"headerlink\" title=\"3.1 HashSet实现类的使用\"></a>3.1 HashSet实现类的使用</h3><p>【1】放入Integer类型数据：</p>\n<pre><code class=\"java\">package com.msb.test07;\nimport java.util.HashSet;\n/**\n * @author : msb-zhaoss\n */\npublic class TestInteger &#123;\n    //这是main方法，程序的入口\n    public static void main(String[] args) &#123;\n        //创建一个HashSet集合：\n        HashSet&lt;Integer&gt; hs = new HashSet&lt;&gt;();\n        System.out.println(hs.add(19));//true\n        hs.add(5);\n        hs.add(20);\n        System.out.println(hs.add(19));//false 这个19没有放入到集合中\n        hs.add(41);\n        hs.add(0);\n        System.out.println(hs.size());//唯一，无序\n        System.out.println(hs);\n    &#125;\n&#125;\n</code></pre>\n<p>【2】放入String类型数据：</p>\n<pre><code class=\"java\">package com.msb.test07;\nimport java.util.HashSet;\n/**\n * @author : msb-zhaoss\n */\npublic class TestString &#123;\n    //这是main方法，程序的入口\n    public static void main(String[] args) &#123;\n        //创建一个HashSet集合：\n        HashSet&lt;String&gt; hs = new HashSet&lt;&gt;();\n        hs.add(&quot;hello&quot;);\n        hs.add(&quot;apple&quot;);\n        hs.add(&quot;banana&quot;);\n        hs.add(&quot;html&quot;);\n        hs.add(&quot;apple&quot;);\n        hs.add(&quot;css&quot;);\n        System.out.println(hs.size());\n        System.out.println(hs);\n    &#125;\n&#125;\n</code></pre>\n<p>【3】放入自定义的引用数据类型的数据：</p>\n<pre><code class=\"java\">package com.msb.test07;\nimport java.util.HashSet;\n/**\n * @author : msb-zhaoss\n */\npublic class TestStudent &#123;\n    //这是main方法，程序的入口\n    public static void main(String[] args) &#123;\n        //创建一个HashSet集合：\n        HashSet&lt;Student&gt; hs = new HashSet&lt;&gt;();\n        hs.add(new Student(19,&quot;lili&quot;));\n        hs.add(new Student(20,&quot;lulu&quot;));\n        hs.add(new Student(18,&quot;feifei&quot;));\n        hs.add(new Student(19,&quot;lili&quot;));\n        hs.add(new Student(10,&quot;nana&quot;));\n        System.out.println(hs.size());\n        System.out.println(hs);\n    &#125;\n&#125;\n</code></pre>\n<p>上面自定义的类型不满足 唯一，无序的特点。为什么呢？</p>\n<p>【4】HashSet原理图：（简要原理图）</p>\n<img data-src=\"/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618173954231.png\" class=\"\">\n\n\n<p>【5】疑问：<br>1.数组的长度是多少。<br>2.数组的类型是什么？<br>3.hashCode，equals方法真的调用了吗？验证<br>4.底层表达式是什么？<br>5.同一个位置的数据 向前放  还是 向后放？<br>6.放入数组中的数据，是直接放的吗？是否封装为对象了？</p>\n<h3 id=\"3-2LinkedHashSet使用\"><a href=\"#3-2LinkedHashSet使用\" class=\"headerlink\" title=\"3.2LinkedHashSet使用\"></a>3.2LinkedHashSet使用</h3><p>其实就是在HashSet的基础上，多了一个总的链表，这个总链表将放入的元素串在一起，方便有序的遍历：<br>（可以看到LinkedHashMap.Entry 继承自HashMap.Node 除了Node 本身有的几个属性外，额外增加了before after 用于指向前一个Entry 后一个Entry。也就是说，元素之间维持着一条总的链表数据结构。）</p>\n<img data-src=\"/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618174059591.png\" class=\"\">\n\n\n<pre><code class=\"java\">package com.msb.test07;\nimport java.util.HashSet;\nimport java.util.LinkedHashMap;\nimport java.util.LinkedHashSet;\n/**\n * @author : msb-zhaoss\n */\npublic class TestInteger &#123;\n    //这是main方法，程序的入口\n    public static void main(String[] args) &#123;\n        //创建一个HashSet集合：\n        LinkedHashSet&lt;Integer&gt; hs = new LinkedHashSet&lt;&gt;();\n        System.out.println(hs.add(19));//true\n        hs.add(5);\n        hs.add(20);\n        System.out.println(hs.add(19));//false 这个19没有放入到集合中\n        hs.add(41);\n        hs.add(0);\n        System.out.println(hs.size());//唯一，无序\n        System.out.println(hs);\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"3-3-比较器的使用\"><a href=\"#3-3-比较器的使用\" class=\"headerlink\" title=\"3.3 比较器的使用\"></a>3.3 比较器的使用</h3><p>【1】以int类型为案例：<br>比较的思路：将比较的数据做差，然后返回一个int类型的数据，将这个int类型的数值  按照 &#x3D;0  &gt;0  &lt;0</p>\n<pre><code class=\"java\">          int a = 10;\n        int b = 20;\n        System.out.println(a-b); // =0  &gt;0  &lt;0\n</code></pre>\n<p>【2】比较String类型数据：<br>String类实现了Comparable接口，这个接口中有一个抽象方法compareTo，String类中重写这个方法即可</p>\n<pre><code class=\"java\">          String a = &quot;A&quot;;\n        String b = &quot;B&quot;;\n        System.out.println(a.compareTo(b));\n</code></pre>\n<p>【3】比较double类型数据：</p>\n<pre><code class=\"java\">         double a = 9.6;\n        double b = 9.3;\n       /* System.out.println((int)(a-b));*/\n        System.out.println(((Double) a).compareTo((Double) b));\n</code></pre>\n<p>【4】比较自定义的数据类型：<br>（1）内部比较器：</p>\n<pre><code class=\"java\">public class Student implements Comparable&lt;Student&gt;&#123;\n    private int age;\n    private double height;\n    private String name;\n    public int getAge() &#123;\n        return age;\n    &#125;\n    public void setAge(int age) &#123;\n        this.age = age;\n    &#125;\n    public double getHeight() &#123;\n        return height;\n    &#125;\n    public void setHeight(double height) &#123;\n        this.height = height;\n    &#125;\n    public String getName() &#123;\n        return name;\n    &#125;\n    public void setName(String name) &#123;\n        this.name = name;\n    &#125;\n    public Student(int age, double height, String name) &#123;\n        this.age = age;\n        this.height = height;\n        this.name = name;\n    &#125;\n    @Override\n    public String toString() &#123;\n        return &quot;Student&#123;&quot; +\n                &quot;age=&quot; + age +\n                &quot;, height=&quot; + height +\n                &quot;, name=&#39;&quot; + name + &#39;\\&#39;&#39; +\n                &#39;&#125;&#39;;\n    &#125;\n    @Override\n    public int compareTo(Student o) &#123;\n        //按照年龄进行比较：\n        /*return this.getAge() - o.getAge();*/\n        //按照身高比较\n        /*return ((Double)(this.getHeight())).compareTo((Double)(o.getHeight()));*/\n        //按照名字比较：\n        return this.getName().compareTo(o.getName());\n    &#125;\n&#125;\n</code></pre>\n<pre><code class=\"java\">public class Test02 &#123;\n    //这是main方法，程序的入口\n    public static void main(String[] args) &#123;\n        //比较两个学生：\n        Student s1 = new Student(14,160.5,&quot;alili&quot;);\n        Student s2 = new Student(14,170.5,&quot;bnana&quot;);\n        System.out.println(s1.compareTo(s2));\n    &#125;\n&#125;\n</code></pre>\n<p>（2）外部比较器：</p>\n<pre><code class=\"java\">public class Student&#123;\n    private int age;\n    private double height;\n    private String name;\n    public int getAge() &#123;\n        return age;\n    &#125;\n    public void setAge(int age) &#123;\n        this.age = age;\n    &#125;\n    public double getHeight() &#123;\n        return height;\n    &#125;\n    public void setHeight(double height) &#123;\n        this.height = height;\n    &#125;\n    public String getName() &#123;\n        return name;\n    &#125;\n    public void setName(String name) &#123;\n        this.name = name;\n    &#125;\n    public Student(int age, double height, String name) &#123;\n        this.age = age;\n        this.height = height;\n        this.name = name;\n    &#125;\n    @Override\n    public String toString() &#123;\n        return &quot;Student&#123;&quot; +\n                &quot;age=&quot; + age +\n                &quot;, height=&quot; + height +\n                &quot;, name=&#39;&quot; + name + &#39;\\&#39;&#39; +\n                &#39;&#125;&#39;;\n    &#125;\n&#125;\nclass BiJiao01 implements Comparator&lt;Student&gt; &#123;\n    @Override\n    public int compare(Student o1, Student o2) &#123;\n        //比较年龄：\n        return o1.getAge()-o2.getAge();\n    &#125;\n&#125;\nclass BiJiao02 implements Comparator&lt;Student&gt; &#123;\n    @Override\n    public int compare(Student o1, Student o2) &#123;\n        //比较姓名：\n        return o1.getName().compareTo(o2.getName());\n    &#125;\n&#125;\n</code></pre>\n<pre><code class=\"java\">class BiJiao03 implements Comparator&lt;Student&gt; &#123;\n    @Override\n    public int compare(Student o1, Student o2) &#123;\n        //在年龄相同的情况下 比较身高  年龄不同比较年龄\n        if((o1.getAge()-o2.getAge())==0)&#123;\n            return ((Double)(o1.getHeight())).compareTo((Double)(o2.getHeight()));\n        &#125;else&#123;//年龄不一样\n            return o1.getAge()-o2.getAge();\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<pre><code class=\"java\">public class Test02 &#123;\n    //这是main方法，程序的入口\n    public static void main(String[] args) &#123;\n        //比较两个学生：\n        Student s1 = new Student(9,160.5,&quot;alili&quot;);\n        Student s2 = new Student(14,170.5,&quot;bnana&quot;);\n        //获取外部比较器：\n        Comparator bj1 = new BiJiao03();\n        System.out.println(bj1.compare(s1, s2));\n    &#125;\n&#125;\n</code></pre>\n<p>【5】外部比较器和内部比较器 谁好呀？<br>答案：外部比较器，多态，扩展性好</p>\n<h3 id=\"3-4-TreeSet实现类的使用\"><a href=\"#3-4-TreeSet实现类的使用\" class=\"headerlink\" title=\"3.4 TreeSet实现类的使用\"></a>3.4 TreeSet实现类的使用</h3><p>【1】存入Integer类型数据：（底层利用的是内部比较器）</p>\n<pre><code class=\"java\">package com.msb.test10;\nimport java.util.TreeSet;\n/**\n * @author : msb-zhaoss\n */\npublic class Test01 &#123;\n    //这是main方法，程序的入口\n    public static void main(String[] args) &#123;\n        //创建一个TreeSet:\n        TreeSet&lt;Integer&gt; ts = new TreeSet&lt;&gt;();\n        ts.add(12);\n        ts.add(3);\n        ts.add(7);\n        ts.add(9);\n        ts.add(3);\n        ts.add(16);\n        System.out.println(ts.size());\n        System.out.println(ts);\n    &#125;\n&#125;\n</code></pre>\n<p>特点：唯一，无序（没有按照输入顺序进行输出）， 有序（按照升序进行遍历）</p>\n<p>【2】原理：底层：二叉树（数据结构中的一个逻辑结构）</p>\n<img data-src=\"/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618174503614.png\" class=\"\">\n\n\n<p>【3】放入String类型数据：（底层实现类内部比较器）</p>\n<pre><code class=\"java\">public class Test02 &#123;\n    //这是main方法，程序的入口\n    public static void main(String[] args) &#123;\n        //创建一个TreeSet:\n        TreeSet&lt;String&gt; ts = new TreeSet&lt;&gt;();\n        ts.add(&quot;elili&quot;);\n        ts.add(&quot;blili&quot;);\n        ts.add(&quot;alili&quot;);\n        ts.add(&quot;elili&quot;);\n        ts.add(&quot;clili&quot;);\n        ts.add(&quot;flili&quot;);\n        ts.add(&quot;glili&quot;);\n        System.out.println(ts.size());\n        System.out.println(ts);\n    &#125;\n&#125;\n</code></pre>\n<p>【4】想放入自定义的Student类型的数据：<br>（1）利用内部比较器：</p>\n<pre><code class=\"java\">public class Student implements Comparable&lt;Student&gt; &#123;\n    private int age;\n    private String name;\n    public int getAge() &#123;\n        return age;\n    &#125;\n    public void setAge(int age) &#123;\n        this.age = age;\n    &#125;\n    public String getName() &#123;\n        return name;\n    &#125;\n    public void setName(String name) &#123;\n        this.name = name;\n    &#125;\n    public Student(int age, String name) &#123;\n        this.age = age;\n        this.name = name;\n    &#125;\n    @Override\n    public String toString() &#123;\n        return &quot;Student&#123;&quot; +\n                &quot;age=&quot; + age +\n                &quot;, name=&#39;&quot; + name + &#39;\\&#39;&#39; +\n                &#39;&#125;&#39;;\n    &#125;\n    @Override\n    public int compareTo(Student o) &#123;\n        return this.getAge()-o.getAge();\n    &#125;\n&#125;\n</code></pre>\n<pre><code class=\"java\">public class Test03 &#123;\n    //这是main方法，程序的入口\n    public static void main(String[] args) &#123;\n        //创建一个TreeSet:\n        TreeSet&lt;Student&gt; ts = new TreeSet&lt;&gt;();\n        ts.add(new Student(10,&quot;elili&quot;));\n        ts.add(new Student(8,&quot;blili&quot;));\n        ts.add(new Student(4,&quot;alili&quot;));\n        ts.add(new Student(9,&quot;elili&quot;));\n        ts.add(new Student(10,&quot;flili&quot;));\n        ts.add(new Student(1,&quot;dlili&quot;));\n        System.out.println(ts.size());\n        System.out.println(ts);\n    &#125;\n&#125;\n</code></pre>\n<p>（2）通过外部比较器：</p>\n<pre><code class=\"java\">public class Student  &#123;\n    private int age;\n    private String name;\n    public int getAge() &#123;\n        return age;\n    &#125;\n    public void setAge(int age) &#123;\n        this.age = age;\n    &#125;\n    public String getName() &#123;\n        return name;\n    &#125;\n    public void setName(String name) &#123;\n        this.name = name;\n    &#125;\n    public Student(int age, String name) &#123;\n        this.age = age;\n        this.name = name;\n    &#125;\n    @Override\n    public String toString() &#123;\n        return &quot;Student&#123;&quot; +\n                &quot;age=&quot; + age +\n                &quot;, name=&#39;&quot; + name + &#39;\\&#39;&#39; +\n                &#39;&#125;&#39;;\n    &#125;\n&#125;\nclass BiJiao implements Comparator&lt;Student&gt;&#123;\n    @Override\n    public int compare(Student o1, Student o2) &#123;\n        return o1.getName().compareTo(o2.getName());\n    &#125;\n&#125;\n</code></pre>\n<pre><code class=\"java\">public class Test03 &#123;\n    //这是main方法，程序的入口\n    public static void main(String[] args) &#123;\n        //创建一个TreeSet:\n        //利用外部比较器，必须自己制定：\n        Comparator&lt;Student&gt; com = new BiJiao();\n        TreeSet&lt;Student&gt; ts = new TreeSet&lt;&gt;(com);//一旦指定外部比较器，那么就会按照外部比较器来比较\n        ts.add(new Student(10,&quot;elili&quot;));\n        ts.add(new Student(8,&quot;blili&quot;));\n        ts.add(new Student(4,&quot;alili&quot;));\n        ts.add(new Student(9,&quot;elili&quot;));\n        ts.add(new Student(10,&quot;flili&quot;));\n        ts.add(new Student(1,&quot;dlili&quot;));\n        System.out.println(ts.size());\n        System.out.println(ts);\n    &#125;\n&#125;\n</code></pre>\n<p>实际开发中利用外部比较器多，因为扩展性好（多态）</p>\n<p>换一种写法：</p>\n<pre><code class=\"java\">public class Test03 &#123;\n    //这是main方法，程序的入口\n    public static void main(String[] args) &#123;\n        //创建一个TreeSet:\n        //利用外部比较器，必须自己制定：\n        /*Comparator&lt;Student&gt; com = new Comparator&lt;Student&gt;() &#123;\n            @Override\n            public int compare(Student o1, Student o2) &#123;\n                return o1.getName().compareTo(o2.getName());\n            &#125;\n        &#125;;*/\n        TreeSet&lt;Student&gt; ts = new TreeSet&lt;&gt;(new Comparator&lt;Student&gt;() &#123;\n            @Override\n            public int compare(Student o1, Student o2) &#123;\n                return o1.getName().compareTo(o2.getName());\n            &#125;\n        &#125;);//一旦指定外部比较器，那么就会按照外部比较器来比较\n        ts.add(new Student(10,&quot;elili&quot;));\n        ts.add(new Student(8,&quot;blili&quot;));\n        ts.add(new Student(4,&quot;alili&quot;));\n        ts.add(new Student(9,&quot;elili&quot;));\n        ts.add(new Student(10,&quot;flili&quot;));\n        ts.add(new Student(1,&quot;dlili&quot;));\n        System.out.println(ts.size());\n        System.out.println(ts);\n    &#125;\n&#125;\n</code></pre>\n<p>【5】TreeSet底层的二叉树的遍历是按照升序的结果出现的，这个升序是靠中序遍历得到的：</p>\n<img data-src=\"/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618174642838.png\" class=\"\">\n\n\n\n\n\n\n<h3 id=\"3-5-Collection部分整体结构图\"><a href=\"#3-5-Collection部分整体结构图\" class=\"headerlink\" title=\"3.5 Collection部分整体结构图\"></a>3.5 Collection部分整体结构图</h3><img data-src=\"/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618174657969.png\" class=\"\">\n\n\n\n\n\n\n<h1 id=\"Map接口\"><a href=\"#Map接口\" class=\"headerlink\" title=\"Map接口\"></a>Map接口</h1><h2 id=\"1-常用方法\"><a href=\"#1-常用方法\" class=\"headerlink\" title=\"1 常用方法\"></a>1 常用方法</h2><pre><code class=\"java\">package com.msb.test11;\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Set;\n/**\n * @author : msb-zhaoss\n */\npublic class Test01 &#123;\n    //这是main方法，程序的入口\n    public static void main(String[] args) &#123;\n        /*\n        增加：put(K key, V value)\n        删除：clear() remove(Object key)\n        修改：\n        查看：entrySet() get(Object key) keySet() size() values()\n        判断：containsKey(Object key) containsValue(Object value)\n            equals(Object o) isEmpty()\n         */\n        //创建一个Map集合：无序，唯一\n        Map&lt;String,Integer&gt; map = new HashMap&lt;&gt;();\n        System.out.println(map.put(&quot;lili&quot;, 10101010));\n        map.put(&quot;nana&quot;,12345234);\n        map.put(&quot;feifei&quot;,34563465);\n        System.out.println(map.put(&quot;lili&quot;, 34565677));\n        map.put(&quot;mingming&quot;,12323);\n        /*map.clear();清空*/\n        /*map.remove(&quot;feifei&quot;);移除*/\n        System.out.println(map.size());\n        System.out.println(map);\n        System.out.println(map.containsKey(&quot;lili&quot;));\n        System.out.println(map.containsValue(12323));\n        Map&lt;String,Integer&gt; map2 = new HashMap&lt;&gt;();\n        System.out.println(map2.put(&quot;lili&quot;, 10101010));\n        map2.put(&quot;nana&quot;,12345234);\n        map2.put(&quot;feifei&quot;,34563465);\n        System.out.println(map2.put(&quot;lili&quot;, 34565677));\n        map2.put(&quot;mingming2&quot;,12323);\n        System.out.println(map==map2);\n        System.out.println(map.equals(map2));//equals进行了重写，比较的是集合中的值是否一致\n        System.out.println(&quot;判断是否为空：&quot;+map.isEmpty());\n        System.out.println(map.get(&quot;nana&quot;));\n        System.out.println(&quot;-----------------------------------&quot;);\n        //keySet()对集合中的key进行遍历查看：\n        Set&lt;String&gt; set = map.keySet();\n        for(String s:set)&#123;\n            System.out.println(s);\n        &#125;\n        System.out.println(&quot;-----------------------------------&quot;);\n        //values()对集合中的value进行遍历查看：\n        Collection&lt;Integer&gt; values = map.values();\n        for(Integer i:values)&#123;\n            System.out.println(i);\n        &#125;\n        System.out.println(&quot;-----------------------------------&quot;);\n        //get(Object key) keySet()\n        Set&lt;String&gt; set2 = map.keySet();\n        for(String s:set2)&#123;\n            System.out.println(map.get(s));\n        &#125;\n        System.out.println(&quot;-----------------------------------&quot;);\n        //entrySet()\n        Set&lt;Map.Entry&lt;String, Integer&gt;&gt; entries = map.entrySet();\n        for(Map.Entry&lt;String, Integer&gt; e:entries)&#123;\n            System.out.println(e.getKey()+&quot;----&quot;+e.getValue());\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"2-TreeMap\"><a href=\"#2-TreeMap\" class=\"headerlink\" title=\"2 TreeMap\"></a>2 TreeMap</h2><p>【1】key的类型为String类型：</p>\n<pre><code class=\"java\">public class Test02 &#123;\n    //这是main方法，程序的入口\n    public static void main(String[] args) &#123;\n        Map&lt;String,Integer&gt; map = new TreeMap&lt;&gt;();\n        map.put(&quot;blili&quot;,1234);\n        map.put(&quot;alili&quot;,2345);\n        map.put(&quot;blili&quot;,5467);\n        map.put(&quot;clili&quot;,5678);\n        map.put(&quot;dlili&quot;,2345);\n        System.out.println(map.size());\n        System.out.println(map);\n    &#125;\n&#125;\n</code></pre>\n<p>【2】key的类型是一个自定义的引用数据类型：<br>（1）内部比较器：</p>\n<pre><code class=\"java\">public class Test03 &#123;\n    //这是main方法，程序的入口\n    public static void main(String[] args) &#123;\n        Map&lt;Student,Integer&gt; map = new TreeMap&lt;&gt;();\n        map.put(new Student(19,&quot;blili&quot;,170.5),1001);\n        map.put(new Student(18,&quot;blili&quot;,150.5),1003);\n        map.put(new Student(19,&quot;alili&quot;,180.5),1023);\n        map.put(new Student(17,&quot;clili&quot;,140.5),1671);\n        map.put(new Student(10,&quot;dlili&quot;,160.5),1891);\n        System.out.println(map);\n        System.out.println(map.size());\n    &#125;\n&#125;\n</code></pre>\n<pre><code class=\"java\">public class Student implements Comparable&lt;Student&gt;&#123;\n    private int age;\n    private String name;\n    private double height;\n    public int getAge() &#123;\n        return age;\n    &#125;\n    public void setAge(int age) &#123;\n        this.age = age;\n    &#125;\n    public String getName() &#123;\n        return name;\n    &#125;\n    public void setName(String name) &#123;\n        this.name = name;\n    &#125;\n    public double getHeight() &#123;\n        return height;\n    &#125;\n    public void setHeight(double height) &#123;\n        this.height = height;\n    &#125;\n    public Student(int age, String name, double height) &#123;\n        this.age = age;\n        this.name = name;\n        this.height = height;\n    &#125;\n    @Override\n    public String toString() &#123;\n        return &quot;Student&#123;&quot; +\n                &quot;age=&quot; + age +\n                &quot;, name=&#39;&quot; + name + &#39;\\&#39;&#39; +\n                &quot;, height=&quot; + height +\n                &#39;&#125;&#39;;\n    &#125;\n    @Override\n    public int compareTo(Student o) &#123;\n       /* return this.getAge()-o.getAge();*/\n        return this.getName().compareTo(o.getName());\n    &#125;\n&#125;\n</code></pre>\n<p>（2）外部比较器：</p>\n<pre><code class=\"java\">public class Test03 &#123;\n    //这是main方法，程序的入口\n    public static void main(String[] args) &#123;\n        Map&lt;Student,Integer&gt; map = new TreeMap&lt;&gt;(new Comparator&lt;Student&gt;() &#123;\n            @Override\n            public int compare(Student o1, Student o2) &#123;\n                return ((Double)(o1.getHeight())).compareTo((Double)(o2.getHeight()));\n            &#125;\n        &#125;);\n        map.put(new Student(19,&quot;blili&quot;,170.5),1001);\n        map.put(new Student(18,&quot;blili&quot;,150.5),1003);\n        map.put(new Student(19,&quot;alili&quot;,180.5),1023);\n        map.put(new Student(17,&quot;clili&quot;,140.5),1671);\n        map.put(new Student(10,&quot;dlili&quot;,160.5),1891);\n        System.out.println(map);\n        System.out.println(map.size());\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"3-Map部分整体结构图\"><a href=\"#3-Map部分整体结构图\" class=\"headerlink\" title=\"3 Map部分整体结构图\"></a>3 Map部分整体结构图</h2><img data-src=\"/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618174919194.png\" class=\"\">\n\n\n<h2 id=\"4-源码部分\"><a href=\"#4-源码部分\" class=\"headerlink\" title=\"4 源码部分\"></a>4 源码部分</h2><h3 id=\"4-1-HashMap\"><a href=\"#4-1-HashMap\" class=\"headerlink\" title=\"4.1 HashMap\"></a>4.1 HashMap</h3><h4 id=\"4-1-1-代码展示特性\"><a href=\"#4-1-1-代码展示特性\" class=\"headerlink\" title=\"4.1.1 代码展示特性\"></a>4.1.1 代码展示特性</h4><pre><code class=\"java\">public class Test &#123;\n    //这是main方法，程序的入口\n    public static void main(String[] args) &#123;\n        //JDK1.7以后支持后面的&lt;&gt;中内容可以不写\n        HashMap&lt;Integer,String&gt; hm = new HashMap&lt;&gt;();\n        System.out.println(hm.put(12,&quot;丽丽&quot;));\n        System.out.println(hm.put(7,&quot;菲菲&quot;));\n        System.out.println(hm.put(19,&quot;露露&quot;));\n        System.out.println(hm.put(12,&quot;明明&quot;));\n        System.out.println(hm.put(6,&quot;莹莹&quot;));\n        System.out.println(&quot;集合的长度：&quot;+hm.size());\n        System.out.println(&quot;集合中内容查看：&quot;+hm);\n    &#125;\n&#125;\n</code></pre>\n<p>结果展示：</p>\n<img data-src=\"/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618175455959.png\" class=\"\">\n\n\n\n\n\n\n<h4 id=\"4-1-2-先演示原理\"><a href=\"#4-1-2-先演示原理\" class=\"headerlink\" title=\"4.1.2 先演示原理\"></a>4.1.2 先演示原理</h4><p>先演示原理图，再看源码，直接看的话，有的人接不上就蒙了：<br>相当于先看原理，然后从源码中验证这个原理是否正确：把图搞懂了，就是事倍功半的效果<br>原理如下：(JDK1.7)</p>\n<img data-src=\"/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618175512371.png\" class=\"\">\n\n\n\n\n\n\n<h4 id=\"4-1-3-源码（JDK1-7版本）\"><a href=\"#4-1-3-源码（JDK1-7版本）\" class=\"headerlink\" title=\"4.1.3 源码（JDK1.7版本）\"></a>4.1.3 源码（JDK1.7版本）</h4><pre><code class=\"java\">public class HashMap&lt;K,V&gt;\n    extends AbstractMap&lt;K,V&gt; //【1】继承的AbstractMap中，已经实现了Map接口\n        //【2】又实现了这个接口，多余，但是设计者觉得没有必要删除，就这么地了\n    implements Map&lt;K,V&gt;, Cloneable, Serializable&#123;\n                \n                \n        //【3】后续会用到的重要属性：先粘贴过来：\n    static final int DEFAULT_INITIAL_CAPACITY = 16;//哈希表主数组的默认长度\n        //定义了一个float类型的变量，以后作为：默认的装填因子，加载因子是表示Hsah表中元素的填满的程度\n        //太大容易引起哈西冲突，太小容易浪费  0.75是经过大量运算后得到的最好值\n        //这个值其实可以自己改，但是不建议改，因为这个0.75是大量运算得到的\n        static final float DEFAULT_LOAD_FACTOR = 0.75f;\n        transient Entry&lt;K,V&gt;[] table;//主数组,每个元素为Entry类型\n        transient int size;\n        int threshold;//数组扩容的界限值,门槛值   16*0.75=12 \n        final float loadFactor;//用来接收装填因子的变量\n        \n        //【4】查看构造器：内部相当于：this(16,0.75f);调用了当前类中的带参构造器\n        public HashMap() &#123;\n        this(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR);\n    &#125;\n        //【5】本类中带参数构造器：--》作用给一些数值进行初始化的！\n        public HashMap(int initialCapacity, float loadFactor) &#123;\n        //【6】给capacity赋值，capacity的值一定是 大于你传进来的initialCapacity 的 最小的 2的倍数\n        int capacity = 1;\n        while (capacity &lt; initialCapacity)\n            capacity &lt;&lt;= 1;\n                //【7】给loadFactor赋值，将装填因子0.75赋值给loadFactor\n        this.loadFactor = loadFactor;\n                //【8】数组扩容的界限值,门槛值\n        threshold = (int)Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + 1);\n                \n                //【9】给table数组赋值，初始化数组长度为16\n        table = new Entry[capacity];\n                   \n    &#125;\n        //【10】调用put方法：\n        public V put(K key, V value) &#123;\n                //【11】对空值的判断\n        if (key == null)\n            return putForNullKey(value);\n                //【12】调用hash方法，获取哈希码\n        int hash = hash(key);\n                //【14】得到key对应在数组中的位置\n        int i = indexFor(hash, table.length);\n                //【16】如果你放入的元素，在主数组那个位置上没有值，e==null  那么下面这个循环不走\n                //当在同一个位置上放入元素的时候\n        for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123;\n            Object k;\n                        //哈希值一样  并且  equals相比一样   \n                        //(k = e.key) == key  如果是一个对象就不用比较equals了\n            if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;\n                V oldValue = e.value;\n                e.value = value;\n                e.recordAccess(this);\n                return oldValue;\n            &#125;\n        &#125;\n        modCount++;\n                //【17】走addEntry添加这个节点的方法：\n        addEntry(hash, key, value, i);\n        return null;\n    &#125;\n        \n        //【13】hash方法返回这个key对应的哈希值，内部进行二次散列，为了尽量保证不同的key得到不同的哈希码！\n        final int hash(Object k) &#123;\n        int h = 0;\n        if (useAltHashing) &#123;\n            if (k instanceof String) &#123;\n                return sun.misc.Hashing.stringHash32((String) k);\n            &#125;\n            h = hashSeed;\n        &#125;\n                //k.hashCode()函数调用的是key键值类型自带的哈希函数，\n                //由于不同的对象其hashCode()有可能相同，所以需对hashCode()再次哈希，以降低相同率。\n        h ^= k.hashCode();\n        // This function ensures that hashCodes that differ only by\n        // constant multiples at each bit position have a bounded\n        // number of collisions (approximately 8 at default load factor).\n                /*\n                接下来的一串与运算和异或运算，称之为“扰动函数”，\n                扰动的核心思想在于使计算出来的值在保留原有相关特性的基础上，\n                增加其值的不确定性，从而降低冲突的概率。\n                不同的版本实现的方式不一样，但其根本思想是一致的。\n                往右移动的目的，就是为了将h的高位利用起来，减少哈西冲突\n                */\n        h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12);\n        return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);\n    &#125;\n        //【15】返回int类型数组的坐标\n        static int indexFor(int h, int length) &#123;\n                //其实这个算法就是取模运算：h%length，取模效率不如位运算\n        return h &amp; (length-1);\n    &#125;\n        //【18】调用addEntry\n        void addEntry(int hash, K key, V value, int bucketIndex) &#123;\n                //【25】size的大小  大于 16*0.75=12的时候，比如你放入的是第13个，这第13个你打算放在没有元素的位置上的时候\n        if ((size &gt;= threshold) &amp;&amp; (null != table[bucketIndex])) &#123;\n                        //【26】主数组扩容为2倍\n            resize(2 * table.length);\n                        //【30】重新调整当前元素的hash码\n            hash = (null != key) ? hash(key) : 0;\n                        //【31】重新计算元素位置\n            bucketIndex = indexFor(hash, table.length);\n        &#125;\n                //【19】将hash,key,value,bucketIndex位置  封装为一个Entry对象：\n        createEntry(hash, key, value, bucketIndex);\n    &#125;\n        //【20】\n        void createEntry(int hash, K key, V value, int bucketIndex) &#123;\n                //【21】获取bucketIndex位置上的元素给e\n        Entry&lt;K,V&gt; e = table[bucketIndex];\n                //【22】然后将hash, key, value封装为一个对象，然后将下一个元素的指向为e （链表的头插法）\n                //【23】将新的Entry放在table[bucketIndex]的位置上\n        table[bucketIndex] = new Entry&lt;&gt;(hash, key, value, e);\n                //【24】集合中加入一个元素 size+1\n        size++;\n    &#125;\n    //【27】\n        void resize(int newCapacity) &#123;\n        Entry[] oldTable = table;\n        int oldCapacity = oldTable.length;\n        if (oldCapacity == MAXIMUM_CAPACITY) &#123;\n            threshold = Integer.MAX_VALUE;\n            return;\n        &#125;\n                //【28】创建长度为newCapacity的数组\n        Entry[] newTable = new Entry[newCapacity];\n        boolean oldAltHashing = useAltHashing;\n        useAltHashing |= sun.misc.VM.isBooted() &amp;&amp;\n                (newCapacity &gt;= Holder.ALTERNATIVE_HASHING_THRESHOLD);\n        boolean rehash = oldAltHashing ^ useAltHashing;\n                //【28.5】转让方法：将老数组中的东西都重新放入新数组中\n        transfer(newTable, rehash);\n                //【29】老数组替换为新数组\n        table = newTable;\n                //【29.5】重新计算\n        threshold = (int)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + 1);\n    &#125;\n        //【28.6】\n        void transfer(Entry[] newTable, boolean rehash) &#123;\n        int newCapacity = newTable.length;\n        for (Entry&lt;K,V&gt; e : table) &#123;\n            while(null != e) &#123;\n                Entry&lt;K,V&gt; next = e.next;\n                if (rehash) &#123;\n                    e.hash = null == e.key ? 0 : hash(e.key);\n                &#125;\n                                //【28.7】将哈希值，和新的数组容量传进去，重新计算key在新数组中的位置\n                int i = indexFor(e.hash, newCapacity);\n                                //【28.8】头插法\n                e.next = newTable[i];//获取链表上元素给e.next\n                newTable[i] = e;//然后将e放在i位置 \n                e = next;//e再指向下一个节点继续遍历\n            &#125;\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<h4 id=\"4-1-4-细节讲解：主数组的长度为2的倍数\"><a href=\"#4-1-4-细节讲解：主数组的长度为2的倍数\" class=\"headerlink\" title=\"4.1.4  细节讲解：主数组的长度为2的倍数\"></a>4.1.4  细节讲解：主数组的长度为2的倍数</h4><p>【1】主数组的长度为2的倍数，</p>\n<img data-src=\"/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618175628889.png\" class=\"\">\n\n\n<p>因为这个length的长度，会影响 key的位置：<br>key的位置的计算：</p>\n<img data-src=\"/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618175638657.png\" class=\"\">\n\n\n\n\n<p>实际上这个算法就是：  h%length   ,但是取模的话  效率太低，所以用位运算效率会很高。</p>\n<p><strong>原因1：</strong><br><img data-src=\"/img/image-20220618175703663.png\" alt=\"image-20220618175703663\">和<img data-src=\"/img/image-20220618175712379.png\" alt=\"image-20220618175712379\">等效的前提就是  length必须是2的整数倍<br><strong>原因2：</strong></p>\n<p>如果不是2的整数倍，那么 哈西碰撞 哈西冲突的概率就高了很多</p>\n<p>位运算 就  涉及  到  length是不是2的整数倍：<br>比如是2的整数倍：</p>\n<img data-src=\"/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618175753914.png\" class=\"\">\n\n\n<img data-src=\"/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618175800521.png\" class=\"\">\n\n\n<p>并且这个得到的索引值，一定在 0-15之间（数组是16的时候）：</p>\n<img data-src=\"/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618175840905.png\" class=\"\">\n\n\n<p>当然如果你扩容后数组长度为 32，那么这个索引就在0-31之间</p>\n<p>比如如果不是2的整数倍：</p>\n<img data-src=\"/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618175850530.png\" class=\"\">\n\n\n<p>发现：如果不是2的整数倍，那么 哈西碰撞 哈西冲突的概率就高了很多</p>\n<h4 id=\"4-1-5-细节讲解：装填因子0-75的原因\"><a href=\"#4-1-5-细节讲解：装填因子0-75的原因\" class=\"headerlink\" title=\"4.1.5 细节讲解：装填因子0.75的原因\"></a>4.1.5 细节讲解：装填因子0.75的原因</h4><p>如果装填因子是1， 那么数组满了再扩容，可以做到  最大的空间利用率<br>但是这是一个理想状态，元素不可能完全的均匀分布，很可能就哈西碰撞产生链表了。产生链表的话 查询时间就长了。<br>—》空间好，时间不好</p>\n<p>那么有人说 ，把装填因子搞小一点，0.5，  如果是0.5的话，就浪费空间，但是可以做到 到0.5就扩容 ，然后哈西碰撞就少，<br>不产生链表的话，那么查询效率很高<br>—》时间好，空间不好</p>\n<p>所以在空间和时间中，<br>取中间值，平衡这个因素 就取值为 0.75</p>\n<img data-src=\"/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618175921895.png\" class=\"\">\n\n\n<p><strong>1.8版本</strong></p>\n<h2 id=\"1-8底层遵照-哈希表结构-红黑树\"><a href=\"#1-8底层遵照-哈希表结构-红黑树\" class=\"headerlink\" title=\"1.8底层遵照 哈希表结构 + 红黑树\"></a>1.8底层遵照 <font color=red >哈希表结构 + 红黑树</font></h2><pre><code class=\"java\">// HashMap&lt;String,Integer&gt; map = new HashMap&lt;&gt;(); --&gt;JDK 1.7开始类型推断，后面用钻石运算符即可。\npublic class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; \t\t//【1】继承的AbstractMap中，已经实现了Map接口\n    implements Map&lt;K,V&gt;, Cloneable, Serializable &#123; //【2】又实现了这个接口，多余，但是集合的设计者觉得没有必要删除，就这么地了\n\n    //------------------属性部分：\n    final float loadFactor;//【3-2】用来接收装填因子的变量\n    /*\n        【3-3】\n        定义了一个float类型的变量，以后作为：默认的装填因子，加载因子是表示Hsah表中元素的填满的程度\n        太大容易引起哈西冲突，太小容易浪费  0.75是经过大量运算后得到的最好值\n        这个值其实可以自己改，但是不建议改，因为这个0.75是大量运算得到的\n    */\n    static final float DEFAULT_LOAD_FACTOR = 0.75f;\n    int threshold;//【6-3】数组扩容的界限值,门槛值\n    transient Node&lt;K,V&gt;[] table;//【7-5】底层主数组\n    //------------------构造器：\n    //【3】调用空构造器\n    public HashMap() &#123;\n        //【3-1】给装填因子loadFactor赋值\n        this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted\n    &#125;\n    \n    //【4】调用有参构造器：\n    public HashMap(int initialCapacity) &#123;\n        //【5】调用两个参数构造器\n        this(initialCapacity, DEFAULT_LOAD_FACTOR);\n    &#125;\n    //【6】\n    public HashMap(int initialCapacity, float loadFactor) &#123;\n        //【6-1】健壮性考虑，传入的数据过小不行，过大不行\n        if (initialCapacity &lt; 0)\n            throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; +\n                                               initialCapacity);\n        if (initialCapacity &gt; MAXIMUM_CAPACITY)\n            initialCapacity = MAXIMUM_CAPACITY;\n        if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))\n            throw new IllegalArgumentException(&quot;Illegal load factor: &quot; +\n                                               loadFactor);\n        //【6-2】给装填因子loadFactor赋值，赋值为0.75，这个值可以单独传入改变，但是不建议改变，一般都用默认的0.75\n        this.loadFactor = loadFactor;\n        //【6-3】给threshold赋值 \n        this.threshold = tableSizeFor(initialCapacity);\n    &#125;\n    //【6-4】返回的是大于initialCapacity的最接近的2的整数倍  ，比如initialCapacity传入10，这个方法返回16\n    static final int tableSizeFor(int cap) &#123;//（内部内容讲源码时候不用管，面试题中详讲）\n        int n = cap - 1;\n        n |= n &gt;&gt;&gt; 1;\n        n |= n &gt;&gt;&gt; 2;\n        n |= n &gt;&gt;&gt; 4;\n        n |= n &gt;&gt;&gt; 8;\n        n |= n &gt;&gt;&gt; 16;\n        return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;\n    &#125;\n    \n    //------------------方法：\n    //【7】调用put方法\n    public V put(K key, V value) &#123;\n        //【7-1】首先调用hash方法计算哈希值：\n        //【7-3】调用putVal方法传入五个参数：\n        return putVal(hash(key), key, value, false, true);\n    &#125;\n    //【7-2】计算hash值\n    static final int hash(Object key) &#123;\n        int h;\n        return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);\n    &#125;\n    //【7-4】调用\n    final V putVal(int hash, K key, V value, boolean onlyIfAbsent,\n                   boolean evict) &#123;\n        Node&lt;K,V&gt;[] tab;\n        Node&lt;K,V&gt; p; \n        int n, i;\n        //【7-6】将底层主数组table给tab，判断是否为null，第一次放数据一定是null\n        if ((tab = table) == null || (n = tab.length) == 0)\n            //【7-7】走入if分支：table是null，就对table进行扩容，走进resize方法\n            n = (tab = resize()).length;//【7-21】table的length为16 ，n为16\n        /*\n        【7-22】\n        i = (n - 1) &amp; hash 根据哈希值和n计算放入数组的位置\n        取出这个位置上的元素，看是否为空，如果是第一个元素，一定是null\n        */\n        if ((p = tab[i = (n - 1) &amp; hash]) == null)\n            //【7-23】在这个位置上将元素封装为Node对象，放入对应位置\n            tab[i] = newNode(hash, key, value, null);//封装Node节点new Node&lt;&gt;(hash, key, value, null);\n        else &#123;\n            Node&lt;K,V&gt; e; K k;\n            if (p.hash == hash &amp;&amp;\n                ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))\n                e = p;\n            else if (p instanceof TreeNode)\n                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);\n            else &#123;\n                for (int binCount = 0; ; ++binCount) &#123;\n                    if ((e = p.next) == null) &#123;\n                        p.next = newNode(hash, key, value, null);\n                        if (binCount &gt;= TREEIFY_THRESHOLD - 1)  \n                            treeifyBin(tab, hash);\n                        break;\n                    &#125;\n                    if (e.hash == hash &amp;&amp;\n                        ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))\n                        break;\n                    p = e;\n                &#125;\n            &#125;\n            if (e != null) &#123;  \n                V oldValue = e.value;\n                if (!onlyIfAbsent || oldValue == null)\n                    e.value = value;\n                afterNodeAccess(e);\n                return oldValue;\n            &#125;\n        &#125;\n        ++modCount;\n        //【7-25】size指的是放入集合的键值总数，size++操作，不大于threshold，resize方法不走\n        if (++size &gt; threshold)\n            resize();\n        afterNodeInsertion(evict);\n        return null;\n    &#125;\n    //【7-8】resize方法：---》假设最开始走的是HashMap的空构造器：\n    final Node&lt;K,V&gt;[] resize() &#123;\n        Node&lt;K,V&gt;[] oldTab = table;//【7-9】table 是null\n        int oldCap = (oldTab == null) ? 0 : oldTab.length; //【7-10】oldCap:0\n        int oldThr = threshold;//【7-11】threshold为16，oldThr：16\n        int newCap, newThr = 0;\n        if (oldCap &gt; 0) &#123;//【7-12】不走\n            if (oldCap &gt;= MAXIMUM_CAPACITY) &#123;\n                threshold = Integer.MAX_VALUE;\n                return oldTab;\n            &#125;\n            else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;\n                     oldCap &gt;= DEFAULT_INITIAL_CAPACITY)\n                newThr = oldThr &lt;&lt; 1;\n        &#125;\n        else if (oldThr &gt; 0)  //【7-13】走\n            newCap = oldThr;//newCap=16\n        else &#123;               //【7-14】不走\n             \n            newCap = DEFAULT_INITIAL_CAPACITY;\n             \n            newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);\n        &#125;\n        if (newThr == 0) &#123;//【7-15】走\n            float ft = (float)newCap * loadFactor;//【7-16】ft: 16*0.75=12\n            newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?\n                      (int)ft : Integer.MAX_VALUE); //【7-17】newThr = 12\n        &#125;\n        //【7-18】threshold赋值为newThr为12， ---》所以走空构造器这里threshold赋值为12，走有参构造器里面threshold赋值为12？？？？\n        threshold = newThr;\n        @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)\n        //【7-19】创建Node数组，长度为newCap16\n            Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];\n        //【7-20】table赋值为newTab\n        table = newTab;\n        if (oldTab != null) &#123;\n            for (int j = 0; j &lt; oldCap; ++j) &#123;\n                Node&lt;K,V&gt; e;\n                if ((e = oldTab[j]) != null) &#123;\n                    oldTab[j] = null;\n                    if (e.next == null)\n                        newTab[e.hash &amp; (newCap - 1)] = e;\n                    else if (e instanceof TreeNode)\n                        ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);\n                    else &#123; \n                        Node&lt;K,V&gt; loHead = null, loTail = null;\n                        Node&lt;K,V&gt; hiHead = null, hiTail = null;\n                        Node&lt;K,V&gt; next;\n                        do &#123;\n                            next = e.next;\n                            if ((e.hash &amp; oldCap) == 0) &#123;\n                                if (loTail == null)\n                                    loHead = e;\n                                else\n                                    loTail.next = e;\n                                loTail = e;\n                            &#125;\n                            else &#123;\n                                if (hiTail == null)\n                                    hiHead = e;\n                                else\n                                    hiTail.next = e;\n                                hiTail = e;\n                            &#125;\n                        &#125; while ((e = next) != null);\n                        if (loTail != null) &#123;\n                            loTail.next = null;\n                            newTab[j] = loHead;\n                        &#125;\n                        if (hiTail != null) &#123;\n                            hiTail.next = null;\n                            newTab[j + oldCap] = hiHead;\n                        &#125;\n                    &#125;\n                &#125;\n            &#125;\n        &#125;\n        return newTab;\n    &#125;\n&#125;\n</code></pre>\n<pre><code class=\"java\">public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; \n    implements Map&lt;K,V&gt;, Cloneable, Serializable &#123; \n    final float loadFactor;\n    static final float DEFAULT_LOAD_FACTOR = 0.75f;\n    int threshold;\n    transient Node&lt;K,V&gt;[] table;\n    public HashMap() &#123;\n        this.loadFactor = DEFAULT_LOAD_FACTOR; \n    &#125;\n    \n    public HashMap(int initialCapacity) &#123;\n        this(initialCapacity, DEFAULT_LOAD_FACTOR);\n    &#125;\n    public HashMap(int initialCapacity, float loadFactor) &#123;\n        if (initialCapacity &lt; 0)\n            throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; +\n                                               initialCapacity);\n        if (initialCapacity &gt; MAXIMUM_CAPACITY)\n            initialCapacity = MAXIMUM_CAPACITY;\n        if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))\n            throw new IllegalArgumentException(&quot;Illegal load factor: &quot; +\n                                               loadFactor);\n        this.loadFactor = loadFactor;\n        this.threshold = tableSizeFor(initialCapacity);\n    &#125;\n    static final int tableSizeFor(int cap) &#123;\n        int n = cap - 1;\n        n |= n &gt;&gt;&gt; 1;\n        n |= n &gt;&gt;&gt; 2;\n        n |= n &gt;&gt;&gt; 4;\n        n |= n &gt;&gt;&gt; 8;\n        n |= n &gt;&gt;&gt; 16;\n        return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;\n    &#125;\n    \n    //【8-1】put方法\n    public V put(K key, V value) &#123;\n        //计算hash值\n        return putVal(hash(key), key, value, false, true);\n    &#125;\n\n    static final int hash(Object key) &#123;\n        int h;\n        return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);\n    &#125;\n    //【8-2】调用putVal方法\n    final V putVal(int hash, K key, V value, boolean onlyIfAbsent,\n                   boolean evict) &#123;\n        Node&lt;K,V&gt;[] tab;\n        Node&lt;K,V&gt; p; \n        int n, i;\n        \n        //【8-3】table不空了，不走if\t\t\n        if ((tab = table) == null || (n = tab.length) == 0)\n            n = (tab = resize()).length;\n        //【8-4】tab[i]不null，不走if\n        if ((p = tab[i = (n - 1) &amp; hash]) == null)\n            tab[i] = newNode(hash, key, value, null);\n        else &#123;\n            Node&lt;K,V&gt; e; K k;\n            /*\n                【8-5】\n                判断p.hash == hash哈希值是否相等，即使hash相等也要做&amp;&amp;后续的判断，因为两个对象哈希值相等是有可能的\n                (k = p.key) == key   == 比较地址值，String的话一样，不是字符串地址也不一样，\n                Animal a1 = new Animal(19);\t\t和 \tAnimal a2 = new Animal(19);\t地址一定不同，就需要用后面的equals进行比较\n            */\n            if (p.hash == hash &amp;&amp;\n                ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))   //----》哈希值相等，出现哈西碰撞\n                //【8-6】将该数组位置的数据给e\n                e = p;\n            else if (p instanceof TreeNode)\n                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);\n            else &#123;\n                for (int binCount = 0; ; ++binCount) &#123;\n                    if ((e = p.next) == null) &#123;\n                        p.next = newNode(hash, key, value, null);\n                        if (binCount &gt;= TREEIFY_THRESHOLD - 1)  \n                            treeifyBin(tab, hash);\n                        break;\n                    &#125;\n                    if (e.hash == hash &amp;&amp;\n                        ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))\n                        break;\n                    p = e;\n                &#125;\n            &#125;\n            if (e != null) &#123;  \n                V oldValue = e.value;\n                if (!onlyIfAbsent || oldValue == null)\n                    e.value = value;//【8-7】新value替换老value\n                afterNodeAccess(e);\n                return oldValue;//【8-8】返回老value\n            &#125;\n        &#125;\n        ++modCount;\n\n        if (++size &gt; threshold)\n            resize();\n        afterNodeInsertion(evict);\n        return null;\n    &#125;\n\n    final Node&lt;K,V&gt;[] resize() &#123;\n        Node&lt;K,V&gt;[] oldTab = table;\n        int oldCap = (oldTab == null) ? 0 : oldTab.length; \n        int oldThr = threshold;\n        int newCap, newThr = 0;\n        if (oldCap &gt; 0) &#123;\n            if (oldCap &gt;= MAXIMUM_CAPACITY) &#123;\n                threshold = Integer.MAX_VALUE;\n                return oldTab;\n            &#125;\n            else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;\n                     oldCap &gt;= DEFAULT_INITIAL_CAPACITY)\n                newThr = oldThr &lt;&lt; 1;\n        &#125;\n        else if (oldThr &gt; 0) \n            newCap = oldThr;\n        else &#123;    \n            newCap = DEFAULT_INITIAL_CAPACITY;\n            newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);\n        &#125;\n        if (newThr == 0) &#123;\n            float ft = (float)newCap * loadFactor;\n            newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?\n                      (int)ft : Integer.MAX_VALUE);\n        &#125;\n        threshold = newThr;\n        @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)\n            Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];\n        table = newTab;\n        if (oldTab != null) &#123;\n            for (int j = 0; j &lt; oldCap; ++j) &#123;\n                Node&lt;K,V&gt; e;\n                if ((e = oldTab[j]) != null) &#123;\n                    oldTab[j] = null;\n                    if (e.next == null)\n                        newTab[e.hash &amp; (newCap - 1)] = e;\n                    else if (e instanceof TreeNode)\n                        ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);\n                    else &#123; \n                        Node&lt;K,V&gt; loHead = null, loTail = null;\n                        Node&lt;K,V&gt; hiHead = null, hiTail = null;\n                        Node&lt;K,V&gt; next;\n                        do &#123;\n                            next = e.next;\n                            if ((e.hash &amp; oldCap) == 0) &#123;\n                                if (loTail == null)\n                                    loHead = e;\n                                else\n                                    loTail.next = e;\n                                loTail = e;\n                            &#125;\n                            else &#123;\n                                if (hiTail == null)\n                                    hiHead = e;\n                                else\n                                    hiTail.next = e;\n                                hiTail = e;\n                            &#125;\n                        &#125; while ((e = next) != null);\n                        if (loTail != null) &#123;\n                            loTail.next = null;\n                            newTab[j] = loHead;\n                        &#125;\n                        if (hiTail != null) &#123;\n                            hiTail.next = null;\n                            newTab[j + oldCap] = hiHead;\n                        &#125;\n                    &#125;\n                &#125;\n            &#125;\n        &#125;\n        return newTab;\n    &#125;\n&#125;\n</code></pre>\n<pre><code class=\"java\">public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; \n    implements Map&lt;K,V&gt;, Cloneable, Serializable &#123; \n    final float loadFactor;\n    static final float DEFAULT_LOAD_FACTOR = 0.75f;\n    int threshold;\n    transient Node&lt;K,V&gt;[] table;\n    public HashMap() &#123;\n        this.loadFactor = DEFAULT_LOAD_FACTOR; \n    &#125;\n    \n    public HashMap(int initialCapacity) &#123;\n        this(initialCapacity, DEFAULT_LOAD_FACTOR);\n    &#125;\n    public HashMap(int initialCapacity, float loadFactor) &#123;\n        if (initialCapacity &lt; 0)\n            throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; +\n                                               initialCapacity);\n        if (initialCapacity &gt; MAXIMUM_CAPACITY)\n            initialCapacity = MAXIMUM_CAPACITY;\n        if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))\n            throw new IllegalArgumentException(&quot;Illegal load factor: &quot; +\n                                               loadFactor);\n        this.loadFactor = loadFactor;\n        this.threshold = tableSizeFor(initialCapacity);\n    &#125;\n    static final int tableSizeFor(int cap) &#123;\n        int n = cap - 1;\n        n |= n &gt;&gt;&gt; 1;\n        n |= n &gt;&gt;&gt; 2;\n        n |= n &gt;&gt;&gt; 4;\n        n |= n &gt;&gt;&gt; 8;\n        n |= n &gt;&gt;&gt; 16;\n        return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;\n    &#125;\n    \n    //【9-1】put方法\n    public V put(K key, V value) &#123;\n        //计算hash值\n        return putVal(hash(key), key, value, false, true);\n    &#125;\n\n    static final int hash(Object key) &#123;\n        int h;\n        return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);\n    &#125;\n    //【9-2】调用putVal方法\n    final V putVal(int hash, K key, V value, boolean onlyIfAbsent,\n                   boolean evict) &#123;\n        Node&lt;K,V&gt;[] tab;\n        Node&lt;K,V&gt; p; \n        int n, i;\n        \n        //【9-3】table不空了，不走if\t\t\n        if ((tab = table) == null || (n = tab.length) == 0)\n            n = (tab = resize()).length;\n        //【9-4】tab[i]不null，不走if\n        if ((p = tab[i = (n - 1) &amp; hash]) == null)\n            tab[i] = newNode(hash, key, value, null);\n        else &#123;\n            Node&lt;K,V&gt; e; K k;\n            /*\n                【9-5】\n                判断p.hash == hash哈希值是否相等，即使hash相等也要做&amp;&amp;后续的判断，因为两个对象哈希值相等是有可能的\n                此时“通话”和“重地”的哈希值一致，但是key不一致，if不走\n            */\n            if (p.hash == hash &amp;&amp;\n                ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))\n                e = p;\n            else if (p instanceof TreeNode)//【9-6】p也不是红黑树，不走if\n                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);\n            else &#123;\n                //【9-7】走到这里，证明数组的这个位置是个链表了\n                for (int binCount = 0; ; ++binCount) &#123;//【9-8】无条件的死循环   binCount 链表上节点的个数\n                    //随着循环  p.next就是一路找链上元素\n                    //p.next要是没有元素，就要开始追加了呗\n                    if ((e = p.next) == null) &#123;//【9-10】一路next比较都没有key相同的数据\n                    \n                        p.next = newNode(hash, key, value, null);//【9-11】追加在链表尾部 ---》 前七后八\n                        //【9-12】如果节点个数大于8，进行树化：要从链表转为红黑树\n                        if (binCount &gt;= TREEIFY_THRESHOLD - 1)  \n                            treeifyBin(tab, hash);//【9-13】这里还涉及 剪枝 问题，树节点在6个以下，就又变成链表了\n                        break;\n                    &#125;\n                    //【9-9】比较过程中：如果比较链表某个key相同，就break结束了，不用继续走了\n                    if (e.hash == hash &amp;&amp;\n                        ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))\n                        break;\n                    p = e;\n                &#125;\n            &#125;\n            if (e != null) &#123;  \n                V oldValue = e.value;\n                if (!onlyIfAbsent || oldValue == null)\n                    e.value = value;//【8-7】新value替换老value\n                afterNodeAccess(e);\n                return oldValue;//【8-8】返回老value\n            &#125;\n        &#125;\n        ++modCount;\n\n        if (++size &gt; threshold)\n            resize();\n        afterNodeInsertion(evict);\n        return null;\n    &#125;\n\n    final Node&lt;K,V&gt;[] resize() &#123;\n        Node&lt;K,V&gt;[] oldTab = table;\n        int oldCap = (oldTab == null) ? 0 : oldTab.length; \n        int oldThr = threshold;\n        int newCap, newThr = 0;\n        if (oldCap &gt; 0) &#123;\n            if (oldCap &gt;= MAXIMUM_CAPACITY) &#123;\n                threshold = Integer.MAX_VALUE;\n                return oldTab;\n            &#125;\n            else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;\n                     oldCap &gt;= DEFAULT_INITIAL_CAPACITY)\n                newThr = oldThr &lt;&lt; 1;\n        &#125;\n        else if (oldThr &gt; 0) \n            newCap = oldThr;\n        else &#123;    \n            newCap = DEFAULT_INITIAL_CAPACITY;\n            newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);\n        &#125;\n        if (newThr == 0) &#123;\n            float ft = (float)newCap * loadFactor;\n            newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?\n                      (int)ft : Integer.MAX_VALUE);\n        &#125;\n        threshold = newThr;\n        @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)\n            Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];\n        table = newTab;\n        if (oldTab != null) &#123;\n            for (int j = 0; j &lt; oldCap; ++j) &#123;\n                Node&lt;K,V&gt; e;\n                if ((e = oldTab[j]) != null) &#123;\n                    oldTab[j] = null;\n                    if (e.next == null)\n                        newTab[e.hash &amp; (newCap - 1)] = e;\n                    else if (e instanceof TreeNode)\n                        ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);\n                    else &#123; \n                        Node&lt;K,V&gt; loHead = null, loTail = null;\n                        Node&lt;K,V&gt; hiHead = null, hiTail = null;\n                        Node&lt;K,V&gt; next;\n                        do &#123;\n                            next = e.next;\n                            if ((e.hash &amp; oldCap) == 0) &#123;\n                                if (loTail == null)\n                                    loHead = e;\n                                else\n                                    loTail.next = e;\n                                loTail = e;\n                            &#125;\n                            else &#123;\n                                if (hiTail == null)\n                                    hiHead = e;\n                                else\n                                    hiTail.next = e;\n                                hiTail = e;\n                            &#125;\n                        &#125; while ((e = next) != null);\n                        if (loTail != null) &#123;\n                            loTail.next = null;\n                            newTab[j] = loHead;\n                        &#125;\n                        if (hiTail != null) &#123;\n                            hiTail.next = null;\n                            newTab[j + oldCap] = hiHead;\n                        &#125;\n                    &#125;\n                &#125;\n            &#125;\n        &#125;\n        return newTab;\n    &#125;\n&#125;\n</code></pre>\n<p><strong>总结：</strong></p>\n<p>默认<strong>数组长度为16</strong>，<strong>最大程度${2^{30}}$</strong>,<strong>负载因子为0.75</strong>，扩容时<strong>扩大2倍</strong>，</p>\n<p>1.8比1.7改变了底层数据结构而已</p>\n<h4 id=\"4-1-6-HashSet底层原理\"><a href=\"#4-1-6-HashSet底层原理\" class=\"headerlink\" title=\"4.1.6 HashSet底层原理\"></a>4.1.6 HashSet底层原理</h4><pre><code class=\"java\">public class HashSet&lt;E&gt;&#123;\n    //重要属性：\n    private transient HashMap&lt;E,Object&gt; map;\n    private static final Object PRESENT = new Object();\n    //构造器：\n    public HashSet() &#123;\n        map = new HashMap&lt;&gt;();//HashSet底层就是利用HashMap来完成的\n    &#125;\n        \n    public boolean add(E e) &#123;\n        return map.put(e, PRESENT)==null;\n    &#125;      \n&#125;\n</code></pre>\n<h3 id=\"4-2TreeMap\"><a href=\"#4-2TreeMap\" class=\"headerlink\" title=\"4.2TreeMap\"></a>4.2TreeMap</h3><p>【1】原理大致介绍：</p>\n<img data-src=\"/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618175955956.png\" class=\"\">\n\n\n<p>【2】源码：</p>\n<pre><code class=\"java\">public class TreeMap&lt;K,V&gt;&#123;\n        //重要属性：\n        //外部比较器：\n        private final Comparator&lt;? super K&gt; comparator;\n        //树的根节点：\n        private transient Entry&lt;K,V&gt; root = null;\n        //集合中元素的数量：\n        private transient int size = 0;\n        //空构造器:\n        public TreeMap() &#123;\n        comparator = null;//如果使用空构造器，那么底层就不使用外部比较器\n    &#125;\n        //有参构造器：\n        public TreeMap(Comparator&lt;? super K&gt; comparator) &#123;\n        this.comparator = comparator;//如果使用有参构造器，那么就相当于指定了外部比较器\n    &#125;\n        \n        public V put(K key, V value) &#123;//k,V的类型在创建对象的时候确定了\n        //如果放入的是第一对元素，那么t的值为null\n        Entry&lt;K,V&gt; t = root;//在放入第二个节点的时候，root已经是根节点了\n                //如果放入的是第一个元素的话，走入这个if中：\n        if (t == null) &#123;\n                        //自己跟自己比\n            compare(key, key); // type (and possibly null) check\n                        //根节点确定为root\n            root = new Entry&lt;&gt;(key, value, null);\n                        //size值变为1\n            size = 1;\n            modCount++;\n            return null;\n        &#125;\n                \n        int cmp;\n        Entry&lt;K,V&gt; parent;\n        // split comparator and comparable paths\n                //将外部比较器赋给cpr:\n        Comparator&lt;? super K&gt; cpr = comparator;\n                //cpr不等于null，意味着你刚才创建对象的时候调用了有参构造器，指定了外部比较器\n        if (cpr != null) &#123;\n            do &#123;\n                parent = t;\n                cmp = cpr.compare(key, t.key);//将元素的key值做比较\n                                //cmp返回的值就是int类型的数据：\n                                //要是这个值《0 =0  》0\n                if (cmp &lt; 0)\n                    t = t.left;\n                else if (cmp &gt; 0)\n                    t = t.right;\n                else//cpm==0\n                                //如果key的值一样，那么新的value替换老的value  但是key不变 因为key是唯一的\n                    return t.setValue(value);\n            &#125; while (t != null);\n        &#125;\n                //cpr等于null，意味着你刚才创建对象的时候调用了空构造器，没有指定外部比较器，使用内部比较器\n        else &#123;\n            if (key == null)\n                throw new NullPointerException();\n            Comparable&lt;? super K&gt; k = (Comparable&lt;? super K&gt;) key;\n            do &#123;\n                parent = t;\n                cmp = k.compareTo(t.key);//将元素的key值做比较\n                if (cmp &lt; 0)\n                    t = t.left;\n                else if (cmp &gt; 0)\n                    t = t.right;\n                else\n                    return t.setValue(value);\n            &#125; while (t != null);\n        &#125;\n        Entry&lt;K,V&gt; e = new Entry&lt;&gt;(key, value, parent);\n        if (cmp &lt; 0)\n            parent.left = e;\n        else\n            parent.right = e;\n        fixAfterInsertion(e);\n        size++;//size加1 操作\n        modCount++;\n        return null;\n    &#125;\n        \n        \n&#125;\n static final class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;\n        K key;\n        V value;\n        Entry&lt;K,V&gt; left = null;\n        Entry&lt;K,V&gt; right = null;\n        Entry&lt;K,V&gt; parent;\n        boolean color = BLACK;\n &#125;\n</code></pre>\n<h4 id=\"TreeSet源码\"><a href=\"#TreeSet源码\" class=\"headerlink\" title=\"TreeSet源码\"></a>TreeSet源码</h4><pre><code class=\"java\">public class TreeSet&lt;E&gt; extends AbstractSet&lt;E&gt;\n    implements NavigableSet&lt;E&gt;, Cloneable, java.io.Serializable&#123;\n                //重要属性：\n                private transient NavigableMap&lt;E,Object&gt; m;\n                private static final Object PRESENT = new Object();\n                \n                //在调用空构造器的时候，底层创建了一个TreeMap\n                public TreeSet() &#123;\n                        this(new TreeMap&lt;E,Object&gt;());\n                &#125;\n                \n                TreeSet(NavigableMap&lt;E,Object&gt; m) &#123;\n                        this.m = m;\n                &#125;\n                \n                public boolean add(E e) &#123;\n        return m.put(e, PRESENT)==null;\n    &#125;\n                \n                \n        &#125;\n</code></pre>\n<h1 id=\"Collections工具类\"><a href=\"#Collections工具类\" class=\"headerlink\" title=\"Collections工具类\"></a>Collections工具类</h1><pre><code class=\"java\">public class Test01 &#123;\n    //这是main方法，程序的入口\n    public static void main(String[] args) &#123;\n        //Collections不支持创建对象，因为构造器私有化了\n        /*Collections cols = new Collections();*/\n        //里面的属性和方法都是被static修饰，我们可以直接用类名.去调用即可：\n        //常用方法：\n        //addAll：\n        ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();\n        list.add(&quot;cc&quot;);\n        list.add(&quot;bb&quot;);\n        list.add(&quot;aa&quot;);\n        Collections.addAll(list,&quot;ee&quot;,&quot;dd&quot;,&quot;ff&quot;);\n        Collections.addAll(list,new String[]&#123;&quot;gg&quot;,&quot;oo&quot;,&quot;pp&quot;&#125;);\n        System.out.println(list);\n        //binarySearch必须在有序的集合中查找：--》排序：\n        Collections.sort(list);//sort提供的是升序排列\n        System.out.println(list);\n        //binarySearch\n        System.out.println(Collections.binarySearch(list, &quot;cc&quot;));\n        //copy:替换方法\n        ArrayList&lt;String&gt; list2 = new ArrayList&lt;&gt;();\n        Collections.addAll(list2,&quot;tt&quot;,&quot;ss&quot;);\n        Collections.copy(list,list2);//将list2的内容替换到list上去\n        System.out.println(list);\n        System.out.println(list2);\n        //fill 填充\n        Collections.fill(list2,&quot;yyy&quot;);\n        System.out.println(list2);\n    &#125;\n&#125;\n</code></pre>\n<h1 id=\"数据结构\"><a href=\"#数据结构\" class=\"headerlink\" title=\"数据结构\"></a>数据结构</h1><h2 id=\"栈\"><a href=\"#栈\" class=\"headerlink\" title=\"栈\"></a>栈</h2><pre><code class=\"java\">public class Test &#123;\n    //这是main方法，程序的入口\n    public static void main(String[] args) &#123;\n        /*\n        Stack是Vector的子类，Vector里面两个重要的属性：\n        Object[] elementData;底层依然是一个数组\n        int elementCount;数组中的容量\n         */\n        Stack s = new Stack();\n        s.add(&quot;A&quot;);\n        s.add(&quot;B&quot;);\n        s.add(&quot;C&quot;);\n        s.add(&quot;D&quot;);\n        System.out.println(s);//[A, B, C, D]\n        System.out.println(&quot;栈是否为空：&quot; + s.empty());\n        System.out.println(&quot;查看栈顶的数据，但是不移除：&quot; + s.peek());\n        System.out.println(s);\n        System.out.println(&quot;查看栈顶的数据，并且不移除：&quot; + s.pop());\n        System.out.println(s);\n        s.push(&quot;D&quot;);//和add方法执行的功能一样，就是返回值不同\n        System.out.println(s);\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"同步类容器\"><a href=\"#同步类容器\" class=\"headerlink\" title=\"同步类容器\"></a>同步类容器</h2><p>比如ArrayList，HashMap，线程不安全，现在想把线程不安全的集合转换为线程安全的集合：</p>\n<pre><code class=\"java\">public class Test01 &#123;\n    //这是main方法，程序的入口\n    public static void main(String[] args) &#123;\n        //ArrayList为案例：从线程不安全  转为线程安全：\n        List list = Collections.synchronizedList(new ArrayList());\n    &#125;\n&#125;\n</code></pre>\n<p>试试ArrayList的线程不安全：</p>\n<pre><code class=\"java\">public class Demo &#123;\n    //这是main方法，程序的入口\n    public static void main(String[] args) &#123;\n        //创建一个ArrayList集合：\n        ArrayList list = new ArrayList();\n        //创建一个线程池：线程池定长100\n        ExecutorService es = Executors.newFixedThreadPool(100);\n        //并发向集合中添加10000个数据：\n        for (int i = 0; i &lt; 10000; i++) &#123;\n            //每个线程处理任务：run方法中的内容就是线程单元，任务，实际线程执行的部分\n            es.execute(new Runnable() &#123;\n                @Override\n                public void run() &#123;\n                    list.add(&quot;aaa&quot;);\n                &#125;\n            &#125;);\n        &#125;\n        //关闭线程池：\n        es.shutdown();\n        //监控线程是否执行完毕：\n        while(true)&#123;\n            //线程都执行完以后返回true\n            if(es.isTerminated())&#123;\n                System.out.println(&quot;所有的子线程都执行完毕了！&quot;);\n                //执行完毕以后看一下集合中元素的数量：\n                System.out.println(list.size());\n                if(list.size() == 10000)&#123;\n                    System.out.println(&quot;线程安全！&quot;);\n                &#125;else&#123;\n                    System.out.println(&quot;线程不安全！&quot;);\n                &#125;\n                //线程执行完以后，while循环可以停止：\n                break;\n            &#125;\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>结果：</p>\n<img data-src=\"/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618180549466.png\" class=\"\">\n\n\n<p>利用同步类容器解决：</p>\n<pre><code class=\"java\">public class Demo &#123;\n    //这是main方法，程序的入口\n    public static void main(String[] args) &#123;\n        //创建一个ArrayList集合：\n        ArrayList oldlist = new ArrayList();\n        List list = Collections.synchronizedList(oldlist);\n        //创建一个线程池：线程池定长100\n        ExecutorService es = Executors.newFixedThreadPool(100);\n        //并发向集合中添加10000个数据：\n        for (int i = 0; i &lt; 10000; i++) &#123;\n            //每个线程处理任务：run方法中的内容就是线程单元，任务，实际线程执行的部分\n            es.execute(new Runnable() &#123;\n                @Override\n                public void run() &#123;\n                    list.add(&quot;aaa&quot;);\n                &#125;\n            &#125;);\n        &#125;\n        //关闭线程池：\n        es.shutdown();\n        //监控线程是否执行完毕：\n        while(true)&#123;\n            //线程都执行完以后返回true\n            if(es.isTerminated())&#123;\n                System.out.println(&quot;所有的子线程都执行完毕了！&quot;);\n                //执行完毕以后看一下集合中元素的数量：\n                System.out.println(list.size());\n                if(list.size() == 10000)&#123;\n                    System.out.println(&quot;线程安全！&quot;);\n                &#125;else&#123;\n                    System.out.println(&quot;线程不安全！&quot;);\n                &#125;\n                //线程执行完以后，while循环可以停止：\n                break;\n            &#125;\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>结果：</p>\n<img data-src=\"/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618180623443.png\" class=\"\">\n\n\n<p>源码解析：</p>\n<img data-src=\"/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618180635090.png\" class=\"\">\n\n\n\n\n<h2 id=\"ConcurrentMap并发容器\"><a href=\"#ConcurrentMap并发容器\" class=\"headerlink\" title=\"ConcurrentMap并发容器\"></a>ConcurrentMap并发容器</h2><p>JDK5.0之后提供了多种并发类容器可以替代同步类容器，提升性能、吞吐量<br>ConcurrentHashMap替代HashMap、HashTable<br>ConcurrentSkipListMap替代TreeMap</p>\n<p>简单原理：</p>\n<img data-src=\"/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618180711631.png\" class=\"\">\n\n\n<p>并发情况下，验证提高性能：</p>\n<p>ConcunrrentHashMap :</p>\n<pre><code class=\"java\">public class Test &#123;\n    //这是main方法，程序的入口\n    public static void main(String[] args) &#123;\n        //选择一个容器：\n        ConcurrentHashMap&lt;String,Integer&gt; map = new ConcurrentHashMap&lt;&gt;();\n        \n        //创建10个线程：\n        for (int i = 0; i &lt; 10; i++) &#123;\n            new Thread(new Runnable() &#123;\n                @Override\n                public void run() &#123;\n                    long startTime = System.currentTimeMillis();\n                    for (int j = 0; j &lt; 1000000; j++) &#123;\n                        map.put(&quot;test&quot; + j , j);\n                    &#125;\n                    long endTime = System.currentTimeMillis();\n                    System.out.println(&quot;一共需要的时间：&quot; + (endTime - startTime));\n                &#125;\n            &#125;).start();\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>结果：</p>\n<img data-src=\"/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618180735265.png\" class=\"\">\n\n\n<p>Hashtable：</p>\n<pre><code class=\"java\">public class Test &#123;\n    //这是main方法，程序的入口\n    public static void main(String[] args) &#123;\n        //选择一个容器：\n        //ConcurrentHashMap&lt;String,Integer&gt; map = new ConcurrentHashMap&lt;&gt;();\n        Hashtable map = new Hashtable();\n        //创建10个线程：\n        for (int i = 0; i &lt; 10; i++) &#123;\n            new Thread(new Runnable() &#123;\n                @Override\n                public void run() &#123;\n                    long startTime = System.currentTimeMillis();\n                    for (int j = 0; j &lt; 1000000; j++) &#123;\n                        map.put(&quot;test&quot; + j , j);\n                    &#125;\n                    long endTime = System.currentTimeMillis();\n                    System.out.println(&quot;一共需要的时间：&quot; + (endTime - startTime));\n                &#125;\n            &#125;).start();\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<img data-src=\"/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618180757516.png\" class=\"\">\n\n\n<p>HashMap：</p>\n<pre><code class=\"java\">public class Test &#123;\n    //这是main方法，程序的入口\n    public static void main(String[] args) &#123;\n        //选择一个容器：\n        //ConcurrentHashMap&lt;String,Integer&gt; map = new ConcurrentHashMap&lt;&gt;();\n        //Hashtable map = new Hashtable();\n        HashMap map = new HashMap();\n        //创建10个线程：\n        for (int i = 0; i &lt; 10; i++) &#123;\n            new Thread(new Runnable() &#123;\n                @Override\n                public void run() &#123;\n                    long startTime = System.currentTimeMillis();\n                    for (int j = 0; j &lt; 1000000; j++) &#123;\n                        map.put(&quot;test&quot; + j , j);\n                    &#125;\n                    long endTime = System.currentTimeMillis();\n                    System.out.println(&quot;一共需要的时间：&quot; + (endTime - startTime));\n                &#125;\n            &#125;).start();\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<img data-src=\"/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618180824896.png\" class=\"\">\n\n\n<p>线程安全的HashMap：</p>\n<pre><code class=\"java\">public class Test &#123;\n    //这是main方法，程序的入口\n    public static void main(String[] args) &#123;\n        //选择一个容器：\n        //ConcurrentHashMap&lt;String,Integer&gt; map = new ConcurrentHashMap&lt;&gt;();\n        //Hashtable map = new Hashtable();\n        HashMap oldmap = new HashMap();\n        Map map = Collections.synchronizedMap(oldmap);\n        //创建10个线程：\n        for (int i = 0; i &lt; 10; i++) &#123;\n            new Thread(new Runnable() &#123;\n                @Override\n                public void run() &#123;\n                    long startTime = System.currentTimeMillis();\n                    for (int j = 0; j &lt; 1000000; j++) &#123;\n                        map.put(&quot;test&quot; + j , j);\n                    &#125;\n                    long endTime = System.currentTimeMillis();\n                    System.out.println(&quot;一共需要的时间：&quot; + (endTime - startTime));\n                &#125;\n            &#125;).start();\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<img data-src=\"/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618180846459.png\" class=\"\">\n\n\n<p>总结：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">ConcurrentHashMap</th>\n<th align=\"center\">性能高，线程安全</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">Hashtable: 线程安全</td>\n<td align=\"center\">性能低</td>\n</tr>\n<tr>\n<td align=\"center\">HashMap:线程不安全</td>\n<td align=\"center\">性能高</td>\n</tr>\n</tbody></table>\n<p>线程安全的HashMap：线程安全，性能低</p>\n<h2 id=\"COW并发容器\"><a href=\"#COW并发容器\" class=\"headerlink\" title=\"COW并发容器\"></a>COW并发容器</h2><p>【1】COW类并发容器，全称：Copy  On  Write容器，写时复制容器。（读写分离容器）</p>\n<p>【2】原理：<br>向容器中添加元素时，先将容器进行Copy复制出一个新容器，然后将元素添加到新容器中，再将原容器的引用指向新容器。<br>并发读的时候不需要锁定容器，因为原容器没有变化，所以可以读取原容器中的值，使用的是一种读写分离的思想。</p>\n<img data-src=\"/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618181056593.png\" class=\"\">\n\n\n\n\n<p>【3】这种设计的好处是什么呢？<br>注意上面的操作arr数组本身是无锁的，没有锁，在添加数据的时候，做了额外的复制，<br>此时如果有线程来读数据，那么读取的是老arr的数据，此时arr的地址还没有改呢，在我添加元素的过程中，<br>无论有多少个线程来读数据，都是读的原来的arr，不是新的arr<br>所以性能很高，读写分离。提高了并发的性能。如果再读再复制…</p>\n<p>【4】注意：<br>CopyOnWrite容器只能保证数据的最终一致性，不能保证数据实时一致性。<br>所以如果你希望写入的的数据，马上能读到，请不要使用CopyOnWrite容器。</p>\n<p>【5】适合特定场合：<br>这个应用场景显而易见，适合读多写少的情况。如果一万个线程都添加操作，都在集合中添加数据，那数组不断复制，长度不断+1，<br>那JVM肯定一直往上飙升，你用的时候肯定要评估使用场景的。<br>由于每次更新都会复制新容器，所以如果数据量较大并且更新操作频繁则对内存消耗很高，建议在高并发读的场景下使用。</p>\n<p>【6】主要讲解：<br>COW容器有两种一种是CopyonWriteArrayList，一种是CopyOnWriteArraySet<br>一个是替代ArrayList，一个是代替Set</p>\n<h3 id=\"CopyOnWriteArrayList\"><a href=\"#CopyOnWriteArrayList\" class=\"headerlink\" title=\"CopyOnWriteArrayList\"></a>CopyOnWriteArrayList</h3><pre><code class=\"java\">public class Test &#123;\n    //这是main方法，程序的入口\n    public static void main(String[] args) &#123;\n        CopyOnWriteArrayList&lt;Integer&gt; list = new CopyOnWriteArrayList&lt;&gt;();\n        //添加方法：\n        list.add(1);\n        list.add(2);\n        list.add(3);\n        list.add(4);\n        System.out.println(list);//[1, 2, 3, 4]\n        list.add(3);//add方法无论元素是否存在，都可以添加进去--》添加重复的元素\n        System.out.println(list);//[1, 2, 3, 4, 3]\n        //adj. 缺席的；缺少的；心不在焉的；茫然的\n        list.addIfAbsent(33);//添加不存在的元素--》不可以添加重复的数据\n        System.out.println(list);//[1, 2, 3, 4, 3, 33]\n    &#125;\n&#125;\n</code></pre>\n<p>源码分析：</p>\n<pre><code class=\"java\">public class CopyOnWriteArrayList&lt;E&gt;&#123;\n        //底层基于数组实现的\n        private transient volatile Object[] array;\n        \n        public CopyOnWriteArrayList() &#123;\n        setArray(new Object[0]);\n    &#125;\n        \n        final void setArray(Object[] a) &#123;\n        array = a; // array = new Object[0]\n    &#125;\n        //add方法：\n        public boolean add(E e) &#123;\n        final ReentrantLock lock = this.lock;\n        lock.lock();\n        try &#123;\n                        //返回底层array数组,给了elements\n            Object[] elements = getArray();\n                        //获取elements的长度---》获取老数组的长度\n            int len = elements.length;\n                        //完成数组的复制，将老数组中的元素复制到新数组中，并且新数组的长度加1操作\n            Object[] newElements = Arrays.copyOf(elements, len + 1);\n                        //将e元素放入新数组最后位置\n            newElements[len] = e;\n                        //array数组的指向从老数组变为新数组\n            setArray(newElements);\n            return true;\n        &#125; finally &#123;\n            lock.unlock();\n        &#125;\n    &#125;\n        \n        \n        final Object[] getArray() &#123;\n        return array;//返回底层数组\n    &#125;\n        \n        \n        private boolean addIfAbsent(E e, Object[] snapshot) &#123;\n        final ReentrantLock lock = this.lock;\n        lock.lock();\n        try &#123;\n                        //取出array数组给current\n            Object[] current = getArray();\n            int len = current.length;\n            if (snapshot != current) &#123;\n                // Optimize for lost race to another addXXX operation\n                int common = Math.min(snapshot.length, len);\n                                //遍历老数组：\n                for (int i = 0; i &lt; common; i++)\n                                        //eq(e, current[i])将放入的元素和老数组的每一个元素进行比较，如果有重复的元素，就返回false，不添加了\n                    if (current[i] != snapshot[i] &amp;&amp; eq(e, current[i]))\n                        return false;\n                if (indexOf(e, current, common, len) &gt;= 0)\n                        return false;\n            &#125;\n                        //完成数组的复制，将老数组中的元素复制到新数组中，并且新数组的长度加1操作\n            Object[] newElements = Arrays.copyOf(current, len + 1);\n                        //将e元素放入新数组最后位置\n            newElements[len] = e;\n                        //array数组的指向从老数组变为新数组\n            setArray(newElements);\n            return true;\n        &#125; finally &#123;\n            lock.unlock();\n        &#125;\n    &#125;             \n&#125;\n</code></pre>\n<h3 id=\"CopyOnWriteArraySet\"><a href=\"#CopyOnWriteArraySet\" class=\"headerlink\" title=\"CopyOnWriteArraySet\"></a>CopyOnWriteArraySet</h3><pre><code class=\"java\">public class Test02 &#123;\n    //这是main方法，程序的入口\n    public static void main(String[] args) &#123;\n        //创建一个集合：\n        CopyOnWriteArraySet&lt;Integer&gt; set = new CopyOnWriteArraySet&lt;&gt;();\n        //在这里也体现出Set和List的本质区别，就在于是否重复\n        //所以add方法直接不可以添加重复数据进去\n        set.add(1);\n        set.add(2);\n        set.add(2);\n        set.add(7);\n        System.out.println(set);//[1, 2, 7]\n        \n    &#125;\n&#125;\n</code></pre>\n<p>源码：</p>\n<pre><code class=\"java\">public class CopyOnWriteArraySet&lt;E&gt;&#123;\n        //CopyOnWriteArraySet底层基于CopyOnWriteArrayList\n        private final CopyOnWriteArrayList&lt;E&gt; al;\n        \n        public CopyOnWriteArraySet() &#123;\n        al = new CopyOnWriteArrayList&lt;E&gt;();\n    &#125;\n        \n        //添加方法：\n        public boolean add(E e) &#123;\n        return al.addIfAbsent(e);//底层调用的还是CopyOnWriteArrayList的addIfAbsent\n    &#125;\n&#125;\n</code></pre>\n<p>总结：</p>\n<p>由上面的源码看出，每次调用CopyOnWriteArraySet的add方法时候，其实底层是基于CopyOnWriteArrayList的addIfAbsent，<br>每次在addIfAbsent方法中每次都要对数组进行遍历，所以CopyOnWriteArraySet的性能低于CopyOnWriteArrayList</p>\n<h2 id=\"队列\"><a href=\"#队列\" class=\"headerlink\" title=\"队列\"></a>队列</h2><p>数据结构分为：<br>（1）逻辑结构 ：–》思想上的结构–》卧室，厨房，卫生间 —》线性表（数组，链表），图，树，栈，队列<br>（2）物理结构 ：–》真实结构–》钢筋混凝土+牛顿力学——》紧密结构（顺序结构），跳转结构（链式结构）</p>\n<p>队列：特点：先进先出 （FIFO）（first in first out）</p>\n<img data-src=\"/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618181454201.png\" class=\"\">\n\n\n<img data-src=\"/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618181504415.png\" class=\"\">\n\n\n\n\n<p>他有两端，一端是让新元素进去，一端是让老元素出去</p>\n<p>在需要公平且经济地对各种自然或社会资源做管理或分配的场合，无论是调度银行和医院的服务窗口，还是管理轮耕的田地和轮伐的森林，队列都可大显身手。</p>\n<p>甚至计算机及其网络自身内部的各种计算资源，无论是多进程共享的 CPU 时间，还是多用户共享的打印机，也都需要借助队列结构实现合理和优化的分配。</p>\n<p>双端队列：两端都可以进行进队，出队的队列：</p>\n<p>（1）前端，后端都可以进出：</p>\n<img data-src=\"/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618181511902.png\" class=\"\">\n\n\n\n\n<p>（2）进行限制：</p>\n<img data-src=\"/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618181516928.png\" class=\"\">\n\n\n\n\n<p>（3）特殊情况，双端队列实现栈操作:</p>\n<img data-src=\"/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618181522040.png\" class=\"\">\n\n\n\n\n<p>栈和队列的物理结构实现 可以用线性表的数组，链表都可以</p>\n<h2 id=\"队列Queue\"><a href=\"#队列Queue\" class=\"headerlink\" title=\"队列Queue\"></a>队列Queue</h2><h3 id=\"阻塞队列\"><a href=\"#阻塞队列\" class=\"headerlink\" title=\"阻塞队列\"></a>阻塞队列</h3><h4 id=\"BlockingQueue介绍\"><a href=\"#BlockingQueue介绍\" class=\"headerlink\" title=\"BlockingQueue介绍\"></a>BlockingQueue介绍</h4><img data-src=\"/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618181740905.png\" class=\"\">\n\n\n<p>总结：BlockingQueue继承Queue，Queue继承自Collection<br>所以Collection最基础的增删改查操作是有的，在这个基础上，多了Queue的特点，在这个基础上又多了阻塞的特点，最终形成了BlockingQueue</p>\n<p>什么叫阻塞？</p>\n<img data-src=\"/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618181750078.png\" class=\"\">\n\n\n<img data-src=\"/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618181756012.png\" class=\"\">\n\n\n<p>常用的API：<br>添加：</p>\n<img data-src=\"/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618181825630.png\" class=\"\">\n\n\n<img data-src=\"/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618181805698.png\" class=\"\">\n\n\n<img data-src=\"/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618181833424.png\" class=\"\">\n\n\n<p>put是阻塞的</p>\n<p>查询：</p>\n<img data-src=\"/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618181839103.png\" class=\"\">\n\n\n<img data-src=\"/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618181845214.png\" class=\"\">\n\n\n\n\n<p>take是阻塞的</p>\n<p>删除：</p>\n<img data-src=\"/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618181852391.png\" class=\"\">\n\n\n\n\n<h4 id=\"常见子类\"><a href=\"#常见子类\" class=\"headerlink\" title=\"常见子类\"></a>常见子类</h4><p><a href=\"#queue_impl1\">ArrayBlockingQueue</a></p>\n<p><a href=\"#queue_impl2\">LinkedBlockingQueue</a></p>\n<p><a href=\"#queue_impl3\">SynchronousQueue</a></p>\n<p><a href=\"#queue_impl4\">PriorityBlockingQueue</a></p>\n<p><a href=\"#queue_impl5\">DelayQueue</a></p>\n<div name=queue_impl1>\n\n\n\n<blockquote>\n<p>ArrayBlockingQueue</p>\n</blockquote>\n<p>源码中的注释的解释说明：</p>\n<img data-src=\"/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618181949074.png\" class=\"\">\n\n\n\n\n<p>【1】添加元素：</p>\n<pre><code class=\"java\">public class Test01 &#123;\n    //这是main方法，程序的入口\n    public static void main(String[] args) throws InterruptedException &#123;\n        //创建一个队列，队列可以指定容量指定长度3：\n        ArrayBlockingQueue aq = new ArrayBlockingQueue(3);\n        //添加元素：\n        //【1】添加null元素：不可以添加null元素，会报空指针异常：NullPointerException\n        //aq.add(null);\n        //aq.offer(null);\n        //aq.put(null);\n        //【2】正常添加元素：\n        aq.add(&quot;aaa&quot;);\n        aq.offer(&quot;bbb&quot;);\n        aq.put(&quot;ccc&quot;);\n        System.out.println(aq);//[aaa, bbb, ccc]\n        //【3】在队列满的情况下，再添加元素：\n        //aq.add(&quot;ddd&quot;);//在队列满的情况下，添加元素 出现异常：Queue full\n        //System.out.println(aq.offer(&quot;ddd&quot;));//没有添加成功，返回false\n        //设置最大阻塞时间，如果时间到了，队列还是满的，就不再阻塞了\n        //aq.offer(&quot;ddd&quot;,2, TimeUnit.SECONDS);\n        //真正阻塞的方法： put ,如果队列满，就永远阻塞 \n        aq.put(&quot;ddd&quot;);\n        System.out.println(aq);\n    &#125;\n&#125;\n</code></pre>\n<p>【2】获取元素：</p>\n<pre><code class=\"java\">public class Test02 &#123;\n    //这是main方法，程序的入口\n    public static void main(String[] args) throws InterruptedException &#123;\n        //创建一个队列，队列可以指定容量指定长度3：\n        ArrayBlockingQueue aq = new ArrayBlockingQueue(3);\n        aq.add(&quot;aaa&quot;);\n        aq.add(&quot;bbb&quot;);\n        aq.add(&quot;ccc&quot;);\n        //得到头元素但是不移除\n        System.out.println(aq.peek());\n        System.out.println(aq);\n        //得到头元素并且移除\n        System.out.println(aq.poll());\n        System.out.println(aq);\n        //得到头元素并且移除\n        System.out.println(aq.take());\n        System.out.println(aq);\n        //清空元素：\n        aq.clear();\n        System.out.println(aq);\n        System.out.println(aq.peek());//null\n        System.out.println(aq.poll());//null\n        //设置阻塞事件，如果队列为空，返回null，时间到了以后就不阻塞了\n        //System.out.println(aq.poll(2, TimeUnit.SECONDS));\n        //真正阻塞：队列为空，永远阻塞\n        System.out.println(aq.take());\n    &#125;\n&#125;\n</code></pre>\n<p>【3】源码：</p>\n<pre><code class=\"java\">public class ArrayBlockingQueue&lt;E&gt; &#123;\n        //底层就是一个数组：\n        final Object[] items;\n        //取元素用到的索引，初始结果为0\n        int takeIndex;\n        //放元素用到的索引，初始结果为0\n        int putIndex;\n        //数组中元素的个数：\n        int count;\n        \n        //一把锁：这个锁肯定很多方法中用到了，所以定义为属性，初始化以后可以随时使用\n    final ReentrantLock lock;\n    //锁伴随的一个等待吃：notEmpty\n    private final Condition notEmpty;\n    //锁伴随的一个等待吃：notFull\n    private final Condition notFull;\n        \n        //构造器：\n        public ArrayBlockingQueue(int capacity) &#123;//传入队列指定的容量\n        this(capacity, false);\n    &#125;\n        \n        public ArrayBlockingQueue(int capacity, boolean fair) &#123;//传入队列指定的容量\n                //健壮性考虑\n        if (capacity &lt;= 0)\n            throw new IllegalArgumentException();\n                //初始化底层数组\n        this.items = new Object[capacity];\n                //初始化锁 和  等待队列\n        lock = new ReentrantLock(fair);\n        notEmpty = lock.newCondition();\n        notFull =  lock.newCondition();\n    &#125;\n        \n        //两个基本方法：一个是入队，一个是出队  ，是其他方法的基础：\n        //入队：\n        private void enqueue(E x) &#123;\n        // assert lock.getHoldCount() == 1;\n        // assert items[putIndex] == null;\n        final Object[] items = this.items;//底层数组赋给items\n                //在对应的下标位置放入元素\n        items[putIndex] = x;\n        if (++putIndex == items.length) //++putIndex putIndex 索引 加1 \n            putIndex = 0;\n                //每放入一个元素，count加1操作\n        count++;\n        notEmpty.signal();\n    &#125;\n        \n        \n        //出队：\n        private E dequeue() &#123;\n        // assert lock.getHoldCount() == 1;\n        // assert items[takeIndex] != null;\n        final Object[] items = this.items;//底层数组赋给items\n        @SuppressWarnings(&quot;unchecked&quot;)\n        E x = (E) items[takeIndex];//在对应的位置取出元素\n        items[takeIndex] = null;//对应位置元素取出后就置为null\n        if (++takeIndex == items.length)//++takeIndex 加1操作\n            takeIndex = 0;\n        count--;//每取出一个元素，count减1操作\n        if (itrs != null)\n            itrs.elementDequeued();\n        notFull.signal();\n        return x;//将取出的元素作为方法的返回值\n    &#125;       \n&#125;\n</code></pre>\n<p>takeIndex和putIndex置为0的原因：</p>\n<img data-src=\"/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618182045354.png\" class=\"\">\n\n\n<p>【4】其他的添加或者获取的方法都是依托与这个入队和出队的基础方法</p>\n<img data-src=\"/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618182053419.png\" class=\"\">\n\n\n<p>【5】感受一下put和take的阻塞：</p>\n<img data-src=\"/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618182101129.png\" class=\"\">\n\n\n<p>上面的while不可以换为if，因为如果notFull中的线程被激活的瞬间，有其他线程放入元素，那么队列就又满了<br>那么沿着await后面继续执行就不可以，所以一定要反复确定队列是否满的，才能放入元素</p>\n<div name=queue_impl2>\n\n\n\n<blockquote>\n<p>LinkedBlockingQueue</p>\n</blockquote>\n<p>一个可选择的有边界的队列：意思就是队列的长度可以指定，也可以不指定</p>\n<img data-src=\"/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618182251224.png\" class=\"\">\n\n\n<p>【1】添加元素：</p>\n<pre><code class=\"java\">public class Test01 &#123;\n    //这是main方法，程序的入口\n    public static void main(String[] args) throws InterruptedException &#123;\n        //创建一个队列，队列可以指定容量指定长度3：\n        LinkedBlockingQueue aq = new LinkedBlockingQueue(3);\n        //添加元素：\n        //【1】添加null元素：不可以添加null元素，会报空指针异常：NullPointerException\n        //aq.add(null);\n        //aq.offer(null);\n        aq.put(null);\n        //【2】正常添加元素：\n        aq.add(&quot;aaa&quot;);\n        aq.offer(&quot;bbb&quot;);\n        aq.put(&quot;ccc&quot;);\n        System.out.println(aq);//[aaa, bbb, ccc]\n        //【3】在队列满的情况下，再添加元素：\n        //aq.add(&quot;ddd&quot;);//在队列满的情况下，添加元素 出现异常：Queue full\n        //System.out.println(aq.offer(&quot;ddd&quot;));//没有添加成功，返回false\n        //设置最大阻塞时间，如果时间到了，队列还是满的，就不再阻塞了\n        //aq.offer(&quot;ddd&quot;,2, TimeUnit.SECONDS);\n        //真正阻塞的方法： put ,如果队列满，就永远阻塞\n        aq.put(&quot;ddd&quot;);\n        System.out.println(aq);\n    &#125;\n&#125;\n</code></pre>\n<p>【2】取出元素：</p>\n<pre><code class=\"java\">public class Test02 &#123;\n    //这是main方法，程序的入口\n    public static void main(String[] args) throws InterruptedException &#123;\n        //创建一个队列，队列可以指定容量指定长度3：\n        LinkedBlockingQueue aq = new LinkedBlockingQueue();\n        aq.add(&quot;aaa&quot;);\n        aq.add(&quot;bbb&quot;);\n        aq.add(&quot;ccc&quot;);\n        //得到头元素但是不移除\n        System.out.println(aq.peek());\n        System.out.println(aq);\n        //得到头元素并且移除\n        System.out.println(aq.poll());\n        System.out.println(aq);\n        //得到头元素并且移除\n        System.out.println(aq.take());\n        System.out.println(aq);\n        //清空元素：\n        aq.clear();\n        System.out.println(aq);\n        System.out.println(aq.peek());//null\n        System.out.println(aq.poll());//null\n        //设置阻塞事件，如果队列为空，返回null，时间到了以后就不阻塞了\n        //System.out.println(aq.poll(2, TimeUnit.SECONDS));\n        //真正阻塞：队列为空，永远阻塞\n        System.out.println(aq.take());\n    &#125;\n&#125;\n</code></pre>\n<p>【3】特点：<br>ArrayBlockingQueue ： 不支持读写同时操作，底层基于数组的。<br>LinkedBlockingQueue：支持读写同时操作，并发情况下，效率高。底层基于链表。</p>\n<p>【4】源码：<br>入队操作：</p>\n<img data-src=\"/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618182330212.png\" class=\"\">\n\n\n<p>出队操作：</p>\n<img data-src=\"/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618182341368.png\" class=\"\">\n\n\n<pre><code class=\"java\">public class LinkedBlockingQueue&lt;E&gt;&#123;\n        //内部类Node就是链表的节点的对象对应的类：\n        static class Node&lt;E&gt; &#123;\n        E item;//封装你要装的那个元素\n        \n        Node&lt;E&gt; next;//下一个Node节点的地址\n        Node(E x) &#123; item = x; &#125;//构造器\n    &#125;\n        //链表的长度\n        private final int capacity;\n        //计数器：\n        private final AtomicInteger count = new AtomicInteger();\n        //链表的头结点\n        transient Node&lt;E&gt; head;\n        //链表的尾结点\n        private transient Node&lt;E&gt; last;\n        //取元素用的锁\n        private final ReentrantLock takeLock = new ReentrantLock();\n        //等待池\n    private final Condition notEmpty = takeLock.newCondition();\n    //放元素用的锁\n    private final ReentrantLock putLock = new ReentrantLock();\n    //等待池\n    private final Condition notFull = putLock.newCondition();\n        \n        public LinkedBlockingQueue() &#123;\n        this(Integer.MAX_VALUE);//调用类本类的空构造器，传入正21亿\n    &#125;\n        \n        public LinkedBlockingQueue(int capacity) &#123;\n                //健壮性考虑\n        if (capacity &lt;= 0) throw new IllegalArgumentException();\n                //给队列指定长度  \n        this.capacity = capacity;\n                //last，head指向一个新的节点，新的节点中 元素为null \n        last = head = new Node&lt;E&gt;(null);\n    &#125;\n        \n        \n        //入队：\n        private void enqueue(Node&lt;E&gt; node) &#123;\n        last = last.next = node;\n    &#125;\n        \n        //出队：\n        private E dequeue() &#123;\n        Node&lt;E&gt; h = head;//h指向了head\n        Node&lt;E&gt; first = h.next;//first 指向head的next\n        h.next = h; // help GC   h.next指向自己，更容易被GC发现 被GC\n        head = first;//head的指向指为first\n        E x = first.item;//取出链中第一个元素，给了x\n        first.item = null;\n        return x;//把x作为方法的返回值\n    &#125;\n&#125;\n</code></pre>\n<p>【5】put的阻塞：</p>\n<p>阻塞的前提是  队列是固定长度的</p>\n<img data-src=\"/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618182407325.png\" class=\"\">\n\n\n\n\n<div name=queue_impl3>\n\n\n\n<blockquote>\n<p>SynchronousQueue</p>\n</blockquote>\n<img data-src=\"/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618182455703.png\" class=\"\">\n\n\n<p>这个特殊的队列设计的意义：</p>\n<img data-src=\"/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618182515070.png\" class=\"\">\n\n\n<p>测试1：先添加元素：</p>\n<pre><code class=\"java\">public class Test01 &#123;\n    //这是main方法，程序的入口\n    public static void main(String[] args) &#123;\n        SynchronousQueue sq = new SynchronousQueue();\n        sq.add(&quot;aaa&quot;);\n    &#125;\n&#125;\n</code></pre>\n<p>直接报错：说队列满了，因为队列没有容量，理解为满也是正常的：</p>\n<img data-src=\"/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618182535474.png\" class=\"\">\n\n\n<p>测试2：put方法  阻塞：队列是空的，可以理解为队列满了，满的话放入元素 put 一定会阻塞：</p>\n<pre><code class=\"java\">public class Test01 &#123;\n    //这是main方法，程序的入口\n    public static void main(String[] args) throws InterruptedException &#123;\n        SynchronousQueue sq = new SynchronousQueue();\n        sq.put(&quot;aaa&quot;);\n    &#125;\n&#125;\n</code></pre>\n<img data-src=\"/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618182600030.png\" class=\"\">\n\n\n<p>测试3：先取  再放：</p>\n<pre><code class=\"java\">public class Test02 &#123;\n    //这是main方法，程序的入口\n    public static void main(String[] args) &#123;\n        SynchronousQueue sq = new SynchronousQueue();\n        //创建一个线程，取数据：\n        new Thread(new Runnable() &#123;\n            @Override\n            public void run() &#123;\n                while(true)&#123;\n                    try &#123;\n                        System.out.println(sq.take());\n                    &#125; catch (InterruptedException e) &#123;\n                        e.printStackTrace();\n                    &#125;\n                &#125;\n            &#125;\n        &#125;).start();\n        //搞一个线程，往里面放数据：\n        new Thread(new Runnable() &#123;\n            @Override\n            public void run() &#123;\n                try &#123;\n                    sq.put(&quot;aaa&quot;);\n                    sq.put(&quot;bbb&quot;);\n                    sq.put(&quot;ccc&quot;);\n                    sq.put(&quot;ddd&quot;);\n                &#125; catch (InterruptedException e) &#123;\n                    e.printStackTrace();\n                &#125;\n            &#125;\n        &#125;).start();\n    &#125;\n&#125;\n</code></pre>\n<img data-src=\"/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618182625271.png\" class=\"\">\n\n\n<p>测试4：poll方法：</p>\n<pre><code class=\"java\">public class Test02 &#123;\n    //这是main方法，程序的入口\n    public static void main(String[] args) &#123;\n        SynchronousQueue sq = new SynchronousQueue();\n        //创建一个线程，取数据：\n        new Thread(new Runnable() &#123;\n            @Override\n            public void run() &#123;\n                while(true)&#123;\n                    try &#123;\n                        //设置一个阻塞事件：超出事件就不阻塞了\n                        Object result = sq.poll(5, TimeUnit.SECONDS);\n                        System.out.println(result);\n                        if(result == null)&#123;\n                            break;\n                        &#125;\n                    &#125; catch (InterruptedException e) &#123;\n                        e.printStackTrace();\n                    &#125;\n                &#125;\n            &#125;\n        &#125;).start();\n        //搞一个线程，往里面放数据：\n        new Thread(new Runnable() &#123;\n            @Override\n            public void run() &#123;\n                try &#123;\n                    sq.put(&quot;aaa&quot;);\n                    sq.put(&quot;bbb&quot;);\n                    sq.put(&quot;ccc&quot;);\n                    sq.put(&quot;ddd&quot;);\n                &#125; catch (InterruptedException e) &#123;\n                    e.printStackTrace();\n                &#125;\n            &#125;\n        &#125;).start();\n    &#125;\n&#125;\n</code></pre>\n<img data-src=\"/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618182647289.png\" class=\"\">\n\n\n<p>注意：取出元素 不能用peek，因为peek不会将元素从队列中拿走，只是查看的效果；</p>\n<div name=queue_impl4>\n\n\n\n<blockquote>\n<p>PriorityBlockingQueue</p>\n</blockquote>\n<p>带有优先级的阻塞队列。<br>优先级队列，意味着队列有先后顺序的，数据有不同的权重。</p>\n<p>无界的队列，没有长度限制，但是在你不指定长度的时候，默认初始长度为11，也可以手动指定，<br>当然随着数据不断的加入，底层（底层是数组Object[]）会自动扩容，直到内存全部消耗殆尽了，导致 OutOfMemoryError内存溢出 程序才会结束。</p>\n<img data-src=\"/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618183001941.png\" class=\"\">\n\n\n<p>不可以放入null元素的，不允许放入不可比较的对象（导致抛出ClassCastException），对象必须实现内部比较器或者外部比较器。</p>\n<p>测试1：添加null数据：</p>\n<pre><code class=\"java\">public class Test &#123;\n    //这是main方法，程序的入口\n    public static void main(String[] args) &#123;\n        PriorityBlockingQueue pq = new PriorityBlockingQueue();\n        pq.put(null);\n    &#125;\n&#125;\n</code></pre>\n<img data-src=\"/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618183016134.png\" class=\"\">\n\n\n<p>测试2：添加四个数据：</p>\n<pre><code class=\"java\">public class Student implements Comparable&lt;Student&gt; &#123;\n    String name;\n    int age;\n    public Student() &#123;\n    &#125;\n    public Student(String name, int age) &#123;\n        this.name = name;\n        this.age = age;\n    &#125;\n    @Override\n    public String toString() &#123;\n        return &quot;Student&#123;&quot; +\n                &quot;name=&#39;&quot; + name + &#39;\\&#39;&#39; +\n                &quot;, age=&quot; + age +\n                &#39;&#125;&#39;;\n    &#125;\n    @Override\n    public int compareTo(Student o) &#123;\n        return this.age - o.age;\n    &#125;\n&#125;\n</code></pre>\n<pre><code class=\"java\">public class Test02 &#123;\n    //这是main方法，程序的入口\n    public static void main(String[] args) &#123;\n        PriorityBlockingQueue&lt;Student&gt; pq = new PriorityBlockingQueue&lt;&gt;();\n        pq.put(new Student(&quot;nana&quot;,18));\n        pq.put(new Student(&quot;lulu&quot;,11));\n        pq.put(new Student(&quot;feifei&quot;,6));\n        pq.put(new Student(&quot;mingming&quot;,21));\n        System.out.println(pq);\n    &#125;\n&#125;\n</code></pre>\n<p>结果</p>\n<img data-src=\"/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618183048547.png\" class=\"\">\n\n\n<p>发现结果并没有按照优先级顺序排列</p>\n<p>测试3：取出数据：</p>\n<pre><code class=\"java\">public class Test02 &#123;\n    //这是main方法，程序的入口\n    public static void main(String[] args) throws InterruptedException &#123;\n        PriorityBlockingQueue&lt;Student&gt; pq = new PriorityBlockingQueue&lt;&gt;();\n        pq.put(new Student(&quot;nana&quot;,18));\n        pq.put(new Student(&quot;lulu&quot;,11));\n        pq.put(new Student(&quot;feifei&quot;,6));\n        pq.put(new Student(&quot;mingming&quot;,21));\n        System.out.println(&quot;------------------------------------------&quot;);\n        System.out.println(pq.take());\n        System.out.println(pq.take());\n        System.out.println(pq.take());\n        System.out.println(pq.take());\n    &#125;\n&#125;\n</code></pre>\n<img data-src=\"/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618183114429.png\" class=\"\">\n\n\n<p>从结果证明，这个优先级队列，并不是在put数据的时候计算谁在前谁在后<br>而是取数据的时候，才真正判断谁在前 谁在后</p>\n<p>优先级 –》取数据的优先级</p>\n<div name=queue_impl5>\n\n\n\n<blockquote>\n<p>DelayQueue</p>\n</blockquote>\n<p>一、DelayQueue是什么<br>DelayQueue是一个无界的BlockingQueue，用于放置实现了Delayed接口的对象，其中的对象只能在其到期时才能从队列中取走。</p>\n<img data-src=\"/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618183216715.png\" class=\"\">\n\n\n<p>​\t 当生产者线程调用put之类的方法加入元素时，会触发Delayed接口中的compareTo方法进行排序，也就是说队列中元素的顺序是按到期时间排序的，而非它们进入队列的顺序。排在队列头部的元素是最早到期的，越往后到期时间赿晚。</p>\n<p>消费者线程查看队列头部的元素，注意是查看不是取出。然后调用元素的getDelay方法，如果此方法返回的值小０或者等于０，则消费者线程会从队列中取出此元素，并进行处理。如果getDelay方法返回的值大于0，则消费者线程wait返回的时间值后，再从队列头部取出元素，此时元素应该已经到期。</p>\n<p>​\t注意：不能将null元素放置到这种队列中。</p>\n<p>二、DelayQueue能做什么</p>\n<ol>\n<li><p>淘宝订单业务:下单之后如果三十分钟之内没有付款就自动取消订单。</p>\n</li>\n<li><p>饿了吗订餐通知:下单成功后60s之后给用户发送短信通知。</p>\n</li>\n<li><p>关闭空闲连接。服务器中，有很多客户端的连接，空闲一段时间之后需要关闭之。</p>\n</li>\n<li><p>缓存。缓存中的对象，超过了空闲时间，需要从缓存中移出。</p>\n</li>\n<li><p>任务超时处理。在网络协议滑动窗口请求应答式交互时，处理超时未响应的请求等。</p>\n</li>\n</ol>\n<p>案例：</p>\n<pre><code class=\"java\">public class User implements Delayed &#123;\n    private int id;//用户id\n    private String name;//用户名字\n    private long endTime;//结束时间\n    public int getId() &#123;\n        return id;\n    &#125;\n    public void setId(int id) &#123;\n        this.id = id;\n    &#125;\n    public String getName() &#123;\n        return name;\n    &#125;\n    public void setName(String name) &#123;\n        this.name = name;\n    &#125;\n    public long getEndTime() &#123;\n        return endTime;\n    &#125;\n    public void setEndTime(long endTime) &#123;\n        this.endTime = endTime;\n    &#125;\n    public User(int id, String name, long endTime) &#123;\n        this.id = id;\n        this.name = name;\n        this.endTime = endTime;\n    &#125;\n    //只包装用户名字就可以\n    @Override\n    public String toString() &#123;\n        return &quot;User&#123;&quot; +\n                &quot;name=&#39;&quot; + name + &#39;\\&#39;&#39; +\n                &#39;&#125;&#39;;\n    &#125;\n    @Override\n    public long getDelay(TimeUnit unit) &#123;\n        //计算剩余时间 剩余时间小于0 &lt;=0  证明已经到期\n        return this.getEndTime() - System.currentTimeMillis();\n    &#125;\n    @Override\n    public int compareTo(Delayed o) &#123;\n        //队列中数据 到期时间的比较\n        User other = (User)o;\n        return ((Long)(this.getEndTime())).compareTo((Long)(other.getEndTime()));\n    &#125;\n&#125;\n</code></pre>\n<p>compareTo：看谁先被移除<br>getDelay ：看剩余时间</p>\n<pre><code class=\"java\">public class TestDelayQueue &#123;\n    //创建一个队列：\n    DelayQueue&lt;User&gt; dq = new DelayQueue&lt;&gt;();\n    //登录游戏：\n    public void login(User user)&#123;\n        dq.add(user);\n        System.out.println(&quot;用户：[&quot; + user.getId() +&quot;],[&quot; + user.getName() + &quot;]已经登录，预计下机时间为：&quot; + user.getEndTime() );\n    &#125;\n    //时间到，退出游戏，队列中移除：\n    public void logout()&#123;\n        //打印队列中剩余的人：\n        System.out.println(dq);\n        try &#123;\n            User user = dq.take();\n            System.out.println(&quot;用户：[&quot; + user.getId() +&quot;],[&quot; + user.getName() + &quot;]上机时间到，自动退出游戏&quot;);\n        &#125; catch (InterruptedException e) &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n    //获取在线人数：\n    public int onlineSize()&#123;\n        return dq.size();\n    &#125;\n    //这是main方法，程序的入口\n    public static void main(String[] args) &#123;\n        //创建测试类对象：\n        TestDelayQueue test = new TestDelayQueue();\n        //添加登录的用户：\n        test.login(new User(1,&quot;张三&quot;,System.currentTimeMillis()+5000));\n        test.login(new User(2,&quot;李四&quot;,System.currentTimeMillis()+2000));\n        test.login(new User(3,&quot;王五&quot;,System.currentTimeMillis()+10000));\n        //一直监控\n        while(true)&#123;\n            //到期的话，就自动下线：\n            test.logout();\n            //队列中元素都被移除了的话，那么停止监控，停止程序即可\n            if(test.onlineSize() == 0)&#123;\n                break;\n            &#125;\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<img data-src=\"/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618183342855.png\" class=\"\">\n\n\n\n\n\n\n<h3 id=\"双端队列Deque\"><a href=\"#双端队列Deque\" class=\"headerlink\" title=\"双端队列Deque\"></a>双端队列Deque</h3><pre><code class=\"java\">public class Test03 &#123;\n    //这是main方法，程序的入口\n    public static void main(String[] args) &#123;\n        /*\n        双端队列：\n        Deque&lt;E&gt; extends Queue\n        Queue一端放 一端取的基本方法  Deque是具备的\n        在此基础上 又扩展了 一些 头尾操作（添加，删除，获取）的方法\n         */\n        Deque&lt;String&gt; d = new LinkedList&lt;&gt;() ;\n        d.offer(&quot;A&quot;);\n        d.offer(&quot;B&quot;);\n        d.offer(&quot;C&quot;);\n        System.out.println(d);//[A, B, C]\n        d.offerFirst(&quot;D&quot;);\n        d.offerLast(&quot;E&quot;);\n        System.out.println(d);//[D, A, B, C, E]\n        System.out.println(d.poll());\n        System.out.println(d);//[A, B, C, E]\n        System.out.println(d.pollFirst());\n        System.out.println(d.pollLast());\n        System.out.println(d);\n    &#125;\n&#125;\n</code></pre>\n",
            "tags": [
                "JavaSE"
            ]
        }
    ]
}