<?xml version="1.0"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>http://example.com</id>
    <title>记录“美食”每刻 • Posts by &#34;集合&#34; category</title>
    <link href="http://example.com" />
    <updated>2022-10-06T16:00:00.000Z</updated>
    <category term="博客" />
    <category term="环境搭建" />
    <category term="分布式" />
    <category term="Dubbo" />
    <category term="FastDFS" />
    <category term="MySQL" />
    <category term="数据库基础" />
    <category term="数据库基本知识" />
    <category term="数据库" />
    <category term="框架" />
    <category term="ORM" />
    <category term="RPC" />
    <category term="中间件" />
    <category term="RabbitMQ" />
    <category term="Solr" />
    <category term="快速搜索" />
    <category term="Redis基础" />
    <category term="NoSQL数据库" />
    <category term="Spring" />
    <category term="SpringBoot" />
    <category term="SpringMVC" />
    <category term="SpringSecurity" />
    <category term="JavaSE" />
    <category term="-JavaSE" />
    <entry>
        <id>http://example.com/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/</id>
        <title>第11章集合</title>
        <link rel="alternate" href="http://example.com/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/"/>
        <content type="html">&lt;h1 id=&#34;11-集合&#34;&gt;&lt;a href=&#34;#11-集合&#34; class=&#34;headerlink&#34; title=&#34;11 集合&#34;&gt;&lt;/a&gt;11 集合&lt;/h1&gt;&lt;img data-src=&#34;/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618180112196.png&#34; class=&#34;&#34;&gt;




&lt;img data-src=&#34;/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618170703735.png&#34; class=&#34;&#34;&gt;




&lt;h1 id=&#34;Colletion接口&#34;&gt;&lt;a href=&#34;#Colletion接口&#34; class=&#34;headerlink&#34; title=&#34;Colletion接口&#34;&gt;&lt;/a&gt;Colletion接口&lt;/h1&gt;&lt;h2 id=&#34;1-1-常用方法&#34;&gt;&lt;a href=&#34;#1-1-常用方法&#34; class=&#34;headerlink&#34; title=&#34;1.1 常用方法&#34;&gt;&lt;/a&gt;1.1 常用方法&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;package com.msb.test01;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.List;
/**
 * @author : msb-zhaoss
 */
public class Test01 &amp;#123;
    //这是main方法，程序的入口
    public static void main(String[] args) &amp;#123;
        /*
        Collection接口的常用方法：
        增加：add(E e) addAll(Collection&amp;lt;? extends E&amp;gt; c)
        删除：clear() remove(Object o)
        修改：
        查看：iterator() size()
        判断：contains(Object o)  equals(Object o) isEmpty()
         */
        //创建对象：接口不能创建对象，利用实现类创建对象：
        Collection col = new ArrayList();
        //调用方法：
        //集合有一个特点：只能存放引用数据类型的数据，不能是基本数据类型
        //基本数据类型自动装箱，对应包装类。int---&amp;gt;Integer
        col.add(18);
        col.add(12);
        col.add(11);
        col.add(17);
        System.out.println(col/*.toString()*/);
        List list = Arrays.asList(new Integer[]&amp;#123;11, 15, 3, 7, 1&amp;#125;);
        col.addAll(list);//将另一个集合添加入col中
        System.out.println(col);
        //col.clear();清空集合
        System.out.println(col);
        System.out.println(&amp;quot;集合中元素的数量为：&amp;quot;+col.size());
        System.out.println(&amp;quot;集合是否为空：&amp;quot;+col.isEmpty());
        boolean isRemove = col.remove(15);
        System.out.println(col);
        System.out.println(&amp;quot;集合中数据是否被删除：&amp;quot;+isRemove);
        Collection col2 = new ArrayList();
        col2.add(18);
        col2.add(12);
        col2.add(11);
        col2.add(17);
        Collection col3 = new ArrayList();
        col3.add(18);
        col3.add(12);
        col3.add(11);
        col3.add(17);
        System.out.println(col2.equals(col3));
        System.out.println(col2==col3);//地址一定不相等  false
        System.out.println(&amp;quot;是否包含元素：&amp;quot;+col3.contains(117));
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;1-2-Collection集合的遍历&#34;&gt;&lt;a href=&#34;#1-2-Collection集合的遍历&#34; class=&#34;headerlink&#34; title=&#34;1.2 Collection集合的遍历&#34;&gt;&lt;/a&gt;1.2 Collection集合的遍历&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;迭代器简要原理图：



package com.msb.test01;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;
/**
 * @author : msb-zhaoss
 */
public class Test02 &amp;#123;
    //这是main方法，程序的入口
    public static void main(String[] args) &amp;#123;
        Collection col = new ArrayList();
        col.add(18);
        col.add(12);
        col.add(11);
        col.add(17);
        col.add(&amp;quot;abc&amp;quot;);
        col.add(9.8);
        //对集合遍历（对集合中元素进行查看）
        //方式1：普通for循环
        /*for(int i= 0;i&amp;lt;col.size();i++)&amp;#123;
            col.
        &amp;#125;*/
        //方式2：增强for循环
        for(Object o:col)&amp;#123;
            System.out.println(o);
        &amp;#125;
        System.out.println(&amp;quot;------------------------&amp;quot;);
        //方式3：iterator()
        Iterator it = col.iterator();
        while(it.hasNext())&amp;#123;
            System.out.println(it.next());
        &amp;#125;
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;2-List接口&#34;&gt;&lt;a href=&#34;#2-List接口&#34; class=&#34;headerlink&#34; title=&#34;2 List接口&#34;&gt;&lt;/a&gt;2 List接口&lt;/h2&gt;&lt;h3 id=&#34;2-1-常用方法和遍历方式&#34;&gt;&lt;a href=&#34;#2-1-常用方法和遍历方式&#34; class=&#34;headerlink&#34; title=&#34;2.1 常用方法和遍历方式&#34;&gt;&lt;/a&gt;2.1 常用方法和遍历方式&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;package com.msb.test01;
import com.sun.org.apache.xerces.internal.dom.PSVIAttrNSImpl;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
/**
 * @author : msb-zhaoss
 */
public class Test03 &amp;#123;
    //这是main方法，程序的入口
    public static void main(String[] args) &amp;#123;
        /*
        List接口中常用方法：
        增加：add(int index, E element)
        删除：remove(int index)  remove(Object o)
        修改：set(int index, E element)
        查看：get(int index)
        判断：
         */
        List list = new ArrayList();
        list.add(13);
        list.add(17);
        list.add(6);
        list.add(-1);
        list.add(2);
        list.add(&amp;quot;abc&amp;quot;);
        System.out.println(list);
        list.add(3,66);
        System.out.println(list);
        list.set(3,77);
        System.out.println(list);
        list.remove(2);//在集合中存入的是Integer类型数据的时候，调用remove方法调用的是：remove(int index)
        System.out.println(list);
        list.remove(&amp;quot;abc&amp;quot;);
        System.out.println(list);
        Object o = list.get(0);
        System.out.println(o);
        //List集合 遍历：
        //方式1：普通for循环：
        System.out.println(&amp;quot;---------------------&amp;quot;);
        for(int i = 0;i&amp;lt;list.size();i++)&amp;#123;
            System.out.println(list.get(i));
        &amp;#125;
        //方式2：增强for循环：
        System.out.println(&amp;quot;---------------------&amp;quot;);
        for(Object obj:list)&amp;#123;
            System.out.println(obj);
        &amp;#125;
        //方式3：迭代器：
        System.out.println(&amp;quot;---------------------&amp;quot;);
        Iterator it = list.iterator();
        while(it.hasNext())&amp;#123;
            System.out.println(it.next());
        &amp;#125;
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;2-2-ArrayList实现类（JDK1-7）&#34;&gt;&lt;a href=&#34;#2-2-ArrayList实现类（JDK1-7）&#34; class=&#34;headerlink&#34; title=&#34;2.2 ArrayList实现类（JDK1.7）&#34;&gt;&lt;/a&gt;2.2 ArrayList实现类（JDK1.7）&lt;/h3&gt;&lt;p&gt;底层重要属性：&lt;/p&gt;
&lt;img data-src=&#34;/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618172028655.png&#34; class=&#34;&#34;&gt;


&lt;p&gt;在JDK1.7中：在调用构造器的时候给底层数组elementData初始化，&lt;font color=#FF0000&gt;数组初始化长度为10&lt;/font&gt;：&lt;/p&gt;
&lt;img data-src=&#34;/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618172107247.png&#34; class=&#34;&#34;&gt;


&lt;p&gt;对应内存：&lt;/p&gt;
&lt;img data-src=&#34;/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618172121579.png&#34; class=&#34;&#34;&gt;


&lt;p&gt;调用add方法：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;         ArrayList al = new ArrayList();
        System.out.println(al.add(&amp;quot;abc&amp;quot;));
        System.out.println(al.add(&amp;quot;def&amp;quot;));
&lt;/code&gt;&lt;/pre&gt;
&lt;img data-src=&#34;/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618172152471.png&#34; class=&#34;&#34;&gt;


&lt;p&gt;当数组中的10个位置都满了的时候就开始进行数组的扩容，扩容长度为 &lt;font color=#FF0000&gt;原数组的1.5倍&lt;/font&gt;：&lt;/p&gt;
&lt;img data-src=&#34;/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618172227199.png&#34; class=&#34;&#34;&gt;


&lt;img data-src=&#34;/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618172231517.png&#34; class=&#34;&#34;&gt;


&lt;img data-src=&#34;/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618172235705.png&#34; class=&#34;&#34;&gt;








&lt;h3 id=&#34;2-3-ArrayList实现类（JDK1-8）&#34;&gt;&lt;a href=&#34;#2-3-ArrayList实现类（JDK1-8）&#34; class=&#34;headerlink&#34; title=&#34;2.3 ArrayList实现类（JDK1.8）&#34;&gt;&lt;/a&gt;2.3 ArrayList实现类（JDK1.8）&lt;/h3&gt;&lt;p&gt;【1】JDK1.8底层依旧是Object类型的数组，size:数组中有效长度：&lt;/p&gt;
&lt;img data-src=&#34;/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618172252320.png&#34; class=&#34;&#34;&gt;


&lt;p&gt;【2】ArrayList al &amp;#x3D; new ArrayList();调用空构造器：&lt;/p&gt;
&lt;img data-src=&#34;/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618172303832.png&#34; class=&#34;&#34;&gt;


&lt;p&gt;【3】add方法：&lt;/p&gt;
&lt;img data-src=&#34;/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618172316929.png&#34; class=&#34;&#34;&gt;


&lt;img data-src=&#34;/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618172324585.png&#34; class=&#34;&#34;&gt;


&lt;img data-src=&#34;/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618172335841.png&#34; class=&#34;&#34;&gt;


&lt;img data-src=&#34;/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618172340839.png&#34; class=&#34;&#34;&gt;




&lt;h3 id=&#34;2-4-Vector实现类&#34;&gt;&lt;a href=&#34;#2-4-Vector实现类&#34; class=&#34;headerlink&#34; title=&#34;2.4 Vector实现类&#34;&gt;&lt;/a&gt;2.4 Vector实现类&lt;/h3&gt;&lt;p&gt;【1】底层Object数组，int类型属性表示数组中有效长度：&lt;/p&gt;
&lt;img data-src=&#34;/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618172455343.png&#34; class=&#34;&#34;&gt;



&lt;p&gt;【2】Vector v&amp;#x3D;new Vector();调用构造器：&lt;/p&gt;
&lt;p&gt;【3】add方法：&lt;/p&gt;
&lt;img data-src=&#34;/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618172507015.png&#34; class=&#34;&#34;&gt;




&lt;h3 id=&#34;2-5-泛型&#34;&gt;&lt;a href=&#34;#2-5-泛型&#34; class=&#34;headerlink&#34; title=&#34;2.5 泛型&#34;&gt;&lt;/a&gt;2.5 泛型&lt;/h3&gt;&lt;p&gt;【1】什么是泛型（Generic）：&lt;br&gt;泛型就相当于标签&lt;br&gt;形式：&amp;lt;&amp;gt;&lt;br&gt;集合容器类在设计阶段&amp;#x2F;声明阶段不能确定这个容器到底实际存的是什么类型的对象，所以在JDK1.5之前只能把元素类型设计为Object，&lt;br&gt;JDK1.5之 后使用泛型来解决。因为这个时候除了元素的类型不确定，其他的部分是确定的，例如关于这个元素如何保存，如何管理等是确定的，因此此时把元素的类型设计成一个参数，这个类型参数叫做泛型。&lt;br&gt;Collection&lt;E&gt;, List&lt;E&gt;， ArrayList&lt;E&gt; 这个&lt;E&gt;就是类型参数，即泛型。&lt;/p&gt;
&lt;p&gt;【2】没有泛型的时候使用集合：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;package com.msb.test01;
import java.util.ArrayList;
/**
 * @author : msb-zhaoss
 */
public class Test01 &amp;#123;
    //这是main方法，程序的入口
    public static void main(String[] args) &amp;#123;
        //创建一个ArrayList集合，向这个集合中存入学生的成绩：
        ArrayList al = new ArrayList();
        al.add(98);
        al.add(18);
        al.add(39);
        al.add(60);
        al.add(83);
        al.add(&amp;quot;丽丽&amp;quot;);
        //对集合遍历查看：
        for(Object obj:al)&amp;#123;
            System.out.println(obj);
        &amp;#125;
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果不使用泛型的话，有缺点：&lt;br&gt;一般我们在使用的时候基本上往集合中存入的都是相同类型的数据–》便于管理，所以现在什么引用数据类型都可以存入集合，不方便！&lt;/p&gt;
&lt;p&gt;【3】JDK1.5以后开始使用泛型，集合中使用泛型：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;package com.msb.test01;
import java.util.ArrayList;
/**
 * @author : msb-zhaoss
 */
public class Test01 &amp;#123;
    //这是main方法，程序的入口
    public static void main(String[] args) &amp;#123;
        //创建一个ArrayList集合，向这个集合中存入学生的成绩：
        //加入泛型的优点：在编译时期就会对类型进行检查，不是泛型对应的类型就不可以添加入这个集合。
        ArrayList&amp;lt;Integer&amp;gt; al = new ArrayList&amp;lt;Integer&amp;gt;();
        al.add(98);
        al.add(18);
        al.add(39);
        al.add(60);
        al.add(83);
        /*al.add(&amp;quot;丽丽&amp;quot;);
        al.add(9.8);*/
        //对集合遍历查看：
        /*for(Object obj:al)&amp;#123;
            System.out.println(obj);
        &amp;#125;*/
        for(Integer i:al)&amp;#123;
            System.out.println(i);
        &amp;#125;
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;【4】泛型总结：&lt;br&gt;（1）JDK1.5以后&lt;br&gt;（2）泛型实际就是 一个&amp;lt;&amp;gt;引起来的 参数类型，这个参数类型  具体在使用的时候才会确定具体的类型。&lt;/p&gt;
&lt;img data-src=&#34;/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618172646571.png&#34; class=&#34;&#34;&gt;


&lt;p&gt;（3）使用了泛型以后，可以确定集合中存放数据的类型，在编译时期就可以检查出来。&lt;br&gt;（4）使用泛型你可能觉得麻烦，实际使用了泛型才会简单，后续的遍历等操作简单。&lt;br&gt;（5）泛型的类型：都是引用数据类型，不能是基本数据类型。&lt;br&gt;（6）ArrayList&lt;Integer&gt; al &amp;#x3D; new ArrayList&lt;Integer&gt;();在JDK1.7以后可以写为：&lt;br&gt;ArrayList&lt;Integer&gt; al &amp;#x3D; new ArrayList&amp;lt;&amp;gt;();  –&amp;lt;&amp;gt;  —钻石运算符&lt;/p&gt;
&lt;h4 id=&#34;2-5-1-自定义泛型结构&#34;&gt;&lt;a href=&#34;#2-5-1-自定义泛型结构&#34; class=&#34;headerlink&#34; title=&#34;2.5.1 自定义泛型结构&#34;&gt;&lt;/a&gt;2.5.1 自定义泛型结构&lt;/h4&gt;&lt;p&gt;泛型类，泛型接口&lt;/p&gt;
&lt;p&gt;【1】泛型类的定义和实例化：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;package com.msb.test02;
/**
 * @author : msb-zhaoss
 * GenericTes就是一个普通的类
 * GenericTest&amp;lt;E&amp;gt; 就是一个泛型类
 * &amp;lt;&amp;gt;里面就是一个参数类型，但是这个类型是什么呢？这个类型现在是不确定的，相当于一个占位
 * 但是现在确定的是这个类型一定是一个引用数据类型，而不是基本数据类型
 */
public class GenericTest&amp;lt;E&amp;gt; &amp;#123;
    int age;
    String name;
    E sex;
    public void a(E n)&amp;#123;
    &amp;#125;
    public void b(E[] m)&amp;#123;
    &amp;#125;
&amp;#125;
class Test&amp;#123;
    //这是main方法，程序的入口
    public static void main(String[] args) &amp;#123;
        //GenericTest进行实例化：
        //(1)实例化的时候不指定泛型：如果实例化的时候不明确的指定类的泛型，那么认为此泛型为Object类型
        GenericTest gt1 = new GenericTest();
        gt1.a(&amp;quot;abc&amp;quot;);
        gt1.a(17);
        gt1.a(9.8);
        gt1.b(new String[]&amp;#123;&amp;quot;a&amp;quot;,&amp;quot;b&amp;quot;,&amp;quot;c&amp;quot;&amp;#125;);
        //（2）实例化的时候指定泛型：---》推荐方式
        GenericTest&amp;lt;String&amp;gt; gt2 = new GenericTest&amp;lt;&amp;gt;();
        gt2.sex = &amp;quot;男&amp;quot;;
        gt2.a(&amp;quot;abc&amp;quot;);
        gt2.b(new String[]&amp;#123;&amp;quot;a&amp;quot;,&amp;quot;b&amp;quot;,&amp;quot;c&amp;quot;&amp;#125;);
        
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;【2】继承情况：&lt;br&gt;（1）父类指定泛型：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;class SubGenericTest extends GenericTest&amp;lt;Integer&amp;gt;&amp;#123;
&amp;#125;
class Demo&amp;#123;
    //这是main方法，程序的入口
    public static void main(String[] args) &amp;#123;
        //指定父类泛型，那么子类就不需要再指定泛型了，可以直接使用
        SubGenericTest sgt = new SubGenericTest();
        sgt.a(19);
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;（2）父类不指定泛型：&lt;br&gt;如果父类不指定泛型，那么子类也会变成一个泛型类，那这个E的类型可以在创建子类对象的时候确定：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;class SubGenericTest2&amp;lt;E&amp;gt; extends GenericTest&amp;lt;E&amp;gt;&amp;#123;
&amp;#125;

class Demo2&amp;#123;
    //这是main方法，程序的入口
    public static void main(String[] args) &amp;#123;
        SubGenericTest2&amp;lt;String&amp;gt; s = new  SubGenericTest2&amp;lt;&amp;gt;();
        s.a(&amp;quot;abc&amp;quot;);
        s.sex = &amp;quot;女&amp;quot;;
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;【3】应用场合：&lt;/p&gt;
&lt;img data-src=&#34;/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618173037582.png&#34; class=&#34;&#34;&gt;


&lt;p&gt;【4】细节：&lt;br&gt;（1）泛型类可以定义多个参数类型&lt;/p&gt;
&lt;img data-src=&#34;/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618173045431.png&#34; class=&#34;&#34;&gt;


&lt;p&gt;（2）泛型类的构造器的写法：&lt;/p&gt;
&lt;img data-src=&#34;/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618173057556.png&#34; class=&#34;&#34;&gt;


&lt;p&gt;（3）不同的泛型的引用类型不可以相互赋值：&lt;/p&gt;
&lt;img data-src=&#34;/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618173104251.png&#34; class=&#34;&#34;&gt;


&lt;p&gt;（4）泛型如果不指定，那么就会被擦除，反应对应的类型为Object类型：&lt;/p&gt;
&lt;img data-src=&#34;/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618173116539.png&#34; class=&#34;&#34;&gt;


&lt;p&gt;（5）反省类中的静态方法不能使用类的泛型：&lt;/p&gt;
&lt;img data-src=&#34;/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618173123924.png&#34; class=&#34;&#34;&gt;


&lt;p&gt;（6）不能直接使用E[]的创建：&lt;/p&gt;
&lt;img data-src=&#34;/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618173130213.png&#34; class=&#34;&#34;&gt;


&lt;h4 id=&#34;2-5-2-泛型方法&#34;&gt;&lt;a href=&#34;#2-5-2-泛型方法&#34; class=&#34;headerlink&#34; title=&#34;2.5.2 泛型方法&#34;&gt;&lt;/a&gt;2.5.2 泛型方法&lt;/h4&gt;&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;package com.msb.test04;
/**
 * @author : msb-zhaoss
 * 1.什么是泛型方法：
 * 不是带泛型的方法就是泛型方法
 * 泛型方法有要求：这个方法的泛型的参数类型要和当前的类的泛型无关
 * 换个角度：
 * 泛型方法对应的那个泛型参数类型 和  当前所在的这个类 是否是泛型类，泛型是啥  无关
 * 2.泛型方法定义的时候，前面要加上&amp;lt;T&amp;gt;
 *     原因：如果不加的话，会把T当做一种数据类型，然而代码中没有T类型那么就会报错
 * 3.T的类型是在调用方法的时候确定的
 * 4.泛型方法可否是静态方法？可以是静态方法
 */
public class TestGeneric&amp;lt;E&amp;gt; &amp;#123;
    //不是泛型方法 （不能是静态方法）
    public static void a(E e)&amp;#123;
    &amp;#125;
    //是泛型方法
    public static &amp;lt;T&amp;gt;  void b(T t)&amp;#123;
    &amp;#125;
&amp;#125;
class Demo&amp;#123;
    //这是main方法，程序的入口
    public static void main(String[] args) &amp;#123;
        TestGeneric&amp;lt;String&amp;gt; tg = new TestGeneric&amp;lt;&amp;gt;();
        tg.a(&amp;quot;abc&amp;quot;);
        tg.b(&amp;quot;abc&amp;quot;);
        tg.b(19);
        tg.b(true);
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;2-5-3-泛型参数存在继承关系的情况&#34;&gt;&lt;a href=&#34;#2-5-3-泛型参数存在继承关系的情况&#34; class=&#34;headerlink&#34; title=&#34;2.5.3 泛型参数存在继承关系的情况&#34;&gt;&lt;/a&gt;2.5.3 泛型参数存在继承关系的情况&lt;/h4&gt;&lt;img data-src=&#34;/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618173213265.png&#34; class=&#34;&#34;&gt;


&lt;h4 id=&#34;2-5-4-通配符&#34;&gt;&lt;a href=&#34;#2-5-4-通配符&#34; class=&#34;headerlink&#34; title=&#34;2.5.4 通配符&#34;&gt;&lt;/a&gt;2.5.4 通配符&lt;/h4&gt;&lt;p&gt;【1】在没有通配符的时候：&lt;br&gt;下面的a方法，相当于方法的重复定义，报错&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;public class Test &amp;#123;
    /*public void a(List&amp;lt;Object&amp;gt; list)&amp;#123;
    &amp;#125;
    public void a(List&amp;lt;String&amp;gt; list)&amp;#123;
    &amp;#125;
    public void a(List&amp;lt;Integer&amp;gt; list)&amp;#123;
    &amp;#125;*/
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;【2】引入通配符：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;public class Demo &amp;#123;
    //这是main方法，程序的入口
    public static void main(String[] args) &amp;#123;
        List&amp;lt;Object&amp;gt; list1 = new ArrayList&amp;lt;&amp;gt;();
        List&amp;lt;String&amp;gt; list2 = new ArrayList&amp;lt;&amp;gt;();
        List&amp;lt;Integer&amp;gt; list3 = new ArrayList&amp;lt;&amp;gt;();
        List&amp;lt;?&amp;gt; list = null;
        list = list1;
        list = list2;
        list = list3;
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;发现： A 和 B是子类父类的关系，G&lt;A&gt;和G&lt;B&gt;不存在子类父类关系，是并列的&lt;br&gt;加入通配符？后，G&amp;lt;?&amp;gt;就变成了 G&lt;A&gt;和G&lt;B&gt;的父类&lt;/p&gt;
&lt;p&gt;【3】使用通配符：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;package com.msb.test06;
import java.util.ArrayList;
import java.util.List;
/**
 * @author : msb-zhaoss
 */
public class Test &amp;#123;
    /*public void a(List&amp;lt;Object&amp;gt; list)&amp;#123;
    &amp;#125;
    public void a(List&amp;lt;String&amp;gt; list)&amp;#123;
    &amp;#125;
    public void a(List&amp;lt;Integer&amp;gt; list)&amp;#123;
    &amp;#125;*/
    public void a(List&amp;lt;?&amp;gt; list)&amp;#123;
        //内部遍历的时候用Object即可，不用？
        for(Object a:list)&amp;#123;
            System.out.println(a);
        &amp;#125;
    &amp;#125;
&amp;#125;
class T&amp;#123;
    //这是main方法，程序的入口
    public static void main(String[] args) &amp;#123;
        Test t = new Test();
        t.a(new ArrayList&amp;lt;Integer&amp;gt;());
        t.a(new ArrayList&amp;lt;String&amp;gt;());
        t.a(new ArrayList&amp;lt;Object&amp;gt;());
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;【4】查看API中应用位置：&lt;/p&gt;
&lt;img data-src=&#34;/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618173333503.png&#34; class=&#34;&#34;&gt;


&lt;h4 id=&#34;2-5-5-使用通配符后的细节&#34;&gt;&lt;a href=&#34;#2-5-5-使用通配符后的细节&#34; class=&#34;headerlink&#34; title=&#34;2.5.5 使用通配符后的细节&#34;&gt;&lt;/a&gt;2.5.5 使用通配符后的细节&lt;/h4&gt;&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;public class Test &amp;#123;
    public void a(List&amp;lt;?&amp;gt; list)&amp;#123;
        //1.遍历：
        for(Object a:list)&amp;#123;
            System.out.println(a);
        &amp;#125;
        //2.数据的写入操作 ：
        //list.add(&amp;quot;abc&amp;quot;);--&amp;gt;出错，不能随意的添加数据
        list.add(null);
        //3.数据的读取操作：
        Object s = list.get(0);
    &amp;#125;
&amp;#125;
class T&amp;#123;
    //这是main方法，程序的入口
    public static void main(String[] args) &amp;#123;
        Test t = new Test();
        t.a(new ArrayList&amp;lt;Integer&amp;gt;());
        t.a(new ArrayList&amp;lt;String&amp;gt;());
        t.a(new ArrayList&amp;lt;Object&amp;gt;());
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;2-5-6-泛型受限&#34;&gt;&lt;a href=&#34;#2-5-6-泛型受限&#34; class=&#34;headerlink&#34; title=&#34;2.5.6 泛型受限&#34;&gt;&lt;/a&gt;2.5.6 泛型受限&lt;/h4&gt;&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;package com.msb.test07;
import java.util.ArrayList;
import java.util.List;

public class Test &amp;#123;
    //这是main方法，程序的入口
    public static void main(String[] args) &amp;#123;
        //a,b,c三个集合是并列的关系：
        List&amp;lt;Object&amp;gt; a = new ArrayList&amp;lt;&amp;gt;();
        List&amp;lt;Person&amp;gt; b = new ArrayList&amp;lt;&amp;gt;();
        List&amp;lt;Student&amp;gt; c = new ArrayList&amp;lt;&amp;gt;();
        /*开始使用泛型受限：泛型的上限
        List&amp;lt;? extends Person&amp;gt;:
        就相当于：
        List&amp;lt;? extends Person&amp;gt;是List&amp;lt;Person&amp;gt;的父类，是List&amp;lt;Person的子类&amp;gt;的父类
         */
        List&amp;lt;? extends Person&amp;gt; list1 = null;
        /*list1 = a;
        list1 = b;
        list1 = c;*/
        /*开始使用泛型受限：泛型的下限
        List&amp;lt;? super Person&amp;gt;
        就相当于：
        List&amp;lt;? super Person&amp;gt;是List&amp;lt;Person&amp;gt;的父类，是List&amp;lt;Person的父类&amp;gt;的父类
         */
        List&amp;lt;? super Person&amp;gt; list2 = null;
        list2 = a;
        list2 = b;
        list3 = c;
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;2-6-LinkedList实现类&#34;&gt;&lt;a href=&#34;#2-6-LinkedList实现类&#34; class=&#34;headerlink&#34; title=&#34;2.6 LinkedList实现类&#34;&gt;&lt;/a&gt;2.6 LinkedList实现类&lt;/h3&gt;&lt;h4 id=&#34;2-6-1-基本方法使用&#34;&gt;&lt;a href=&#34;#2-6-1-基本方法使用&#34; class=&#34;headerlink&#34; title=&#34;2.6.1 基本方法使用&#34;&gt;&lt;/a&gt;2.6.1 基本方法使用&lt;/h4&gt;&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;package com.msb.test04;
import java.util.Iterator;
import java.util.LinkedList;
/**
 * @author : msb-zhaoss
 */
public class Test &amp;#123;
    //这是main方法，程序的入口
    public static void main(String[] args) &amp;#123;
        /*
        LinkedList常用方法：
        增加 addFirst(E e) addLast(E e)
             offer(E e) offerFirst(E e) offerLast(E e)
        删除 poll()
            pollFirst() pollLast()  ---》JDK1.6以后新出的方法，提高了代码的健壮性
            removeFirst() removeLast()
        修改
        查看 element()
             getFirst()  getLast()
             indexOf(Object o)   lastIndexOf(Object o)
             peek()
             peekFirst() peekLast()
        判断
         */
        //创建一个LinkedList集合对象：
        LinkedList&amp;lt;String&amp;gt; list = new LinkedList&amp;lt;&amp;gt;();
        list.add(&amp;quot;aaaaa&amp;quot;);
        list.add(&amp;quot;bbbbb&amp;quot;);
        list.add(&amp;quot;ccccc&amp;quot;);
        list.add(&amp;quot;ddddd&amp;quot;);
        list.add(&amp;quot;eeeee&amp;quot;);
        list.add(&amp;quot;bbbbb&amp;quot;);
        list.add(&amp;quot;fffff&amp;quot;);
        list.addFirst(&amp;quot;jj&amp;quot;);
        list.addLast(&amp;quot;hh&amp;quot;);
        list.offer(&amp;quot;kk&amp;quot;);//添加元素在尾端
        list.offerFirst(&amp;quot;pp&amp;quot;);
        list.offerLast(&amp;quot;rr&amp;quot;);
        System.out.println(list);//LinkedList可以添加重复数据
        System.out.println(list.poll());//删除头上的元素并且将元素输出
        System.out.println(list.pollFirst());
        System.out.println(list.pollLast());
        System.out.println(list.removeFirst());
        System.out.println(list.removeLast());
        System.out.println(list);//LinkedList可以添加重复数据
        /*list.clear();//清空集合
        System.out.println(list);*/
        /*System.out.println(list.pollFirst());*/
        /*System.out.println(list.removeFirst());报错：Exception in thread &amp;quot;main&amp;quot; java.util.NoSuchElementException*/
        //集合的遍历：
        System.out.println(&amp;quot;---------------------&amp;quot;);
        //普通for循环：
        for(int i = 0;i&amp;lt;list.size();i++)&amp;#123;
            System.out.println(list.get(i));
        &amp;#125;
        System.out.println(&amp;quot;---------------------&amp;quot;);
        //增强for：
        for(String s:list)&amp;#123;
            System.out.println(s);
        &amp;#125;
        System.out.println(&amp;quot;---------------------&amp;quot;);
        //迭代器：
        /*Iterator&amp;lt;String&amp;gt; it = list.iterator();
        while(it.hasNext())&amp;#123;
            System.out.println(it.next());
        &amp;#125;*/
        //下面这种方式好，节省内存
        for(Iterator&amp;lt;String&amp;gt; it = list.iterator();it.hasNext();)&amp;#123;
            System.out.println(it.next());
        &amp;#125;
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;2-6-2-简要底层原理图&#34;&gt;&lt;a href=&#34;#2-6-2-简要底层原理图&#34; class=&#34;headerlink&#34; title=&#34;2.6.2 简要底层原理图&#34;&gt;&lt;/a&gt;2.6.2 简要底层原理图&lt;/h4&gt;&lt;img data-src=&#34;/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618173515599.png&#34; class=&#34;&#34;&gt;


&lt;h4 id=&#34;2-6-3-模拟LinkedList源码&#34;&gt;&lt;a href=&#34;#2-6-3-模拟LinkedList源码&#34; class=&#34;headerlink&#34; title=&#34;2.6.3 模拟LinkedList源码&#34;&gt;&lt;/a&gt;2.6.3 模拟LinkedList源码&lt;/h4&gt;&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;package com.msb.test05;
/**
 * @author : msb-zhaoss
 */
public class MyLinkedList &amp;#123;
    //链中一定有一个首节点：
    Node first;
    //链中一定有一个尾节点：
    Node last;
    //计数器：
    int count = 0;
    //提供一个构造器：
    public MyLinkedList()&amp;#123;
    &amp;#125;
    //添加元素方法：
    public void add(Object o)&amp;#123;
        if(first == null)&amp;#123;//证明你添加的元素是第一个节点：
            //将添加的元素封装为一个Node对象：
            Node n = new Node();
            n.setPre(null);
            n.setObj(o);
            n.setNext(null);
            //当前链中第一个节点变为n
            first = n;
            //当前链中最后一个节点变为n
            last = n;
        &amp;#125;else&amp;#123;//证明已经不是链中第一个节点了
            //将添加的元素封装为一个Node对象：
            Node n = new Node();
            n.setPre(last);//n的上一个节点一定是当前链中的最后一个节点last
            n.setObj(o);
            n.setNext(null);
            //当前链中的最后一个节点的下一个元素 要指向n
            last.setNext(n);
            //将最后一个节点变为n
            last = n;
        &amp;#125;
        //链中元素数量加1
        count++;
    &amp;#125;
    //得到集合中元素的数量：
    public int getSize()&amp;#123;
        return count;
    &amp;#125;
    //通过下标得到元素：
    public Object get(int index)&amp;#123;
        //获取链表的头元素：
        Node n = first;
        //一路next得到想要的元素
        for(int i=0;i&amp;lt;index;i++)&amp;#123;
            n = n.getNext();
        &amp;#125;
        return n.getObj();
    &amp;#125;
&amp;#125;
class Test&amp;#123;
    //这是main方法，程序的入口
    public static void main(String[] args) &amp;#123;
        //创建一个MyLinkedList集合对象：
        MyLinkedList ml = new MyLinkedList();
        ml.add(&amp;quot;aa&amp;quot;);
        ml.add(&amp;quot;bb&amp;quot;);
        ml.add(&amp;quot;cc&amp;quot;);
        System.out.println(ml.getSize());
        System.out.println(ml.get(0));
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;2-6-4-LinkedList源码解析&#34;&gt;&lt;a href=&#34;#2-6-4-LinkedList源码解析&#34; class=&#34;headerlink&#34; title=&#34;2.6.4 LinkedList源码解析&#34;&gt;&lt;/a&gt;2.6.4 LinkedList源码解析&lt;/h4&gt;&lt;p&gt;【1】JDK1.7和JDK1.8的LinkedList的源码是一致的&lt;br&gt;【2】源码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;public class LinkedList&amp;lt;E&amp;gt;&amp;#123;//E是一个泛型，具体的类型要在实例化的时候才会最终确定
        transient int size = 0;//集合中元素的数量
        //Node的内部类
        private static class Node&amp;lt;E&amp;gt; &amp;#123;
        E item;//当前元素
        Node&amp;lt;E&amp;gt; next;//指向下一个元素地址
        Node&amp;lt;E&amp;gt; prev;//上一个元素地址
        Node(Node&amp;lt;E&amp;gt; prev, E element, Node&amp;lt;E&amp;gt; next) &amp;#123;
            this.item = element;
            this.next = next;
            this.prev = prev;
        &amp;#125;
    &amp;#125;
        transient Node&amp;lt;E&amp;gt; first;//链表的首节点
        transient Node&amp;lt;E&amp;gt; last;//链表的尾节点
        //空构造器：
        public LinkedList() &amp;#123;
    &amp;#125;
        //添加元素操作：
        public boolean add(E e) &amp;#123;
        linkLast(e);
        return true;
    &amp;#125;
        void linkLast(E e) &amp;#123;//添加的元素e
        final Node&amp;lt;E&amp;gt; l = last;//将链表中的last节点给l 如果是第一个元素的话 l为null
                //将元素封装为一个Node具体的对象：
        final Node&amp;lt;E&amp;gt; newNode = new Node&amp;lt;&amp;gt;(l, e, null);
                //将链表的last节点指向新的创建的对象：
        last = newNode;
                
        if (l == null)//如果添加的是第一个节点
            first = newNode;//将链表的first节点指向为新节点
        else//如果添加的不是第一个节点 
            l.next = newNode;//将l的下一个指向为新的节点
        size++;//集合中元素数量加1操作
        modCount++;
    &amp;#125;
        //获取集合中元素数量
        public int size() &amp;#123;
        return size;
    &amp;#125;
        //通过索引得到元素：
        public E get(int index) &amp;#123;
        checkElementIndex(index);//健壮性考虑
        return node(index).item;
    &amp;#125;
        
    Node&amp;lt;E&amp;gt; node(int index) &amp;#123;
        //如果index在链表的前半段，那么从前往后找
        if (index &amp;lt; (size &amp;gt;&amp;gt; 1)) &amp;#123;
            Node&amp;lt;E&amp;gt; x = first;
            for (int i = 0; i &amp;lt; index; i++)
                x = x.next;
            return x;
        &amp;#125; else &amp;#123;//如果index在链表的后半段，那么从后往前找
            Node&amp;lt;E&amp;gt; x = last;
            for (int i = size - 1; i &amp;gt; index; i--)
                x = x.prev;
            return x;
        &amp;#125;
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;面试题：&#34;&gt;&lt;a href=&#34;#面试题：&#34; class=&#34;headerlink&#34; title=&#34;面试题：&#34;&gt;&lt;/a&gt;面试题：&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;iterator(),Iterator,Iterable关系&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;【1】面试题：对应的关系：&lt;/p&gt;
&lt;img data-src=&#34;/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618173707713.png&#34; class=&#34;&#34;&gt;


&lt;p&gt;【2】hasNext(),next()的具体实现：&lt;/p&gt;
&lt;img data-src=&#34;/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618173654976.png&#34; class=&#34;&#34;&gt;


&lt;p&gt;ListIterator迭代器&lt;/p&gt;
&lt;p&gt;【1】加入字符串：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;package com.msb.test06;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
/**
 * @author : msb-zhaoss
 */
public class Test2 &amp;#123;
    //这是main方法，程序的入口
    public static void main(String[] args) &amp;#123;
        ArrayList&amp;lt;String&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
        list.add(&amp;quot;aa&amp;quot;);
        list.add(&amp;quot;bb&amp;quot;);
        list.add(&amp;quot;cc&amp;quot;);
        list.add(&amp;quot;dd&amp;quot;);
        list.add(&amp;quot;ee&amp;quot;);
        //在&amp;quot;cc&amp;quot;之后添加一个字符串&amp;quot;kk&amp;quot;
        Iterator&amp;lt;String&amp;gt; it = list.iterator();
        while(it.hasNext())&amp;#123;
            if(&amp;quot;cc&amp;quot;.equals(it.next()))&amp;#123;
                list.add(&amp;quot;kk&amp;quot;);
            &amp;#125;
        &amp;#125;
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;发现报错：&lt;/p&gt;
&lt;img data-src=&#34;/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618173818117.png&#34; class=&#34;&#34;&gt;


&lt;p&gt;出错原因：就是迭代器和list同时对集合进行操作：&lt;/p&gt;
&lt;img data-src=&#34;/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618173826503.png&#34; class=&#34;&#34;&gt;


&lt;p&gt;解决办法：事情让一个“人”做 –》引入新的迭代器：ListIterator&lt;br&gt;迭代和添加操作都是靠ListIterator来完成的：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;package com.msb.test06;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.ListIterator;
/**
 * @author : msb-zhaoss
 */
public class Test2 &amp;#123;
    //这是main方法，程序的入口
    public static void main(String[] args) &amp;#123;
        ArrayList&amp;lt;String&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
        list.add(&amp;quot;aa&amp;quot;);
        list.add(&amp;quot;bb&amp;quot;);
        list.add(&amp;quot;cc&amp;quot;);
        list.add(&amp;quot;dd&amp;quot;);
        list.add(&amp;quot;ee&amp;quot;);
        //在&amp;quot;cc&amp;quot;之后添加一个字符串&amp;quot;kk&amp;quot;
        ListIterator&amp;lt;String&amp;gt; it = list.listIterator();
        while(it.hasNext())&amp;#123;
            if(&amp;quot;cc&amp;quot;.equals(it.next()))&amp;#123;
                it.add(&amp;quot;kk&amp;quot;);
            &amp;#125;
        &amp;#125;
        System.out.println(it.hasNext());
        System.out.println(it.hasPrevious());
        //逆向遍历：
        while(it.hasPrevious())&amp;#123;
            System.out.println(it.previous());
        &amp;#125;
        System.out.println(it.hasNext());
        System.out.println(it.hasPrevious());
        System.out.println(list);
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;3-Set接口&#34;&gt;&lt;a href=&#34;#3-Set接口&#34; class=&#34;headerlink&#34; title=&#34;3 Set接口&#34;&gt;&lt;/a&gt;3 Set接口&lt;/h2&gt;&lt;h3 id=&#34;3-1-HashSet实现类的使用&#34;&gt;&lt;a href=&#34;#3-1-HashSet实现类的使用&#34; class=&#34;headerlink&#34; title=&#34;3.1 HashSet实现类的使用&#34;&gt;&lt;/a&gt;3.1 HashSet实现类的使用&lt;/h3&gt;&lt;p&gt;【1】放入Integer类型数据：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;package com.msb.test07;
import java.util.HashSet;
/**
 * @author : msb-zhaoss
 */
public class TestInteger &amp;#123;
    //这是main方法，程序的入口
    public static void main(String[] args) &amp;#123;
        //创建一个HashSet集合：
        HashSet&amp;lt;Integer&amp;gt; hs = new HashSet&amp;lt;&amp;gt;();
        System.out.println(hs.add(19));//true
        hs.add(5);
        hs.add(20);
        System.out.println(hs.add(19));//false 这个19没有放入到集合中
        hs.add(41);
        hs.add(0);
        System.out.println(hs.size());//唯一，无序
        System.out.println(hs);
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;【2】放入String类型数据：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;package com.msb.test07;
import java.util.HashSet;
/**
 * @author : msb-zhaoss
 */
public class TestString &amp;#123;
    //这是main方法，程序的入口
    public static void main(String[] args) &amp;#123;
        //创建一个HashSet集合：
        HashSet&amp;lt;String&amp;gt; hs = new HashSet&amp;lt;&amp;gt;();
        hs.add(&amp;quot;hello&amp;quot;);
        hs.add(&amp;quot;apple&amp;quot;);
        hs.add(&amp;quot;banana&amp;quot;);
        hs.add(&amp;quot;html&amp;quot;);
        hs.add(&amp;quot;apple&amp;quot;);
        hs.add(&amp;quot;css&amp;quot;);
        System.out.println(hs.size());
        System.out.println(hs);
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;【3】放入自定义的引用数据类型的数据：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;package com.msb.test07;
import java.util.HashSet;
/**
 * @author : msb-zhaoss
 */
public class TestStudent &amp;#123;
    //这是main方法，程序的入口
    public static void main(String[] args) &amp;#123;
        //创建一个HashSet集合：
        HashSet&amp;lt;Student&amp;gt; hs = new HashSet&amp;lt;&amp;gt;();
        hs.add(new Student(19,&amp;quot;lili&amp;quot;));
        hs.add(new Student(20,&amp;quot;lulu&amp;quot;));
        hs.add(new Student(18,&amp;quot;feifei&amp;quot;));
        hs.add(new Student(19,&amp;quot;lili&amp;quot;));
        hs.add(new Student(10,&amp;quot;nana&amp;quot;));
        System.out.println(hs.size());
        System.out.println(hs);
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面自定义的类型不满足 唯一，无序的特点。为什么呢？&lt;/p&gt;
&lt;p&gt;【4】HashSet原理图：（简要原理图）&lt;/p&gt;
&lt;img data-src=&#34;/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618173954231.png&#34; class=&#34;&#34;&gt;


&lt;p&gt;【5】疑问：&lt;br&gt;1.数组的长度是多少。&lt;br&gt;2.数组的类型是什么？&lt;br&gt;3.hashCode，equals方法真的调用了吗？验证&lt;br&gt;4.底层表达式是什么？&lt;br&gt;5.同一个位置的数据 向前放  还是 向后放？&lt;br&gt;6.放入数组中的数据，是直接放的吗？是否封装为对象了？&lt;/p&gt;
&lt;h3 id=&#34;3-2LinkedHashSet使用&#34;&gt;&lt;a href=&#34;#3-2LinkedHashSet使用&#34; class=&#34;headerlink&#34; title=&#34;3.2LinkedHashSet使用&#34;&gt;&lt;/a&gt;3.2LinkedHashSet使用&lt;/h3&gt;&lt;p&gt;其实就是在HashSet的基础上，多了一个总的链表，这个总链表将放入的元素串在一起，方便有序的遍历：&lt;br&gt;（可以看到LinkedHashMap.Entry 继承自HashMap.Node 除了Node 本身有的几个属性外，额外增加了before after 用于指向前一个Entry 后一个Entry。也就是说，元素之间维持着一条总的链表数据结构。）&lt;/p&gt;
&lt;img data-src=&#34;/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618174059591.png&#34; class=&#34;&#34;&gt;


&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;package com.msb.test07;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
/**
 * @author : msb-zhaoss
 */
public class TestInteger &amp;#123;
    //这是main方法，程序的入口
    public static void main(String[] args) &amp;#123;
        //创建一个HashSet集合：
        LinkedHashSet&amp;lt;Integer&amp;gt; hs = new LinkedHashSet&amp;lt;&amp;gt;();
        System.out.println(hs.add(19));//true
        hs.add(5);
        hs.add(20);
        System.out.println(hs.add(19));//false 这个19没有放入到集合中
        hs.add(41);
        hs.add(0);
        System.out.println(hs.size());//唯一，无序
        System.out.println(hs);
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;3-3-比较器的使用&#34;&gt;&lt;a href=&#34;#3-3-比较器的使用&#34; class=&#34;headerlink&#34; title=&#34;3.3 比较器的使用&#34;&gt;&lt;/a&gt;3.3 比较器的使用&lt;/h3&gt;&lt;p&gt;【1】以int类型为案例：&lt;br&gt;比较的思路：将比较的数据做差，然后返回一个int类型的数据，将这个int类型的数值  按照 &amp;#x3D;0  &amp;gt;0  &amp;lt;0&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;          int a = 10;
        int b = 20;
        System.out.println(a-b); // =0  &amp;gt;0  &amp;lt;0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;【2】比较String类型数据：&lt;br&gt;String类实现了Comparable接口，这个接口中有一个抽象方法compareTo，String类中重写这个方法即可&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;          String a = &amp;quot;A&amp;quot;;
        String b = &amp;quot;B&amp;quot;;
        System.out.println(a.compareTo(b));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;【3】比较double类型数据：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;         double a = 9.6;
        double b = 9.3;
       /* System.out.println((int)(a-b));*/
        System.out.println(((Double) a).compareTo((Double) b));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;【4】比较自定义的数据类型：&lt;br&gt;（1）内部比较器：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;public class Student implements Comparable&amp;lt;Student&amp;gt;&amp;#123;
    private int age;
    private double height;
    private String name;
    public int getAge() &amp;#123;
        return age;
    &amp;#125;
    public void setAge(int age) &amp;#123;
        this.age = age;
    &amp;#125;
    public double getHeight() &amp;#123;
        return height;
    &amp;#125;
    public void setHeight(double height) &amp;#123;
        this.height = height;
    &amp;#125;
    public String getName() &amp;#123;
        return name;
    &amp;#125;
    public void setName(String name) &amp;#123;
        this.name = name;
    &amp;#125;
    public Student(int age, double height, String name) &amp;#123;
        this.age = age;
        this.height = height;
        this.name = name;
    &amp;#125;
    @Override
    public String toString() &amp;#123;
        return &amp;quot;Student&amp;#123;&amp;quot; +
                &amp;quot;age=&amp;quot; + age +
                &amp;quot;, height=&amp;quot; + height +
                &amp;quot;, name=&amp;#39;&amp;quot; + name + &amp;#39;\&amp;#39;&amp;#39; +
                &amp;#39;&amp;#125;&amp;#39;;
    &amp;#125;
    @Override
    public int compareTo(Student o) &amp;#123;
        //按照年龄进行比较：
        /*return this.getAge() - o.getAge();*/
        //按照身高比较
        /*return ((Double)(this.getHeight())).compareTo((Double)(o.getHeight()));*/
        //按照名字比较：
        return this.getName().compareTo(o.getName());
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;public class Test02 &amp;#123;
    //这是main方法，程序的入口
    public static void main(String[] args) &amp;#123;
        //比较两个学生：
        Student s1 = new Student(14,160.5,&amp;quot;alili&amp;quot;);
        Student s2 = new Student(14,170.5,&amp;quot;bnana&amp;quot;);
        System.out.println(s1.compareTo(s2));
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;（2）外部比较器：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;public class Student&amp;#123;
    private int age;
    private double height;
    private String name;
    public int getAge() &amp;#123;
        return age;
    &amp;#125;
    public void setAge(int age) &amp;#123;
        this.age = age;
    &amp;#125;
    public double getHeight() &amp;#123;
        return height;
    &amp;#125;
    public void setHeight(double height) &amp;#123;
        this.height = height;
    &amp;#125;
    public String getName() &amp;#123;
        return name;
    &amp;#125;
    public void setName(String name) &amp;#123;
        this.name = name;
    &amp;#125;
    public Student(int age, double height, String name) &amp;#123;
        this.age = age;
        this.height = height;
        this.name = name;
    &amp;#125;
    @Override
    public String toString() &amp;#123;
        return &amp;quot;Student&amp;#123;&amp;quot; +
                &amp;quot;age=&amp;quot; + age +
                &amp;quot;, height=&amp;quot; + height +
                &amp;quot;, name=&amp;#39;&amp;quot; + name + &amp;#39;\&amp;#39;&amp;#39; +
                &amp;#39;&amp;#125;&amp;#39;;
    &amp;#125;
&amp;#125;
class BiJiao01 implements Comparator&amp;lt;Student&amp;gt; &amp;#123;
    @Override
    public int compare(Student o1, Student o2) &amp;#123;
        //比较年龄：
        return o1.getAge()-o2.getAge();
    &amp;#125;
&amp;#125;
class BiJiao02 implements Comparator&amp;lt;Student&amp;gt; &amp;#123;
    @Override
    public int compare(Student o1, Student o2) &amp;#123;
        //比较姓名：
        return o1.getName().compareTo(o2.getName());
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;class BiJiao03 implements Comparator&amp;lt;Student&amp;gt; &amp;#123;
    @Override
    public int compare(Student o1, Student o2) &amp;#123;
        //在年龄相同的情况下 比较身高  年龄不同比较年龄
        if((o1.getAge()-o2.getAge())==0)&amp;#123;
            return ((Double)(o1.getHeight())).compareTo((Double)(o2.getHeight()));
        &amp;#125;else&amp;#123;//年龄不一样
            return o1.getAge()-o2.getAge();
        &amp;#125;
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;public class Test02 &amp;#123;
    //这是main方法，程序的入口
    public static void main(String[] args) &amp;#123;
        //比较两个学生：
        Student s1 = new Student(9,160.5,&amp;quot;alili&amp;quot;);
        Student s2 = new Student(14,170.5,&amp;quot;bnana&amp;quot;);
        //获取外部比较器：
        Comparator bj1 = new BiJiao03();
        System.out.println(bj1.compare(s1, s2));
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;【5】外部比较器和内部比较器 谁好呀？&lt;br&gt;答案：外部比较器，多态，扩展性好&lt;/p&gt;
&lt;h3 id=&#34;3-4-TreeSet实现类的使用&#34;&gt;&lt;a href=&#34;#3-4-TreeSet实现类的使用&#34; class=&#34;headerlink&#34; title=&#34;3.4 TreeSet实现类的使用&#34;&gt;&lt;/a&gt;3.4 TreeSet实现类的使用&lt;/h3&gt;&lt;p&gt;【1】存入Integer类型数据：（底层利用的是内部比较器）&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;package com.msb.test10;
import java.util.TreeSet;
/**
 * @author : msb-zhaoss
 */
public class Test01 &amp;#123;
    //这是main方法，程序的入口
    public static void main(String[] args) &amp;#123;
        //创建一个TreeSet:
        TreeSet&amp;lt;Integer&amp;gt; ts = new TreeSet&amp;lt;&amp;gt;();
        ts.add(12);
        ts.add(3);
        ts.add(7);
        ts.add(9);
        ts.add(3);
        ts.add(16);
        System.out.println(ts.size());
        System.out.println(ts);
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;特点：唯一，无序（没有按照输入顺序进行输出）， 有序（按照升序进行遍历）&lt;/p&gt;
&lt;p&gt;【2】原理：底层：二叉树（数据结构中的一个逻辑结构）&lt;/p&gt;
&lt;img data-src=&#34;/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618174503614.png&#34; class=&#34;&#34;&gt;


&lt;p&gt;【3】放入String类型数据：（底层实现类内部比较器）&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;public class Test02 &amp;#123;
    //这是main方法，程序的入口
    public static void main(String[] args) &amp;#123;
        //创建一个TreeSet:
        TreeSet&amp;lt;String&amp;gt; ts = new TreeSet&amp;lt;&amp;gt;();
        ts.add(&amp;quot;elili&amp;quot;);
        ts.add(&amp;quot;blili&amp;quot;);
        ts.add(&amp;quot;alili&amp;quot;);
        ts.add(&amp;quot;elili&amp;quot;);
        ts.add(&amp;quot;clili&amp;quot;);
        ts.add(&amp;quot;flili&amp;quot;);
        ts.add(&amp;quot;glili&amp;quot;);
        System.out.println(ts.size());
        System.out.println(ts);
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;【4】想放入自定义的Student类型的数据：&lt;br&gt;（1）利用内部比较器：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;public class Student implements Comparable&amp;lt;Student&amp;gt; &amp;#123;
    private int age;
    private String name;
    public int getAge() &amp;#123;
        return age;
    &amp;#125;
    public void setAge(int age) &amp;#123;
        this.age = age;
    &amp;#125;
    public String getName() &amp;#123;
        return name;
    &amp;#125;
    public void setName(String name) &amp;#123;
        this.name = name;
    &amp;#125;
    public Student(int age, String name) &amp;#123;
        this.age = age;
        this.name = name;
    &amp;#125;
    @Override
    public String toString() &amp;#123;
        return &amp;quot;Student&amp;#123;&amp;quot; +
                &amp;quot;age=&amp;quot; + age +
                &amp;quot;, name=&amp;#39;&amp;quot; + name + &amp;#39;\&amp;#39;&amp;#39; +
                &amp;#39;&amp;#125;&amp;#39;;
    &amp;#125;
    @Override
    public int compareTo(Student o) &amp;#123;
        return this.getAge()-o.getAge();
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;public class Test03 &amp;#123;
    //这是main方法，程序的入口
    public static void main(String[] args) &amp;#123;
        //创建一个TreeSet:
        TreeSet&amp;lt;Student&amp;gt; ts = new TreeSet&amp;lt;&amp;gt;();
        ts.add(new Student(10,&amp;quot;elili&amp;quot;));
        ts.add(new Student(8,&amp;quot;blili&amp;quot;));
        ts.add(new Student(4,&amp;quot;alili&amp;quot;));
        ts.add(new Student(9,&amp;quot;elili&amp;quot;));
        ts.add(new Student(10,&amp;quot;flili&amp;quot;));
        ts.add(new Student(1,&amp;quot;dlili&amp;quot;));
        System.out.println(ts.size());
        System.out.println(ts);
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;（2）通过外部比较器：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;public class Student  &amp;#123;
    private int age;
    private String name;
    public int getAge() &amp;#123;
        return age;
    &amp;#125;
    public void setAge(int age) &amp;#123;
        this.age = age;
    &amp;#125;
    public String getName() &amp;#123;
        return name;
    &amp;#125;
    public void setName(String name) &amp;#123;
        this.name = name;
    &amp;#125;
    public Student(int age, String name) &amp;#123;
        this.age = age;
        this.name = name;
    &amp;#125;
    @Override
    public String toString() &amp;#123;
        return &amp;quot;Student&amp;#123;&amp;quot; +
                &amp;quot;age=&amp;quot; + age +
                &amp;quot;, name=&amp;#39;&amp;quot; + name + &amp;#39;\&amp;#39;&amp;#39; +
                &amp;#39;&amp;#125;&amp;#39;;
    &amp;#125;
&amp;#125;
class BiJiao implements Comparator&amp;lt;Student&amp;gt;&amp;#123;
    @Override
    public int compare(Student o1, Student o2) &amp;#123;
        return o1.getName().compareTo(o2.getName());
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;public class Test03 &amp;#123;
    //这是main方法，程序的入口
    public static void main(String[] args) &amp;#123;
        //创建一个TreeSet:
        //利用外部比较器，必须自己制定：
        Comparator&amp;lt;Student&amp;gt; com = new BiJiao();
        TreeSet&amp;lt;Student&amp;gt; ts = new TreeSet&amp;lt;&amp;gt;(com);//一旦指定外部比较器，那么就会按照外部比较器来比较
        ts.add(new Student(10,&amp;quot;elili&amp;quot;));
        ts.add(new Student(8,&amp;quot;blili&amp;quot;));
        ts.add(new Student(4,&amp;quot;alili&amp;quot;));
        ts.add(new Student(9,&amp;quot;elili&amp;quot;));
        ts.add(new Student(10,&amp;quot;flili&amp;quot;));
        ts.add(new Student(1,&amp;quot;dlili&amp;quot;));
        System.out.println(ts.size());
        System.out.println(ts);
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;实际开发中利用外部比较器多，因为扩展性好（多态）&lt;/p&gt;
&lt;p&gt;换一种写法：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;public class Test03 &amp;#123;
    //这是main方法，程序的入口
    public static void main(String[] args) &amp;#123;
        //创建一个TreeSet:
        //利用外部比较器，必须自己制定：
        /*Comparator&amp;lt;Student&amp;gt; com = new Comparator&amp;lt;Student&amp;gt;() &amp;#123;
            @Override
            public int compare(Student o1, Student o2) &amp;#123;
                return o1.getName().compareTo(o2.getName());
            &amp;#125;
        &amp;#125;;*/
        TreeSet&amp;lt;Student&amp;gt; ts = new TreeSet&amp;lt;&amp;gt;(new Comparator&amp;lt;Student&amp;gt;() &amp;#123;
            @Override
            public int compare(Student o1, Student o2) &amp;#123;
                return o1.getName().compareTo(o2.getName());
            &amp;#125;
        &amp;#125;);//一旦指定外部比较器，那么就会按照外部比较器来比较
        ts.add(new Student(10,&amp;quot;elili&amp;quot;));
        ts.add(new Student(8,&amp;quot;blili&amp;quot;));
        ts.add(new Student(4,&amp;quot;alili&amp;quot;));
        ts.add(new Student(9,&amp;quot;elili&amp;quot;));
        ts.add(new Student(10,&amp;quot;flili&amp;quot;));
        ts.add(new Student(1,&amp;quot;dlili&amp;quot;));
        System.out.println(ts.size());
        System.out.println(ts);
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;【5】TreeSet底层的二叉树的遍历是按照升序的结果出现的，这个升序是靠中序遍历得到的：&lt;/p&gt;
&lt;img data-src=&#34;/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618174642838.png&#34; class=&#34;&#34;&gt;






&lt;h3 id=&#34;3-5-Collection部分整体结构图&#34;&gt;&lt;a href=&#34;#3-5-Collection部分整体结构图&#34; class=&#34;headerlink&#34; title=&#34;3.5 Collection部分整体结构图&#34;&gt;&lt;/a&gt;3.5 Collection部分整体结构图&lt;/h3&gt;&lt;img data-src=&#34;/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618174657969.png&#34; class=&#34;&#34;&gt;






&lt;h1 id=&#34;Map接口&#34;&gt;&lt;a href=&#34;#Map接口&#34; class=&#34;headerlink&#34; title=&#34;Map接口&#34;&gt;&lt;/a&gt;Map接口&lt;/h1&gt;&lt;h2 id=&#34;1-常用方法&#34;&gt;&lt;a href=&#34;#1-常用方法&#34; class=&#34;headerlink&#34; title=&#34;1 常用方法&#34;&gt;&lt;/a&gt;1 常用方法&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;package com.msb.test11;
import java.util.Collection;
import java.util.HashMap;
import java.util.Map;
import java.util.Set;
/**
 * @author : msb-zhaoss
 */
public class Test01 &amp;#123;
    //这是main方法，程序的入口
    public static void main(String[] args) &amp;#123;
        /*
        增加：put(K key, V value)
        删除：clear() remove(Object key)
        修改：
        查看：entrySet() get(Object key) keySet() size() values()
        判断：containsKey(Object key) containsValue(Object value)
            equals(Object o) isEmpty()
         */
        //创建一个Map集合：无序，唯一
        Map&amp;lt;String,Integer&amp;gt; map = new HashMap&amp;lt;&amp;gt;();
        System.out.println(map.put(&amp;quot;lili&amp;quot;, 10101010));
        map.put(&amp;quot;nana&amp;quot;,12345234);
        map.put(&amp;quot;feifei&amp;quot;,34563465);
        System.out.println(map.put(&amp;quot;lili&amp;quot;, 34565677));
        map.put(&amp;quot;mingming&amp;quot;,12323);
        /*map.clear();清空*/
        /*map.remove(&amp;quot;feifei&amp;quot;);移除*/
        System.out.println(map.size());
        System.out.println(map);
        System.out.println(map.containsKey(&amp;quot;lili&amp;quot;));
        System.out.println(map.containsValue(12323));
        Map&amp;lt;String,Integer&amp;gt; map2 = new HashMap&amp;lt;&amp;gt;();
        System.out.println(map2.put(&amp;quot;lili&amp;quot;, 10101010));
        map2.put(&amp;quot;nana&amp;quot;,12345234);
        map2.put(&amp;quot;feifei&amp;quot;,34563465);
        System.out.println(map2.put(&amp;quot;lili&amp;quot;, 34565677));
        map2.put(&amp;quot;mingming2&amp;quot;,12323);
        System.out.println(map==map2);
        System.out.println(map.equals(map2));//equals进行了重写，比较的是集合中的值是否一致
        System.out.println(&amp;quot;判断是否为空：&amp;quot;+map.isEmpty());
        System.out.println(map.get(&amp;quot;nana&amp;quot;));
        System.out.println(&amp;quot;-----------------------------------&amp;quot;);
        //keySet()对集合中的key进行遍历查看：
        Set&amp;lt;String&amp;gt; set = map.keySet();
        for(String s:set)&amp;#123;
            System.out.println(s);
        &amp;#125;
        System.out.println(&amp;quot;-----------------------------------&amp;quot;);
        //values()对集合中的value进行遍历查看：
        Collection&amp;lt;Integer&amp;gt; values = map.values();
        for(Integer i:values)&amp;#123;
            System.out.println(i);
        &amp;#125;
        System.out.println(&amp;quot;-----------------------------------&amp;quot;);
        //get(Object key) keySet()
        Set&amp;lt;String&amp;gt; set2 = map.keySet();
        for(String s:set2)&amp;#123;
            System.out.println(map.get(s));
        &amp;#125;
        System.out.println(&amp;quot;-----------------------------------&amp;quot;);
        //entrySet()
        Set&amp;lt;Map.Entry&amp;lt;String, Integer&amp;gt;&amp;gt; entries = map.entrySet();
        for(Map.Entry&amp;lt;String, Integer&amp;gt; e:entries)&amp;#123;
            System.out.println(e.getKey()+&amp;quot;----&amp;quot;+e.getValue());
        &amp;#125;
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;2-TreeMap&#34;&gt;&lt;a href=&#34;#2-TreeMap&#34; class=&#34;headerlink&#34; title=&#34;2 TreeMap&#34;&gt;&lt;/a&gt;2 TreeMap&lt;/h2&gt;&lt;p&gt;【1】key的类型为String类型：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;public class Test02 &amp;#123;
    //这是main方法，程序的入口
    public static void main(String[] args) &amp;#123;
        Map&amp;lt;String,Integer&amp;gt; map = new TreeMap&amp;lt;&amp;gt;();
        map.put(&amp;quot;blili&amp;quot;,1234);
        map.put(&amp;quot;alili&amp;quot;,2345);
        map.put(&amp;quot;blili&amp;quot;,5467);
        map.put(&amp;quot;clili&amp;quot;,5678);
        map.put(&amp;quot;dlili&amp;quot;,2345);
        System.out.println(map.size());
        System.out.println(map);
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;【2】key的类型是一个自定义的引用数据类型：&lt;br&gt;（1）内部比较器：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;public class Test03 &amp;#123;
    //这是main方法，程序的入口
    public static void main(String[] args) &amp;#123;
        Map&amp;lt;Student,Integer&amp;gt; map = new TreeMap&amp;lt;&amp;gt;();
        map.put(new Student(19,&amp;quot;blili&amp;quot;,170.5),1001);
        map.put(new Student(18,&amp;quot;blili&amp;quot;,150.5),1003);
        map.put(new Student(19,&amp;quot;alili&amp;quot;,180.5),1023);
        map.put(new Student(17,&amp;quot;clili&amp;quot;,140.5),1671);
        map.put(new Student(10,&amp;quot;dlili&amp;quot;,160.5),1891);
        System.out.println(map);
        System.out.println(map.size());
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;public class Student implements Comparable&amp;lt;Student&amp;gt;&amp;#123;
    private int age;
    private String name;
    private double height;
    public int getAge() &amp;#123;
        return age;
    &amp;#125;
    public void setAge(int age) &amp;#123;
        this.age = age;
    &amp;#125;
    public String getName() &amp;#123;
        return name;
    &amp;#125;
    public void setName(String name) &amp;#123;
        this.name = name;
    &amp;#125;
    public double getHeight() &amp;#123;
        return height;
    &amp;#125;
    public void setHeight(double height) &amp;#123;
        this.height = height;
    &amp;#125;
    public Student(int age, String name, double height) &amp;#123;
        this.age = age;
        this.name = name;
        this.height = height;
    &amp;#125;
    @Override
    public String toString() &amp;#123;
        return &amp;quot;Student&amp;#123;&amp;quot; +
                &amp;quot;age=&amp;quot; + age +
                &amp;quot;, name=&amp;#39;&amp;quot; + name + &amp;#39;\&amp;#39;&amp;#39; +
                &amp;quot;, height=&amp;quot; + height +
                &amp;#39;&amp;#125;&amp;#39;;
    &amp;#125;
    @Override
    public int compareTo(Student o) &amp;#123;
       /* return this.getAge()-o.getAge();*/
        return this.getName().compareTo(o.getName());
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;（2）外部比较器：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;public class Test03 &amp;#123;
    //这是main方法，程序的入口
    public static void main(String[] args) &amp;#123;
        Map&amp;lt;Student,Integer&amp;gt; map = new TreeMap&amp;lt;&amp;gt;(new Comparator&amp;lt;Student&amp;gt;() &amp;#123;
            @Override
            public int compare(Student o1, Student o2) &amp;#123;
                return ((Double)(o1.getHeight())).compareTo((Double)(o2.getHeight()));
            &amp;#125;
        &amp;#125;);
        map.put(new Student(19,&amp;quot;blili&amp;quot;,170.5),1001);
        map.put(new Student(18,&amp;quot;blili&amp;quot;,150.5),1003);
        map.put(new Student(19,&amp;quot;alili&amp;quot;,180.5),1023);
        map.put(new Student(17,&amp;quot;clili&amp;quot;,140.5),1671);
        map.put(new Student(10,&amp;quot;dlili&amp;quot;,160.5),1891);
        System.out.println(map);
        System.out.println(map.size());
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;3-Map部分整体结构图&#34;&gt;&lt;a href=&#34;#3-Map部分整体结构图&#34; class=&#34;headerlink&#34; title=&#34;3 Map部分整体结构图&#34;&gt;&lt;/a&gt;3 Map部分整体结构图&lt;/h2&gt;&lt;img data-src=&#34;/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618174919194.png&#34; class=&#34;&#34;&gt;


&lt;h2 id=&#34;4-源码部分&#34;&gt;&lt;a href=&#34;#4-源码部分&#34; class=&#34;headerlink&#34; title=&#34;4 源码部分&#34;&gt;&lt;/a&gt;4 源码部分&lt;/h2&gt;&lt;h3 id=&#34;4-1-HashMap&#34;&gt;&lt;a href=&#34;#4-1-HashMap&#34; class=&#34;headerlink&#34; title=&#34;4.1 HashMap&#34;&gt;&lt;/a&gt;4.1 HashMap&lt;/h3&gt;&lt;h4 id=&#34;4-1-1-代码展示特性&#34;&gt;&lt;a href=&#34;#4-1-1-代码展示特性&#34; class=&#34;headerlink&#34; title=&#34;4.1.1 代码展示特性&#34;&gt;&lt;/a&gt;4.1.1 代码展示特性&lt;/h4&gt;&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;public class Test &amp;#123;
    //这是main方法，程序的入口
    public static void main(String[] args) &amp;#123;
        //JDK1.7以后支持后面的&amp;lt;&amp;gt;中内容可以不写
        HashMap&amp;lt;Integer,String&amp;gt; hm = new HashMap&amp;lt;&amp;gt;();
        System.out.println(hm.put(12,&amp;quot;丽丽&amp;quot;));
        System.out.println(hm.put(7,&amp;quot;菲菲&amp;quot;));
        System.out.println(hm.put(19,&amp;quot;露露&amp;quot;));
        System.out.println(hm.put(12,&amp;quot;明明&amp;quot;));
        System.out.println(hm.put(6,&amp;quot;莹莹&amp;quot;));
        System.out.println(&amp;quot;集合的长度：&amp;quot;+hm.size());
        System.out.println(&amp;quot;集合中内容查看：&amp;quot;+hm);
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;结果展示：&lt;/p&gt;
&lt;img data-src=&#34;/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618175455959.png&#34; class=&#34;&#34;&gt;






&lt;h4 id=&#34;4-1-2-先演示原理&#34;&gt;&lt;a href=&#34;#4-1-2-先演示原理&#34; class=&#34;headerlink&#34; title=&#34;4.1.2 先演示原理&#34;&gt;&lt;/a&gt;4.1.2 先演示原理&lt;/h4&gt;&lt;p&gt;先演示原理图，再看源码，直接看的话，有的人接不上就蒙了：&lt;br&gt;相当于先看原理，然后从源码中验证这个原理是否正确：把图搞懂了，就是事倍功半的效果&lt;br&gt;原理如下：(JDK1.7)&lt;/p&gt;
&lt;img data-src=&#34;/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618175512371.png&#34; class=&#34;&#34;&gt;






&lt;h4 id=&#34;4-1-3-源码（JDK1-7版本）&#34;&gt;&lt;a href=&#34;#4-1-3-源码（JDK1-7版本）&#34; class=&#34;headerlink&#34; title=&#34;4.1.3 源码（JDK1.7版本）&#34;&gt;&lt;/a&gt;4.1.3 源码（JDK1.7版本）&lt;/h4&gt;&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;public class HashMap&amp;lt;K,V&amp;gt;
    extends AbstractMap&amp;lt;K,V&amp;gt; //【1】继承的AbstractMap中，已经实现了Map接口
        //【2】又实现了这个接口，多余，但是设计者觉得没有必要删除，就这么地了
    implements Map&amp;lt;K,V&amp;gt;, Cloneable, Serializable&amp;#123;
                
                
        //【3】后续会用到的重要属性：先粘贴过来：
    static final int DEFAULT_INITIAL_CAPACITY = 16;//哈希表主数组的默认长度
        //定义了一个float类型的变量，以后作为：默认的装填因子，加载因子是表示Hsah表中元素的填满的程度
        //太大容易引起哈西冲突，太小容易浪费  0.75是经过大量运算后得到的最好值
        //这个值其实可以自己改，但是不建议改，因为这个0.75是大量运算得到的
        static final float DEFAULT_LOAD_FACTOR = 0.75f;
        transient Entry&amp;lt;K,V&amp;gt;[] table;//主数组,每个元素为Entry类型
        transient int size;
        int threshold;//数组扩容的界限值,门槛值   16*0.75=12 
        final float loadFactor;//用来接收装填因子的变量
        
        //【4】查看构造器：内部相当于：this(16,0.75f);调用了当前类中的带参构造器
        public HashMap() &amp;#123;
        this(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR);
    &amp;#125;
        //【5】本类中带参数构造器：--》作用给一些数值进行初始化的！
        public HashMap(int initialCapacity, float loadFactor) &amp;#123;
        //【6】给capacity赋值，capacity的值一定是 大于你传进来的initialCapacity 的 最小的 2的倍数
        int capacity = 1;
        while (capacity &amp;lt; initialCapacity)
            capacity &amp;lt;&amp;lt;= 1;
                //【7】给loadFactor赋值，将装填因子0.75赋值给loadFactor
        this.loadFactor = loadFactor;
                //【8】数组扩容的界限值,门槛值
        threshold = (int)Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + 1);
                
                //【9】给table数组赋值，初始化数组长度为16
        table = new Entry[capacity];
                   
    &amp;#125;
        //【10】调用put方法：
        public V put(K key, V value) &amp;#123;
                //【11】对空值的判断
        if (key == null)
            return putForNullKey(value);
                //【12】调用hash方法，获取哈希码
        int hash = hash(key);
                //【14】得到key对应在数组中的位置
        int i = indexFor(hash, table.length);
                //【16】如果你放入的元素，在主数组那个位置上没有值，e==null  那么下面这个循环不走
                //当在同一个位置上放入元素的时候
        for (Entry&amp;lt;K,V&amp;gt; e = table[i]; e != null; e = e.next) &amp;#123;
            Object k;
                        //哈希值一样  并且  equals相比一样   
                        //(k = e.key) == key  如果是一个对象就不用比较equals了
            if (e.hash == hash &amp;amp;&amp;amp; ((k = e.key) == key || key.equals(k))) &amp;#123;
                V oldValue = e.value;
                e.value = value;
                e.recordAccess(this);
                return oldValue;
            &amp;#125;
        &amp;#125;
        modCount++;
                //【17】走addEntry添加这个节点的方法：
        addEntry(hash, key, value, i);
        return null;
    &amp;#125;
        
        //【13】hash方法返回这个key对应的哈希值，内部进行二次散列，为了尽量保证不同的key得到不同的哈希码！
        final int hash(Object k) &amp;#123;
        int h = 0;
        if (useAltHashing) &amp;#123;
            if (k instanceof String) &amp;#123;
                return sun.misc.Hashing.stringHash32((String) k);
            &amp;#125;
            h = hashSeed;
        &amp;#125;
                //k.hashCode()函数调用的是key键值类型自带的哈希函数，
                //由于不同的对象其hashCode()有可能相同，所以需对hashCode()再次哈希，以降低相同率。
        h ^= k.hashCode();
        // This function ensures that hashCodes that differ only by
        // constant multiples at each bit position have a bounded
        // number of collisions (approximately 8 at default load factor).
                /*
                接下来的一串与运算和异或运算，称之为“扰动函数”，
                扰动的核心思想在于使计算出来的值在保留原有相关特性的基础上，
                增加其值的不确定性，从而降低冲突的概率。
                不同的版本实现的方式不一样，但其根本思想是一致的。
                往右移动的目的，就是为了将h的高位利用起来，减少哈西冲突
                */
        h ^= (h &amp;gt;&amp;gt;&amp;gt; 20) ^ (h &amp;gt;&amp;gt;&amp;gt; 12);
        return h ^ (h &amp;gt;&amp;gt;&amp;gt; 7) ^ (h &amp;gt;&amp;gt;&amp;gt; 4);
    &amp;#125;
        //【15】返回int类型数组的坐标
        static int indexFor(int h, int length) &amp;#123;
                //其实这个算法就是取模运算：h%length，取模效率不如位运算
        return h &amp;amp; (length-1);
    &amp;#125;
        //【18】调用addEntry
        void addEntry(int hash, K key, V value, int bucketIndex) &amp;#123;
                //【25】size的大小  大于 16*0.75=12的时候，比如你放入的是第13个，这第13个你打算放在没有元素的位置上的时候
        if ((size &amp;gt;= threshold) &amp;amp;&amp;amp; (null != table[bucketIndex])) &amp;#123;
                        //【26】主数组扩容为2倍
            resize(2 * table.length);
                        //【30】重新调整当前元素的hash码
            hash = (null != key) ? hash(key) : 0;
                        //【31】重新计算元素位置
            bucketIndex = indexFor(hash, table.length);
        &amp;#125;
                //【19】将hash,key,value,bucketIndex位置  封装为一个Entry对象：
        createEntry(hash, key, value, bucketIndex);
    &amp;#125;
        //【20】
        void createEntry(int hash, K key, V value, int bucketIndex) &amp;#123;
                //【21】获取bucketIndex位置上的元素给e
        Entry&amp;lt;K,V&amp;gt; e = table[bucketIndex];
                //【22】然后将hash, key, value封装为一个对象，然后将下一个元素的指向为e （链表的头插法）
                //【23】将新的Entry放在table[bucketIndex]的位置上
        table[bucketIndex] = new Entry&amp;lt;&amp;gt;(hash, key, value, e);
                //【24】集合中加入一个元素 size+1
        size++;
    &amp;#125;
    //【27】
        void resize(int newCapacity) &amp;#123;
        Entry[] oldTable = table;
        int oldCapacity = oldTable.length;
        if (oldCapacity == MAXIMUM_CAPACITY) &amp;#123;
            threshold = Integer.MAX_VALUE;
            return;
        &amp;#125;
                //【28】创建长度为newCapacity的数组
        Entry[] newTable = new Entry[newCapacity];
        boolean oldAltHashing = useAltHashing;
        useAltHashing |= sun.misc.VM.isBooted() &amp;amp;&amp;amp;
                (newCapacity &amp;gt;= Holder.ALTERNATIVE_HASHING_THRESHOLD);
        boolean rehash = oldAltHashing ^ useAltHashing;
                //【28.5】转让方法：将老数组中的东西都重新放入新数组中
        transfer(newTable, rehash);
                //【29】老数组替换为新数组
        table = newTable;
                //【29.5】重新计算
        threshold = (int)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + 1);
    &amp;#125;
        //【28.6】
        void transfer(Entry[] newTable, boolean rehash) &amp;#123;
        int newCapacity = newTable.length;
        for (Entry&amp;lt;K,V&amp;gt; e : table) &amp;#123;
            while(null != e) &amp;#123;
                Entry&amp;lt;K,V&amp;gt; next = e.next;
                if (rehash) &amp;#123;
                    e.hash = null == e.key ? 0 : hash(e.key);
                &amp;#125;
                                //【28.7】将哈希值，和新的数组容量传进去，重新计算key在新数组中的位置
                int i = indexFor(e.hash, newCapacity);
                                //【28.8】头插法
                e.next = newTable[i];//获取链表上元素给e.next
                newTable[i] = e;//然后将e放在i位置 
                e = next;//e再指向下一个节点继续遍历
            &amp;#125;
        &amp;#125;
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;4-1-4-细节讲解：主数组的长度为2的倍数&#34;&gt;&lt;a href=&#34;#4-1-4-细节讲解：主数组的长度为2的倍数&#34; class=&#34;headerlink&#34; title=&#34;4.1.4  细节讲解：主数组的长度为2的倍数&#34;&gt;&lt;/a&gt;4.1.4  细节讲解：主数组的长度为2的倍数&lt;/h4&gt;&lt;p&gt;【1】主数组的长度为2的倍数，&lt;/p&gt;
&lt;img data-src=&#34;/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618175628889.png&#34; class=&#34;&#34;&gt;


&lt;p&gt;因为这个length的长度，会影响 key的位置：&lt;br&gt;key的位置的计算：&lt;/p&gt;
&lt;img data-src=&#34;/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618175638657.png&#34; class=&#34;&#34;&gt;




&lt;p&gt;实际上这个算法就是：  h%length   ,但是取模的话  效率太低，所以用位运算效率会很高。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;原因1：&lt;/strong&gt;&lt;br&gt;&lt;img data-src=&#34;/img/image-20220618175703663.png&#34; alt=&#34;image-20220618175703663&#34;&gt;和&lt;img data-src=&#34;/img/image-20220618175712379.png&#34; alt=&#34;image-20220618175712379&#34;&gt;等效的前提就是  length必须是2的整数倍&lt;br&gt;&lt;strong&gt;原因2：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果不是2的整数倍，那么 哈西碰撞 哈西冲突的概率就高了很多&lt;/p&gt;
&lt;p&gt;位运算 就  涉及  到  length是不是2的整数倍：&lt;br&gt;比如是2的整数倍：&lt;/p&gt;
&lt;img data-src=&#34;/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618175753914.png&#34; class=&#34;&#34;&gt;


&lt;img data-src=&#34;/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618175800521.png&#34; class=&#34;&#34;&gt;


&lt;p&gt;并且这个得到的索引值，一定在 0-15之间（数组是16的时候）：&lt;/p&gt;
&lt;img data-src=&#34;/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618175840905.png&#34; class=&#34;&#34;&gt;


&lt;p&gt;当然如果你扩容后数组长度为 32，那么这个索引就在0-31之间&lt;/p&gt;
&lt;p&gt;比如如果不是2的整数倍：&lt;/p&gt;
&lt;img data-src=&#34;/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618175850530.png&#34; class=&#34;&#34;&gt;


&lt;p&gt;发现：如果不是2的整数倍，那么 哈西碰撞 哈西冲突的概率就高了很多&lt;/p&gt;
&lt;h4 id=&#34;4-1-5-细节讲解：装填因子0-75的原因&#34;&gt;&lt;a href=&#34;#4-1-5-细节讲解：装填因子0-75的原因&#34; class=&#34;headerlink&#34; title=&#34;4.1.5 细节讲解：装填因子0.75的原因&#34;&gt;&lt;/a&gt;4.1.5 细节讲解：装填因子0.75的原因&lt;/h4&gt;&lt;p&gt;如果装填因子是1， 那么数组满了再扩容，可以做到  最大的空间利用率&lt;br&gt;但是这是一个理想状态，元素不可能完全的均匀分布，很可能就哈西碰撞产生链表了。产生链表的话 查询时间就长了。&lt;br&gt;—》空间好，时间不好&lt;/p&gt;
&lt;p&gt;那么有人说 ，把装填因子搞小一点，0.5，  如果是0.5的话，就浪费空间，但是可以做到 到0.5就扩容 ，然后哈西碰撞就少，&lt;br&gt;不产生链表的话，那么查询效率很高&lt;br&gt;—》时间好，空间不好&lt;/p&gt;
&lt;p&gt;所以在空间和时间中，&lt;br&gt;取中间值，平衡这个因素 就取值为 0.75&lt;/p&gt;
&lt;img data-src=&#34;/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618175921895.png&#34; class=&#34;&#34;&gt;


&lt;p&gt;&lt;strong&gt;1.8版本&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;1-8底层遵照-哈希表结构-红黑树&#34;&gt;&lt;a href=&#34;#1-8底层遵照-哈希表结构-红黑树&#34; class=&#34;headerlink&#34; title=&#34;1.8底层遵照 哈希表结构 + 红黑树&#34;&gt;&lt;/a&gt;1.8底层遵照 &lt;font color=red &gt;哈希表结构 + 红黑树&lt;/font&gt;&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;// HashMap&amp;lt;String,Integer&amp;gt; map = new HashMap&amp;lt;&amp;gt;(); --&amp;gt;JDK 1.7开始类型推断，后面用钻石运算符即可。
public class HashMap&amp;lt;K,V&amp;gt; extends AbstractMap&amp;lt;K,V&amp;gt; 		//【1】继承的AbstractMap中，已经实现了Map接口
    implements Map&amp;lt;K,V&amp;gt;, Cloneable, Serializable &amp;#123; //【2】又实现了这个接口，多余，但是集合的设计者觉得没有必要删除，就这么地了

    //------------------属性部分：
    final float loadFactor;//【3-2】用来接收装填因子的变量
    /*
        【3-3】
        定义了一个float类型的变量，以后作为：默认的装填因子，加载因子是表示Hsah表中元素的填满的程度
        太大容易引起哈西冲突，太小容易浪费  0.75是经过大量运算后得到的最好值
        这个值其实可以自己改，但是不建议改，因为这个0.75是大量运算得到的
    */
    static final float DEFAULT_LOAD_FACTOR = 0.75f;
    int threshold;//【6-3】数组扩容的界限值,门槛值
    transient Node&amp;lt;K,V&amp;gt;[] table;//【7-5】底层主数组
    //------------------构造器：
    //【3】调用空构造器
    public HashMap() &amp;#123;
        //【3-1】给装填因子loadFactor赋值
        this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted
    &amp;#125;
    
    //【4】调用有参构造器：
    public HashMap(int initialCapacity) &amp;#123;
        //【5】调用两个参数构造器
        this(initialCapacity, DEFAULT_LOAD_FACTOR);
    &amp;#125;
    //【6】
    public HashMap(int initialCapacity, float loadFactor) &amp;#123;
        //【6-1】健壮性考虑，传入的数据过小不行，过大不行
        if (initialCapacity &amp;lt; 0)
            throw new IllegalArgumentException(&amp;quot;Illegal initial capacity: &amp;quot; +
                                               initialCapacity);
        if (initialCapacity &amp;gt; MAXIMUM_CAPACITY)
            initialCapacity = MAXIMUM_CAPACITY;
        if (loadFactor &amp;lt;= 0 || Float.isNaN(loadFactor))
            throw new IllegalArgumentException(&amp;quot;Illegal load factor: &amp;quot; +
                                               loadFactor);
        //【6-2】给装填因子loadFactor赋值，赋值为0.75，这个值可以单独传入改变，但是不建议改变，一般都用默认的0.75
        this.loadFactor = loadFactor;
        //【6-3】给threshold赋值 
        this.threshold = tableSizeFor(initialCapacity);
    &amp;#125;
    //【6-4】返回的是大于initialCapacity的最接近的2的整数倍  ，比如initialCapacity传入10，这个方法返回16
    static final int tableSizeFor(int cap) &amp;#123;//（内部内容讲源码时候不用管，面试题中详讲）
        int n = cap - 1;
        n |= n &amp;gt;&amp;gt;&amp;gt; 1;
        n |= n &amp;gt;&amp;gt;&amp;gt; 2;
        n |= n &amp;gt;&amp;gt;&amp;gt; 4;
        n |= n &amp;gt;&amp;gt;&amp;gt; 8;
        n |= n &amp;gt;&amp;gt;&amp;gt; 16;
        return (n &amp;lt; 0) ? 1 : (n &amp;gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;
    &amp;#125;
    
    //------------------方法：
    //【7】调用put方法
    public V put(K key, V value) &amp;#123;
        //【7-1】首先调用hash方法计算哈希值：
        //【7-3】调用putVal方法传入五个参数：
        return putVal(hash(key), key, value, false, true);
    &amp;#125;
    //【7-2】计算hash值
    static final int hash(Object key) &amp;#123;
        int h;
        return (key == null) ? 0 : (h = key.hashCode()) ^ (h &amp;gt;&amp;gt;&amp;gt; 16);
    &amp;#125;
    //【7-4】调用
    final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
                   boolean evict) &amp;#123;
        Node&amp;lt;K,V&amp;gt;[] tab;
        Node&amp;lt;K,V&amp;gt; p; 
        int n, i;
        //【7-6】将底层主数组table给tab，判断是否为null，第一次放数据一定是null
        if ((tab = table) == null || (n = tab.length) == 0)
            //【7-7】走入if分支：table是null，就对table进行扩容，走进resize方法
            n = (tab = resize()).length;//【7-21】table的length为16 ，n为16
        /*
        【7-22】
        i = (n - 1) &amp;amp; hash 根据哈希值和n计算放入数组的位置
        取出这个位置上的元素，看是否为空，如果是第一个元素，一定是null
        */
        if ((p = tab[i = (n - 1) &amp;amp; hash]) == null)
            //【7-23】在这个位置上将元素封装为Node对象，放入对应位置
            tab[i] = newNode(hash, key, value, null);//封装Node节点new Node&amp;lt;&amp;gt;(hash, key, value, null);
        else &amp;#123;
            Node&amp;lt;K,V&amp;gt; e; K k;
            if (p.hash == hash &amp;amp;&amp;amp;
                ((k = p.key) == key || (key != null &amp;amp;&amp;amp; key.equals(k))))
                e = p;
            else if (p instanceof TreeNode)
                e = ((TreeNode&amp;lt;K,V&amp;gt;)p).putTreeVal(this, tab, hash, key, value);
            else &amp;#123;
                for (int binCount = 0; ; ++binCount) &amp;#123;
                    if ((e = p.next) == null) &amp;#123;
                        p.next = newNode(hash, key, value, null);
                        if (binCount &amp;gt;= TREEIFY_THRESHOLD - 1)  
                            treeifyBin(tab, hash);
                        break;
                    &amp;#125;
                    if (e.hash == hash &amp;amp;&amp;amp;
                        ((k = e.key) == key || (key != null &amp;amp;&amp;amp; key.equals(k))))
                        break;
                    p = e;
                &amp;#125;
            &amp;#125;
            if (e != null) &amp;#123;  
                V oldValue = e.value;
                if (!onlyIfAbsent || oldValue == null)
                    e.value = value;
                afterNodeAccess(e);
                return oldValue;
            &amp;#125;
        &amp;#125;
        ++modCount;
        //【7-25】size指的是放入集合的键值总数，size++操作，不大于threshold，resize方法不走
        if (++size &amp;gt; threshold)
            resize();
        afterNodeInsertion(evict);
        return null;
    &amp;#125;
    //【7-8】resize方法：---》假设最开始走的是HashMap的空构造器：
    final Node&amp;lt;K,V&amp;gt;[] resize() &amp;#123;
        Node&amp;lt;K,V&amp;gt;[] oldTab = table;//【7-9】table 是null
        int oldCap = (oldTab == null) ? 0 : oldTab.length; //【7-10】oldCap:0
        int oldThr = threshold;//【7-11】threshold为16，oldThr：16
        int newCap, newThr = 0;
        if (oldCap &amp;gt; 0) &amp;#123;//【7-12】不走
            if (oldCap &amp;gt;= MAXIMUM_CAPACITY) &amp;#123;
                threshold = Integer.MAX_VALUE;
                return oldTab;
            &amp;#125;
            else if ((newCap = oldCap &amp;lt;&amp;lt; 1) &amp;lt; MAXIMUM_CAPACITY &amp;amp;&amp;amp;
                     oldCap &amp;gt;= DEFAULT_INITIAL_CAPACITY)
                newThr = oldThr &amp;lt;&amp;lt; 1;
        &amp;#125;
        else if (oldThr &amp;gt; 0)  //【7-13】走
            newCap = oldThr;//newCap=16
        else &amp;#123;               //【7-14】不走
             
            newCap = DEFAULT_INITIAL_CAPACITY;
             
            newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);
        &amp;#125;
        if (newThr == 0) &amp;#123;//【7-15】走
            float ft = (float)newCap * loadFactor;//【7-16】ft: 16*0.75=12
            newThr = (newCap &amp;lt; MAXIMUM_CAPACITY &amp;amp;&amp;amp; ft &amp;lt; (float)MAXIMUM_CAPACITY ?
                      (int)ft : Integer.MAX_VALUE); //【7-17】newThr = 12
        &amp;#125;
        //【7-18】threshold赋值为newThr为12， ---》所以走空构造器这里threshold赋值为12，走有参构造器里面threshold赋值为12？？？？
        threshold = newThr;
        @SuppressWarnings(&amp;#123;&amp;quot;rawtypes&amp;quot;,&amp;quot;unchecked&amp;quot;&amp;#125;)
        //【7-19】创建Node数组，长度为newCap16
            Node&amp;lt;K,V&amp;gt;[] newTab = (Node&amp;lt;K,V&amp;gt;[])new Node[newCap];
        //【7-20】table赋值为newTab
        table = newTab;
        if (oldTab != null) &amp;#123;
            for (int j = 0; j &amp;lt; oldCap; ++j) &amp;#123;
                Node&amp;lt;K,V&amp;gt; e;
                if ((e = oldTab[j]) != null) &amp;#123;
                    oldTab[j] = null;
                    if (e.next == null)
                        newTab[e.hash &amp;amp; (newCap - 1)] = e;
                    else if (e instanceof TreeNode)
                        ((TreeNode&amp;lt;K,V&amp;gt;)e).split(this, newTab, j, oldCap);
                    else &amp;#123; 
                        Node&amp;lt;K,V&amp;gt; loHead = null, loTail = null;
                        Node&amp;lt;K,V&amp;gt; hiHead = null, hiTail = null;
                        Node&amp;lt;K,V&amp;gt; next;
                        do &amp;#123;
                            next = e.next;
                            if ((e.hash &amp;amp; oldCap) == 0) &amp;#123;
                                if (loTail == null)
                                    loHead = e;
                                else
                                    loTail.next = e;
                                loTail = e;
                            &amp;#125;
                            else &amp;#123;
                                if (hiTail == null)
                                    hiHead = e;
                                else
                                    hiTail.next = e;
                                hiTail = e;
                            &amp;#125;
                        &amp;#125; while ((e = next) != null);
                        if (loTail != null) &amp;#123;
                            loTail.next = null;
                            newTab[j] = loHead;
                        &amp;#125;
                        if (hiTail != null) &amp;#123;
                            hiTail.next = null;
                            newTab[j + oldCap] = hiHead;
                        &amp;#125;
                    &amp;#125;
                &amp;#125;
            &amp;#125;
        &amp;#125;
        return newTab;
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;public class HashMap&amp;lt;K,V&amp;gt; extends AbstractMap&amp;lt;K,V&amp;gt; 
    implements Map&amp;lt;K,V&amp;gt;, Cloneable, Serializable &amp;#123; 
    final float loadFactor;
    static final float DEFAULT_LOAD_FACTOR = 0.75f;
    int threshold;
    transient Node&amp;lt;K,V&amp;gt;[] table;
    public HashMap() &amp;#123;
        this.loadFactor = DEFAULT_LOAD_FACTOR; 
    &amp;#125;
    
    public HashMap(int initialCapacity) &amp;#123;
        this(initialCapacity, DEFAULT_LOAD_FACTOR);
    &amp;#125;
    public HashMap(int initialCapacity, float loadFactor) &amp;#123;
        if (initialCapacity &amp;lt; 0)
            throw new IllegalArgumentException(&amp;quot;Illegal initial capacity: &amp;quot; +
                                               initialCapacity);
        if (initialCapacity &amp;gt; MAXIMUM_CAPACITY)
            initialCapacity = MAXIMUM_CAPACITY;
        if (loadFactor &amp;lt;= 0 || Float.isNaN(loadFactor))
            throw new IllegalArgumentException(&amp;quot;Illegal load factor: &amp;quot; +
                                               loadFactor);
        this.loadFactor = loadFactor;
        this.threshold = tableSizeFor(initialCapacity);
    &amp;#125;
    static final int tableSizeFor(int cap) &amp;#123;
        int n = cap - 1;
        n |= n &amp;gt;&amp;gt;&amp;gt; 1;
        n |= n &amp;gt;&amp;gt;&amp;gt; 2;
        n |= n &amp;gt;&amp;gt;&amp;gt; 4;
        n |= n &amp;gt;&amp;gt;&amp;gt; 8;
        n |= n &amp;gt;&amp;gt;&amp;gt; 16;
        return (n &amp;lt; 0) ? 1 : (n &amp;gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;
    &amp;#125;
    
    //【8-1】put方法
    public V put(K key, V value) &amp;#123;
        //计算hash值
        return putVal(hash(key), key, value, false, true);
    &amp;#125;

    static final int hash(Object key) &amp;#123;
        int h;
        return (key == null) ? 0 : (h = key.hashCode()) ^ (h &amp;gt;&amp;gt;&amp;gt; 16);
    &amp;#125;
    //【8-2】调用putVal方法
    final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
                   boolean evict) &amp;#123;
        Node&amp;lt;K,V&amp;gt;[] tab;
        Node&amp;lt;K,V&amp;gt; p; 
        int n, i;
        
        //【8-3】table不空了，不走if		
        if ((tab = table) == null || (n = tab.length) == 0)
            n = (tab = resize()).length;
        //【8-4】tab[i]不null，不走if
        if ((p = tab[i = (n - 1) &amp;amp; hash]) == null)
            tab[i] = newNode(hash, key, value, null);
        else &amp;#123;
            Node&amp;lt;K,V&amp;gt; e; K k;
            /*
                【8-5】
                判断p.hash == hash哈希值是否相等，即使hash相等也要做&amp;amp;&amp;amp;后续的判断，因为两个对象哈希值相等是有可能的
                (k = p.key) == key   == 比较地址值，String的话一样，不是字符串地址也不一样，
                Animal a1 = new Animal(19);		和 	Animal a2 = new Animal(19);	地址一定不同，就需要用后面的equals进行比较
            */
            if (p.hash == hash &amp;amp;&amp;amp;
                ((k = p.key) == key || (key != null &amp;amp;&amp;amp; key.equals(k))))   //----》哈希值相等，出现哈西碰撞
                //【8-6】将该数组位置的数据给e
                e = p;
            else if (p instanceof TreeNode)
                e = ((TreeNode&amp;lt;K,V&amp;gt;)p).putTreeVal(this, tab, hash, key, value);
            else &amp;#123;
                for (int binCount = 0; ; ++binCount) &amp;#123;
                    if ((e = p.next) == null) &amp;#123;
                        p.next = newNode(hash, key, value, null);
                        if (binCount &amp;gt;= TREEIFY_THRESHOLD - 1)  
                            treeifyBin(tab, hash);
                        break;
                    &amp;#125;
                    if (e.hash == hash &amp;amp;&amp;amp;
                        ((k = e.key) == key || (key != null &amp;amp;&amp;amp; key.equals(k))))
                        break;
                    p = e;
                &amp;#125;
            &amp;#125;
            if (e != null) &amp;#123;  
                V oldValue = e.value;
                if (!onlyIfAbsent || oldValue == null)
                    e.value = value;//【8-7】新value替换老value
                afterNodeAccess(e);
                return oldValue;//【8-8】返回老value
            &amp;#125;
        &amp;#125;
        ++modCount;

        if (++size &amp;gt; threshold)
            resize();
        afterNodeInsertion(evict);
        return null;
    &amp;#125;

    final Node&amp;lt;K,V&amp;gt;[] resize() &amp;#123;
        Node&amp;lt;K,V&amp;gt;[] oldTab = table;
        int oldCap = (oldTab == null) ? 0 : oldTab.length; 
        int oldThr = threshold;
        int newCap, newThr = 0;
        if (oldCap &amp;gt; 0) &amp;#123;
            if (oldCap &amp;gt;= MAXIMUM_CAPACITY) &amp;#123;
                threshold = Integer.MAX_VALUE;
                return oldTab;
            &amp;#125;
            else if ((newCap = oldCap &amp;lt;&amp;lt; 1) &amp;lt; MAXIMUM_CAPACITY &amp;amp;&amp;amp;
                     oldCap &amp;gt;= DEFAULT_INITIAL_CAPACITY)
                newThr = oldThr &amp;lt;&amp;lt; 1;
        &amp;#125;
        else if (oldThr &amp;gt; 0) 
            newCap = oldThr;
        else &amp;#123;    
            newCap = DEFAULT_INITIAL_CAPACITY;
            newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);
        &amp;#125;
        if (newThr == 0) &amp;#123;
            float ft = (float)newCap * loadFactor;
            newThr = (newCap &amp;lt; MAXIMUM_CAPACITY &amp;amp;&amp;amp; ft &amp;lt; (float)MAXIMUM_CAPACITY ?
                      (int)ft : Integer.MAX_VALUE);
        &amp;#125;
        threshold = newThr;
        @SuppressWarnings(&amp;#123;&amp;quot;rawtypes&amp;quot;,&amp;quot;unchecked&amp;quot;&amp;#125;)
            Node&amp;lt;K,V&amp;gt;[] newTab = (Node&amp;lt;K,V&amp;gt;[])new Node[newCap];
        table = newTab;
        if (oldTab != null) &amp;#123;
            for (int j = 0; j &amp;lt; oldCap; ++j) &amp;#123;
                Node&amp;lt;K,V&amp;gt; e;
                if ((e = oldTab[j]) != null) &amp;#123;
                    oldTab[j] = null;
                    if (e.next == null)
                        newTab[e.hash &amp;amp; (newCap - 1)] = e;
                    else if (e instanceof TreeNode)
                        ((TreeNode&amp;lt;K,V&amp;gt;)e).split(this, newTab, j, oldCap);
                    else &amp;#123; 
                        Node&amp;lt;K,V&amp;gt; loHead = null, loTail = null;
                        Node&amp;lt;K,V&amp;gt; hiHead = null, hiTail = null;
                        Node&amp;lt;K,V&amp;gt; next;
                        do &amp;#123;
                            next = e.next;
                            if ((e.hash &amp;amp; oldCap) == 0) &amp;#123;
                                if (loTail == null)
                                    loHead = e;
                                else
                                    loTail.next = e;
                                loTail = e;
                            &amp;#125;
                            else &amp;#123;
                                if (hiTail == null)
                                    hiHead = e;
                                else
                                    hiTail.next = e;
                                hiTail = e;
                            &amp;#125;
                        &amp;#125; while ((e = next) != null);
                        if (loTail != null) &amp;#123;
                            loTail.next = null;
                            newTab[j] = loHead;
                        &amp;#125;
                        if (hiTail != null) &amp;#123;
                            hiTail.next = null;
                            newTab[j + oldCap] = hiHead;
                        &amp;#125;
                    &amp;#125;
                &amp;#125;
            &amp;#125;
        &amp;#125;
        return newTab;
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;public class HashMap&amp;lt;K,V&amp;gt; extends AbstractMap&amp;lt;K,V&amp;gt; 
    implements Map&amp;lt;K,V&amp;gt;, Cloneable, Serializable &amp;#123; 
    final float loadFactor;
    static final float DEFAULT_LOAD_FACTOR = 0.75f;
    int threshold;
    transient Node&amp;lt;K,V&amp;gt;[] table;
    public HashMap() &amp;#123;
        this.loadFactor = DEFAULT_LOAD_FACTOR; 
    &amp;#125;
    
    public HashMap(int initialCapacity) &amp;#123;
        this(initialCapacity, DEFAULT_LOAD_FACTOR);
    &amp;#125;
    public HashMap(int initialCapacity, float loadFactor) &amp;#123;
        if (initialCapacity &amp;lt; 0)
            throw new IllegalArgumentException(&amp;quot;Illegal initial capacity: &amp;quot; +
                                               initialCapacity);
        if (initialCapacity &amp;gt; MAXIMUM_CAPACITY)
            initialCapacity = MAXIMUM_CAPACITY;
        if (loadFactor &amp;lt;= 0 || Float.isNaN(loadFactor))
            throw new IllegalArgumentException(&amp;quot;Illegal load factor: &amp;quot; +
                                               loadFactor);
        this.loadFactor = loadFactor;
        this.threshold = tableSizeFor(initialCapacity);
    &amp;#125;
    static final int tableSizeFor(int cap) &amp;#123;
        int n = cap - 1;
        n |= n &amp;gt;&amp;gt;&amp;gt; 1;
        n |= n &amp;gt;&amp;gt;&amp;gt; 2;
        n |= n &amp;gt;&amp;gt;&amp;gt; 4;
        n |= n &amp;gt;&amp;gt;&amp;gt; 8;
        n |= n &amp;gt;&amp;gt;&amp;gt; 16;
        return (n &amp;lt; 0) ? 1 : (n &amp;gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;
    &amp;#125;
    
    //【9-1】put方法
    public V put(K key, V value) &amp;#123;
        //计算hash值
        return putVal(hash(key), key, value, false, true);
    &amp;#125;

    static final int hash(Object key) &amp;#123;
        int h;
        return (key == null) ? 0 : (h = key.hashCode()) ^ (h &amp;gt;&amp;gt;&amp;gt; 16);
    &amp;#125;
    //【9-2】调用putVal方法
    final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
                   boolean evict) &amp;#123;
        Node&amp;lt;K,V&amp;gt;[] tab;
        Node&amp;lt;K,V&amp;gt; p; 
        int n, i;
        
        //【9-3】table不空了，不走if		
        if ((tab = table) == null || (n = tab.length) == 0)
            n = (tab = resize()).length;
        //【9-4】tab[i]不null，不走if
        if ((p = tab[i = (n - 1) &amp;amp; hash]) == null)
            tab[i] = newNode(hash, key, value, null);
        else &amp;#123;
            Node&amp;lt;K,V&amp;gt; e; K k;
            /*
                【9-5】
                判断p.hash == hash哈希值是否相等，即使hash相等也要做&amp;amp;&amp;amp;后续的判断，因为两个对象哈希值相等是有可能的
                此时“通话”和“重地”的哈希值一致，但是key不一致，if不走
            */
            if (p.hash == hash &amp;amp;&amp;amp;
                ((k = p.key) == key || (key != null &amp;amp;&amp;amp; key.equals(k))))
                e = p;
            else if (p instanceof TreeNode)//【9-6】p也不是红黑树，不走if
                e = ((TreeNode&amp;lt;K,V&amp;gt;)p).putTreeVal(this, tab, hash, key, value);
            else &amp;#123;
                //【9-7】走到这里，证明数组的这个位置是个链表了
                for (int binCount = 0; ; ++binCount) &amp;#123;//【9-8】无条件的死循环   binCount 链表上节点的个数
                    //随着循环  p.next就是一路找链上元素
                    //p.next要是没有元素，就要开始追加了呗
                    if ((e = p.next) == null) &amp;#123;//【9-10】一路next比较都没有key相同的数据
                    
                        p.next = newNode(hash, key, value, null);//【9-11】追加在链表尾部 ---》 前七后八
                        //【9-12】如果节点个数大于8，进行树化：要从链表转为红黑树
                        if (binCount &amp;gt;= TREEIFY_THRESHOLD - 1)  
                            treeifyBin(tab, hash);//【9-13】这里还涉及 剪枝 问题，树节点在6个以下，就又变成链表了
                        break;
                    &amp;#125;
                    //【9-9】比较过程中：如果比较链表某个key相同，就break结束了，不用继续走了
                    if (e.hash == hash &amp;amp;&amp;amp;
                        ((k = e.key) == key || (key != null &amp;amp;&amp;amp; key.equals(k))))
                        break;
                    p = e;
                &amp;#125;
            &amp;#125;
            if (e != null) &amp;#123;  
                V oldValue = e.value;
                if (!onlyIfAbsent || oldValue == null)
                    e.value = value;//【8-7】新value替换老value
                afterNodeAccess(e);
                return oldValue;//【8-8】返回老value
            &amp;#125;
        &amp;#125;
        ++modCount;

        if (++size &amp;gt; threshold)
            resize();
        afterNodeInsertion(evict);
        return null;
    &amp;#125;

    final Node&amp;lt;K,V&amp;gt;[] resize() &amp;#123;
        Node&amp;lt;K,V&amp;gt;[] oldTab = table;
        int oldCap = (oldTab == null) ? 0 : oldTab.length; 
        int oldThr = threshold;
        int newCap, newThr = 0;
        if (oldCap &amp;gt; 0) &amp;#123;
            if (oldCap &amp;gt;= MAXIMUM_CAPACITY) &amp;#123;
                threshold = Integer.MAX_VALUE;
                return oldTab;
            &amp;#125;
            else if ((newCap = oldCap &amp;lt;&amp;lt; 1) &amp;lt; MAXIMUM_CAPACITY &amp;amp;&amp;amp;
                     oldCap &amp;gt;= DEFAULT_INITIAL_CAPACITY)
                newThr = oldThr &amp;lt;&amp;lt; 1;
        &amp;#125;
        else if (oldThr &amp;gt; 0) 
            newCap = oldThr;
        else &amp;#123;    
            newCap = DEFAULT_INITIAL_CAPACITY;
            newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);
        &amp;#125;
        if (newThr == 0) &amp;#123;
            float ft = (float)newCap * loadFactor;
            newThr = (newCap &amp;lt; MAXIMUM_CAPACITY &amp;amp;&amp;amp; ft &amp;lt; (float)MAXIMUM_CAPACITY ?
                      (int)ft : Integer.MAX_VALUE);
        &amp;#125;
        threshold = newThr;
        @SuppressWarnings(&amp;#123;&amp;quot;rawtypes&amp;quot;,&amp;quot;unchecked&amp;quot;&amp;#125;)
            Node&amp;lt;K,V&amp;gt;[] newTab = (Node&amp;lt;K,V&amp;gt;[])new Node[newCap];
        table = newTab;
        if (oldTab != null) &amp;#123;
            for (int j = 0; j &amp;lt; oldCap; ++j) &amp;#123;
                Node&amp;lt;K,V&amp;gt; e;
                if ((e = oldTab[j]) != null) &amp;#123;
                    oldTab[j] = null;
                    if (e.next == null)
                        newTab[e.hash &amp;amp; (newCap - 1)] = e;
                    else if (e instanceof TreeNode)
                        ((TreeNode&amp;lt;K,V&amp;gt;)e).split(this, newTab, j, oldCap);
                    else &amp;#123; 
                        Node&amp;lt;K,V&amp;gt; loHead = null, loTail = null;
                        Node&amp;lt;K,V&amp;gt; hiHead = null, hiTail = null;
                        Node&amp;lt;K,V&amp;gt; next;
                        do &amp;#123;
                            next = e.next;
                            if ((e.hash &amp;amp; oldCap) == 0) &amp;#123;
                                if (loTail == null)
                                    loHead = e;
                                else
                                    loTail.next = e;
                                loTail = e;
                            &amp;#125;
                            else &amp;#123;
                                if (hiTail == null)
                                    hiHead = e;
                                else
                                    hiTail.next = e;
                                hiTail = e;
                            &amp;#125;
                        &amp;#125; while ((e = next) != null);
                        if (loTail != null) &amp;#123;
                            loTail.next = null;
                            newTab[j] = loHead;
                        &amp;#125;
                        if (hiTail != null) &amp;#123;
                            hiTail.next = null;
                            newTab[j + oldCap] = hiHead;
                        &amp;#125;
                    &amp;#125;
                &amp;#125;
            &amp;#125;
        &amp;#125;
        return newTab;
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;总结：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;默认&lt;strong&gt;数组长度为16&lt;/strong&gt;，&lt;strong&gt;最大程度${2^{30}}$&lt;/strong&gt;,&lt;strong&gt;负载因子为0.75&lt;/strong&gt;，扩容时&lt;strong&gt;扩大2倍&lt;/strong&gt;，&lt;/p&gt;
&lt;p&gt;1.8比1.7改变了底层数据结构而已&lt;/p&gt;
&lt;h4 id=&#34;4-1-6-HashSet底层原理&#34;&gt;&lt;a href=&#34;#4-1-6-HashSet底层原理&#34; class=&#34;headerlink&#34; title=&#34;4.1.6 HashSet底层原理&#34;&gt;&lt;/a&gt;4.1.6 HashSet底层原理&lt;/h4&gt;&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;public class HashSet&amp;lt;E&amp;gt;&amp;#123;
    //重要属性：
    private transient HashMap&amp;lt;E,Object&amp;gt; map;
    private static final Object PRESENT = new Object();
    //构造器：
    public HashSet() &amp;#123;
        map = new HashMap&amp;lt;&amp;gt;();//HashSet底层就是利用HashMap来完成的
    &amp;#125;
        
    public boolean add(E e) &amp;#123;
        return map.put(e, PRESENT)==null;
    &amp;#125;      
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;4-2TreeMap&#34;&gt;&lt;a href=&#34;#4-2TreeMap&#34; class=&#34;headerlink&#34; title=&#34;4.2TreeMap&#34;&gt;&lt;/a&gt;4.2TreeMap&lt;/h3&gt;&lt;p&gt;【1】原理大致介绍：&lt;/p&gt;
&lt;img data-src=&#34;/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618175955956.png&#34; class=&#34;&#34;&gt;


&lt;p&gt;【2】源码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;public class TreeMap&amp;lt;K,V&amp;gt;&amp;#123;
        //重要属性：
        //外部比较器：
        private final Comparator&amp;lt;? super K&amp;gt; comparator;
        //树的根节点：
        private transient Entry&amp;lt;K,V&amp;gt; root = null;
        //集合中元素的数量：
        private transient int size = 0;
        //空构造器:
        public TreeMap() &amp;#123;
        comparator = null;//如果使用空构造器，那么底层就不使用外部比较器
    &amp;#125;
        //有参构造器：
        public TreeMap(Comparator&amp;lt;? super K&amp;gt; comparator) &amp;#123;
        this.comparator = comparator;//如果使用有参构造器，那么就相当于指定了外部比较器
    &amp;#125;
        
        public V put(K key, V value) &amp;#123;//k,V的类型在创建对象的时候确定了
        //如果放入的是第一对元素，那么t的值为null
        Entry&amp;lt;K,V&amp;gt; t = root;//在放入第二个节点的时候，root已经是根节点了
                //如果放入的是第一个元素的话，走入这个if中：
        if (t == null) &amp;#123;
                        //自己跟自己比
            compare(key, key); // type (and possibly null) check
                        //根节点确定为root
            root = new Entry&amp;lt;&amp;gt;(key, value, null);
                        //size值变为1
            size = 1;
            modCount++;
            return null;
        &amp;#125;
                
        int cmp;
        Entry&amp;lt;K,V&amp;gt; parent;
        // split comparator and comparable paths
                //将外部比较器赋给cpr:
        Comparator&amp;lt;? super K&amp;gt; cpr = comparator;
                //cpr不等于null，意味着你刚才创建对象的时候调用了有参构造器，指定了外部比较器
        if (cpr != null) &amp;#123;
            do &amp;#123;
                parent = t;
                cmp = cpr.compare(key, t.key);//将元素的key值做比较
                                //cmp返回的值就是int类型的数据：
                                //要是这个值《0 =0  》0
                if (cmp &amp;lt; 0)
                    t = t.left;
                else if (cmp &amp;gt; 0)
                    t = t.right;
                else//cpm==0
                                //如果key的值一样，那么新的value替换老的value  但是key不变 因为key是唯一的
                    return t.setValue(value);
            &amp;#125; while (t != null);
        &amp;#125;
                //cpr等于null，意味着你刚才创建对象的时候调用了空构造器，没有指定外部比较器，使用内部比较器
        else &amp;#123;
            if (key == null)
                throw new NullPointerException();
            Comparable&amp;lt;? super K&amp;gt; k = (Comparable&amp;lt;? super K&amp;gt;) key;
            do &amp;#123;
                parent = t;
                cmp = k.compareTo(t.key);//将元素的key值做比较
                if (cmp &amp;lt; 0)
                    t = t.left;
                else if (cmp &amp;gt; 0)
                    t = t.right;
                else
                    return t.setValue(value);
            &amp;#125; while (t != null);
        &amp;#125;
        Entry&amp;lt;K,V&amp;gt; e = new Entry&amp;lt;&amp;gt;(key, value, parent);
        if (cmp &amp;lt; 0)
            parent.left = e;
        else
            parent.right = e;
        fixAfterInsertion(e);
        size++;//size加1 操作
        modCount++;
        return null;
    &amp;#125;
        
        
&amp;#125;
 static final class Entry&amp;lt;K,V&amp;gt; implements Map.Entry&amp;lt;K,V&amp;gt; &amp;#123;
        K key;
        V value;
        Entry&amp;lt;K,V&amp;gt; left = null;
        Entry&amp;lt;K,V&amp;gt; right = null;
        Entry&amp;lt;K,V&amp;gt; parent;
        boolean color = BLACK;
 &amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;TreeSet源码&#34;&gt;&lt;a href=&#34;#TreeSet源码&#34; class=&#34;headerlink&#34; title=&#34;TreeSet源码&#34;&gt;&lt;/a&gt;TreeSet源码&lt;/h4&gt;&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;public class TreeSet&amp;lt;E&amp;gt; extends AbstractSet&amp;lt;E&amp;gt;
    implements NavigableSet&amp;lt;E&amp;gt;, Cloneable, java.io.Serializable&amp;#123;
                //重要属性：
                private transient NavigableMap&amp;lt;E,Object&amp;gt; m;
                private static final Object PRESENT = new Object();
                
                //在调用空构造器的时候，底层创建了一个TreeMap
                public TreeSet() &amp;#123;
                        this(new TreeMap&amp;lt;E,Object&amp;gt;());
                &amp;#125;
                
                TreeSet(NavigableMap&amp;lt;E,Object&amp;gt; m) &amp;#123;
                        this.m = m;
                &amp;#125;
                
                public boolean add(E e) &amp;#123;
        return m.put(e, PRESENT)==null;
    &amp;#125;
                
                
        &amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;Collections工具类&#34;&gt;&lt;a href=&#34;#Collections工具类&#34; class=&#34;headerlink&#34; title=&#34;Collections工具类&#34;&gt;&lt;/a&gt;Collections工具类&lt;/h1&gt;&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;public class Test01 &amp;#123;
    //这是main方法，程序的入口
    public static void main(String[] args) &amp;#123;
        //Collections不支持创建对象，因为构造器私有化了
        /*Collections cols = new Collections();*/
        //里面的属性和方法都是被static修饰，我们可以直接用类名.去调用即可：
        //常用方法：
        //addAll：
        ArrayList&amp;lt;String&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
        list.add(&amp;quot;cc&amp;quot;);
        list.add(&amp;quot;bb&amp;quot;);
        list.add(&amp;quot;aa&amp;quot;);
        Collections.addAll(list,&amp;quot;ee&amp;quot;,&amp;quot;dd&amp;quot;,&amp;quot;ff&amp;quot;);
        Collections.addAll(list,new String[]&amp;#123;&amp;quot;gg&amp;quot;,&amp;quot;oo&amp;quot;,&amp;quot;pp&amp;quot;&amp;#125;);
        System.out.println(list);
        //binarySearch必须在有序的集合中查找：--》排序：
        Collections.sort(list);//sort提供的是升序排列
        System.out.println(list);
        //binarySearch
        System.out.println(Collections.binarySearch(list, &amp;quot;cc&amp;quot;));
        //copy:替换方法
        ArrayList&amp;lt;String&amp;gt; list2 = new ArrayList&amp;lt;&amp;gt;();
        Collections.addAll(list2,&amp;quot;tt&amp;quot;,&amp;quot;ss&amp;quot;);
        Collections.copy(list,list2);//将list2的内容替换到list上去
        System.out.println(list);
        System.out.println(list2);
        //fill 填充
        Collections.fill(list2,&amp;quot;yyy&amp;quot;);
        System.out.println(list2);
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;数据结构&#34;&gt;&lt;a href=&#34;#数据结构&#34; class=&#34;headerlink&#34; title=&#34;数据结构&#34;&gt;&lt;/a&gt;数据结构&lt;/h1&gt;&lt;h2 id=&#34;栈&#34;&gt;&lt;a href=&#34;#栈&#34; class=&#34;headerlink&#34; title=&#34;栈&#34;&gt;&lt;/a&gt;栈&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;public class Test &amp;#123;
    //这是main方法，程序的入口
    public static void main(String[] args) &amp;#123;
        /*
        Stack是Vector的子类，Vector里面两个重要的属性：
        Object[] elementData;底层依然是一个数组
        int elementCount;数组中的容量
         */
        Stack s = new Stack();
        s.add(&amp;quot;A&amp;quot;);
        s.add(&amp;quot;B&amp;quot;);
        s.add(&amp;quot;C&amp;quot;);
        s.add(&amp;quot;D&amp;quot;);
        System.out.println(s);//[A, B, C, D]
        System.out.println(&amp;quot;栈是否为空：&amp;quot; + s.empty());
        System.out.println(&amp;quot;查看栈顶的数据，但是不移除：&amp;quot; + s.peek());
        System.out.println(s);
        System.out.println(&amp;quot;查看栈顶的数据，并且不移除：&amp;quot; + s.pop());
        System.out.println(s);
        s.push(&amp;quot;D&amp;quot;);//和add方法执行的功能一样，就是返回值不同
        System.out.println(s);
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;同步类容器&#34;&gt;&lt;a href=&#34;#同步类容器&#34; class=&#34;headerlink&#34; title=&#34;同步类容器&#34;&gt;&lt;/a&gt;同步类容器&lt;/h2&gt;&lt;p&gt;比如ArrayList，HashMap，线程不安全，现在想把线程不安全的集合转换为线程安全的集合：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;public class Test01 &amp;#123;
    //这是main方法，程序的入口
    public static void main(String[] args) &amp;#123;
        //ArrayList为案例：从线程不安全  转为线程安全：
        List list = Collections.synchronizedList(new ArrayList());
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;试试ArrayList的线程不安全：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;public class Demo &amp;#123;
    //这是main方法，程序的入口
    public static void main(String[] args) &amp;#123;
        //创建一个ArrayList集合：
        ArrayList list = new ArrayList();
        //创建一个线程池：线程池定长100
        ExecutorService es = Executors.newFixedThreadPool(100);
        //并发向集合中添加10000个数据：
        for (int i = 0; i &amp;lt; 10000; i++) &amp;#123;
            //每个线程处理任务：run方法中的内容就是线程单元，任务，实际线程执行的部分
            es.execute(new Runnable() &amp;#123;
                @Override
                public void run() &amp;#123;
                    list.add(&amp;quot;aaa&amp;quot;);
                &amp;#125;
            &amp;#125;);
        &amp;#125;
        //关闭线程池：
        es.shutdown();
        //监控线程是否执行完毕：
        while(true)&amp;#123;
            //线程都执行完以后返回true
            if(es.isTerminated())&amp;#123;
                System.out.println(&amp;quot;所有的子线程都执行完毕了！&amp;quot;);
                //执行完毕以后看一下集合中元素的数量：
                System.out.println(list.size());
                if(list.size() == 10000)&amp;#123;
                    System.out.println(&amp;quot;线程安全！&amp;quot;);
                &amp;#125;else&amp;#123;
                    System.out.println(&amp;quot;线程不安全！&amp;quot;);
                &amp;#125;
                //线程执行完以后，while循环可以停止：
                break;
            &amp;#125;
        &amp;#125;
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;结果：&lt;/p&gt;
&lt;img data-src=&#34;/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618180549466.png&#34; class=&#34;&#34;&gt;


&lt;p&gt;利用同步类容器解决：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;public class Demo &amp;#123;
    //这是main方法，程序的入口
    public static void main(String[] args) &amp;#123;
        //创建一个ArrayList集合：
        ArrayList oldlist = new ArrayList();
        List list = Collections.synchronizedList(oldlist);
        //创建一个线程池：线程池定长100
        ExecutorService es = Executors.newFixedThreadPool(100);
        //并发向集合中添加10000个数据：
        for (int i = 0; i &amp;lt; 10000; i++) &amp;#123;
            //每个线程处理任务：run方法中的内容就是线程单元，任务，实际线程执行的部分
            es.execute(new Runnable() &amp;#123;
                @Override
                public void run() &amp;#123;
                    list.add(&amp;quot;aaa&amp;quot;);
                &amp;#125;
            &amp;#125;);
        &amp;#125;
        //关闭线程池：
        es.shutdown();
        //监控线程是否执行完毕：
        while(true)&amp;#123;
            //线程都执行完以后返回true
            if(es.isTerminated())&amp;#123;
                System.out.println(&amp;quot;所有的子线程都执行完毕了！&amp;quot;);
                //执行完毕以后看一下集合中元素的数量：
                System.out.println(list.size());
                if(list.size() == 10000)&amp;#123;
                    System.out.println(&amp;quot;线程安全！&amp;quot;);
                &amp;#125;else&amp;#123;
                    System.out.println(&amp;quot;线程不安全！&amp;quot;);
                &amp;#125;
                //线程执行完以后，while循环可以停止：
                break;
            &amp;#125;
        &amp;#125;
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;结果：&lt;/p&gt;
&lt;img data-src=&#34;/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618180623443.png&#34; class=&#34;&#34;&gt;


&lt;p&gt;源码解析：&lt;/p&gt;
&lt;img data-src=&#34;/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618180635090.png&#34; class=&#34;&#34;&gt;




&lt;h2 id=&#34;ConcurrentMap并发容器&#34;&gt;&lt;a href=&#34;#ConcurrentMap并发容器&#34; class=&#34;headerlink&#34; title=&#34;ConcurrentMap并发容器&#34;&gt;&lt;/a&gt;ConcurrentMap并发容器&lt;/h2&gt;&lt;p&gt;JDK5.0之后提供了多种并发类容器可以替代同步类容器，提升性能、吞吐量&lt;br&gt;ConcurrentHashMap替代HashMap、HashTable&lt;br&gt;ConcurrentSkipListMap替代TreeMap&lt;/p&gt;
&lt;p&gt;简单原理：&lt;/p&gt;
&lt;img data-src=&#34;/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618180711631.png&#34; class=&#34;&#34;&gt;


&lt;p&gt;并发情况下，验证提高性能：&lt;/p&gt;
&lt;p&gt;ConcunrrentHashMap :&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;public class Test &amp;#123;
    //这是main方法，程序的入口
    public static void main(String[] args) &amp;#123;
        //选择一个容器：
        ConcurrentHashMap&amp;lt;String,Integer&amp;gt; map = new ConcurrentHashMap&amp;lt;&amp;gt;();
        
        //创建10个线程：
        for (int i = 0; i &amp;lt; 10; i++) &amp;#123;
            new Thread(new Runnable() &amp;#123;
                @Override
                public void run() &amp;#123;
                    long startTime = System.currentTimeMillis();
                    for (int j = 0; j &amp;lt; 1000000; j++) &amp;#123;
                        map.put(&amp;quot;test&amp;quot; + j , j);
                    &amp;#125;
                    long endTime = System.currentTimeMillis();
                    System.out.println(&amp;quot;一共需要的时间：&amp;quot; + (endTime - startTime));
                &amp;#125;
            &amp;#125;).start();
        &amp;#125;
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;结果：&lt;/p&gt;
&lt;img data-src=&#34;/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618180735265.png&#34; class=&#34;&#34;&gt;


&lt;p&gt;Hashtable：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;public class Test &amp;#123;
    //这是main方法，程序的入口
    public static void main(String[] args) &amp;#123;
        //选择一个容器：
        //ConcurrentHashMap&amp;lt;String,Integer&amp;gt; map = new ConcurrentHashMap&amp;lt;&amp;gt;();
        Hashtable map = new Hashtable();
        //创建10个线程：
        for (int i = 0; i &amp;lt; 10; i++) &amp;#123;
            new Thread(new Runnable() &amp;#123;
                @Override
                public void run() &amp;#123;
                    long startTime = System.currentTimeMillis();
                    for (int j = 0; j &amp;lt; 1000000; j++) &amp;#123;
                        map.put(&amp;quot;test&amp;quot; + j , j);
                    &amp;#125;
                    long endTime = System.currentTimeMillis();
                    System.out.println(&amp;quot;一共需要的时间：&amp;quot; + (endTime - startTime));
                &amp;#125;
            &amp;#125;).start();
        &amp;#125;
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;img data-src=&#34;/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618180757516.png&#34; class=&#34;&#34;&gt;


&lt;p&gt;HashMap：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;public class Test &amp;#123;
    //这是main方法，程序的入口
    public static void main(String[] args) &amp;#123;
        //选择一个容器：
        //ConcurrentHashMap&amp;lt;String,Integer&amp;gt; map = new ConcurrentHashMap&amp;lt;&amp;gt;();
        //Hashtable map = new Hashtable();
        HashMap map = new HashMap();
        //创建10个线程：
        for (int i = 0; i &amp;lt; 10; i++) &amp;#123;
            new Thread(new Runnable() &amp;#123;
                @Override
                public void run() &amp;#123;
                    long startTime = System.currentTimeMillis();
                    for (int j = 0; j &amp;lt; 1000000; j++) &amp;#123;
                        map.put(&amp;quot;test&amp;quot; + j , j);
                    &amp;#125;
                    long endTime = System.currentTimeMillis();
                    System.out.println(&amp;quot;一共需要的时间：&amp;quot; + (endTime - startTime));
                &amp;#125;
            &amp;#125;).start();
        &amp;#125;
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;img data-src=&#34;/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618180824896.png&#34; class=&#34;&#34;&gt;


&lt;p&gt;线程安全的HashMap：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;public class Test &amp;#123;
    //这是main方法，程序的入口
    public static void main(String[] args) &amp;#123;
        //选择一个容器：
        //ConcurrentHashMap&amp;lt;String,Integer&amp;gt; map = new ConcurrentHashMap&amp;lt;&amp;gt;();
        //Hashtable map = new Hashtable();
        HashMap oldmap = new HashMap();
        Map map = Collections.synchronizedMap(oldmap);
        //创建10个线程：
        for (int i = 0; i &amp;lt; 10; i++) &amp;#123;
            new Thread(new Runnable() &amp;#123;
                @Override
                public void run() &amp;#123;
                    long startTime = System.currentTimeMillis();
                    for (int j = 0; j &amp;lt; 1000000; j++) &amp;#123;
                        map.put(&amp;quot;test&amp;quot; + j , j);
                    &amp;#125;
                    long endTime = System.currentTimeMillis();
                    System.out.println(&amp;quot;一共需要的时间：&amp;quot; + (endTime - startTime));
                &amp;#125;
            &amp;#125;).start();
        &amp;#125;
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;img data-src=&#34;/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618180846459.png&#34; class=&#34;&#34;&gt;


&lt;p&gt;总结：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;ConcurrentHashMap&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;性能高，线程安全&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;Hashtable: 线程安全&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;性能低&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;HashMap:线程不安全&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;性能高&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;线程安全的HashMap：线程安全，性能低&lt;/p&gt;
&lt;h2 id=&#34;COW并发容器&#34;&gt;&lt;a href=&#34;#COW并发容器&#34; class=&#34;headerlink&#34; title=&#34;COW并发容器&#34;&gt;&lt;/a&gt;COW并发容器&lt;/h2&gt;&lt;p&gt;【1】COW类并发容器，全称：Copy  On  Write容器，写时复制容器。（读写分离容器）&lt;/p&gt;
&lt;p&gt;【2】原理：&lt;br&gt;向容器中添加元素时，先将容器进行Copy复制出一个新容器，然后将元素添加到新容器中，再将原容器的引用指向新容器。&lt;br&gt;并发读的时候不需要锁定容器，因为原容器没有变化，所以可以读取原容器中的值，使用的是一种读写分离的思想。&lt;/p&gt;
&lt;img data-src=&#34;/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618181056593.png&#34; class=&#34;&#34;&gt;




&lt;p&gt;【3】这种设计的好处是什么呢？&lt;br&gt;注意上面的操作arr数组本身是无锁的，没有锁，在添加数据的时候，做了额外的复制，&lt;br&gt;此时如果有线程来读数据，那么读取的是老arr的数据，此时arr的地址还没有改呢，在我添加元素的过程中，&lt;br&gt;无论有多少个线程来读数据，都是读的原来的arr，不是新的arr&lt;br&gt;所以性能很高，读写分离。提高了并发的性能。如果再读再复制…&lt;/p&gt;
&lt;p&gt;【4】注意：&lt;br&gt;CopyOnWrite容器只能保证数据的最终一致性，不能保证数据实时一致性。&lt;br&gt;所以如果你希望写入的的数据，马上能读到，请不要使用CopyOnWrite容器。&lt;/p&gt;
&lt;p&gt;【5】适合特定场合：&lt;br&gt;这个应用场景显而易见，适合读多写少的情况。如果一万个线程都添加操作，都在集合中添加数据，那数组不断复制，长度不断+1，&lt;br&gt;那JVM肯定一直往上飙升，你用的时候肯定要评估使用场景的。&lt;br&gt;由于每次更新都会复制新容器，所以如果数据量较大并且更新操作频繁则对内存消耗很高，建议在高并发读的场景下使用。&lt;/p&gt;
&lt;p&gt;【6】主要讲解：&lt;br&gt;COW容器有两种一种是CopyonWriteArrayList，一种是CopyOnWriteArraySet&lt;br&gt;一个是替代ArrayList，一个是代替Set&lt;/p&gt;
&lt;h3 id=&#34;CopyOnWriteArrayList&#34;&gt;&lt;a href=&#34;#CopyOnWriteArrayList&#34; class=&#34;headerlink&#34; title=&#34;CopyOnWriteArrayList&#34;&gt;&lt;/a&gt;CopyOnWriteArrayList&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;public class Test &amp;#123;
    //这是main方法，程序的入口
    public static void main(String[] args) &amp;#123;
        CopyOnWriteArrayList&amp;lt;Integer&amp;gt; list = new CopyOnWriteArrayList&amp;lt;&amp;gt;();
        //添加方法：
        list.add(1);
        list.add(2);
        list.add(3);
        list.add(4);
        System.out.println(list);//[1, 2, 3, 4]
        list.add(3);//add方法无论元素是否存在，都可以添加进去--》添加重复的元素
        System.out.println(list);//[1, 2, 3, 4, 3]
        //adj. 缺席的；缺少的；心不在焉的；茫然的
        list.addIfAbsent(33);//添加不存在的元素--》不可以添加重复的数据
        System.out.println(list);//[1, 2, 3, 4, 3, 33]
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;源码分析：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;public class CopyOnWriteArrayList&amp;lt;E&amp;gt;&amp;#123;
        //底层基于数组实现的
        private transient volatile Object[] array;
        
        public CopyOnWriteArrayList() &amp;#123;
        setArray(new Object[0]);
    &amp;#125;
        
        final void setArray(Object[] a) &amp;#123;
        array = a; // array = new Object[0]
    &amp;#125;
        //add方法：
        public boolean add(E e) &amp;#123;
        final ReentrantLock lock = this.lock;
        lock.lock();
        try &amp;#123;
                        //返回底层array数组,给了elements
            Object[] elements = getArray();
                        //获取elements的长度---》获取老数组的长度
            int len = elements.length;
                        //完成数组的复制，将老数组中的元素复制到新数组中，并且新数组的长度加1操作
            Object[] newElements = Arrays.copyOf(elements, len + 1);
                        //将e元素放入新数组最后位置
            newElements[len] = e;
                        //array数组的指向从老数组变为新数组
            setArray(newElements);
            return true;
        &amp;#125; finally &amp;#123;
            lock.unlock();
        &amp;#125;
    &amp;#125;
        
        
        final Object[] getArray() &amp;#123;
        return array;//返回底层数组
    &amp;#125;
        
        
        private boolean addIfAbsent(E e, Object[] snapshot) &amp;#123;
        final ReentrantLock lock = this.lock;
        lock.lock();
        try &amp;#123;
                        //取出array数组给current
            Object[] current = getArray();
            int len = current.length;
            if (snapshot != current) &amp;#123;
                // Optimize for lost race to another addXXX operation
                int common = Math.min(snapshot.length, len);
                                //遍历老数组：
                for (int i = 0; i &amp;lt; common; i++)
                                        //eq(e, current[i])将放入的元素和老数组的每一个元素进行比较，如果有重复的元素，就返回false，不添加了
                    if (current[i] != snapshot[i] &amp;amp;&amp;amp; eq(e, current[i]))
                        return false;
                if (indexOf(e, current, common, len) &amp;gt;= 0)
                        return false;
            &amp;#125;
                        //完成数组的复制，将老数组中的元素复制到新数组中，并且新数组的长度加1操作
            Object[] newElements = Arrays.copyOf(current, len + 1);
                        //将e元素放入新数组最后位置
            newElements[len] = e;
                        //array数组的指向从老数组变为新数组
            setArray(newElements);
            return true;
        &amp;#125; finally &amp;#123;
            lock.unlock();
        &amp;#125;
    &amp;#125;             
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;CopyOnWriteArraySet&#34;&gt;&lt;a href=&#34;#CopyOnWriteArraySet&#34; class=&#34;headerlink&#34; title=&#34;CopyOnWriteArraySet&#34;&gt;&lt;/a&gt;CopyOnWriteArraySet&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;public class Test02 &amp;#123;
    //这是main方法，程序的入口
    public static void main(String[] args) &amp;#123;
        //创建一个集合：
        CopyOnWriteArraySet&amp;lt;Integer&amp;gt; set = new CopyOnWriteArraySet&amp;lt;&amp;gt;();
        //在这里也体现出Set和List的本质区别，就在于是否重复
        //所以add方法直接不可以添加重复数据进去
        set.add(1);
        set.add(2);
        set.add(2);
        set.add(7);
        System.out.println(set);//[1, 2, 7]
        
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;源码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;public class CopyOnWriteArraySet&amp;lt;E&amp;gt;&amp;#123;
        //CopyOnWriteArraySet底层基于CopyOnWriteArrayList
        private final CopyOnWriteArrayList&amp;lt;E&amp;gt; al;
        
        public CopyOnWriteArraySet() &amp;#123;
        al = new CopyOnWriteArrayList&amp;lt;E&amp;gt;();
    &amp;#125;
        
        //添加方法：
        public boolean add(E e) &amp;#123;
        return al.addIfAbsent(e);//底层调用的还是CopyOnWriteArrayList的addIfAbsent
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;总结：&lt;/p&gt;
&lt;p&gt;由上面的源码看出，每次调用CopyOnWriteArraySet的add方法时候，其实底层是基于CopyOnWriteArrayList的addIfAbsent，&lt;br&gt;每次在addIfAbsent方法中每次都要对数组进行遍历，所以CopyOnWriteArraySet的性能低于CopyOnWriteArrayList&lt;/p&gt;
&lt;h2 id=&#34;队列&#34;&gt;&lt;a href=&#34;#队列&#34; class=&#34;headerlink&#34; title=&#34;队列&#34;&gt;&lt;/a&gt;队列&lt;/h2&gt;&lt;p&gt;数据结构分为：&lt;br&gt;（1）逻辑结构 ：–》思想上的结构–》卧室，厨房，卫生间 —》线性表（数组，链表），图，树，栈，队列&lt;br&gt;（2）物理结构 ：–》真实结构–》钢筋混凝土+牛顿力学——》紧密结构（顺序结构），跳转结构（链式结构）&lt;/p&gt;
&lt;p&gt;队列：特点：先进先出 （FIFO）（first in first out）&lt;/p&gt;
&lt;img data-src=&#34;/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618181454201.png&#34; class=&#34;&#34;&gt;


&lt;img data-src=&#34;/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618181504415.png&#34; class=&#34;&#34;&gt;




&lt;p&gt;他有两端，一端是让新元素进去，一端是让老元素出去&lt;/p&gt;
&lt;p&gt;在需要公平且经济地对各种自然或社会资源做管理或分配的场合，无论是调度银行和医院的服务窗口，还是管理轮耕的田地和轮伐的森林，队列都可大显身手。&lt;/p&gt;
&lt;p&gt;甚至计算机及其网络自身内部的各种计算资源，无论是多进程共享的 CPU 时间，还是多用户共享的打印机，也都需要借助队列结构实现合理和优化的分配。&lt;/p&gt;
&lt;p&gt;双端队列：两端都可以进行进队，出队的队列：&lt;/p&gt;
&lt;p&gt;（1）前端，后端都可以进出：&lt;/p&gt;
&lt;img data-src=&#34;/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618181511902.png&#34; class=&#34;&#34;&gt;




&lt;p&gt;（2）进行限制：&lt;/p&gt;
&lt;img data-src=&#34;/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618181516928.png&#34; class=&#34;&#34;&gt;




&lt;p&gt;（3）特殊情况，双端队列实现栈操作:&lt;/p&gt;
&lt;img data-src=&#34;/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618181522040.png&#34; class=&#34;&#34;&gt;




&lt;p&gt;栈和队列的物理结构实现 可以用线性表的数组，链表都可以&lt;/p&gt;
&lt;h2 id=&#34;队列Queue&#34;&gt;&lt;a href=&#34;#队列Queue&#34; class=&#34;headerlink&#34; title=&#34;队列Queue&#34;&gt;&lt;/a&gt;队列Queue&lt;/h2&gt;&lt;h3 id=&#34;阻塞队列&#34;&gt;&lt;a href=&#34;#阻塞队列&#34; class=&#34;headerlink&#34; title=&#34;阻塞队列&#34;&gt;&lt;/a&gt;阻塞队列&lt;/h3&gt;&lt;h4 id=&#34;BlockingQueue介绍&#34;&gt;&lt;a href=&#34;#BlockingQueue介绍&#34; class=&#34;headerlink&#34; title=&#34;BlockingQueue介绍&#34;&gt;&lt;/a&gt;BlockingQueue介绍&lt;/h4&gt;&lt;img data-src=&#34;/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618181740905.png&#34; class=&#34;&#34;&gt;


&lt;p&gt;总结：BlockingQueue继承Queue，Queue继承自Collection&lt;br&gt;所以Collection最基础的增删改查操作是有的，在这个基础上，多了Queue的特点，在这个基础上又多了阻塞的特点，最终形成了BlockingQueue&lt;/p&gt;
&lt;p&gt;什么叫阻塞？&lt;/p&gt;
&lt;img data-src=&#34;/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618181750078.png&#34; class=&#34;&#34;&gt;


&lt;img data-src=&#34;/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618181756012.png&#34; class=&#34;&#34;&gt;


&lt;p&gt;常用的API：&lt;br&gt;添加：&lt;/p&gt;
&lt;img data-src=&#34;/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618181825630.png&#34; class=&#34;&#34;&gt;


&lt;img data-src=&#34;/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618181805698.png&#34; class=&#34;&#34;&gt;


&lt;img data-src=&#34;/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618181833424.png&#34; class=&#34;&#34;&gt;


&lt;p&gt;put是阻塞的&lt;/p&gt;
&lt;p&gt;查询：&lt;/p&gt;
&lt;img data-src=&#34;/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618181839103.png&#34; class=&#34;&#34;&gt;


&lt;img data-src=&#34;/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618181845214.png&#34; class=&#34;&#34;&gt;




&lt;p&gt;take是阻塞的&lt;/p&gt;
&lt;p&gt;删除：&lt;/p&gt;
&lt;img data-src=&#34;/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618181852391.png&#34; class=&#34;&#34;&gt;




&lt;h4 id=&#34;常见子类&#34;&gt;&lt;a href=&#34;#常见子类&#34; class=&#34;headerlink&#34; title=&#34;常见子类&#34;&gt;&lt;/a&gt;常见子类&lt;/h4&gt;&lt;p&gt;&lt;a href=&#34;#queue_impl1&#34;&gt;ArrayBlockingQueue&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;#queue_impl2&#34;&gt;LinkedBlockingQueue&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;#queue_impl3&#34;&gt;SynchronousQueue&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;#queue_impl4&#34;&gt;PriorityBlockingQueue&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;#queue_impl5&#34;&gt;DelayQueue&lt;/a&gt;&lt;/p&gt;
&lt;div name=queue_impl1&gt;



&lt;blockquote&gt;
&lt;p&gt;ArrayBlockingQueue&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;源码中的注释的解释说明：&lt;/p&gt;
&lt;img data-src=&#34;/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618181949074.png&#34; class=&#34;&#34;&gt;




&lt;p&gt;【1】添加元素：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;public class Test01 &amp;#123;
    //这是main方法，程序的入口
    public static void main(String[] args) throws InterruptedException &amp;#123;
        //创建一个队列，队列可以指定容量指定长度3：
        ArrayBlockingQueue aq = new ArrayBlockingQueue(3);
        //添加元素：
        //【1】添加null元素：不可以添加null元素，会报空指针异常：NullPointerException
        //aq.add(null);
        //aq.offer(null);
        //aq.put(null);
        //【2】正常添加元素：
        aq.add(&amp;quot;aaa&amp;quot;);
        aq.offer(&amp;quot;bbb&amp;quot;);
        aq.put(&amp;quot;ccc&amp;quot;);
        System.out.println(aq);//[aaa, bbb, ccc]
        //【3】在队列满的情况下，再添加元素：
        //aq.add(&amp;quot;ddd&amp;quot;);//在队列满的情况下，添加元素 出现异常：Queue full
        //System.out.println(aq.offer(&amp;quot;ddd&amp;quot;));//没有添加成功，返回false
        //设置最大阻塞时间，如果时间到了，队列还是满的，就不再阻塞了
        //aq.offer(&amp;quot;ddd&amp;quot;,2, TimeUnit.SECONDS);
        //真正阻塞的方法： put ,如果队列满，就永远阻塞 
        aq.put(&amp;quot;ddd&amp;quot;);
        System.out.println(aq);
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;【2】获取元素：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;public class Test02 &amp;#123;
    //这是main方法，程序的入口
    public static void main(String[] args) throws InterruptedException &amp;#123;
        //创建一个队列，队列可以指定容量指定长度3：
        ArrayBlockingQueue aq = new ArrayBlockingQueue(3);
        aq.add(&amp;quot;aaa&amp;quot;);
        aq.add(&amp;quot;bbb&amp;quot;);
        aq.add(&amp;quot;ccc&amp;quot;);
        //得到头元素但是不移除
        System.out.println(aq.peek());
        System.out.println(aq);
        //得到头元素并且移除
        System.out.println(aq.poll());
        System.out.println(aq);
        //得到头元素并且移除
        System.out.println(aq.take());
        System.out.println(aq);
        //清空元素：
        aq.clear();
        System.out.println(aq);
        System.out.println(aq.peek());//null
        System.out.println(aq.poll());//null
        //设置阻塞事件，如果队列为空，返回null，时间到了以后就不阻塞了
        //System.out.println(aq.poll(2, TimeUnit.SECONDS));
        //真正阻塞：队列为空，永远阻塞
        System.out.println(aq.take());
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;【3】源码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;public class ArrayBlockingQueue&amp;lt;E&amp;gt; &amp;#123;
        //底层就是一个数组：
        final Object[] items;
        //取元素用到的索引，初始结果为0
        int takeIndex;
        //放元素用到的索引，初始结果为0
        int putIndex;
        //数组中元素的个数：
        int count;
        
        //一把锁：这个锁肯定很多方法中用到了，所以定义为属性，初始化以后可以随时使用
    final ReentrantLock lock;
    //锁伴随的一个等待吃：notEmpty
    private final Condition notEmpty;
    //锁伴随的一个等待吃：notFull
    private final Condition notFull;
        
        //构造器：
        public ArrayBlockingQueue(int capacity) &amp;#123;//传入队列指定的容量
        this(capacity, false);
    &amp;#125;
        
        public ArrayBlockingQueue(int capacity, boolean fair) &amp;#123;//传入队列指定的容量
                //健壮性考虑
        if (capacity &amp;lt;= 0)
            throw new IllegalArgumentException();
                //初始化底层数组
        this.items = new Object[capacity];
                //初始化锁 和  等待队列
        lock = new ReentrantLock(fair);
        notEmpty = lock.newCondition();
        notFull =  lock.newCondition();
    &amp;#125;
        
        //两个基本方法：一个是入队，一个是出队  ，是其他方法的基础：
        //入队：
        private void enqueue(E x) &amp;#123;
        // assert lock.getHoldCount() == 1;
        // assert items[putIndex] == null;
        final Object[] items = this.items;//底层数组赋给items
                //在对应的下标位置放入元素
        items[putIndex] = x;
        if (++putIndex == items.length) //++putIndex putIndex 索引 加1 
            putIndex = 0;
                //每放入一个元素，count加1操作
        count++;
        notEmpty.signal();
    &amp;#125;
        
        
        //出队：
        private E dequeue() &amp;#123;
        // assert lock.getHoldCount() == 1;
        // assert items[takeIndex] != null;
        final Object[] items = this.items;//底层数组赋给items
        @SuppressWarnings(&amp;quot;unchecked&amp;quot;)
        E x = (E) items[takeIndex];//在对应的位置取出元素
        items[takeIndex] = null;//对应位置元素取出后就置为null
        if (++takeIndex == items.length)//++takeIndex 加1操作
            takeIndex = 0;
        count--;//每取出一个元素，count减1操作
        if (itrs != null)
            itrs.elementDequeued();
        notFull.signal();
        return x;//将取出的元素作为方法的返回值
    &amp;#125;       
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;takeIndex和putIndex置为0的原因：&lt;/p&gt;
&lt;img data-src=&#34;/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618182045354.png&#34; class=&#34;&#34;&gt;


&lt;p&gt;【4】其他的添加或者获取的方法都是依托与这个入队和出队的基础方法&lt;/p&gt;
&lt;img data-src=&#34;/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618182053419.png&#34; class=&#34;&#34;&gt;


&lt;p&gt;【5】感受一下put和take的阻塞：&lt;/p&gt;
&lt;img data-src=&#34;/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618182101129.png&#34; class=&#34;&#34;&gt;


&lt;p&gt;上面的while不可以换为if，因为如果notFull中的线程被激活的瞬间，有其他线程放入元素，那么队列就又满了&lt;br&gt;那么沿着await后面继续执行就不可以，所以一定要反复确定队列是否满的，才能放入元素&lt;/p&gt;
&lt;div name=queue_impl2&gt;



&lt;blockquote&gt;
&lt;p&gt;LinkedBlockingQueue&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;一个可选择的有边界的队列：意思就是队列的长度可以指定，也可以不指定&lt;/p&gt;
&lt;img data-src=&#34;/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618182251224.png&#34; class=&#34;&#34;&gt;


&lt;p&gt;【1】添加元素：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;public class Test01 &amp;#123;
    //这是main方法，程序的入口
    public static void main(String[] args) throws InterruptedException &amp;#123;
        //创建一个队列，队列可以指定容量指定长度3：
        LinkedBlockingQueue aq = new LinkedBlockingQueue(3);
        //添加元素：
        //【1】添加null元素：不可以添加null元素，会报空指针异常：NullPointerException
        //aq.add(null);
        //aq.offer(null);
        aq.put(null);
        //【2】正常添加元素：
        aq.add(&amp;quot;aaa&amp;quot;);
        aq.offer(&amp;quot;bbb&amp;quot;);
        aq.put(&amp;quot;ccc&amp;quot;);
        System.out.println(aq);//[aaa, bbb, ccc]
        //【3】在队列满的情况下，再添加元素：
        //aq.add(&amp;quot;ddd&amp;quot;);//在队列满的情况下，添加元素 出现异常：Queue full
        //System.out.println(aq.offer(&amp;quot;ddd&amp;quot;));//没有添加成功，返回false
        //设置最大阻塞时间，如果时间到了，队列还是满的，就不再阻塞了
        //aq.offer(&amp;quot;ddd&amp;quot;,2, TimeUnit.SECONDS);
        //真正阻塞的方法： put ,如果队列满，就永远阻塞
        aq.put(&amp;quot;ddd&amp;quot;);
        System.out.println(aq);
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;【2】取出元素：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;public class Test02 &amp;#123;
    //这是main方法，程序的入口
    public static void main(String[] args) throws InterruptedException &amp;#123;
        //创建一个队列，队列可以指定容量指定长度3：
        LinkedBlockingQueue aq = new LinkedBlockingQueue();
        aq.add(&amp;quot;aaa&amp;quot;);
        aq.add(&amp;quot;bbb&amp;quot;);
        aq.add(&amp;quot;ccc&amp;quot;);
        //得到头元素但是不移除
        System.out.println(aq.peek());
        System.out.println(aq);
        //得到头元素并且移除
        System.out.println(aq.poll());
        System.out.println(aq);
        //得到头元素并且移除
        System.out.println(aq.take());
        System.out.println(aq);
        //清空元素：
        aq.clear();
        System.out.println(aq);
        System.out.println(aq.peek());//null
        System.out.println(aq.poll());//null
        //设置阻塞事件，如果队列为空，返回null，时间到了以后就不阻塞了
        //System.out.println(aq.poll(2, TimeUnit.SECONDS));
        //真正阻塞：队列为空，永远阻塞
        System.out.println(aq.take());
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;【3】特点：&lt;br&gt;ArrayBlockingQueue ： 不支持读写同时操作，底层基于数组的。&lt;br&gt;LinkedBlockingQueue：支持读写同时操作，并发情况下，效率高。底层基于链表。&lt;/p&gt;
&lt;p&gt;【4】源码：&lt;br&gt;入队操作：&lt;/p&gt;
&lt;img data-src=&#34;/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618182330212.png&#34; class=&#34;&#34;&gt;


&lt;p&gt;出队操作：&lt;/p&gt;
&lt;img data-src=&#34;/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618182341368.png&#34; class=&#34;&#34;&gt;


&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;public class LinkedBlockingQueue&amp;lt;E&amp;gt;&amp;#123;
        //内部类Node就是链表的节点的对象对应的类：
        static class Node&amp;lt;E&amp;gt; &amp;#123;
        E item;//封装你要装的那个元素
        
        Node&amp;lt;E&amp;gt; next;//下一个Node节点的地址
        Node(E x) &amp;#123; item = x; &amp;#125;//构造器
    &amp;#125;
        //链表的长度
        private final int capacity;
        //计数器：
        private final AtomicInteger count = new AtomicInteger();
        //链表的头结点
        transient Node&amp;lt;E&amp;gt; head;
        //链表的尾结点
        private transient Node&amp;lt;E&amp;gt; last;
        //取元素用的锁
        private final ReentrantLock takeLock = new ReentrantLock();
        //等待池
    private final Condition notEmpty = takeLock.newCondition();
    //放元素用的锁
    private final ReentrantLock putLock = new ReentrantLock();
    //等待池
    private final Condition notFull = putLock.newCondition();
        
        public LinkedBlockingQueue() &amp;#123;
        this(Integer.MAX_VALUE);//调用类本类的空构造器，传入正21亿
    &amp;#125;
        
        public LinkedBlockingQueue(int capacity) &amp;#123;
                //健壮性考虑
        if (capacity &amp;lt;= 0) throw new IllegalArgumentException();
                //给队列指定长度  
        this.capacity = capacity;
                //last，head指向一个新的节点，新的节点中 元素为null 
        last = head = new Node&amp;lt;E&amp;gt;(null);
    &amp;#125;
        
        
        //入队：
        private void enqueue(Node&amp;lt;E&amp;gt; node) &amp;#123;
        last = last.next = node;
    &amp;#125;
        
        //出队：
        private E dequeue() &amp;#123;
        Node&amp;lt;E&amp;gt; h = head;//h指向了head
        Node&amp;lt;E&amp;gt; first = h.next;//first 指向head的next
        h.next = h; // help GC   h.next指向自己，更容易被GC发现 被GC
        head = first;//head的指向指为first
        E x = first.item;//取出链中第一个元素，给了x
        first.item = null;
        return x;//把x作为方法的返回值
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;【5】put的阻塞：&lt;/p&gt;
&lt;p&gt;阻塞的前提是  队列是固定长度的&lt;/p&gt;
&lt;img data-src=&#34;/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618182407325.png&#34; class=&#34;&#34;&gt;




&lt;div name=queue_impl3&gt;



&lt;blockquote&gt;
&lt;p&gt;SynchronousQueue&lt;/p&gt;
&lt;/blockquote&gt;
&lt;img data-src=&#34;/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618182455703.png&#34; class=&#34;&#34;&gt;


&lt;p&gt;这个特殊的队列设计的意义：&lt;/p&gt;
&lt;img data-src=&#34;/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618182515070.png&#34; class=&#34;&#34;&gt;


&lt;p&gt;测试1：先添加元素：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;public class Test01 &amp;#123;
    //这是main方法，程序的入口
    public static void main(String[] args) &amp;#123;
        SynchronousQueue sq = new SynchronousQueue();
        sq.add(&amp;quot;aaa&amp;quot;);
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;直接报错：说队列满了，因为队列没有容量，理解为满也是正常的：&lt;/p&gt;
&lt;img data-src=&#34;/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618182535474.png&#34; class=&#34;&#34;&gt;


&lt;p&gt;测试2：put方法  阻塞：队列是空的，可以理解为队列满了，满的话放入元素 put 一定会阻塞：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;public class Test01 &amp;#123;
    //这是main方法，程序的入口
    public static void main(String[] args) throws InterruptedException &amp;#123;
        SynchronousQueue sq = new SynchronousQueue();
        sq.put(&amp;quot;aaa&amp;quot;);
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;img data-src=&#34;/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618182600030.png&#34; class=&#34;&#34;&gt;


&lt;p&gt;测试3：先取  再放：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;public class Test02 &amp;#123;
    //这是main方法，程序的入口
    public static void main(String[] args) &amp;#123;
        SynchronousQueue sq = new SynchronousQueue();
        //创建一个线程，取数据：
        new Thread(new Runnable() &amp;#123;
            @Override
            public void run() &amp;#123;
                while(true)&amp;#123;
                    try &amp;#123;
                        System.out.println(sq.take());
                    &amp;#125; catch (InterruptedException e) &amp;#123;
                        e.printStackTrace();
                    &amp;#125;
                &amp;#125;
            &amp;#125;
        &amp;#125;).start();
        //搞一个线程，往里面放数据：
        new Thread(new Runnable() &amp;#123;
            @Override
            public void run() &amp;#123;
                try &amp;#123;
                    sq.put(&amp;quot;aaa&amp;quot;);
                    sq.put(&amp;quot;bbb&amp;quot;);
                    sq.put(&amp;quot;ccc&amp;quot;);
                    sq.put(&amp;quot;ddd&amp;quot;);
                &amp;#125; catch (InterruptedException e) &amp;#123;
                    e.printStackTrace();
                &amp;#125;
            &amp;#125;
        &amp;#125;).start();
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;img data-src=&#34;/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618182625271.png&#34; class=&#34;&#34;&gt;


&lt;p&gt;测试4：poll方法：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;public class Test02 &amp;#123;
    //这是main方法，程序的入口
    public static void main(String[] args) &amp;#123;
        SynchronousQueue sq = new SynchronousQueue();
        //创建一个线程，取数据：
        new Thread(new Runnable() &amp;#123;
            @Override
            public void run() &amp;#123;
                while(true)&amp;#123;
                    try &amp;#123;
                        //设置一个阻塞事件：超出事件就不阻塞了
                        Object result = sq.poll(5, TimeUnit.SECONDS);
                        System.out.println(result);
                        if(result == null)&amp;#123;
                            break;
                        &amp;#125;
                    &amp;#125; catch (InterruptedException e) &amp;#123;
                        e.printStackTrace();
                    &amp;#125;
                &amp;#125;
            &amp;#125;
        &amp;#125;).start();
        //搞一个线程，往里面放数据：
        new Thread(new Runnable() &amp;#123;
            @Override
            public void run() &amp;#123;
                try &amp;#123;
                    sq.put(&amp;quot;aaa&amp;quot;);
                    sq.put(&amp;quot;bbb&amp;quot;);
                    sq.put(&amp;quot;ccc&amp;quot;);
                    sq.put(&amp;quot;ddd&amp;quot;);
                &amp;#125; catch (InterruptedException e) &amp;#123;
                    e.printStackTrace();
                &amp;#125;
            &amp;#125;
        &amp;#125;).start();
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;img data-src=&#34;/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618182647289.png&#34; class=&#34;&#34;&gt;


&lt;p&gt;注意：取出元素 不能用peek，因为peek不会将元素从队列中拿走，只是查看的效果；&lt;/p&gt;
&lt;div name=queue_impl4&gt;



&lt;blockquote&gt;
&lt;p&gt;PriorityBlockingQueue&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;带有优先级的阻塞队列。&lt;br&gt;优先级队列，意味着队列有先后顺序的，数据有不同的权重。&lt;/p&gt;
&lt;p&gt;无界的队列，没有长度限制，但是在你不指定长度的时候，默认初始长度为11，也可以手动指定，&lt;br&gt;当然随着数据不断的加入，底层（底层是数组Object[]）会自动扩容，直到内存全部消耗殆尽了，导致 OutOfMemoryError内存溢出 程序才会结束。&lt;/p&gt;
&lt;img data-src=&#34;/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618183001941.png&#34; class=&#34;&#34;&gt;


&lt;p&gt;不可以放入null元素的，不允许放入不可比较的对象（导致抛出ClassCastException），对象必须实现内部比较器或者外部比较器。&lt;/p&gt;
&lt;p&gt;测试1：添加null数据：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;public class Test &amp;#123;
    //这是main方法，程序的入口
    public static void main(String[] args) &amp;#123;
        PriorityBlockingQueue pq = new PriorityBlockingQueue();
        pq.put(null);
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;img data-src=&#34;/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618183016134.png&#34; class=&#34;&#34;&gt;


&lt;p&gt;测试2：添加四个数据：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;public class Student implements Comparable&amp;lt;Student&amp;gt; &amp;#123;
    String name;
    int age;
    public Student() &amp;#123;
    &amp;#125;
    public Student(String name, int age) &amp;#123;
        this.name = name;
        this.age = age;
    &amp;#125;
    @Override
    public String toString() &amp;#123;
        return &amp;quot;Student&amp;#123;&amp;quot; +
                &amp;quot;name=&amp;#39;&amp;quot; + name + &amp;#39;\&amp;#39;&amp;#39; +
                &amp;quot;, age=&amp;quot; + age +
                &amp;#39;&amp;#125;&amp;#39;;
    &amp;#125;
    @Override
    public int compareTo(Student o) &amp;#123;
        return this.age - o.age;
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;public class Test02 &amp;#123;
    //这是main方法，程序的入口
    public static void main(String[] args) &amp;#123;
        PriorityBlockingQueue&amp;lt;Student&amp;gt; pq = new PriorityBlockingQueue&amp;lt;&amp;gt;();
        pq.put(new Student(&amp;quot;nana&amp;quot;,18));
        pq.put(new Student(&amp;quot;lulu&amp;quot;,11));
        pq.put(new Student(&amp;quot;feifei&amp;quot;,6));
        pq.put(new Student(&amp;quot;mingming&amp;quot;,21));
        System.out.println(pq);
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;结果&lt;/p&gt;
&lt;img data-src=&#34;/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618183048547.png&#34; class=&#34;&#34;&gt;


&lt;p&gt;发现结果并没有按照优先级顺序排列&lt;/p&gt;
&lt;p&gt;测试3：取出数据：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;public class Test02 &amp;#123;
    //这是main方法，程序的入口
    public static void main(String[] args) throws InterruptedException &amp;#123;
        PriorityBlockingQueue&amp;lt;Student&amp;gt; pq = new PriorityBlockingQueue&amp;lt;&amp;gt;();
        pq.put(new Student(&amp;quot;nana&amp;quot;,18));
        pq.put(new Student(&amp;quot;lulu&amp;quot;,11));
        pq.put(new Student(&amp;quot;feifei&amp;quot;,6));
        pq.put(new Student(&amp;quot;mingming&amp;quot;,21));
        System.out.println(&amp;quot;------------------------------------------&amp;quot;);
        System.out.println(pq.take());
        System.out.println(pq.take());
        System.out.println(pq.take());
        System.out.println(pq.take());
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;img data-src=&#34;/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618183114429.png&#34; class=&#34;&#34;&gt;


&lt;p&gt;从结果证明，这个优先级队列，并不是在put数据的时候计算谁在前谁在后&lt;br&gt;而是取数据的时候，才真正判断谁在前 谁在后&lt;/p&gt;
&lt;p&gt;优先级 –》取数据的优先级&lt;/p&gt;
&lt;div name=queue_impl5&gt;



&lt;blockquote&gt;
&lt;p&gt;DelayQueue&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;一、DelayQueue是什么&lt;br&gt;DelayQueue是一个无界的BlockingQueue，用于放置实现了Delayed接口的对象，其中的对象只能在其到期时才能从队列中取走。&lt;/p&gt;
&lt;img data-src=&#34;/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618183216715.png&#34; class=&#34;&#34;&gt;


&lt;p&gt;​	 当生产者线程调用put之类的方法加入元素时，会触发Delayed接口中的compareTo方法进行排序，也就是说队列中元素的顺序是按到期时间排序的，而非它们进入队列的顺序。排在队列头部的元素是最早到期的，越往后到期时间赿晚。&lt;/p&gt;
&lt;p&gt;消费者线程查看队列头部的元素，注意是查看不是取出。然后调用元素的getDelay方法，如果此方法返回的值小０或者等于０，则消费者线程会从队列中取出此元素，并进行处理。如果getDelay方法返回的值大于0，则消费者线程wait返回的时间值后，再从队列头部取出元素，此时元素应该已经到期。&lt;/p&gt;
&lt;p&gt;​	注意：不能将null元素放置到这种队列中。&lt;/p&gt;
&lt;p&gt;二、DelayQueue能做什么&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;淘宝订单业务:下单之后如果三十分钟之内没有付款就自动取消订单。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;饿了吗订餐通知:下单成功后60s之后给用户发送短信通知。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;关闭空闲连接。服务器中，有很多客户端的连接，空闲一段时间之后需要关闭之。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;缓存。缓存中的对象，超过了空闲时间，需要从缓存中移出。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;任务超时处理。在网络协议滑动窗口请求应答式交互时，处理超时未响应的请求等。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;案例：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;public class User implements Delayed &amp;#123;
    private int id;//用户id
    private String name;//用户名字
    private long endTime;//结束时间
    public int getId() &amp;#123;
        return id;
    &amp;#125;
    public void setId(int id) &amp;#123;
        this.id = id;
    &amp;#125;
    public String getName() &amp;#123;
        return name;
    &amp;#125;
    public void setName(String name) &amp;#123;
        this.name = name;
    &amp;#125;
    public long getEndTime() &amp;#123;
        return endTime;
    &amp;#125;
    public void setEndTime(long endTime) &amp;#123;
        this.endTime = endTime;
    &amp;#125;
    public User(int id, String name, long endTime) &amp;#123;
        this.id = id;
        this.name = name;
        this.endTime = endTime;
    &amp;#125;
    //只包装用户名字就可以
    @Override
    public String toString() &amp;#123;
        return &amp;quot;User&amp;#123;&amp;quot; +
                &amp;quot;name=&amp;#39;&amp;quot; + name + &amp;#39;\&amp;#39;&amp;#39; +
                &amp;#39;&amp;#125;&amp;#39;;
    &amp;#125;
    @Override
    public long getDelay(TimeUnit unit) &amp;#123;
        //计算剩余时间 剩余时间小于0 &amp;lt;=0  证明已经到期
        return this.getEndTime() - System.currentTimeMillis();
    &amp;#125;
    @Override
    public int compareTo(Delayed o) &amp;#123;
        //队列中数据 到期时间的比较
        User other = (User)o;
        return ((Long)(this.getEndTime())).compareTo((Long)(other.getEndTime()));
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;compareTo：看谁先被移除&lt;br&gt;getDelay ：看剩余时间&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;public class TestDelayQueue &amp;#123;
    //创建一个队列：
    DelayQueue&amp;lt;User&amp;gt; dq = new DelayQueue&amp;lt;&amp;gt;();
    //登录游戏：
    public void login(User user)&amp;#123;
        dq.add(user);
        System.out.println(&amp;quot;用户：[&amp;quot; + user.getId() +&amp;quot;],[&amp;quot; + user.getName() + &amp;quot;]已经登录，预计下机时间为：&amp;quot; + user.getEndTime() );
    &amp;#125;
    //时间到，退出游戏，队列中移除：
    public void logout()&amp;#123;
        //打印队列中剩余的人：
        System.out.println(dq);
        try &amp;#123;
            User user = dq.take();
            System.out.println(&amp;quot;用户：[&amp;quot; + user.getId() +&amp;quot;],[&amp;quot; + user.getName() + &amp;quot;]上机时间到，自动退出游戏&amp;quot;);
        &amp;#125; catch (InterruptedException e) &amp;#123;
            e.printStackTrace();
        &amp;#125;
    &amp;#125;
    //获取在线人数：
    public int onlineSize()&amp;#123;
        return dq.size();
    &amp;#125;
    //这是main方法，程序的入口
    public static void main(String[] args) &amp;#123;
        //创建测试类对象：
        TestDelayQueue test = new TestDelayQueue();
        //添加登录的用户：
        test.login(new User(1,&amp;quot;张三&amp;quot;,System.currentTimeMillis()+5000));
        test.login(new User(2,&amp;quot;李四&amp;quot;,System.currentTimeMillis()+2000));
        test.login(new User(3,&amp;quot;王五&amp;quot;,System.currentTimeMillis()+10000));
        //一直监控
        while(true)&amp;#123;
            //到期的话，就自动下线：
            test.logout();
            //队列中元素都被移除了的话，那么停止监控，停止程序即可
            if(test.onlineSize() == 0)&amp;#123;
                break;
            &amp;#125;
        &amp;#125;
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;img data-src=&#34;/2022/10/07/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618183342855.png&#34; class=&#34;&#34;&gt;






&lt;h3 id=&#34;双端队列Deque&#34;&gt;&lt;a href=&#34;#双端队列Deque&#34; class=&#34;headerlink&#34; title=&#34;双端队列Deque&#34;&gt;&lt;/a&gt;双端队列Deque&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;public class Test03 &amp;#123;
    //这是main方法，程序的入口
    public static void main(String[] args) &amp;#123;
        /*
        双端队列：
        Deque&amp;lt;E&amp;gt; extends Queue
        Queue一端放 一端取的基本方法  Deque是具备的
        在此基础上 又扩展了 一些 头尾操作（添加，删除，获取）的方法
         */
        Deque&amp;lt;String&amp;gt; d = new LinkedList&amp;lt;&amp;gt;() ;
        d.offer(&amp;quot;A&amp;quot;);
        d.offer(&amp;quot;B&amp;quot;);
        d.offer(&amp;quot;C&amp;quot;);
        System.out.println(d);//[A, B, C]
        d.offerFirst(&amp;quot;D&amp;quot;);
        d.offerLast(&amp;quot;E&amp;quot;);
        System.out.println(d);//[D, A, B, C, E]
        System.out.println(d.poll());
        System.out.println(d);//[A, B, C, E]
        System.out.println(d.pollFirst());
        System.out.println(d.pollLast());
        System.out.println(d);
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
</content>
        <category term="JavaSE" />
        <updated>2022-10-06T16:00:00.000Z</updated>
    </entry>
</feed>
