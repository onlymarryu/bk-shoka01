{
    "version": "https://jsonfeed.org/version/1",
    "title": "记录“美食”每刻 • All posts by \"spring\" category",
    "description": "记录“美食”每刻",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/2022/10/07/Spring/",
            "url": "http://example.com/2022/10/07/Spring/",
            "title": "Spring",
            "date_published": "2022-10-06T16:00:00.000Z",
            "content_html": "<h1 id=\"概念：\"><a href=\"#概念：\" class=\"headerlink\" title=\"概念：\"></a>概念：</h1><ul>\n<li><p>Spring是**一个轻量级 **Java开发框架，目的是为了解决企业级应用开发的业务逻辑层和其他各层的耦合问题。它是一个分层的JavaSE&#x2F;JavaEE full-stack（一站式）轻量级开源框架，为开发Java应用程序提供全面的基础架构支持。Spring负责基础架构，因此Java开发者可以专注于应用程序的开发。</p>\n</li>\n<li><p>Spring最根本的使命是<strong>解决企业级应用开发的复杂性，</strong>即简化<em>Java</em>开发。</p>\n</li>\n<li><p>Spring可以做很多事情，它为企业级开发提供给了丰富的功能，但是这些功能的底层都依赖于它的</p>\n</li>\n</ul>\n<p>两个核心特性，也就是<strong>依赖注入（dependency injection，DI</strong>）和<strong>面向切面编程</strong>（<strong>aspect-</strong></p>\n<p><strong>oriented programming，AOP）</strong>。</p>\n<p>为了降低Java开发的复杂性，Spring采取了以下4种关键策略</p>\n<ul>\n<li><p>基于POJO的轻量级和最小侵入性编程；</p>\n</li>\n<li><p>通过依赖注入和面向接口实现松耦合；</p>\n</li>\n<li><p>基于切面和惯例进行声明式编程；</p>\n</li>\n<li><p>通过切面和模板减少样板式代码。</p>\n</li>\n</ul>\n<h1 id=\"Spring的俩大核心概念\"><a href=\"#Spring的俩大核心概念\" class=\"headerlink\" title=\"Spring的俩大核心概念\"></a>Spring的俩大核心概念</h1><h2 id=\"IOC（控制翻转）：\"><a href=\"#IOC（控制翻转）：\" class=\"headerlink\" title=\"IOC（控制翻转）：\"></a>IOC（控制翻转）：</h2><p>控制翻转，也叫依赖注入，他就是不会直接创建对象，只是把对象声明出来，在代码 中不直</p>\n<p>接与对象和服务进行连接，但是在配置文件中描述了哪一项组件需要哪一项服 务，容器将他</p>\n<p>们组件起来。在一般的IOC场景中容器创建了所有的对象，并设置了必 要的属性将他们联系</p>\n<p>在一起，等到需要使用的时候才把他们声明出来，使用注解就跟 方便了，容器会自动根据注</p>\n<p>解把对象组合起来</p>\n<h2 id=\"其中还有一个点DI-依赖注入\"><a href=\"#其中还有一个点DI-依赖注入\" class=\"headerlink\" title=\"其中还有一个点DI(依赖注入)\"></a>其中还有一个点DI(依赖注入)</h2><h2 id=\"AOP（面对切面编程）\"><a href=\"#AOP（面对切面编程）\" class=\"headerlink\" title=\"AOP（面对切面编程）\"></a>AOP（面对切面编程）</h2><p>面对切面编程，这是一种编程模式，他允许程序员通过自定义的横切点进行模块 化，将那些</p>\n<p>影响多个类的行为封装到课重用的模块中。 例子：比如日志输出，不使用AOP的话就需要把</p>\n<p>日志的输出语句放在所有类中，方法 中，但是有了AOP就可以把日志输出语句封装一个可重</p>\n<p>用模块，在以声明的方式将他 们放在类中，每次使用类就自动完成了日志输出。</p>\n<h1 id=\"Bean的生命周期\"><a href=\"#Bean的生命周期\" class=\"headerlink\" title=\"Bean的生命周期\"></a>Bean的生命周期</h1><p>1 通过构造器创建bean实例           执行构造器<br>2 为bean属性赋值                         执行set方法<br>3 初始化bean                                调用bean的初始化方法,需要配置指定调用的方法<br>4 bean的获取                                容器对象 getBean方法<br>5 容器关闭销毁bean                      调用销毁方法,需要配置指定调用的方法</p>\n<pre><code class=\"java\">public class User &#123;\n    private Integer userid;\n    private String username;\n    private String password;\n    public void initUser()&#123;\n        System.out.println(&quot;第三步:User初始化&quot;);\n    &#125;\n    public User() &#123;\n        System.out.println(&quot;第一步:User构造&quot;);\n    &#125;\n    public void destoryUser()&#123;\n        System.out.println(&quot;第五步:User销毁&quot;);\n    &#125;\n    @Override\n    public String toString() &#123;\n        return &quot;User&#123;&quot; +\n                &quot;userid=&quot; + userid +\n                &quot;, username=&#39;&quot; + username + &#39;\\&#39;&#39; +\n                &quot;, password=&#39;&quot; + password + &#39;\\&#39;&#39; +\n                &#39;&#125;&#39;;\n    &#125;\n    public User(Integer userid, String username, String password) &#123;\n        this.userid = userid;\n        this.username = username;\n        this.password = password;\n    &#125;\n    public void setUserid(Integer userid) &#123;\n        System.out.println(&quot;setUserid&quot;);\n        this.userid = userid;\n    &#125;\n    public void setUsername(String username) &#123;\n        System.out.println(&quot;第二步:User属性赋值&quot;);\n        this.username = username;\n    &#125;\n    public void setPassword(String password) &#123;\n        this.password = password;\n    &#125;\n&#125;\n</code></pre>\n<p>配置Bean</p>\n<pre><code class=\"xml\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;\n       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n       xmlns:p=&quot;http://www.springframework.org/schema/p&quot;\n       xmlns:c=&quot;http://www.springframework.org/schema/c&quot;\n       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans\n       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;\n    &lt;!--  --&gt;\n    &lt;bean id=&quot;user&quot; class=&quot;com.msb.bean.User&quot; init-method=&quot;initUser&quot; destroy-method=&quot;destoryUser&quot;&gt;\n        &lt;property name=&quot;username&quot; value=&quot;xiaoming&quot;&gt;&lt;/property&gt;\n    &lt;/bean&gt;\n&lt;/beans&gt;\n</code></pre>\n<p>根据 Class、property 通过反射去找构造器创建实例，然后对property属性根据 set 方法注入依赖也叫赋值，</p>\n<p>通过指定 init-method(初始化方法) 来对我们的对象再次进行操作，第四步获取 Bean 对象，第五步项目结束Context销毁，调用销毁方法销毁Bean</p>\n<p>&#x3D;&#x3D;以上我们是对一般的过程其实在这个基础上我们还可以再次增加两步，这个叫后置处理器，处理后的顺序：&#x3D;&#x3D;</p>\n<p>1 通过构造器创建bean实例           执行构造器<br>2 为bean属性赋值                         执行set方法<br><font color=red>3 把bean实例传递给bean的后置处理器的方法</font><br>4 初始化bean                                调用bean的初始化方法,需要配置指定调用的方法<br><font color=red>5 把bean实例传递给bean的后置处理器的方法</font><br>6 bean的获取                                容器对象 getBean方法<br>7 容器关闭销毁bean                      调用销毁方法,需要配置指定调用的方法</p>\n<p>&#x3D;&#x3D;添加后置处理器&#x3D;&#x3D;</p>\n<p><strong>1 创建后置处理器 实现 BeanPostProcesser  重写两个方法</strong></p>\n<pre><code class=\"java\">\nimport org.springframework.beans.BeansException;\nimport org.springframework.beans.factory.config.BeanPostProcessor;\n// 1 创建后置处理器 实现 BeanPostProcesser  重写两个方法\npublic class MyBeanProcesser implements BeanPostProcessor &#123;\n    @Override\n    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException &#123;\n        //Object bean      实例化的bean\n        //String beanName  bean的id\n        System.out.println(&quot;bean:初始化方法之前&quot;);\n        return bean;// 这里必须return bean\n    &#125;\n    @Override\n    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123;\n        System.out.println(&quot;bean:初始化方法之后&quot;);\n        return bean;// 这里必须returnbean\n    &#125;\n&#125;\n</code></pre>\n<p><strong>2 配置后置处理器,对容器中的所有bean添加后置处理器的生命周期</strong></p>\n<pre><code class=\"xml\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;\n       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n       xmlns:p=&quot;http://www.springframework.org/schema/p&quot;\n       xmlns:c=&quot;http://www.springframework.org/schema/c&quot;\n       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans\n       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;\n    &lt;bean id=&quot;user&quot; class=&quot;com.msb.bean.User&quot; init-method=&quot;initUser&quot; destroy-method=&quot;destoryUser&quot;&gt;\n        &lt;property name=&quot;username&quot; value=&quot;xiaoming&quot;&gt;&lt;/property&gt;\n    &lt;/bean&gt;\n    \n    &lt;bean id=&quot;myBeanProcesser&quot; class=&quot;com.msb.beanProcesser.MyBeanProcesser&quot;&gt;&lt;/bean&gt;\n&lt;/beans&gt;\n</code></pre>\n<p><strong>BeanPostProcessor接口作用：</strong></p>\n<blockquote>\n<p>如果我们想在Spring容器中完成bean实例化、配置以及其他初始化方法前后要添加一些自己逻辑处理。我们需要定义一个或多个BeanPostProcessor接口实现类，然后注册到Spring IoC容器中。</p>\n</blockquote>\n<p>1、接口中的两个方法都要将传入的bean返回，而不能返回null，如果返回的是null那么我们通过getBean方法将得不到目标。<br>2、ApplicationContext会自动检测在配置文件中实现了BeanPostProcessor接口的所有bean，并把它们注册为后置处理器，然后在容器创建bean的适当时候调用它，因此部署一个后置处理器同部署其他的bean并没有什么区别。而使用BeanFactory实现的时候，bean 后置处理器必须通过代码显式地去注册，在IoC容器继承体系中的ConfigurableBeanFactory接口中定义了注册方法</p>\n<p><strong>总结</strong></p>\n<p>完整的过程：</p>\n<blockquote>\n<p>创建实例 –&gt; set赋值 –&gt; 再次初始化对象–&gt; 获取Bean对象–&gt; 销毁Bean对象</p>\n<p>创建实例 –&gt; set赋值 –&gt;把bean实例传递给bean的后置处理器的方法 –&gt; 再次初始化对象 –&gt; 把bean实例传递给bean的后置处理器的方法 —&gt; 获取Bean对象–&gt; 销毁Bean对象</p>\n</blockquote>\n<h1 id=\"Bean自动装配\"><a href=\"#Bean自动装配\" class=\"headerlink\" title=\"Bean自动装配\"></a>Bean自动装配</h1><p>通过property标签可以手动指定给属性进行注入<br>我们也可以通过自动转配,完成&#x3D;&#x3D;属性的自动注入&#x3D;&#x3D;,就是自动装配,可以简化DI的配置</p>\n<pre><code class=\"xml\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;\n       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n       xmlns:p=&quot;http://www.springframework.org/schema/p&quot;\n       xmlns:c=&quot;http://www.springframework.org/schema/c&quot;\n       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans\n       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;\n    &lt;bean id=&quot;dept&quot; class=&quot;com.msb.bean.Dept&quot;&gt;&lt;/bean&gt;\n    &lt;!--\n    autowire 属性控制自动将容器中的对象注入到当前对象的属性上\n    byName 根据目标id值和属性值注入,要保证当前对象的属性值和目标对象的id值一致\n    byType 根据类型注入,要保证相同类型的目标对象在容器中只有一个实例\n    --&gt;\n    &lt;bean id=&quot;emp&quot; class=&quot;com.msb.bean.Emp&quot; autowire=&quot;byName&quot;&gt;&lt;/bean&gt;\n&lt;/beans&gt;\n</code></pre>\n<h1 id=\"Spring注解管理Bean\"><a href=\"#Spring注解管理Bean\" class=\"headerlink\" title=\"Spring注解管理Bean\"></a>Spring注解管理Bean</h1><h2 id=\"1注解方式创建对象IOC\"><a href=\"#1注解方式创建对象IOC\" class=\"headerlink\" title=\"1注解方式创建对象IOC\"></a>1注解方式创建对象IOC</h2><p>导入依赖 aop</p>\n<p>@Component    放在类上,用于标记,告诉spring当前类需要由容器实例化bean并放入容器中<br>  该注解有三个子注解<br>  @Controller   用于实例化controller层bean<br>        @Service        用于实例化service层bean<br>        @Repository  用于实例化持久层bean<br>  当不确定是哪一层,就用Component<br>这几个注解互相混用其实也可以,但是不推荐</p>\n<h2 id=\"2注解方式依赖注入DI\"><a href=\"#2注解方式依赖注入DI\" class=\"headerlink\" title=\"2注解方式依赖注入DI\"></a>2注解方式依赖注入DI</h2><p>@Autowired   根据属性数据类型自动装配<br>@Qualifier      根据属性名称注入依赖<br>@Resources   可以根据类型,也可以根据名称注入<br>@Value           注入普通数据类型(8+String)</p>\n<pre><code class=\"java\">// 详解 \n/*\n    * @Autowired\n    * 根据类型到容器中去寻找对应的对象,找到后给当前属性赋值\n    * 不需要依赖 set方法\n    * 属性类型可以是接口,会自动匹配对应的实现类对象\n    * @Autowired配合 @Qualifier,可以通过名称指定注入的对象\n    *\n    * @Resource 如果不配置name 那么就是根据类型注入\n    * @Resource(name=&quot;userDaoImplB&quot;) 配置name,就是根据名称注入\n    *\n    *\n    * @Resource  是JDK中javax包的注解\n    * @Autowired 和 @Qualifier 是spring中的注解\n    *\n    * @Value 可以个普通属性赋值\n    * @Value 可以使用$&#123;&#125;这种表达式获取系统的变量值\n    *        或者是.properties属性配置文件中的值\n    *\n    * */\n</code></pre>\n<h1 id=\"代理\"><a href=\"#代理\" class=\"headerlink\" title=\"代理\"></a>代理</h1><p><em>概念</em>：在使用对象的时候，不直接使用用一个代理对象代理他，这样可以在目标<strong>对象基础上增强额外的功能</strong>。</p>\n<p><em>分类</em>：静态代理，动态代理</p>\n<h2 id=\"静态代理\"><a href=\"#静态代理\" class=\"headerlink\" title=\"静态代理\"></a>静态代理</h2><blockquote>\n<p>​\t静态代理中<strong>代理类</strong>与<strong>被代理类</strong>都<strong>需要实现同一个接口</strong>，这就说明我们的<strong>一个静态代理类只能代理一个类</strong>，并且还要事先知道我们<strong>要代理哪个类才能写代理类</strong>，如果我们<strong>有其他类还想使用代理那就必须再写一个代理类</strong>。</p>\n</blockquote>\n<p>​\t然而在实际开发中我们是可能是有非常多的类是需要被代理的，并且事先我们可能并不知道我们要代理哪个类。所以如果继续使用静态代理反而会增加许多的工作量，并且<strong>效率低下</strong>，<strong>代码复用率也不好</strong>。</p>\n<pre><code class=\"java\">public class Test1 &#123;\n    public static void main(String[] args) &#123;\n        /**\n        lawyer律师代替Person张三打官司，不用张三直接打，可以更加清楚\n        */\n        Person person =new Person(&quot;张三&quot;);\n        Court court=new Lawyer(person);\n        court.doCourt();\n    &#125;\n&#125;\n// 接口\ninterface Court&#123;\n    void doCourt();\n&#125;\n// 代理类\nclass Lawyer implements Court&#123;\n    private Person person;\n    public Lawyer(Person person) &#123;\n        this.person = person;\n    &#125;\n    @Override\n    public void doCourt() &#123;\n        System.out.println(&quot;律师取证:视频证明张三当时正在旅游,不在案发现场&quot;);\n        System.out.println(&quot;律师总结:张三不可能去杀人&quot;);\n        person.doCourt();\n    &#125;\n&#125;\n// 被代理的类\nclass Person implements Court&#123;\n    private String name;\n    public Person(String name) &#123;\n        this.name = name;\n    &#125;\n    @Override\n    public void doCourt() &#123;\n        System.out.println(name+&quot;说:我没有杀人&quot;);\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"动态代理\"><a href=\"#动态代理\" class=\"headerlink\" title=\"动态代理\"></a>动态代理</h2><p><em>概念</em>：动态代理可以<strong>针对</strong>于一些<strong>不特定的类</strong>或者一些<strong>不特定的方法</strong>进行代理,我们可以在程序运行时动态的变化代理的规则，<strong>代理类在程序运行时才创建的代理模式成为动态代理</strong>。这种情况下，代理类并不是在Java代码中定义好的，而是在程序运行时根据我们的在Java代码中的“指示”动态生成的</p>\n<p>实现方法：JDK自带的Proxy、CJlib</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\"><strong>Proxy</strong></th>\n<th align=\"center\"><strong>JDK动态代理</strong></th>\n<th align=\"center\"><strong>面向接口</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"><em><strong>cglib</strong></em></td>\n<td align=\"center\"><em><strong>第三方动态代理</strong></em></td>\n<td align=\"center\"><em><strong>面向父类</strong></em></td>\n</tr>\n</tbody></table>\n<p>实现案例：</p>\n<p>Proxy:</p>\n<pre><code class=\"java\">public class ProxyTest1 &#123;\n\n    public static void main(String[] args) &#123;\n        Dinner dinner = new Person(&quot;张三&quot;);\n        ClassLoader loader = dinner.getClass().getClassLoader();\n        Class&lt;?&gt;[] interfaces = dinner.getClass().getInterfaces();\n        /*\n           Object proxy, 代理对象\n           Method method,被代理的方法\n           Object[] args,被代理方法运行时的实参\n         */\n        /*InvocationHandler invocationHandler = (proxy,\n                                              method,\n                                              params)-&gt;&#123;\n            System.out.println(&quot;invoked 方法执行&quot;);\n\n            return null;\n        &#125;;*/\n        InvocationHandler invocationHandler = new InvocationHandler() &#123;\n            @Override\n            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;\n                Object res = new Object();\n\n                if (method.getName().equals(&quot;eat&quot;)) &#123;\n                    System.out.println(&quot;饭前洗手&quot;);\n                    // 让原有的eat的方法去运行\n                    res =method.invoke(dinner, args);\n                    System.out.println(&quot;饭后刷碗&quot;);\n                &#125;\n                else&#123;\n                    // 如果是其他方法,那么正常执行就可以了\n                    res =method.invoke(dinner, args);\n                &#125;\n                return res;\n            &#125;\n        &#125;;\n\n        /**\n         * 动态代理\n         * 需要三次个参数 loader代理类，增强的对象，\n         *              interfaces 实现的接口，\n         *              增强方法 invoke()\n         */\n        Dinner dinner1 = (Dinner) Proxy.newProxyInstance(loader,interfaces,invocationHandler);\n        dinner1.eat(&quot;包子&quot;);\n    &#125;\n&#125;\ninterface Dinner&#123;\n    void eat(String foodName);\n    void drink();\n&#125;\n\nclass Person implements Dinner&#123;\n    private String name;\n    public Person(String name) &#123;\n        this.name = name;\n    &#125;\n    @Override\n    public void eat(String foodName) &#123;\n        System.out.println(name+&quot;正在吃&quot;+foodName);\n    &#125;\n    @Override\n    public void drink( ) &#123;\n        System.out.println(name+&quot;正在喝茶&quot;);\n    &#125;\n&#125;\nclass Student implements Dinner&#123;\n    private String name;\n    public Student(String name) &#123;\n        this.name = name;\n    &#125;\n    @Override\n    public void eat(String foodName) &#123;\n        System.out.println(name+&quot;正在食堂吃&quot;+foodName);\n    &#125;\n    @Override\n    public void drink( ) &#123;\n        System.out.println(name+&quot;正在喝可乐&quot;);\n    &#125;\n&#125;\n</code></pre>\n<p>Cglib</p>\n<pre><code class=\"java\">public class ProxyTest2 &#123;\n\n    public static void main(String[] args) &#123;\n        // 获取一个Person的代理对象\n        Person person = new Person();\n        // 1 获得一个Enhancer对象\n        Enhancer enhancer = new Enhancer();\n        // 2 设置父类字节码\n        enhancer.setSuperclass(Person.class);\n        // 3 获取MethodIntercepter对象 用于定义增强规则\n        MethodInterceptor methodInterceptor = new MethodInterceptor() &#123;\n            /*\n            * Object o 生成之后的代理对象 personProxy\n            * Method method 父类中原本要执行的方法  Person&gt;&gt;&gt; eat()要增强的方法（还没有被增强，父类方法）\n            * Object[] objects 实际传入的参数\n            * MethodProxy methodProxy 子类中重写父类的方法 personProxy &gt;&gt;&gt; eat()代理对象增强的方法（增强的方法，子类对象）\n            * */\n            @Override\n            public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable &#123;\n                Object res = null;\n\n                if (method.getName().equals(&quot;eat&quot;)) &#123;\n                    System.out.println(&quot;饭前洗手&quot;);\n                    res=methodProxy.invokeSuper(o,objects);\n                    System.out.println(&quot;饭后刷碗&quot;);\n                &#125;else&#123;\n                    // 如果是其他方法 不增强运行\n                    res=methodProxy.invokeSuper(o,objects); // 子类对象方法在执行,默认会调用父类对应被重写的方法\n                &#125;\n                return res;\n            &#125;\n        &#125;;\n        // 4 设置methodInterceptor\n        enhancer.setCallback(methodInterceptor);\n        // 5 获得代理对象\n        Person personProxy = (Person)enhancer.create();\n        // 6 使用代理对象完成功能\n        personProxy.eat(&quot;包子&quot;);\n    &#125;\n&#125;\n\nclass Person  &#123;\n    public Person( ) &#123;\n    &#125;\n    public void eat(String foodName) &#123;\n        System.out.println(&quot;张三正在吃&quot;+foodName);\n    &#125;\n&#125;\n</code></pre>\n<blockquote>\n<p>总结</p>\n</blockquote>\n<ul>\n<li>在<strong>不修改原有代码</strong>的 或者没有办法修改原有代码的情况下  <strong>增强对象功能</strong>  <strong>使用代理对象</strong> 代替原来的对象去完成功能进而达到拓展功能的目的</li>\n<li><strong>JDK Proxy 动态代理面向接口的动态代理</strong>  一定<strong>要有接口</strong>和<strong>实现类</strong>的存在 代理对象<strong>增强的是实现类</strong> 在实现接口的方法重写的方法   生成的代理对象只能转换成 接口的不能转换成 被代理类代理对象只能增强接口中定义的方法  <strong>实现类中其他和接口无关的方法是无法增强的代理对象只能读取到接口中方法上的注解 不能读取到实现类方法上的注解</strong></li>\n</ul>\n<h1 id=\"AOP\"><a href=\"#AOP\" class=\"headerlink\" title=\"AOP\"></a>AOP</h1><p>全名：Aspect Oriented Programmings，面向切面编程，通过<strong>预编译</strong>和<strong>运行时生成动态代理</strong>实现程序功能的统一维护的一种技术。AOP是OOP的延续，是Spring框架的一个重要内容，是函数式编程的一种衍生范式。利用AOP可以对业务逻辑的各个部分进行隔离，从而使各个部分的耦合性降低，提高程序的可重用行，提高开发效率。</p>\n<hr>\n<p>AOP切面编程一般可以帮助我们在不修改现有代码的情况下,对程序的功能进行拓展,往往用于实现 日志处理,权限控制,性能检测,事务控制等<br>AOP实现的原理就是动态代理,在有接口的情况下,使用JDK动态代理,在没有接口的情况下使用cglib动态代理</p>\n<img data-src=\"/2022/10/07/Spring/image-20220716162550876.png\" class=\"\">\n\n\n\n\n<p>AOP中的术语辨析</p>\n<p>1 连接点 Joint point：类里面那些可以被增强的方法</p>\n<p>2 切入点 Pointcu：实际被增强的方法,称之为切入点</p>\n<p>3 通知 Advice:：实际增强的逻辑部分称为通知 (增加的功能)</p>\n<p>4 目标对象 Target：被增强功能的对象(被代理的对象)</p>\n<p>5 切面Aspect： 表现为功能相关的一些advice方法放在一起声明成的一个Java类</p>\n<p>6 织入 Weaving：创建代理对象并实现功能增强的声明并运行过程</p>\n<p>具体操作</p>\n<pre><code class=\"java\">/*\n事先准备 dao 以及他的实现类\n我们直接编写 Aspect 层的代码\n*/\n\n@Component\n@Aspect\npublic class DaoAspect &#123;\n    /*\n    切入点表达式: 通过一个表达式来确定AOP要增强的是哪个或者那些方法\n    语法结构:execution([权限修饰符][返回值类型][类的全路径名][方法名](参数 列表) )\n    execution(* com.msb.dao.UserDaoImpl.add(..))   //指定切点为UserDaoImpl.add方法\n    execution(* com.msb.dao.UserDaoImpl.*(..))     //指定切点为UserDaoImpl.所有的方法\n    execution(* com.msb.dao.*.*(..))               //指定切点为dao包下所有的类中的所有的方法\n    execution(* com.msb.dao.*.add(..))             // 指定切点为dao包下所有的类中的add的方法\n    execution(* com.msb.dao.*.add*(..))            // 指定切点为dao包下所有的类中的add开头的方法\n    *  */\n    //定义公共切点\n    @Pointcut(&quot;execution( * com.zjj.aop.dao.*.add*(..) )&quot;)\n    public void addPointCut()&#123;\n\n    &#125;\n\n    /*\n     * 前置通知: 切点方法执行之前先执行的功能\n     * 参数列表可以用JoinPoint接收切点对象\n     * 可以获取方法执行的参数\n     * */\n    @Before(&quot;addPointCut()&quot;) // 这里用了公共切点，不然又要写一次公共切点上的 @PointCut()\n    public void methodBefore(JoinPoint joinPoint) &#123;\n        System.out.println(&quot;Before invoked&quot;);\n    &#125;\n\n\n    /*\n     * 后置通知:方法执行之后要增强的功能\n     * 无论切点方法是否出现异常都会执行的方法\n     * 参数列表可以用JoinPoint接收切点对象\n     * */\n    @After(&quot;addPointCut()&quot;)\n    public void methodAfter(JoinPoint joinPoint)&#123;\n        System.out.println(&quot;After invoked&quot;);\n    &#125;\n\n    /*\n     * 返回通知:切点方法正常运行结束后增强的功能\n     * 如果方法运行过程中出现异常,则该功能不运行\n     * 参数列表可以用 JoinPoint joinPoint接收切点对象\n     * 可以用Object res接收方法返回值,需要用returning指定返回值名称\n     * */\n    @AfterReturning( value = &quot;addPointCut()&quot;,returning = &quot;res&quot;)\n    public void methodAfterReturning(JoinPoint joinPoint,Object res)&#123;\n        System.out.println(&quot;AfterReturning invoked&quot;);\n    &#125;\n    /*\n     * 异常通知:切点方法出现异常时运行的增强功能\n     * 如果方法运行没有出现异常,则该功能不运行\n     * 参数列表可以用Exception ex接收异常对象 需要通过throwing指定异常名称\n     * */\n    @AfterThrowing( value = &quot;addPointCut()&quot;,throwing = &quot;ex&quot;)\n    public void methodAfterThrowing(Exception ex)&#123;\n        System.out.println(&quot;AfterThrowing invoked&quot;);\n    &#125;\n\n    /*环绕通知:在切点方法之前和之后都进行功能的增强\n     * 需要在通知中定义方法执行的位置,并在执行位置之前和之后自定义增强的功能\n     * 方法列表可以通过ProceedingJoinPoint获取执行的切点\n     * 通过proceedingJoinPoint.proceed()方法控制切点方法的执行位置\n     * proceedingJoinPoint.proceed()方法会将切点方法的返回值获取到,并交给我们,可以做后续处理\n     * 我们在环绕通知的最后需要将切点方法的返回值继续向上返回,否则切点方法在执行时接收不到返回值\n     * */\n    @Around(&quot;addPointCut()&quot;)\n    public Object methodAround(ProceedingJoinPoint proceedingJoinPoint) throws Throwable &#123;\n        System.out.println(&quot;aroundA invoked&quot;);\n        Object proceed = proceedingJoinPoint.proceed();\n        System.out.println(&quot;aroundB invoked&quot;);\n        return proceed;\n    &#125;\n\n&#125;\n</code></pre>\n<p>测试</p>\n<pre><code class=\"java\">@SpringBootTest(classes = MyAOPSpringApplication.class)\npublic class SpringAOPTests &#123;\n    @Resource\n    ApplicationContext context;\n    @Test\n    public void t1() &#123;\n        UserService userService = context.getBean(UserService.class);\n        userService.addUser(10, &quot;小明&quot;);\n    &#125;\n&#125;\n</code></pre>\n<p>结果：</p>\n<blockquote>\n<p>aroundA invoked</p>\n<p>Before invoked</p>\n<p>userDao add … …</p>\n<p>AfterReturning invoked</p>\n<p>After invoked</p>\n<p>aroundB invoked</p>\n</blockquote>\n<p>面试题</p>\n<p>如果在不使用框架的前提下你要做权限的校验你会怎么做?</p>\n<blockquote>\n<p>我会在要鉴权的方法加入环绕通知，在请求到方法前先进行一次查找，一般这些数据我们会在redis中也会存储一个，第一次查过来我们去redis中找，找到直接让他操作并且在之后提交事务，但是没找到的时候我们先让他去操作，但是不提交事务，同时去数据库中查找他的信息，找到后添加redis，提交事务，没找到就回滚事务即可。</p>\n</blockquote>\n<h1 id=\"事务\"><a href=\"#事务\" class=\"headerlink\" title=\"事务\"></a>事务</h1><h2 id=\"事务的概念\"><a href=\"#事务的概念\" class=\"headerlink\" title=\"事务的概念\"></a>事务的概念</h2><p>事务（Transaction）指的是一个操作序列，该操作序列中的多个操作要么都做，要么都不做，是一个不可分割的工作单位，是数据库环境中的逻辑工作单位，由DBMS中的事务管理子系统负责事务的处理。</p>\n<p>目前常用的存储引擎有InnoDB（MySQL5.5以后默认的存储引擎）和MyISAM（MySQL5.5之前默认的存储引擎），其中InnoDB支持事务处理机制，而MyISAM不支持。</p>\n<h2 id=\"事务的特性\"><a href=\"#事务的特性\" class=\"headerlink\" title=\"事务的特性\"></a>事务的特性</h2><p>事务处理可以确保除非事务性序列内的所有操作都成功完成，否则不会永久更新面向数据的资源。通过将一组相关操作组合为一个要么全部成功要么全部失败的序列，可以简化错误恢复并使应用程序更加可靠。</p>\n<p>但并不是所有的操作序列都可以称为事务，这是因为一个操作序列要成为事务，必须满足事务的原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）和持久性（Durability）。这四个特性简称为ACID特性。</p>\n<img data-src=\"/2022/10/07/Spring/image-20220716210341261.png\" class=\"\">\n\n\n<ol>\n<li><pre><code>原子性\n</code></pre>\n</li>\n</ol>\n<p>原子是自然界最小的颗粒，具有不可再分的特性。事务中的所有操作可以看做一个原子，事务是应用中不可再分的最小的逻辑执行体。</p>\n<p>使用事务对数据进行修改的操作序列，要么全部执行，要么全不执行。通常，某个事务中的操作都具有共同的目标，并且是相互依赖的。如果数据库系统只执行这些操作中的一部分，则可能会破坏事务的总体目标，而原子性消除了系统只处理部分操作的可能性。</p>\n<ol start=\"2\">\n<li><pre><code> 一致性\n</code></pre>\n</li>\n</ol>\n<p>一致性是指事务执行的结果必须使数据库从一个一致性状态，变到另一个一致性状态。当数据库中只包含事务成功提交的结果时，数据库处于一致性状态。一致性是通过原子性来保证的。</p>\n<p>例如：在转账时，只有保证转出和转入的金额一致才能构成事务。也就是说事务发生前和发生后，数据的总额依然匹配。</p>\n<ol start=\"3\">\n<li><pre><code> 隔离性\n</code></pre>\n</li>\n</ol>\n<p>隔离性是指各个事务的执行互不干扰，任意一个事务的内部操作对其他并发的事务，都是隔离的。也就是说：并发执行的事务之间既不能看到对方的中间状态，也不能相互影响。</p>\n<p>例如：在转账时，只有当A账户中的转出和B账户中转入操作都执行成功后才能看到A账户中的金额减少以及B账户中的金额增多。并且其他的事务对于转账操作的事务是不能产生任何影响的。</p>\n<ol start=\"4\">\n<li><pre><code>持久性\n</code></pre>\n</li>\n</ol>\n<p>持久性指事务一旦提交，对数据所做的任何改变，都要记录到永久存储器中，通常是保存进物理数据库，即使数据库出现故障，提交的数据也应该能够恢复。但如果是由于外部原因导致的数据库故障，如硬盘被损坏，那么之前提交的数据则有可能会丢失。</p>\n<h2 id=\"事务的并发问题\"><a href=\"#事务的并发问题\" class=\"headerlink\" title=\"事务的并发问题\"></a>事务的并发问题</h2><p>脏读（Dirty read）</p>\n<p>当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。</p>\n<img data-src=\"/2022/10/07/Spring/image-20220716210633569.png\" class=\"\">\n\n\n<p>不可重复读</p>\n<p>（Unrepeatableread）: 指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。</p>\n<img data-src=\"/2022/10/07/Spring/image-20220716210640447.png\" class=\"\">\n\n\n<p>幻读</p>\n<p>（Phantom read）: 幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。</p>\n<img data-src=\"/2022/10/07/Spring/image-20220716210646452.png\" class=\"\">\n\n\n<p><strong>不可重复度和幻读区别：</strong></p>\n<p>不可重复读的重点是修改，幻读的重点在于新增或者删除。</p>\n<p><strong>解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表</strong></p>\n<p>例1（同样的条件, 你读取过的数据, 再次读取出来发现值不一样了 ）：事务1中的A先生读取自己的工资为 1000的操作还没完成，事务2中的B先生就修改了A的工资为2000，导 致A再读自己的工资时工资变为 2000；这就是不可重复读。</p>\n<p>例2（同样的条件, 第1次和第2次读出来的记录数不一样 ）：假某工资单表中工资大于3000的有4人，事务1读取了所有工资大于3000的人，共查到4条记录，这时事务2又插入了一条工资大于3000的记录，事务1再次读取时查到的记录就变为了5条，这样就导致了幻读</p>\n<h2 id=\"事务的隔离级别\"><a href=\"#事务的隔离级别\" class=\"headerlink\" title=\"事务的隔离级别\"></a>事务的隔离级别</h2><p>事务的隔离级别用于决定如何控制并发用户读写数据的操作。数据库是允许多用户并发访问的，如果多个用户同时开启事务并对同一数据进行读写操作的话，有可能会出现脏读、不可重复读和幻读问题，所以MySQL中提供了四种隔离级别来解决上述问题。</p>\n<p>事务的隔离级别从低到高依次为READ UNCOMMITTED、READ COMMITTED、REPEATABLE READ以及SERIALIZABLE，隔离级别越低，越能支持高并发的数据库操作。</p>\n<p>​                                   </p>\n<h2 id=\"spring中可以使用如下方式实现事务的控制\"><a href=\"#spring中可以使用如下方式实现事务的控制\" class=\"headerlink\" title=\"spring中可以使用如下方式实现事务的控制\"></a>spring中可以使用如下方式实现事务的控制</h2><p>1 编程式(不推荐)</p>\n<p>2 声明式(掌握)</p>\n<p>​\t1) 注解(简单,必会)</p>\n<p>​\t2) XML配置(繁琐,了解)</p>\n<p>  <strong>Spring声明式事务的实现方式,底层就是AOP,AOP的底层就是动态代理</strong></p>\n<p>Spring事务管理相关的API</p>\n<p>事务管理器接口: PlatformTransactionManager  针对不同的框架,提供了不同的实现类</p>\n<img data-src=\"/2022/10/07/Spring/image-20220716210813110.png\" class=\"\">\n\n\n<p>注解方式实现事务控制<br>在applicationContext.xml配置事务相关的配置</p>\n<pre><code class=\"xml\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;\n       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n       xmlns:p=&quot;http://www.springframework.org/schema/p&quot;\n       xmlns:c=&quot;http://www.springframework.org/schema/c&quot;\n       xmlns:util=&quot;http://www.springframework.org/schema/util&quot;\n       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;\n       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;\n       xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;\n       xsi:schemaLocation=&quot;\n       http://www.springframework.org/schema/beans\n       http://www.springframework.org/schema/beans/spring-beans.xsd\n       http://www.springframework.org/schema/util\n       http://www.springframework.org/schema/util/spring-util.xsd\n       http://www.springframework.org/schema/context\n       http://www.springframework.org/schema/context/spring-context.xsd\n       http://www.springframework.org/schema/aop\n       http://www.springframework.org/schema/aop/spring-aop.xsd\n       http://www.springframework.org/schema/tx\n       http://www.springframework.org/schema/tx/spring-tx.xsd\n&quot;&gt;\n    &lt;!--spring 注解扫描--&gt;\n    &lt;context:component-scan base-package=&quot;com.msb&quot;/&gt;\n    &lt;!--读取jdbc配置文件--&gt;\n    &lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot;/&gt;\n    &lt;!--配置德鲁伊连接池--&gt;\n    &lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt;\n        &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc_username&#125;&quot;&gt;&lt;/property&gt;\n        &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc_password&#125;&quot;&gt;&lt;/property&gt;\n        &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc_url&#125;&quot;&gt;&lt;/property&gt;\n        &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;jdbc_driver&#125;&quot;&gt;&lt;/property&gt;\n    &lt;/bean&gt;\n    &lt;!--配置JDBCTemplate对象,并向里面注入DataSource--&gt;\n    &lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt;\n        &lt;!--通过set方法注入连接池--&gt;\n        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;\n    &lt;/bean&gt;\n    &lt;!--配置一个事务管理器--&gt;\n    &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;\n        &lt;!--将数据源注入事务管理器--&gt;\n        &lt;property name=&quot;dataSource&quot;  ref=&quot;dataSource&quot;&gt;&lt;/property&gt;\n    &lt;/bean&gt;\n    &lt;!--开启事务注解--&gt;\n    &lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot;/&gt;\n&lt;/beans&gt;\n</code></pre>\n<pre><code class=\"java\">@Service\n//@Transactional //加在类上,代表类中的所有方法都添加了事务控制\npublic class AccountServiceImpl implements AccountService &#123;\n    @Autowired\n    private AccountDao accountDao;\n    @Override\n    @Transactional// 放在方法上,就是仅仅对当前方法增加了事务控制\n    public int transMoney(int from, int to, int money) &#123;\n        int rows=0;\n        rows+=accountDao.transMoney(from, 0 - money);\n        int i =1/0;\n        rows+=accountDao.transMoney(to, money);\n        return rows;\n    &#125;\n&#125;\n</code></pre>\n<p>再次测试,就算是service方法运行出现异常,自动会回滚,如果没有,那么自动提交</p>\n<p>@Transactional 注解的一些参数和参数的含义<br>@Transactional(propagation &#x3D; Propagation.REQUIRED,isolation &#x3D; Isolation.READ_UNCOMMITTED,readOnly &#x3D; true,rollbackFor &#x3D; ClassCastException.class,noRollbackFor &#x3D; NullPointerException.class,timeout &#x3D; 10)</p>\n<pre><code class=\"java\">@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)\n@Retention(RetentionPolicy.RUNTIME)\n@Inherited\n@Documented\npublic @interface Transactional &#123;\n    @AliasFor(&quot;transactionManager&quot;)\n    String value() default &quot;&quot;;\n    @AliasFor(&quot;value&quot;)\n    String transactionManager() default &quot;&quot;;\n    String[] label() default &#123;&#125;;\n    Propagation propagation() default Propagation.REQUIRED;\n    Isolation isolation() default Isolation.DEFAULT;\n    int timeout() default -1;\n    String timeoutString() default &quot;&quot;;\n    boolean readOnly() default false;\n    Class&lt;? extends Throwable&gt;[] rollbackFor() default &#123;&#125;;\n    String[] rollbackForClassName() default &#123;&#125;;\n    Class&lt;? extends Throwable&gt;[] noRollbackFor() default &#123;&#125;;\n    String[] noRollbackForClassName() default &#123;&#125;;\n&#125;\n</code></pre>\n<h2 id=\"propagation-事务的传播行为-面试\"><a href=\"#propagation-事务的传播行为-面试\" class=\"headerlink\" title=\"propagation  事务的传播行为(面试)\"></a>propagation  事务的传播行为(面试)</h2><p>多事务方法之间调用,事务是如何管理的</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">事务传播行为类型</th>\n<th align=\"center\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">PROPAGATION_REQUIRED</td>\n<td align=\"center\">如果当前没有事务，就新建一个事务，如果已经存在一个事务中，加入到这个事务中。这是最常见的选择(默认)。</td>\n</tr>\n<tr>\n<td align=\"center\">PROPAGATION_SUPPORTS</td>\n<td align=\"center\">支持当前事务，如果当前没有事务，就以非事务方式执行。</td>\n</tr>\n<tr>\n<td align=\"center\">PROPAGATION_MANDATORY</td>\n<td align=\"center\">使用当前的事务，如果当前没有事务，就抛出异常。</td>\n</tr>\n<tr>\n<td align=\"center\">PROPAGATION_REQUIRES_NEW</td>\n<td align=\"center\">新建事务，如果当前存在事务，把当前事务挂起。</td>\n</tr>\n<tr>\n<td align=\"center\">PROPAGATION_NOT_SUPPORTED</td>\n<td align=\"center\">以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。</td>\n</tr>\n<tr>\n<td align=\"center\">PROPAGATION_NEVER</td>\n<td align=\"center\">以非事务方式执行，如果当前存在事务，则抛出异常。</td>\n</tr>\n<tr>\n<td align=\"center\">PROPAGATION_NESTED</td>\n<td align=\"center\">如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与PROPAGATION_REQUIRED类似的操作。</td>\n</tr>\n</tbody></table>\n<p>如果service层  add方法调用了 addDept和addEmp两个方法</p>\n<p>&#x3D;&#x3D;<em><strong>PROPAGATION_REQUIRED</strong></em>&#x3D;&#x3D;<br>如果add方法有事务,那么addDept和addEmp就加入到add方法里的事务<br>如果add方法没有事务,那么就新建一个事务,将addDept和addEmp加入到这个新的事务中</p>\n<p>&#x3D;&#x3D;<em><strong>PROPAGATION_REQUIRES_NEW</strong></em>&#x3D;&#x3D;<br>无论add是否有事务,都建立一个新的事务,所有的方法都加入到新的事务中,add原来的事务就不用了</p>\n<p><strong>isolation 事务的隔离级别</strong></p>\n<ol>\n<li><p>DEFAULT （默认）<br>这是一个PlatfromTransactionManager默认的隔离级别，使用数据库默认的事务隔离级别。另外四个与JDBC的隔离级别相对应。<br>MySQL默认REPEATABLE_READ<br>Oracle默认READ_COMMITTED</p>\n</li>\n<li><p>READ_UNCOMMITTED （读未提交）<br>这是事务最低的隔离级别，它允许另外一个事务可以看到这个事务未提交的数据。这种隔离级别会产生脏读，不可重复读和幻像读。 </p>\n</li>\n<li><p>READ_COMMITTED （读已提交）<br>保证一个事务修改的数据提交后才能被另外一个事务读取，另外一个事务不能读取该事务未提交的数据。这种事务隔离级别可以避免脏读出现，但是可能会出现不可重复读和幻像读。 </p>\n</li>\n<li><p>REPEATABLE_READ （可重复读）<br>这种事务隔离级别可以防止脏读、不可重复读，但是可能出现幻像读。它除了保证一个事务不能读取另一个事务未提交的数据外，还保证了不可重复读。</p>\n</li>\n<li><p>SERIALIZABLE（串行化）<br>这是花费最高代价但是最可靠的事务隔离级别，事务被处理为顺序执行。除了防止脏读、不可重复读外，还避免了幻像读。</p>\n</li>\n</ol>\n<p><em>timeout 超时时间</em><br>事务一定要在多长时间之内提交,如果不提交就会回滚</p>\n<p><em>readOnly 只读事务</em><br>事务是否只能读取数据库的数据,如果为true,则不允许进行增删改</p>\n<p><em>rollbackFor 指定发生回滚的异常</em><br>当方法发生哪些异常时才会回滚</p>\n<p><em>noRollbackFor 指定不发生回滚的异常</em><br>当方法发生哪些异常时,不会回滚</p>\n<h1 id=\"面试题\"><a href=\"#面试题\" class=\"headerlink\" title=\"面试题\"></a>面试题</h1><h2 id=\"spring的循环依赖是什么？怎么解决\"><a href=\"#spring的循环依赖是什么？怎么解决\" class=\"headerlink\" title=\"spring的循环依赖是什么？怎么解决?\"></a>spring的循环依赖是什么？怎么解决?</h2><p>循环依赖：</p>\n<p>​\t指循环引用，是两个或多个Bean之间相互持有对方的引用</p>\n<p>三种依赖方式：</p>\n<p>​\t1、A依赖B ,B依赖A \t   \t\t\t\t\t——&gt; 直接依赖</p>\n<p>​\t2、A依赖C，C依赖B，B依赖A\t   ——&gt; 间接依赖</p>\n<p>​\t3、A依赖A \t\t\t\t\t\t\t\t\t\t\t——&gt; 自我依赖</p>\n<p>为什么会产生这个问题呢？</p>\n<p>​\t因为我们的 Spring 其中一大特点就是Spring IOC 、DI，Spring会自动帮我们创建对象和对对象赋值，而一旦产生循环依赖问题就会导致我们初始化的时候陷入阻塞状态，最终导致Spring容器都无法启动</p>\n<p>解决办法</p>\n<blockquote>\n<p>​\t使用缓存，缓存就是将所有缓存好的Bean，全部放在一个容器中缓存起来，并且呢，将已经完全实例化，但是没有完成赋值的Bean标记起来。然后呢，再Bean第一次实例化完成后，在扫描一次容器将没有完成赋值的Bean的属性完成赋值就可以了。(@Autowriter的对象)</p>\n<p>目前循环依赖只在属性&#x3D;&#x3D;set注入&#x3D;&#x3D;且&#x3D;&#x3D;单例&#x3D;&#x3D;的情况下才能解决</p>\n</blockquote>\n<h2 id=\"解决循环依赖问题一定要使用二级缓存吗？\"><a href=\"#解决循环依赖问题一定要使用二级缓存吗？\" class=\"headerlink\" title=\"解决循环依赖问题一定要使用二级缓存吗？\"></a>解决循环依赖问题一定要使用二级缓存吗？</h2><p>不一定，但是为什么又要设计二级缓存？假设我们只有一个缓存容器，并且缓存是直接开放给用户可以调用的，未完成赋值的Bean和已完成赋值的Bean全部放入一个容器的话，调用者就有可能会拿到未赋值的Bean，这对于用户来说是没有意义的，可能会造成空指针异常。所以基于这样的考虑，Spring将能够直接提供给用户使用的Bean放在了一级缓存中，这样的Bean称之为终态Bean；将已经完成初始化，但还不能提供给用户使用的Bean放在了二级缓存，称之为临时Bean。</p>\n<h2 id=\"为什么在二级缓存的基础上还要创建三级缓存\"><a href=\"#为什么在二级缓存的基础上还要创建三级缓存\" class=\"headerlink\" title=\"为什么在二级缓存的基础上还要创建三级缓存\"></a>为什么在二级缓存的基础上还要创建三级缓存</h2><p>Spring中的有很多的注入的Bean需要去创建代理的Bean，但是不是所有的Bean都需要去实例化之后就立马要创建代理Bean，是要等到Bean初始化之后，完成之后才能够去创建代理Bean，因此的循环依赖呢Spring又不得不去提前的创建代理Bean，如果不创建代理Bean，注入原始的Bean就会产生错误。所以Spring设计三级缓存专门存储这些代理Bean，但是每个代理Bean的Bean的创建规则他又不一样，因此呢，Spring的三级缓存中并不是直接去保存代理Bean的引用，而是保存了创建代理Bean的Factory</p>\n<h2 id=\"什么是-Spring-三级缓存？\"><a href=\"#什么是-Spring-三级缓存？\" class=\"headerlink\" title=\"什么是 Spring 三级缓存？\"></a>什么是 Spring 三级缓存？</h2><p>singletonObjects   \t\t \t\t&lt;ConCurrentHashMap&lt;&gt; \t  ——&gt;   \t 一级缓存</p>\n<p>earlySingletonObjects\t \t&lt;HashMap&lt;&gt;\t\t\t\t  \t\t\t——&gt;   \t 二级缓存</p>\n<p>singletonFactories\t\t\t\t&lt;HashMap&lt;&gt;\t\t\t\t\t\t \t ——&gt;   \t 三级缓存</p>\n<p>一级缓存就是终态缓存；二级缓存就是临时缓存；三级缓存就是代理工厂的缓存</p>\n<img data-src=\"/2022/10/07/Spring/image-20220821162504894.png\" class=\"\">\n\n\n\n\n<h2 id=\"什么情况下循环依赖无法解决？\"><a href=\"#什么情况下循环依赖无法解决？\" class=\"headerlink\" title=\"什么情况下循环依赖无法解决？\"></a>什么情况下循环依赖无法解决？</h2><p>1、多实例Bean 通过 set注入无法解决</p>\n<p>2、构造器注入注入的Bean无法解决</p>\n<p>3、单里的代理Bean通过 set注入无法解决</p>\n<p>4、设置@DependsOn注解的Bean注入无法解决</p>\n<h2 id=\"后序补充……\"><a href=\"#后序补充……\" class=\"headerlink\" title=\"后序补充…….\"></a>后序补充…….</h2>",
            "tags": [
                "框架",
                "Spring"
            ]
        },
        {
            "id": "http://example.com/2022/10/07/SpringBoot/",
            "url": "http://example.com/2022/10/07/SpringBoot/",
            "title": "SpringBoot",
            "date_published": "2022-10-06T16:00:00.000Z",
            "content_html": "<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><h2 id=\"原有Spring优缺点分析\"><a href=\"#原有Spring优缺点分析\" class=\"headerlink\" title=\"原有Spring优缺点分析\"></a>原有Spring优缺点分析</h2><p>优点：</p>\n<blockquote>\n<p>Spring是Java企业版（JAVAEE)开发的一种相对简单的方法，通过依赖注入和面向切面编程，用简单 的Java对象实现了EJB&#x3D;&#x3D;(Enterprise Java Beans技术的简称, 又被称为企业Java Beans)&#x3D;&#x3D;的功能</p>\n</blockquote>\n<p>缺点：</p>\n<ul>\n<li>虽然Spring的组件<strong>代码是轻量级</strong>的，但它的<strong>配置却是重量级</strong>的</li>\n<li><strong>依赖管理</strong>也是一件耗时耗力的事情，会产生版本不兼容的问题</li>\n</ul>\n<h2 id=\"SpringBoot概念简介\"><a href=\"#SpringBoot概念简介\" class=\"headerlink\" title=\"SpringBoot概念简介\"></a>SpringBoot概念简介</h2><blockquote>\n<p>Spring Boot是Spring公司的一个顶级项目，和Spring Framework是一个级别的。<br>Spring Boot实际上是利用Spring Framework 4 自动配置特性完成。编写项目时不需要编写xml文件。发展到现在，Spring Boot已经具有很很大的生态圈，各种主流技术已经都提供了Spring Boot的启动器。</p>\n</blockquote>\n<h2 id=\"什么是启动器\"><a href=\"#什么是启动器\" class=\"headerlink\" title=\"什么是启动器\"></a>什么是启动器</h2><blockquote>\n<p>Spring框架在项目中作用是Spring整合各种其他技术，让其他技术使用更加方便。Spring Boot的启动器<strong>实际上就是一个依赖</strong>。这个依赖中包含了整个这个技术的相关jar包，还包含了这个技术的自动配置，以前绝大多数XML配置都不需要配置了。当然了，启动器中自动配置无法实现所有内容的自动配置，在使用Spring Boot时还需要进行少量的配置（这个配置不是在xml中了，而是在properties或yml中即可）。如果是<strong>Spring自己封装的启动器</strong>的artifact id<strong>名字满足：spring-boot-starter-<em>xxxx</em></strong>，如果是<strong>第三方公司提供的启动</strong>满足：<strong><em>xxxx</em>-spring-boot-starter</strong>。以后每次使用Spring Boot整合其他技术时首先需要考虑导入启动器。</p>\n</blockquote>\n<h1 id=\"Spring-Boot优点\"><a href=\"#Spring-Boot优点\" class=\"headerlink\" title=\"Spring Boot优点\"></a>Spring Boot优点</h1><p>①　使用Spring Boot可以创建独立的Spring应用程序<br>②　在Spring Boot中<strong>直接嵌入了Tomcat</strong>、Jetty、Undertow等Web  容器，在使用SpringBoot做Web开发时<strong>不需要部署WAR文件</strong><br>③　通过提供自己的启动器(Starter)依赖，简化项目构建配置<br>④　尽量的自动配置Spring和第三方库<br>⑤　绝对没有代码生成，也不需要XML配置文件</p>\n<h1 id=\"Spring-Boot的核心\"><a href=\"#Spring-Boot的核心\" class=\"headerlink\" title=\"Spring Boot的核心\"></a>Spring Boot的核心</h1><p><strong>起步依赖</strong>：起步依赖本质上是一个Maven项目对象模型（Project Object Model，POM），定义了对其他库的传递依赖，这些东西加在一起即支持某项功能。 简单的说，起步依赖就是将具备某种功能的坐标打包到一起，并提供一些默认的功能。</p>\n<p><strong>自动配置</strong> ：Spring Boot的自动配置是一个运行时（更准确地说，是应用程序启动时）的过程，考虑了众多因素，才决定 Spring配置应该用哪个，不该用哪个。该过程是Spring自动完成的。</p>\n<h1 id=\"启动原理分析\"><a href=\"#启动原理分析\" class=\"headerlink\" title=\"启动原理分析\"></a>启动原理分析</h1><img data-src=\"/2022/10/07/SpringBoot/%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE.jpg\" class=\"\">\n\n\n\n\n<pre><code class=\"java\">static class Registrar implements ImportBeanDefinitionRegistrar, DeterminableImports &#123;\n    @Override\n    public void registerBeanDefinitions(AnnotationMetadata metadata, BeanDefinitionRegistry registry) &#123;\n        register(registry, new PackageImports(metadata).getPackageNames().toArray(new String[0]));\n    &#125;\n    @Override\n    public Set&lt;Object&gt; determineImports(AnnotationMetadata metadata) &#123;\n        return Collections.singleton(new PackageImports(metadata));\n    &#125;\n&#125;\n</code></pre>\n<p>将配置类@SpringBootApplication标注的类所在包及下面所有子包里的所有组件扫描到spring容器</p>\n<pre><code class=\"java\">protected List&lt;String&gt; getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes) &#123;\n        List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(getSpringFactoriesLoaderFactoryClass(),\n                getBeanClassLoader());\n        Assert.notEmpty(configurations, &quot;No auto configuration classes found in META-INF/spring.factories. If you &quot;\n                + &quot;are using a custom packaging, make sure that file is correct.&quot;);\n        return configurations;\n    &#125;\n</code></pre>\n<p><strong>通过 getCandidateConfigurations读取自带的配置文件，得到他们的全路径名，通过反射创建他们</strong></p>\n<h1 id=\"异常处理和拦截器\"><a href=\"#异常处理和拦截器\" class=\"headerlink\" title=\"异常处理和拦截器\"></a>异常处理和拦截器</h1><p><strong>均与SpringMVC中处理一致</strong></p>\n<h1 id=\"分页\"><a href=\"#分页\" class=\"headerlink\" title=\"分页\"></a>分页</h1><p>主要参数：</p>\n<p>当前页 、一页n个(每页的数量)、 总条数</p>\n<h2 id=\"属性介绍\"><a href=\"#属性介绍\" class=\"headerlink\" title=\"属性介绍\"></a>属性介绍</h2><table>\n<thead>\n<tr>\n<th align=\"center\">属性名</th>\n<th align=\"center\">类型</th>\n<th align=\"center\">默认值</th>\n<th align=\"center\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">overflow</td>\n<td align=\"center\">boolean</td>\n<td align=\"center\">false</td>\n<td align=\"center\">溢出总页数后是否进行处理<br/>(默认不处理,参见 <code>插件#continuePage</code> 方法)</td>\n</tr>\n<tr>\n<td align=\"center\">maxLimit</td>\n<td align=\"center\">Long</td>\n<td align=\"center\"></td>\n<td align=\"center\">单页分页条数限制<br/>(默认无限制,参见 <code>插件#handlerLimit</code> 方法)</td>\n</tr>\n<tr>\n<td align=\"center\">dbType</td>\n<td align=\"center\">DbType</td>\n<td align=\"center\"></td>\n<td align=\"center\">数据库类型<br/>(根据类型获取应使用的分页方言,参见 <code>插件#findIDialect</code> 方法)</td>\n</tr>\n<tr>\n<td align=\"center\">dialect</td>\n<td align=\"center\">IDialect</td>\n<td align=\"center\"></td>\n<td align=\"center\">方言实现类<br/>(参见 <code>插件#findIDialect</code> 方法)</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>建议单一数据库类型的均设置 dbType</p>\n</blockquote>\n<pre><code class=\"java\">    @GetMapping(&quot;/test&quot;)\n    public Response test()&#123;\n        Page&lt;Produce&gt; producePage = new Page&lt;&gt;(1,1);\n        Page&lt;Produce&gt; page = produceService.page(producePage);\n        System.out.println(producePage == page);\n        List&lt;Produce&gt; records = page.getRecords();\n        for (Produce record : records) &#123;\n            System.out.println(record);\n        &#125;\n        return new Response&lt;&gt;(records, ResultEnum.SUCCESS);\n    &#125;\n</code></pre>\n<img data-src=\"/2022/10/07/SpringBoot/656c18aaaf9ed11fee9b9f1576cc840f.png\" class=\"\">\n\n\n<p>默认是会查询总条数，都有get、set方法，可以根据自己的需求设置（点开Page类看看）</p>\n<img data-src=\"/2022/10/07/SpringBoot/d0e0280ca8a9d46a4a41c4a1de89ab3c.png\" class=\"\">\n\n\n\n\n\n\n\n\n\n\n<h1 id=\"项目打包和部署\"><a href=\"#项目打包和部署\" class=\"headerlink\" title=\"项目打包和部署\"></a>项目打包和部署</h1><h2 id=\"打包\"><a href=\"#打包\" class=\"headerlink\" title=\"打包\"></a>打包</h2><p>SpringBoot项目打包在linux服务器中运行:<br>    ①jar类型项目会打成jar包:<br>    jar类型项目使用SpringBoot打包插件打包时，会在打成的jar中内置一个tomcat的jar。所以我们可以使用jdk直接运行该jar项目可，jar项目中有一个功能，将功能代码放到其内置的tomcat中运行。我们直接使用浏览器访问即可。<br>    ②war类型项目会打成war包:<br>    在打包时需要将内置的tomcat插件排除，配置servlet的依赖。将war正常的放到tomcat服务器中运行即可。</p>\n<img data-src=\"/2022/10/07/SpringBoot/image-20220718170542347.png\" class=\"\">\n\n\n<h2 id=\"部署\"><a href=\"#部署\" class=\"headerlink\" title=\"部署\"></a>部署</h2><p><strong>注：这里是部署到Tomcat（war），jar直接编译启动</strong></p>\n<h3 id=\"第一步：\"><a href=\"#第一步：\" class=\"headerlink\" title=\"第一步：\"></a>第一步：</h3><pre><code>在部署到Tomcat 之前我们要将我们项目中的Tomcat(==它在Web中==)去掉，但是我们在项目中又有可能要使用他提供的jar包 HttpServlet 之类的，所以我们还需要再将它手动导入，但是他不需要他打包。\n</code></pre>\n<pre><code class=\"xml\">&lt;!--配置SpringBoot的web启动器--&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;\n    &lt;!--排除web启动中自动依赖的tomcat插件--&gt;\n    &lt;exclusions&gt;\n        &lt;exclusion&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;\n        &lt;/exclusion&gt;\n    &lt;/exclusions&gt;\n&lt;/dependency&gt;\n\n&lt;!--\n    手动依赖tomcat插件，但是表明项目打包时该依赖不会被打进去，目的主要是保证开发阶段本地SpringBoot\n    项目可以正常运行\n--&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;\n    &lt;!--打包的时候可以不用包进去，别的设施会提供。事实上该依赖理论上可以参与编译，测试，运行等周期。\n        相当于compile，但是打包阶段做了exclude操作--&gt;\n    &lt;scope&gt;provided&lt;/scope&gt;\n&lt;/dependency&gt;\n</code></pre>\n<h3 id=\"第二步：\"><a href=\"#第二步：\" class=\"headerlink\" title=\"第二步：\"></a>第二步：</h3><p>SpringBoot的<strong>启动类继承SpringBootServletInitializer</strong>，并<strong>重写configure</strong></p>\n<pre><code class=\"java\">@SpringBootApplication\npublic class MyApplication extends SpringBootServletInitializer &#123;\n    //重写配置方法\n    @Override\n    protected SpringApplicationBuilder configure(SpringApplicationBuilder application) &#123;\n        return application.sources(MyApplication.class);\n    &#125;\n    public static void main(String[] args) &#123;\n        //启动SpringBoot\n        SpringApplication.run(MyApplication.class,args);\n    &#125;\n&#125;\n</code></pre>\n<p>使用package命令打包项目，并将war包放到tomcat下的webapps下，启动tomcat即可。</p>\n<h3 id=\"注：\"><a href=\"#注：\" class=\"headerlink\" title=\"注：\"></a>注：</h3><ul>\n<li>部署到tomcat之后我们的URL就会变化，tomcat会自动编译war包，我们的<strong>项目名和war包同名</strong>，所以不想改变提前修改</li>\n<li><strong>端口号也是tomcat的端口号</strong>（tomcat&#x2F;conf&#x2F;server.xml）</li>\n</ul>\n<h1 id=\"面试题\"><a href=\"#面试题\" class=\"headerlink\" title=\"面试题\"></a>面试题</h1><h2 id=\"SpringBoot约定大于配置理解\"><a href=\"#SpringBoot约定大于配置理解\" class=\"headerlink\" title=\"SpringBoot约定大于配置理解\"></a>SpringBoot约定大于配置理解</h2><p>约定大于配置是一种开发原则，就是减少人为的配置，直接用默认的配置就能获得我们想要的结果。<br>　　SpringBoot的约定大于配置，按我的理解是：对比SpringMVC，需要在web.xml里面配置前端控制器，还需要在核心配置文件（*-servlet.xml）中配置视图解析器啥的，更要配置第三方的Tomcat服务器。而SpringBoot就不需要我们配置这些，他内嵌了Tomcat服务器，我们只需要在Maven配置文件（Pom.xml）里面导入SpringMVC所需要的依赖就可以了。<br>　　这就是SpringBoot的优势，在传统所需要配置的地方，SpringBoot都进行了约定（配置好了），开发人员能配置得更少，更直接地开发项目，写业务逻辑代码。<br>spring boot和maven的约定大于配置体现 点：<br>　　1.maven的目录文件结构<br>　　1）默认有resources文件夹,存放资源配置文件。src-main-resources,src-main-java<br>默认的编译生成的类都在targetwen。<br>　　2）默认有target文件夹，将生成class文件盒编程生成的jar存放在target文件夹下</p>\n<p>2.spring boot默认的配置文件必须是，也只能是application.命名的yml文件或者properties文件，且唯一</p>\n<p>1）spring boot默认只会去src-main-resources文件夹下去找application配置文件</p>\n<p>这个问题呢，我从四个方面来回答。</p>\n<p>首先，约定优于配置是一种软件设计的范式，它的核心思想，是减少软件开发人员对于配置项的。从而让开发人员更加聚焦在业务逻辑上</p>\n<p>第二个呢，Spring boot就是约定优于配置这一理念下的产物，它类似于spring框架下的一个脚手架，通过spring boot，我们可以快速开发基于spring生态下的应用程序。基于传统的spring框架开发web应用的时候，我们需要做很多和业务无关，并且只需要做一次的配置项，比如</p>\n<ol>\n<li><p>管理架包的依赖</p>\n</li>\n<li><p>web.xml的维护</p>\n</li>\n<li><p>spring MVC中的一个叫 Dispatch-Servlet.x ml 配置项的一个维护</p>\n</li>\n<li><p>应用需要自己手动去部署到web容器</p>\n</li>\n<li><p>第三方组件集成到spring IOC容器中，我们需要做配置项的维护</p>\n</li>\n</ol>\n<p>而在SpringBoot中，我们不再需要去做这些繁琐的配置，因为SpringBoot已经帮我们自动完成了，而完成这样一个动作的前提就是基于&#x3D;&#x3D;约定优于配置&#x3D;&#x3D;这样一个思想。</p>\n<p>最后呢，Spring boot约定优于配置的体现有很多，</p>\n<p>比如第一个spring boat start启动依赖，它能够帮助我们管理所有的jar包版本。</p>\n<p>第二个，如果当前的应用依赖了web这样一个 jar 包，那么spring boot会自动内置Tomcat，他们看着容器来去运行web应用，我们不再需要去单独进行应用部署。</p>\n<p>第三，Spring boot的自动装配机制的实现中，通过扫描约定路径下的spring.factory文件去进行识别配置类，从而去实现类的自动装载</p>\n<p>第四，Spring boot？默认会加载resource目录下的application.property文件。总的来说啊，约定优于配置呢，是一个比较常见的软件设计思想，它的核心本质都是为了去更加高效，以及更加便捷的去实现软件系统的开发和维护。</p>\n<p><strong>自我总结：</strong></p>\n<p>​\t约定大于配置，不是说我们要设定啥，原来规定的是什么就不能改变，不是这个意思。他真正的意思是说当我们配置某个选项时，springboot会自动帮我们加载可能会与其相关的配置，就好比我们应用依赖了 web，那么spring boot会自动内置Tomcat，他们看着容器来去运行web应用，我们不再需要去单独进行应用部署。</p>\n<p>​\t总的来说啊，约定优于配置呢，是一个比较常见的软件设计思想，它的核心本质都是为了去更加高效，以及更加便捷的去实现软件系统的开发和维护。</p>\n",
            "tags": [
                "框架",
                "Spring",
                "SpringBoot"
            ]
        },
        {
            "id": "http://example.com/2022/10/07/SpringMVC/",
            "url": "http://example.com/2022/10/07/SpringMVC/",
            "title": "SpringMVC",
            "date_published": "2022-10-06T16:00:00.000Z",
            "content_html": "<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><img data-src=\"/2022/10/07/SpringMVC/image-20220716212203883.png\" class=\"\">\n\n\n<p>M   model      模型层   DAO封装        &gt;&gt;&gt; Mybatis<br>V    view         视图层   html css js  jsp<br>C    controller 控制层   Servlet封装    &gt;&gt;&gt; springMVC </p>\n<p>SpringMVC是spring为展现层提供的基于MVC设计理念的优秀WEB框架,是目前最主流的MVC框架之一<br>SpringMVC通过一套注解,可以让普通的JAVA类成为contrllor控制器,无需继承Servlet,实现了控制层和Servlet之间的解耦<br>SpringMVC支持Rest风格的URL写法<br>SpringMVC采用了松耦合,可热插的主键结构,比其他的框架更具扩展性和灵活性</p>\n<h1 id=\"执行流程\"><a href=\"#执行流程\" class=\"headerlink\" title=\"执行流程\"></a>执行流程</h1><img data-src=\"/2022/10/07/SpringMVC/image-20220717190437596.png\" class=\"\">\n\n\n<img data-src=\"/2022/10/07/SpringMVC/image-20220717190445738.png\" class=\"\">\n\n\n<p>1DispatcherServlet：前端控制器<br>用户请求到达前端控制器，它就相当于 mvc 模式中的 c，dispatcherServlet 是整个流程控制的中心，由 它调用其它组件处理用户的请求，dispatcherServlet 的存在降低了组件之间的耦合性。</p>\n<p><strong>2 HandlerMapping：处理器映射器</strong><br>HandlerMapping 负责根据用户请求找到 Handler 即处理器，SpringMVC 提供了不同的映射器实现不同的 映射方式，例如：配置文件方式，实现接口方式，注解方式等。</p>\n<p>3 Handler：处理器 (自己定义的Controller处理单元)<br>它就是我们开发中要编写的具体业务控制器。由 DispatcherServlet 把用户请求转发到 Handler。由 Handler 对具体的用户请求进行处理。</p>\n<p><strong>4 HandlAdapter：处理器适配器</strong><br>通过 HandlerAdapter 对处理器进行执行，这是适配器模式的应用，通过扩展适配器可以对更多类型的处理器进行执行</p>\n<p>5 View Resolver：视图解析器<br>View Resolver 负责将处理结果生成 View 视图，View Resolver 首先根据逻辑视图名解析成物理视图名 即具体的页面地址，再生成 View 视图对象，最后对 View 进行渲染将处理结果通过页面展示给用户。</p>\n<p>6 View：视图<br>SpringMVC 框架提供了很多的 View 视图类型的支持，包括：jstlView、freemarkerView、pdfView等。我们最常用的视图就是 jsp。 一般情况下需要通过页面标签或页面模版技术将模型数据通过页面展示给用户，需要由程序员根据业务需求开 发具体的页面。</p>\n<p>7 <span class=\"exturl\" data-url=\"bXZjOmFubm90YXRpb24tZHJpdmVu\">mvc:annotation-driven</span>说明<br>在 SpringMVC 的各个组件中，处理器映射器、处理器适配器、视图解析器称为 SpringMVC 的三大组件。<br>使 用 <span class=\"exturl\" data-url=\"bXZjOmFubm90YXRpb24tZHJpdmVu\">mvc:annotation-driven</span> 自动加载 RequestMappingHandlerMapping （处理映射器） 和 RequestMappingHandlerAdapter （ 处 理 适 配 器 ） ， 可 用 在 SpringMVC.xml 配 置 文 件 中 使 用 <span class=\"exturl\" data-url=\"bXZjOmFubm90YXRpb24tZHJpdmVu\">mvc:annotation-driven</span>替代注解处理器和适配器的配置。</p>\n<p>HandlerMapping的实现类的作用<br>实现类RequestMappingHandlerMapping，它会处理@RequestMapping 注解，并将其注册到请求映射表中。</p>\n<p>HandlerAdapter的实现类的作用<br>实现类RequestMappingHandlerAdapter，则是处理请求的适配器，确定调用哪个类的哪个方法，并且构造方法参数，返回值。</p>\n<p>当配置了mvc:annotation-driven&#x2F;后，Spring就知道了我们启用注解驱动。然后Spring通过context:component-scan&#x2F;标签的配置，会自动为我们将扫描到的@Component，@Controller，@Service，@Repository等注解标记的组件注册到工厂中，来处理我们的请求,这个时候接收返回json数据、参数验证、统一异常等功能。</p>\n<h1 id=\"重要注解\"><a href=\"#重要注解\" class=\"headerlink\" title=\"重要注解\"></a>重要注解</h1><h2 id=\"1、RequestMapping\"><a href=\"#1、RequestMapping\" class=\"headerlink\" title=\"1、RequestMapping\"></a>1、RequestMapping</h2><p>紧耦合方式(了解)<br>DispatcherServlet中的service方法直接将此次请求的request对象传递给调用的单元方法即可。同时在单元方法上声明形参HttpServletRequest来接收request实参即可。<br><strong>解耦合方式(熟练)</strong><br>DispatcherServlet在其service方法中将请求数据根据需求从request对象中获取出来后，将数据直接传递给对应的单元方法使用。同时在单元方法上直接声明对应的形参接收请求数据即可。在单元方法上声明形参来接收请求数据时，形参名必须和请求数据的键名一致，DispatcherServlet会将调用单元方法的形参名作为请求数据的键名获取请求数据，然后传递给单元方法。</p>\n<pre><code class=\"java\">@RestController\npublic class TestDataController &#123;\n    /*紧耦合方式参数注入\n    * 使用传统的HttpServletRequest对象获取参数  javax.servlet\n    * */\n    @RequestMapping(&quot;/getParamByRequest.do&quot;)\n    public String getParam1(HttpServletRequest req, HttpServletResponse resp)&#123;\n        String username = req.getParameter(&quot;username&quot;);\n        String password = req.getParameter(&quot;password&quot;);\n        System.out.println(&quot;username:&quot;+username+&quot;   password:&quot;+password);\n        return &quot;getParamSuccess&quot;;\n    &#125;\n    /*解耦合方式参数注入\n    * HttpServletRequest对象获取参数 通过SpringMVC框架功能,自动转换参数\n    * 处理单元参数列表中参数名必须和请求中的参数名一致\n                                        * 如不一致,可以通过@RequestParma注解进行转换\n    * */\n    @RequestMapping(&quot;/getParamByArgName.do&quot;)\n    public String getParam2(String username,@RequestParam(&quot;pwd&quot;) int password)&#123;\n        System.out.println(&quot;username:&quot;+username+&quot;   password:&quot;+password);\n        return &quot;getParamSuccess&quot;;\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"2、PathVariable注解和RESTful风格的支持\"><a href=\"#2、PathVariable注解和RESTful风格的支持\" class=\"headerlink\" title=\"2、PathVariable注解和RESTful风格的支持\"></a>2、PathVariable注解和RESTful风格的支持</h2><p><strong>普通形式的url</strong></p>\n<pre><code class=\"java\">*/contextPath/aaa.do\n*/contextPath/aaa.jsp\n*/contextPath/aaa.html\n*/contextPath/css/aaa.css\n*/contextPath/js/aaa.js\n*/contextPath/aaa.do?id=10&amp;username=root\n</code></pre>\n<p><strong>restFul风格的url</strong></p>\n<pre><code class=\"java\">*/contextPath/aaa/10/root\n*/contextPath/aaa\n</code></pre>\n<pre><code class=\"java\">@Controller\npublic class PathController &#123;\n    @RequestMapping(&quot;/testPathVariable/&#123;id&#125;/&#123;username&#125;&quot;)\n    public String testPathVariable(@PathVariable(&quot;id&quot;) Integer id, @PathVariable(&quot;username&quot;) String username)&#123;\n        System.out.println(&quot;id:&quot;+id);\n        System.out.println(&quot;username:&quot;+username);\n        System.out.println(&quot;testPathVariable1&quot;);\n        return &quot;success&quot;;\n    &#125;\n&#125;\n</code></pre>\n<img data-src=\"/2022/10/07/SpringMVC/image-20220717191056216.png\" class=\"\">\n\n\n<img data-src=\"/2022/10/07/SpringMVC/image-20220717191104583-1661419340091.png\" class=\"\">\n\n\n\n\n\n\n<h1 id=\"响应处理\"><a href=\"#响应处理\" class=\"headerlink\" title=\"响应处理\"></a>响应处理</h1><img data-src=\"/2022/10/07/SpringMVC/image-20220717191212189-1661419342477.png\" class=\"\">\n\n\n\n\n<p>1、单元方法返回值为void</p>\n<img data-src=\"/2022/10/07/SpringMVC/image-20220717191318663-1661419344199.png\" class=\"\">\n\n\n<blockquote>\n<p>在SpringMVC中如果对于当前的控制单元，没有写对应的返回值，这个时候<strong>SpringMVC就会找和自己控制单元名称一致的页面展示</strong>，<strong>如果没有配置视图解析器的前缀和后缀是没有产生404</strong>,需要注意控制单元仍然可以进。</p>\n</blockquote>\n<p>2、转发和重定向ServletAPI 实现</p>\n<pre><code class=\"java\">@RequestMapping(&quot;demo1&quot;)\n    public void testDemo1(HttpServletRequest request, HttpServletResponse response) throws Exception &#123;\n        // 请求转发\n        //request.getRequestDispatcher(&quot;/forward.jsp&quot;).forward(request,response);\n        // 响应重定向\n        response.sendRedirect(request.getContextPath()+&quot;/redirect.jsp&quot;);\n    &#125;\n</code></pre>\n<blockquote>\n<p>单元方法的返回值类型设置void。因为使用response对象在单元方法中直接对此次请求进行了响应，不再通过DispatcherServlet了，既然已经响应了，就不需要再给DispatcherServlet返回值了。在单元方法上声明HttpServletResponse形参，来接收此次请求的response对象。</p>\n</blockquote>\n<p>3、使用forward关键字完成响应</p>\n<pre><code class=\"java\"> /*\n    * 返回字符串告诉DispatcherServlet跳转的路径\n    * 在路径之前放上一个forward: 关键字,就是请求转发\n    * 如果路径前的关键字是forward,那么可以省略不写\n    * */\n    @RequestMapping(&quot;demo2&quot;)\n    public String testDemo2() throws Exception &#123;\n        //return &quot;forward:/forwardPage.jsp&quot;;\n        return &quot;/forwardPage.jsp&quot;;\n    &#125;\n</code></pre>\n<p>使用通过单元方法的返回值来告诉DispatcherServlet请求转发指定的资源,如果是请求转发，<strong>forward关键字可以<em>省略不写</em>的</strong></p>\n<p>4、使用redirect关键字完成响应</p>\n<pre><code class=\"java\">/*\n     * 返回字符串告诉DispatcherServlet跳转的路径\n     * 在路径之前放上一个redirect: 关键字,就是重定向\n     * 如果路径前的关键字是redirect,那么不可以省略\n     * /表示当前项目下.这里不需要项目的上下文路径\n     * */\n    @RequestMapping(&quot;demo3&quot;)\n    public String testDemo3() throws Exception &#123;\n        return &quot;redirect:/redirectPage.jsp&quot;;\n    &#125;\n</code></pre>\n<p>使用通过单元方法的返回值来告诉DispatcherServlet重定向指定的资源，注意这个<strong>redirect关键字<em>不可以省去</em></strong></p>\n<p>5、使用View视图转发和重定向</p>\n<pre><code class=\"java\"> @RequestMapping(&quot;demo4&quot;)\n    public View testDemo4(HttpServletRequest req)   &#123;\n        View  view =null;\n        // 请求转发\n        //view =new InternalResourceView(&quot;/forwardPage.jsp&quot;);\n        // 重定向\n        view=new RedirectView(req.getContextPath()+&quot;/redirectPage.jsp&quot;);\n        return view;\n    &#125;\n</code></pre>\n<blockquote>\n<p>RedirectView中所做的操作，最终的实现是在renderMergedOutputModel中完成实现的，简单来说RedirectView实现了链接的重定向，并且将数据保存到FlashMap中，这样在跳转后的链接中可以获取一些数据.</p>\n</blockquote>\n<p>6、使用ModelAndView转发重定向</p>\n<pre><code class=\"java\">@RequestMapping(&quot;demo5&quot;)\n    public ModelAndView testDemo5(HttpServletRequest req)   &#123;\n        ModelAndView mv=new ModelAndView();\n        // 请求转发\n        //mv.setViewName(&quot;forward:/forwardPage.jsp&quot;);\n        //mv.setView(new InternalResourceView(&quot;/forwardPage.jsp&quot;));\n        // 重定向\n        //mv.setViewName(&quot;redirect:/redirectPage.jsp&quot;);\n        mv.setView(new RedirectView(req.getContextPath()+&quot;/redirectPage.jsp&quot;));\n        return mv;\n    &#125;\n</code></pre>\n<p>​\tModelAndView中的Model代表模型，View代表视图，这个名字就很好地解释了该类的作用。业务处理器调用模型层处理完用户请求后，把结果数据存储在该类的model属性中，把要返回的视图信息存储在该类的view属性中，然后让该ModelAndView返回该Spring MVC框架。</p>\n<h1 id=\"作用域传参\"><a href=\"#作用域传参\" class=\"headerlink\" title=\"作用域传参\"></a>作用域传参</h1><img data-src=\"/2022/10/07/SpringMVC/image-20220717191751516-1661419352934.png\" class=\"\">\n\n\n<blockquote>\n<p>PageContext对象</p>\n</blockquote>\n<p>作用域范围:当前jsp页面内有效</p>\n<blockquote>\n<p>request对象</p>\n</blockquote>\n<p>作用域范围:一次请求内。</p>\n<p>作用: 解决了一次请求内的资源的数据共享问题</p>\n<blockquote>\n<p>session对象</p>\n</blockquote>\n<p>作用域范围:一次会话内有效。</p>\n<p>说明:浏览器不关闭,并且后台的session不失效，在任意请求中都可以获取到同一个session对象。</p>\n<p>作用:解决了一个用户不同请求的数据共享问题。</p>\n<blockquote>\n<p>application(ServletContext)对象</p>\n</blockquote>\n<p>作用域范围:整个项目内有效。</p>\n<p>特点:一个项目只有一个，在服务器启动的时候即完成初始化创建无论如何获取都是同一个项目。</p>\n<p>作用:解决了不同用户的数据共享问题。</p>\n<h1 id=\"拦截器\"><a href=\"#拦截器\" class=\"headerlink\" title=\"拦截器\"></a>拦截器</h1><h2 id=\"引入\"><a href=\"#引入\" class=\"headerlink\" title=\"引入\"></a>引入</h2><blockquote>\n<p>&#x3D;&#x3D;过滤器的作用是保护请求的服务器资源，在请求资源被执行之前&#x3D;&#x3D;，如果请求地址符合拦截范围，则会先执行过滤器。&#x3D;&#x3D;过滤器的执行时机，是在Servlet之前执行的&#x3D;&#x3D;。但是在使用了SpringMVC后，Servlet只有一个了，也就是DisptcherServlet。那么，如果我们仍然使用过滤器来完成请求的拦截，因为过滤器是在Servlet之前执行的，就会造成，&#x3D;&#x3D;过滤器会拦截DispatcherServlet所有的请求&#x3D;&#x3D;。那么，如果我们有&#x3D;&#x3D;部分请求不想被拦截&#x3D;&#x3D;，怎么办？</p>\n</blockquote>\n<h2 id=\"拦截器使用\"><a href=\"#拦截器使用\" class=\"headerlink\" title=\"拦截器使用\"></a>拦截器使用</h2><img data-src=\"/2022/10/07/SpringMVC/image-20220717191927439-1661419356594.png\" class=\"\">\n\n\n<p>Spring MVC中的拦截器（Interceptor）类似于Servlet中的过滤器（Filter），它主要用于拦截用户请求并作相应的处理。例如通过拦截器可以进行权限验证、记录请求信息的日志、判断用户是否登录等。<br>    要使用Spring MVC中的拦截器，就需要对拦截器类进行定义和配置。通常拦截器类可以通过两种方式来定义。<br>    1.通过实现HandlerInterceptor接口，或继承HandlerInterceptor接口的实现类（如HandlerInterceptorAdapter）来定义。<br>    2.通过实现WebRequestInterceptor接口，或继承WebRequestInterceptor接口的实现类来定义。</p>\n<h2 id=\"拦截器和过滤器的区别\"><a href=\"#拦截器和过滤器的区别\" class=\"headerlink\" title=\"拦截器和过滤器的区别\"></a>拦截器和过滤器的区别</h2><ol>\n<li><p>拦截器SpringMVC的，而过滤器是servlet的。\t</p>\n</li>\n<li><p>拦截器不依赖与servlet容器,由spring容器初始化，过滤器依赖与servlet容器,由servlet容器初始化。. </p>\n</li>\n<li><p>拦截器只能对action请求起作用，而过滤器则可以对几乎所有的请求起作用。</p>\n</li>\n<li><p>拦截器可以访问action上下文、值栈里的对象，而过滤器不能访问。</p>\n</li>\n<li><p>在action的生命周期中，拦截器可以多次被调用，而过滤器只能在容器初始化时被调用一次。</p>\n</li>\n<li><p>拦截器可以获取IOC容器中的各个bean，而过滤器就不太方便，这点很重要，在拦截器里注入一个service，可以调用业务逻辑。</p>\n</li>\n</ol>\n<pre><code class=\"java\">public class MyInterceptor implements HandlerInterceptor &#123;\n    @Override\n    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;\n        /*在请求到达我们定义的handler之前工作的*/\n        System.out.println(&quot;MyInterceptor preHandle&quot;);\n        /*返回的是true,代表放行,可以继续到达handler*/\n        return true;\n    &#125;\n    @Override\n    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123;\n        System.out.println(&quot;MyInterceptor postHandle&quot;);\n        /*handler 处理单元返回ModelAndView 时候进行 拦截*/\n    &#125;\n    @Override\n    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123;\n        /*\n        页面渲染完毕,但是还没有给浏览器响应数据的时候\n         */\n        System.out.println(&quot;MyInterceptor afterCompletion&quot;);\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"多个拦截器执行顺序\"><a href=\"#多个拦截器执行顺序\" class=\"headerlink\" title=\"多个拦截器执行顺序\"></a>多个拦截器执行顺序</h2><p>多个拦截器同时存在时,执行的顺序由配置顺序决定. 先配置谁, 谁就先执行.多个拦截器可以理解为拦截器栈, 先进后出(后进先出), 如图所示:</p>\n<img data-src=\"/2022/10/07/SpringMVC/image-20220717192103889-1661419360360.png\" class=\"\">\n\n\n\n\n<h1 id=\"异常处理\"><a href=\"#异常处理\" class=\"headerlink\" title=\"异常处理\"></a>异常处理</h1><h2 id=\"SpringMVC异常简介\"><a href=\"#SpringMVC异常简介\" class=\"headerlink\" title=\"SpringMVC异常简介\"></a>SpringMVC异常简介</h2><p>​\t系统中异常包括两类：预期异常(检查型异常)和运行时异常 RuntimeException，前者通过捕获异常从而获取异常信息， 后者主要通过规范代码开发、测试通过手段减少运行时异常的发生</p>\n<h2 id=\"具体实现\"><a href=\"#具体实现\" class=\"headerlink\" title=\"具体实现\"></a>具体实现</h2><h3 id=\"1使用-ExceptionHandler注解处理异常\"><a href=\"#1使用-ExceptionHandler注解处理异常\" class=\"headerlink\" title=\"1使用@ExceptionHandler注解处理异常\"></a>1使用@ExceptionHandler注解处理异常</h3><p>缺点：只能处理当前Controller中的异常。</p>\n<pre><code class=\"java\"> @ExceptionHandler(value =&#123;ArithmeticException.class,NullPointerException.class&#125; )\n    public ModelAndView handelException()&#123;\n        ModelAndView mv =new ModelAndView();\n        mv.setViewName(&quot;error1.jsp&quot;);\n        return mv;\n    &#125;\n</code></pre>\n<h3 id=\"2使用：-ControllerAdvice-ExceptionHandler\"><a href=\"#2使用：-ControllerAdvice-ExceptionHandler\" class=\"headerlink\" title=\"2使用：@ControllerAdvice+@ExceptionHandler\"></a>2使用：@ControllerAdvice+@ExceptionHandler</h3><p>此处优先级低于局部异常处理器</p>\n<pre><code class=\"java\">@ControllerAdvice\npublic class GloableExceptionHandler1 &#123;\n    @ExceptionHandler(value =&#123;ArithmeticException.class,NullPointerException.class&#125; )\n    public ModelAndView handelException()&#123;\n        ModelAndView mv =new ModelAndView();\n        mv.setViewName(&quot;error1.jsp&quot;);\n        return mv;\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"3使用：SimpleMappingExceptionResolver\"><a href=\"#3使用：SimpleMappingExceptionResolver\" class=\"headerlink\" title=\"3使用：SimpleMappingExceptionResolver\"></a>3使用：SimpleMappingExceptionResolver</h3><pre><code class=\"java\">/**\n * 全局异常\n */\n  @Configuration\n  public class GloableException2 &#123;\n    @Bean\n    public SimpleMappingExceptionResolver getSimpleMappingExceptionResolver()&#123;\n        SimpleMappingExceptionResolver resolver = new SimpleMappingExceptionResolver();\n        Properties prop = new Properties();\n        prop.put(&quot;java.lang.NullPointerException&quot;,&quot;error1.jsp&quot;);\n        prop.put(&quot;java.lang.ArithmeticException&quot;,&quot;error2.jsp&quot;);\n        resolver.setExceptionMappings(prop);\n        return resolver;\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"4自定义的HandlerExceptionResolver\"><a href=\"#4自定义的HandlerExceptionResolver\" class=\"headerlink\" title=\"4自定义的HandlerExceptionResolver\"></a>4自定义的HandlerExceptionResolver</h3><pre><code class=\"java\">/**\n * 全局异常\n * HandlerExceptionResolve\n */\n  @Configuration\n  public class GloableException3 implements HandlerExceptionResolver &#123;\n    @Override\n    public ModelAndView resolveException(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e) &#123;\n        ModelAndView mv = new ModelAndView();\n        if(e instanceof NullPointerException)&#123;\n                mv.setViewName(&quot;error1&quot;);\n        &#125;\n        if(e instanceof ArithmeticException)&#123;\n                mv.setViewName(&quot;error2&quot;);\n        &#125;\n        mv.addObject(&quot;msg&quot;,e);\n        return mv;\n    &#125;&#125;\n</code></pre>\n<h1 id=\"其他注解\"><a href=\"#其他注解\" class=\"headerlink\" title=\"其他注解\"></a>其他注解</h1><h2 id=\"RequestBody\"><a href=\"#RequestBody\" class=\"headerlink\" title=\"@RequestBody\"></a>@RequestBody</h2><p>作用：</p>\n<p>​\t用于获取请求体json格式的字符串内容。直接使用得到是 key&#x3D;value&amp;key&#x3D;value…结构的数据，get 请求方式不适用。</p>\n<p>属性：</p>\n<p>​\trequired：是否必须有请求体。默认值是:true。当取值为 true 时,get 请求方式会报错。如果取值 为 false，get 请求得到是null。</p>\n<h2 id=\"CrossOrigin\"><a href=\"#CrossOrigin\" class=\"headerlink\" title=\"@CrossOrigin\"></a>@CrossOrigin</h2><p>作用：</p>\n<p>​\t解决ajax请求之间的跨域问题</p>\n<p>属性:</p>\n<p>origins  ： 允许可访问的域列表IP</p>\n<p>maxAge：准备响应前的缓存持续的最大时间（以秒为单位）。</p>\n",
            "tags": [
                "框架",
                "Spring",
                "SpringMVC"
            ]
        },
        {
            "id": "http://example.com/2022/10/07/SpringSecurity/",
            "url": "http://example.com/2022/10/07/SpringSecurity/",
            "title": "SpringSecurity",
            "date_published": "2022-10-06T16:00:00.000Z",
            "content_html": "<hr/>\n<p style=\"font-size:70px; color:red;background-color:66FF66\">Spring Security</p><br/><hr/>\n\n<h1 id=\"一、简介\"><a href=\"#一、简介\" class=\"headerlink\" title=\"一、简介\"></a>一、简介</h1><p>​\t\t<strong>Spring Security</strong> 是 Spring 家族中的一个安全管理框架。相比与另外一个安全框架<strong>Shiro</strong>，它提供了更丰富的功能，社区资源也比Shiro丰富。</p>\n<p>​\t一般来说中大型的项目都是使用<strong>SpringSecurity</strong> 来做安全框架。小项目有Shiro的比较多，因为相比与SpringSecurity，Shiro的上手更加的简单。</p>\n<p>​\t 一般Web应用的需要进行<strong>认证</strong>和<strong>授权</strong>。</p>\n<p>​\t\t<strong>认证：验证当前访问系统的是不是本系统的用户，并且要确认具体是哪个用户</strong></p>\n<p>​\t\t<strong>授权：经过认证后判断当前用户是否有权限进行某个操作</strong></p>\n<p>​\t而<strong>认证</strong>和<strong>授权</strong>也是SpringSecurity作为安全框架的<strong>核心功能</strong>。</p>\n<h1 id=\"二、第一个Spring-Security项目\"><a href=\"#二、第一个Spring-Security项目\" class=\"headerlink\" title=\"二、第一个Spring Security项目\"></a>二、第一个Spring Security项目</h1><h2 id=\"1-导入依赖\"><a href=\"#1-导入依赖\" class=\"headerlink\" title=\"1.导入依赖\"></a>1.导入依赖</h2><p>​\tSpring Security已经被Spring boot进行集成，使用时直接引入启动器即可。</p>\n<pre><code class=\"xml\">    &lt;properties&gt;\n        &lt;java.version&gt;1.8&lt;/java.version&gt;\n        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;\n        &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;\n        &lt;spring-boot.version&gt;2.3.7.RELEASE&lt;/spring-boot.version&gt;\n    &lt;/properties&gt;\t\n\n    &lt;dependencies&gt;\n        &lt;!--thymeleaf--&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n        &lt;!--druid--&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;\n            &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt;\n            &lt;version&gt;1.2.8&lt;/version&gt;\n        &lt;/dependency&gt;\n        &lt;!--mysql--&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;mysql&lt;/groupId&gt;\n            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n        &lt;!--mybatis-plus--&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;com.baomidou&lt;/groupId&gt;\n            &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;\n            &lt;version&gt;3.4.2&lt;/version&gt;\n        &lt;/dependency&gt;\n        &lt;!--redis依赖--&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n        &lt;!--fastjson依赖--&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;\n            &lt;artifactId&gt;fastjson&lt;/artifactId&gt;\n            &lt;version&gt;1.2.33&lt;/version&gt;\n        &lt;/dependency&gt;\n        &lt;!--jwt依赖--&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt;\n            &lt;artifactId&gt;jjwt&lt;/artifactId&gt;\n            &lt;version&gt;0.9.0&lt;/version&gt;\n        &lt;/dependency&gt;\n        &lt;!--spring-security--&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n        &lt;!--lombok--&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;\n            &lt;artifactId&gt;lombok&lt;/artifactId&gt;\n            &lt;optional&gt;true&lt;/optional&gt;\n        &lt;/dependency&gt;\n        &lt;!--spring-web--&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n        &lt;!--Spring test--&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;\n            &lt;scope&gt;test&lt;/scope&gt;\n            &lt;exclusions&gt;\n                &lt;exclusion&gt;\n                    &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt;\n                    &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt;\n                &lt;/exclusion&gt;\n            &lt;/exclusions&gt;\n        &lt;/dependency&gt;\n    &lt;/dependencies&gt;\n</code></pre>\n<h2 id=\"2-写一个控制器\"><a href=\"#2-写一个控制器\" class=\"headerlink\" title=\"2.写一个控制器\"></a>2.写一个控制器</h2><pre><code class=\"java\">\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RestController;\n\n@RestController\npublic class HelloController &#123;\n\n    @RequestMapping(&quot;/hello&quot;)\n    public String hello()&#123;\n        return &quot;hello&quot;;\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"3-访问页面\"><a href=\"#3-访问页面\" class=\"headerlink\" title=\"3.访问页面\"></a>3.访问页面</h2><p>​\t导入spring-boot-starter-security启动器后，Spring Security已经生效，默认拦截全部请求，如果用户没有登录，跳转到内置登录页面。</p>\n<p>​\t在项目中新建login.html页面后</p>\n<p>​\t在浏览器输入：<span class=\"exturl\" data-url=\"aHR0cDovL2xvY2FsaG9zdDo4MDgwL2xvZ2luLmh0bWwlRTUlOTAlOEUlRTQlQkMlOUElRTYlOTglQkUlRTclQTQlQkElRTQlQjglOEIlRTklOUQlQTIlRTklQTElQjUlRTklOUQlQTI=\">http://localhost:8080/login.html后会显示下面页面</span></p>\n<img data-src=\"/2022/10/07/SpringSecurity/springSecurity-01.jpg\" class=\"\">\n\n\n<p>​\t默认的username为user，password打印在控制台中。当然了，每个人的显示的肯定和我的不一样。</p>\n<p>​\t\t在浏览器中输入账号和密码后会显示login.html页面内容。</p>\n<h1 id=\"三、用户认证\"><a href=\"#三、用户认证\" class=\"headerlink\" title=\"三、用户认证\"></a>三、用户认证</h1><h2 id=\"3-1-登陆校验流程\"><a href=\"#3-1-登陆校验流程\" class=\"headerlink\" title=\"3.1 登陆校验流程\"></a>3.1 登陆校验流程</h2><img data-src=\"/2022/10/07/SpringSecurity/image-20211215094003288.png\" class=\"\">\n\n\n<h2 id=\"3-2-原理初探\"><a href=\"#3-2-原理初探\" class=\"headerlink\" title=\"3.2 原理初探\"></a>3.2 原理初探</h2><p>​\t想要知道如何实现自己的登陆流程就必须要先知道入门案例中SpringSecurity的流程。</p>\n<h3 id=\"3-2-1-SpringSecurity完整流程\"><a href=\"#3-2-1-SpringSecurity完整流程\" class=\"headerlink\" title=\"3.2.1 SpringSecurity完整流程\"></a>3.2.1 SpringSecurity完整流程</h3><p>​\tSpringSecurity的原理其实就是一个过滤器链，内部包含了提供各种功能的过滤器。这里我们可以看看入门案例中的过滤器。</p>\n<img data-src=\"/2022/10/07/SpringSecurity/image-20211214144425527.png\" class=\"\">\n\n\n<p>​\t图中只展示了核心过滤器，其它的非核心过滤器并没有在图中展示。</p>\n<p><strong>UsernamePasswordAuthenticationFilter</strong>:负责处理我们在登陆页面填写了用户名密码后的登陆请求。入门案例的认证工作主要有它负责。</p>\n<p><strong>ExceptionTranslationFilter：</strong>处理过滤器链中抛出的任何AccessDeniedException和AuthenticationException 。</p>\n<p><strong>FilterSecurityInterceptor：</strong>负责权限校验的过滤器。</p>\n<p>​\t</p>\n<p>​\t我们可以通过Debug查看当前系统中SpringSecurity过滤器链中有哪些过滤器及它们的顺序。</p>\n<img data-src=\"/2022/10/07/SpringSecurity/image-20211214145824903.png\" class=\"\">\n\n\n\n\n<h3 id=\"3-2-2-认证流程详解\"><a href=\"#3-2-2-认证流程详解\" class=\"headerlink\" title=\"3.2.2 认证流程详解\"></a>3.2.2 认证流程详解</h3><img data-src=\"/2022/10/07/SpringSecurity/image-20211214151515385.png\" class=\"\">\n\n\n<p>概念速查:</p>\n<p>Authentication接口: 它的实现类，表示当前访问系统的用户，封装了用户相关信息。</p>\n<p>AuthenticationManager接口：定义了认证Authentication的方法 </p>\n<p>UserDetailsService接口：加载用户特定数据的核心接口。里面定义了一个根据用户名查询用户信息的方法。</p>\n<p>UserDetails接口：提供核心用户信息。通过UserDetailsService根据用户名获取处理的用户信息要封装成UserDetails对象返回。然后将这些信息封装到Authentication对象中。</p>\n<h2 id=\"3-3-实现方式\"><a href=\"#3-3-实现方式\" class=\"headerlink\" title=\"3.3 实现方式\"></a>3.3 实现方式</h2><ul>\n<li>前后端不分离，登录页面由自己提供——3.1(不推荐)</li>\n<li>前后端分离，登录页面由前端提供     ——3.2(推荐，后序我们其他授权和别的操作，均以这个为主)</li>\n</ul>\n<p>在第二部分的基础上，进行操作</p>\n<h3 id=\"3-3-1-前后端不分离\"><a href=\"#3-3-1-前后端不分离\" class=\"headerlink\" title=\"3.3.1 前后端不分离\"></a>3.3.1 前后端不分离</h3><h4 id=\"1-准备工作\"><a href=\"#1-准备工作\" class=\"headerlink\" title=\"1 准备工作\"></a>1 准备工作</h4><h5 id=\"application-yml\"><a href=\"#application-yml\" class=\"headerlink\" title=\"application.yml\"></a>application.yml</h5><pre><code class=\"yaml\">spring:\n  application:\n    name: msb-spring-security\n  datasource:\n    druid:\n      url: jdbc:mysql://localhost:3306/mydb?characterEncoding=utf-8&amp;serverTimezone=UTC\n      username: root\n      password: root\n      driver-class-name: com.mysql.cj.jdbc.Driver\n\nmybatis-plus:\n  mapper-locations: classpath:mapper/*.xml\nlogging:\n  level:\n    com:\n      zjj:\n        mapper: debug\nserver:\n  port: 8081\n</code></pre>\n<h5 id=\"数据库准备\"><a href=\"#数据库准备\" class=\"headerlink\" title=\"数据库准备\"></a>数据库准备</h5><pre><code class=\"sql\">\nSET NAMES utf8mb4;\nSET FOREIGN_KEY_CHECKS = 0;\n\n-- ----------------------------\n-- Table structure for sys_menu\n-- ----------------------------\nDROP TABLE IF EXISTS `sys_menu`;\nCREATE TABLE `sys_menu`  (\n  `id` bigint(20) NOT NULL AUTO_INCREMENT,\n  `menu_name` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL DEFAULT &#39;NULL&#39; COMMENT &#39;菜单名&#39;,\n  `path` varchar(200) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT &#39;路由地址&#39;,\n  `component` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT &#39;组件路径&#39;,\n  `visible` char(1) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT &#39;0&#39; COMMENT &#39;菜单状态（0显示 1隐藏）&#39;,\n  `status` char(1) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT &#39;0&#39; COMMENT &#39;菜单状态（0正常 1停用）&#39;,\n  `perms` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT &#39;权限标识&#39;,\n  `icon` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT &#39;#&#39; COMMENT &#39;菜单图标&#39;,\n  `create_by` bigint(20) NULL DEFAULT NULL,\n  `create_time` datetime NULL DEFAULT NULL,\n  `update_by` bigint(20) NULL DEFAULT NULL,\n  `update_time` datetime NULL DEFAULT NULL,\n  `del_flag` int(11) NULL DEFAULT 0 COMMENT &#39;是否删除（0未删除 1已删除）&#39;,\n  `remark` varchar(500) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT &#39;备注&#39;,\n  PRIMARY KEY (`id`) USING BTREE\n) ENGINE = InnoDB AUTO_INCREMENT = 6 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci COMMENT = &#39;菜单表&#39; ROW_FORMAT = Dynamic;\n\nDROP TABLE IF EXISTS `sys_role`;\nCREATE TABLE `sys_role`  (\n  `id` bigint(20) NOT NULL AUTO_INCREMENT,\n  `name` varchar(128) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,\n  `role_key` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT &#39;角色权限字符串&#39;,\n  `status` char(1) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT &#39;0&#39; COMMENT &#39;角色状态（0正常 1停用）&#39;,\n  `del_flag` int(1) NULL DEFAULT 0 COMMENT &#39;del_flag&#39;,\n  `create_by` bigint(200) NULL DEFAULT NULL,\n  `create_time` datetime NULL DEFAULT NULL,\n  `update_by` bigint(200) NULL DEFAULT NULL,\n  `update_time` datetime NULL DEFAULT NULL,\n  `remark` varchar(500) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT &#39;备注&#39;,\n  PRIMARY KEY (`id`) USING BTREE\n) ENGINE = InnoDB AUTO_INCREMENT = 6 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci COMMENT = &#39;角色表&#39; ROW_FORMAT = Dynamic;\n\nDROP TABLE IF EXISTS `sys_role_menu`;\nCREATE TABLE `sys_role_menu`  (\n  `role_id` bigint(200) NOT NULL AUTO_INCREMENT COMMENT &#39;角色ID&#39;,\n  `menu_id` bigint(200) NOT NULL DEFAULT 0 COMMENT &#39;菜单id&#39;,\n  PRIMARY KEY (`role_id`, `menu_id`) USING BTREE\n) ENGINE = InnoDB AUTO_INCREMENT = 4 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Dynamic;\n\nDROP TABLE IF EXISTS `sys_user`;\nCREATE TABLE `sys_user`  (\n  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT &#39;主键&#39;,\n  `user_name` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL DEFAULT &#39;NULL&#39; COMMENT &#39;用户名&#39;,\n  `nick_name` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL DEFAULT &#39;NULL&#39; COMMENT &#39;昵称&#39;,\n  `password` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL DEFAULT &#39;NULL&#39; COMMENT &#39;密码&#39;,\n  `status` char(1) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT &#39;0&#39; COMMENT &#39;账号状态（0正常 1停用）&#39;,\n  `email` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT &#39;邮箱&#39;,\n  `phonenumber` varchar(32) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT &#39;手机号&#39;,\n  `sex` char(1) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT &#39;用户性别（0男，1女，2未知）&#39;,\n  `avatar` varchar(128) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT &#39;头像&#39;,\n  `user_type` char(1) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL DEFAULT &#39;1&#39; COMMENT &#39;用户类型（0管理员，1普通用户）&#39;,\n  `create_by` bigint(20) NULL DEFAULT NULL COMMENT &#39;创建人的用户id&#39;,\n  `create_time` datetime NULL DEFAULT NULL COMMENT &#39;创建时间&#39;,\n  `update_by` bigint(20) NULL DEFAULT NULL COMMENT &#39;更新人&#39;,\n  `update_time` datetime NULL DEFAULT NULL COMMENT &#39;更新时间&#39;,\n  `del_flag` int(11) NULL DEFAULT 0 COMMENT &#39;删除标志（0代表未删除，1代表已删除）&#39;,\n  PRIMARY KEY (`id`) USING BTREE\n) ENGINE = InnoDB AUTO_INCREMENT = 4 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci COMMENT = &#39;用户表&#39; ROW_FORMAT = Dynamic;\n\n\nDROP TABLE IF EXISTS `sys_user_role`;\nCREATE TABLE `sys_user_role`  (\n  `user_id` bigint(200) NOT NULL AUTO_INCREMENT COMMENT &#39;用户id&#39;,\n  `role_id` bigint(200) NOT NULL DEFAULT 0 COMMENT &#39;角色id&#39;,\n  PRIMARY KEY (`user_id`, `role_id`) USING BTREE\n) ENGINE = InnoDB AUTO_INCREMENT = 4 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Dynamic;\n\n\n\nINSERT INTO `sys_menu` VALUES (2, &#39;demo:select&#39;, NULL, NULL, &#39;0&#39;, &#39;0&#39;, NULL, &#39;#&#39;, NULL, NULL, NULL, NULL, 0, NULL);\nINSERT INTO `sys_menu` VALUES (3, &#39;demo:update&#39;, NULL, NULL, &#39;0&#39;, &#39;0&#39;, NULL, &#39;#&#39;, NULL, NULL, NULL, NULL, 0, NULL);\nINSERT INTO `sys_menu` VALUES (4, &#39;demo:insert&#39;, NULL, NULL, &#39;0&#39;, &#39;0&#39;, NULL, &#39;#&#39;, NULL, NULL, NULL, NULL, 0, NULL);\nINSERT INTO `sys_menu` VALUES (5, &#39;demo:delete&#39;, NULL, NULL, &#39;0&#39;, &#39;0&#39;, NULL, &#39;#&#39;, NULL, NULL, NULL, NULL, 0, NULL);\n\nINSERT INTO `sys_role` VALUES (3, &#39;管理员&#39;, NULL, &#39;0&#39;, 0, NULL, NULL, NULL, NULL, NULL);\nINSERT INTO `sys_role` VALUES (4, &#39;员工&#39;, NULL, &#39;0&#39;, 0, NULL, NULL, NULL, NULL, NULL);\nINSERT INTO `sys_role` VALUES (5, &#39;普通用户&#39;, NULL, &#39;0&#39;, 0, NULL, NULL, NULL, NULL, NULL);\n\nINSERT INTO `sys_role_menu` VALUES (1, 1);\nINSERT INTO `sys_role_menu` VALUES (1, 2);\nINSERT INTO `sys_role_menu` VALUES (1, 3);\nINSERT INTO `sys_role_menu` VALUES (1, 4);\nINSERT INTO `sys_role_menu` VALUES (2, 1);\nINSERT INTO `sys_role_menu` VALUES (2, 4);\nINSERT INTO `sys_role_menu` VALUES (3, 1);\n\nINSERT INTO `sys_user` VALUES (1, &#39;zhangsan&#39;, &#39;zhangsan&#39;, &#39;$2a$10$CFr1dsdBA3XDNrNRtsfX3ezUj/pUVsEhkg6cpKa9QG0oraGBMOZ5u&#39;, &#39;0&#39;, &#39;12@qq.com&#39;, &#39;123&#39;, &#39;1&#39;, NULL, &#39;0&#39;, NULL, &#39;2022-08-03 08:51:48&#39;, NULL, &#39;2022-08-27 08:51:54&#39;, 0);\nINSERT INTO `sys_user` VALUES (2, &#39;lisi&#39;, &#39;lisi&#39;, &#39;$2a$10$GRjbaR73zd9c9tCnj0BnnexqGSbQzXCVrXTPVEiOJqaypwCijbe4O&#39;, &#39;0&#39;, &#39;65.@126.com&#39;, &#39;456&#39;, &#39;0&#39;, NULL, &#39;0&#39;, NULL, &#39;2022-08-19 08:51:51&#39;, NULL, &#39;2022-08-27 08:51:59&#39;, 0);\nINSERT INTO `sys_user` VALUES (3, &#39;wangwu&#39;, &#39;wangwu&#39;, &#39;$2a$10$PsFb4a4bn0A.5pf4Rq5kheKaOkrhJOaz6hlu2WmBnkE8H9wZOoNXS&#39;, &#39;0&#39;, NULL, NULL, NULL, NULL, &#39;1&#39;, NULL, NULL, NULL, NULL, 0);\n\nINSERT INTO `sys_user_role` VALUES (1, 1);\nINSERT INTO `sys_user_role` VALUES (2, 2);\nINSERT INTO `sys_user_role` VALUES (3, 3);\n</code></pre>\n<h5 id=\"实体类1\"><a href=\"#实体类1\" class=\"headerlink\" title=\"实体类1\"></a>实体类1</h5><p>​\t这里目前只提供了登录所需要的User对象，以及我们自己封装的 USerDetails 对象，其余对象自己后续生成。（easycode 、 mybatisX、….都行）</p>\n<pre><code class=\"java\">package com.zjj.pojo;\n\nimport java.util.Date;\nimport com.baomidou.mybatisplus.extension.activerecord.Model;\nimport java.io.Serializable;\nimport lombok.*;\nimport com.baomidou.mybatisplus.annotation.TableName;\nimport com.baomidou.mybatisplus.annotation.TableField;\n\n/**\n * 用户表(User)表实体类\n *\n * @author makejava\n * @since 2022-08-24 21:09:13\n */\n\n@AllArgsConstructor\n@NoArgsConstructor\n@Data\n@ToString\n@TableName(value = &quot;sys_user&quot;)\npublic class User implements Serializable &#123;\n    /**\n    * 主键    \n    */ \n    @TableField(&quot;id&quot;)\n    private Long id;\n    \n    /**\n    * 用户名    \n    */ \n    @TableField(&quot;user_name&quot;)\n    private String username;\n    \n    /**\n    * 昵称    \n    */ \n    @TableField(&quot;nick_name&quot;)\n    private String nickName;\n    \n    /**\n    * 密码    \n    */ \n    @TableField(&quot;password&quot;)\n    private String password;\n    \n    /**\n    * 账号状态（0正常 1停用）    \n    */ \n    @TableField(&quot;status&quot;)\n    private String status;\n    \n    /**\n    * 邮箱    \n    */ \n    @TableField(&quot;email&quot;)\n    private String email;\n    \n    /**\n    * 手机号    \n    */ \n    @TableField(&quot;phonenumber&quot;)\n    private String phonenumber;\n    \n    /**\n    * 用户性别（0男，1女，2未知）    \n    */ \n    @TableField(&quot;sex&quot;)\n    private String sex;\n    \n    /**\n    * 头像    \n    */ \n    @TableField(&quot;avatar&quot;)\n    private String avatar;\n    \n    /**\n    * 用户类型（0管理员，1普通用户）    \n    */ \n    @TableField(&quot;user_type&quot;)\n    private String userType;\n    \n    /**\n    * 创建人的用户id    \n    */ \n    @TableField(&quot;create_by&quot;)\n    private Long createBy;\n    \n    /**\n    * 创建时间    \n    */ \n    @TableField(&quot;create_time&quot;)\n    private Date createTime;\n    \n    /**\n    * 更新人    \n    */ \n    @TableField(&quot;update_by&quot;)\n    private Long updateBy;\n    \n    /**\n    * 更新时间    \n    */ \n    @TableField(&quot;update_time&quot;)\n    private Date updateTime;\n    \n    /**\n    * 删除标志（0代表未删除，1代表已删除）    \n    */ \n    @TableField(&quot;del_flag&quot;)\n    private Integer delFlag;\n    \n\n&#125;\n</code></pre>\n<h5 id=\"实体类2\"><a href=\"#实体类2\" class=\"headerlink\" title=\"实体类2\"></a>实体类2</h5><pre><code class=\"java\">import com.alibaba.fastjson.annotation.JSONField;\nimport lombok.AllArgsConstructor;\nimport lombok.Data;\nimport lombok.NoArgsConstructor;\nimport lombok.ToString;\nimport org.springframework.security.core.GrantedAuthority;\nimport org.springframework.security.core.authority.SimpleGrantedAuthority;\nimport org.springframework.security.core.userdetails.UserDetails;\n\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.stream.Collectors;\n\n@AllArgsConstructor\n@NoArgsConstructor\n@Data\n@ToString\npublic class LoginUser implements UserDetails &#123;\n    private User user;\n\n    private List&lt;String&gt; permission;\n\n    public LoginUser(User user, List&lt;String&gt; permission) &#123;\n        this.user = user;\n        this.permission = permission;\n    &#125;\n\n    @JSONField(serialize = false) //redis存储的话会出现问题，不让他序列化，主要为了安全\n    List&lt;SimpleGrantedAuthority&gt; authorities ;\n    @Override\n    public Collection&lt;? extends GrantedAuthority&gt; getAuthorities() &#123;\n        // 把permission中的String类型的权限信息封装成 SimpleGrantedAuthority 对象\n        if (null != authorities) return authorities;//要是有信息就不用再授权了\n        authorities = permission.stream()\n                .map(SimpleGrantedAuthority::new)\n                .collect(Collectors.toList());\n        return authorities;\n    &#125;\n\n    @Override\n    public String getPassword() &#123;\n        return user.getPassword();\n    &#125;\n\n    @Override\n    public String getUsername() &#123;\n        return user.getUsername();\n    &#125;\n\n    @Override\n    public boolean isAccountNonExpired() &#123;\n        return true;\n    &#125;\n\n    @Override\n    public boolean isAccountNonLocked() &#123;\n        return true;\n    &#125;\n\n    @Override\n    public boolean isCredentialsNonExpired() &#123;\n        return true;\n    &#125;\n\n    @Override\n    public boolean isEnabled() &#123;\n        return true;\n    &#125;\n&#125;\n</code></pre>\n<h4 id=\"2-重写一个登录服务-ServiceImpl\"><a href=\"#2-重写一个登录服务-ServiceImpl\" class=\"headerlink\" title=\"2 重写一个登录服务(ServiceImpl)\"></a>2 重写一个登录服务(ServiceImpl)</h4><p>​\t这里要实现一个实现 UserDetailsService ，重写loadUserByUsername，因为这里是我们认证的地方，在下一个章节我们会具体说明</p>\n<pre><code class=\"java\">package com.zjj.service.impl;\n\nimport com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;\nimport com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;\nimport com.zjj.mapper.UserMapper;\nimport com.zjj.pojo.LoginUser;\nimport com.zjj.pojo.User;\nimport com.zjj.service.UserService;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.security.authentication.AuthenticationManager;\nimport org.springframework.security.authentication.UsernamePasswordAuthenticationToken;\nimport org.springframework.security.core.Authentication;\nimport org.springframework.security.core.userdetails.UserDetails;\nimport org.springframework.security.core.userdetails.UserDetailsService;\nimport org.springframework.security.core.userdetails.UsernameNotFoundException;\nimport org.springframework.stereotype.Service;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Objects;\n\n/**\n * 用户表(User)表服务实现类\n * @author makejava\n * @since 2022-08-24 21:09:13\n */\n@Service(&quot;userService&quot;)\npublic class UserServiceImpl extends ServiceImpl&lt;UserMapper, User&gt;\n        implements UserService, UserDetailsService &#123;\n    @Autowired\n    private UserMapper userMapper;\n\n    @Override\n    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException &#123;\n        LambdaQueryWrapper&lt;User&gt; qw = new LambdaQueryWrapper&lt;&gt;();\n        qw.eq(User::getUsername, username);\n        User user = userMapper.selectOne(qw);\n        if (Objects.isNull(user)) &#123;\n            throw new UsernameNotFoundException(&quot;没有该用户&quot;);\n        &#125;\n\n        // TODO 权限信息后序添加\n        List&lt;String&gt; menus = userMapper.findMenuByUserId(user.getId());\n        List&lt;String&gt; roles = userMapper.findRoleByUserId(user.getId());\n        List&lt;String&gt; res = new ArrayList&lt;&gt;();\n\n        for (String menu : menus) &#123;\n            res.add(menu);\n        &#125;\n        for (String role : roles) &#123;\n            res.add(&quot;ROLE_&quot;+role);\n        &#125;\n        // 用户的权限和角色直接赋值 的话 要注意写法\n        /*\n        1、我们没有user对象直接往回 new UserDetails(username,password,Authorities) 对象时，\n            要注意Authorities手动String转化可以用 AuthorityUtils.commaSeparatedStringToAuthorityList(String str)\n                但是里面的 str里面包含了权限以及角色，每个要用 “,” 间隔，而且角色开头要要拼接 ROLE_\n\n        2、我们自定义了user 实现了 UserDetails 对象 我们重写了 getAuthorities属性，具体看这个类的注释\n            他在初始化值的时候我们传参传递的是一个list对象，这个时候我们不需要用 “，” 间隔，但是角色前要加 ROLE_\n         */\n        return new LoginUser(user,res);\n    &#125;\n&#125;\n</code></pre>\n<h4 id=\"3-重写mapper层和对应的映射文件\"><a href=\"#3-重写mapper层和对应的映射文件\" class=\"headerlink\" title=\"3 重写mapper层和对应的映射文件\"></a>3 重写mapper层和对应的映射文件</h4><pre><code class=\"java\">import com.baomidou.mybatisplus.core.mapper.BaseMapper;\nimport com.zjj.pojo.User;\nimport org.apache.ibatis.annotations.Mapper;\n\nimport java.util.List;\n\n/**\n * 用户表(User)表数据库访问层\n *\n * @author makejava\n * @since 2022-08-24 21:09:13\n */\n\n@Mapper\npublic interface UserMapper extends BaseMapper&lt;User&gt; &#123;\n    public List&lt;String&gt; findMenuByUserId(Long id);\n    public List&lt;String&gt; findRoleByUserId(Long id);\n\n&#125;\n</code></pre>\n<pre><code class=\"xml\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;\n&lt;mapper namespace=&quot;com.zjj.mapper.UserMapper&quot;&gt;\n\n    &lt;sql id=&quot;AllUserColumn&quot;&gt;id , user_name , nick_name , password , status , email , phonenumber , sex , avatar , user_type , create_by , create_time , update_by , update_time , del_flag &lt;/sql&gt;   \n    &lt;resultMap type=&quot;com.zjj.pojo.User&quot; id=&quot;UserMap&quot;&gt;\n        &lt;result property=&quot;id&quot; column=&quot;id&quot; /&gt;\n        &lt;result property=&quot;userName&quot; column=&quot;user_name&quot; /&gt;\n        &lt;result property=&quot;nickName&quot; column=&quot;nick_name&quot; /&gt;\n        &lt;result property=&quot;password&quot; column=&quot;password&quot; /&gt;\n        &lt;result property=&quot;status&quot; column=&quot;status&quot; /&gt;\n        &lt;result property=&quot;email&quot; column=&quot;email&quot; /&gt;\n        &lt;result property=&quot;phonenumber&quot; column=&quot;phonenumber&quot; /&gt;\n        &lt;result property=&quot;sex&quot; column=&quot;sex&quot; /&gt;\n        &lt;result property=&quot;avatar&quot; column=&quot;avatar&quot; /&gt;\n        &lt;result property=&quot;userType&quot; column=&quot;user_type&quot; /&gt;\n        &lt;result property=&quot;createBy&quot; column=&quot;create_by&quot; /&gt;\n        &lt;result property=&quot;createTime&quot; column=&quot;create_time&quot; /&gt;\n        &lt;result property=&quot;updateBy&quot; column=&quot;update_by&quot; /&gt;\n        &lt;result property=&quot;updateTime&quot; column=&quot;update_time&quot; /&gt;\n        &lt;result property=&quot;delFlag&quot; column=&quot;del_flag&quot; /&gt;\n    &lt;/resultMap&gt;\n    &lt;select id=&quot;findMenuByUserId&quot; resultType=&quot;java.lang.String&quot;&gt;\n        SELECT\n            distinct(m.menu_name)\n        FROM\n            sys_user_role ur\n                LEFT JOIN sys_user u on u.id = ur.user_id\n                LEFT JOIN sys_role r ON ur.role_id = r.id\n                LEFT JOIN sys_role_menu rm ON ur.role_id = rm.role_id\n                LEFT JOIN sys_menu m ON m.id = rm.menu_id\n        WHERE\n            u.id = #&#123;args1&#125;\n          AND r.status = 0\n          AND m.status = 0\n    &lt;/select&gt;\n    &lt;select id=&quot;findRoleByUserId&quot; resultType=&quot;java.lang.String&quot;&gt;\n        SELECT\n            distinct(r.name)\n        FROM\n            sys_user_role ur\n                LEFT JOIN sys_user u on u.id = ur.user_id\n                LEFT JOIN sys_role r ON ur.role_id = r.id\n                LEFT JOIN sys_role_menu rm ON ur.role_id = rm.role_id\n                LEFT JOIN sys_menu m ON m.id = rm.menu_id\n        WHERE\n            u.id = #&#123;args1&#125;\n          AND r.status = 0\n          AND m.status = 0\n    &lt;/select&gt;\n    \n\n&lt;/mapper&gt;\n</code></pre>\n<h4 id=\"4-导入我们的登录页面\"><a href=\"#4-导入我们的登录页面\" class=\"headerlink\" title=\"4 导入我们的登录页面\"></a>4 导入我们的登录页面</h4><pre><code class=\"html\">&lt;!DOCTYPE html&gt;\n&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n    &lt;head&gt;\n        &lt;meta charset=&quot;UTF-8&quot;&gt;\n        &lt;title&gt;内容&lt;/title&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n        &lt;form action=&quot;/login&quot; method=&quot;post&quot;&gt;\n            username:&lt;input type=&quot;text&quot; name=&quot;username&quot;/&gt;&lt;br/&gt;\n            password:&lt;input type=&quot;password&quot; name=&quot;password&quot;/&gt;&lt;br/&gt;\n            &lt;input type=&quot;submit&quot; value=&quot;提交&quot;/&gt;\n        &lt;/form&gt;\n\n    &lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<h4 id=\"5-提供登录接口\"><a href=\"#5-提供登录接口\" class=\"headerlink\" title=\"5 提供登录接口\"></a>5 提供登录接口</h4><p>​\t就是一个页面的跳转指定我们的登录页面(&#x3D;&#x3D;要配置的&#x3D;&#x3D;)</p>\n<pre><code class=\"java\">import com.zjj.pojo.User;\nimport com.zjj.service.UserService;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.RequestBody;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.ResponseBody;\n@Controller\npublic class LoginController &#123;\n    @Autowired\n    private UserService userService;\n\n    @RequestMapping(&quot;/demo&quot;)\n    @ResponseBody\n    public String demo() &#123;\n        return &quot;demo&quot;;\n    &#125;\n\n    // 登录页面\n    @RequestMapping(&quot;/showLogin&quot;)\n    public String logint() &#123;\n        System.out.println(&quot;logint invoked&quot;);\n        return &quot;login&quot;;\n    &#125;\n&#125;\n</code></pre>\n<h4 id=\"6-修改配置类\"><a href=\"#6-修改配置类\" class=\"headerlink\" title=\"6 修改配置类\"></a>6 修改配置类</h4><p>​\t主要内容和细节，在formLogin里面，一定仔细查看注释，小细节很多</p>\n<pre><code class=\"java\">import org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.security.authentication.AuthenticationManager;\nimport org.springframework.security.config.annotation.web.builders.HttpSecurity;\nimport org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;\nimport org.springframework.security.config.http.SessionCreationPolicy;\nimport org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;\nimport org.springframework.security.crypto.password.PasswordEncoder;\n\n@Configuration\npublic class MySecurityCore extends WebSecurityConfigurerAdapter &#123;\n    @Bean\n    public PasswordEncoder getPasswordEncoder()&#123;\n        return new BCryptPasswordEncoder();\n    &#125;\n\n    @Override\n    protected void configure(HttpSecurity http) throws Exception &#123;\n\n        // http.formLogin() 所有和表单有关系的\n        http.formLogin()\n                // 登录页面，走一个controller\n                // 注意要和，LoginProcessingUrl 配合使用，不然在表单中的action中 url 失效\n                // 因为只配置loginPage()， 会导致在初始化的时候将loginProcessingUrl的配置相同化，可以自己debug 在AbstractAuthenticationFilterConfigurer 的 updateAuthenticationDefaults 方法\n                // 也就是说loginPage(&quot;/login&quot;)  loginProcessingUrl(&quot;/login&quot;),导致提交信息失败最终导致认证失败\n                .loginPage(&quot;/showLogin&quot;)\n                // 当发现什么URL时，把请求转发给自定义登录逻辑\n                // 表单提交的地址 action ,他就会直接去认证进入到 UserDetailsServiceImpl\n                // 去这里进行用户的验证 和 用户权限信息的集体封装\n                .loginProcessingUrl(&quot;/login&quot;)\n                // 登录成功的操作\n                // 下面两种方法都可以，推荐第二种，两种同时写第一个直接失效\n                // 第一种写法，要注意在写映射的时候要注意请求的方法 get/post\n                .successForwardUrl(&quot;/showMain&quot;)\n                .successHandler((request, response, authentication) -&gt; &#123;\n                    System.out.println(&quot;successHandler invoked&quot;);\n                    // 我们在每次请求同一个页面尽量使用重定向，要是请求转发\n                    // 因为请求转发是浏览器的行为，每次都要请求服务器并且重复提交表单，不好\n                    // response.sendRedirect(&quot;/fail&quot;);\n                    LoginUser loginUser = (LoginUser) authentication.getPrincipal();\n                    for (String s : loginUser.getPermission()) &#123;\n                        System.out.println(s);\n                    &#125;\n                &#125;)\n                // 登录失败的操作\n                // 内容和上述情况相同，只是一个成功的一个失败的\n                .failureForwardUrl(&quot;/fail&quot;)\n                // 当前端表单传递过来的用户名参数、密码参数名和后端不对应，可以利用下列方法\n                // 指定前端传递过来的用户名参数名称，默认 username\n                //.usernameParameter(&quot;MyuserName&quot;)\n                // 指定前端传递过来的密码参数名称，默认 password\n                //.passwordParameter(&quot;MypassWord&quot;)\n        ;\n\n        // http.authorizeRequests() 所有和授权相关\n        http.authorizeRequests()\n                // 这里面支持 正则 和 ant表达式\n                .antMatchers(&quot;/showLogin&quot;).anonymous()\n                .antMatchers(&quot;/js/**&quot;).permitAll()\n                .anyRequest().authenticated();\n\n\n        // http.csrf\n        http.csrf().disable()\n                // 不通过Session获取SecurityContext\n                // 因为我们使用了前后端分离的思想，在session中不存在参数，要用让东西存在它里面，所以不让他生成\n                .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS);\n\n    &#125;\n&#125;\n</code></pre>\n<h4 id=\"7-启动测试\"><a href=\"#7-启动测试\" class=\"headerlink\" title=\"7 启动测试\"></a>7 启动测试</h4><p>这个时候我们的用户名、密码都是我们在数据库中存储的（&#x3D;&#x3D;密码必须使我们提供的加密方式加密之后的&#x3D;&#x3D;）</p>\n<img data-src=\"/2022/10/07/SpringSecurity/image-20220825114004014.png\" class=\"\">\n\n\n<p>登录是否成功，一方面看是否请求被阻拦</p>\n<img data-src=\"/2022/10/07/SpringSecurity/image-20220825114855873.png\" class=\"\">\n\n\n<p>另一方面，我在配置中设置了认证成功之后的操作 successHandler(request,response.authentication) 我在里面将我们获得认证的用户权限信息全部打印在了控制台，如果错误了也可同样配置一些信息，具体配置将在后序章节详细总结我们的配置类中的配置，现在主要目的是理清逻辑即可</p>\n<img data-src=\"/2022/10/07/SpringSecurity/image-20220825114558928.png\" class=\"\">\n\n\n<h4 id=\"8-补充——密码加密\"><a href=\"#8-补充——密码加密\" class=\"headerlink\" title=\"8 补充——密码加密\"></a>8 补充——密码加密</h4><p>实际项目中我们不会把密码明文存储在数据库中。</p>\n<p>​\t默认使用的PasswordEncoder要求数据库中的密码格式为：{id}password 。它会根据id去判断密码的加密方式。但是我们一般不会采用这种方式。所以就需要替换PasswordEncoder。</p>\n<p>​\t我们一般使用SpringSecurity为我们提供的BCryptPasswordEncoder。</p>\n<p>​\t我们只需要使用把BCryptPasswordEncoder对象注入Spring容器中，SpringSecurity就会使用该PasswordEncoder来进行密码校验。</p>\n<p>​\t我们可以定义一个SpringSecurity的配置类，SpringSecurity要求这个配置类要继承WebSecurityConfigurerAdapter。</p>\n<pre><code class=\"java\">@Configuration\npublic class SecurityConfig extends WebSecurityConfigurerAdapter &#123;\n    \n    @Bean\n    public PasswordEncoder passwordEncoder()&#123;\n        return new BCryptPasswordEncoder();\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"3-3-2-前后端分离\"><a href=\"#3-3-2-前后端分离\" class=\"headerlink\" title=\"3.3.2  前后端分离\"></a>3.3.2  前后端分离</h3><h4 id=\"1-准备工作-1\"><a href=\"#1-准备工作-1\" class=\"headerlink\" title=\"1 准备工作\"></a>1 准备工作</h4><p>数据库、实体类均和3.3.1中相同</p>\n<p>application.yml</p>\n<pre><code class=\"yaml\">spring:\n  application:\n    name: spring-security\n  datasource:\n    druid:\n      url: jdbc:mysql://localhost:3306/mydb?characterEncoding=utf-8&amp;serverTimezone=UTC\n      username: root\n      password: root\n      driver-class-name: com.mysql.cj.jdbc.Driver\n  redis:\n    host: localhost\n    port: 6379\nmybatis-plus:\n  mapper-locations: classpath:mapper/*.xml\nlogging:\n  level:\n    com:\n      zjj:\n        mapper: debug\n</code></pre>\n<p>统一返回类</p>\n<pre><code class=\"java\">package com.zjj.common;\n\nimport com.fasterxml.jackson.annotation.JsonInclude;\n\n@JsonInclude(JsonInclude.Include.NON_NULL)\npublic class ResponseResult&lt;T&gt; &#123;\n    /**\n     * 状态码\n     */\n    private Integer code;\n    /**\n     * 提示信息，如果有错误时，前端可以获取该字段进行提示\n     */\n    private String msg;\n    /**\n     * 查询到的结果数据，\n     */\n    private T data;\n\n    public ResponseResult(Integer code, String msg) &#123;\n        this.code = code;\n        this.msg = msg;\n    &#125;\n\n    public ResponseResult(Integer code, T data) &#123;\n        this.code = code;\n        this.data = data;\n    &#125;\n\n    public Integer getCode() &#123;\n        return code;\n    &#125;\n\n    public void setCode(Integer code) &#123;\n        this.code = code;\n    &#125;\n\n    public String getMsg() &#123;\n        return msg;\n    &#125;\n\n    public void setMsg(String msg) &#123;\n        this.msg = msg;\n    &#125;\n\n    public T getData() &#123;\n        return data;\n    &#125;\n\n    public void setData(T data) &#123;\n        this.data = data;\n    &#125;\n\n    public ResponseResult(Integer code, String msg, T data) &#123;\n        this.code = code;\n        this.msg = msg;\n        this.data = data;\n    &#125;\n&#125;\n</code></pre>\n<p>工具类</p>\n<pre><code class=\"java\">import com.alibaba.fastjson.JSON;\nimport com.alibaba.fastjson.serializer.SerializerFeature;\nimport com.fasterxml.jackson.databind.JavaType;\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport com.fasterxml.jackson.databind.type.TypeFactory;\nimport org.springframework.data.redis.serializer.RedisSerializer;\nimport org.springframework.data.redis.serializer.SerializationException;\nimport com.alibaba.fastjson.parser.ParserConfig;\nimport org.springframework.util.Assert;\nimport java.nio.charset.Charset;\n\n/**\n * Redis使用FastJson序列化\n * \n * @author sg\n */\npublic class FastJsonRedisSerializer&lt;T&gt; implements RedisSerializer&lt;T&gt;\n&#123;\n\n    public static final Charset DEFAULT_CHARSET = Charset.forName(&quot;UTF-8&quot;);\n\n    private Class&lt;T&gt; clazz;\n\n    static\n    &#123;\n        ParserConfig.getGlobalInstance().setAutoTypeSupport(true);\n    &#125;\n\n    public FastJsonRedisSerializer(Class&lt;T&gt; clazz)\n    &#123;\n        super();\n        this.clazz = clazz;\n    &#125;\n\n    @Override\n    public byte[] serialize(T t) throws SerializationException\n    &#123;\n        if (t == null)\n        &#123;\n            return new byte[0];\n        &#125;\n        return JSON.toJSONString(t, SerializerFeature.WriteClassName).getBytes(DEFAULT_CHARSET);\n    &#125;\n\n    @Override\n    public T deserialize(byte[] bytes) throws SerializationException\n    &#123;\n        if (bytes == null || bytes.length &lt;= 0)\n        &#123;\n            return null;\n        &#125;\n        String str = new String(bytes, DEFAULT_CHARSET);\n\n        return JSON.parseObject(str, clazz);\n    &#125;\n\n\n    protected JavaType getJavaType(Class&lt;?&gt; clazz)\n    &#123;\n        return TypeFactory.defaultInstance().constructType(clazz);\n    &#125;\n&#125;\n</code></pre>\n<pre><code class=\"java\">package com.zjj.util;\n\nimport io.jsonwebtoken.Claims;\nimport io.jsonwebtoken.JwtBuilder;\nimport io.jsonwebtoken.Jwts;\nimport io.jsonwebtoken.SignatureAlgorithm;\n\nimport javax.crypto.SecretKey;\nimport javax.crypto.spec.SecretKeySpec;\nimport java.util.Base64;\nimport java.util.Date;\nimport java.util.UUID;\n\n/**\n * JWT工具类\n */\npublic class JwtUtil &#123;\n\n    //有效期为\n    public static final Long JWT_TTL = 60 * 60 *1000L;// 60 * 60 *1000  一个小时\n    //设置秘钥明文\n    public static final String JWT_KEY = &quot;sangeng&quot;;\n\n    public static String getUUID()&#123;\n        String token = UUID.randomUUID().toString().replaceAll(&quot;-&quot;, &quot;&quot;);\n        return token;\n    &#125;\n    \n    /**\n     * 生成jtw\n     * @param subject token中要存放的数据（json格式）\n     * @return\n     */\n    public static String createJWT(String subject) &#123;\n        JwtBuilder builder = getJwtBuilder(subject, null, getUUID());// 设置过期时间\n        return builder.compact();\n    &#125;\n\n    /**\n     * 生成jtw\n     * @param subject token中要存放的数据（json格式）\n     * @param ttlMillis token超时时间\n     * @return\n     */\n    public static String createJWT(String subject, Long ttlMillis) &#123;\n        JwtBuilder builder = getJwtBuilder(subject, ttlMillis, getUUID());// 设置过期时间\n        return builder.compact();\n    &#125;\n\n    private static JwtBuilder getJwtBuilder(String subject, Long ttlMillis, String uuid) &#123;\n        SignatureAlgorithm signatureAlgorithm = SignatureAlgorithm.HS256;\n        SecretKey secretKey = generalKey();\n        long nowMillis = System.currentTimeMillis();\n        Date now = new Date(nowMillis);\n        if(ttlMillis==null)&#123;\n            ttlMillis=JwtUtil.JWT_TTL;\n        &#125;\n        long expMillis = nowMillis + ttlMillis;\n        Date expDate = new Date(expMillis);\n        return Jwts.builder()\n                .setId(uuid)              //唯一的ID\n                .setSubject(subject)   // 主题  可以是JSON数据\n                .setIssuer(&quot;sg&quot;)     // 签发者\n                .setIssuedAt(now)      // 签发时间\n                .signWith(signatureAlgorithm, secretKey) //使用HS256对称加密算法签名, 第二个参数为秘钥\n                .setExpiration(expDate);\n    &#125;\n\n    /**\n     * 创建token\n     * @param id\n     * @param subject\n     * @param ttlMillis\n     * @return\n     */\n    public static String createJWT(String id, String subject, Long ttlMillis) &#123;\n        JwtBuilder builder = getJwtBuilder(subject, ttlMillis, id);// 设置过期时间\n        return builder.compact();\n    &#125;\n\n    public static void main(String[] args) throws Exception &#123;\n        String token = &quot;eyJhbGciOiJIUzI1NiJ9.eyJqdGkiOiJjYWM2ZDVhZi1mNjVlLTQ0MDAtYjcxMi0zYWEwOGIyOTIwYjQiLCJzdWIiOiJzZyIsImlzcyI6InNnIiwiaWF0IjoxNjM4MTA2NzEyLCJleHAiOjE2MzgxMTAzMTJ9.JVsSbkP94wuczb4QryQbAke3ysBDIL5ou8fWsbt_ebg&quot;;\n        Claims claims = parseJWT(token);\n        System.out.println(claims);\n    &#125;\n\n    /**\n     * 生成加密后的秘钥 secretKey\n     * @return\n     */\n    public static SecretKey generalKey() &#123;\n        byte[] encodedKey = Base64.getDecoder().decode(JwtUtil.JWT_KEY);\n        SecretKey key = new SecretKeySpec(encodedKey, 0, encodedKey.length, &quot;AES&quot;);\n        return key;\n    &#125;\n    \n    /**\n     * 解析\n     *\n     * @param jwt\n     * @return\n     * @throws Exception\n     */\n    public static Claims parseJWT(String jwt) throws Exception &#123;\n        SecretKey secretKey = generalKey();\n        return Jwts.parser()\n                .setSigningKey(secretKey)\n                .parseClaimsJws(jwt)\n                .getBody();\n    &#125;\n\n\n&#125;\n</code></pre>\n<pre><code class=\"java\">package com.zjj.util;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.data.redis.core.BoundSetOperations;\nimport org.springframework.data.redis.core.HashOperations;\nimport org.springframework.data.redis.core.RedisTemplate;\nimport org.springframework.data.redis.core.ValueOperations;\nimport org.springframework.stereotype.Component;\n\nimport java.util.*;\nimport java.util.concurrent.TimeUnit;\n\n@SuppressWarnings(value = &#123; &quot;unchecked&quot;, &quot;rawtypes&quot; &#125;)\n@Component\npublic class RedisCache\n&#123;\n    @Autowired\n    public RedisTemplate redisTemplate;\n\n    /**\n     * 缓存基本的对象，Integer、String、实体类等\n     *\n     * @param key 缓存的键值\n     * @param value 缓存的值\n     */\n    public &lt;T&gt; void setCacheObject(final String key, final T value)\n    &#123;\n        redisTemplate.opsForValue().set(key, value);\n    &#125;\n\n    /**\n     * 缓存基本的对象，Integer、String、实体类等\n     *\n     * @param key 缓存的键值\n     * @param value 缓存的值\n     * @param timeout 时间\n     * @param timeUnit 时间颗粒度\n     */\n    public &lt;T&gt; void setCacheObject(final String key, final T value, final Integer timeout, final TimeUnit timeUnit)\n    &#123;\n        redisTemplate.opsForValue().set(key, value, timeout, timeUnit);\n    &#125;\n\n    /**\n     * 设置有效时间\n     *\n     * @param key Redis键\n     * @param timeout 超时时间\n     * @return true=设置成功；false=设置失败\n     */\n    public boolean expire(final String key, final long timeout)\n    &#123;\n        return expire(key, timeout, TimeUnit.SECONDS);\n    &#125;\n\n    /**\n     * 设置有效时间\n     *\n     * @param key Redis键\n     * @param timeout 超时时间\n     * @param unit 时间单位\n     * @return true=设置成功；false=设置失败\n     */\n    public boolean expire(final String key, final long timeout, final TimeUnit unit)\n    &#123;\n        return redisTemplate.expire(key, timeout, unit);\n    &#125;\n\n    /**\n     * 获得缓存的基本对象。\n     *\n     * @param key 缓存键值\n     * @return 缓存键值对应的数据\n     */\n    public &lt;T&gt; T getCacheObject(final String key)\n    &#123;\n        ValueOperations&lt;String, T&gt; operation = redisTemplate.opsForValue();\n        return operation.get(key);\n    &#125;\n\n    /**\n     * 删除单个对象\n     *\n     * @param key\n     */\n    public boolean deleteObject(final String key)\n    &#123;\n        return redisTemplate.delete(key);\n    &#125;\n\n    /**\n     * 删除集合对象\n     *\n     * @param collection 多个对象\n     * @return\n     */\n    public long deleteObject(final Collection collection)\n    &#123;\n        return redisTemplate.delete(collection);\n    &#125;\n\n    /**\n     * 缓存List数据\n     *\n     * @param key 缓存的键值\n     * @param dataList 待缓存的List数据\n     * @return 缓存的对象\n     */\n    public &lt;T&gt; long setCacheList(final String key, final List&lt;T&gt; dataList)\n    &#123;\n        Long count = redisTemplate.opsForList().rightPushAll(key, dataList);\n        return count == null ? 0 : count;\n    &#125;\n\n    /**\n     * 获得缓存的list对象\n     *\n     * @param key 缓存的键值\n     * @return 缓存键值对应的数据\n     */\n    public &lt;T&gt; List&lt;T&gt; getCacheList(final String key)\n    &#123;\n        return redisTemplate.opsForList().range(key, 0, -1);\n    &#125;\n\n    /**\n     * 缓存Set\n     *\n     * @param key 缓存键值\n     * @param dataSet 缓存的数据\n     * @return 缓存数据的对象\n     */\n    public &lt;T&gt; BoundSetOperations&lt;String, T&gt; setCacheSet(final String key, final Set&lt;T&gt; dataSet)\n    &#123;\n        BoundSetOperations&lt;String, T&gt; setOperation = redisTemplate.boundSetOps(key);\n        Iterator&lt;T&gt; it = dataSet.iterator();\n        while (it.hasNext())\n        &#123;\n            setOperation.add(it.next());\n        &#125;\n        return setOperation;\n    &#125;\n\n    /**\n     * 获得缓存的set\n     *\n     * @param key\n     * @return\n     */\n    public &lt;T&gt; Set&lt;T&gt; getCacheSet(final String key)\n    &#123;\n        return redisTemplate.opsForSet().members(key);\n    &#125;\n\n    /**\n     * 缓存Map\n     *\n     * @param key\n     * @param dataMap\n     */\n    public &lt;T&gt; void setCacheMap(final String key, final Map&lt;String, T&gt; dataMap)\n    &#123;\n        if (dataMap != null) &#123;\n            redisTemplate.opsForHash().putAll(key, dataMap);\n        &#125;\n    &#125;\n\n    /**\n     * 获得缓存的Map\n     *\n     * @param key\n     * @return\n     */\n    public &lt;T&gt; Map&lt;String, T&gt; getCacheMap(final String key)\n    &#123;\n        return redisTemplate.opsForHash().entries(key);\n    &#125;\n\n    /**\n     * 往Hash中存入数据\n     *\n     * @param key Redis键\n     * @param hKey Hash键\n     * @param value 值\n     */\n    public &lt;T&gt; void setCacheMapValue(final String key, final String hKey, final T value)\n    &#123;\n        redisTemplate.opsForHash().put(key, hKey, value);\n    &#125;\n\n    /**\n     * 获取Hash中的数据\n     *\n     * @param key Redis键\n     * @param hKey Hash键\n     * @return Hash中的对象\n     */\n    public &lt;T&gt; T getCacheMapValue(final String key, final String hKey)\n    &#123;\n        HashOperations&lt;String, String, T&gt; opsForHash = redisTemplate.opsForHash();\n        return opsForHash.get(key, hKey);\n    &#125;\n\n    /**\n     * 删除Hash中的数据\n     * \n     * @param key\n     * @param hkey\n     */\n    public void delCacheMapValue(final String key, final String hkey)\n    &#123;\n        HashOperations hashOperations = redisTemplate.opsForHash();\n        hashOperations.delete(key, hkey);\n    &#125;\n\n    /**\n     * 获取多个Hash中的数据\n     *\n     * @param key Redis键\n     * @param hKeys Hash键集合\n     * @return Hash对象集合\n     */\n    public &lt;T&gt; List&lt;T&gt; getMultiCacheMapValue(final String key, final Collection&lt;Object&gt; hKeys)\n    &#123;\n        return redisTemplate.opsForHash().multiGet(key, hKeys);\n    &#125;\n\n    /**\n     * 获得缓存的基本对象列表\n     *\n     * @param pattern 字符串前缀\n     * @return 对象列表\n     */\n    public Collection&lt;String&gt; keys(final String pattern)\n    &#123;\n        return redisTemplate.keys(pattern);\n    &#125;\n&#125;\n</code></pre>\n<pre><code class=\"java\">package com.zjj.util;\n\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\n\npublic class WebUtils\n&#123;\n    /**\n     * 将字符串渲染到客户端\n     * \n     * @param response 渲染对象\n     * @param string 待渲染的字符串\n     * @return null\n     */\n    public static String renderString(HttpServletResponse response, String string) &#123;\n        try\n        &#123;\n            response.setStatus(200);\n            response.setContentType(&quot;application/json&quot;);\n            response.setCharacterEncoding(&quot;utf-8&quot;);\n            response.getWriter().print(string);\n        &#125;\n        catch (IOException e)\n        &#123;\n            e.printStackTrace();\n        &#125;\n        return null;\n    &#125;\n&#125;\n</code></pre>\n<pre><code class=\"java\">package com.zjj.config;\n\nimport com.zjj.util.FastJsonRedisSerializer;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.data.redis.connection.RedisConnectionFactory;\nimport org.springframework.data.redis.core.RedisTemplate;\nimport org.springframework.data.redis.serializer.StringRedisSerializer;\n\n@Configuration\npublic class RedisConfig &#123;\n\n    @Bean\n    @SuppressWarnings(value = &#123; &quot;unchecked&quot;, &quot;rawtypes&quot; &#125;)\n    public RedisTemplate&lt;Object, Object&gt; redisTemplate(RedisConnectionFactory connectionFactory)\n    &#123;\n        RedisTemplate&lt;Object, Object&gt; template = new RedisTemplate&lt;&gt;();\n        template.setConnectionFactory(connectionFactory);\n\n        FastJsonRedisSerializer serializer = new FastJsonRedisSerializer(Object.class);\n\n        // 使用StringRedisSerializer来序列化和反序列化redis的key值\n        template.setKeySerializer(new StringRedisSerializer());\n        template.setValueSerializer(serializer);\n\n        // Hash的key也采用StringRedisSerializer的序列化方式\n        template.setHashKeySerializer(new StringRedisSerializer());\n        template.setHashValueSerializer(serializer);\n\n        template.afterPropertiesSet();\n        return template;\n    &#125;\n&#125;\n</code></pre>\n<h4 id=\"2-重写登录服务-ServiceImpl\"><a href=\"#2-重写登录服务-ServiceImpl\" class=\"headerlink\" title=\"2  重写登录服务(ServiceImpl)\"></a>2  重写登录服务(ServiceImpl)</h4><p>​\t这里我们需要写一个LoginService 、LoginServiceImpl 以及&#x3D;&#x3D;认证服务&#x3D;&#x3D;  UserDetailServiceImpl (后续会详细解释)</p>\n<pre><code class=\"java\">package com.zjj.service.impl;\n\nimport com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;\nimport com.zjj.mapper.UserMapper;\nimport com.zjj.pojo.LoginUser;\nimport com.zjj.pojo.User;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.security.core.userdetails.UserDetails;\nimport org.springframework.security.core.userdetails.UserDetailsService;\nimport org.springframework.security.core.userdetails.UsernameNotFoundException;\nimport org.springframework.stereotype.Service;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Objects;\n\n@Service\npublic class UserDetailServiceImpl implements UserDetailsService &#123;\n    @Autowired\n    private UserMapper userMapper;\n\n    @Override\n    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException &#123;\n        LambdaQueryWrapper&lt;User&gt; qw = new LambdaQueryWrapper&lt;&gt;();\n        qw.eq(User::getUserName, username);\n        User user = userMapper.selectOne(qw);\n        if (Objects.isNull(user)) &#123;\n            throw new UsernameNotFoundException(&quot;没有该用户&quot;);\n        &#125;\n\n        // TODO 权限信息后序添加\n        List&lt;String&gt; menus = userMapper.findMenuByUserId(user.getId());\n        List&lt;String&gt; roles = userMapper.findRoleByUserId(user.getId());\n        List&lt;String&gt; res = new ArrayList&lt;&gt;();\n\n        \n        for (String menu : menus) &#123;\n            res.add(menu);\n        &#125;\n        for (String role : roles) &#123;\n            res.add(&quot;ROLE_&quot;+role);\n        &#125;\n        // 用户的权限和角色直接赋值 的话 要注意写法\n        /*\n        1、我们没有user对象直接往回 new UserDetails(username,password,Authorities) 对象时，\n            要注意Authorities手动String转化可以用 AuthorityUtils.commaSeparatedStringToAuthorityList(String str)\n                但是里面的 str里面包含了权限以及角色，每个要用 “,” 间隔，而且角色开头要要拼接 ROLE_\n\n        2、我们自定义了user 实现了 UserDetails 对象 我们重写了 getAuthorities属性，具体看这个类的注释\n            他在初始化值的时候我们传参传递的是一个list对象，这个时候我们不需要用 “，” 间隔，但是角色前要加 ROLE_\n         */\n        return new LoginUser(user,res);\n    &#125;\n&#125;\n</code></pre>\n<pre><code class=\"java\">public interface LoginService &#123;\n    public ResponseResult login(User user);\n\n    ResponseResult logout();\n&#125;\n</code></pre>\n<pre><code class=\"java\">import com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;\nimport com.zjj.mapper.UserMapper;\nimport com.zjj.pojo.LoginUser;\nimport com.zjj.pojo.User;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.security.core.userdetails.UserDetails;\nimport org.springframework.security.core.userdetails.UserDetailsService;\nimport org.springframework.security.core.userdetails.UsernameNotFoundException;\nimport org.springframework.stereotype.Service;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Objects;\n\n@Service\npublic class UserDetailServiceImpl implements UserDetailsService &#123;\n    @Autowired\n    private UserMapper userMapper;\n\n    @Override\n    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException &#123;\n        LambdaQueryWrapper&lt;User&gt; qw = new LambdaQueryWrapper&lt;&gt;();\n        qw.eq(User::getUserName, username);\n        User user = userMapper.selectOne(qw);\n        if (Objects.isNull(user)) &#123;\n            throw new UsernameNotFoundException(&quot;没有该用户&quot;);\n        &#125;\n\n        // TODO 权限信息后序添加\n        List&lt;String&gt; menus = userMapper.findMenuByUserId(user.getId());\n        List&lt;String&gt; roles = userMapper.findRoleByUserId(user.getId());\n        List&lt;String&gt; res = new ArrayList&lt;&gt;();\n\n        for (String menu : menus) &#123;\n            res.add(menu);\n        &#125;\n        for (String role : roles) &#123;\n            res.add(&quot;ROLE_&quot;+role);\n        &#125;\n        // 用户的权限和角色直接赋值 的话 要注意写法\n        /*\n        1、我们没有user对象直接往回 new UserDetails(username,password,Authorities) 对象时，\n            要注意Authorities手动String转化可以用 AuthorityUtils.commaSeparatedStringToAuthorityList(String str)\n                但是里面的 str里面包含了权限以及角色，每个要用 “,” 间隔，而且角色开头要要拼接 ROLE_\n\n        2、我们自定义了user 实现了 UserDetails 对象 我们重写了 getAuthorities属性，具体看这个类的注释\n            他在初始化值的时候我们传参传递的是一个list对象，这个时候我们不需要用 “，” 间隔，但是角色前要加 ROLE_\n         */\n        return new LoginUser(user,res);\n    &#125;\n&#125;\n</code></pre>\n<h4 id=\"3-重写mapper层和对应的映射文件-1\"><a href=\"#3-重写mapper层和对应的映射文件-1\" class=\"headerlink\" title=\"3 重写mapper层和对应的映射文件\"></a>3 重写mapper层和对应的映射文件</h4><p>和3.3.1的准备相同</p>\n<h4 id=\"4-配置类配置\"><a href=\"#4-配置类配置\" class=\"headerlink\" title=\"4 配置类配置\"></a>4 配置类配置</h4><pre><code class=\"java\">@Configuration\npublic class SecurityConfig extends WebSecurityConfigurerAdapter &#123;\n\n\n    @Bean\n    public PasswordEncoder passwordEncoder()&#123;\n        return new BCryptPasswordEncoder();\n    &#125;\n\n    @Override\n    protected void configure(HttpSecurity http) throws Exception &#123;\n        http\n                //关闭csrf\n                .csrf().disable()\n                //不通过Session获取SecurityContext\n                .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)\n                .and()\n                .authorizeRequests()\n                // 对于登录接口 允许匿名访问\n                .antMatchers(&quot;/user/login&quot;).anonymous()\n                // 除上面外的所有请求全部需要鉴权认证\n                .anyRequest().authenticated();\n    &#125;\n\n    @Bean\n    @Override\n    public AuthenticationManager authenticationManagerBean() throws Exception &#123;\n        return super.authenticationManagerBean();\n    &#125;\n&#125;\n</code></pre>\n<h4 id=\"5-对接登录接口\"><a href=\"#5-对接登录接口\" class=\"headerlink\" title=\"5 对接登录接口\"></a>5 对接登录接口</h4><p>假定登录接口为\t“&#x2F;user&#x2F;login”</p>\n<pre><code class=\"java\">@Controller\npublic class LoginController &#123;\n\n    @Autowired\n    private LoginService loginService;\n\n    @RequestMapping(&quot;/user/login&quot;)\n    @ResponseBody\n    public ResponseResult login(@RequestBody User user)&#123;\n        return loginService.login(user);\n    &#125;\n    @RequestMapping(&quot;/user/logout&quot;)\n    @ResponseBody\n    public ResponseResult logout() &#123;\n        return loginService.logout();\n    &#125;\n&#125;\n</code></pre>\n<p>5 测试接口</p>\n<p>这里用接口测试工具即可，我们没有登录页面，页面是前端提供的，所以我们只需要确保接口测试正确即可</p>\n<p><span class=\"exturl\" data-url=\"aHR0cDovL2xvY2FsaG9zdDo4MDgwL3VzZXIvbG9naW4=\">http://localhost:8080/user/login</span></p>\n<pre><code class=\"json\">&#123;\n    &quot;userName&quot;:&quot;zhangsan&quot;,\n    &quot;password&quot;:&quot;zhangsan&quot;\n    // &quot;userName&quot;:&quot;lisi&quot;,\n    // &quot;password&quot;:&quot;lisi&quot;\n    // &quot;userName&quot;:&quot;wangwu&quot;,\n    // &quot;password&quot;:&quot;wangwu&quot;\n&#125;\n</code></pre>\n<img data-src=\"/2022/10/07/SpringSecurity/image-20220825120818298.png\" class=\"\">\n\n\n<h4 id=\"6-优化认证——引入Redis\"><a href=\"#6-优化认证——引入Redis\" class=\"headerlink\" title=\"6 优化认证——引入Redis\"></a>6 优化认证——引入Redis</h4><p>​\t我们在项目中，不可能每次这种常用数据都去数据库访问，这样会给数据库造成极大的负担，导致我们的数据库宕机。因此我们引入的NoSQL数据库、缓存数据库 Redis 用来存储我们短期常用数据。但是问题又来了。怎么存储呢？</p>\n<p>​\t引入 3.2.1SpringSecurity完整流程 </p>\n<img data-src=\"/2022/10/07/SpringSecurity/image-20211214144425527.png\" class=\"\">\n\n\n<p>​\t我们每次的登录验证都需要经过 UsernamePasswordAuthenticationFilter ，在这个过滤器下我们必须得到一个认证的用户，所以我们在这里为了得到用户的认证信息我们老办法就是去数据库中查找，但是我们现在不想让他老去数据库中找，在他之前我们要是直接能得到这个认证过的用户岂不皆大欢喜，所以我们在他之前也加上一个过滤器用来查找每次请求是否有这个认证用户有的话我们就可以省略掉去数据库中查找他的信息的过程。</p>\n<p>​\t那么问题又来了我们如何存储一个用户的信息呢？</p>\n<p>这里我们可以利用JWT根据我们的用户ID生成一个Token，以他为键值存储到redis中</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA3MDE3NS9hcnRpY2xlL2RldGFpbHMvMTE4NTU5Mjcy\">JWT详解</span> ：除了讲解JWT，还很好的帮忙回顾了Token的优势</p>\n<pre><code class=\"java\">package com.zjj.filter;\n\nimport com.zjj.pojo.LoginUser;\nimport com.zjj.util.JwtUtil;\nimport com.zjj.util.RedisCache;\nimport io.jsonwebtoken.Claims;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.security.authentication.UsernamePasswordAuthenticationToken;\nimport org.springframework.security.core.context.SecurityContextHolder;\nimport org.springframework.stereotype.Component;\nimport org.springframework.util.StringUtils;\nimport org.springframework.web.filter.OncePerRequestFilter;\n\nimport javax.servlet.FilterChain;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport java.util.Objects;\n\n@Component\npublic class JwtAuthenticationTokenFilter extends OncePerRequestFilter &#123;\n\n    @Autowired\n    private RedisCache redisCache;\n\n    @Override\n    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException &#123;\n        //获取token\n        String token = request.getHeader(&quot;token&quot;);\n        if (!StringUtils.hasText(token)) &#123;\n            //放行\n            /*\n            * 解释一下，为什么没有Token还放行，因为没有token可以但是可能他是登录请求\n            * 我们还是要放行的，不然所有人都登录不了，但是问题是如果不是为什么还要放行\n            * 这里不用担心，如果不是登录请求他就可能会存在User对象的账户和密码，就无法完成第一步的认证工作，跟别说后面的鉴权了，所以他会直接被挡住\n            * 其次我们倒数第二个过滤器就是为我们处理我们出现的问题的过滤器，出了问题让他解决就行了，这里的问题其实大多数都是token错误，需要重新认证\n            * */\n            filterChain.doFilter(request, response);\n            return;\n        &#125;\n        //解析token\n        String userid;\n        try &#123;\n            Claims claims = JwtUtil.parseJWT(token);\n            userid = claims.getSubject();\n        &#125; catch (Exception e) &#123;\n            e.printStackTrace();\n            throw new RuntimeException(&quot;token非法&quot;);\n        &#125;\n        //从redis中获取用户信息\n        String redisKey = &quot;login:&quot; + userid;\n        LoginUser loginUser = redisCache.getCacheObject(redisKey);\n        if(Objects.isNull(loginUser))&#123;\n            throw new RuntimeException(&quot;用户未登录&quot;);\n        &#125;\n        //存入SecurityContextHolder ——&gt; 认证成功的对象都在这\n        //TODO 获取权限信息封装到Authentication中\n        /*\n        * 三参构造可以获取该对象是否是以认证状态\n        *  */\n        UsernamePasswordAuthenticationToken authenticationToken =\n                new UsernamePasswordAuthenticationToken(loginUser,null,loginUser.getAuthorities());\n        SecurityContextHolder.getContext().setAuthentication(authenticationToken);\n        //放行\n        filterChain.doFilter(request, response);\n    &#125;\n&#125;\n</code></pre>\n<h4 id=\"7-修改配置类\"><a href=\"#7-修改配置类\" class=\"headerlink\" title=\"7 修改配置类\"></a>7 修改配置类</h4><pre><code class=\"java\">package com.zjj.config;\n\nimport com.zjj.filter.JwtAuthenticationTokenFilter;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.security.authentication.AuthenticationManager;\nimport org.springframework.security.config.annotation.web.builders.HttpSecurity;\nimport org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;\nimport org.springframework.security.config.http.SessionCreationPolicy;\nimport org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;\nimport org.springframework.security.crypto.password.PasswordEncoder;\nimport org.springframework.security.web.AuthenticationEntryPoint;\nimport org.springframework.security.web.access.AccessDeniedHandler;\nimport org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;\n\n\n@Configuration\npublic class SpringSecurityConfig extends WebSecurityConfigurerAdapter &#123;\n\n    @Autowired\n    private JwtAuthenticationTokenFilter jwtAuthenticationTokenFilter;\n    @Autowired\n    private AuthenticationEntryPoint authenticationEntryPoint;\n    @Autowired\n    private AccessDeniedHandler accessDeniedHandler;\n\n    @Override\n    protected void configure(HttpSecurity http) throws Exception &#123;\n\n        // 认证、授权错误处理\n        http.exceptionHandling()\n                .authenticationEntryPoint(authenticationEntryPoint)\n                .accessDeniedHandler(accessDeniedHandler);\n        // 认证过滤器添加\n        http.addFilterBefore(jwtAuthenticationTokenFilter, UsernamePasswordAuthenticationFilter.class);\n\n        // url拦截\n        http.authorizeRequests()\n                // anonymous 匿名 没有认证的才可以访问，permitALL 谁都能访问，不需要认证\n                .antMatchers(&quot;/user/login&quot;,&quot;/login&quot;,&quot;/loginPage&quot;).anonymous()\n                .antMatchers(&quot;/login.html&quot;,&quot;/fail.html&quot;).permitAll()\n                // authenticated 认证了才能访问\n                .anyRequest().authenticated();\n\n        //关闭CSRF\n        http.csrf().disable()\n                // 不通过Session获取SecurityContext\n                .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS);\n        // Cors\n        http.cors();\n    &#125;\n\n    @Bean\n    @Override\n    public AuthenticationManager authenticationManagerBean() throws Exception &#123;\n        return super.authenticationManagerBean();\n    &#125;\n\n\n    @Bean\n    public PasswordEncoder getPasswordEncoder()&#123;\n        return new BCryptPasswordEncoder();\n    &#125;\n&#125;\n</code></pre>\n<h4 id=\"8-测试\"><a href=\"#8-测试\" class=\"headerlink\" title=\"8 测试\"></a>8 测试</h4><p>这里要打开你的 redis服务端 ，如果不是本地的，你要去配置中添加配置</p>\n<p>最后根据 步骤5 再次测试，成功后你的redis 中会多出一组数据，这就是我们的Token，具体步骤不再演示！</p>\n<h1 id=\"四、UserDetailsService详解\"><a href=\"#四、UserDetailsService详解\" class=\"headerlink\" title=\"四、UserDetailsService详解\"></a>四、UserDetailsService详解</h1><p>​\t当什么也没有配置的时候，账号和密码是由Spring Security定义生成的。而在实际项目中账号和密码都是从数据库中查询出来的。 所以我们要通过自定义逻辑控制**&#x3D;&#x3D;认证逻辑&#x3D;&#x3D;**。</p>\n<img data-src=\"/2022/10/07/SpringSecurity/image-20211214151515385.png\" class=\"\">\n\n\n<p>​\t如果需要自定义逻辑时，只需要实现UserDetailsService接口即可。接口定义如下：</p>\n<img data-src=\"/2022/10/07/SpringSecurity/springSecurity-03.jpg\" class=\"\">\n\n\n<h2 id=\"1-返回值\"><a href=\"#1-返回值\" class=\"headerlink\" title=\"1.返回值\"></a>1.返回值</h2><p>​\t返回值UserDetails是一个接口，定义如下</p>\n<img data-src=\"/2022/10/07/SpringSecurity/springSecurity-04.jpg\" class=\"\">\n\n\n<p>​\t要想返回UserDetails的实例就只能返回接口的实现类。Spring Security中提供了如下的实例。对于我们只需要使用里面的User类即可。注意User的全限定路径是：</p>\n<p>​\torg.springframework.security.core.userdetails.User</p>\n<p>​\t此处经常和系统中自己开发的User类弄混。</p>\n<img data-src=\"/2022/10/07/SpringSecurity/springSecurity-05.jpg\" class=\"\">\n\n\n<p>​\t在User类中提供了很多方法和属性。</p>\n<img data-src=\"/2022/10/07/SpringSecurity/springSecurity-06.jpg\" class=\"\">\n\n\n<p>​\t其中构造方法有两个，调用其中任何一个都可以实例化UserDetails实现类User类的实例。而三个参数的构造方法实际上也是调用7个参数的构造方法。</p>\n<p>​\tusername:用户名</p>\n<p>​\tpassword:密码</p>\n<p>​\tauthorities：用户具有的权限。此处不允许为null</p>\n<img data-src=\"/2022/10/07/SpringSecurity/springSecurity-07.jpg\" class=\"\">\n\n\n<p>​\t此处的用户名应该是客户端传递过来的用户名。而密码应该是从数据库中查询出来的密码。Spring Security会根据User中的password和客户端传递过来的password进行比较。如果相同则表示认证通过，如果不相同表示认证失败。</p>\n<p>​\tauthorities里面的权限对于后面学习授权是很有必要的，包含的所有内容为此用户具有的权限，如有里面没有包含某个权限，而在做某个事情时必须包含某个权限则会出现403。&#x3D;&#x3D;通常都是通过AuthorityUtils.commaSeparatedStringToAuthorityList(“”)来创建authorities集合对象的&#x3D;&#x3D;。参数是一个字符串，&#x3D;&#x3D;多个权限使用逗号分隔，角色信息前要加<font color=blue>  ROLE_  </font>来标识不然会当成权限信息处理&#x3D;&#x3D;。</p>\n<p><strong>建议</strong></p>\n<blockquote>\n<p>​\t我们的项目中对于用户信息的表，肯定是不同的，我们可以利用这个类，对于用来认证的UserDetails对象进行进一步封装，自定义我们的认证对象。例如：</p>\n<pre><code class=\"java\">package com.zjj.pojo;\n\nimport com.alibaba.fastjson.annotation.JSONField;\nimport lombok.AllArgsConstructor;\nimport lombok.Data;\nimport lombok.NoArgsConstructor;\nimport lombok.ToString;\nimport org.springframework.security.core.GrantedAuthority;\nimport org.springframework.security.core.authority.SimpleGrantedAuthority;\nimport org.springframework.security.core.userdetails.UserDetails;\n\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.stream.Collectors;\n\n@AllArgsConstructor\n@NoArgsConstructor\n@Data\n@ToString\npublic class LoginUser implements UserDetails &#123;\n    private User user;\n\n    private List&lt;String&gt; permission;\n\n    public LoginUser(User user, List&lt;String&gt; permission) &#123;\n        this.user = user;\n        this.permission = permission;\n    &#125;\n\n    @JSONField(serialize = false) //redis存储的话会出现问题，不让他序列化，主要为了安全\n    List&lt;SimpleGrantedAuthority&gt; authorities ;\n    @Override\n    public Collection&lt;? extends GrantedAuthority&gt; getAuthorities() &#123;\n        // 把permission中的String类型的权限信息封装成 SimpleGrantedAuthority 对象\n        if (null != authorities) return authorities;//要是有信息就不用再授权了\n        authorities = permission.stream()\n                .map(SimpleGrantedAuthority::new)\n                .collect(Collectors.toList());\n        return authorities;\n    &#125;\n\n    @Override\n    public String getPassword() &#123;\n        return user.getPassword();\n    &#125;\n\n    @Override\n    public String getUsername() &#123;\n        return user.getUsername();\n    &#125;\n\n    @Override\n    public boolean isAccountNonExpired() &#123;\n        return true;\n    &#125;\n\n    @Override\n    public boolean isAccountNonLocked() &#123;\n        return true;\n    &#125;\n\n    @Override\n    public boolean isCredentialsNonExpired() &#123;\n        return true;\n    &#125;\n\n    @Override\n    public boolean isEnabled() &#123;\n        return true;\n    &#125;\n&#125;\n</code></pre>\n<p>​\t这里只是一个例子，我重写了getAuthorities() ，其他的信息我们可以根据我们自己的数据库的User信息进行初始化，这里我为了测试方便其余都事 TRUE 打开了他们的权限</p>\n<p>​\t这里我自定义个 permission 用来存储我们查询到的权限信息，用它来对authorities来初始化 以及对getAuthorities() 的重写，authorities 是我们根据SpringSecurity 要求封装的权限集合 ，但是要注意，不要让他存储到redis中，redis存储的话会出现问题，不要让他序列化，主要为了安全。</p>\n<p>​\t这样我们每次认证的时候就直接可以利用这个认证对象，而我们的原生User还可以进行别的操作，这样做更加灵活。&#x3D;&#x3D;推荐********&#x3D;&#x3D;</p>\n</blockquote>\n<h2 id=\"2-方法参数\"><a href=\"#2-方法参数\" class=\"headerlink\" title=\"2.方法参数\"></a>2.方法参数</h2><p>​\t方法参数表示用户名。此值是客户端表单传递过来的数据。默认情况下必须叫username，否则无法接收。</p>\n<h2 id=\"3-异常\"><a href=\"#3-异常\" class=\"headerlink\" title=\"3.异常\"></a>3.异常</h2><p>​\tUsernameNotFoundException 用户名没有发现异常。在loadUserByUsername中是需要通过自己的逻辑从数据库中取值的。如果通过用户名没有查询到对应的数据，应该抛出UsernameNotFoundException，系统就知道用户名没有查询到。</p>\n<h1 id=\"五、配置类说明-1-—-认证配置\"><a href=\"#五、配置类说明-1-—-认证配置\" class=\"headerlink\" title=\"五、配置类说明 1 — 认证配置\"></a>五、配置类说明 1 — 认证配置</h1><h2 id=\"1-失败跳转\"><a href=\"#1-失败跳转\" class=\"headerlink\" title=\"1.失败跳转\"></a>1.失败跳转</h2><p>​\t表单处理中成功会跳转到一个地址，失败也可以跳转到一个地址中。</p>\n<h3 id=\"1-1编写页面\"><a href=\"#1-1编写页面\" class=\"headerlink\" title=\"1.1编写页面\"></a>1.1编写页面</h3><p>​\t在src&#x2F;main&#x2F;resources&#x2F;static下新建fail.html并编写如下内容</p>\n<pre><code class=\"html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n    &lt;head&gt;\n        &lt;meta charset=&quot;UTF-8&quot;&gt;\n        &lt;title&gt;Title&lt;/title&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n        操作失败，请重新登录. &lt;a href=&quot;/login.html&quot;&gt;跳转&lt;/a&gt;\n    &lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<h3 id=\"1-2修改表单配置\"><a href=\"#1-2修改表单配置\" class=\"headerlink\" title=\"1.2修改表单配置\"></a>1.2修改表单配置</h3><p>​\t在配置方法中表单认证部分添加failureForwardUrl()方法，表示登录失败跳转的url。此处依然是POST请求，所以跳转到可以接收POST请求的控制器&#x2F;fail中。</p>\n<pre><code class=\"java\">// 表单认证\nhttp.formLogin()\n    .loginProcessingUrl(&quot;/login&quot;)   //当发现/login时认为是登录，需要执行UserDetailsServiceImpl\n    .successForwardUrl(&quot;/toMain&quot;)   //此处是post请求\n    .failureForwardUrl(&quot;/fail&quot;)     //登录失败跳转地址\n    .loginPage(&quot;/login.html&quot;);\n</code></pre>\n<h3 id=\"1-3添加控制器方法\"><a href=\"#1-3添加控制器方法\" class=\"headerlink\" title=\"1.3添加控制器方法\"></a>1.3添加控制器方法</h3><p>​\t在控制器类中添加控制器方法，方法映射路径&#x2F;fail。此处要注意：由于是POST请求访问&#x2F;fail。所以如果返回值直接转发到fail.html中，及时有效果，控制台也会报警告，提示fail.html不支持POST访问方式。</p>\n<pre><code class=\"java\">@PostMapping(&quot;/fail&quot;)\npublic String fail()&#123;\n    return &quot;redirect:/fail.html&quot;;\n&#125;\n</code></pre>\n<h3 id=\"1-4设置fail-html不需要认证\"><a href=\"#1-4设置fail-html不需要认证\" class=\"headerlink\" title=\"1.4设置fail.html不需要认证\"></a>1.4设置fail.html不需要认证</h3><p>​\t认证失败跳转到fail.html页面中，所以必须配置fail.html不需要被认证。需要修改配置类中内容</p>\n<pre><code class=\"java\">// url 拦截\nhttp.authorizeRequests()\n        .antMatchers(&quot;/login.html&quot;).permitAll() //login.html不需要被认证\n        .antMatchers(&quot;/fail.html&quot;).permitAll()  //fail.html不需要被认证\n        .anyRequest().authenticated();//所有的请求都必须被认证。必须登录后才能访问。\n</code></pre>\n<h2 id=\"2-设置请求账户和密码的参数名\"><a href=\"#2-设置请求账户和密码的参数名\" class=\"headerlink\" title=\"2.设置请求账户和密码的参数名\"></a>2.设置请求账户和密码的参数名</h2><h3 id=\"2-1源码简介\"><a href=\"#2-1源码简介\" class=\"headerlink\" title=\"2.1源码简介\"></a>2.1源码简介</h3><p>​\t当进行登录时会执行UsernamePasswordAuthenticationFilter过滤器。</p>\n<p>​\tusernamePasrameter:账户参数名</p>\n<p>​\tpasswordParameter:密码参数名</p>\n<p>​\tpostOnly&#x3D;true:默认情况下只允许POST请求。</p>\n<img data-src=\"/2022/10/07/SpringSecurity/springSecurity-10-1661413396371.jpg\" class=\"\">\n\n\n<h3 id=\"2-2修改配置\"><a href=\"#2-2修改配置\" class=\"headerlink\" title=\"2.2修改配置\"></a>2.2修改配置</h3><pre><code class=\"java\">// 表单认证\nhttp.formLogin()\n        .loginProcessingUrl(&quot;/login&quot;)   //当发现/login时认为是登录，需要执行UserDetailsServiceImpl\n        .successForwardUrl(&quot;/toMain&quot;)   //此处是post请求\n        .failureForwardUrl(&quot;/fail&quot;)     //登录失败跳转地址\n        .loginPage(&quot;/login.html&quot;)\n        .usernameParameter(&quot;myusername&quot;)\n        .passwordParameter(&quot;mypassword&quot;);\n</code></pre>\n<h3 id=\"2-3修改页面\"><a href=\"#2-3修改页面\" class=\"headerlink\" title=\"2.3修改页面\"></a>2.3修改页面</h3><p>​\t修改login.html</p>\n<pre><code class=\"html\">&lt;form action = &quot;/login&quot; method=&quot;post&quot;&gt;\n    用户名：&lt;input type=&quot;text&quot; name=&quot;myusername&quot;/&gt;&lt;br/&gt;\n    密码:&lt;input type=&quot;password&quot; name=&quot;mypassword&quot;/&gt;&lt;br/&gt;\n    &lt;input type=&quot;submit&quot; value=&quot;登录&quot;/&gt;\n&lt;/form&gt;\n</code></pre>\n<h2 id=\"3-自定义登录成功处理器\"><a href=\"#3-自定义登录成功处理器\" class=\"headerlink\" title=\"3.自定义登录成功处理器\"></a>3.自定义登录成功处理器</h2><h3 id=\"3-1源码分析\"><a href=\"#3-1源码分析\" class=\"headerlink\" title=\"3.1源码分析\"></a>3.1源码分析</h3><p>​\t使用successForwardUrl()时表示成功后转发请求到地址。内部是通过successHandler（）方法进行控制成功后交给哪个类进行处理</p>\n<img data-src=\"/2022/10/07/SpringSecurity/springSecurity-11-1661413396370.jpg\" class=\"\">\n\n\n<p>​\tForwardAuthenticationSuccessHandler内部就是最简单的请求转发。由于是请求转发，当遇到需要跳转到站外或在前后端分离的项目中就无法使用了。</p>\n<img data-src=\"/2022/10/07/SpringSecurity/springSecurity-12-1661413396371.jpg\" class=\"\">\n\n\n<p>​\t当需要控制登录成功后去做一些事情时，可以进行自定义认证成功控制器。</p>\n<h3 id=\"3-2代码实现\"><a href=\"#3-2代码实现\" class=\"headerlink\" title=\"3.2代码实现\"></a>3.2代码实现</h3><h4 id=\"3-2-1自定义类\"><a href=\"#3-2-1自定义类\" class=\"headerlink\" title=\"3.2.1自定义类\"></a>3.2.1自定义类</h4><p>​\t新建类MyAuthenticationSuccessHandler 实现 AuthenticationSuccessHandler ，编写如下：</p>\n<pre><code class=\"java\">public class MyAuthenticationSuccessHandler implements AuthenticationSuccessHandler &#123;\n    @Override\n    public void onAuthenticationSuccess(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Authentication authentication) throws IOException, ServletException &#123;\n        //Principal 主体，存放了登录用户的信息\n        User user = (User)authentication.getPrincipal();\n        System.out.println(user.getUsername());\n        System.out.println(user.getPassword());//密码输出为null\n        System.out.println(user.getAuthorities());\n        //重定向到百度。这只是一个示例，具体需要看项目业务需求\n        httpServletResponse.sendRedirect(&quot;http://www.baidu.com&quot;);\n    &#125;\n&#125;\n</code></pre>\n<h4 id=\"3-2-2修改配置项\"><a href=\"#3-2-2修改配置项\" class=\"headerlink\" title=\"3.2.2修改配置项\"></a>3.2.2修改配置项</h4><p>使用successHandler()方法设置成功后交给哪个对象进行处理</p>\n<pre><code class=\"java\">// 表单认证\nhttp.formLogin()\n        .loginProcessingUrl(&quot;/login&quot;)   //当发现/login时认为是登录，需要执行UserDetailsServiceImpl\n        .successHandler(new MyAuthenticationSuccessHandler())\n        //.successForwardUrl(&quot;/toMain&quot;)   //此处是post请求\n        .failureForwardUrl(&quot;/fail&quot;)     //登录失败跳转地址\n        .loginPage(&quot;/login.html&quot;);\n</code></pre>\n<h2 id=\"4-自定义登录失败处理器\"><a href=\"#4-自定义登录失败处理器\" class=\"headerlink\" title=\"4.自定义登录失败处理器\"></a>4.自定义登录失败处理器</h2><h3 id=\"4-1源码分析\"><a href=\"#4-1源码分析\" class=\"headerlink\" title=\"4.1源码分析\"></a>4.1源码分析</h3><p>​\tfailureForwardUrl()内部调用的是failureHandler()方法</p>\n<p>​\t<strong>ForwardAuthenticationFailureHandler</strong>中也是一个请求转发，并在request作用域中设置\t\t\t SPRING_SECURITY_LAST_EXCEPTION的key，内容为异常对象。</p>\n<img data-src=\"/2022/10/07/SpringSecurity/springSecurity-14.jpg\" class=\"\">\n\n\n<h3 id=\"4-2代码实现\"><a href=\"#4-2代码实现\" class=\"headerlink\" title=\"4.2代码实现\"></a>4.2代码实现</h3><h4 id=\"4-2-1新建控制器\"><a href=\"#4-2-1新建控制器\" class=\"headerlink\" title=\"4.2.1新建控制器\"></a>4.2.1新建控制器</h4><p>​\t新建MyForwardAuthenticationFailureHandler实现 AuthenticationFailureHandler 。在方法中添加重定向语句</p>\n<pre><code class=\"java\">public class MyForwardAuthenticationFailureHandler implements AuthenticationFailureHandler &#123;\n    @Override\n    public void onAuthenticationFailure(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, AuthenticationException e) throws IOException, ServletException &#123;\n        httpServletResponse.sendRedirect(&quot;/fail.html&quot;);\n    &#125;\n&#125;\n</code></pre>\n<h4 id=\"4-2-2修改配置类\"><a href=\"#4-2-2修改配置类\" class=\"headerlink\" title=\"4.2.2修改配置类\"></a>4.2.2修改配置类</h4><p>​\t修改配置类中表单登录部分。设置失败时交给失败处理器进行操作。failureForwardUrl和failureHandler不可共存。</p>\n<pre><code class=\"java\">        // 表单认证\n        http.formLogin()\n                .loginProcessingUrl(&quot;/login&quot;)   //当发现/login时认为是登录，需要执行UserDetailsServiceImpl\n                .successHandler(new MyAuthenticationSuccessHandler())\n                //.successForwardUrl(&quot;/toMain&quot;)   //此处是post请求\n                .failureHandler(new MyForwardAuthenticationFailureHandler())\n//                .failureForwardUrl(&quot;/fail&quot;)     //登录失败跳转地址\n                .loginPage(&quot;/login.html&quot;);\n</code></pre>\n<h2 id=\"5-总结\"><a href=\"#5-总结\" class=\"headerlink\" title=\"5 总结\"></a>5 总结</h2><pre><code class=\"java\">        // http.formLogin() 所有和表单有关系的\n        http.formLogin()\n                // 登录页面，走一个controller\n                // 注意要和，LoginProcessingUrl 配合使用，不然在表单中的action中 url 失效\n                // 因为只配置loginPage()， 会导致在初始化的时候将loginProcessingUrl的配置相同化，可以自己debug 在AbstractAuthenticationFilterConfigurer 的 updateAuthenticationDefaults 方法\n                // 也就是说loginPage(&quot;/login&quot;)  loginProcessingUrl(&quot;/login&quot;),导致提交信息失败最终导致认证失败\n                .loginPage(&quot;/showLogin&quot;)\n                // 当发现什么URL时，把请求转发给自定义登录逻辑\n                // 表单提交的地址 action ,他就会直接去认证进入到 UserDetailsServiceImpl\n                // 去这里进行用户的验证 和 用户权限信息的集体封装\n                .loginProcessingUrl(&quot;/login&quot;)\n            \n                // 登录成功的操作\n                // 下面两种方法都可以，推荐第二种，两种同时写第一个直接失效\n                // 第一种写法，要注意在写映射的时候要注意请求的方法 get/post\n                .successForwardUrl(&quot;/showMain&quot;)\n                .successHandler((request, response, authentication) -&gt; &#123;\n                    System.out.println(&quot;successHandler invoked&quot;);\n                    // 我们在每次请求同一个页面尽量使用重定向，要是请求转发\n                    // 因为请求转发是浏览器的行为，每次都要请求服务器并且重复提交表单，不好\n                    // response.sendRedirect(&quot;/fail&quot;);\n                    LoginUser loginUser = (LoginUser) authentication.getPrincipal();\n                    for (String s : loginUser.getPermission()) &#123;\n                        System.out.println(s);\n                    &#125;\n                &#125;)\n                // 登录失败的操作\n                // 内容和上述情况相同，只是一个成功的一个失败的\n                .failureForwardUrl(&quot;/fail&quot;)\n                // 当前端表单传递过来的用户名参数、密码参数名和后端不对应，可以利用下列方法\n                // 指定前端传递过来的用户名参数名称\n                //.usernameParameter(&quot;MyuserName&quot;)\n                // 指定前端传递过来的密码参数名称\n                // .passwordParameter(&quot;MypassWord&quot;)\n        ;\n</code></pre>\n<h1 id=\"六、用户授权\"><a href=\"#六、用户授权\" class=\"headerlink\" title=\"六、用户授权\"></a>六、用户授权</h1><h2 id=\"1-权限系统的作用\"><a href=\"#1-权限系统的作用\" class=\"headerlink\" title=\"1 权限系统的作用\"></a>1 权限系统的作用</h2><p>​\t例如一个学校图书馆的管理系统，如果是普通学生登录就能看到借书还书相关的功能，不可能让他看到并且去使用添加书籍信息，删除书籍信息等功能。但是如果是一个图书馆管理员的账号登录了，应该就能看到并使用添加书籍信息，删除书籍信息等功能。</p>\n<p>​\t总结起来就是<a><strong>不同的用户可以使用不同的功能</strong></a>。这就是权限系统要去实现的效果。</p>\n<h2 id=\"2-授权基本流程\"><a href=\"#2-授权基本流程\" class=\"headerlink\" title=\"2 授权基本流程\"></a>2 授权基本流程</h2><p>​\t在SpringSecurity中，会使用默认的<strong>FilterSecurityInterceptor</strong>来进行权限校验。在 <strong>FilterSecurityInterceptor</strong>中会从<strong>SecurityContextHolder</strong>获取其<strong>Authentication</strong>，然后获取其中的权限信息。当前用户是否拥有访问当前资源所需的权限。</p>\n<p>​\t<a>所以我们在项目中只需要把当前登录用户的权限信息也存入Authentication。</a>然后设置我们的资源所需要的权限即可。</p>\n<h2 id=\"3-RBAC权限模型\"><a href=\"#3-RBAC权限模型\" class=\"headerlink\" title=\"3 RBAC权限模型\"></a>3 RBAC权限模型</h2><p>参考博客：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3F6dzc1Mjg5MDkxMy9hcnRpY2xlL2RldGFpbHMvMTI0NDYxOTUy\">https://blog.csdn.net/qzw752890913/article/details/124461952</span></p>\n<p>​\tRBAC（Role Based Access Control，基于角色的访问控制），就是用户通过角色与权限进行关联，而不是直接将权限赋予用户。</p>\n<p>​\t一个用户拥有若干个角色，每个角色拥有若干个权限，这样就构成了“用户-角色-权限”的授权模型。这种授权模型的好处在于，不必每次创建用户时都进行权限分配的操作，只要分配用户相应的角色即可，而且角色的权限变更比用户的权限变更要少得多，减少频繁设置。</p>\n<p>RBAC模型中，用户与角色之间、角色与权限之间，一般是多对多的关系。</p>\n<p>所谓“多对多”，就是双向的一对多。</p>\n<img data-src=\"/2022/10/07/SpringSecurity/image-20220825151716381.png\" class=\"\">\n\n\n<p>​\t</p>\n<h2 id=\"4-授权实现\"><a href=\"#4-授权实现\" class=\"headerlink\" title=\"4 授权实现\"></a>4 授权实现</h2><ul>\n<li>基于配置——在SpringSecurity的配置类中和登录页一样进行权限配置(<font color=red>不推荐，过程繁琐，开发麻烦</font>)</li>\n<li>基于注解——直接可以对我们次处理，也就是对我们的控制层进行权限的设置(<font color=red>强烈推荐</font>)</li>\n</ul>\n<h3 id=\"4-1-基于配置授权\"><a href=\"#4-1-基于配置授权\" class=\"headerlink\" title=\"4.1 基于配置授权\"></a>4.1 基于配置授权</h3><p>这里没什么好说的，从刚开始我们就开始写了权限的认证，就是我们重写的配置类</p>\n<pre><code class=\"java\">// http.authorizeRequests() 所有和授权相关\nhttp.authorizeRequests()\n    // 这里面支持 正则 和 ant表达式\t\n    // anonymous 匿名 没有认证的才可以访问，permitALL 谁都能访问，不需要认证\n    .antMatchers(&quot;/user/login&quot;,&quot;/login&quot;,&quot;/loginPage&quot;).anonymous()\n    .antMatchers(&quot;/js/**&quot;).permitAll()\n    // authenticated 认证了才能访问\n    .anyRequest().authenticated();\n</code></pre>\n<p>这样写，除了静态资源权限需要这么写，其余请求折磨写太麻烦，我们的业务众多，这样写极大的增加了业务开发的负担，再加上静态资源我们都已经前后端分离也就涉及不到他的权限问题，所以这种方式了解就好。主要重点放在注解学习上。</p>\n<h3 id=\"4-2-基于注解授权\"><a href=\"#4-2-基于注解授权\" class=\"headerlink\" title=\"4.2 基于注解授权\"></a>4.2 基于注解授权</h3><h4 id=\"准备阶段\"><a href=\"#准备阶段\" class=\"headerlink\" title=\"准备阶段\"></a>准备阶段</h4><p>​\tSpringSecurity为我们提供了基于注解的权限控制方案，这也是我们项目中主要采用的方式。我们可以使用注解去指定访问对应的资源所需的权限。</p>\n<p>​\t&#x3D;&#x3D;但是要使用它我们需要先开启相关配置。&#x3D;&#x3D;，&#x3D;&#x3D;不打开直接用会 500&#x3D;&#x3D;</p>\n<pre><code class=\"java\">@EnableGlobalMethodSecurity(prePostEnabled = true)//启动类上添加注解\n</code></pre>\n<h4 id=\"找到对应的接口\"><a href=\"#找到对应的接口\" class=\"headerlink\" title=\"找到对应的接口\"></a>找到对应的接口</h4><p>这里我们找到需要授权的接口，对他们进行授权，主要有3个主要注解 </p>\n<ul>\n<li>@Secured</li>\n<li>@PerAuthorize() 、@PostAuthorize</li>\n</ul>\n<p>只要对我们的接口上添加相对应的注解即可，例如</p>\n<pre><code class=\"java\">@Controller\npublic class loginController&#123;\n    @Secured(&quot;ROLE_abc&quot;) //专门用于判断是否具有角色的。能写在方法或类上。参数要以ROLE_开头。\n    @RequestMapping(&quot;/toMain&quot;)\n    public String toMain()&#123;\n        return &quot;redirect:/main.html&quot;;\n    &#125;\n    \n    @RequestMapping(&quot;/hello3&quot;)\n    @ResponseBody\n    // 是方法或类级别注解。\n    @PreAuthorize(&quot;hasAnyAuthority(&#39;demo:delete&#39;)&quot;)\n    public String testThree()&#123;\n        return &quot;success!&quot;;\n    &#125;\n\n    @RequestMapping(&quot;/hello4&quot;)\n    @ResponseBody\n    //  是方法或类级别注解。\n    @PostAuthorize(&quot;hasAnyRole(&#39;ROLE_管理员&#39;)&quot;)\n    public String testFour()&#123;\n        return &quot;success!&quot;;\n    &#125;\n&#125;\n</code></pre>\n<h1 id=\"七、配置类说明-2-—访问控制\"><a href=\"#七、配置类说明-2-—访问控制\" class=\"headerlink\" title=\"七、配置类说明 2 —访问控制\"></a>七、配置类说明 2 —访问控制</h1><p>在前面讲解了认证中所有常用配置，主要是对http.formLogin()进行操作。而在配置类中\t\thttp.authorizeRequests()主要是对url进行控制，也就是我们所说的授权（访问控制）。http.authorizeRequests()也支持连缀写法，总体公式为：</p>\n<p>​\turl匹配规则.权限控制方法</p>\n<p>通过上面的公式可以有很多url匹配规则和很多权限控制方法。这些内容进行各种组合就形成了Spring Security中的授权。</p>\n<p>​\t在所有匹配规则中取所有规则的交集。配置顺序影响了之后授权效果，越是具体的应该放在前面，越是笼统的应该放到后面。\t</p>\n<h2 id=\"1-anyRequest\"><a href=\"#1-anyRequest\" class=\"headerlink\" title=\"1.anyRequest()\"></a>1.anyRequest()</h2><p>​\t在之前认证过程中我们就已经使用过anyRequest()，表示匹配所有的请求。一般情况下此方法都会使用，设置全部内容都需要进行认证。</p>\n<p>​\t代码示例:</p>\n<pre><code class=\"java\">anyRequest().authenticated();\n</code></pre>\n<h2 id=\"2-antMatcher\"><a href=\"#2-antMatcher\" class=\"headerlink\" title=\"2.antMatcher()\"></a>2.antMatcher()</h2><p>​\t方法定义如下：</p>\n<pre><code class=\"java\">public C antMatchers(String... antPatterns)\n</code></pre>\n<p>​\t参数是不定向参数，每个参数是一个 正则&#x2F;ant表达式，用于匹配URL规则。</p>\n<p>​\t规则如下：</p>\n<p>​\t? 匹配一个字符</p>\n<p>​\t* 匹配0个或多个字符</p>\n<p>​\t** 匹配0个或多个目录</p>\n<p>​\t在实际项目中经常需要放行所有静态资源，下面演示放行js文件夹下所有脚本文件。</p>\n<pre><code class=\"java\">.antMatchers(&quot;/js/**&quot;).permitAll()\n</code></pre>\n<p>还有一种配置方式是只要是.js文件都放行</p>\n<pre><code class=\"java\">antMatchers(&quot;/**/*.js&quot;).permitAll()\n</code></pre>\n<h2 id=\"3-regexMatchers\"><a href=\"#3-regexMatchers\" class=\"headerlink\" title=\"3.regexMatchers()\"></a>3.regexMatchers()</h2><h3 id=\"3-1介绍\"><a href=\"#3-1介绍\" class=\"headerlink\" title=\"3.1介绍\"></a>3.1介绍</h3><p>使用正则表达式进行匹配。和antMatchers()主要的区别就是参数，antMatchers()参数是ant表达式，regexMatchers()参数是正则表达式。</p>\n<p>演示所有以.js结尾的文件都被放行。</p>\n<pre><code class=\"java\">.regexMatchers(&quot;.+[.]js&quot;).permitAll()\n</code></pre>\n<h3 id=\"3-2两个参数时使用方式\"><a href=\"#3-2两个参数时使用方式\" class=\"headerlink\" title=\"3.2两个参数时使用方式\"></a>3.2两个参数时使用方式</h3><p>无论是antMatchers()还是regexMatchers()都具有两个参数的方法，其中第一个参数都是HttpMethod，表示请求方式，当设置了HttpMethod后表示只有设定的特定的请求方式才执行对应的权限设置。</p>\n<p>枚举类型HttpMethod内置属性如下：</p>\n<img data-src=\"/2022/10/07/SpringSecurity/springSecurity-15.jpg\" class=\"\">\n\n\n<h2 id=\"4-内置访问控制方法介绍\"><a href=\"#4-内置访问控制方法介绍\" class=\"headerlink\" title=\"4 内置访问控制方法介绍\"></a>4 内置访问控制方法介绍</h2><p>​\tSpring Security匹配了URL后调用了permitAll()表示不需要认证，随意访问。在Spring Security中提供了多种内置控制。</p>\n<h3 id=\"1-permitAll\"><a href=\"#1-permitAll\" class=\"headerlink\" title=\"1.permitAll()\"></a>1.permitAll()</h3><p>​\t<strong>permitAll()表示所匹配的URL任何人都允许访问。</strong></p>\n<h3 id=\"2-authenticated\"><a href=\"#2-authenticated\" class=\"headerlink\" title=\"2.authenticated()\"></a>2.authenticated()</h3><p>​\t<strong>authenticated()表示所匹配的URL都需要被认证才能访问。</strong></p>\n<h3 id=\"3-anonymous\"><a href=\"#3-anonymous\" class=\"headerlink\" title=\"3.anonymous()\"></a>3.anonymous()</h3><p>​\t<strong>anonymous()表示可以匿名访问匹配的URL。和permitAll()效果类似，只是设置为anonymous()的url会执行filter 链中</strong></p>\n<p>​\t官方源码定义如下：</p>\n<img data-src=\"/2022/10/07/SpringSecurity/springSecurity-18.jpg\" class=\"\">\n\n\n<h3 id=\"4-denyAll\"><a href=\"#4-denyAll\" class=\"headerlink\" title=\"4.denyAll()\"></a>4.denyAll()</h3><p>​\t<strong>denyAll()表示所匹配的URL都不允许被访问。</strong></p>\n<img data-src=\"/2022/10/07/SpringSecurity/springSecurity-19.jpg\" class=\"\">\n\n\n<h3 id=\"5-rememberMe\"><a href=\"#5-rememberMe\" class=\"headerlink\" title=\"5.rememberMe()\"></a>5.rememberMe()</h3><p>​\t<strong>被“remember me”的用户允许访问</strong></p>\n<img data-src=\"/2022/10/07/SpringSecurity/springSecurity-20.jpg\" class=\"\">\n\n\n<h3 id=\"6-fullyAuthenticated\"><a href=\"#6-fullyAuthenticated\" class=\"headerlink\" title=\"6.fullyAuthenticated()\"></a>6.fullyAuthenticated()</h3><p>​\t<strong>如果用户不是被remember me的，才可以访问</strong>。</p>\n<img data-src=\"/2022/10/07/SpringSecurity/springSecurity-21.jpg\" class=\"\">\n\n\n<h3 id=\"7-hasIpAddress-String\"><a href=\"#7-hasIpAddress-String\" class=\"headerlink\" title=\"7.hasIpAddress(String)\"></a>7.hasIpAddress(String)</h3><p>如果请求是指定的IP就运行访问。</p>\n<p>​\t可以通过request.getRemoteAddr()获取ip地址。</p>\n<p>​\t需要注意的是在本机进行测试时localhost和127.0.0.1输出的ip地址是不一样的。</p>\n<p>​\t当浏览器中通过localhost进行访问时控制台打印的内容：</p>\n<img data-src=\"/2022/10/07/SpringSecurity/springSecurity-25-1661415211434.jpg\" class=\"\">\n\n\n<p>​\t当浏览器中通过127.0.0.1访问时控制台打印的内容：</p>\n<img data-src=\"/2022/10/07/SpringSecurity/springSecurity-26-1661415211434.jpg\" class=\"\">\n\n\n<p>​\t当浏览器中通过具体ip进行访问时控制台打印内容：</p>\n<img data-src=\"/2022/10/07/SpringSecurity/springSecurity-27-1606734864126-1661415211434.jpg\" class=\"\">\n\n\n<p>​\t使用Spring Security时经常会看见403（无权限），默认情况下显示的效果如下：</p>\n<img data-src=\"/2022/10/07/SpringSecurity/springSecurity-28-1661415211434.jpg\" class=\"\">\n\n\n<p>​\t而在实际项目中可能都是一个异步请求，显示上述效果对于用户就不是特别友好了。Spring Security支持自定义权限受限。</p>\n<h4 id=\"1-新建类\"><a href=\"#1-新建类\" class=\"headerlink\" title=\"1.新建类\"></a>1.新建类</h4><p>​\t新建类实现<strong>AccessDeniedHandler</strong></p>\n<pre><code class=\"java\">@Component\npublic class MyAccessDeniedHandler implements AccessDeniedHandler &#123;\n    @Override\n    public void handle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, AccessDeniedException e) throws IOException, ServletException &#123;\n        httpServletResponse.setStatus(HttpServletResponse.SC_FORBIDDEN);\n        httpServletResponse.setHeader(&quot;Content-Type&quot;,&quot;application/json;charset=utf-8&quot;);\n        PrintWriter out = httpServletResponse.getWriter();\n        out.write(&quot;&#123;\\&quot;status\\&quot;:\\&quot;error\\&quot;,\\&quot;msg\\&quot;:\\&quot;权限不足，请联系管理员!\\&quot;&#125;&quot;);\n        out.flush();\n        out.close();\n    &#125;\n&#125;\n</code></pre>\n<h4 id=\"2-修改配置类\"><a href=\"#2-修改配置类\" class=\"headerlink\" title=\"2.修改配置类\"></a>2.修改配置类</h4><p>​\t配置类中重点添加异常处理器。设置访问受限后交给哪个对象进行处理。</p>\n<p>​\tmyAccessDeniedHandler是在配置类中进行自动注入的。</p>\n<pre><code class=\"java\">//异常处理\nhttp.exceptionHandling()\n        .accessDeniedHandler(myAccessDeniedHandler);\n</code></pre>\n<h2 id=\"5-总结-1\"><a href=\"#5-总结-1\" class=\"headerlink\" title=\"5 总结\"></a>5 总结</h2><p>在选择特定请求时 2&#x2F;3 任选其一 效果相同，主要注意内置访问控制方法的选择</p>\n<h1 id=\"八、配置类说明-3-—基于表达式的访问控制\"><a href=\"#八、配置类说明-3-—基于表达式的访问控制\" class=\"headerlink\" title=\"八、配置类说明 3 —基于表达式的访问控制\"></a>八、配置类说明 3 —基于表达式的访问控制</h1><h2 id=\"1-access-方法使用\"><a href=\"#1-access-方法使用\" class=\"headerlink\" title=\"1.access()方法使用\"></a>1.access()方法使用</h2><p>​\t之前学习的登录用户权限判断实际上底层实现都是调用access(表达式)</p>\n<img data-src=\"/2022/10/07/SpringSecurity/springSecurity-29.jpg\" class=\"\">\n\n\n<p>​\t可以通过access()实现和之前学习的权限控制完成相同的功能。</p>\n<h3 id=\"1-1以hasRole和permitAll举例\"><a href=\"#1-1以hasRole和permitAll举例\" class=\"headerlink\" title=\"1.1以hasRole和permitAll举例\"></a>1.1以hasRole和permitAll举例</h3><p>​\t下面代码和直接使用permitAll()和hasRole()是等效的。</p>\n<img data-src=\"/2022/10/07/SpringSecurity/springSecurity-30.jpg\" class=\"\">\n\n\n<h2 id=\"2-自定义权限验证方法\"><a href=\"#2-自定义权限验证方法\" class=\"headerlink\" title=\"2.自定义权限验证方法\"></a>2.自定义权限验证方法</h2><p>​\t虽然这里面已经包含了很多的表达式(方法)但是在实际项目中很有可能出现需要自己自定义逻辑的情况。</p>\n<p>​\t判断登录用户是否具有访问当前URL权限。</p>\n<h3 id=\"2-1新建接口及实现类\"><a href=\"#2-1新建接口及实现类\" class=\"headerlink\" title=\"2.1新建接口及实现类\"></a>2.1新建接口及实现类</h3><p>​\t新建接口com.msb.service.MyService后新建实现类。</p>\n<pre><code class=\"java\">public interface MyService &#123;\n    boolean hasPermission(HttpServletRequest request, Authentication authentication);\n&#125;\n</code></pre>\n<pre><code class=\"java\">@Component\npublic class MyServiceImpl implements MyService &#123;\n    @Override\n    public boolean hasPermission(HttpServletRequest request, Authentication authentication) &#123;\n        Object obj = authentication.getPrincipal();\n        if(obj instanceof UserDetails)&#123;\n            UserDetails user = (UserDetails) obj;\n            Collection&lt;? extends GrantedAuthority&gt; authorities = user.getAuthorities();\n            return authorities.contains(new SimpleGrantedAuthority(request.getRequestURI()));\n        &#125;\n        return false;\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"2-2修改配置类\"><a href=\"#2-2修改配置类\" class=\"headerlink\" title=\"2.2修改配置类\"></a>2.2修改配置类</h3><p>​\t在access中通过@bean的id名.方法(参数)的形式进行调用</p>\n<p>​\t配置类中修改如下：</p>\n<pre><code class=\"java\"> // url 拦截 (授权)\nhttp.authorizeRequests()\n        .antMatchers(&quot;/login.html&quot;).access(&quot;permitAll&quot;)\n        .antMatchers(&quot;/fail.html&quot;).permitAll()\n        // @Bean的名字，表示引入某个Bean，我们的Bean在主动命名的情况下，都是以首字母小写命名\n        .anyRequest().access(&quot;@myServiceImpl.hasPermission(request,authentication)&quot;);\n</code></pre>\n<h1 id=\"九、基于注解的访问控制\"><a href=\"#九、基于注解的访问控制\" class=\"headerlink\" title=\"九、基于注解的访问控制\"></a>九、基于注解的访问控制</h1><p>​\t在Spring Security中提供了一些访问控制的注解。这些注解都是默认是都不可用的，需要通过@EnableGlobalMethodSecurity进行开启后使用。</p>\n<p>​\t&#x3D;&#x3D;如果设置的条件允许，程序正常执行。如果不允许会报500&#x3D;&#x3D;</p>\n<p>​\t这些注解可以写到Service接口或方法上上也可以写到Controller或Controller的方法上。通常情况下都是写在控制器方法上的，控制接口URL是否允许被访问。</p>\n<h2 id=\"1-Secured\"><a href=\"#1-Secured\" class=\"headerlink\" title=\"1.@Secured\"></a>1.@Secured</h2><p>​\t@Secured是&#x3D;&#x3D;专门用于判断是否具有角色的&#x3D;&#x3D;。能写在&#x3D;&#x3D;方法或类&#x3D;&#x3D;上。&#x3D;&#x3D;参数要以ROLE_开头&#x3D;&#x3D;。</p>\n<img data-src=\"/2022/10/07/SpringSecurity/springSecurity-32-1661416083118.jpg\" class=\"\">\n\n\n<h3 id=\"1-1实现步骤\"><a href=\"#1-1实现步骤\" class=\"headerlink\" title=\"1.1实现步骤\"></a>1.1实现步骤</h3><h4 id=\"1-1-1-开启注解\"><a href=\"#1-1-1-开启注解\" class=\"headerlink\" title=\"1.1.1 开启注解\"></a>1.1.1 开启注解</h4><p>​\t在启动类(也可以在配置类等能够扫描的类上)上添加@EnableGlobalMethodSecurity(securedEnabled &#x3D; true)</p>\n<pre><code class=\"java\">@SpringBootApplication\n@EnableGlobalMethodSecurity(securedEnabled = true)\npublic class MyApp &#123;\n    public static void main(String [] args)&#123;\n        SpringApplication.run(MyApp.class,args);\n    &#125;\n&#125;\n</code></pre>\n<h4 id=\"1-1-2在控制器方法上添加-Secured注解\"><a href=\"#1-1-2在控制器方法上添加-Secured注解\" class=\"headerlink\" title=\"1.1.2在控制器方法上添加@Secured注解\"></a>1.1.2在控制器方法上添加@Secured注解</h4><p>​\t在LoginController中方法上添加注解</p>\n<pre><code class=\"java\">@Secured(&quot;ROLE_abc&quot;)\n@RequestMapping(&quot;/toMain&quot;)\npublic String toMain()&#123;\n    return &quot;redirect:/main.html&quot;;\n&#125;\n</code></pre>\n<h4 id=\"1-1-3配置类\"><a href=\"#1-1-3配置类\" class=\"headerlink\" title=\"1.1.3配置类\"></a>1.1.3配置类</h4><p>​\t配置类中方法配置保留最基本的配置即可。</p>\n<pre><code class=\"java\">protected void configure(HttpSecurity http) throws Exception &#123;\n    // 表单认证\n    http.formLogin()\n            .loginProcessingUrl(&quot;/login&quot;)   //当发现/login时认为是登录，需要执行UserDetailsServiceImpl\n            .successForwardUrl(&quot;/toMain&quot;)   //此处是post请求\n            .loginPage(&quot;/login.html&quot;);\n\n    // url 拦截\n    http.authorizeRequests()\n            .antMatchers(&quot;/login.html&quot;).permitAll() //login.html不需要被认证\n            .anyRequest().authenticated();//所有的请求都必须被认证。必须登录后才能访问。\n\n    //关闭csrf防护\n    http.csrf().disable();\n\n&#125;\n</code></pre>\n<h2 id=\"2-PreAuthorize-x2F-PostAuthorize\"><a href=\"#2-PreAuthorize-x2F-PostAuthorize\" class=\"headerlink\" title=\"2.@PreAuthorize&#x2F;@PostAuthorize\"></a>2.@PreAuthorize&#x2F;@PostAuthorize</h2><p>​\t@PreAuthorize和@PostAuthorize都是方法或类级别注解。</p>\n<p>​\t**@PreAuthorize ** 表示访问方法或类在&#x3D;&#x3D;执行之前先判断权限&#x3D;&#x3D;，大多情况下都是使用这个注解，注解的参数和access()方法参数取值相同，都是权限表达式。</p>\n<p>​\t@<strong>PostAuthorize</strong> 表示&#x3D;&#x3D;方法或类执行结束后判断权限&#x3D;&#x3D;，此注解很少被使用到。</p>\n<img data-src=\"/2022/10/07/SpringSecurity/image-20220825155542682.png\" class=\"\">\n\n\n<h3 id=\"2-1实现步骤\"><a href=\"#2-1实现步骤\" class=\"headerlink\" title=\"2.1实现步骤\"></a>2.1实现步骤</h3><h4 id=\"2-1-1开启注解\"><a href=\"#2-1-1开启注解\" class=\"headerlink\" title=\"2.1.1开启注解\"></a>2.1.1开启注解</h4><p>​\t在启动类中开启@PreAuthorize注解。</p>\n<pre><code class=\"java\">@SpringBootApplication\n@EnableGlobalMethodSecurity(prePostEnabled = true)\npublic class MyApp &#123;\n    public static void main(String [] args)&#123;\n        SpringApplication.run(MyApp.class,args);\n    &#125;\n&#125;\n</code></pre>\n<h4 id=\"2-1-2添加-PreAuthorize\"><a href=\"#2-1-2添加-PreAuthorize\" class=\"headerlink\" title=\"2.1.2添加@PreAuthorize\"></a>2.1.2添加@PreAuthorize</h4><p>​\t在控制器方法上添加@PreAuthorize，参数可以是任何access()支持的表达式</p>\n<pre><code class=\"java\">@PreAuthorize(&quot;hasRole(&#39;abc&#39;)&quot;)\n@RequestMapping(&quot;/toMain&quot;)\npublic String toMain()&#123;\n    return &quot;redirect:/main.html&quot;;\n&#125;\n</code></pre>\n<h2 id=\"3-自定义权限校验方法-针对Pre注解\"><a href=\"#3-自定义权限校验方法-针对Pre注解\" class=\"headerlink\" title=\"3.自定义权限校验方法(针对Pre注解)\"></a>3.自定义权限校验方法(针对Pre注解)</h2><p>我们如果觉得单纯验证不合适，或者说不符合我们的业务我们也可以自定义方法</p>\n<h3 id=\"其它权限校验方法\"><a href=\"#其它权限校验方法\" class=\"headerlink\" title=\"其它权限校验方法\"></a>其它权限校验方法</h3><p>​\t我们前面都是使用@PreAuthorize注解，然后在在其中使用的是hasAuthority方法进行校验。SpringSecurity还为我们提供了其它方法例如：hasAnyAuthority，hasRole，hasAnyRole等。</p>\n<p>​\t这里我们先不急着去介绍这些方法，我们先去理解hasAuthority的原理，然后再去学习其他方法你就更容易理解，而不是死记硬背区别。并且我们也可以选择定义校验方法，实现我们自己的校验逻辑。</p>\n<p>​\t<strong>hasAuthority</strong>方法实际是执行到了<strong>SecurityExpressionRoot</strong>的<strong>hasAuthority</strong>，大家只要断点调试既可知道它内部的校验原理。</p>\n<p>​\t它内部其实是调用<strong>authentication</strong>的<strong>getAuthorities</strong>方法获取用户的权限列表。然后判断我们存入的方法参数数据在权限列表中。</p>\n<p>​\t<strong>hasAnyAuthority</strong>方法可以传入多个权限，只有用户有其中任意一个权限都可以访问对应资源。</p>\n<pre><code class=\"java\">    @PreAuthorize(&quot;hasAnyAuthority(&#39;admin&#39;,&#39;test&#39;,&#39;system:dept:list&#39;)&quot;)\n    public String hello()&#123;\n        return &quot;hello&quot;;\n    &#125;\n</code></pre>\n<p>​\t<strong>hasRole</strong>要求有对应的角色才可以访问，但是它内部会把我们传入的参数拼接上 <strong>ROLE_</strong> 后再去比较。所以这种情况下要用用户对应的权限也要有 <strong>ROLE_</strong> 这个前缀才可以。</p>\n<pre><code class=\"java\">    @PreAuthorize(&quot;hasRole(&#39;system:dept:list&#39;)&quot;)\n    public String hello()&#123;\n        return &quot;hello&quot;;\n    &#125;\n</code></pre>\n<p>​\t<strong>hasAnyRole</strong> 有任意的角色就可以访问。它内部也会把我们传入的参数拼接上 <strong>ROLE_</strong> 后再去比较。所以这种情况下要用用户对应的权限也要有 <strong>ROLE_</strong> 这个前缀才可以。</p>\n<pre><code class=\"java\">    @PreAuthorize(&quot;hasAnyRole(&#39;admin&#39;,&#39;system:dept:list&#39;)&quot;)\n    public String hello()&#123;\n        return &quot;hello&quot;;\n    &#125;\n</code></pre>\n<h3 id=\"自定义权限校验方法\"><a href=\"#自定义权限校验方法\" class=\"headerlink\" title=\"自定义权限校验方法\"></a>自定义权限校验方法</h3><p>​\t我们也可以定义自己的权限校验方法，在@PreAuthorize注解中使用我们的方法。</p>\n<pre><code class=\"java\">@Component(&quot;ex&quot;)\npublic class MyExpressionRoot &#123;\n    // 一定要返回一个Bool值\n    public boolean hasAuthority(String authority)&#123;\n        //获取当前用户的权限\n        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();\n        LoginUser loginUser = (LoginUser) authentication.getPrincipal();\n        List&lt;String&gt; permissions = loginUser.getPermissions();\n        //判断用户权限集合中是否存在authority\n        return permissions.contains(authority);\n    &#125;\n&#125;\n</code></pre>\n<p>​\t <strong>在SPEL表达式中使用 @ex相当于获取容器中bean的名字为ex的对象。然后再调用这个对象的hasAuthority方法</strong></p>\n<pre><code class=\"java\">    @RequestMapping(&quot;/hello&quot;)\n    @PreAuthorize(&quot;@ex.hasAuthority(&#39;system:dept:list&#39;)&quot;)\n    public String hello()&#123;\n        return &quot;hello&quot;;\n    &#125;\n</code></pre>\n<h1 id=\"十、自定义失败处理\"><a href=\"#十、自定义失败处理\" class=\"headerlink\" title=\"十、自定义失败处理\"></a>十、自定义失败处理</h1><p>​\t我们还希望在认证失败或者是授权失败的情况下也能和我们的接口一样返回相同结构的json，这样可以让前端能对响应进行统一的处理。要实现这个功能我们需要知道SpringSecurity的异常处理机制。</p>\n<p>​\t在SpringSecurity中，如果我们在认证或者授权的过程中出现了异常会被ExceptionTranslationFilter捕获到。在ExceptionTranslationFilter中会去判断是认证失败还是授权失败出现的异常。</p>\n<p>​\t如果是&#x3D;&#x3D;认证过程中出现的异常&#x3D;&#x3D;会被封装成<strong>AuthenticationException</strong>然后调用<strong>AuthenticationEntryPoint</strong>对象的方法去进行异常处理。</p>\n<p>​\t如果是&#x3D;&#x3D;授权过程中出现的异常&#x3D;&#x3D;会被封装成<strong>AccessDeniedException</strong>然后调用<strong>AccessDeniedHandler</strong>对象的方法去进行异常处理。</p>\n<p>​\t所以如果我们&#x3D;&#x3D;需要自定义异常处理&#x3D;&#x3D;，我们只需要&#x3D;&#x3D;自定义AuthenticationEntryPoint和AccessDeniedHandler然后配置给SpringSecurity即可&#x3D;&#x3D;。</p>\n<h2 id=\"①自定义实现类\"><a href=\"#①自定义实现类\" class=\"headerlink\" title=\"①自定义实现类\"></a>①自定义实现类</h2><pre><code class=\"java\">@Component\npublic class AccessDeniedHandlerImpl implements AccessDeniedHandler &#123;\n    @Override\n    public void handle(HttpServletRequest request, HttpServletResponse response, AccessDeniedException accessDeniedException) throws IOException, ServletException &#123;\n        ResponseResult result = new ResponseResult(HttpStatus.FORBIDDEN.value(), &quot;权限不足&quot;);\n        String json = JSON.toJSONString(result);\n        WebUtils.renderString(response,json);\n    &#125;\n&#125;\n</code></pre>\n<pre><code class=\"java\">@Component\npublic class AuthenticationEntryPointImpl implements AuthenticationEntryPoint &#123;\n    @Override\n    public void commence(HttpServletRequest request, HttpServletResponse response, AuthenticationException authException) throws IOException, ServletException &#123;\n        ResponseResult result = new ResponseResult(HttpStatus.UNAUTHORIZED.value(), &quot;认证失败请重新登录&quot;);\n        String json = JSON.toJSONString(result);\n        WebUtils.renderString(response,json);\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"②配置给SpringSecurity\"><a href=\"#②配置给SpringSecurity\" class=\"headerlink\" title=\"②配置给SpringSecurity\"></a>②配置给SpringSecurity</h2><p>​\t先注入对应的处理器</p>\n<pre><code class=\"java\">    @Autowired\n    private AuthenticationEntryPoint authenticationEntryPoint;\n\n    @Autowired\n    private AccessDeniedHandler accessDeniedHandler;\n</code></pre>\n<p>​\t然后我们可以使用HttpSecurity对象的方法去配置。</p>\n<pre><code class=\"java\">        http.exceptionHandling()\n            .authenticationEntryPoint(authenticationEntryPoint)\n            .accessDeniedHandler(accessDeniedHandler);\n</code></pre>\n<h1 id=\"十一、Remember-Me功能实现\"><a href=\"#十一、Remember-Me功能实现\" class=\"headerlink\" title=\"十一、Remember Me功能实现\"></a>十一、Remember Me功能实现</h1><p>​\tSpring Security 中Remember Me为“记住我”功能，用户只需要在登录时添加remember-me复选框，取值为true。Spring Security会自动把用户信息存储到数据源中，以后就可以不登录进行访问。</p>\n<h2 id=\"1-添加依赖\"><a href=\"#1-添加依赖\" class=\"headerlink\" title=\"1.添加依赖\"></a>1.添加依赖</h2><p>​\tSpring Security实现Remember Me 功能时底层实现依赖Spring-JDBC，所以需要导入Spring-JDBC。以后多使用MyBatis框架而很少直接导入spring-jdbc，所以此处导入mybatis启动器</p>\n<p>同时还需要添加MySQL驱动</p>\n<pre><code class=\"xml\">&lt;dependency&gt;\n    &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;\n    &lt;version&gt;2.1.1&lt;/version&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;mysql&lt;/groupId&gt;\n    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;\n    &lt;version&gt;5.1.6&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>\n<h2 id=\"2-配置数据源\"><a href=\"#2-配置数据源\" class=\"headerlink\" title=\"2.配置数据源\"></a>2.配置数据源</h2><p>​\t在application.properties中配置数据源。请确保数据库中已经存在security数据库</p>\n<pre><code class=\"properties\">spring.datasource.driver-class-name=com.mysql.jdbc.Driver\nspring.datasource.url=jdbc:mysql://127.0.0.1:3306/mashibing\nspring.datasource.username=root\nspring.datasource.password=root\n</code></pre>\n<h2 id=\"3-编写配置\"><a href=\"#3-编写配置\" class=\"headerlink\" title=\"3.编写配置\"></a>3.编写配置</h2><p>​\t新建com.msb.config.RememberMeConfig类，并创建Bean对象</p>\n<pre><code class=\"java\">@Configuration\npublic class RememberMeConfig &#123;\n    @Autowired\n    private DataSource dataSource;\n    @Bean\n    public PersistentTokenRepository getPersistentTokenRepository() &#123;\n        JdbcTokenRepositoryImpl jdbcTokenRepositoryImpl=new JdbcTokenRepositoryImpl();\n        jdbcTokenRepositoryImpl.setDataSource(dataSource);\n        //自动建表，第一次启动时需要，第二次启动时注释掉\n//        jdbcTokenRepositoryImpl.setCreateTableOnStartup(true);\n        return jdbcTokenRepositoryImpl;\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"4-修改SecurityConfig\"><a href=\"#4-修改SecurityConfig\" class=\"headerlink\" title=\"4.修改SecurityConfig\"></a>4.修改SecurityConfig</h2><p>​\t在SecurityConfig中添加RememberMeConfig和UserDetailsService实现类对象，并自动注入。</p>\n<p>​\t在configure中添加下面配置内容。</p>\n<pre><code class=\"java\">http.rememberMe()\n    .userDetailsService(userDetailsService) //登录逻辑交给哪个对象\n    .tokenRepository(repository);   //持久层对象\n</code></pre>\n<h2 id=\"5-在客户端页面中添加复选框\"><a href=\"#5-在客户端页面中添加复选框\" class=\"headerlink\" title=\"5.在客户端页面中添加复选框\"></a>5.在客户端页面中添加复选框</h2><p>​\t在客户端登录页面中添加remember-me的复选框，只要用户勾选了复选框下次就不需要进行登录了。</p>\n<pre><code class=\"html\">&lt;form action = &quot;/login&quot; method=&quot;post&quot;&gt;\n    用户名：&lt;input type=&quot;text&quot; name=&quot;username&quot;/&gt;&lt;br/&gt;\n    密码:&lt;input type=&quot;text&quot; name=&quot;password&quot;/&gt;&lt;br/&gt;\n    &lt;input type=&quot;checkbox&quot; name=&quot;remember-me&quot; value=&quot;true&quot;/&gt; &lt;br/&gt;\n    &lt;input type=&quot;submit&quot; value=&quot;登录&quot;/&gt;\n&lt;/form&gt;\n</code></pre>\n<h2 id=\"6-有效时间\"><a href=\"#6-有效时间\" class=\"headerlink\" title=\"6.有效时间\"></a>6.有效时间</h2><p>​\t默认情况下重启项目后登录状态失效了。但是可以通过设置状态有效时间，即使项目重新启动下次也可以正常登录。</p>\n<pre><code class=\"java\">//remember Me\nhttp.rememberMe()\n        .tokenValiditySeconds(120)//单位：秒\n        .tokenRepository(repository)\n        .userDetailsService(userDetailsServiceImpl);\n</code></pre>\n<h1 id=\"十二、Thymeleaf中Spring-Security的使用\"><a href=\"#十二、Thymeleaf中Spring-Security的使用\" class=\"headerlink\" title=\"十二、Thymeleaf中Spring Security的使用\"></a>十二、Thymeleaf中Spring Security的使用</h1><p>​\tSpring Security可以在一些视图技术中进行控制显示效果。例如：JSP或Thymeleaf。在非前后端分离且使用Spring Boot的项目中多使用Thymeleaf作为视图展示技术。</p>\n<p>​\tThymeleaf对Spring Security的支持都放在thymeleaf-extras-springsecurityX中，目前最新版本为5。所以需要在项目中添加此jar包的依赖和thymeleaf的依赖。</p>\n<pre><code class=\"xml\">&lt;dependency&gt;\n    &lt;groupId&gt;org.thymeleaf.extras&lt;/groupId&gt;\n    &lt;artifactId&gt;thymeleaf-extras-springsecurity5&lt;/artifactId&gt;\n    &lt;version&gt;3.0.4.RELEASE&lt;/version&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;\n&lt;/dependency&gt;\n</code></pre>\n<p>​\t在html页面中引入thymeleaf命名空间和security命名空间</p>\n<pre><code class=\"html\">&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;\n      xmlns:th=&quot;http://www.thymeleaf.org&quot;\nxmlns:sec=&quot;http://www.thymeleaf.org/thymeleaf-extras-springsecurity5&quot;&gt;\n</code></pre>\n<h2 id=\"1-获取属性\"><a href=\"#1-获取属性\" class=\"headerlink\" title=\"1.获取属性\"></a>1.获取属性</h2><p>​\t可以在html页面中通过 sec:authentication&#x3D;””获取UsernamePasswordAuthenticationToken中所有getXXX的内容，包含父类中的getXXX的内容。</p>\n<p>​\t根据源码得出下面属性：</p>\n<p>​\tl name：登录账号名称</p>\n<p>​\tl principal：登录主体，在自定义登录逻辑中是UserDet ails</p>\n<p>​\tl credentials：凭证</p>\n<p>​\tl authorities：权限和角色</p>\n<p>​\tl details：实际上是WebAuthenticationDetails的实例。可以获取remoteAddress(客户端ip)和sessionId(当\t前sessionId)</p>\n<h3 id=\"1-1实现步骤：\"><a href=\"#1-1实现步骤：\" class=\"headerlink\" title=\"1.1实现步骤：\"></a>1.1实现步骤：</h3><h4 id=\"1-1-1新建demo-html\"><a href=\"#1-1-1新建demo-html\" class=\"headerlink\" title=\"1.1.1新建demo.html\"></a>1.1.1新建demo.html</h4><p>​\t在项目resources中新建templates文件夹，在templates中新建demo.html页面</p>\n<img data-src=\"/2022/10/07/SpringSecurity/springSecurity-34.jpg\" class=\"\">\n\n\n<h4 id=\"1-1-2编写demo-html\"><a href=\"#1-1-2编写demo-html\" class=\"headerlink\" title=\"1.1.2编写demo.html\"></a>1.1.2编写demo.html</h4><p>​\t在demo.html中编写下面内容，测试获取到的值</p>\n<pre><code class=\"html\">&lt;!DOCTYPE html&gt;\n&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;\n      xmlns:th=&quot;http://www.thymeleaf.org&quot;\n      xmlns:sec=&quot;http://www.thymeleaf.org/thymeleaf-extras-springsecurity5&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;title&gt;Title&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    登录账号:&lt;span sec:authentication=&quot;name&quot;&gt;&lt;/span&gt;&lt;br/&gt;\n    登录账号:&lt;span sec:authentication=&quot;principal.username&quot;&gt;&lt;/span&gt;&lt;br/&gt;\n    凭证：&lt;span sec:authentication=&quot;credentials&quot;&gt;&lt;/span&gt;&lt;br/&gt;\n    权限和角色：&lt;span sec:authentication=&quot;authorities&quot;&gt;&lt;/span&gt;&lt;br/&gt;\n    客户端地址：&lt;span sec:authentication=&quot;details.remoteAddress&quot;&gt;&lt;/span&gt;&lt;br/&gt;\n    sessionId：&lt;span sec:authentication=&quot;details.sessionId&quot;&gt;&lt;/span&gt;&lt;br/&gt;\n&lt;/body&gt;\n&lt;/html&gt;  \n</code></pre>\n<h4 id=\"1-1-3编写控制器\"><a href=\"#1-1-3编写控制器\" class=\"headerlink\" title=\"1.1.3编写控制器\"></a>1.1.3编写控制器</h4><p>​\tthymeleaf页面需要控制转发，在控制器类中编写下面方法</p>\n<pre><code class=\"java\">@RequestMapping(&quot;/demo&quot;)\npublic String demo()&#123;\n    return &quot;demo&quot;;\n&#125;\n</code></pre>\n<h2 id=\"2-权限判断\"><a href=\"#2-权限判断\" class=\"headerlink\" title=\"2.权限判断\"></a>2.权限判断</h2><p>​\t在html页面中可以使用sec:authorize&#x3D;”表达式”进行权限控制，判断是否显示某些内容。表达式的内容和access(表达式)的用法相同。如果用户具有指定的权限，则显示对应的内容；如果表达式不成立，则不显示对应的元素。</p>\n<h3 id=\"2-1不同权限的用户显示不同的按钮\"><a href=\"#2-1不同权限的用户显示不同的按钮\" class=\"headerlink\" title=\"2.1不同权限的用户显示不同的按钮\"></a>2.1不同权限的用户显示不同的按钮</h3><h4 id=\"2-1-1设置用户角色和权限\"><a href=\"#2-1-1设置用户角色和权限\" class=\"headerlink\" title=\"2.1.1设置用户角色和权限\"></a>2.1.1设置用户角色和权限</h4><p>​\t设定用户具有admin，&#x2F;insert，&#x2F;delete权限ROLE_abc角色。</p>\n<pre><code class=\"java\">return new User(username,password, \n                AuthorityUtils.commaSeparatedStringToAuthorityList(&quot;admin,ROLE_abc,/insert,/delete&quot;));\n</code></pre>\n<h4 id=\"2-1-2控制页面显示效果\"><a href=\"#2-1-2控制页面显示效果\" class=\"headerlink\" title=\"2.1.2控制页面显示效果\"></a>2.1.2控制页面显示效果</h4><p>在页面中根据用户权限和角色判断页面中显示的内容</p>\n<pre><code class=\"html\">通过权限判断：\n&lt;button sec:authorize=&quot;hasAuthority(&#39;/insert&#39;)&quot;&gt;新增&lt;/button&gt;\n&lt;button sec:authorize=&quot;hasAuthority(&#39;/delete&#39;)&quot;&gt;删除&lt;/button&gt;\n&lt;button sec:authorize=&quot;hasAuthority(&#39;/update&#39;)&quot;&gt;修改&lt;/button&gt;\n&lt;button sec:authorize=&quot;hasAuthority(&#39;/select&#39;)&quot;&gt;查看&lt;/button&gt;\n&lt;br/&gt;\n通过角色判断：\n&lt;button sec:authorize=&quot;hasRole(&#39;abc&#39;)&quot;&gt;新增&lt;/button&gt;\n&lt;button sec:authorize=&quot;hasRole(&#39;abc&#39;)&quot;&gt;删除&lt;/button&gt;\n&lt;button sec:authorize=&quot;hasRole(&#39;abc&#39;)&quot;&gt;修改&lt;/button&gt;\n&lt;button sec:authorize=&quot;hasRole(&#39;abc&#39;)&quot;&gt;查看&lt;/button&gt;\n</code></pre>\n<h1 id=\"十三、SpringSecurity-的”跨域”问题\"><a href=\"#十三、SpringSecurity-的”跨域”问题\" class=\"headerlink\" title=\"十三、SpringSecurity 的”跨域”问题\"></a>十三、SpringSecurity 的”跨域”问题</h1><p>​\t浏览器出于安全的考虑，使用 XMLHttpRequest对象发起 HTTP请求时必须遵守同源策略，否则就是跨域的HTTP请求，默认情况下是被禁止的。 同源策略要求源相同才能正常进行通信，即协议、域名、端口号都完全一致。 </p>\n<p>​\t前后端分离项目，前端项目和后端项目一般都不是同源的，所以肯定会存在跨域请求的问题。</p>\n<p>​\t所以我们就要处理一下，让前端能进行跨域请求。</p>\n<h2 id=\"①先对SpringBoot配置，运行跨域请求\"><a href=\"#①先对SpringBoot配置，运行跨域请求\" class=\"headerlink\" title=\"①先对SpringBoot配置，运行跨域请求\"></a>①先对SpringBoot配置，运行跨域请求</h2><p>这里的方式多种多想可以 配置类，也可以对跨域的请求直接加注解 ，自己视情况而定</p>\n<pre><code class=\"java\">@Configuration\npublic class CorsConfig implements WebMvcConfigurer &#123;\n\n    @Override\n    public void addCorsMappings(CorsRegistry registry) &#123;\n      // 设置允许跨域的路径\n        registry.addMapping(&quot;/**&quot;)\n                // 设置允许跨域请求的域名\n                .allowedOriginPatterns(&quot;*&quot;)\n                // 是否允许cookie\n                .allowCredentials(true)\n                // 设置允许的请求方式\n                .allowedMethods(&quot;GET&quot;, &quot;POST&quot;, &quot;DELETE&quot;, &quot;PUT&quot;)\n                // 设置允许的header属性\n                .allowedHeaders(&quot;*&quot;)\n                // 跨域允许时间\n                .maxAge(3600);\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"②开启SpringSecurity的跨域访问\"><a href=\"#②开启SpringSecurity的跨域访问\" class=\"headerlink\" title=\"②开启SpringSecurity的跨域访问\"></a>②开启SpringSecurity的跨域访问</h2><p>由于我们的资源都会收到SpringSecurity的保护，所以想要跨域访问还要让SpringSecurity运行跨域访问。</p>\n<pre><code class=\"java\">    @Override\n    protected void configure(HttpSecurity http) throws Exception &#123;\n        http\n                //关闭csrf\n                .csrf().disable()\n                //不通过Session获取SecurityContext\n                .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)\n                .and()\n                .authorizeRequests()\n                // 对于登录接口 允许匿名访问\n                .antMatchers(&quot;/user/login&quot;).anonymous()\n                // 除上面外的所有请求全部需要鉴权认证\n                .anyRequest().authenticated();\n\n        //添加过滤器\n        http.addFilterBefore(jwtAuthenticationTokenFilter, UsernamePasswordAuthenticationFilter.class);\n\n        //配置异常处理器\n        http.exceptionHandling()\n                //配置认证失败处理器\n                .authenticationEntryPoint(authenticationEntryPoint)\n                .accessDeniedHandler(accessDeniedHandler);\n\n        //允许跨域\n        http.cors();\n    &#125;\n</code></pre>\n<h1 id=\"十三、退出登录\"><a href=\"#十三、退出登录\" class=\"headerlink\" title=\"十三、退出登录\"></a>十三、退出登录</h1><p>​\t用户只需要向Spring Security项目中发送&#x2F;logout退出请求即可。</p>\n<h2 id=\"1-退出实现\"><a href=\"#1-退出实现\" class=\"headerlink\" title=\"1.退出实现\"></a>1.退出实现</h2><p>实现退出非常简单，只要在页面中添加&#x2F;logout的超链接即可。</p>\n<pre><code class=\"html\">&lt;a href=&quot;/logout&quot;&gt;退出登录&lt;/a&gt;\n</code></pre>\n<p>​\t为了实现更好的效果，通常添加退出的配置。默认的退出url为&#x2F;logout，退出成功后跳转到&#x2F;login?logout</p>\n<p>​\t如果不希望使用默认值，可以通过下面的方法进行修改。</p>\n<pre><code class=\"java\">http.logout()     \n    .logoutUrl(**&quot;/logout&quot;**)     \n    .logoutSuccessUrl(**&quot;/login.html&quot;**);\n</code></pre>\n<h2 id=\"2-logout其他常用配置源码解读\"><a href=\"#2-logout其他常用配置源码解读\" class=\"headerlink\" title=\"2.logout其他常用配置源码解读\"></a>2.logout其他常用配置源码解读</h2><h3 id=\"2-1-addLogoutHandler-LogoutHandler\"><a href=\"#2-1-addLogoutHandler-LogoutHandler\" class=\"headerlink\" title=\"2.1.addLogoutHandler(LogoutHandler)\"></a>2.1.addLogoutHandler(LogoutHandler)</h3><p>​\t默认是contextLogoutHandler</p>\n<p>​\t默认实例内容</p>\n<img data-src=\"/2022/10/07/SpringSecurity/springSecurity-37.jpg\" class=\"\">\n\n\n<h3 id=\"2-2clearAuthentication-boolean\"><a href=\"#2-2clearAuthentication-boolean\" class=\"headerlink\" title=\"2.2clearAuthentication(boolean)\"></a>2.2clearAuthentication(boolean)</h3><p>​\t是否清除认证状态，默认为true</p>\n<h5 id=\"2-3invalidateHttpSession-boolean\"><a href=\"#2-3invalidateHttpSession-boolean\" class=\"headerlink\" title=\"2.3invalidateHttpSession(boolean)\"></a>2.3invalidateHttpSession(boolean)</h5><p>​\t是否销毁HttpSession对象，默认为true</p>\n<h3 id=\"2-4logoutSuccessHandler-LogoutSuccessHandler\"><a href=\"#2-4logoutSuccessHandler-LogoutSuccessHandler\" class=\"headerlink\" title=\"2.4logoutSuccessHandler(LogoutSuccessHandler)\"></a>2.4logoutSuccessHandler(LogoutSuccessHandler)</h3><p>​\t退出成功处理器。</p>\n<p>​\t也可以自己进行定义退出成功处理器。只要实现了LogoutSuccessHandler接口。与之前讲解的登录成功处理器和登录失败处理器极其类似。</p>\n<h1 id=\"十四、Spring-Security-中-CSRF\"><a href=\"#十四、Spring-Security-中-CSRF\" class=\"headerlink\" title=\"十四、Spring Security 中 CSRF\"></a>十四、Spring Security 中 CSRF</h1><p>​\t从刚开始学习Spring Security时，在配置类中一直存在这样一行代码：http.csrf().disable();如果没有这行代码导致用户无法被认证。这行代码的含义是：关闭csrf防护。</p>\n<h2 id=\"1-什么是CSRF\"><a href=\"#1-什么是CSRF\" class=\"headerlink\" title=\"1.什么是CSRF\"></a>1.什么是CSRF</h2><p>​\tCSRF（Cross-site request forgery）跨站请求伪造，也被称为“One Click Attack” 或者Session Riding。通过伪造用户请求访问受信任站点的非法请求访问。</p>\n<p>​\t跨域：只要网络协议，ip地址，端口中任何一个不相同就是跨域请求。</p>\n<p>​\t客户端与服务进行交互时，由于http协议本身是无状态协议，所以引入了cookie进行记录客户端身份。在cookie中会存放session id用来识别客户端身份的。在跨域的情况下，session id可能被第三方恶意劫持，通过这个session id向服务端发起请求时，服务端会认为这个请求是合法的，可能发生很多意想不到的事情。</p>\n<h2 id=\"2-Spring-Security中CSRF\"><a href=\"#2-Spring-Security中CSRF\" class=\"headerlink\" title=\"2.Spring Security中CSRF\"></a>2.Spring Security中CSRF</h2><p>​\t从Spring Security4开始CSRF防护默认开启。默认会拦截请求。进行CSRF处理。CSRF为了保证不是其他第三方网站访问，要求访问时携带参数名为_csrf值为token(token在服务端产生)的内容，如果token和服务端的token匹配成功，则正常访问。 </p>\n<h3 id=\"2-1实现步骤-1\"><a href=\"#2-1实现步骤-1\" class=\"headerlink\" title=\"2.1实现步骤\"></a>2.1实现步骤</h3><h4 id=\"2-1-1-编写控制器方法\"><a href=\"#2-1-1-编写控制器方法\" class=\"headerlink\" title=\"2.1.1 编写控制器方法\"></a>2.1.1 编写控制器方法</h4><p>​\t编写控制器方法，跳转到templates中login.html页面。</p>\n<pre><code class=\"java\">@GetMapping(&quot;/showLogin&quot;)\npublic String showLogin() &#123;\n    return &quot;login&quot;;\n&#125;\n</code></pre>\n<h4 id=\"2-1-2新建login-html\"><a href=\"#2-1-2新建login-html\" class=\"headerlink\" title=\"2.1.2新建login.html\"></a>2.1.2新建login.html</h4><p>在项目resources下新建templates文件夹，并在文件夹中新建login.html页面。红色部分是必须存在的否则无法正常登录。</p>\n<pre><code class=\"html\">&lt;!DOCTYPE html&gt;\n&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;\n      xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;title&gt;Title&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;form action = &quot;/login&quot; method=&quot;post&quot;&gt;\n    &lt;input type=&quot;hidden&quot; th:value=&quot;$&#123;_csrf.token&#125;&quot; name=&quot;_csrf&quot; th:if=&quot;$&#123;_csrf&#125;&quot;/&gt;\n    用户名：&lt;input type=&quot;text&quot; name=&quot;username&quot;/&gt;&lt;br/&gt;\n    密码:&lt;input type=&quot;password&quot; name=&quot;password&quot;/&gt;&lt;br/&gt;\n    &lt;input type=&quot;submit&quot; value=&quot;登录&quot;/&gt;\n&lt;/form&gt;\n&lt;/body&gt;\n&lt;/html&gt;     \n</code></pre>\n<h4 id=\"2-1-3修改配置类\"><a href=\"#2-1-3修改配置类\" class=\"headerlink\" title=\"2.1.3修改配置类\"></a>2.1.3修改配置类</h4><p>在配置类中注释掉CSRF防护失效</p>\n<pre><code class=\"java\">//关闭csrf防护\n//http.csrf().disable();\n</code></pre>\n",
            "tags": [
                "框架",
                "Spring",
                "SpringSecurity"
            ]
        }
    ]
}