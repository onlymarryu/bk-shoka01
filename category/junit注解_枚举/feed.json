{
    "version": "https://jsonfeed.org/version/1",
    "title": "记录“美食”每刻 • All posts by \"junit注解_枚举\" category",
    "description": "记录“美食”每刻",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/2022/10/07/Java/%E7%AC%AC15%E7%AB%A0Junit%E6%B3%A8%E8%A7%A3_%E6%9E%9A%E4%B8%BE/",
            "url": "http://example.com/2022/10/07/Java/%E7%AC%AC15%E7%AB%A0Junit%E6%B3%A8%E8%A7%A3_%E6%9E%9A%E4%B8%BE/",
            "title": "第15章Junit注解_枚举",
            "date_published": "2022-10-06T16:00:00.000Z",
            "content_html": "<h1 id=\"第15章-Junit-注解-枚举\"><a href=\"#第15章-Junit-注解-枚举\" class=\"headerlink\" title=\"第15章_Junit_注解_枚举\"></a>第15章_Junit_注解_枚举</h1><h1 id=\"Junit单元测试\"><a href=\"#Junit单元测试\" class=\"headerlink\" title=\"Junit单元测试\"></a>Junit单元测试</h1><h2 id=\"引入\"><a href=\"#引入\" class=\"headerlink\" title=\"引入\"></a>引入</h2><p>【1】软件测试的目的：</p>\n<p>软件测试的目的是在规定的条件下对程序进行操作,以发现程序错误,衡量软件质量,并对其是否能满足设计要求进行评估的过程。</p>\n<p>【2】测试分类：</p>\n<p>（1）黑盒测试：</p>\n<p>软件的黑盒测试意味着测试要在软件的接口处进行。这种方法是把测试对象看做一个黑盒子,测试人员完全不考虑程序内部的逻辑结构和内部特性,只依据程序的需求规格说明书,检查程序的功能是否符合它的功能说明。因此黑盒测试又叫功能测试。</p>\n<p>（2）白盒测试：—》Junit属于白盒测试。</p>\n<p>软件的白盒测试是对软件的过程性细节做细致的检查。这种方法是把测试对象看做一个打开的盒子,它允许测试人员利用程序内部的逻辑结构及有关信息,设计或选择测试用例,对程序的所有逻辑路径进行测试,通过在不同点检查程序状态,确定实际状态是否与预期的状态一致。因此白盒测试又称为结构测试。</p>\n<img data-src=\"/2022/10/07/Java/%E7%AC%AC15%E7%AB%A0Junit%E6%B3%A8%E8%A7%A3_%E6%9E%9A%E4%B8%BE/42a7ac6afb1bc65c1526524fb22c0cf6.png\" class=\"\">\n\n\n<h2 id=\"没有Junit的情况下如何测试\"><a href=\"#没有Junit的情况下如何测试\" class=\"headerlink\" title=\"没有Junit的情况下如何测试\"></a>没有Junit的情况下如何测试</h2><p>在没有使用Junit的时候，缺点：</p>\n<p>（1）测试一定走main方法，是程序的入口，main方法的格式必须不能写错。</p>\n<p>（2）要是在同一个main方法中测试的话，那么不需要测试的东西必须注释掉。</p>\n<p>（3）测试逻辑如果分开的话，需要定义多个测试类，麻烦。</p>\n<p>（4）业务逻辑和测试代码，都混淆了。</p>\n<p>代码：</p>\n<pre><code class=\"java\">public class Calculator &#123;\n    //加法：\n    public int add(int a,int b)&#123;\n        return a+b;\n    &#125;\n\n    //减法：\n    public int sub(int a,int b)&#123;\n        return a-b;\n    &#125;\n&#125;\n\npublic class Test &#123;\n    //这是一个main方法，是程序的入口：\n    public static void main(String[] args) &#123;\n        //测试加法：\n        Calculator cal = new Calculator();\n        int result = cal.add(10, 20);\n        System.out.println(result);\n        //测试减法：\n        /\\* int result = cal.sub(30, 10);\n        System.out.println(result);\\*/\n    &#125;\n&#125;\npublic class Test02 &#123;\n    //这是一个main方法，是程序的入口：\n    public static void main(String[] args) &#123;\n        Calculator cal = new Calculator();\n        //测试减法：\n        int result = cal.sub(30, 10);\n        System.out.println(result);\n    &#125;\n&#125;\n\n</code></pre>\n<h2 id=\"Junit的使用\"><a href=\"#Junit的使用\" class=\"headerlink\" title=\"Junit的使用\"></a>Junit的使用</h2><p>【1】一般测试和业务做一个分离，分离为不同的包：</p>\n<p>建议起名：公司域名倒着写+test</p>\n<p>以后测试类就单独放在这个包下</p>\n<p>【2】测试类的名字：****Test —&gt;见名知意</p>\n<p>【3】测试方法的定义–》这个方法可以独立运行，不依托于main方法</p>\n<p>建议：</p>\n<p>名字：testAdd() testSub() 见名知意</p>\n<p>参数：无参</p>\n<p>返回值：void</p>\n<p>【4】测试方法定义完以后，不能直接就独立运行了，必须要在方法前加入一个注解： @Test</p>\n<p>【5】导入Junit的依赖的环境：</p>\n<img data-src=\"/2022/10/07/Java/%E7%AC%AC15%E7%AB%A0Junit%E6%B3%A8%E8%A7%A3_%E6%9E%9A%E4%B8%BE/46fb99bb996eae46795d2c8db94485f6.png\" class=\"\">\n\n\n<p>【6】代码：</p>\n<pre><code class=\"java\">public class CalculatorTest &#123;\n    //测试add方法\n    @Test\n    public void testAdd()&#123;\n        System.out.println(&quot;测试add方法&quot;);\n        Calculator cal = new Calculator();\n        int result = cal.add(10, 30);\n        System.out.println(result);\n    &#125;\n\n    //测试sub方法\n    @Test\n    public void testSub()&#123;\n        System.out.println(&quot;测试sub方法&quot;);\n        Calculator cal = new Calculator();\n        int result = cal.sub(10, 30);\n        System.out.println(result);\n    &#125;\n&#125;\n\n</code></pre>\n<p>【7】判定结果：</p>\n<p>绿色：正常结果</p>\n<p>红色：出现异常</p>\n<p>【8】即使出现绿色效果，也不意味着你的测试就通过了，因为代码中逻辑也可能出现问题，这种情况怎么解决呢？</p>\n<p>加入断言</p>\n<pre><code class=\"java\">public class CalculatorTest &#123;\n    //测试add方法\n    @Test\n    public void testAdd()&#123;\n        System.out.println(&quot;测试add方法&quot;);\n        Calculator cal = new Calculator();\n        int result = cal.add(10, 30);\n        //System.out.println(result);--》程序的运行结果可以不关注\n        //加入断言：预测一下结果，判断一下我预测的结果和 实际的结果是否一致：\n        Assert.assertEquals(40,result);//第一个参数：预测结果 第二个参数：实际结果\n    &#125;\n\n    //测试sub方法\n    @Test\n    public void testSub()&#123;\n        System.out.println(&quot;测试sub方法&quot;);\n        Calculator cal = new Calculator();\n        int result = cal.sub(10, 30);\n        System.out.println(result);\n    &#125;\n&#125;\n\n</code></pre>\n<img data-src=\"/2022/10/07/Java/%E7%AC%AC15%E7%AB%A0Junit%E6%B3%A8%E8%A7%A3_%E6%9E%9A%E4%B8%BE/f28545eda706a96a1dc81a62bd94b0b6.png\" class=\"\">\n\n\n<h2 id=\"Before-After\"><a href=\"#Before-After\" class=\"headerlink\" title=\"@Before_@After\"></a>@Before_@After</h2><p>@Before:</p>\n<p>某一个方法中，加入了@Before注解以后，那么这个方法中的功能会在测试方法执行前先执行</p>\n<p>一般会在@Beforer修饰的那个方法中加入：加入一些申请资源的代码：申请数据库资源，申请IO资源，申请网络资源。。。</p>\n<p>@After:</p>\n<p>某一个方法中，加入了@After注解以后，那么这个方法中的功能会在测试方法执行后先执行</p>\n<p>一般会在@After修饰的那个方法中加入：加入释放资源的代码：释放数据库资源，释放IO资源，释放网络资源。。。</p>\n<p>代码：</p>\n<pre><code class=\"java\">public class CalculatorTest &#123;\n    @Before\n    public void init()&#123;\n        System.out.println(&quot;方法执行开始了。。。&quot;);\n    &#125;\n    @After\n    public void close()&#123;\n        System.out.println(&quot;方法执行结束了。。。&quot;);\n    &#125;\n    //测试add方法\n    @Test\n    public void testAdd()&#123;\n        System.out.println(&quot;测试add方法&quot;);\n        Calculator cal = new Calculator();\n        int result = cal.add(10, 30);\n        //System.out.println(result);--》程序的运行结果可以不关注\n        //加入断言：预测一下结果，判断一下我预测的结果和 实际的结果是否一致：\n        Assert.assertEquals(40,result);//第一个参数：预测结果 第二个参数：实际结果\n    &#125;\n\n    //测试sub方法\n    @Test\n    public void testSub()&#123;\n        System.out.println(&quot;测试sub方法&quot;);\n        Calculator cal = new Calculator();\n        int result = cal.sub(10, 30);\n        System.out.println(result);\n    &#125;\n&#125;\n\n</code></pre>\n<h1 id=\"注解\"><a href=\"#注解\" class=\"headerlink\" title=\"注解\"></a>注解</h1><h2 id=\"引入-1\"><a href=\"#引入-1\" class=\"headerlink\" title=\"引入\"></a>引入</h2><p>【1】历史：</p>\n<p>JDK5.0 新增 — 注解（Annotation）,也叫元数据</p>\n<p>【2】什么是注解？</p>\n<p>注解其实就是代码里的特殊标记，这些标记可以在编译,类加载,运行时被读取,并执行相应的处理。通过使用注解,程序员可以在不改变原有逻辑的情况下，在源文件中嵌入一些补充信息。代码分析工具、开发工具和部署工具可以通过这些补充信息进行验证或者进行部署。</p>\n<p>使用注解时要在其前面增加@符号,并把该注解当成一个修饰符使用。用于修饰它支持的程序元素。</p>\n<p>【3】注解的重要性：</p>\n<p>Annotation 可以像修饰符一样被使用，可用于修饰包，类，构造器,方法，成员变量,参数，局部变量的声明，这些信息被保存在Annotation的”name&#x3D;value”对中。在JavaSE中，注解的使用目的比较简单，例如标记过时的功能，忽略警告等。在JavaEE&#x2F;ArIdroid中注解占据了更重要的角色，例如用来配置应用程序的任何切面，代替JavaEE旧版中所遗留的繁冗代码和XML配置等。未来的开发模式都是基于注解的，JPA(java的持久化API)是基于注解的，Spring2.5以. E都是基于注解的，Hibernate3.x以后也是基于注解的，现在的Struts2有一部分也是基于注解的了，注解是一种趋势，一定程度上可以说 ：框架&#x3D;注解+反射+设计模式。</p>\n<h2 id=\"注解的使用实例\"><a href=\"#注解的使用实例\" class=\"headerlink\" title=\"注解的使用实例\"></a>注解的使用实例</h2><h3 id=\"Junit的注解\"><a href=\"#Junit的注解\" class=\"headerlink\" title=\"Junit的注解\"></a>Junit的注解</h3><p>@Test</p>\n<p>@Before</p>\n<p>@After</p>\n<p>代码：</p>\n<pre><code class=\"java\">\n\n public class CalculatorTest &#123;\n @Before\n public void init()&#123;\n System.out.println(&quot;方法执行开始了。。。&quot;);\n &#125;\n @After\n public void close()&#123;\n System.out.println(&quot;方法执行结束了。。。&quot;);\n &#125;\n @Test\n public void testAdd()&#123;\n System.out.println(&quot;测试add方法&quot;);\n Calculator cal = new Calculator();\n int result = cal.add(10, 30);\n Assert.assertEquals(40,result);//第一个参数：预测结果 第二个参数：实际结果\n &#125;\n &#125;\n</code></pre>\n<h3 id=\"文档相关的注解\"><a href=\"#文档相关的注解\" class=\"headerlink\" title=\"文档相关的注解\"></a>文档相关的注解</h3><p>说明注释允许你在程序中嵌入关于程序的信息。你可以使用 javadoc 工具软件来生成信息，并输出到HTML文件中。</p>\n<p>说明注释，使你更加方便的记录你的程序信息。</p>\n<p>文档注解我们一般使用在文档注释中，配合javadoc工具</p>\n<p>javadoc 工具软件识别以下标签：</p>\n<img data-src=\"/2022/10/07/Java/%E7%AC%AC15%E7%AB%A0Junit%E6%B3%A8%E8%A7%A3_%E6%9E%9A%E4%B8%BE/23874004c970e81a5f5e4f59177c0a6f.png\" class=\"\">\n\n\n<p>其中注意：</p>\n<p>Ø @param @return和@exception这三个标记都是只用于方法的。</p>\n<p>Ø @param的格式要求: @param 形参名 形参类型 形参说明</p>\n<p>Ø @return的格式要求: @return 返回值类型返回值说明，如果方法的返回值类型是void就不能写</p>\n<p>Ø @exception的格式要求: @exception 异常类型异常说明</p>\n<p>Ø @param和@exception可以并列多个</p>\n<p>代码：</p>\n<pre><code class=\"java\">public class Person &#123;\n    /**\n * 下面是eat方法，实现了XXX功能。\n * @param num1 就餐人数\n * @param num2 点了几个菜\n */\n    public void eat(int num1,int num2)&#123;\n\n    &#125;\n\n    /\\*\\*\n        \\* @param age 年龄\n        \\* @return int\n        \\* @exception RuntimeException 当年龄过大的时候\n        \\* @exception IndexOutOfBoundsException 当年龄过小的时候\n        \\* @see Student\n        \\*/\n        public int sleep(int age)&#123;\n        new Student();\n        if(age\\&gt;100)&#123;\n            throw new RuntimeException();\n        &#125;\n        if(age\\&lt;0)&#123;\n            throw new IndexOutOfBoundsException();\n        &#125;\n        return 10;\n    &#125;\n&#125;\n</code></pre>\n<p>IDEA中的javadoc使用：</p>\n<img data-src=\"/2022/10/07/Java/%E7%AC%AC15%E7%AB%A0Junit%E6%B3%A8%E8%A7%A3_%E6%9E%9A%E4%B8%BE/1887cd6739c2f89c5a4ef2d33ec03b55.png\" class=\"\">\n\n\n<p>防止乱码：</p>\n<img data-src=\"/2022/10/07/Java/%E7%AC%AC15%E7%AB%A0Junit%E6%B3%A8%E8%A7%A3_%E6%9E%9A%E4%B8%BE/7fe5daf476aadfa53d22106b5979d514.png\" class=\"\">\n\n\n<img data-src=\"/2022/10/07/Java/%E7%AC%AC15%E7%AB%A0Junit%E6%B3%A8%E8%A7%A3_%E6%9E%9A%E4%B8%BE/010eb501804b4f0f6a550a3a3c8617a2.png\" class=\"\">\n\n\n<h3 id=\"JDK内置的3个注解\"><a href=\"#JDK内置的3个注解\" class=\"headerlink\" title=\"JDK内置的3个注解\"></a>JDK内置的3个注解</h3><p>@Override:限定重写父类方法，该注解只能用于方法</p>\n<pre><code class=\"java\">\n</code></pre>\n<p>| ———————————————————— |</p>\n<pre><code class=\"java\">\n</code></pre>\n<p>@Deprecated:用于表示所修饰的元素(类,方法，构造器，属性等)已过时。通常是因为所修饰的结构危险或存在更好的选择</p>\n<pre><code class=\"java\">public class Student extends Person &#123;\n    /\\*\n        @Override的作用：限定重写的方法，只要重写方法有问题，就有错误提示。\n        \\*/\n        @Override\n        public void eat()&#123;\n        System.out.println(&quot;子类eat..&quot;);\n    &#125;\n    /\\*\n        在方法前加入@Deprecated，这个方法就会变成一个废弃方法/过期方法/过时方法\n        \\*/\n\n        @Deprecated\n        public void study()&#123;\n        System.out.println(&quot;学习。。&quot;);\n    &#125;\n&#125;\n</code></pre>\n<img data-src=\"/2022/10/07/Java/%E7%AC%AC15%E7%AB%A0Junit%E6%B3%A8%E8%A7%A3_%E6%9E%9A%E4%B8%BE/e87bd738286630379a4436ddeb991a7f.png\" class=\"\">\n\n\n<p>@SuppressWarnings:抑制编译器警告</p>\n<pre><code class=\"java\">public class Test02 &#123;\n    //这是一个main方法，是程序的入口：\n    public static void main(String[] args) &#123;\n        @SuppressWarnings(&quot;unused&quot;)\n        int age = 10;\n\n        int num = 10;\n        System.out.println(num);\n        @SuppressWarnings(&#123;&quot;unused&quot;,&quot;rwatypes&quot;&#125;)\n        ArrayList al = new ArrayList();\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"实现替代配置文件功能的注解\"><a href=\"#实现替代配置文件功能的注解\" class=\"headerlink\" title=\"实现替代配置文件功能的注解\"></a>实现替代配置文件功能的注解</h3><p>在servlet3.0之前的配置：</p>\n<table>\n<thead>\n<tr>\n<th>&lt;?xml version&#x3D;”1.0” encoding&#x3D;”UTF-8”?&gt;  &lt;web-app xmlns&#x3D;”<span class=\"exturl\" data-url=\"aHR0cDovL3htbG5zLmpjcC5vcmcveG1sL25zL2phdmFlZSZxdW90Ow==\">http://xmlns.jcp.org/xml/ns/javaee&quot;</span>   xmlns:xsi&#x3D;”<span class=\"exturl\" data-url=\"aHR0cDovL3d3dy53My5vcmcvMjAwMS9YTUxTY2hlbWEtaW5zdGFuY2UmcXVvdDs=\">http://www.w3.org/2001/XMLSchema-instance&quot;</span>   xsi:schemaLocation&#x3D;”<span class=\"exturl\" data-url=\"aHR0cDovL3htbG5zLmpjcC5vcmcveG1sL25zL2phdmFlZQ==\">http://xmlns.jcp.org/xml/ns/javaee</span> <span class=\"exturl\" data-url=\"aHR0cDovL3htbG5zLmpjcC5vcmcveG1sL25zL2phdmFlZS93ZWItYXBwXzRfMC54c2QmcXVvdDs=\">http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;</span>   version&#x3D;”4.0”&gt;   &lt;!–配置Servlet–&gt;   &lt;!–配置Servlet的信息–&gt;   &lt;servlet&gt;   &lt;servlet-name&gt;HelloServlet&lt;&#x2F;servlet-name&gt;   &lt;servlet-class&gt;com.bjsxt.servlet.HelloServlet&lt;&#x2F;servlet-class&gt;   &lt;&#x2F;servlet&gt;   &lt;!–配置Servlet的映射路径–&gt;   &lt;servlet-mapping&gt;   &lt;servlet-name&gt;HelloServlet&lt;&#x2F;servlet-name&gt;   &lt;!–<span class=\"exturl\" data-url=\"aHR0cDovL2xvY2FsaG9zdDo4MDgwLzAxLWhlbGxvLXNlcnZsZXQvaGVsbG8tLS8mZ3Q7\">http://localhost:8080/01-hello-servlet/hello--\\&gt;</span>   &lt;url-pattern&gt;&#x2F;hello&lt;&#x2F;url-pattern&gt;   &lt;&#x2F;servlet-mapping&gt;  &lt;&#x2F;web-app&gt;</th>\n</tr>\n</thead>\n</table>\n<p>在servlet3.0之后使用注解：替代配置文件。</p>\n<pre><code class=\"java\">\n</code></pre>\n<p>|——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————–|</p>\n<h2 id=\"自定义注解\"><a href=\"#自定义注解\" class=\"headerlink\" title=\"自定义注解\"></a>自定义注解</h2><p>【1】自定义注解使用很少，一般情况下都是用现成的注解。</p>\n<p>【2】如何自定义注解：</p>\n<img data-src=\"/2022/10/07/Java/%E7%AC%AC15%E7%AB%A0Junit%E6%B3%A8%E8%A7%A3_%E6%9E%9A%E4%B8%BE/4b5d48a592cbac3d289f687d5e9ec1e7.png\" class=\"\">\n\n\n<img data-src=\"/2022/10/07/Java/%E7%AC%AC15%E7%AB%A0Junit%E6%B3%A8%E8%A7%A3_%E6%9E%9A%E4%B8%BE/1f30647690be446463b91286618f3176.png\" class=\"\">\n\n\n<p>发现定义的注解的声明使用的关键字：<span class=\"exturl\" data-url=\"ZmlsZTovLy9EOlzkuIvovb1AaW50ZXJmYWNl\">@interface</span>，跟接口没有一点关系。</p>\n<p>【3】注解的内部：</p>\n<p>以<span class=\"exturl\" data-url=\"ZmlsZTovLy9EOlzkuIvovb1AU3VwcHJlc3NXYXJuaW5ncw==\">@SuppressWarnings</span>为例，发现内部：</p>\n<img data-src=\"/2022/10/07/Java/%E7%AC%AC15%E7%AB%A0Junit%E6%B3%A8%E8%A7%A3_%E6%9E%9A%E4%B8%BE/258a1b996f98d74fa67f5511b0957b01.png\" class=\"\">\n\n\n<p>这value是属性还是方法？</p>\n<p>答案：看上去是无参数方法，实际上理解为一个成员变量，一个属性</p>\n<p>无参数方法名字–》成员变量的名字</p>\n<p>无参数方法的返回值–》成员变量的类型</p>\n<p>这个参数叫 配置参数</p>\n<p>无参数方法的类型：基本数据类型（八种），String，枚举，注解类型，还可以是以上类型对应的数组。</p>\n<p>PS：注意：如果只有一个成员变量的话，名字尽量叫value。</p>\n<p>【4】使用注解：</p>\n<p>（1）使用注解的话，如果你定义了配置参数，就必须给配置参数进行赋值操作：</p>\n<pre><code class=\"java\">@MyAnnotation(value=&#123;&quot;abc&quot;,&quot;def&quot;,&quot;hij&quot;&#125;)\npublic class Person &#123;\n &#125;\n</code></pre>\n<p>（2）如果只有一个参数，并且这个参数的名字为value的话，那么value&#x3D;可以省略不写。</p>\n<pre><code class=\"java\">@MyAnnotation(&#123;&quot;abc&quot;,&quot;def&quot;,&quot;hij&quot;&#125;)\npublic class Person &#123;\n &#125;\n</code></pre>\n<p>（3）如果你给配置参数设置默认的值了，那么使用的时候可以无需传值：</p>\n<ol>\n<li>public @interface MyAnnotation2 {</li>\n<li>String value() default “abc”;</li>\n<li>}</li>\n</ol>\n<p>使用：</p>\n<pre><code class=\"java\">@MyAnnotation2\n@MyAnnotation(&#123;&quot;abc&quot;,&quot;def&quot;,&quot;hij&quot;&#125;)\npublic class Person &#123;\n    \n &#125;\n</code></pre>\n<p>（4）一个注解的内部是可以不定义配置参数的：</p>\n<pre><code class=\"java\">  public @interface MyAnnotation3 &#123;\n  &#125;\n</code></pre>\n<p>内部没有定义配置参数的注解–》可以叫做标记</p>\n<img data-src=\"/2022/10/07/Java/%E7%AC%AC15%E7%AB%A0Junit%E6%B3%A8%E8%A7%A3_%E6%9E%9A%E4%B8%BE/5a3c24803c3f8ed92d3272ac78b52ce7.png\" class=\"\">\n\n\n<p>内部定义配置参数的注解–》元数据</p>\n<img data-src=\"/2022/10/07/Java/%E7%AC%AC15%E7%AB%A0Junit%E6%B3%A8%E8%A7%A3_%E6%9E%9A%E4%B8%BE/0f6376fb4928988abc36de912ae6e857.png\" class=\"\">\n\n\n<p>【5】注解的使用：</p>\n<p>现在只学习注解的大致技能点，具体怎么应用 后面慢慢学习。</p>\n<h2 id=\"元注解\"><a href=\"#元注解\" class=\"headerlink\" title=\"元注解\"></a>元注解</h2><p>元注解是用于修饰其它注解的注解。</p>\n<p>举例：</p>\n<img data-src=\"/2022/10/07/Java/%E7%AC%AC15%E7%AB%A0Junit%E6%B3%A8%E8%A7%A3_%E6%9E%9A%E4%B8%BE/34f66e3c7b9665d0d116172ef2d023e3.png\" class=\"\">\n\n\n<p>JDK5.0提供了四种元注解：Retention, Target, Documented, Inherited</p>\n<h3 id=\"Retention\"><a href=\"#Retention\" class=\"headerlink\" title=\"Retention\"></a>Retention</h3><p>@Retention:用于修饰注解，用于指定修饰的那个注解的生命周期，@Rentention包含一个RetentionPolicy枚举类型的成员变量,使用@Rentention时必须为该value成员变量指定值:</p>\n<p>➢RetentionPolicy.SOURCE:在源文件中有效(即源文件保留),编译器直接丢弃这种策略的注释，在.class文件中不会保留注解信息</p>\n<p>案例：</p>\n<img data-src=\"/2022/10/07/Java/%E7%AC%AC15%E7%AB%A0Junit%E6%B3%A8%E8%A7%A3_%E6%9E%9A%E4%B8%BE/d3e2e82ebd228e73e7c31cc574e94c62.png\" class=\"\">\n\n\n<img data-src=\"/2022/10/07/Java/%E7%AC%AC15%E7%AB%A0Junit%E6%B3%A8%E8%A7%A3_%E6%9E%9A%E4%B8%BE/4d2c3bc743b41c72b97faabb8603e63d.png\" class=\"\">\n\n\n<p>反编译查看字节码文件：发现字节码文件中没有MyAnnotation这个注解：</p>\n<img data-src=\"/2022/10/07/Java/%E7%AC%AC15%E7%AB%A0Junit%E6%B3%A8%E8%A7%A3_%E6%9E%9A%E4%B8%BE/ef82a6553de8c7049479945ca1d4435e.png\" class=\"\">\n\n\n<p>➢RetentionPolicy.CLASS:在class文件中有效(即class保留)，保留在.class文件中，但是当运行Java程序时，他就不会继续加载了，不会保留在内存中，JVM不会保留注解。如果注解没有加Retention元注解，那么相当于默认的注解就是这种状态。</p>\n<p>案例：</p>\n<img data-src=\"/2022/10/07/Java/%E7%AC%AC15%E7%AB%A0Junit%E6%B3%A8%E8%A7%A3_%E6%9E%9A%E4%B8%BE/f23af522879c92eb18b5b6a6de68eb92.png\" class=\"\">\n\n\n<img data-src=\"/2022/10/07/Java/%E7%AC%AC15%E7%AB%A0Junit%E6%B3%A8%E8%A7%A3_%E6%9E%9A%E4%B8%BE/b6d188929cf9db1376241c79683d1e86.png\" class=\"\">\n\n\n<p>反编译看字节码文件，字节码文件中带有MyAnnotation注解：</p>\n<img data-src=\"/2022/10/07/Java/%E7%AC%AC15%E7%AB%A0Junit%E6%B3%A8%E8%A7%A3_%E6%9E%9A%E4%B8%BE/ce86fb17bc2a2f453556cdbac9a35524.png\" class=\"\">\n\n\n<p>➢RetentionPolicy.RUNTIME:在运行时有效(即运行时保留),当运行 Java程序时，JVM会保留注释，加载在内存中了，那么程序可以通过反射获取该注释。</p>\n<h3 id=\"Target\"><a href=\"#Target\" class=\"headerlink\" title=\"Target\"></a>Target</h3><p>用于修饰注解的注解，用于指定被修饰的注解能用于修饰哪些程序元素。@Target也包含一个名为value的成员变量。</p>\n<p>案例：</p>\n<pre><code class=\"java\">@Target(&#123;TYPE,CONSTRUCTOR,METHOD&#125;)\npublic @interface MyAnnotation4 &#123;\n&#125;\n</code></pre>\n<p>使用：</p>\n<img data-src=\"/2022/10/07/Java/%E7%AC%AC15%E7%AB%A0Junit%E6%B3%A8%E8%A7%A3_%E6%9E%9A%E4%B8%BE/f7fc8775a65c517683db05e1714142d4.png\" class=\"\">\n\n\n<h3 id=\"Documented（很少）\"><a href=\"#Documented（很少）\" class=\"headerlink\" title=\"Documented（很少）\"></a>Documented（很少）</h3><p>用于指定被该元注解修饰的注解类将被javadoc工具提取成文档。默认情况下，javadoc是 不包括注解的，但是加上了这个注解生成的文档中就会带着注解了</p>\n<p>案例：</p>\n<p>如果：Documented注解修饰了Deprecated注解，</p>\n<img data-src=\"/2022/10/07/Java/%E7%AC%AC15%E7%AB%A0Junit%E6%B3%A8%E8%A7%A3_%E6%9E%9A%E4%B8%BE/2c2e47e5817fc9dce848588c74c99fca.png\" class=\"\">\n\n\n<p>那么Deprecated注解就会在javadoc提取的时候，提取到API中：</p>\n<img data-src=\"/2022/10/07/Java/%E7%AC%AC15%E7%AB%A0Junit%E6%B3%A8%E8%A7%A3_%E6%9E%9A%E4%B8%BE/eaffd4880e967c3b2924741f4ce2213c.png\" class=\"\">\n\n\n<h3 id=\"Inherited（极少）\"><a href=\"#Inherited（极少）\" class=\"headerlink\" title=\"Inherited（极少）\"></a>Inherited（极少）</h3><p>被它修饰的Annotation将具有继承性。如果某个类使用了被</p>\n<p>@Inherited修饰的Annotation,则其子类将自动具有该注解。</p>\n<p>案例：</p>\n<p>注解：如果MyAnno注解使用了@Inherited之后，就具备了继承性，那么相当于子类Student也使用了这个MyAnno</p>\n<img data-src=\"/2022/10/07/Java/%E7%AC%AC15%E7%AB%A0Junit%E6%B3%A8%E8%A7%A3_%E6%9E%9A%E4%B8%BE/30e71681fd1e8664b949a536691dc82f.png\" class=\"\">\n\n\n<p>父类：  </p>\n<img data-src=\"/2022/10/07/Java/%E7%AC%AC15%E7%AB%A0Junit%E6%B3%A8%E8%A7%A3_%E6%9E%9A%E4%B8%BE/2a385f34e462174022fc8abb73112b4f.png\" class=\"\">\n\n\n<p>子类：</p>\n<img data-src=\"/2022/10/07/Java/%E7%AC%AC15%E7%AB%A0Junit%E6%B3%A8%E8%A7%A3_%E6%9E%9A%E4%B8%BE/0f863775e4fc46e421d2a5189572c538.png\" class=\"\">\n\n\n<h1 id=\"枚举\"><a href=\"#枚举\" class=\"headerlink\" title=\"枚举\"></a>枚举</h1><h2 id=\"引入-2\"><a href=\"#引入-2\" class=\"headerlink\" title=\"引入\"></a>引入</h2><p>【1】数学：枚举法：</p>\n<p>1&lt;x&lt;4</p>\n<p>2&lt;y&lt;5</p>\n<p>求x+y&#x3D;6</p>\n<p>枚举法：一枚一枚的列举出来。前提：有限，确定</p>\n<p>【2】在java中，类的对象是有限个，确定的。这个类我们可以定义为枚举类。</p>\n<p>举例：</p>\n<p>星期：一二三四五六日</p>\n<p>性别：男女</p>\n<p>季节：春夏秋冬</p>\n<p>【3】自定义枚举类：（JDK1.5之前自定义枚举类）</p>\n<ol start=\"2\">\n<li></li>\n<li>&#x2F;**</li>\n<li>* @author : msb-zhaoss</li>\n<li>* 定义枚举类：季节</li>\n<li>*&#x2F;</li>\n</ol>\n<pre><code class=\"java\">public class Season &#123;\n    //属性：\n    private final String seasonName ;//季节名字\n    private final String seasonDesc ;//季节描述\n    //利用构造器对属性进行赋值操作：\n    //构造器私有化，外界不能调用这个构造器，只能Season内部自己调用\n    private Season(String seasonName,String seasonDesc)&#123;\n        this.seasonName = seasonName;\n        this.seasonDesc = seasonDesc;\n    &#125;\n\n    //提供枚举类的有限的 确定的对象：\n    public static final Season SPRING = new Season(&quot;春天&quot;,&quot;春暖花开&quot;);\n    public static final Season SUMMER = new Season(&quot;夏天&quot;,&quot;烈日炎炎&quot;);\n    public static final Season AUTUMN = new Season(&quot;秋天&quot;,&quot;硕果累累&quot;);\n    public static final Season WINTER = new Season(&quot;冬天&quot;,&quot;冰天雪地&quot;);\n\n    //额外因素：\n\n    public String getSeasonName() &#123;\n        return seasonName;\n    &#125;\n\n    public String getSeasonDesc() &#123;\n        return seasonDesc;\n    &#125;\n\n    //toString();\n\n    @Override\n    public String toString() &#123;\n        return &quot;Season&#123;&quot; +\n            &quot;seasonName=&#39;&quot; + seasonName + &#39;\\\\&#39;&#39; +\n            &quot;, seasonDesc=&#39;&quot; + seasonDesc + &#39;\\\\&#39;&#39; +\n            &#39;&#125;&#39;;\n    &#125;\n&#125;\n\n</code></pre>\n<p>测试类：</p>\n<pre><code class=\"java\">public class TestSeason &#123;\n    //这是一个main方法，是程序的入口：\n    public static void main(String[] args) &#123;\n        Season summer = Season.SUMMER;\n        System.out.println(summer/\\*.toString()\\*/);\n        System.out.println(summer.getSeasonName());\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"JDK1-5之后使用enum关键字来创建枚举类\"><a href=\"#JDK1-5之后使用enum关键字来创建枚举类\" class=\"headerlink\" title=\"JDK1_5之后使用enum关键字来创建枚举类\"></a>JDK1_5之后使用enum关键字来创建枚举类</h2><p>JDK1.5以后使用enum关键字创建枚举类：</p>\n<img data-src=\"/2022/10/07/Java/%E7%AC%AC15%E7%AB%A0Junit%E6%B3%A8%E8%A7%A3_%E6%9E%9A%E4%B8%BE/657e63e35654f2386483ef6f014c3be2.png\" class=\"\">\n\n\n<p>变为下面的枚举类：</p>\n<pre><code class=\"java\">public enum Season &#123;\n    //提供枚举类的有限的 确定的对象：---\\&gt;enum枚举类要求对象（常量）必须放在最开始位置\n    //多个对象之间用，进行连接，最后一个对象后面用;结束\n    SPRING(&quot;春天&quot;,&quot;春暖花开&quot;),\n    SUMMER(&quot;夏天&quot;,&quot;烈日炎炎&quot;),\n    AUTUMN(&quot;秋天&quot;,&quot;硕果累累&quot;),\n    WINTER(&quot;冬天&quot;,&quot;冰天雪地&quot;);\n    //属性：\n    private final String seasonName ;//季节名字\n    private final String seasonDesc ;//季节描述\n    //利用构造器对属性进行赋值操作：\n    //构造器私有化，外界不能调用这个构造器，只能Season内部自己调用\n    private Season(String seasonName, String seasonDesc)&#123;\n        this.seasonName = seasonName;\n        this.seasonDesc = seasonDesc;\n    &#125;\n\n\n\n    //额外因素：\n\n    public String getSeasonName() &#123;\n        return seasonName;\n    &#125;\n\n    public String getSeasonDesc() &#123;\n        return seasonDesc;\n    &#125;\n\n    //toString();\n\n    @Override\n    public String toString() &#123;\n        return &quot;Season&#123;&quot; +\n            &quot;seasonName=&#39;&quot; + seasonName + &#39;\\\\&#39;&#39; +\n            &quot;, seasonDesc=&#39;&quot; + seasonDesc + &#39;\\\\&#39;&#39; +\n            &#39;&#125;&#39;;\n    &#125;\n&#125;\n</code></pre>\n<p>使用枚举类：</p>\n<pre><code class=\"java\">public class TestSeason &#123;\n    //这是一个main方法，是程序的入口：\n    public static void main(String[] args) &#123;\n        Season winter = Season.WINTER;\n        System.out.println(winter);\n        //enum关键字对应的枚举类的上层父类是 ：java.lang.Enum\n        //但是我们自定义的枚举类的上层父类：Object\n        System.out.println(Season.class.getSuperclass().getName());//java.lang.Enum\n    &#125;\n&#125;\n\n</code></pre>\n<p>在源码中经常看到别人定义的枚举类形态：</p>\n<pre><code class=\"java\">public enum Season &#123;\n    SPRING,\n    SUMMER,\n    AUTUMN,\n    WINTER;\n&#125;\n</code></pre>\n<p>为什么这么简单：因为这个枚举类底层没有属性，属性，构造器，toString，get方法都删掉不写了，然后案例来说应该</p>\n<p>写为：SPRING() 现在连（）可以省略 就变成 SPRING</p>\n<p>看到的形态就剩：常量名（对象名）</p>\n<p>案例：Thread中的枚举类：State</p>\n<pre><code class=\"java\">\npublic enum State &#123;\n    /\\*\\*\n        \\* Thread state for a thread which has not yet started.\n            \\*/\n            NEW,\n\n    /\\*\\*\n        \\* Thread state for a runnable thread. A thread in the runnable\n            \\* state is executing in the Java virtual machine but it may\n            \\* be waiting for other resources from the operating system\n                \\* such as processor.\n                \\*/\n                RUNNABLE,\n\n    /\\*\\*\n        \\* Thread state for a thread blocked waiting for a monitor lock.\n            \\* A thread in the blocked state is waiting for a monitor lock\n                \\* to enter a synchronized block/method or\n                \\* reenter a synchronized block/method after calling\n                \\* &#123;@link Object\\#wait() Object.wait&#125;.\n                \\*/\n                BLOCKED,\n\n    /\\*\\*\n        \\* Thread state for a waiting thread.\n            \\* A thread is in the waiting state due to calling one of the\n            \\* following methods:\n    \\* \\&lt;ul\\&gt;\n        \\* \\&lt;li\\&gt;&#123;@link Object\\#wait() Object.wait&#125; with no timeout\\&lt;/li\\&gt;\n        \\* \\&lt;li\\&gt;&#123;@link \\#join() Thread.join&#125; with no timeout\\&lt;/li\\&gt;\n        \\* \\&lt;li\\&gt;&#123;@link LockSupport\\#park() LockSupport.park&#125;\\&lt;/li\\&gt;\n        \\* \\&lt;/ul\\&gt;\n        \\*\n        \\* \\&lt;p\\&gt;A thread in the waiting state is waiting for another thread to\n            \\* perform a particular action.\n            \\*\n            \\* For example, a thread that has called \\&lt;tt\\&gt;Object.wait()\\&lt;/tt\\&gt;\n            \\* on an object is waiting for another thread to call\n                \\* \\&lt;tt\\&gt;Object.notify()\\&lt;/tt\\&gt; or \\&lt;tt\\&gt;Object.notifyAll()\\&lt;/tt\\&gt; on\n                \\* that object. A thread that has called \\&lt;tt\\&gt;Thread.join()\\&lt;/tt\\&gt;\n                \\* is waiting for a specified thread to terminate.\n                    \\*/\n                    WAITING,\n\n    /\\*\\*\n        \\* Thread state for a waiting thread with a specified waiting time.\n            \\* A thread is in the timed waiting state due to calling one of\n            \\* the following methods with a specified positive waiting time:\n    \\* \\&lt;ul\\&gt;\n        \\* \\&lt;li\\&gt;&#123;@link \\#sleep Thread.sleep&#125;\\&lt;/li\\&gt;\n        \\* \\&lt;li\\&gt;&#123;@link Object\\#wait(long) Object.wait&#125; with timeout\\&lt;/li\\&gt;\n        \\* \\&lt;li\\&gt;&#123;@link \\#join(long) Thread.join&#125; with timeout\\&lt;/li\\&gt;\n        \\* \\&lt;li\\&gt;&#123;@link LockSupport\\#parkNanos LockSupport.parkNanos&#125;\\&lt;/li\\&gt;\n        \\* \\&lt;li\\&gt;&#123;@link LockSupport\\#parkUntil LockSupport.parkUntil&#125;\\&lt;/li\\&gt;\n        \\* \\&lt;/ul\\&gt;\n        \\*/\n        TIMED_WAITING,\n\n    /\\*\\*\n        \\* Thread state for a terminated thread.\n            \\* The thread has completed execution.\n            \\*/\n            TERMINATED;\n&#125;\n</code></pre>\n<h2 id=\"Enum类的常用方法\"><a href=\"#Enum类的常用方法\" class=\"headerlink\" title=\"Enum类的常用方法\"></a>Enum类的常用方法</h2><pre><code class=\"java\">public class TestSeason &#123;\n    //这是一个main方法，是程序的入口：\n    public static void main(String[] args) &#123;\n        //用enum关键字创建的Season枚举类上面的父类是：java.lang.Enum,常用方法子类Season可以直接拿过来使用：\n        //toString();---\\&gt;获取对象的名字\n        Season autumn = Season.AUTUMN;\n        System.out.println(autumn/\\*.toString()\\*/);//AUTUMN\n\n        System.out.println(&quot;--------------------&quot;);\n        //values:返回枚举类对象的数组\n        Season[] values = Season.values();\n        for(Season s:values)&#123;\n            System.out.println(s/\\*.toString()\\*/);\n        &#125;\n\n        System.out.println(&quot;--------------------&quot;);\n        //valueOf：通过对象名字获取这个枚举对象\n        //注意：对象的名字必须传正确，否则抛出异常\n        Season autumn1 = Season.valueOf(&quot;AUTUMN&quot;);\n        System.out.println(autumn1);\n    &#125;\n&#125;\n\n</code></pre>\n<h2 id=\"枚举类实现接口\"><a href=\"#枚举类实现接口\" class=\"headerlink\" title=\"枚举类实现接口\"></a>枚举类实现接口</h2><p>定义一个接口：</p>\n<pre><code class=\"java\">public interface TestInterface &#123;\n    void show();\n&#125;\n</code></pre>\n<p>枚举类实现接口，并且重写show方法：</p>\n<pre><code class=\"java\">public enum Season implements TestInterface &#123;\n    SPRING,\n    SUMMER,\n    AUTUMN,\n    WINTER;\n\n    @Override\n    public void show() &#123;\n        System.out.println(&quot;这是Season....&quot;);\n    &#125;\n&#125;\n</code></pre>\n<p>测试类：</p>\n<pre><code class=\"java\">public class Test &#123;\n    //这是一个main方法，是程序的入口：\n    public static void main(String[] args) &#123;\n        Season autumn = Season.AUTUMN;\n        autumn.show();\n        Season summer = Season.SUMMER;\n        summer.show();\n    &#125;\n&#125;\n</code></pre>\n<p>上面发现所有的枚举对象，调用这个show方法的时候走的都是同一个方法，结果都一样：</p>\n<img data-src=\"/2022/10/07/Java/%E7%AC%AC15%E7%AB%A0Junit%E6%B3%A8%E8%A7%A3_%E6%9E%9A%E4%B8%BE/1f3767921901f0bdaab9e90f542d92ee.png\" class=\"\">\n\n\n<p>但是现在我想要：不同的对象 调用的show方法也不同：</p>\n<pre><code class=\"java\">public enum Season implements TestInterface &#123;\n    SPRING&#123;\n        @Override\n        public void show() &#123;\n            System.out.println(&quot;这是春天。。。&quot;);\n        &#125;\n    &#125;,\n    SUMMER&#123;\n        @Override\n        public void show() &#123;\n            System.out.println(&quot;这是夏天。。&quot;);\n        &#125;\n    &#125;,\n    AUTUMN&#123;\n        @Override\n        public void show() &#123;\n            System.out.println(&quot;这是秋天&quot;);\n        &#125;\n    &#125;,\n    WINTER&#123;\n        @Override\n        public void show() &#123;\n            System.out.println(&quot;这是冬天&quot;);\n        &#125;\n    &#125;;\n\n    /\\*@Override\n        public void show() &#123;\n        System.out.println(&quot;这是Season....&quot;);\n    &#125;\\*/\n&#125;\n</code></pre>\n<pre><code class=\"java\">\npublic class Test &#123;\n    //这是一个main方法，是程序的入口：\n    public static void main(String[] args) &#123;\n        Season autumn = Season.AUTUMN;\n        autumn.show();\n        Season summer = Season.SUMMER;\n        summer.show();\n    &#125;\n&#125;\n</code></pre>\n<img data-src=\"/2022/10/07/Java/%E7%AC%AC15%E7%AB%A0Junit%E6%B3%A8%E8%A7%A3_%E6%9E%9A%E4%B8%BE/5739ebe7587a21e7d7144b96ec7a5833.png\" class=\"\">\n\n\n<h2 id=\"实际应用\"><a href=\"#实际应用\" class=\"headerlink\" title=\"实际应用\"></a>实际应用</h2><pre><code class=\"java\">public class Person &#123;\n    //属性：\n    private int age;\n    private String name;\n    private Gender sex;\n\n    public int getAge() &#123;\n        return age;\n    &#125;\n\n    public void setAge(int age) &#123;\n        this.age = age;\n    &#125;\n\n    public String getName() &#123;\n        return name;\n    &#125;\n\n    public void setName(String name) &#123;\n        this.name = name;\n    &#125;\n\n    public Gender getSex() &#123;\n        return sex;\n    &#125;\n\n    public void setSex(Gender sex) &#123;\n        this.sex = sex;\n    &#125;\n\n    @Override\n    public String toString() &#123;\n        return &quot;Person&#123;&quot; +\n            &quot;age=&quot; + age +\n            &quot;, name=&#39;&quot; + name + &#39;\\\\&#39;&#39; +\n            &quot;, sex=&#39;&quot; + sex + &#39;\\\\&#39;&#39; +\n            &#39;&#125;&#39;;\n    &#125;\n&#125;\n\npublic enum Gender &#123;\n    男,\n    女;\n&#125;\n\npublic class Test &#123;\n    //这是一个main方法，是程序的入口：\n    public static void main(String[] args) &#123;\n        Person p = new Person();\n        p.setAge(19);\n        p.setName(&quot;lili&quot;);\n        p.setSex(Gender.男);//传入枚举类Gender的对象：--\\&gt;在入口处对参数进行了限制\n        System.out.println(p);\n    &#125;\n&#125;\n\n</code></pre>\n<p>还可以通过枚举结合switch处理：</p>\n<pre><code class=\"java\">public class Test02 &#123;\n    //这是一个main方法，是程序的入口：\n    public static void main(String[] args) &#123;\n        Gender sex = Gender.男;\n        //switch后面的（）中可以传入枚举类型\n        //switch后面的（）:int,short,byte,char,String ,枚举\n        switch (sex)&#123;\n            case 女:\n                System.out.println(&quot;是个女孩&quot;);\n                break;\n            case 男:\n                System.out.println(&quot;是个男孩&quot;);\n                break;\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n",
            "tags": [
                "JavaSE"
            ]
        }
    ]
}