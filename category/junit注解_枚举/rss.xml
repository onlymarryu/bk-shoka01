<?xml version="1.0"?>
<rss version="2.0">
    <channel>
        <title>记录“美食”每刻 • Posts by &#34;junit注解_枚举&#34; category</title>
        <link>http://example.com</link>
        <description>记录“美食”每刻</description>
        <language>zh-CN</language>
        <pubDate>Fri, 07 Oct 2022 00:00:00 +0800</pubDate>
        <lastBuildDate>Fri, 07 Oct 2022 00:00:00 +0800</lastBuildDate>
        <category>博客</category>
        <category>环境搭建</category>
        <category>分布式</category>
        <category>Dubbo</category>
        <category>FastDFS</category>
        <category>MySQL</category>
        <category>数据库基础</category>
        <category>数据库基本知识</category>
        <category>数据库</category>
        <category>框架</category>
        <category>ORM</category>
        <category>RPC</category>
        <category>中间件</category>
        <category>RabbitMQ</category>
        <category>Solr</category>
        <category>快速搜索</category>
        <category>Redis基础</category>
        <category>NoSQL数据库</category>
        <category>Spring</category>
        <category>SpringBoot</category>
        <category>SpringMVC</category>
        <category>SpringSecurity</category>
        <category>JavaSE</category>
        <category>-JavaSE</category>
        <item>
            <guid isPermalink="true">http://example.com/2022/10/07/%E7%AC%AC15%E7%AB%A0Junit%E6%B3%A8%E8%A7%A3_%E6%9E%9A%E4%B8%BE/</guid>
            <title>第15章Junit注解_枚举</title>
            <link>http://example.com/2022/10/07/%E7%AC%AC15%E7%AB%A0Junit%E6%B3%A8%E8%A7%A3_%E6%9E%9A%E4%B8%BE/</link>
            <category>JavaSE</category>
            <pubDate>Fri, 07 Oct 2022 00:00:00 +0800</pubDate>
            <description><![CDATA[ &lt;h1 id=&#34;第15章-Junit-注解-枚举&#34;&gt;&lt;a href=&#34;#第15章-Junit-注解-枚举&#34; class=&#34;headerlink&#34; title=&#34;第15章_Junit_注解_枚举&#34;&gt;&lt;/a&gt;第15章_Junit_注解_枚举&lt;/h1&gt;&lt;h1 id=&#34;Junit单元测试&#34;&gt;&lt;a href=&#34;#Junit单元测试&#34; class=&#34;headerlink&#34; title=&#34;Junit单元测试&#34;&gt;&lt;/a&gt;Junit单元测试&lt;/h1&gt;&lt;h2 id=&#34;引入&#34;&gt;&lt;a href=&#34;#引入&#34; class=&#34;headerlink&#34; title=&#34;引入&#34;&gt;&lt;/a&gt;引入&lt;/h2&gt;&lt;p&gt;【1】软件测试的目的：&lt;/p&gt;
&lt;p&gt;软件测试的目的是在规定的条件下对程序进行操作,以发现程序错误,衡量软件质量,并对其是否能满足设计要求进行评估的过程。&lt;/p&gt;
&lt;p&gt;【2】测试分类：&lt;/p&gt;
&lt;p&gt;（1）黑盒测试：&lt;/p&gt;
&lt;p&gt;软件的黑盒测试意味着测试要在软件的接口处进行。这种方法是把测试对象看做一个黑盒子,测试人员完全不考虑程序内部的逻辑结构和内部特性,只依据程序的需求规格说明书,检查程序的功能是否符合它的功能说明。因此黑盒测试又叫功能测试。&lt;/p&gt;
&lt;p&gt;（2）白盒测试：—》Junit属于白盒测试。&lt;/p&gt;
&lt;p&gt;软件的白盒测试是对软件的过程性细节做细致的检查。这种方法是把测试对象看做一个打开的盒子,它允许测试人员利用程序内部的逻辑结构及有关信息,设计或选择测试用例,对程序的所有逻辑路径进行测试,通过在不同点检查程序状态,确定实际状态是否与预期的状态一致。因此白盒测试又称为结构测试。&lt;/p&gt;
&lt;img data-src=&#34;/2022/10/07/%E7%AC%AC15%E7%AB%A0Junit%E6%B3%A8%E8%A7%A3_%E6%9E%9A%E4%B8%BE/42a7ac6afb1bc65c1526524fb22c0cf6.png&#34; class=&#34;&#34;&gt;


&lt;h2 id=&#34;没有Junit的情况下如何测试&#34;&gt;&lt;a href=&#34;#没有Junit的情况下如何测试&#34; class=&#34;headerlink&#34; title=&#34;没有Junit的情况下如何测试&#34;&gt;&lt;/a&gt;没有Junit的情况下如何测试&lt;/h2&gt;&lt;p&gt;在没有使用Junit的时候，缺点：&lt;/p&gt;
&lt;p&gt;（1）测试一定走main方法，是程序的入口，main方法的格式必须不能写错。&lt;/p&gt;
&lt;p&gt;（2）要是在同一个main方法中测试的话，那么不需要测试的东西必须注释掉。&lt;/p&gt;
&lt;p&gt;（3）测试逻辑如果分开的话，需要定义多个测试类，麻烦。&lt;/p&gt;
&lt;p&gt;（4）业务逻辑和测试代码，都混淆了。&lt;/p&gt;
&lt;p&gt;代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;public class Calculator &amp;#123;
    //加法：
    public int add(int a,int b)&amp;#123;
        return a+b;
    &amp;#125;

    //减法：
    public int sub(int a,int b)&amp;#123;
        return a-b;
    &amp;#125;
&amp;#125;

public class Test &amp;#123;
    //这是一个main方法，是程序的入口：
    public static void main(String[] args) &amp;#123;
        //测试加法：
        Calculator cal = new Calculator();
        int result = cal.add(10, 20);
        System.out.println(result);
        //测试减法：
        /\* int result = cal.sub(30, 10);
        System.out.println(result);\*/
    &amp;#125;
&amp;#125;
public class Test02 &amp;#123;
    //这是一个main方法，是程序的入口：
    public static void main(String[] args) &amp;#123;
        Calculator cal = new Calculator();
        //测试减法：
        int result = cal.sub(30, 10);
        System.out.println(result);
    &amp;#125;
&amp;#125;

&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;Junit的使用&#34;&gt;&lt;a href=&#34;#Junit的使用&#34; class=&#34;headerlink&#34; title=&#34;Junit的使用&#34;&gt;&lt;/a&gt;Junit的使用&lt;/h2&gt;&lt;p&gt;【1】一般测试和业务做一个分离，分离为不同的包：&lt;/p&gt;
&lt;p&gt;建议起名：公司域名倒着写+test&lt;/p&gt;
&lt;p&gt;以后测试类就单独放在这个包下&lt;/p&gt;
&lt;p&gt;【2】测试类的名字：****Test —&amp;gt;见名知意&lt;/p&gt;
&lt;p&gt;【3】测试方法的定义–》这个方法可以独立运行，不依托于main方法&lt;/p&gt;
&lt;p&gt;建议：&lt;/p&gt;
&lt;p&gt;名字：testAdd() testSub() 见名知意&lt;/p&gt;
&lt;p&gt;参数：无参&lt;/p&gt;
&lt;p&gt;返回值：void&lt;/p&gt;
&lt;p&gt;【4】测试方法定义完以后，不能直接就独立运行了，必须要在方法前加入一个注解： @Test&lt;/p&gt;
&lt;p&gt;【5】导入Junit的依赖的环境：&lt;/p&gt;
&lt;img data-src=&#34;/2022/10/07/%E7%AC%AC15%E7%AB%A0Junit%E6%B3%A8%E8%A7%A3_%E6%9E%9A%E4%B8%BE/46fb99bb996eae46795d2c8db94485f6.png&#34; class=&#34;&#34;&gt;


&lt;p&gt;【6】代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;public class CalculatorTest &amp;#123;
    //测试add方法
    @Test
    public void testAdd()&amp;#123;
        System.out.println(&amp;quot;测试add方法&amp;quot;);
        Calculator cal = new Calculator();
        int result = cal.add(10, 30);
        System.out.println(result);
    &amp;#125;

    //测试sub方法
    @Test
    public void testSub()&amp;#123;
        System.out.println(&amp;quot;测试sub方法&amp;quot;);
        Calculator cal = new Calculator();
        int result = cal.sub(10, 30);
        System.out.println(result);
    &amp;#125;
&amp;#125;

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;【7】判定结果：&lt;/p&gt;
&lt;p&gt;绿色：正常结果&lt;/p&gt;
&lt;p&gt;红色：出现异常&lt;/p&gt;
&lt;p&gt;【8】即使出现绿色效果，也不意味着你的测试就通过了，因为代码中逻辑也可能出现问题，这种情况怎么解决呢？&lt;/p&gt;
&lt;p&gt;加入断言&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;public class CalculatorTest &amp;#123;
    //测试add方法
    @Test
    public void testAdd()&amp;#123;
        System.out.println(&amp;quot;测试add方法&amp;quot;);
        Calculator cal = new Calculator();
        int result = cal.add(10, 30);
        //System.out.println(result);--》程序的运行结果可以不关注
        //加入断言：预测一下结果，判断一下我预测的结果和 实际的结果是否一致：
        Assert.assertEquals(40,result);//第一个参数：预测结果 第二个参数：实际结果
    &amp;#125;

    //测试sub方法
    @Test
    public void testSub()&amp;#123;
        System.out.println(&amp;quot;测试sub方法&amp;quot;);
        Calculator cal = new Calculator();
        int result = cal.sub(10, 30);
        System.out.println(result);
    &amp;#125;
&amp;#125;

&lt;/code&gt;&lt;/pre&gt;
&lt;img data-src=&#34;/2022/10/07/%E7%AC%AC15%E7%AB%A0Junit%E6%B3%A8%E8%A7%A3_%E6%9E%9A%E4%B8%BE/f28545eda706a96a1dc81a62bd94b0b6.png&#34; class=&#34;&#34;&gt;


&lt;h2 id=&#34;Before-After&#34;&gt;&lt;a href=&#34;#Before-After&#34; class=&#34;headerlink&#34; title=&#34;@Before_@After&#34;&gt;&lt;/a&gt;@Before_@After&lt;/h2&gt;&lt;p&gt;@Before:&lt;/p&gt;
&lt;p&gt;某一个方法中，加入了@Before注解以后，那么这个方法中的功能会在测试方法执行前先执行&lt;/p&gt;
&lt;p&gt;一般会在@Beforer修饰的那个方法中加入：加入一些申请资源的代码：申请数据库资源，申请IO资源，申请网络资源。。。&lt;/p&gt;
&lt;p&gt;@After:&lt;/p&gt;
&lt;p&gt;某一个方法中，加入了@After注解以后，那么这个方法中的功能会在测试方法执行后先执行&lt;/p&gt;
&lt;p&gt;一般会在@After修饰的那个方法中加入：加入释放资源的代码：释放数据库资源，释放IO资源，释放网络资源。。。&lt;/p&gt;
&lt;p&gt;代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;public class CalculatorTest &amp;#123;
    @Before
    public void init()&amp;#123;
        System.out.println(&amp;quot;方法执行开始了。。。&amp;quot;);
    &amp;#125;
    @After
    public void close()&amp;#123;
        System.out.println(&amp;quot;方法执行结束了。。。&amp;quot;);
    &amp;#125;
    //测试add方法
    @Test
    public void testAdd()&amp;#123;
        System.out.println(&amp;quot;测试add方法&amp;quot;);
        Calculator cal = new Calculator();
        int result = cal.add(10, 30);
        //System.out.println(result);--》程序的运行结果可以不关注
        //加入断言：预测一下结果，判断一下我预测的结果和 实际的结果是否一致：
        Assert.assertEquals(40,result);//第一个参数：预测结果 第二个参数：实际结果
    &amp;#125;

    //测试sub方法
    @Test
    public void testSub()&amp;#123;
        System.out.println(&amp;quot;测试sub方法&amp;quot;);
        Calculator cal = new Calculator();
        int result = cal.sub(10, 30);
        System.out.println(result);
    &amp;#125;
&amp;#125;

&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;注解&#34;&gt;&lt;a href=&#34;#注解&#34; class=&#34;headerlink&#34; title=&#34;注解&#34;&gt;&lt;/a&gt;注解&lt;/h1&gt;&lt;h2 id=&#34;引入-1&#34;&gt;&lt;a href=&#34;#引入-1&#34; class=&#34;headerlink&#34; title=&#34;引入&#34;&gt;&lt;/a&gt;引入&lt;/h2&gt;&lt;p&gt;【1】历史：&lt;/p&gt;
&lt;p&gt;JDK5.0 新增 — 注解（Annotation）,也叫元数据&lt;/p&gt;
&lt;p&gt;【2】什么是注解？&lt;/p&gt;
&lt;p&gt;注解其实就是代码里的特殊标记，这些标记可以在编译,类加载,运行时被读取,并执行相应的处理。通过使用注解,程序员可以在不改变原有逻辑的情况下，在源文件中嵌入一些补充信息。代码分析工具、开发工具和部署工具可以通过这些补充信息进行验证或者进行部署。&lt;/p&gt;
&lt;p&gt;使用注解时要在其前面增加@符号,并把该注解当成一个修饰符使用。用于修饰它支持的程序元素。&lt;/p&gt;
&lt;p&gt;【3】注解的重要性：&lt;/p&gt;
&lt;p&gt;Annotation 可以像修饰符一样被使用，可用于修饰包，类，构造器,方法，成员变量,参数，局部变量的声明，这些信息被保存在Annotation的”name&amp;#x3D;value”对中。在JavaSE中，注解的使用目的比较简单，例如标记过时的功能，忽略警告等。在JavaEE&amp;#x2F;ArIdroid中注解占据了更重要的角色，例如用来配置应用程序的任何切面，代替JavaEE旧版中所遗留的繁冗代码和XML配置等。未来的开发模式都是基于注解的，JPA(java的持久化API)是基于注解的，Spring2.5以. E都是基于注解的，Hibernate3.x以后也是基于注解的，现在的Struts2有一部分也是基于注解的了，注解是一种趋势，一定程度上可以说 ：框架&amp;#x3D;注解+反射+设计模式。&lt;/p&gt;
&lt;h2 id=&#34;注解的使用实例&#34;&gt;&lt;a href=&#34;#注解的使用实例&#34; class=&#34;headerlink&#34; title=&#34;注解的使用实例&#34;&gt;&lt;/a&gt;注解的使用实例&lt;/h2&gt;&lt;h3 id=&#34;Junit的注解&#34;&gt;&lt;a href=&#34;#Junit的注解&#34; class=&#34;headerlink&#34; title=&#34;Junit的注解&#34;&gt;&lt;/a&gt;Junit的注解&lt;/h3&gt;&lt;p&gt;@Test&lt;/p&gt;
&lt;p&gt;@Before&lt;/p&gt;
&lt;p&gt;@After&lt;/p&gt;
&lt;p&gt;代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;

 public class CalculatorTest &amp;#123;
 @Before
 public void init()&amp;#123;
 System.out.println(&amp;quot;方法执行开始了。。。&amp;quot;);
 &amp;#125;
 @After
 public void close()&amp;#123;
 System.out.println(&amp;quot;方法执行结束了。。。&amp;quot;);
 &amp;#125;
 @Test
 public void testAdd()&amp;#123;
 System.out.println(&amp;quot;测试add方法&amp;quot;);
 Calculator cal = new Calculator();
 int result = cal.add(10, 30);
 Assert.assertEquals(40,result);//第一个参数：预测结果 第二个参数：实际结果
 &amp;#125;
 &amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;文档相关的注解&#34;&gt;&lt;a href=&#34;#文档相关的注解&#34; class=&#34;headerlink&#34; title=&#34;文档相关的注解&#34;&gt;&lt;/a&gt;文档相关的注解&lt;/h3&gt;&lt;p&gt;说明注释允许你在程序中嵌入关于程序的信息。你可以使用 javadoc 工具软件来生成信息，并输出到HTML文件中。&lt;/p&gt;
&lt;p&gt;说明注释，使你更加方便的记录你的程序信息。&lt;/p&gt;
&lt;p&gt;文档注解我们一般使用在文档注释中，配合javadoc工具&lt;/p&gt;
&lt;p&gt;javadoc 工具软件识别以下标签：&lt;/p&gt;
&lt;img data-src=&#34;/2022/10/07/%E7%AC%AC15%E7%AB%A0Junit%E6%B3%A8%E8%A7%A3_%E6%9E%9A%E4%B8%BE/23874004c970e81a5f5e4f59177c0a6f.png&#34; class=&#34;&#34;&gt;


&lt;p&gt;其中注意：&lt;/p&gt;
&lt;p&gt;Ø @param @return和@exception这三个标记都是只用于方法的。&lt;/p&gt;
&lt;p&gt;Ø @param的格式要求: @param 形参名 形参类型 形参说明&lt;/p&gt;
&lt;p&gt;Ø @return的格式要求: @return 返回值类型返回值说明，如果方法的返回值类型是void就不能写&lt;/p&gt;
&lt;p&gt;Ø @exception的格式要求: @exception 异常类型异常说明&lt;/p&gt;
&lt;p&gt;Ø @param和@exception可以并列多个&lt;/p&gt;
&lt;p&gt;代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;public class Person &amp;#123;
    /**
 * 下面是eat方法，实现了XXX功能。
 * @param num1 就餐人数
 * @param num2 点了几个菜
 */
    public void eat(int num1,int num2)&amp;#123;

    &amp;#125;

    /\*\*
        \* @param age 年龄
        \* @return int
        \* @exception RuntimeException 当年龄过大的时候
        \* @exception IndexOutOfBoundsException 当年龄过小的时候
        \* @see Student
        \*/
        public int sleep(int age)&amp;#123;
        new Student();
        if(age\&amp;gt;100)&amp;#123;
            throw new RuntimeException();
        &amp;#125;
        if(age\&amp;lt;0)&amp;#123;
            throw new IndexOutOfBoundsException();
        &amp;#125;
        return 10;
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;IDEA中的javadoc使用：&lt;/p&gt;
&lt;img data-src=&#34;/2022/10/07/%E7%AC%AC15%E7%AB%A0Junit%E6%B3%A8%E8%A7%A3_%E6%9E%9A%E4%B8%BE/1887cd6739c2f89c5a4ef2d33ec03b55.png&#34; class=&#34;&#34;&gt;


&lt;p&gt;防止乱码：&lt;/p&gt;
&lt;img data-src=&#34;/2022/10/07/%E7%AC%AC15%E7%AB%A0Junit%E6%B3%A8%E8%A7%A3_%E6%9E%9A%E4%B8%BE/7fe5daf476aadfa53d22106b5979d514.png&#34; class=&#34;&#34;&gt;


&lt;img data-src=&#34;/2022/10/07/%E7%AC%AC15%E7%AB%A0Junit%E6%B3%A8%E8%A7%A3_%E6%9E%9A%E4%B8%BE/010eb501804b4f0f6a550a3a3c8617a2.png&#34; class=&#34;&#34;&gt;


&lt;h3 id=&#34;JDK内置的3个注解&#34;&gt;&lt;a href=&#34;#JDK内置的3个注解&#34; class=&#34;headerlink&#34; title=&#34;JDK内置的3个注解&#34;&gt;&lt;/a&gt;JDK内置的3个注解&lt;/h3&gt;&lt;p&gt;@Override:限定重写父类方法，该注解只能用于方法&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;| ———————————————————— |&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;@Deprecated:用于表示所修饰的元素(类,方法，构造器，属性等)已过时。通常是因为所修饰的结构危险或存在更好的选择&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;public class Student extends Person &amp;#123;
    /\*
        @Override的作用：限定重写的方法，只要重写方法有问题，就有错误提示。
        \*/
        @Override
        public void eat()&amp;#123;
        System.out.println(&amp;quot;子类eat..&amp;quot;);
    &amp;#125;
    /\*
        在方法前加入@Deprecated，这个方法就会变成一个废弃方法/过期方法/过时方法
        \*/

        @Deprecated
        public void study()&amp;#123;
        System.out.println(&amp;quot;学习。。&amp;quot;);
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;img data-src=&#34;/2022/10/07/%E7%AC%AC15%E7%AB%A0Junit%E6%B3%A8%E8%A7%A3_%E6%9E%9A%E4%B8%BE/e87bd738286630379a4436ddeb991a7f.png&#34; class=&#34;&#34;&gt;


&lt;p&gt;@SuppressWarnings:抑制编译器警告&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;public class Test02 &amp;#123;
    //这是一个main方法，是程序的入口：
    public static void main(String[] args) &amp;#123;
        @SuppressWarnings(&amp;quot;unused&amp;quot;)
        int age = 10;

        int num = 10;
        System.out.println(num);
        @SuppressWarnings(&amp;#123;&amp;quot;unused&amp;quot;,&amp;quot;rwatypes&amp;quot;&amp;#125;)
        ArrayList al = new ArrayList();
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;实现替代配置文件功能的注解&#34;&gt;&lt;a href=&#34;#实现替代配置文件功能的注解&#34; class=&#34;headerlink&#34; title=&#34;实现替代配置文件功能的注解&#34;&gt;&lt;/a&gt;实现替代配置文件功能的注解&lt;/h3&gt;&lt;p&gt;在servlet3.0之前的配置：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&amp;lt;?xml version&amp;#x3D;”1.0” encoding&amp;#x3D;”UTF-8”?&amp;gt;  &amp;lt;web-app xmlns&amp;#x3D;”&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cDovL3htbG5zLmpjcC5vcmcveG1sL25zL2phdmFlZSZxdW90Ow==&#34;&gt;http://xmlns.jcp.org/xml/ns/javaee&amp;quot;&lt;/span&gt;   xmlns:xsi&amp;#x3D;”&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cDovL3d3dy53My5vcmcvMjAwMS9YTUxTY2hlbWEtaW5zdGFuY2UmcXVvdDs=&#34;&gt;http://www.w3.org/2001/XMLSchema-instance&amp;quot;&lt;/span&gt;   xsi:schemaLocation&amp;#x3D;”&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cDovL3htbG5zLmpjcC5vcmcveG1sL25zL2phdmFlZQ==&#34;&gt;http://xmlns.jcp.org/xml/ns/javaee&lt;/span&gt; &lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cDovL3htbG5zLmpjcC5vcmcveG1sL25zL2phdmFlZS93ZWItYXBwXzRfMC54c2QmcXVvdDs=&#34;&gt;http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&amp;quot;&lt;/span&gt;   version&amp;#x3D;”4.0”&amp;gt;   &amp;lt;!–配置Servlet–&amp;gt;   &amp;lt;!–配置Servlet的信息–&amp;gt;   &amp;lt;servlet&amp;gt;   &amp;lt;servlet-name&amp;gt;HelloServlet&amp;lt;&amp;#x2F;servlet-name&amp;gt;   &amp;lt;servlet-class&amp;gt;com.bjsxt.servlet.HelloServlet&amp;lt;&amp;#x2F;servlet-class&amp;gt;   &amp;lt;&amp;#x2F;servlet&amp;gt;   &amp;lt;!–配置Servlet的映射路径–&amp;gt;   &amp;lt;servlet-mapping&amp;gt;   &amp;lt;servlet-name&amp;gt;HelloServlet&amp;lt;&amp;#x2F;servlet-name&amp;gt;   &amp;lt;!–&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cDovL2xvY2FsaG9zdDo4MDgwLzAxLWhlbGxvLXNlcnZsZXQvaGVsbG8tLS8mZ3Q7&#34;&gt;http://localhost:8080/01-hello-servlet/hello--\&amp;gt;&lt;/span&gt;   &amp;lt;url-pattern&amp;gt;&amp;#x2F;hello&amp;lt;&amp;#x2F;url-pattern&amp;gt;   &amp;lt;&amp;#x2F;servlet-mapping&amp;gt;  &amp;lt;&amp;#x2F;web-app&amp;gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;/table&gt;
&lt;p&gt;在servlet3.0之后使用注解：替代配置文件。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;|——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————–|&lt;/p&gt;
&lt;h2 id=&#34;自定义注解&#34;&gt;&lt;a href=&#34;#自定义注解&#34; class=&#34;headerlink&#34; title=&#34;自定义注解&#34;&gt;&lt;/a&gt;自定义注解&lt;/h2&gt;&lt;p&gt;【1】自定义注解使用很少，一般情况下都是用现成的注解。&lt;/p&gt;
&lt;p&gt;【2】如何自定义注解：&lt;/p&gt;
&lt;img data-src=&#34;/2022/10/07/%E7%AC%AC15%E7%AB%A0Junit%E6%B3%A8%E8%A7%A3_%E6%9E%9A%E4%B8%BE/4b5d48a592cbac3d289f687d5e9ec1e7.png&#34; class=&#34;&#34;&gt;


&lt;img data-src=&#34;/2022/10/07/%E7%AC%AC15%E7%AB%A0Junit%E6%B3%A8%E8%A7%A3_%E6%9E%9A%E4%B8%BE/1f30647690be446463b91286618f3176.png&#34; class=&#34;&#34;&gt;


&lt;p&gt;发现定义的注解的声明使用的关键字：&lt;span class=&#34;exturl&#34; data-url=&#34;ZmlsZTovLy9EOlzkuIvovb1AaW50ZXJmYWNl&#34;&gt;@interface&lt;/span&gt;，跟接口没有一点关系。&lt;/p&gt;
&lt;p&gt;【3】注解的内部：&lt;/p&gt;
&lt;p&gt;以&lt;span class=&#34;exturl&#34; data-url=&#34;ZmlsZTovLy9EOlzkuIvovb1AU3VwcHJlc3NXYXJuaW5ncw==&#34;&gt;@SuppressWarnings&lt;/span&gt;为例，发现内部：&lt;/p&gt;
&lt;img data-src=&#34;/2022/10/07/%E7%AC%AC15%E7%AB%A0Junit%E6%B3%A8%E8%A7%A3_%E6%9E%9A%E4%B8%BE/258a1b996f98d74fa67f5511b0957b01.png&#34; class=&#34;&#34;&gt;


&lt;p&gt;这value是属性还是方法？&lt;/p&gt;
&lt;p&gt;答案：看上去是无参数方法，实际上理解为一个成员变量，一个属性&lt;/p&gt;
&lt;p&gt;无参数方法名字–》成员变量的名字&lt;/p&gt;
&lt;p&gt;无参数方法的返回值–》成员变量的类型&lt;/p&gt;
&lt;p&gt;这个参数叫 配置参数&lt;/p&gt;
&lt;p&gt;无参数方法的类型：基本数据类型（八种），String，枚举，注解类型，还可以是以上类型对应的数组。&lt;/p&gt;
&lt;p&gt;PS：注意：如果只有一个成员变量的话，名字尽量叫value。&lt;/p&gt;
&lt;p&gt;【4】使用注解：&lt;/p&gt;
&lt;p&gt;（1）使用注解的话，如果你定义了配置参数，就必须给配置参数进行赋值操作：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;@MyAnnotation(value=&amp;#123;&amp;quot;abc&amp;quot;,&amp;quot;def&amp;quot;,&amp;quot;hij&amp;quot;&amp;#125;)
public class Person &amp;#123;
 &amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;（2）如果只有一个参数，并且这个参数的名字为value的话，那么value&amp;#x3D;可以省略不写。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;@MyAnnotation(&amp;#123;&amp;quot;abc&amp;quot;,&amp;quot;def&amp;quot;,&amp;quot;hij&amp;quot;&amp;#125;)
public class Person &amp;#123;
 &amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;（3）如果你给配置参数设置默认的值了，那么使用的时候可以无需传值：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;public @interface MyAnnotation2 {&lt;/li&gt;
&lt;li&gt;String value() default “abc”;&lt;/li&gt;
&lt;li&gt;}&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;使用：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;@MyAnnotation2
@MyAnnotation(&amp;#123;&amp;quot;abc&amp;quot;,&amp;quot;def&amp;quot;,&amp;quot;hij&amp;quot;&amp;#125;)
public class Person &amp;#123;
    
 &amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;（4）一个注解的内部是可以不定义配置参数的：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;  public @interface MyAnnotation3 &amp;#123;
  &amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;内部没有定义配置参数的注解–》可以叫做标记&lt;/p&gt;
&lt;img data-src=&#34;/2022/10/07/%E7%AC%AC15%E7%AB%A0Junit%E6%B3%A8%E8%A7%A3_%E6%9E%9A%E4%B8%BE/5a3c24803c3f8ed92d3272ac78b52ce7.png&#34; class=&#34;&#34;&gt;


&lt;p&gt;内部定义配置参数的注解–》元数据&lt;/p&gt;
&lt;img data-src=&#34;/2022/10/07/%E7%AC%AC15%E7%AB%A0Junit%E6%B3%A8%E8%A7%A3_%E6%9E%9A%E4%B8%BE/0f6376fb4928988abc36de912ae6e857.png&#34; class=&#34;&#34;&gt;


&lt;p&gt;【5】注解的使用：&lt;/p&gt;
&lt;p&gt;现在只学习注解的大致技能点，具体怎么应用 后面慢慢学习。&lt;/p&gt;
&lt;h2 id=&#34;元注解&#34;&gt;&lt;a href=&#34;#元注解&#34; class=&#34;headerlink&#34; title=&#34;元注解&#34;&gt;&lt;/a&gt;元注解&lt;/h2&gt;&lt;p&gt;元注解是用于修饰其它注解的注解。&lt;/p&gt;
&lt;p&gt;举例：&lt;/p&gt;
&lt;img data-src=&#34;/2022/10/07/%E7%AC%AC15%E7%AB%A0Junit%E6%B3%A8%E8%A7%A3_%E6%9E%9A%E4%B8%BE/34f66e3c7b9665d0d116172ef2d023e3.png&#34; class=&#34;&#34;&gt;


&lt;p&gt;JDK5.0提供了四种元注解：Retention, Target, Documented, Inherited&lt;/p&gt;
&lt;h3 id=&#34;Retention&#34;&gt;&lt;a href=&#34;#Retention&#34; class=&#34;headerlink&#34; title=&#34;Retention&#34;&gt;&lt;/a&gt;Retention&lt;/h3&gt;&lt;p&gt;@Retention:用于修饰注解，用于指定修饰的那个注解的生命周期，@Rentention包含一个RetentionPolicy枚举类型的成员变量,使用@Rentention时必须为该value成员变量指定值:&lt;/p&gt;
&lt;p&gt;➢RetentionPolicy.SOURCE:在源文件中有效(即源文件保留),编译器直接丢弃这种策略的注释，在.class文件中不会保留注解信息&lt;/p&gt;
&lt;p&gt;案例：&lt;/p&gt;
&lt;img data-src=&#34;/2022/10/07/%E7%AC%AC15%E7%AB%A0Junit%E6%B3%A8%E8%A7%A3_%E6%9E%9A%E4%B8%BE/d3e2e82ebd228e73e7c31cc574e94c62.png&#34; class=&#34;&#34;&gt;


&lt;img data-src=&#34;/2022/10/07/%E7%AC%AC15%E7%AB%A0Junit%E6%B3%A8%E8%A7%A3_%E6%9E%9A%E4%B8%BE/4d2c3bc743b41c72b97faabb8603e63d.png&#34; class=&#34;&#34;&gt;


&lt;p&gt;反编译查看字节码文件：发现字节码文件中没有MyAnnotation这个注解：&lt;/p&gt;
&lt;img data-src=&#34;/2022/10/07/%E7%AC%AC15%E7%AB%A0Junit%E6%B3%A8%E8%A7%A3_%E6%9E%9A%E4%B8%BE/ef82a6553de8c7049479945ca1d4435e.png&#34; class=&#34;&#34;&gt;


&lt;p&gt;➢RetentionPolicy.CLASS:在class文件中有效(即class保留)，保留在.class文件中，但是当运行Java程序时，他就不会继续加载了，不会保留在内存中，JVM不会保留注解。如果注解没有加Retention元注解，那么相当于默认的注解就是这种状态。&lt;/p&gt;
&lt;p&gt;案例：&lt;/p&gt;
&lt;img data-src=&#34;/2022/10/07/%E7%AC%AC15%E7%AB%A0Junit%E6%B3%A8%E8%A7%A3_%E6%9E%9A%E4%B8%BE/f23af522879c92eb18b5b6a6de68eb92.png&#34; class=&#34;&#34;&gt;


&lt;img data-src=&#34;/2022/10/07/%E7%AC%AC15%E7%AB%A0Junit%E6%B3%A8%E8%A7%A3_%E6%9E%9A%E4%B8%BE/b6d188929cf9db1376241c79683d1e86.png&#34; class=&#34;&#34;&gt;


&lt;p&gt;反编译看字节码文件，字节码文件中带有MyAnnotation注解：&lt;/p&gt;
&lt;img data-src=&#34;/2022/10/07/%E7%AC%AC15%E7%AB%A0Junit%E6%B3%A8%E8%A7%A3_%E6%9E%9A%E4%B8%BE/ce86fb17bc2a2f453556cdbac9a35524.png&#34; class=&#34;&#34;&gt;


&lt;p&gt;➢RetentionPolicy.RUNTIME:在运行时有效(即运行时保留),当运行 Java程序时，JVM会保留注释，加载在内存中了，那么程序可以通过反射获取该注释。&lt;/p&gt;
&lt;h3 id=&#34;Target&#34;&gt;&lt;a href=&#34;#Target&#34; class=&#34;headerlink&#34; title=&#34;Target&#34;&gt;&lt;/a&gt;Target&lt;/h3&gt;&lt;p&gt;用于修饰注解的注解，用于指定被修饰的注解能用于修饰哪些程序元素。@Target也包含一个名为value的成员变量。&lt;/p&gt;
&lt;p&gt;案例：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;@Target(&amp;#123;TYPE,CONSTRUCTOR,METHOD&amp;#125;)
public @interface MyAnnotation4 &amp;#123;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用：&lt;/p&gt;
&lt;img data-src=&#34;/2022/10/07/%E7%AC%AC15%E7%AB%A0Junit%E6%B3%A8%E8%A7%A3_%E6%9E%9A%E4%B8%BE/f7fc8775a65c517683db05e1714142d4.png&#34; class=&#34;&#34;&gt;


&lt;h3 id=&#34;Documented（很少）&#34;&gt;&lt;a href=&#34;#Documented（很少）&#34; class=&#34;headerlink&#34; title=&#34;Documented（很少）&#34;&gt;&lt;/a&gt;Documented（很少）&lt;/h3&gt;&lt;p&gt;用于指定被该元注解修饰的注解类将被javadoc工具提取成文档。默认情况下，javadoc是 不包括注解的，但是加上了这个注解生成的文档中就会带着注解了&lt;/p&gt;
&lt;p&gt;案例：&lt;/p&gt;
&lt;p&gt;如果：Documented注解修饰了Deprecated注解，&lt;/p&gt;
&lt;img data-src=&#34;/2022/10/07/%E7%AC%AC15%E7%AB%A0Junit%E6%B3%A8%E8%A7%A3_%E6%9E%9A%E4%B8%BE/2c2e47e5817fc9dce848588c74c99fca.png&#34; class=&#34;&#34;&gt;


&lt;p&gt;那么Deprecated注解就会在javadoc提取的时候，提取到API中：&lt;/p&gt;
&lt;img data-src=&#34;/2022/10/07/%E7%AC%AC15%E7%AB%A0Junit%E6%B3%A8%E8%A7%A3_%E6%9E%9A%E4%B8%BE/eaffd4880e967c3b2924741f4ce2213c.png&#34; class=&#34;&#34;&gt;


&lt;h3 id=&#34;Inherited（极少）&#34;&gt;&lt;a href=&#34;#Inherited（极少）&#34; class=&#34;headerlink&#34; title=&#34;Inherited（极少）&#34;&gt;&lt;/a&gt;Inherited（极少）&lt;/h3&gt;&lt;p&gt;被它修饰的Annotation将具有继承性。如果某个类使用了被&lt;/p&gt;
&lt;p&gt;@Inherited修饰的Annotation,则其子类将自动具有该注解。&lt;/p&gt;
&lt;p&gt;案例：&lt;/p&gt;
&lt;p&gt;注解：如果MyAnno注解使用了@Inherited之后，就具备了继承性，那么相当于子类Student也使用了这个MyAnno&lt;/p&gt;
&lt;img data-src=&#34;/2022/10/07/%E7%AC%AC15%E7%AB%A0Junit%E6%B3%A8%E8%A7%A3_%E6%9E%9A%E4%B8%BE/30e71681fd1e8664b949a536691dc82f.png&#34; class=&#34;&#34;&gt;


&lt;p&gt;父类：  &lt;/p&gt;
&lt;img data-src=&#34;/2022/10/07/%E7%AC%AC15%E7%AB%A0Junit%E6%B3%A8%E8%A7%A3_%E6%9E%9A%E4%B8%BE/2a385f34e462174022fc8abb73112b4f.png&#34; class=&#34;&#34;&gt;


&lt;p&gt;子类：&lt;/p&gt;
&lt;img data-src=&#34;/2022/10/07/%E7%AC%AC15%E7%AB%A0Junit%E6%B3%A8%E8%A7%A3_%E6%9E%9A%E4%B8%BE/0f863775e4fc46e421d2a5189572c538.png&#34; class=&#34;&#34;&gt;


&lt;h1 id=&#34;枚举&#34;&gt;&lt;a href=&#34;#枚举&#34; class=&#34;headerlink&#34; title=&#34;枚举&#34;&gt;&lt;/a&gt;枚举&lt;/h1&gt;&lt;h2 id=&#34;引入-2&#34;&gt;&lt;a href=&#34;#引入-2&#34; class=&#34;headerlink&#34; title=&#34;引入&#34;&gt;&lt;/a&gt;引入&lt;/h2&gt;&lt;p&gt;【1】数学：枚举法：&lt;/p&gt;
&lt;p&gt;1&amp;lt;x&amp;lt;4&lt;/p&gt;
&lt;p&gt;2&amp;lt;y&amp;lt;5&lt;/p&gt;
&lt;p&gt;求x+y&amp;#x3D;6&lt;/p&gt;
&lt;p&gt;枚举法：一枚一枚的列举出来。前提：有限，确定&lt;/p&gt;
&lt;p&gt;【2】在java中，类的对象是有限个，确定的。这个类我们可以定义为枚举类。&lt;/p&gt;
&lt;p&gt;举例：&lt;/p&gt;
&lt;p&gt;星期：一二三四五六日&lt;/p&gt;
&lt;p&gt;性别：男女&lt;/p&gt;
&lt;p&gt;季节：春夏秋冬&lt;/p&gt;
&lt;p&gt;【3】自定义枚举类：（JDK1.5之前自定义枚举类）&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;&amp;#x2F;**&lt;/li&gt;
&lt;li&gt;* @author : msb-zhaoss&lt;/li&gt;
&lt;li&gt;* 定义枚举类：季节&lt;/li&gt;
&lt;li&gt;*&amp;#x2F;&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;public class Season &amp;#123;
    //属性：
    private final String seasonName ;//季节名字
    private final String seasonDesc ;//季节描述
    //利用构造器对属性进行赋值操作：
    //构造器私有化，外界不能调用这个构造器，只能Season内部自己调用
    private Season(String seasonName,String seasonDesc)&amp;#123;
        this.seasonName = seasonName;
        this.seasonDesc = seasonDesc;
    &amp;#125;

    //提供枚举类的有限的 确定的对象：
    public static final Season SPRING = new Season(&amp;quot;春天&amp;quot;,&amp;quot;春暖花开&amp;quot;);
    public static final Season SUMMER = new Season(&amp;quot;夏天&amp;quot;,&amp;quot;烈日炎炎&amp;quot;);
    public static final Season AUTUMN = new Season(&amp;quot;秋天&amp;quot;,&amp;quot;硕果累累&amp;quot;);
    public static final Season WINTER = new Season(&amp;quot;冬天&amp;quot;,&amp;quot;冰天雪地&amp;quot;);

    //额外因素：

    public String getSeasonName() &amp;#123;
        return seasonName;
    &amp;#125;

    public String getSeasonDesc() &amp;#123;
        return seasonDesc;
    &amp;#125;

    //toString();

    @Override
    public String toString() &amp;#123;
        return &amp;quot;Season&amp;#123;&amp;quot; +
            &amp;quot;seasonName=&amp;#39;&amp;quot; + seasonName + &amp;#39;\\&amp;#39;&amp;#39; +
            &amp;quot;, seasonDesc=&amp;#39;&amp;quot; + seasonDesc + &amp;#39;\\&amp;#39;&amp;#39; +
            &amp;#39;&amp;#125;&amp;#39;;
    &amp;#125;
&amp;#125;

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;测试类：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;public class TestSeason &amp;#123;
    //这是一个main方法，是程序的入口：
    public static void main(String[] args) &amp;#123;
        Season summer = Season.SUMMER;
        System.out.println(summer/\*.toString()\*/);
        System.out.println(summer.getSeasonName());
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;JDK1-5之后使用enum关键字来创建枚举类&#34;&gt;&lt;a href=&#34;#JDK1-5之后使用enum关键字来创建枚举类&#34; class=&#34;headerlink&#34; title=&#34;JDK1_5之后使用enum关键字来创建枚举类&#34;&gt;&lt;/a&gt;JDK1_5之后使用enum关键字来创建枚举类&lt;/h2&gt;&lt;p&gt;JDK1.5以后使用enum关键字创建枚举类：&lt;/p&gt;
&lt;img data-src=&#34;/2022/10/07/%E7%AC%AC15%E7%AB%A0Junit%E6%B3%A8%E8%A7%A3_%E6%9E%9A%E4%B8%BE/657e63e35654f2386483ef6f014c3be2.png&#34; class=&#34;&#34;&gt;


&lt;p&gt;变为下面的枚举类：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;public enum Season &amp;#123;
    //提供枚举类的有限的 确定的对象：---\&amp;gt;enum枚举类要求对象（常量）必须放在最开始位置
    //多个对象之间用，进行连接，最后一个对象后面用;结束
    SPRING(&amp;quot;春天&amp;quot;,&amp;quot;春暖花开&amp;quot;),
    SUMMER(&amp;quot;夏天&amp;quot;,&amp;quot;烈日炎炎&amp;quot;),
    AUTUMN(&amp;quot;秋天&amp;quot;,&amp;quot;硕果累累&amp;quot;),
    WINTER(&amp;quot;冬天&amp;quot;,&amp;quot;冰天雪地&amp;quot;);
    //属性：
    private final String seasonName ;//季节名字
    private final String seasonDesc ;//季节描述
    //利用构造器对属性进行赋值操作：
    //构造器私有化，外界不能调用这个构造器，只能Season内部自己调用
    private Season(String seasonName, String seasonDesc)&amp;#123;
        this.seasonName = seasonName;
        this.seasonDesc = seasonDesc;
    &amp;#125;



    //额外因素：

    public String getSeasonName() &amp;#123;
        return seasonName;
    &amp;#125;

    public String getSeasonDesc() &amp;#123;
        return seasonDesc;
    &amp;#125;

    //toString();

    @Override
    public String toString() &amp;#123;
        return &amp;quot;Season&amp;#123;&amp;quot; +
            &amp;quot;seasonName=&amp;#39;&amp;quot; + seasonName + &amp;#39;\\&amp;#39;&amp;#39; +
            &amp;quot;, seasonDesc=&amp;#39;&amp;quot; + seasonDesc + &amp;#39;\\&amp;#39;&amp;#39; +
            &amp;#39;&amp;#125;&amp;#39;;
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用枚举类：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;public class TestSeason &amp;#123;
    //这是一个main方法，是程序的入口：
    public static void main(String[] args) &amp;#123;
        Season winter = Season.WINTER;
        System.out.println(winter);
        //enum关键字对应的枚举类的上层父类是 ：java.lang.Enum
        //但是我们自定义的枚举类的上层父类：Object
        System.out.println(Season.class.getSuperclass().getName());//java.lang.Enum
    &amp;#125;
&amp;#125;

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在源码中经常看到别人定义的枚举类形态：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;public enum Season &amp;#123;
    SPRING,
    SUMMER,
    AUTUMN,
    WINTER;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;为什么这么简单：因为这个枚举类底层没有属性，属性，构造器，toString，get方法都删掉不写了，然后案例来说应该&lt;/p&gt;
&lt;p&gt;写为：SPRING() 现在连（）可以省略 就变成 SPRING&lt;/p&gt;
&lt;p&gt;看到的形态就剩：常量名（对象名）&lt;/p&gt;
&lt;p&gt;案例：Thread中的枚举类：State&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;
public enum State &amp;#123;
    /\*\*
        \* Thread state for a thread which has not yet started.
            \*/
            NEW,

    /\*\*
        \* Thread state for a runnable thread. A thread in the runnable
            \* state is executing in the Java virtual machine but it may
            \* be waiting for other resources from the operating system
                \* such as processor.
                \*/
                RUNNABLE,

    /\*\*
        \* Thread state for a thread blocked waiting for a monitor lock.
            \* A thread in the blocked state is waiting for a monitor lock
                \* to enter a synchronized block/method or
                \* reenter a synchronized block/method after calling
                \* &amp;#123;@link Object\#wait() Object.wait&amp;#125;.
                \*/
                BLOCKED,

    /\*\*
        \* Thread state for a waiting thread.
            \* A thread is in the waiting state due to calling one of the
            \* following methods:
    \* \&amp;lt;ul\&amp;gt;
        \* \&amp;lt;li\&amp;gt;&amp;#123;@link Object\#wait() Object.wait&amp;#125; with no timeout\&amp;lt;/li\&amp;gt;
        \* \&amp;lt;li\&amp;gt;&amp;#123;@link \#join() Thread.join&amp;#125; with no timeout\&amp;lt;/li\&amp;gt;
        \* \&amp;lt;li\&amp;gt;&amp;#123;@link LockSupport\#park() LockSupport.park&amp;#125;\&amp;lt;/li\&amp;gt;
        \* \&amp;lt;/ul\&amp;gt;
        \*
        \* \&amp;lt;p\&amp;gt;A thread in the waiting state is waiting for another thread to
            \* perform a particular action.
            \*
            \* For example, a thread that has called \&amp;lt;tt\&amp;gt;Object.wait()\&amp;lt;/tt\&amp;gt;
            \* on an object is waiting for another thread to call
                \* \&amp;lt;tt\&amp;gt;Object.notify()\&amp;lt;/tt\&amp;gt; or \&amp;lt;tt\&amp;gt;Object.notifyAll()\&amp;lt;/tt\&amp;gt; on
                \* that object. A thread that has called \&amp;lt;tt\&amp;gt;Thread.join()\&amp;lt;/tt\&amp;gt;
                \* is waiting for a specified thread to terminate.
                    \*/
                    WAITING,

    /\*\*
        \* Thread state for a waiting thread with a specified waiting time.
            \* A thread is in the timed waiting state due to calling one of
            \* the following methods with a specified positive waiting time:
    \* \&amp;lt;ul\&amp;gt;
        \* \&amp;lt;li\&amp;gt;&amp;#123;@link \#sleep Thread.sleep&amp;#125;\&amp;lt;/li\&amp;gt;
        \* \&amp;lt;li\&amp;gt;&amp;#123;@link Object\#wait(long) Object.wait&amp;#125; with timeout\&amp;lt;/li\&amp;gt;
        \* \&amp;lt;li\&amp;gt;&amp;#123;@link \#join(long) Thread.join&amp;#125; with timeout\&amp;lt;/li\&amp;gt;
        \* \&amp;lt;li\&amp;gt;&amp;#123;@link LockSupport\#parkNanos LockSupport.parkNanos&amp;#125;\&amp;lt;/li\&amp;gt;
        \* \&amp;lt;li\&amp;gt;&amp;#123;@link LockSupport\#parkUntil LockSupport.parkUntil&amp;#125;\&amp;lt;/li\&amp;gt;
        \* \&amp;lt;/ul\&amp;gt;
        \*/
        TIMED_WAITING,

    /\*\*
        \* Thread state for a terminated thread.
            \* The thread has completed execution.
            \*/
            TERMINATED;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;Enum类的常用方法&#34;&gt;&lt;a href=&#34;#Enum类的常用方法&#34; class=&#34;headerlink&#34; title=&#34;Enum类的常用方法&#34;&gt;&lt;/a&gt;Enum类的常用方法&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;public class TestSeason &amp;#123;
    //这是一个main方法，是程序的入口：
    public static void main(String[] args) &amp;#123;
        //用enum关键字创建的Season枚举类上面的父类是：java.lang.Enum,常用方法子类Season可以直接拿过来使用：
        //toString();---\&amp;gt;获取对象的名字
        Season autumn = Season.AUTUMN;
        System.out.println(autumn/\*.toString()\*/);//AUTUMN

        System.out.println(&amp;quot;--------------------&amp;quot;);
        //values:返回枚举类对象的数组
        Season[] values = Season.values();
        for(Season s:values)&amp;#123;
            System.out.println(s/\*.toString()\*/);
        &amp;#125;

        System.out.println(&amp;quot;--------------------&amp;quot;);
        //valueOf：通过对象名字获取这个枚举对象
        //注意：对象的名字必须传正确，否则抛出异常
        Season autumn1 = Season.valueOf(&amp;quot;AUTUMN&amp;quot;);
        System.out.println(autumn1);
    &amp;#125;
&amp;#125;

&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;枚举类实现接口&#34;&gt;&lt;a href=&#34;#枚举类实现接口&#34; class=&#34;headerlink&#34; title=&#34;枚举类实现接口&#34;&gt;&lt;/a&gt;枚举类实现接口&lt;/h2&gt;&lt;p&gt;定义一个接口：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;public interface TestInterface &amp;#123;
    void show();
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;枚举类实现接口，并且重写show方法：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;public enum Season implements TestInterface &amp;#123;
    SPRING,
    SUMMER,
    AUTUMN,
    WINTER;

    @Override
    public void show() &amp;#123;
        System.out.println(&amp;quot;这是Season....&amp;quot;);
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;测试类：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;public class Test &amp;#123;
    //这是一个main方法，是程序的入口：
    public static void main(String[] args) &amp;#123;
        Season autumn = Season.AUTUMN;
        autumn.show();
        Season summer = Season.SUMMER;
        summer.show();
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面发现所有的枚举对象，调用这个show方法的时候走的都是同一个方法，结果都一样：&lt;/p&gt;
&lt;img data-src=&#34;/2022/10/07/%E7%AC%AC15%E7%AB%A0Junit%E6%B3%A8%E8%A7%A3_%E6%9E%9A%E4%B8%BE/1f3767921901f0bdaab9e90f542d92ee.png&#34; class=&#34;&#34;&gt;


&lt;p&gt;但是现在我想要：不同的对象 调用的show方法也不同：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;public enum Season implements TestInterface &amp;#123;
    SPRING&amp;#123;
        @Override
        public void show() &amp;#123;
            System.out.println(&amp;quot;这是春天。。。&amp;quot;);
        &amp;#125;
    &amp;#125;,
    SUMMER&amp;#123;
        @Override
        public void show() &amp;#123;
            System.out.println(&amp;quot;这是夏天。。&amp;quot;);
        &amp;#125;
    &amp;#125;,
    AUTUMN&amp;#123;
        @Override
        public void show() &amp;#123;
            System.out.println(&amp;quot;这是秋天&amp;quot;);
        &amp;#125;
    &amp;#125;,
    WINTER&amp;#123;
        @Override
        public void show() &amp;#123;
            System.out.println(&amp;quot;这是冬天&amp;quot;);
        &amp;#125;
    &amp;#125;;

    /\*@Override
        public void show() &amp;#123;
        System.out.println(&amp;quot;这是Season....&amp;quot;);
    &amp;#125;\*/
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;
public class Test &amp;#123;
    //这是一个main方法，是程序的入口：
    public static void main(String[] args) &amp;#123;
        Season autumn = Season.AUTUMN;
        autumn.show();
        Season summer = Season.SUMMER;
        summer.show();
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;img data-src=&#34;/2022/10/07/%E7%AC%AC15%E7%AB%A0Junit%E6%B3%A8%E8%A7%A3_%E6%9E%9A%E4%B8%BE/5739ebe7587a21e7d7144b96ec7a5833.png&#34; class=&#34;&#34;&gt;


&lt;h2 id=&#34;实际应用&#34;&gt;&lt;a href=&#34;#实际应用&#34; class=&#34;headerlink&#34; title=&#34;实际应用&#34;&gt;&lt;/a&gt;实际应用&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;public class Person &amp;#123;
    //属性：
    private int age;
    private String name;
    private Gender sex;

    public int getAge() &amp;#123;
        return age;
    &amp;#125;

    public void setAge(int age) &amp;#123;
        this.age = age;
    &amp;#125;

    public String getName() &amp;#123;
        return name;
    &amp;#125;

    public void setName(String name) &amp;#123;
        this.name = name;
    &amp;#125;

    public Gender getSex() &amp;#123;
        return sex;
    &amp;#125;

    public void setSex(Gender sex) &amp;#123;
        this.sex = sex;
    &amp;#125;

    @Override
    public String toString() &amp;#123;
        return &amp;quot;Person&amp;#123;&amp;quot; +
            &amp;quot;age=&amp;quot; + age +
            &amp;quot;, name=&amp;#39;&amp;quot; + name + &amp;#39;\\&amp;#39;&amp;#39; +
            &amp;quot;, sex=&amp;#39;&amp;quot; + sex + &amp;#39;\\&amp;#39;&amp;#39; +
            &amp;#39;&amp;#125;&amp;#39;;
    &amp;#125;
&amp;#125;

public enum Gender &amp;#123;
    男,
    女;
&amp;#125;

public class Test &amp;#123;
    //这是一个main方法，是程序的入口：
    public static void main(String[] args) &amp;#123;
        Person p = new Person();
        p.setAge(19);
        p.setName(&amp;quot;lili&amp;quot;);
        p.setSex(Gender.男);//传入枚举类Gender的对象：--\&amp;gt;在入口处对参数进行了限制
        System.out.println(p);
    &amp;#125;
&amp;#125;

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;还可以通过枚举结合switch处理：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;public class Test02 &amp;#123;
    //这是一个main方法，是程序的入口：
    public static void main(String[] args) &amp;#123;
        Gender sex = Gender.男;
        //switch后面的（）中可以传入枚举类型
        //switch后面的（）:int,short,byte,char,String ,枚举
        switch (sex)&amp;#123;
            case 女:
                System.out.println(&amp;quot;是个女孩&amp;quot;);
                break;
            case 男:
                System.out.println(&amp;quot;是个男孩&amp;quot;);
                break;
        &amp;#125;
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
 ]]></description>
        </item>
    </channel>
</rss>
