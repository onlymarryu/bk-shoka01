<?xml version="1.0"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>http://example.com</id>
    <title>记录“美食”每刻 • Posts by &#34;mybatis&#34; category</title>
    <link href="http://example.com" />
    <updated>2022-10-06T16:00:00.000Z</updated>
    <category term="分布式" />
    <category term="Dubbo" />
    <category term="FastDFS" />
    <category term="RPC" />
    <category term="中间件" />
    <category term="RabbitMQ" />
    <category term="Solr" />
    <category term="快速搜索" />
    <category term="JavaSE" />
    <category term="-JavaSE" />
    <category term="框架" />
    <category term="ORM" />
    <category term="Spring" />
    <category term="SpringBoot" />
    <category term="SpringMVC" />
    <category term="博客" />
    <category term="环境搭建" />
    <category term="SpringSecurity" />
    <category term="Redis基础" />
    <category term="NoSQL数据库" />
    <entry>
        <id>http://example.com/2022/10/07/ORM/Mybatis/</id>
        <title>Mybatis</title>
        <link rel="alternate" href="http://example.com/2022/10/07/ORM/Mybatis/"/>
        <content type="html">&lt;h1 id=&#34;1-Mybatis入门&#34;&gt;&lt;a href=&#34;#1-Mybatis入门&#34; class=&#34;headerlink&#34; title=&#34;1 Mybatis入门&#34;&gt;&lt;/a&gt;1 Mybatis入门&lt;/h1&gt;&lt;p&gt;原生JDBC实现CURD的问题&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;1 编码繁琐&lt;br&gt;2 需要我们自己将结果集映射成对象&lt;br&gt;3 性能不太好  连接池 缓存&lt;br&gt;4 SQL语句和java代码的耦合度特别高&lt;br&gt;5 … …&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;MyBatis 本是Apache的一个开源项目iBatis, 2010年这个项目由Apache Software Foundation 迁移到了Google Code，且改名为MyBatis 。2013年11月迁移到GitHub。iBATIS一词来源于“internet”和“abatis”的组合，是一个基于Java的持久层框架。&lt;br&gt;MyBatis 是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 POJOs(Plain Ordinary Java Object,普通的 Java对象)映射成数据库中的记录。&lt;/p&gt;
&lt;img data-src=&#34;/2022/10/07/ORM/Mybatis/image-20220617191731748.png&#34; class=&#34;&#34; title=&#34;image-20220617191731748&#34;&gt;





&lt;h2 id=&#34;1-认识框架&#34;&gt;&lt;a href=&#34;#1-认识框架&#34; class=&#34;headerlink&#34; title=&#34;1 认识框架&#34;&gt;&lt;/a&gt;1 认识框架&lt;/h2&gt;&lt;p&gt;框架（Framework）是一个框子——指其约束性，也是一个架子——指其支撑性。是一个基本概念上的结构，用于去解决或者处理复杂的问题。框架这个广泛的定义使用的十分流行，尤其在软件概念。&lt;br&gt;框架( Framework )对于java来说,就是一系列为了解决特定问题而定义的一系列接口和实现类,在组织框架代码时,使用了一系列优秀的设计模式,使代码无论在性能上还是API操作上得到很大提升.框架可以看做是项目开发的半成品,基本的底层操作已经封装完毕,通过框架,程序员可以从底层代码中解脱出来,专注于业务逻辑的完成和性能的优化。框架规定了你的应用的体系结构。它定义了整体结构，类和对象的分割，各部分的主要责任，类和对象怎么协作，以及控制流程。框架预定义了这些设计参数，以便于应用设计者或实现者能集中精力于应用本身的特定细节。&lt;/p&gt;
&lt;p&gt;如果将开发完成的软件比作是一套已经装修完毕的新房，那框架就好比是一套已经修建好的毛坯房。用户直接购买毛坯房，建筑质量和户型合理有保证，还省去了自己建造房屋的时间，一举多得。&lt;br&gt;在开发过程是使用框架，同样可以保证减少开发时间、降低开发难度，并且还保证设计质量。好比和世界上最优秀的软件工程师是一个项目的，并且他们完成的还是基础、全局的工作。想想是不是很嗨的一件事情。&lt;/p&gt;
&lt;img data-src=&#34;/2022/10/07/ORM/Mybatis/image-20220617191818381.png&#34; class=&#34;&#34; title=&#34;image-20220617191818381&#34;&gt;





&lt;p&gt;框架还有一个作用是约束。莎士比亚说,”一千个观众眼中有一千个哈姆雷特” 即仁者见仁,智者见智.说每个人都会对作品有不同的理解，每个人对待任何事物都有自己的看法，一千个人就有可能有一千种不同的看法1000人心中有1000个哈姆雷特。同样的技术解决同样的问题会产生不同流程和风格的解决方案，而采用一种框架其实就是限制用户必须使用其规定的方案来实现，&lt;strong&gt;可以降低程序员之间沟通以及日后维护的成本。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;常用的基于JavaEE的三大开源框架，已经从SSH、SSH2过渡到了SSM：SpringMVC、Spring、MyBatis &amp;gt;&amp;gt;&amp;gt; springBoot&lt;/p&gt;
&lt;p&gt;&lt;font face=&#34;微软雅黑&#34; size=6 color=#FF0000&gt;总之，框架是一个半成品，已经对基础的代码进行了封装并提供相应的API，开发者在使用框架是直接调用封装好的API可以省去很多代码编写，从而提高工作效率和开发速度。&lt;/font&gt;&lt;/p&gt;
&lt;h2 id=&#34;2-认识ORM&#34;&gt;&lt;a href=&#34;#2-认识ORM&#34; class=&#34;headerlink&#34; title=&#34;2 认识ORM&#34;&gt;&lt;/a&gt;2 认识ORM&lt;/h2&gt;&lt;p&gt;DBC的缺点：&lt;/p&gt;
&lt;p&gt;需要手动的完成面向对象的Java语言、面向关系的数据库之间数据的转换，代码繁琐无技术含量，影响了开发效率。&lt;/p&gt;
&lt;p&gt;如图所示，查询是需要手动的将结果集的列数据转换为Java对象的属性；而添加操作时需要手动将Java对象的属性转换为数据库表的列字段。&lt;/p&gt;
&lt;p&gt;关于面向对象的Java语言、面向关系的数据库之间数据的转换必须要做，问题在于这个转换是否可以不由开发者来做。可以的。ORM框架就是专门来做这个问题的，相当于在面向对象语言和关系数据库之间搭建一个桥梁。&lt;/p&gt;
&lt;p&gt;&amp;#x3D;&amp;#x3D;ORM，Object-Relationl Mapping，对象关系映射，它的作用是在关系型数据库和对象之间作一个映射，这样我们在具体的操作数据库的时候，只要像平时操作对象一样操作它就可以了，ORM框架会根据映射完成对数据库的操作，就不需要再去和复杂的SQL语句打交道了&amp;#x3D;&amp;#x3D;。&lt;/p&gt;
&lt;img data-src=&#34;/2022/10/07/ORM/Mybatis/image-20220617192304044.png&#34; class=&#34;&#34; title=&#34;image-20220617192304044&#34;&gt;


&lt;p&gt;另外学习ORM必须知道两个概念：持久化、持久层&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;什么是“持久化”&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;持久（Persistence），&lt;font color=#FF0000&gt;即把数据（如内存中的对象）保存到可永久保存的存储设备中（如磁盘）&lt;/font&gt;。持久化的主要应用是将内存中的数据存储在关系型的数据库中，当然也可以存储在磁盘文件中、XML数据文件中等等。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;什么是 “持久层”&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;持久层（Persistence Layer），即专注于实现数据持久化应用领域的某个特定系统的一个逻辑层面，将数据使用者和数据实体相关联。之前使用JDBC访问数据库的DAO层，后面采用MyBatis访问数据库的mapper层，就是持久层。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Mybatis是一持久层的款半自动的ORM映射框架&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;3-认识MyBatis&#34;&gt;&lt;a href=&#34;#3-认识MyBatis&#34; class=&#34;headerlink&#34; title=&#34;3 认识MyBatis&#34;&gt;&lt;/a&gt;3 认识MyBatis&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;MyBatis 本是Apache的一个开源项目iBatis, 2010年这个项目由Apache Software Foundation 迁移到了Google Code，且改名为MyBatis 。2013年11月迁移到GitHub。iBATIS一词来源于“internet”和“abatis”的组合，是一个基于Java的持久层框架。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;MyBatis 是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 POJOs(Plain Ordinary Java Object,普通的 Java对象)映射成数据库中的记录。&lt;/p&gt;
&lt;img data-src=&#34;/2022/10/07/ORM/Mybatis/image-20220617192446302.png&#34; class=&#34;&#34; title=&#34;image-20220617192446302&#34;&gt;

&lt;p&gt;精简解释：MyBatis是一个半自动ORM框架，其本质是对JDBC的封装。使用MyBatis重点需要程序员编写SQL命令，不需要写一行JDBC代码&lt;/p&gt;
&lt;h1 id=&#34;2-MyBatis初次使用&#34;&gt;&lt;a href=&#34;#2-MyBatis初次使用&#34; class=&#34;headerlink&#34; title=&#34;2 MyBatis初次使用&#34;&gt;&lt;/a&gt;2 MyBatis初次使用&lt;/h1&gt;&lt;h2 id=&#34;1-创建maven项目导入相关依赖&#34;&gt;&lt;a href=&#34;#1-创建maven项目导入相关依赖&#34; class=&#34;headerlink&#34; title=&#34;1 创建maven项目导入相关依赖&#34;&gt;&lt;/a&gt;1 创建maven项目导入相关依赖&lt;/h2&gt;&lt;p&gt;但凡是框架,使用都是分三步走&lt;/p&gt;
&lt;p&gt;1导入jar文件,maven&lt;/p&gt;
&lt;p&gt;2处理配置文件&lt;/p&gt;
&lt;p&gt;3开发业务代码&lt;/p&gt;
&lt;p&gt;先创建一个空项目,用于存放后面Mybatis相关项目模块&lt;/p&gt;
&lt;img data-src=&#34;/2022/10/07/ORM/Mybatis/image-20220617192550409.png&#34; class=&#34;&#34; title=&#34;image-20220617192550409&#34;&gt;


&lt;p&gt;项目名为mybatisAll即可&lt;/p&gt;
&lt;img data-src=&#34;/2022/10/07/ORM/Mybatis/image-20220617192555641.png&#34; class=&#34;&#34; title=&#34;image-20220617192555641&#34;&gt;




&lt;p&gt;这里不显示项目名 没关系,如果想看到项目名,可以close项目后,再次open即可&lt;/p&gt;
&lt;img data-src=&#34;/2022/10/07/ORM/Mybatis/image-20220617192604832.png&#34; class=&#34;&#34; title=&#34;image-20220617192604832&#34;&gt;




&lt;p&gt;关闭项目&lt;/p&gt;
&lt;img data-src=&#34;/2022/10/07/ORM/Mybatis/image-20220617192611548.png&#34; class=&#34;&#34; title=&#34;image-20220617192611548&#34;&gt;


&lt;p&gt;再次open&lt;/p&gt;
&lt;img data-src=&#34;/2022/10/07/ORM/Mybatis/image-20220617192630884.png&#34; class=&#34;&#34; title=&#34;image-20220617192630884&#34;&gt;






&lt;p&gt;项目名就显示了&lt;/p&gt;
&lt;img data-src=&#34;/2022/10/07/ORM/Mybatis/image-20220617192636190.png&#34; class=&#34;&#34; title=&#34;image-20220617192636190&#34;&gt;


&lt;p&gt;接下来设置maven为我们自己安装的,不用idea自带的(当然用自带的也行)&lt;/p&gt;
&lt;img data-src=&#34;/2022/10/07/ORM/Mybatis/image-20220617192641520.png&#34; class=&#34;&#34; title=&#34;image-20220617192641520&#34;&gt;



&lt;img data-src=&#34;/2022/10/07/ORM/Mybatis/image-20220617192647200.png&#34; class=&#34;&#34; title=&#34;image-20220617192647200&#34;&gt;


&lt;p&gt;在当前项目中创建模块&lt;/p&gt;
&lt;img data-src=&#34;/2022/10/07/ORM/Mybatis/image-20220617192652567.png&#34; class=&#34;&#34; title=&#34;image-20220617192652567&#34;&gt;


&lt;p&gt;选择maven项目 next&lt;/p&gt;
&lt;img data-src=&#34;/2022/10/07/ORM/Mybatis/image-20220617192703265.png&#34; class=&#34;&#34; title=&#34;image-20220617192703265&#34;&gt;






&lt;p&gt;输入groupid和aitifactid  然后finish&lt;/p&gt;
&lt;img data-src=&#34;/2022/10/07/ORM/Mybatis/image-20220617192713221.png&#34; class=&#34;&#34; title=&#34;image-20220617192713221&#34;&gt;


&lt;p&gt;检查项目目前在磁盘上的存放路径 然后next&lt;/p&gt;
&lt;img data-src=&#34;/2022/10/07/ORM/Mybatis/image-20220617192719403.png&#34; class=&#34;&#34; title=&#34;image-20220617192719403&#34;&gt;




&lt;p&gt;检查项目目录结构是否有缺失&lt;/p&gt;
&lt;img data-src=&#34;/2022/10/07/ORM/Mybatis/image-20220617192723928.png&#34; class=&#34;&#34; title=&#34;image-20220617192723928&#34;&gt;


&lt;p&gt;MyBatis官网说明文档   &lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9teWJhdGlzLm9yZy9teWJhdGlzLTMvemgvaW5kZXguaHRtbA==&#34;&gt;https://mybatis.org/mybatis-3/zh/index.html&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;在pom.xml中导入MyBatis相关依赖jar文件&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;
&amp;lt;project xmlns=&amp;quot;http://maven.apache.org/POM/4.0.0&amp;quot;
         xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot;
         xsi:schemaLocation=&amp;quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&amp;quot;&amp;gt;
    &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;
    &amp;lt;groupId&amp;gt;com.msb&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;mybatisTest01&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.0-SNAPSHOT&amp;lt;/version&amp;gt;
    &amp;lt;packaging&amp;gt;jar&amp;lt;/packaging&amp;gt;
    &amp;lt;dependencies&amp;gt;
        &amp;lt;!--mysqlConnector--&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;mysql&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;mysql-connector-java&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;8.0.16&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;!--mybatis 核心jar包--&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.mybatis&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;mybatis&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;3.5.3&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;!--junit--&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;junit&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;junit&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;4.13.1&amp;lt;/version&amp;gt;
            &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;!--lombok --&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.projectlombok&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;lombok&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;1.18.12&amp;lt;/version&amp;gt;
            &amp;lt;scope&amp;gt;provided&amp;lt;/scope&amp;gt;
        &amp;lt;/dependency&amp;gt;
    &amp;lt;/dependencies&amp;gt;
&amp;lt;/project&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;安装lombok插件后,重启idea&lt;/p&gt;
&lt;img data-src=&#34;/2022/10/07/ORM/Mybatis/image-20220617192808470.png&#34; class=&#34;&#34; title=&#34;image-20220617192808470&#34;&gt;




&lt;p&gt;导入lombok依赖后,单独设置启用注解处理&lt;/p&gt;
&lt;img data-src=&#34;/2022/10/07/ORM/Mybatis/image-20220617192814365.png&#34; class=&#34;&#34; title=&#34;image-20220617192814365&#34;&gt;



&lt;h2 id=&#34;2-准备数据库-包结构和实体类&#34;&gt;&lt;a href=&#34;#2-准备数据库-包结构和实体类&#34; class=&#34;headerlink&#34; title=&#34;2  准备数据库_包结构和实体类&#34;&gt;&lt;/a&gt;2  准备数据库_包结构和实体类&lt;/h2&gt;&lt;p&gt;数据库&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;/../spring/img/image-20220617192857161.png&#34; alt=&#34;image-20220617192857161&#34;&gt;&lt;/p&gt;
&lt;p&gt;项目结构&lt;/p&gt;
&lt;img data-src=&#34;/2022/10/07/ORM/Mybatis/image-20220617192901785.png&#34; class=&#34;&#34; title=&#34;image-20220617192901785&#34;&gt;

&lt;p&gt; 实体类Dept&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt; package com.msb.pojo;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import java.io.Serializable;
/**

 * @Author: Ma HaiYang
 * @Description: MircoMessage:Mark_7001
    */
    @Data
    @AllArgsConstructor
    @NoArgsConstructor
    public class Dept implements Serializable &amp;#123;
    private Integer deptno;
    private String dname;
    private String loc;
    &amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;3-准备Mapper映射文件和核心配置文件&#34;&gt;&lt;a href=&#34;#3-准备Mapper映射文件和核心配置文件&#34; class=&#34;headerlink&#34; title=&#34;3 准备Mapper映射文件和核心配置文件&#34;&gt;&lt;/a&gt;3 准备Mapper映射文件和核心配置文件&lt;/h2&gt;&lt;p&gt;resources目录下 创建 com&amp;#x2F;msb&amp;#x2F;mapper目录,然后添加DeptMapper.xml映射文件&lt;/p&gt;
&lt;img data-src=&#34;/2022/10/07/ORM/Mybatis/image-20220617193030929.png&#34; class=&#34;&#34; title=&#34;image-20220617193030929&#34;&gt;

&lt;pre&gt;&lt;code class=&#34;xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot; ?&amp;gt;
&amp;lt;!DOCTYPE mapper
        PUBLIC &amp;quot;-//mybatis.org//DTD Mapper 3.0//EN&amp;quot;
        &amp;quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&amp;quot;&amp;gt;
&amp;lt;mapper namespace=&amp;quot;aaa&amp;quot;&amp;gt;
    &amp;lt;!--public List&amp;lt;Dept&amp;gt; findAll()&amp;#123;    &amp;#125;--&amp;gt;
    &amp;lt;select id=&amp;quot;findAll&amp;quot; resultType=&amp;quot;com.msb.pojo.Dept&amp;quot; &amp;gt;
        select * from dept
    &amp;lt;/select&amp;gt;
&amp;lt;/mapper&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;resources目录下准备sqlMapConfig.xml 核心配置文件&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot; ?&amp;gt;
&amp;lt;!DOCTYPE configuration
        PUBLIC &amp;quot;-//mybatis.org//DTD Config 3.0//EN&amp;quot;
        &amp;quot;http://mybatis.org/dtd/mybatis-3-config.dtd&amp;quot;&amp;gt;
&amp;lt;configuration&amp;gt;
    &amp;lt;environments default=&amp;quot;development&amp;quot;&amp;gt;
        &amp;lt;environment id=&amp;quot;development&amp;quot;&amp;gt;
            &amp;lt;transactionManager type=&amp;quot;JDBC&amp;quot;/&amp;gt;
            &amp;lt;dataSource type=&amp;quot;POOLED&amp;quot;&amp;gt;
                &amp;lt;property name=&amp;quot;driver&amp;quot; value=&amp;quot;com.mysql.cj.jdbc.Driver&amp;quot;/&amp;gt;
                &amp;lt;property name=&amp;quot;url&amp;quot; value=&amp;quot;jdbc:mysql://127.0.0.1:3306/mydb?useSSL=false&amp;amp;amp;useUnicode=true&amp;amp;amp;characterEncoding=UTF-8&amp;amp;amp;serverTimezone=Asia/Shanghai&amp;quot;/&amp;gt;
                &amp;lt;property name=&amp;quot;username&amp;quot; value=&amp;quot;root&amp;quot;/&amp;gt;
                &amp;lt;property name=&amp;quot;password&amp;quot; value=&amp;quot;root&amp;quot;/&amp;gt;
            &amp;lt;/dataSource&amp;gt;
        &amp;lt;/environment&amp;gt;
    &amp;lt;/environments&amp;gt;
    &amp;lt;!--加载mapper映射文件--&amp;gt;
    &amp;lt;mappers&amp;gt;
        &amp;lt;mapper resource=&amp;quot;com/msb/mapper/DeptMapper.xml&amp;quot;/&amp;gt;
    &amp;lt;/mappers&amp;gt;
&amp;lt;/configuration&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;4-运行测试&#34;&gt;&lt;a href=&#34;#4-运行测试&#34; class=&#34;headerlink&#34; title=&#34;4 运行测试&#34;&gt;&lt;/a&gt;4 运行测试&lt;/h2&gt;&lt;img data-src=&#34;/2022/10/07/ORM/Mybatis/image-20220617193244713.png&#34; class=&#34;&#34; title=&#34;image-20220617193244713&#34;&gt;

&lt;p&gt;在test目录下开发测试代码并运行&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;/../spring/img/image-20220617193259351.png&#34; alt=&#34;image-20220617193259351&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt; package com.msb.test;
import com.msb.pojo.Dept;
import org.apache.ibatis.io.Resources;
import org.apache.ibatis.session.SqlSession;
import org.apache.ibatis.session.SqlSessionFactory;
import org.apache.ibatis.session.SqlSessionFactoryBuilder;
import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import java.io.IOException;
import java.io.InputStream;
import java.util.List;
/**

 * @Author: Ma HaiYang
 * @Description: MircoMessage:Mark_7001
    */
    public class Test1 &amp;#123;
    private SqlSession sqlSession;
    @Before
    public void init()&amp;#123;
        SqlSessionFactoryBuilder ssfb =new SqlSessionFactoryBuilder();
        InputStream resourceAsStream = null;
        try &amp;#123;
            resourceAsStream = Resources.getResourceAsStream(&amp;quot;sqlMapConfig.xml&amp;quot;);
        &amp;#125; catch (IOException e) &amp;#123;
            e.printStackTrace();
        &amp;#125;
        SqlSessionFactory factory=ssfb.build(resourceAsStream) ;
        sqlSession=factory.openSession();
    &amp;#125;
    @Test
    public void testFindAll()&amp;#123;
        // 调用SQL语句
        List&amp;lt;Dept&amp;gt; list = sqlSession.selectList(&amp;quot;findAll&amp;quot;);
        for (Dept dept : list) &amp;#123;
            System.out.println(dept);
        &amp;#125;
    &amp;#125;
    @After
    public void release()&amp;#123;
        // 关闭SQLSession
        sqlSession.close();
    &amp;#125;
    &amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;3-MyBatis配置详解&#34;&gt;&lt;a href=&#34;#3-MyBatis配置详解&#34; class=&#34;headerlink&#34; title=&#34;3 MyBatis配置详解&#34;&gt;&lt;/a&gt;3 MyBatis配置详解&lt;/h1&gt;&lt;h3 id=&#34;1-log4j1和log4j2的简单配置&#34;&gt;&lt;a href=&#34;#1-log4j1和log4j2的简单配置&#34; class=&#34;headerlink&#34; title=&#34;1_log4j1和log4j2的简单配置&#34;&gt;&lt;/a&gt;1_log4j1和log4j2的简单配置&lt;/h3&gt;&lt;p&gt;项目中添加依赖&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;xml&#34;&gt;&amp;lt;!-- log4j2 --&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.apache.logging.log4j&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;log4j-core&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;2.12.1&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;!-- log4j1 --&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;log4j&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;log4j&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.2.17&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;在mybatis.cfg.xml中配置MyBatis所使用的具体日志实现。如果不指定将自动搜索。可能会搜到log4j，但是如果优先搜到了其他的日志实现呢，所以还是设置为好。这一来log4j就跑不了了。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;log4j 1&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;将log4j.properties文件负责到src下。另外在其中可以将全局的日志级别调高，避免大量debug信息的干扰。同时将对映射文件的操作调低，可以用来显示SQL语句的调试信息。开发阶段，建议启动控制的日志。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt; #定义全局日志级别调试阶段推荐debug&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;properties&#34;&gt;log4j.rootLogger=debug,stdout 
log4j.appender.stdout=org.apache.log4j.ConsoleAppender
log4j.appender.stdout.Target=System.err
log4j.appender.stdout.layout=org.apache.log4j.SimpleLayout
log4j.appender.logfile=org.apache.log4j.FileAppender
log4j.appender.logfile.File=d:/msb.log
log4j.appender.logfile.layout=org.apache.log4j.PatternLayout
log4j.appender.logfile.layout.ConversionPattern=%d&amp;#123;yyyy-MM-dd HH:mm:ss&amp;#125; %l %F %p %m%n
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在核心配置文件中可以选择的其他日志处理方式&lt;/p&gt;
&lt;p&gt;log4j 2&lt;/p&gt;
&lt;p&gt;将log4j2.xml文件负责到resources下。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;xml&#34;&gt; &amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;
&amp;lt;Configuration status=&amp;quot;DEBUG&amp;quot;&amp;gt;
    &amp;lt;Appenders&amp;gt;
        &amp;lt;Console name=&amp;quot;Console&amp;quot; target=&amp;quot;SYSTEM_ERR&amp;quot;&amp;gt;
            &amp;lt;PatternLayout pattern=&amp;quot;%d&amp;#123;YYYY-MM-dd HH:mm:ss&amp;#125; [%t] %-5p %c&amp;#123;1&amp;#125;:%L - %msg%n&amp;quot; /&amp;gt;
        &amp;lt;/Console&amp;gt;
        &amp;lt;RollingFile name=&amp;quot;RollingFile&amp;quot; filename=&amp;quot;log/test.log&amp;quot;
                     filepattern=&amp;quot;$&amp;#123;logPath&amp;#125;/%d&amp;#123;YYYYMMddHHmmss&amp;#125;-fargo.log&amp;quot;&amp;gt;
            &amp;lt;PatternLayout pattern=&amp;quot;%d&amp;#123;YYYY-MM-dd HH:mm:ss&amp;#125; [%t] %-5p %c&amp;#123;1&amp;#125;:%L - %msg%n&amp;quot; /&amp;gt;
            &amp;lt;Policies&amp;gt;
                &amp;lt;SizeBasedTriggeringPolicy size=&amp;quot;10 MB&amp;quot; /&amp;gt;
            &amp;lt;/Policies&amp;gt;
            &amp;lt;DefaultRolloverStrategy max=&amp;quot;20&amp;quot; /&amp;gt;
        &amp;lt;/RollingFile&amp;gt;
    &amp;lt;/Appenders&amp;gt;
    &amp;lt;Loggers&amp;gt;
        &amp;lt;Root level=&amp;quot;INFO&amp;quot;&amp;gt;
            &amp;lt;AppenderRef ref=&amp;quot;Console&amp;quot; /&amp;gt;
        &amp;lt;/Root&amp;gt;
    &amp;lt;/Loggers&amp;gt;
&amp;lt;/Configuration&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;核心配置文件中可以指定日志打印方式&lt;/p&gt;
&lt;img data-src=&#34;/2022/10/07/ORM/Mybatis/image-20220617193736735.png&#34; class=&#34;&#34; title=&#34;image-20220617193736735&#34;&gt;



&lt;h2 id=&#34;2-关于事务配置&#34;&gt;&lt;a href=&#34;#2-关于事务配置&#34; class=&#34;headerlink&#34; title=&#34;2_关于事务配置&#34;&gt;&lt;/a&gt;2_关于事务配置&lt;/h2&gt;&lt;img data-src=&#34;/2022/10/07/ORM/Mybatis/image-20220617193831478.png&#34; class=&#34;&#34; title=&#34;image-20220617193831478&#34;&gt;

&lt;p&gt;在mybatis核心配置文件中 envirment中 通过transactionManager配置事务的处理策略&lt;/p&gt;
&lt;p&gt;&lt;font color=#FF000&gt;JDBC&lt;/font&gt; – 这个配置直接简单使用了 JDBC 的提交和回滚设置。它依赖于从数据源得到的连接来管理事务范围。&lt;/p&gt;
&lt;p&gt;&lt;font color=#FF000&gt;MANAGED &lt;/font&gt;– 这个配置几乎没做什么。它从来不提交或回滚一个连接。而它会让容器来管理事务的整个生命周期(比如 Spring 或 JEE 应用服务器的上下文) 默认情况下它会关闭连接。然而一些容器并不希望这样, 因此如果你需要从连接中停止它,将closeConnection 属性设置为 false. mybatis本身并不做事务的处理,交给其他框架去处理事务,如spring&lt;/p&gt;
&lt;h2 id=&#34;3-关于映射文件的加载方式&#34;&gt;&lt;a href=&#34;#3-关于映射文件的加载方式&#34; class=&#34;headerlink&#34; title=&#34;3_关于映射文件的加载方式&#34;&gt;&lt;/a&gt;3_关于映射文件的加载方式&lt;/h2&gt;&lt;p&gt;1.mapper映射文件的文件路径导入 使用的mapper标签的resource属性&lt;/p&gt;
&lt;p&gt;2.网络资源路径 使用的mapper标签的url属性&lt;/p&gt;
&lt;p&gt;3.接口的全限定名导入 使用的是mapper标签的class属性 (基于接口的代理模式开发)&lt;/p&gt;
&lt;p&gt;4.包扫描形式加载所有的mapper映射文件 使用的是 package标签&lt;/p&gt;
&lt;img data-src=&#34;/2022/10/07/ORM/Mybatis/image-20220617193946594.png&#34; class=&#34;&#34; title=&#34;image-20220617193946594&#34;&gt;

&lt;h2 id=&#34;4-关于实体类别名处理&#34;&gt;&lt;a href=&#34;#4-关于实体类别名处理&#34; class=&#34;headerlink&#34; title=&#34;4_关于实体类别名处理&#34;&gt;&lt;/a&gt;4_关于实体类别名处理&lt;/h2&gt;&lt;p&gt;在mybatis核心配置文件中使用别名处理&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;xml&#34;&gt; &amp;lt;!--设置实体类别名--&amp;gt;
&amp;lt;typeAliases&amp;gt;
    &amp;lt;!--
    通过包扫描给所有的实体类起别名
    给指定报名下的所有类起别名
    默认每个实体类的别名是首字母小写的类名
    Dept   dept
    Emp    emp
    --&amp;gt;
    &amp;lt;package name=&amp;quot;com.msb.pojo&amp;quot;/&amp;gt;
&amp;lt;/typeAliases&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在映射文件的resultType 返回值类型  和paramterType 上就可以使用别名了&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;xml&#34;&gt;&amp;lt;select id=&amp;quot;selectByEmpno&amp;quot;  resultType=&amp;quot;emp&amp;quot;&amp;gt;
    select * from emp where empno = 7566
&amp;lt;/select&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;5-关于外部属性配置文件存储数据库连接信息&#34;&gt;&lt;a href=&#34;#5-关于外部属性配置文件存储数据库连接信息&#34; class=&#34;headerlink&#34; title=&#34;5_关于外部属性配置文件存储数据库连接信息&#34;&gt;&lt;/a&gt;5_关于外部属性配置文件存储数据库连接信息&lt;/h2&gt;&lt;p&gt;在resources下准备jdbc.properties属性配置文件&lt;/p&gt;
&lt;img data-src=&#34;/2022/10/07/ORM/Mybatis/image-20220617194131042.png&#34; class=&#34;&#34; title=&#34;image-20220617194131042&#34;&gt;


&lt;p&gt;配置文件中的内容&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;properties&#34;&gt;jdbc_driver=com.mysql.cj.jdbc.Driver
jdbc_url=jdbc:mysql://127.0.0.1:3306/mydb?useSSL=false&amp;amp;useUnicode=true&amp;amp;characterEncoding=UTF-8&amp;amp;serverTimezone=Asia/Shanghai
jdbc_username=root
jdbc_password=root
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在核心配置文件中引入db.properties属性文件&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;xml&#34;&gt; &amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot; ?&amp;gt;
&amp;lt;!-- xml文档约束 约束xml文档中可以有哪些标签,哪些属性,以及标签的包含关系和顺序....
dtd 约束
schema 约束
--&amp;gt;

&amp;lt;!DOCTYPE configuration
        PUBLIC &amp;quot;-//mybatis.org//DTD Config 3.0//EN&amp;quot;
        &amp;quot;http://mybatis.org/dtd/mybatis-3-config.dtd&amp;quot;&amp;gt;
&amp;lt;configuration&amp;gt;
    &amp;lt;properties resource=&amp;quot;jdbc.properties&amp;quot;&amp;gt;&amp;lt;/properties&amp;gt;
    &amp;lt;settings&amp;gt;
        &amp;lt;!--设置日志处理方式--&amp;gt;
        &amp;lt;setting name=&amp;quot;logImpl&amp;quot; value=&amp;quot;LOG4J&amp;quot;/&amp;gt;
    &amp;lt;/settings&amp;gt;
    &amp;lt;!--设置实体类别名--&amp;gt;
    &amp;lt;typeAliases&amp;gt;
        &amp;lt;!--
        通过包扫描给所有的实体类起别名
        给指定报名下的所有类起别名
        默认每个实体类的别名是首字母小写的类名
        Dept   dept
        Emp    emp
        --&amp;gt;
        &amp;lt;package name=&amp;quot;com.msb.pojo&amp;quot;/&amp;gt;
    &amp;lt;/typeAliases&amp;gt;
    &amp;lt;!--配置数据库链接信息--&amp;gt;
    &amp;lt;environments default=&amp;quot;mysql&amp;quot;&amp;gt;
        &amp;lt;!--数据源1--&amp;gt;
        &amp;lt;environment id=&amp;quot;mysql&amp;quot;&amp;gt;
            &amp;lt;transactionManager type=&amp;quot;JDBC&amp;quot;/&amp;gt;
            &amp;lt;!--一个数据源--&amp;gt;
            &amp;lt;dataSource type=&amp;quot;POOLED&amp;quot;&amp;gt;
                &amp;lt;property name=&amp;quot;driver&amp;quot; value=&amp;quot;$&amp;#123;jdbc_driver&amp;#125;&amp;quot;/&amp;gt;
                &amp;lt;property name=&amp;quot;url&amp;quot; value=&amp;quot;$&amp;#123;jdbc_url&amp;#125;&amp;quot;/&amp;gt;
                &amp;lt;property name=&amp;quot;username&amp;quot; value=&amp;quot;$&amp;#123;jdbc_username&amp;#125;&amp;quot;/&amp;gt;
                &amp;lt;property name=&amp;quot;password&amp;quot; value=&amp;quot;$&amp;#123;jdbc_password&amp;#125;&amp;quot;/&amp;gt;
            &amp;lt;/dataSource&amp;gt;
        &amp;lt;/environment&amp;gt;
    &amp;lt;/environments&amp;gt;
    &amp;lt;!--加载映射文件的--&amp;gt;
    &amp;lt;mappers&amp;gt;
        &amp;lt;mapper resource=&amp;quot;com/msb/mapper/DeptMapper.xml&amp;quot;/&amp;gt;
    &amp;lt;/mappers&amp;gt;
&amp;lt;/configuration&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;4-MyBatis传统DAO模式开发&#34;&gt;&lt;a href=&#34;#4-MyBatis传统DAO模式开发&#34; class=&#34;headerlink&#34; title=&#34;4 MyBatis传统DAO模式开发&#34;&gt;&lt;/a&gt;4 MyBatis传统DAO模式开发&lt;/h1&gt;&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;普通模式,也称为传统DAO模式,就是在传统DAO模式下,定义接口和实现类,如 interface EmpDao  class EmpDaoImpl implements EmpDao.  在实现类中,用SQLSession对象调用select insert delete update 等方法实现.目前极为少见.在传统模式下,我们需要知道SqlSession对象 实现CURD和 参数传递的处理
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;1-sqlSession查询的三种方式&#34;&gt;&lt;a href=&#34;#1-sqlSession查询的三种方式&#34; class=&#34;headerlink&#34; title=&#34;1_sqlSession查询的三种方式&#34;&gt;&lt;/a&gt;1_sqlSession查询的三种方式&lt;/h2&gt;&lt;p&gt;SqlSession对象本身的API中就有三个查询方法,分别能够实现如下查询方式&lt;/p&gt;
&lt;p&gt;1返回单个对象 selectOne&lt;/p&gt;
&lt;p&gt;2返回对象List集合 selectList&lt;/p&gt;
&lt;p&gt;3返回对象Map集合 selectMap&lt;/p&gt;
&lt;p&gt;接下来我们就对这三个方法进行一个快速的学习&lt;/p&gt;
&lt;img data-src=&#34;/2022/10/07/ORM/Mybatis/image-20220617194257643.png&#34; class=&#34;&#34; title=&#34;image-20220617194257643&#34;&gt;


&lt;p&gt;创建Emp实体类&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;@AllArgsConstructor
@NoArgsConstructor
@Data
public class Emp implements Serializable &amp;#123;
    private Integer empno;
    private String ename;
    private String job;
    private Integer mgr;
    private Date hiredate;
    private Double sal;
    private Double comm;
    private Integer deptno;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;准备Mapper映射文件&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot; ?&amp;gt;
&amp;lt;!DOCTYPE mapper
        PUBLIC &amp;quot;-//mybatis.org//DTD Mapper 3.0//EN&amp;quot;
        &amp;quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&amp;quot;&amp;gt;
&amp;lt;mapper namespace=&amp;quot;EmpMapper&amp;quot;&amp;gt;
    &amp;lt;!--
    返回单个对象
    public Emp findOne();
    id 相当于方法名
    resultType 相当于返回值类型
        sql语句的查询结果用哪个类来进行封装 如果返回值类型是集合,这里写的也是集合中的元素对应的类,不是集合本身作为类型
    paramaterType 参数类型
    SQL语句就是具体的方法体的实现
    --&amp;gt;
    &amp;lt;select id=&amp;quot;findOne&amp;quot; resultType=&amp;quot;emp&amp;quot; &amp;gt;
        select * from emp where empno = 7499
    &amp;lt;/select&amp;gt;
    &amp;lt;!--
    返回多个对象List集合
    查询全部的员工信息
    public List&amp;lt;Emp&amp;gt; findAll()
    --&amp;gt;
    &amp;lt;select id=&amp;quot;findAll&amp;quot; resultType=&amp;quot;emp&amp;quot;&amp;gt;
        select * from emp
    &amp;lt;/select&amp;gt;
    &amp;lt;!--返回多个对象的Map集合
    把查询出来的数据中的某一列作为键,整条数据封装的对象作为值
    public Map&amp;lt;key,Emp&amp;gt; findEmpMap()
    &amp;lt;empno,Emp&amp;gt;
    &amp;lt;key,Emp&amp;gt;
    --&amp;gt;
    &amp;lt;select id=&amp;quot;findEmpMap&amp;quot; resultType=&amp;quot;map&amp;quot;&amp;gt;
        select * from emp
    &amp;lt;/select&amp;gt;
&amp;lt;/mapper&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;sqlMapConfig中导入EmpMapper映射文件&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;xml&#34;&gt;&amp;lt;!--加载mapper映射文件--&amp;gt;
&amp;lt;mappers&amp;gt;
    &amp;lt;mapper resource=&amp;quot;com/msb/mapper/DeptMapper.xml&amp;quot;/&amp;gt;
    &amp;lt;mapper resource=&amp;quot;com/msb/mapper/EmpMapper.xml&amp;quot;/&amp;gt;
&amp;lt;/mappers&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;测试代码&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;package com.msb.test;
import com.msb.pojo.Dept;
import com.msb.pojo.Emp;
import org.apache.ibatis.io.Resources;
import org.apache.ibatis.session.SqlSession;
import org.apache.ibatis.session.SqlSessionFactory;
import org.apache.ibatis.session.SqlSessionFactoryBuilder;
import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import java.io.IOException;
import java.io.InputStream;
import java.util.List;
import java.util.Map;
import java.util.Set;
/**

 * @Author: Ma HaiYang
 * @Description: MircoMessage:Mark_7001
    */
    public class Test2 &amp;#123;
    private SqlSession sqlSession;
    @Before
    public void init()&amp;#123;
        SqlSessionFactoryBuilder ssfb =new SqlSessionFactoryBuilder();
        InputStream resourceAsStream = null;
        try &amp;#123;
            resourceAsStream = Resources.getResourceAsStream(&amp;quot;sqlMapConfig.xml&amp;quot;);
        &amp;#125; catch (IOException e) &amp;#123;
            e.printStackTrace();
        &amp;#125;
        SqlSessionFactory factory=ssfb.build(resourceAsStream) ;
        sqlSession=factory.openSession();
    &amp;#125;
    @Test
    public void testSelectOne()&amp;#123;
        // 查询单个对象
        System.out.println(&amp;quot;sqlSession查询单个对象&amp;quot;);
        Emp emp = sqlSession.selectOne(&amp;quot;findOne&amp;quot;);
        System.out.println(emp);
    &amp;#125;
    @Test
    public void testSelectList()&amp;#123;
        // 查询多个对象的List集合
        System.out.println(&amp;quot;sqlSession查询对象List集合&amp;quot;);
        List&amp;lt;Emp&amp;gt; emps = sqlSession.selectList(&amp;quot;EmpMapper.findAll&amp;quot;);
        emps.forEach(System.out::println);
    &amp;#125;
    @Test
    public void testSelectMap()&amp;#123;
        // 查询多个对象的Map集合
        System.out.println(&amp;quot;sqlSession查询对象Map集合&amp;quot;);
        Map&amp;lt;Integer, Emp&amp;gt; empMap = sqlSession.selectMap(&amp;quot;findEmpMap&amp;quot;, &amp;quot;EMPNO&amp;quot;);
        Set&amp;lt;Integer&amp;gt; empnos = empMap.keySet();
        for (Integer empno : empnos) &amp;#123;
            System.out.println(empno+&amp;quot; :&amp;quot; +empMap.get(empno));
        &amp;#125;
    &amp;#125;
    @After
    public void release()&amp;#123;
        // 关闭SQLSession
        sqlSession.close();
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;2-sqlSession传递参数的三种方式&#34;&gt;&lt;a href=&#34;#2-sqlSession传递参数的三种方式&#34; class=&#34;headerlink&#34; title=&#34;2_sqlSession传递参数的三种方式&#34;&gt;&lt;/a&gt;2_sqlSession传递参数的三种方式&lt;/h2&gt;&lt;p&gt;1 单个基础数据类型作为参数&lt;/p&gt;
&lt;p&gt;2 多个基础数据类型的map 集合作为参数&lt;/p&gt;
&lt;p&gt;3 引用类型作为参数&lt;/p&gt;
&lt;p&gt;Mapper映射文件&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;xml&#34;&gt; &amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot; ?&amp;gt;
&amp;lt;!DOCTYPE mapper
        PUBLIC &amp;quot;-//mybatis.org//DTD Mapper 3.0//EN&amp;quot;
        &amp;quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&amp;quot;&amp;gt;
&amp;lt;mapper namespace=&amp;quot;EmpMapper2&amp;quot;&amp;gt;
    &amp;lt;!--
    参数为一个基本数据类型
    根据员工工号查询员工的全部信息,返回单个员工对象
    public Emp findByEmpno(int empno);
    parameterType 在有参数情况下也是可以省略不写  mybatis 可以根据实际情况自动判断
    如果要写parameterType 那么就要写对
    在SQL语句上可以使用$&amp;#123;&amp;#125;  #&amp;#123;&amp;#125; 代表参数的占位
    如果参数是单个基本数据类型,&amp;#123;&amp;#125;中名字可以随便写,见名知意
    $&amp;#123;&amp;#125; 代表mybatis底层使用Statment语句对象,参数是以字符串拼接的形式设置
    #&amp;#123;&amp;#125; 代表mybatis底层使用的preparedStatment语句对象,参数使用?作为占位符处理
    #&amp;#123;&amp;#125; 以后常用
    --&amp;gt;
    &amp;lt;select id=&amp;quot;findByEmpno&amp;quot; resultType=&amp;quot;emp&amp;quot; parameterType=&amp;quot;int&amp;quot;&amp;gt;
        select  * from emp where empno = #&amp;#123;empno&amp;#125;
    &amp;lt;/select&amp;gt;
    &amp;lt;!--
    参数为map集合
    查询指定部门号和指定最低薪资的员工信息
    20 号部门 且工资在1500以上的员工信息
    public List&amp;lt;Emp&amp;gt; findEmpByDeptnoAndSal(int deptno,double sal);
    &amp;lt;  &amp;gt;  最好要进行转译处理,参照HTML转译  w3school在线文档中有转译符号对应规则
     Map&amp;lt;String,Object&amp;gt; args=new HashMap&amp;lt;&amp;gt;();
        args.put(&amp;quot;deptno&amp;quot;, 20);
        args.put(&amp;quot;sal&amp;quot;, 1500.0);
    #&amp;#123;&amp;#125;中写的是map集合中,参数的键
    --&amp;gt;
    &amp;lt;select id=&amp;quot;findEmpByDeptnoAndSal&amp;quot; resultType=&amp;quot;emp&amp;quot; parameterType=&amp;quot;map&amp;quot;&amp;gt;
    &amp;lt;/select&amp;gt;
    &amp;lt;!--
   参数为对象
   emp &amp;gt;&amp;gt;&amp;gt;  deptno   sal
   参数是我们自定义的类型,那么 #&amp;#123;&amp;#125;中写的是参数的属性名
   --&amp;gt;
    &amp;lt;select id=&amp;quot;findEmpByDeptnoAndSal2&amp;quot; resultType=&amp;quot;emp&amp;quot; parameterType=&amp;quot;emp&amp;quot;&amp;gt;
    &amp;lt;/select&amp;gt;
&amp;lt;/mapper&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;测试代码&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt; package com.msb.test;
import com.msb.pojo.Emp;
import org.apache.ibatis.io.Resources;
import org.apache.ibatis.session.SqlSession;
import org.apache.ibatis.session.SqlSessionFactory;
import org.apache.ibatis.session.SqlSessionFactoryBuilder;
import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import java.io.IOException;
import java.io.InputStream;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
/**

 * @Author: Ma HaiYang
 * @Description: MircoMessage:Mark_7001
    */
    public class Test3 &amp;#123;
    private SqlSession sqlSession;
    @Before
    public void init()&amp;#123;
        SqlSessionFactoryBuilder ssfb =new SqlSessionFactoryBuilder();
        InputStream resourceAsStream = null;
        try &amp;#123;
            resourceAsStream = Resources.getResourceAsStream(&amp;quot;sqlMapConfig.xml&amp;quot;);
        &amp;#125; catch (IOException e) &amp;#123;
            e.printStackTrace();
        &amp;#125;
        SqlSessionFactory factory=ssfb.build(resourceAsStream) ;
        sqlSession=factory.openSession();
    &amp;#125;
    @Test
    public void testSingleArg()&amp;#123;
        // 测试单个基本数据类型作为参数
        Emp emp = sqlSession.selectOne(&amp;quot;findByEmpno&amp;quot;, 7499);
        System.out.println(emp);
    &amp;#125;
    @Test
    public void testMapArg()&amp;#123;
        // 测试Map集合作为参数
        Map&amp;lt;String,Object&amp;gt; args=new HashMap&amp;lt;&amp;gt;();
        args.put(&amp;quot;deptno&amp;quot;, 20);
        args.put(&amp;quot;sal&amp;quot;, 3000.0);
        List&amp;lt;Emp&amp;gt; emps = sqlSession.selectList(&amp;quot;findEmpByDeptnoAndSal&amp;quot;, args);
        emps.forEach(System.out::println);
    &amp;#125;
    @Test
    public void testEmpArg()&amp;#123;
        // 测试Map集合作为参数
        Emp arg =new Emp();
        arg.setDeptno(10);
        arg.setSal(2000.0);
        List&amp;lt;Emp&amp;gt; emps = sqlSession.selectList(&amp;quot;findEmpByDeptnoAndSal2&amp;quot;, arg);
        emps.forEach(System.out::println);
    &amp;#125;
    @After
    public void release()&amp;#123;
        // 关闭SQLSession
        sqlSession.close();
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;3-sqlSession完成DML所有操作&#34;&gt;&lt;a href=&#34;#3-sqlSession完成DML所有操作&#34; class=&#34;headerlink&#34; title=&#34;3_sqlSession完成DML所有操作&#34;&gt;&lt;/a&gt;3_sqlSession完成DML所有操作&lt;/h2&gt;&lt;p&gt;Mapper映射文件&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot; ?&amp;gt;
&amp;lt;!DOCTYPE mapper
        PUBLIC &amp;quot;-//mybatis.org//DTD Mapper 3.0//EN&amp;quot;
        &amp;quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&amp;quot;&amp;gt;
&amp;lt;mapper namespace=&amp;quot;EmpMapper3&amp;quot;&amp;gt;
    &amp;lt;!--
    增删方法的返回值类型都是int
    resultType就无需指定了
    insert update delete 标签中没有resultType
    但是仍然可以有paramaterType
    --&amp;gt;
    &amp;lt;!-- 增加方法
    public int addEmp(Emp emp);
    --&amp;gt;
    &amp;lt;insert id=&amp;quot;addEmp&amp;quot; parameterType=&amp;quot;emp&amp;quot;&amp;gt;
    &amp;lt;/insert&amp;gt;
    &amp;lt;!--修改
    根据工号修改员工姓名
    public int updateEmp(Emp emp);
    --&amp;gt;
    &amp;lt;update id=&amp;quot;updateEmp&amp;quot; parameterType=&amp;quot;emp&amp;quot;&amp;gt;
    &amp;lt;/update&amp;gt;
    &amp;lt;!-- 删除
    删除大于给定工号的员工信息
    public int deleteEmp(int empno)
    --&amp;gt;
    &amp;lt;delete id=&amp;quot;deleteEmp&amp;quot; parameterType=&amp;quot;int&amp;quot;&amp;gt;
        delete from emp where empno &amp;gt;= #&amp;#123;empno&amp;#125;
    &amp;lt;/delete&amp;gt;
&amp;lt;/mapper&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;测试代码&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;package com.msb.test;
import com.msb.pojo.Emp;
import org.apache.ibatis.io.Resources;
import org.apache.ibatis.session.SqlSession;
import org.apache.ibatis.session.SqlSessionFactory;
import org.apache.ibatis.session.SqlSessionFactoryBuilder;
import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import java.io.IOException;
import java.io.InputStream;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
/**
 * @Author: Ma HaiYang
 * @Description: MircoMessage:Mark_7001
 */
public class Test4 &amp;#123;
    private SqlSession sqlSession;
    @Before
    public void init()&amp;#123;
        SqlSessionFactoryBuilder ssfb =new SqlSessionFactoryBuilder();
        InputStream resourceAsStream = null;
        try &amp;#123;
            resourceAsStream = Resources.getResourceAsStream(&amp;quot;sqlMapConfig.xml&amp;quot;);
        &amp;#125; catch (IOException e) &amp;#123;
            e.printStackTrace();
        &amp;#125;
        SqlSessionFactory factory=ssfb.build(resourceAsStream) ;
        sqlSession=factory.openSession(true);
    &amp;#125;
    @Test
    public void testInsert()&amp;#123;
        Emp emp =new Emp(null,&amp;quot;按住啦Baby&amp;quot;,&amp;quot;SALESMAN&amp;quot;,7839,new Date(),3100.0, 200.0,10 );
        int rows = sqlSession.insert(&amp;quot;addEmp&amp;quot;, emp);
        System.out.println(rows);
        // 手动提交事务
        //sqlSession.commit();
        /*增删改 要提交事务
        * sqlSession.commit();手动提交事务
        * sqlSession=factory.openSession(true); 设置事务自动提交
        * */
    &amp;#125;
    @Test
    public void testUpdate()&amp;#123;
        Emp emp =new Emp( );
        emp.setEname(&amp;quot;晓明&amp;quot;);
        emp.setEmpno(7937);
        int rows = sqlSession.update(&amp;quot;updateEmp&amp;quot;, emp);
        System.out.println(rows);
    &amp;#125;
    @Test
    public void testDelete()&amp;#123;
        int rows = sqlSession.delete(&amp;quot;deleteEmp&amp;quot;, 7936);
        System.out.println(rows);
    &amp;#125;
    @After
    public void release()&amp;#123;
        // 关闭SQLSession
        sqlSession.close();
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;5-MyBatis代理模式开发&#34;&gt;&lt;a href=&#34;#5-MyBatis代理模式开发&#34; class=&#34;headerlink&#34; title=&#34;5 MyBatis代理模式开发&#34;&gt;&lt;/a&gt;5 MyBatis代理模式开发&lt;/h1&gt;&lt;p&gt;前面已经使用MyBatis完成了对Emp表的CRUD操作，都是由SqlSession调用自身方法发送SQL命令并得到结果的，实现了MyBatis的入门。&lt;/p&gt;
&lt;p&gt;但是却存在如下缺点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;不管是selectList()、selectOne()、selectMap()，都是通过SQLSession对象的API完成增删改查,都只能提供一个查询参数。如果要多个参数，需要封装到JavaBean或者Map中，并不一定永远是一个好办法。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;返回值类型较固定。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;只提供了映射文件，没有提供数据库操作的接口，不利于后期的维护扩展。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在MyBatis中提供了另外一种成为&lt;strong&gt;Mapper代理（或称为接口绑定）&lt;/strong&gt;的操作方式。在实际开发中也使用该方式。下面我们就是要Mapper代理的方式来实现对Emp表的CRUD操作吧，还有完成多个参数传递、模糊查询、自增主键回填等更多的技能实现。搭建好的项目框架如图所示，相比而言，增加了接口EmployeeMapper。但是却会引起映射文件和测试类的变化。&lt;/p&gt;
&lt;p&gt;优点:&lt;/p&gt;
&lt;p&gt;1有接口 模块之间有规范了&lt;/p&gt;
&lt;p&gt;2参数的处理多样了,接口中的方法参数列表由我们自己决定&lt;/p&gt;
&lt;p&gt;3通过代理模式由mybatis提供接口的实现类对象 我们不用写实现类了&lt;/p&gt;
&lt;p&gt;项目结构:注意文件路径和文件位置!!!&lt;/p&gt;
&lt;img data-src=&#34;/2022/10/07/ORM/Mybatis/image-20220617195010768.png&#34; class=&#34;&#34; title=&#34;image-20220617195010768&#34;&gt;


&lt;p&gt;准备接口和mapper映射文件&lt;/p&gt;
&lt;p&gt;EmpMapper接口&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;package com.msb.mapper;
import com.msb.pojo.Emp;
import java.util.List;
/**

 * @Author: Ma HaiYang
 * @Description: MircoMessage:Mark_7001
    */
public interface EmpMapper &amp;#123;
    /**
     * 该方法用于查询全部的员工信息
     * @return 全部员工信息封装的Emp对象的List集合
        */
    List&amp;lt;Emp&amp;gt; findAll();
 &amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;EmpMapper.xml映射文件&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;xml&#34;&gt; &amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot; ?&amp;gt;
&amp;lt;!DOCTYPE mapper
        PUBLIC &amp;quot;-//mybatis.org//DTD Mapper 3.0//EN&amp;quot;
        &amp;quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&amp;quot;&amp;gt;
&amp;lt;mapper namespace=&amp;quot;com.msb.mapper.EmpMapper&amp;quot;&amp;gt;
    &amp;lt;!--
    1 接口的名字和Mapper映射为文件名字必须保持一致(不包含拓展名)
    2 Mapper映射文件的namespace必须是接口的全路径名
    3 sql语句的id必须是对应方法的名
    4 DeptMapper映射文件应该和接口编译之后放在同一个目录下
    --&amp;gt;
    &amp;lt;!--List&amp;lt;Emp&amp;gt; findAll();--&amp;gt;
    &amp;lt;select id=&amp;quot;findAll&amp;quot; resultType=&amp;quot;emp&amp;quot; &amp;gt;
        select * from emp
    &amp;lt;/select&amp;gt;
&amp;lt;/mapper&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在sqlMapConfig.xml核心配置文件中使用包扫描形式加载所有的映射文件&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;xml&#34;&gt; &amp;lt;!--加载mapper映射文件--&amp;gt;
&amp;lt;mappers&amp;gt;
    &amp;lt;!--通过类的全路径去找mapper映射文件--&amp;gt;
    &amp;lt;mapper class=&amp;quot;com.msb.mapper.EmpMapper&amp;quot;/&amp;gt;
&amp;lt;/mappers&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt; 测试代码&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;package com.msb.test;
import com.msb.mapper.EmpMapper;
import com.msb.pojo.Dept;
import com.msb.pojo.Emp;
import org.apache.ibatis.io.Resources;
import org.apache.ibatis.session.SqlSession;
import org.apache.ibatis.session.SqlSessionFactory;
import org.apache.ibatis.session.SqlSessionFactoryBuilder;
import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import java.io.IOException;
import java.io.InputStream;
import java.util.List;
/**

 * @Author: Ma HaiYang
 * @Description: MircoMessage:Mark_7001
    */
    public class Test1 &amp;#123;
    private SqlSession sqlSession;
    @Before
    public void init()&amp;#123;
        SqlSessionFactoryBuilder ssfb =new SqlSessionFactoryBuilder();
        InputStream resourceAsStream = null;
        try &amp;#123;
            resourceAsStream = Resources.getResourceAsStream(&amp;quot;sqlMapConfig.xml&amp;quot;);
        &amp;#125; catch (IOException e) &amp;#123;
            e.printStackTrace();
        &amp;#125;
        SqlSessionFactory factory=ssfb.build(resourceAsStream) ;
        sqlSession=factory.openSession();
    &amp;#125;
    @Test
    public void testFindAll()&amp;#123;
        EmpMapper empMapper=sqlSession.getMapper(EmpMapper.class);
        List&amp;lt;Emp&amp;gt; emps = empMapper.findAll();
        emps.forEach(System.out::println);
    &amp;#125;
    @After
    public void release()&amp;#123;
        // 关闭SQLSession
        sqlSession.close();
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;代理模式浅析&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;mybatis是如何通过代理模式实现查询的&lt;/p&gt;
&lt;p&gt;这条语句的底层使用了动态代理模式，动态创建一个EmployeeMapper的一个代理对象并赋给接口引用。所以在MyBatis中不需要显式提供Mapper接口的实现类，这也是简单的地方。&lt;/p&gt;
&lt;h1 id=&#34;6-代理模式下开发各种功能&#34;&gt;&lt;a href=&#34;#6-代理模式下开发各种功能&#34; class=&#34;headerlink&#34; title=&#34;6 代理模式下开发各种功能&#34;&gt;&lt;/a&gt;6 代理模式下开发各种功能&lt;/h1&gt;&lt;h2 id=&#34;1-多种参数传递问题&#34;&gt;&lt;a href=&#34;#1-多种参数传递问题&#34; class=&#34;headerlink&#34; title=&#34;1_多种参数传递问题&#34;&gt;&lt;/a&gt;1_多种参数传递问题&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;1单个基本数据类型&lt;/p&gt;
&lt;p&gt;2多个基本数据类型&lt;/p&gt;
&lt;p&gt;3单个引用数据类型&lt;/p&gt;
&lt;p&gt;4map集合数据类型&lt;/p&gt;
&lt;p&gt;5多个引用数据类型&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;接口&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;package com.msb.mapper;
import com.msb.pojo.Emp;
import org.apache.ibatis.annotations.Param;
import java.util.List;
import java.util.Map;
/**
 * @Author: Ma HaiYang
 * @Description: MircoMessage:Mark_7001
 */
public interface EmpMapper &amp;#123;
    /**
     * 该方法用于查询全部的员工信息
     * @return 全部员工信息封装的Emp对象的List集合
     */
    List&amp;lt;Emp&amp;gt; findAll();
    /**
     * 根据员工编号查询单个员工信息的方法
     * @param empno 员工编号
     * @return 如果找到了返回Emp对象,找不到返回null
     */
    Emp findByEmpno(int empno);
    /**
     * 根据员工编号和薪资下限去查询员工信息
     * @param empno 员工编号
     * @param sal 薪资下限
     * @return 多个Emp对象的List集合
     */
    List&amp;lt;Emp&amp;gt; findByDeptnoAndSal(@Param(&amp;quot;deptno&amp;quot;) int deptno,@Param(&amp;quot;sal&amp;quot;) double sal);
    List&amp;lt;Emp&amp;gt; findByDeptnoAndSal2(Map&amp;lt;String,Object&amp;gt; map);
    List&amp;lt;Emp&amp;gt; findByDeptnoAndSal3(Emp emp);
    List&amp;lt;Emp&amp;gt; findByDeptnoAndSal4(@Param(&amp;quot;empa&amp;quot;) Emp empa,@Param(&amp;quot;empb&amp;quot;) Emp empb);
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;mapper映射文件&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot; ?&amp;gt;
&amp;lt;!DOCTYPE mapper
        PUBLIC &amp;quot;-//mybatis.org//DTD Mapper 3.0//EN&amp;quot;
        &amp;quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&amp;quot;&amp;gt;
&amp;lt;mapper namespace=&amp;quot;com.msb.mapper.EmpMapper&amp;quot;&amp;gt;
    &amp;lt;!--
    1 接口的名字和Mapper映射为文件名字必须保持一致(不包含拓展名)
    2 Mapper映射文件的namespace必须是接口的全路径名
    3 sql语句的id必须是对应方法的名
    4 DeptMapper映射文件应该和接口编译之后放在同一个目录下
    --&amp;gt;
    &amp;lt;!--List&amp;lt;Emp&amp;gt; findAll();--&amp;gt;
    &amp;lt;select id=&amp;quot;findAll&amp;quot; resultType=&amp;quot;emp&amp;quot; &amp;gt;
        select * from emp
    &amp;lt;/select&amp;gt;
    &amp;lt;!--
    单个基本数据类型作为方法参数
    #&amp;#123;&amp;#125;中可以随便写,遵循见名知意
    Emp findByEmpno(int empno);
    --&amp;gt;
    &amp;lt;select id=&amp;quot;findByEmpno&amp;quot; resultType=&amp;quot;emp&amp;quot; &amp;gt;
        select * from emp where empno =#&amp;#123;empno&amp;#125;
    &amp;lt;/select&amp;gt;
    &amp;lt;!--
     多个基本数据类型作为方法参数
     List&amp;lt;Emp&amp;gt; findByDeptnoAndSal(@Param(&amp;quot;detpno&amp;quot;) int deptno,@Param(&amp;quot;sal&amp;quot;) double sal);
     方式1 arg*     arg0 arg1 arg2 数字是索引,从0开始
     方式2 param*   param1 param2 param3 数字是编号,从1开始
     使用别名
     List&amp;lt;Emp&amp;gt; findByDeptnoAndSal(@Param(&amp;quot;detpno&amp;quot;) int deptno,@Param(&amp;quot;sal&amp;quot;) double sal);
     通过@Param注解使用别名之后,就不能再使用arg* 但是可以继续使用param*
    --&amp;gt;
    &amp;lt;select id=&amp;quot;findByDeptnoAndSal&amp;quot; resultType=&amp;quot;emp&amp;quot;&amp;gt;
    &amp;lt;/select&amp;gt;
    &amp;lt;!--
    参数是map,&amp;#123;&amp;#125;写键的名字
    --&amp;gt;
    &amp;lt;select id=&amp;quot;findByDeptnoAndSal2&amp;quot; resultType=&amp;quot;emp&amp;quot; parameterType=&amp;quot;map&amp;quot; &amp;gt;
    &amp;lt;/select&amp;gt;
    &amp;lt;!--单个引用类型,&amp;#123;&amp;#125;中写的使用对象的属性名--&amp;gt;
    &amp;lt;select id=&amp;quot;findByDeptnoAndSal3&amp;quot; resultType=&amp;quot;emp&amp;quot; parameterType=&amp;quot;emp&amp;quot; &amp;gt;
    &amp;lt;/select&amp;gt;
    &amp;lt;!--
    多个引用类型作为方法参数
     List&amp;lt;Emp&amp;gt; findByDeptnoAndSal4(@Param(&amp;quot;empa&amp;quot;) Emp empa,@Param(&amp;quot;empb&amp;quot;) Emp empb);
     如果用@Param定义了别名,那么就不能使用arg*.属性名,但是可以使用param*.属性名和别名.属性名
    --&amp;gt;
    &amp;lt;select id=&amp;quot;findByDeptnoAndSal4&amp;quot; resultType=&amp;quot;emp&amp;quot;  &amp;gt;
    &amp;lt;/select&amp;gt;
&amp;lt;/mapper&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;测试 代码&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;package com.msb.testDemo;
import com.msb.mapper.EmpMapper;
import com.msb.pojo.Emp;
import com.msb.util.SqlSessionUtil;
import org.apache.ibatis.session.SqlSession;
import java.util.List;
public class Test1 &amp;#123;
    public static void main(String[] args) &amp;#123;
        SqlSession sqlSession = SqlSessionUtil.getSqlSession(true);
        /*
        * 帮助我们生成一个接口下的实现类对象的
        *
        * */
        EmpMapper mapper = sqlSession.getMapper(EmpMapper.class);
        List&amp;lt;Emp&amp;gt; emps = mapper.getAllEmp();
        for(Emp emp:emps) &amp;#123;
            System.out.println(emp);
        &amp;#125;
        // 1单个基本数据类型作为方法参数
        Emp emp = mapper.getByEmpno(7902);
        System.out.println(emp);
        // 2多个基本数据类型作为方法参数
        List&amp;lt;Emp&amp;gt; emps2 = mapper.getByDeptnoAndSal(10, 1500);
        for(Emp em:emps2) &amp;#123;
            System.out.println(em);
        &amp;#125;
        // 3单个引用类型作为方法参数
        Emp condition=new Emp();
        condition.setDeptno(10);
        condition.setSal(1500.0);
        List&amp;lt;Emp&amp;gt; emps3 = mapper.getByDeptnoAndSal2(condition);
        for(Emp em:emps3) &amp;#123;
            System.out.println(em);
        &amp;#125;
        // 4多个引用类型作为方法参数
        Emp condition1=new Emp();
        condition1.setDeptno(10);
        Emp condition2=new Emp();
        condition2.setSal(1500.0);
        List&amp;lt;Emp&amp;gt; emps4 = mapper.getByDeptnoAndSal3(condition1,condition2);
        for(Emp em:emps4) &amp;#123;
            System.out.println(em);
        &amp;#125;
        sqlSession.close();
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;2-模糊查询功能&#34;&gt;&lt;a href=&#34;#2-模糊查询功能&#34; class=&#34;headerlink&#34; title=&#34;2 模糊查询功能&#34;&gt;&lt;/a&gt;2 模糊查询功能&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;在进行模糊查询时，在映射文件中可以使用concat()函数来连接参数和通配符。另外注意对于特殊字符，比如&amp;lt;，不能直接书写，应该使用字符实体替换。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;接口&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;/**
 * 根据名字做模糊查询
 * @param name 模糊查询的文字
 * @return  Emp对象List集合
 */
List&amp;lt;Emp&amp;gt; findByEname( String name);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;mapper映射文件&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;xml&#34;&gt;&amp;lt;!--List&amp;lt;Emp&amp;gt; getByName(String name);--&amp;gt;
&amp;lt;select id=&amp;quot;findByEname&amp;quot;  resultType=&amp;quot;emp&amp;quot; &amp;gt;
    select * from emp where ename like concat(&amp;#39;%&amp;#39;,#&amp;#123;name&amp;#125;,&amp;#39;%&amp;#39;)
&amp;lt;/select&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;3-主键自增回填&#34;&gt;&lt;a href=&#34;#3-主键自增回填&#34; class=&#34;headerlink&#34; title=&#34;3_主键自增回填&#34;&gt;&lt;/a&gt;3_主键自增回填&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;MySQL支持主键自增。有时候完成添加后需要立刻获取刚刚自增的主键，由下一个操作来使用。比如结算构造车后，主订单的主键确定后，需要作为后续订单明细项的外键存在。如何拿到主键呢，MyBatis提供了支持，可以非常简单的获取。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;接口&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;public interface DeptMapper &amp;#123;
    int addDept(Dept dept);
    int addDept2(Dept dept);
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;mapper映射文件&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;xml&#34;&gt;&amp;lt;mapper namespace=&amp;quot;com.msb.mapper.DeptMapper&amp;quot;&amp;gt;
   &amp;lt;!-- int addDept(Dept dept);
   useGeneratedKeys=&amp;quot;true&amp;quot; 返回数据库帮我们生成的主键
   keyProperty=&amp;quot;deptno&amp;quot; 生成的主键值用我们dept对象那个属性存储
   --&amp;gt;
    &amp;lt;insert id=&amp;quot;addDept&amp;quot; parameterType=&amp;quot;dept&amp;quot; useGeneratedKeys=&amp;quot;true&amp;quot; keyProperty=&amp;quot;deptno&amp;quot;&amp;gt;
    &amp;lt;/insert&amp;gt;
    &amp;lt;insert id=&amp;quot;addDept2&amp;quot; parameterType=&amp;quot;dept&amp;quot;&amp;gt;
        &amp;lt;selectKey order=&amp;quot;AFTER&amp;quot; keyProperty=&amp;quot;deptno&amp;quot;  resultType=&amp;quot;int&amp;quot;&amp;gt;
            select @@identity
        &amp;lt;/selectKey&amp;gt;
    &amp;lt;/insert&amp;gt;
&amp;lt;/mapper&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;测试代码&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;SqlSession sqlSession = SqlSessionUtil.getSqlSession(true);
DeptMapper mapper = sqlSession.getMapper(DeptMapper.class);
Dept dept =new Dept(null,&amp;quot;AI学院&amp;quot;,&amp;quot;北京&amp;quot;);
int i = mapper.addDept2(dept);
System.out.println(i);
System.out.println(dept.getDeptno());
sqlSession.close();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;方式1&lt;/p&gt;
&lt;p&gt;useGeneratedKeys：表示要使用自增的主键&lt;/p&gt;
&lt;p&gt;keyProperty：表示把自增的主键赋给JavaBean的哪个成员变量。&lt;/p&gt;
&lt;p&gt;以添加Dept对象为例，添加前Dept对象的deptno是空的，添加完毕后可以通过getDeptno() 获取自增的主键。&lt;/p&gt;
&lt;p&gt;方式2&lt;/p&gt;
&lt;p&gt;order：取值AFTER|BEFORE，表示在新增之后|之前执行&lt;selectKey&gt;中的SQL命令&lt;/p&gt;
&lt;p&gt;keyProperty：执行select @@identity后结果填充到哪个属性中&lt;/p&gt;
&lt;p&gt;resultType：结果类型。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;技术扩展&lt;/strong&gt;&lt;br&gt;在很多应用场景中需要新增数据后获取到新增数据的主键值，针对这样的需求一般由三种解决方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;主键自定义，用户通过UUID或时间戳等方式生成唯一主键，把这个值当做主键值。在分布式场景中应用较多。&lt;/li&gt;
&lt;li&gt;查询后通过select max(主键) from 表获取主键最大值。这种方式在多线程访问情况下可能出现问题。&lt;/li&gt;
&lt;li&gt;查询后通过select @@identity获取最新生成主键。要求这条SQL必须在insert操作之后，且数据库连接没有关闭。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;4-实现DML操作&#34;&gt;&lt;a href=&#34;#4-实现DML操作&#34; class=&#34;headerlink&#34; title=&#34;4_实现DML操作&#34;&gt;&lt;/a&gt;4_实现DML操作&lt;/h2&gt;&lt;p&gt;EmpMapper接口&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;/**
 * 增加员工信息
 * @param emp 存储新增员工信息的Emp对象
 * @return 对数据库数据产生影响的行数
 */
int addEmp(Emp emp);
/**
 * 根据员工编号修改员工姓名的方法
 * @param empno 要修改的员工编号
 * @param ename 修改之后的新的员工名字
 * @return 对数据库数据产生影响的行数
 */
int updateEnameByEmpno(@Param(&amp;quot;empno&amp;quot;) int empno,@Param(&amp;quot;ename&amp;quot;) String ename);
/**
 * 根据员工编号删除员工信息
 * @param empno 要删除的员工编号
 * @return 对数据库数据产生影响的行数
 */
int deleteByEmpno(int empno);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;EmpMapper映射 文件&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;xml&#34;&gt;&amp;lt;!--int addEmp(Emp emp);--&amp;gt;
&amp;lt;insert id=&amp;quot;addEmp&amp;quot; &amp;gt;
&amp;lt;/insert&amp;gt;
&amp;lt;!--int updateEnameByEmpno(@Param(&amp;quot;empno&amp;quot;) int empno,@Param(&amp;quot;ename&amp;quot;) String ename);--&amp;gt;
&amp;lt;update id=&amp;quot;updateEnameByEmpno&amp;quot; &amp;gt;
&amp;lt;/update&amp;gt;
&amp;lt;!--int deleteByEmpno(int empno);--&amp;gt;
&amp;lt;update id=&amp;quot;deleteByEmpno&amp;quot; &amp;gt;
    delete from emp where empno =#&amp;#123;empno&amp;#125;
&amp;lt;/update&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;测试代码&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;package com.msb.test;
import com.msb.mapper.DeptMapper;
import com.msb.mapper.EmpMapper;
import com.msb.pojo.Dept;
import com.msb.pojo.Emp;
import org.apache.ibatis.io.Resources;
import org.apache.ibatis.session.SqlSession;
import org.apache.ibatis.session.SqlSessionFactory;
import org.apache.ibatis.session.SqlSessionFactoryBuilder;
import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import java.io.IOException;
import java.io.InputStream;
import java.util.Date;
/**
 * @Author: Ma HaiYang
 * @Description: MircoMessage:Mark_7001
 */
public class Test3 &amp;#123;
    private SqlSession sqlSession;
    @Before
    public void init()&amp;#123;
        SqlSessionFactoryBuilder ssfb =new SqlSessionFactoryBuilder();
        InputStream resourceAsStream = null;
        try &amp;#123;
            resourceAsStream = Resources.getResourceAsStream(&amp;quot;sqlMapConfig.xml&amp;quot;);
        &amp;#125; catch (IOException e) &amp;#123;
            e.printStackTrace();
        &amp;#125;
        SqlSessionFactory factory=ssfb.build(resourceAsStream) ;
        sqlSession=factory.openSession();
    &amp;#125;
    @Test
    public void testAddEmp()&amp;#123;
        EmpMapper mapper = sqlSession.getMapper(EmpMapper.class);
        mapper.addEmp(new Emp(null, &amp;quot;TOM&amp;quot;, &amp;quot;SALESMAN&amp;quot;, 7521, new Date(), 2314.0, 100.0, 10));
        sqlSession.commit();
    &amp;#125;
    @Test
    public void testUpdateEnameByEmpno()&amp;#123;
        EmpMapper mapper = sqlSession.getMapper(EmpMapper.class);
        mapper.updateEnameByEmpno(7938, &amp;quot;TOM&amp;quot;);
        sqlSession.commit();
    &amp;#125;
    @Test
    public void testDeletByEmpno()&amp;#123;
        EmpMapper mapper = sqlSession.getMapper(EmpMapper.class);
        mapper.deleteByEmpno(7938);
        sqlSession.commit();
    &amp;#125;
    @After
    public void release()&amp;#123;
        // 关闭SQLSession
        sqlSession.close();
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;7-动态SQL&#34;&gt;&lt;a href=&#34;#7-动态SQL&#34; class=&#34;headerlink&#34; title=&#34;7 动态SQL&#34;&gt;&lt;/a&gt;7 动态SQL&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;经常遇到很多按照很多查询条件进行查询的情况，比如京东根据不同的条件筛选商品。其中经常出现很多条件不取值的情况，在后台应该如何完成最终的SQL语句呢？









如果采用JDBC进行处理，需要根据条件是否取值进行SQL语句的拼接，一般情况下是使用StringBuilder类及其append方法实现，还是有些繁琐的。如果你有使用 JDBC 或其它类似框架的经验，你就能体会到根据不同条件拼接 SQL语句的痛苦。例如拼接时要确保不能忘记添加必要的空格，还要注意去掉列表最后一个列名的逗号。利用动态 SQL 这一特性可以彻底摆脱这种痛苦。

MyBatis在简化操作方法提出了动态SQL功能，将使用Java代码拼接SQL语句，改变为在XML映射文件中截止标签拼接SQL语句。相比而言，大大减少了代码量，更灵活、高度可配置、利于后期维护。

MyBatis中动态SQL是编写在mapper.xml中的，其语法和JSTL类似，但是却是基于强大的OGNL表达式实现的。

MyBatis也可以在注解中配置SQL，但是由于注解功能受限，尤其是对于复杂的SQL语句，可读性很差，所以较少使用。
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;1-if标签&#34;&gt;&lt;a href=&#34;#1-if标签&#34; class=&#34;headerlink&#34; title=&#34;1_if标签&#34;&gt;&lt;/a&gt;1_if标签&lt;/h2&gt;&lt;p&gt;接口&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;public interface EmpMapper2 &amp;#123;
  List&amp;lt;Emp&amp;gt; findByCondition(Emp emp);
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;映射文件&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot; ?&amp;gt;
&amp;lt;!DOCTYPE mapper
        PUBLIC &amp;quot;-//mybatis.org//DTD Mapper 3.0//EN&amp;quot;
        &amp;quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&amp;quot;&amp;gt;
&amp;lt;mapper namespace=&amp;quot;com.msb.mapper.EmpMapper2&amp;quot;&amp;gt;
&amp;lt;!--List&amp;lt;Emp&amp;gt; findByCondition(Emp emp);--&amp;gt;
    &amp;lt;select id=&amp;quot;findByCondition&amp;quot; resultType=&amp;quot;emp&amp;quot;&amp;gt;
        select * from emp where 1=1
        &amp;lt;if test=&amp;quot;empno != null&amp;quot;&amp;gt;
            and empno =#&amp;#123;empno&amp;#125;
        &amp;lt;/if&amp;gt;
        &amp;lt;if test=&amp;quot;ename != null and ename != &amp;#39;&amp;#39;&amp;quot;&amp;gt;
            and ename like concat(&amp;#39;%&amp;#39;,#&amp;#123;ename&amp;#125;,&amp;#39;%&amp;#39;)
        &amp;lt;/if&amp;gt;
        &amp;lt;if test=&amp;quot;job != null and job != &amp;#39;&amp;#39;&amp;quot;&amp;gt;
            and job =#&amp;#123;job&amp;#125;
        &amp;lt;/if&amp;gt;
        &amp;lt;if test=&amp;quot;mgr != null&amp;quot;&amp;gt;
            and mgr =#&amp;#123;mgr&amp;#125;
        &amp;lt;/if&amp;gt;
        &amp;lt;if test=&amp;quot;hiredate != null&amp;quot;&amp;gt;
            and hiredate =#&amp;#123;hiredate&amp;#125;
        &amp;lt;/if&amp;gt;
        &amp;lt;if test=&amp;quot;sal != null&amp;quot;&amp;gt;
            and sal =#&amp;#123;sal&amp;#125;
        &amp;lt;/if&amp;gt;
        &amp;lt;if test=&amp;quot;comm != null&amp;quot;&amp;gt;
            and comm =#&amp;#123;comm&amp;#125;
        &amp;lt;/if&amp;gt;
        &amp;lt;if test=&amp;quot;deptno != null&amp;quot;&amp;gt;
            and deptno =#&amp;#123;deptno&amp;#125;
        &amp;lt;/if&amp;gt;
    &amp;lt;/select&amp;gt;
&amp;lt;/mapper&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;测试代码&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;public static void main(String[] args) &amp;#123;
    SqlSession sqlSession = MyBatisUtil.getSqlSession(false);
    EmpMapper2 mapper = sqlSession.getMapper(EmpMapper2.class);
    Emp condition =new Emp();
   /* condition.setDeptno(20);*/
   /* condition.setSal(3000.0);*/
   /*condition.setHiredate(new java.sql.Date(81,1,22));*/
   condition.setComm(0.0);
   condition.setDeptno(20);
    List&amp;lt;Emp&amp;gt; emps = mapper.findEmpByCondition(condition);
    for (Emp e:emps
         ) &amp;#123;
        System.out.println(e);
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;2-where标签&#34;&gt;&lt;a href=&#34;#2-where标签&#34; class=&#34;headerlink&#34; title=&#34;2_where标签&#34;&gt;&lt;/a&gt;2_where标签&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;用于处理where关键字和and&lt;/p&gt;
&lt;p&gt;默认删除第一个and逻辑连接符&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;xml&#34;&gt;&amp;lt;select id=&amp;quot;findEmpByCondition&amp;quot; resultType=&amp;quot;emp&amp;quot;&amp;gt;
    select * from emp
    &amp;lt;where&amp;gt;
        &amp;lt;if test=&amp;quot;empno != null&amp;quot;&amp;gt;
            and empno= #&amp;#123;empno&amp;#125;
        &amp;lt;/if&amp;gt;
        &amp;lt;if test=&amp;quot;ename != null and ename != &amp;#39;&amp;#39;&amp;quot;&amp;gt;
            and ename= #&amp;#123;ename&amp;#125;
        &amp;lt;/if&amp;gt;
        &amp;lt;if test=&amp;quot;job != null and job != &amp;#39;&amp;#39;&amp;quot;&amp;gt;
            and job= #&amp;#123;job&amp;#125;
        &amp;lt;/if&amp;gt;
        &amp;lt;if test=&amp;quot;mgr != null &amp;quot;&amp;gt;
            and mgr= #&amp;#123;mgr&amp;#125;
        &amp;lt;/if&amp;gt;
        &amp;lt;if test=&amp;quot;hiredate != null &amp;quot;&amp;gt;
            and hiredate= #&amp;#123;hiredate&amp;#125;
        &amp;lt;/if&amp;gt;
        &amp;lt;if test=&amp;quot;sal != null&amp;quot;&amp;gt;
            and sal= #&amp;#123;sal&amp;#125;
        &amp;lt;/if&amp;gt;
        &amp;lt;if test=&amp;quot;comm != null &amp;quot;&amp;gt;
             and comm =#&amp;#123;comm&amp;#125;
        &amp;lt;/if&amp;gt;
        &amp;lt;if test=&amp;quot;deptno != null &amp;quot;&amp;gt;
            and deptno= #&amp;#123;deptno&amp;#125;
        &amp;lt;/if&amp;gt;
    &amp;lt;/where&amp;gt;
&amp;lt;/select&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;3-choose标签&#34;&gt;&lt;a href=&#34;#3-choose标签&#34; class=&#34;headerlink&#34; title=&#34;3_choose标签&#34;&gt;&lt;/a&gt;3_choose标签&lt;/h2&gt;&lt;p&gt;前面的when条件成立 后面的 when就不再判断了&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;xml&#34;&gt; &amp;lt;select id=&amp;quot;findEmpByCondition2&amp;quot; resultType=&amp;quot;emp&amp;quot;&amp;gt;
    select * from emp
    &amp;lt;where&amp;gt;
        &amp;lt;choose&amp;gt;
            &amp;lt;when test=&amp;quot;empno != null&amp;quot;&amp;gt;
                and empno= #&amp;#123;empno&amp;#125;
            &amp;lt;/when&amp;gt;
            &amp;lt;when test=&amp;quot;ename != null and ename != &amp;#39;&amp;#39;&amp;quot;&amp;gt;
                and ename= #&amp;#123;ename&amp;#125;
            &amp;lt;/when&amp;gt;
            &amp;lt;when test=&amp;quot;job != null and job != &amp;#39;&amp;#39;&amp;quot;&amp;gt;
                and job= #&amp;#123;job&amp;#125;
            &amp;lt;/when&amp;gt;
            &amp;lt;when test=&amp;quot;mgr != null &amp;quot;&amp;gt;
                and mgr= #&amp;#123;mgr&amp;#125;
            &amp;lt;/when&amp;gt;
            &amp;lt;when test=&amp;quot;hiredate != null &amp;quot;&amp;gt;
                and hiredate= #&amp;#123;hiredate&amp;#125;
            &amp;lt;/when&amp;gt;
            &amp;lt;when test=&amp;quot;sal != null&amp;quot;&amp;gt;
                and sal= #&amp;#123;sal&amp;#125;
            &amp;lt;/when&amp;gt;
            &amp;lt;when test=&amp;quot;comm != null &amp;quot;&amp;gt;
                and comm =#&amp;#123;comm&amp;#125;
            &amp;lt;/when&amp;gt;
            &amp;lt;when test=&amp;quot;deptno != null &amp;quot;&amp;gt;
                and deptno= #&amp;#123;deptno&amp;#125;
            &amp;lt;/when&amp;gt;
        &amp;lt;/choose&amp;gt;
    &amp;lt;/where&amp;gt;
&amp;lt;/select&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;4-set标签&#34;&gt;&lt;a href=&#34;#4-set标签&#34; class=&#34;headerlink&#34; title=&#34;4_set标签&#34;&gt;&lt;/a&gt;4_set标签&lt;/h2&gt;&lt;p&gt;接口&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt; int updateEmpByCondtion(Emp emp);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;映射文件&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;xml&#34;&gt; &amp;lt;!--int updateEmpByCondtion(Emp emp);--&amp;gt;
&amp;lt;update id=&amp;quot;updateEmpByCondtion&amp;quot; &amp;gt;
    update emp
    &amp;lt;set&amp;gt;
        &amp;lt;if test=&amp;quot;ename != null and ename != &amp;#39;&amp;#39; &amp;quot;&amp;gt;
            , ename =#&amp;#123;ename&amp;#125;
        &amp;lt;/if&amp;gt;
        &amp;lt;if test=&amp;quot;job != null and ename != &amp;#39;&amp;#39; &amp;quot;&amp;gt;
            , job =#&amp;#123;job&amp;#125;
        &amp;lt;/if&amp;gt;
        &amp;lt;if test=&amp;quot;mgr != null &amp;quot;&amp;gt;
            , mgr =#&amp;#123;mgr&amp;#125;
        &amp;lt;/if&amp;gt;
        &amp;lt;if test=&amp;quot;hiredate != null &amp;quot;&amp;gt;
            , hiredate =#&amp;#123;hiredate&amp;#125;
        &amp;lt;/if&amp;gt;
        &amp;lt;if test=&amp;quot;sal != null &amp;quot;&amp;gt;
            , sal =#&amp;#123;sal&amp;#125;
        &amp;lt;/if&amp;gt;
        &amp;lt;if test=&amp;quot;comm != null &amp;quot;&amp;gt;
            , comm =#&amp;#123;comm&amp;#125;
        &amp;lt;/if&amp;gt;
        &amp;lt;if test=&amp;quot;deptno != null &amp;quot;&amp;gt;
            , deptno =#&amp;#123;deptno&amp;#125;
        &amp;lt;/if&amp;gt;
    &amp;lt;/set&amp;gt;
    where empno =#&amp;#123;empno&amp;#125;
&amp;lt;/update&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;5-trim标签&#34;&gt;&lt;a href=&#34;#5-trim标签&#34; class=&#34;headerlink&#34; title=&#34;5_trim标签&#34;&gt;&lt;/a&gt;5_trim标签&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;Trim 标签处理 set  ，可以为他包裹起来的SQL语句前后 增加&amp;#x2F;删除 关键词&amp;#x2F;固定字符&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;xml&#34;&gt;&amp;lt;update id=&amp;quot;updateEmpByCondition2&amp;quot; &amp;gt;
    update emp
    &amp;lt;!--prefix 要增加什么前缀
    prefixOverrides 要去除什么前缀
    suffix 要增加什么后缀
    suffixOverrides 要去除什么后缀
    set 是trim的一种特殊情况
    --&amp;gt;
    &amp;lt;trim prefix=&amp;quot;set&amp;quot;  suffixOverrides=&amp;quot;,&amp;quot; &amp;gt;
        &amp;lt;if test=&amp;quot;ename != null and ename != &amp;#39;&amp;#39;&amp;quot;&amp;gt;
            ename= #&amp;#123;ename&amp;#125;,
        &amp;lt;/if&amp;gt;
        &amp;lt;if test=&amp;quot;job != null and job != &amp;#39;&amp;#39;&amp;quot;&amp;gt;
            job= #&amp;#123;job&amp;#125;,
        &amp;lt;/if&amp;gt;
        &amp;lt;if test=&amp;quot;mgr != null &amp;quot;&amp;gt;
            mgr= #&amp;#123;mgr&amp;#125;,
        &amp;lt;/if&amp;gt;
        &amp;lt;if test=&amp;quot;hiredate != null &amp;quot;&amp;gt;
            hiredate= #&amp;#123;hiredate&amp;#125;,
        &amp;lt;/if&amp;gt;
        &amp;lt;if test=&amp;quot;sal != null&amp;quot;&amp;gt;
            sal= #&amp;#123;sal&amp;#125;,
        &amp;lt;/if&amp;gt;
        &amp;lt;if test=&amp;quot;comm != null &amp;quot;&amp;gt;
            comm =#&amp;#123;comm&amp;#125;,
        &amp;lt;/if&amp;gt;
        &amp;lt;if test=&amp;quot;deptno != null &amp;quot;&amp;gt;
            deptno= #&amp;#123;deptno&amp;#125;,
        &amp;lt;/if&amp;gt;
    &amp;lt;/trim&amp;gt;
    where  empno = #&amp;#123;empno&amp;#125;
&amp;lt;/update&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Trim标签  处理where&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;xml&#34;&gt;    &amp;lt;select id=&amp;quot;findByCondition&amp;quot; resultMap=&amp;quot;EmpMap&amp;quot;&amp;gt;
        select * from emp 
        &amp;lt;trim prefix=&amp;quot;where&amp;quot; prefixOverrides=&amp;quot;and&amp;quot;&amp;gt;
            &amp;lt;if test=&amp;quot;empno != null&amp;quot;&amp;gt;
                and empno =#&amp;#123;empno&amp;#125;
            &amp;lt;/if&amp;gt;
            &amp;lt;if test=&amp;quot;ename != null and ename != &amp;#39;&amp;#39;&amp;quot;&amp;gt;
                &amp;lt;bind name=&amp;quot;likePattern&amp;quot; value=&amp;quot;&amp;#39;%&amp;#39;+ename+&amp;#39;%&amp;#39;&amp;quot;/&amp;gt;
                and ename like #&amp;#123;likePattern&amp;#125;
            &amp;lt;/if&amp;gt;
            &amp;lt;if test=&amp;quot;job != null and job != &amp;#39;&amp;#39;&amp;quot;&amp;gt;
                and job =#&amp;#123;job&amp;#125;
            &amp;lt;/if&amp;gt;
            &amp;lt;if test=&amp;quot;mgr != null&amp;quot;&amp;gt;
                and mgr =#&amp;#123;mgr&amp;#125;
            &amp;lt;/if&amp;gt;
            &amp;lt;if test=&amp;quot;hiredate != null&amp;quot;&amp;gt;
                and hiredate =#&amp;#123;hiredate&amp;#125;
            &amp;lt;/if&amp;gt;
            &amp;lt;if test=&amp;quot;sal != null&amp;quot;&amp;gt;
                and sal =#&amp;#123;sal&amp;#125;
            &amp;lt;/if&amp;gt;
            &amp;lt;if test=&amp;quot;comm != null&amp;quot;&amp;gt;
                and comm =#&amp;#123;comm&amp;#125;
            &amp;lt;/if&amp;gt;
            &amp;lt;if test=&amp;quot;deptno != null&amp;quot;&amp;gt;
                and deptno =#&amp;#123;deptno&amp;#125;
            &amp;lt;/if&amp;gt;
        &amp;lt;/trim&amp;gt;
    &amp;lt;/select&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;6-bind标签&#34;&gt;&lt;a href=&#34;#6-bind标签&#34; class=&#34;headerlink&#34; title=&#34;6_bind标签&#34;&gt;&lt;/a&gt;6_bind标签&lt;/h2&gt;&lt;p&gt;一般用于处理模糊查询的模板&lt;/p&gt;
&lt;p&gt;接口&lt;/p&gt;
&lt;img data-src=&#34;/2022/10/07/ORM/Mybatis/image-20220617200421440.png&#34; class=&#34;&#34; title=&#34;image-20220617200421440&#34;&gt;


&lt;p&gt;SQL语句&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;xml&#34;&gt;&amp;lt;!-- bind 写一个局部SQL模板，模糊 like 常用--&amp;gt;
    &amp;lt;select id=&amp;quot;findEmpByEname&amp;quot; resultMap=&amp;quot;EmpMap&amp;quot;&amp;gt;
        &amp;lt;bind name=&amp;quot;likePatten&amp;quot; value=&amp;quot;&amp;#39;%&amp;#39;+param1+&amp;#39;%&amp;#39;&amp;quot;/&amp;gt;
        select * from emp where ename like #&amp;#123;likePatten&amp;#125;;
    &amp;lt;/select&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;7-nclude&#34;&gt;&lt;a href=&#34;#7-nclude&#34; class=&#34;headerlink&#34; title=&#34;7_nclude&#34;&gt;&lt;/a&gt;7_nclude&lt;/h2&gt;&lt;p&gt;引用提前写好的 SQL 标签的SQL语句&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;xml&#34;&gt;    &amp;lt;sql id=&amp;quot;empColumn&amp;quot;&amp;gt;empno,ename,job,mgr,hiredate,sal,comm,deptno&amp;lt;/sql&amp;gt;
    &amp;lt;sql id=&amp;quot;baseSelect&amp;quot;&amp;gt;
        select &amp;lt;include refid=&amp;quot;empColumn&amp;quot;&amp;gt;&amp;lt;/include&amp;gt; from emp
    &amp;lt;/sql&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;8-sql标签&#34;&gt;&lt;a href=&#34;#8-sql标签&#34; class=&#34;headerlink&#34; title=&#34;8_sql标签&#34;&gt;&lt;/a&gt;8_sql标签&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;xml&#34;&gt; &amp;lt;sql id=&amp;quot;empColumn&amp;quot;&amp;gt;empno,ename,job,mgr,hiredate,sal,comm,deptno&amp;lt;/sql&amp;gt;
&amp;lt;sql id=&amp;quot;baseSelect&amp;quot;&amp;gt;select &amp;lt;include refid=&amp;quot;empColumn&amp;quot;&amp;gt;&amp;lt;/include&amp;gt; from emp&amp;lt;/sql&amp;gt;
&amp;lt;!--List&amp;lt;Emp&amp;gt; findByCondition(Emp emp);--&amp;gt;
&amp;lt;select id=&amp;quot;findByCondition&amp;quot; resultType=&amp;quot;emp&amp;quot;&amp;gt;
    &amp;lt;include refid=&amp;quot;baseSelect&amp;quot;&amp;gt;&amp;lt;/include&amp;gt;
    &amp;lt;trim prefix=&amp;quot;where&amp;quot; prefixOverrides=&amp;quot;and&amp;quot;&amp;gt;
        &amp;lt;if test=&amp;quot;empno != null&amp;quot;&amp;gt;
            and empno =#&amp;#123;empno&amp;#125;
        &amp;lt;/if&amp;gt;
        &amp;lt;if test=&amp;quot;ename != null and ename != &amp;#39;&amp;#39;&amp;quot;&amp;gt;
            &amp;lt;bind name=&amp;quot;likePattern&amp;quot; value=&amp;quot;&amp;#39;%&amp;#39;+ename+&amp;#39;%&amp;#39;&amp;quot;/&amp;gt;
            and ename like #&amp;#123;likePattern&amp;#125;
        &amp;lt;/if&amp;gt;
        &amp;lt;if test=&amp;quot;job != null and job != &amp;#39;&amp;#39;&amp;quot;&amp;gt;
            and job =#&amp;#123;job&amp;#125;
        &amp;lt;/if&amp;gt;
        &amp;lt;if test=&amp;quot;mgr != null&amp;quot;&amp;gt;
            and mgr =#&amp;#123;mgr&amp;#125;
        &amp;lt;/if&amp;gt;
        &amp;lt;if test=&amp;quot;hiredate != null&amp;quot;&amp;gt;
            and hiredate =#&amp;#123;hiredate&amp;#125;
        &amp;lt;/if&amp;gt;
        &amp;lt;if test=&amp;quot;sal != null&amp;quot;&amp;gt;
            and sal =#&amp;#123;sal&amp;#125;
        &amp;lt;/if&amp;gt;
        &amp;lt;if test=&amp;quot;comm != null&amp;quot;&amp;gt;
            and comm =#&amp;#123;comm&amp;#125;
        &amp;lt;/if&amp;gt;
        &amp;lt;if test=&amp;quot;deptno != null&amp;quot;&amp;gt;
            and deptno =#&amp;#123;deptno&amp;#125;
        &amp;lt;/if&amp;gt;
    &amp;lt;/trim&amp;gt;
&amp;lt;/select&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;9-foreach标签&#34;&gt;&lt;a href=&#34;#9-foreach标签&#34; class=&#34;headerlink&#34; title=&#34;9_foreach标签&#34;&gt;&lt;/a&gt;9_foreach标签&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;xml&#34;&gt; &amp;lt;!--List&amp;lt;Emp&amp;gt; findByEmpnos1(int[] empnos);
 collection=&amp;quot;&amp;quot;  遍历的集合或者是数组
                 参数是数组,collection中名字指定为array
                 参数是List集合,collection中名字指定为list
 separator=&amp;quot;&amp;quot;   多个元素取出的时候 用什么文字分隔
 open=&amp;quot;&amp;quot;        以什么开头
 close=&amp;quot;&amp;quot;       以什么结尾
 item=&amp;quot;&amp;quot;        中间变量名
 for(Person per:PersonList)
 --&amp;gt;
 &amp;lt;select id=&amp;quot;findByEmpnos1&amp;quot; resultType=&amp;quot;emp&amp;quot;&amp;gt;
     select * from emp  where empno in
     &amp;lt;foreach collection=&amp;quot;array&amp;quot; separator=&amp;quot;,&amp;quot; open=&amp;quot;(&amp;quot; close=&amp;quot;)&amp;quot; item=&amp;quot;deptno&amp;quot;&amp;gt;
         #&amp;#123;deptno&amp;#125;
     &amp;lt;/foreach&amp;gt;
 &amp;lt;/select&amp;gt;
&amp;lt;!-- List&amp;lt;Emp&amp;gt; findByEmpnos2(List&amp;lt;Integer&amp;gt; empnos);--&amp;gt;
 &amp;lt;select id=&amp;quot;findByEmpnos2&amp;quot; resultType=&amp;quot;emp&amp;quot;&amp;gt;
     select * from emp  where empno in
     &amp;lt;foreach collection=&amp;quot;list&amp;quot; separator=&amp;quot;,&amp;quot; open=&amp;quot;(&amp;quot; close=&amp;quot;)&amp;quot; item=&amp;quot;deptno&amp;quot;&amp;gt;
         #&amp;#123;deptno&amp;#125;
     &amp;lt;/foreach&amp;gt;
 &amp;lt;/select&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;8-MyBatis实现多表查询&#34;&gt;&lt;a href=&#34;#8-MyBatis实现多表查询&#34; class=&#34;headerlink&#34; title=&#34;8 MyBatis实现多表查询&#34;&gt;&lt;/a&gt;8 MyBatis实现多表查询&lt;/h1&gt;&lt;p&gt;前面已经使用MyBatis完成了对Emp表的CRUD操作，不管是使用SqlSession直接操作，还是使用Mapper代理方式，都只是完成了对单个数据库表的操作。这肯定是远远不够的。&lt;/p&gt;
&lt;p&gt;在实际开发中，经常会将来自多张表的数据在一个位置显示。比如查询并显示的员工信息中会有来自部门表、岗位表的数据，而后台一般是定义一个方法&lt;/p&gt;
&lt;h2 id=&#34;1-关联查询&#34;&gt;&lt;a href=&#34;#1-关联查询&#34; class=&#34;headerlink&#34; title=&#34;1 关联查询&#34;&gt;&lt;/a&gt;1 关联查询&lt;/h2&gt;&lt;h3 id=&#34;1-手动处理映射关系&#34;&gt;&lt;a href=&#34;#1-手动处理映射关系&#34; class=&#34;headerlink&#34; title=&#34;1 手动处理映射关系&#34;&gt;&lt;/a&gt;1 手动处理映射关系&lt;/h3&gt;&lt;p&gt;实体类&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;public class Emp  implements Serializable &amp;#123;
    private Integer empno;
    private String name;
    private String job;
    private Integer mgr;
    private Date hiredate;
    private Double sal;
    private Double comm;
    private Integer deptno;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;映射文件&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;xml&#34;&gt;&amp;lt;mapper namespace=&amp;quot;com.msb.mapper.EmpMapper&amp;quot;&amp;gt;
    &amp;lt;!--手动处理数据库查询字段和封装实体类属性之间的映射关系
    1 主键一般使用id属性
    2 当属性名和查询出的数据表字段名相同 可以不写映射关系
    --&amp;gt;
    &amp;lt;resultMap id=&amp;quot;empMap&amp;quot; type=&amp;quot;emp&amp;quot;&amp;gt;
        &amp;lt;!--&amp;lt;id property=&amp;quot;empno&amp;quot; column=&amp;quot;empno&amp;quot;&amp;gt;&amp;lt;/id&amp;gt;--&amp;gt;
        &amp;lt;result property=&amp;quot;name&amp;quot; column=&amp;quot;ename&amp;quot;&amp;gt;&amp;lt;/result&amp;gt;
        &amp;lt;!--&amp;lt;result property=&amp;quot;job&amp;quot; column=&amp;quot;job&amp;quot;&amp;gt;&amp;lt;/result&amp;gt;
        &amp;lt;result property=&amp;quot;sal&amp;quot; column=&amp;quot;sal&amp;quot;&amp;gt;&amp;lt;/result&amp;gt;
        &amp;lt;result property=&amp;quot;hiredate&amp;quot; column=&amp;quot;hiredate&amp;quot;&amp;gt;&amp;lt;/result&amp;gt;
        &amp;lt;result property=&amp;quot;mgr&amp;quot; column=&amp;quot;mgr&amp;quot;&amp;gt;&amp;lt;/result&amp;gt;
        &amp;lt;result property=&amp;quot;comm&amp;quot; column=&amp;quot;comm&amp;quot;&amp;gt;&amp;lt;/result&amp;gt;
        &amp;lt;result property=&amp;quot;deptno&amp;quot; column=&amp;quot;deptno&amp;quot;&amp;gt;&amp;lt;/result&amp;gt;--&amp;gt;
    &amp;lt;/resultMap&amp;gt;
    &amp;lt;select id=&amp;quot;findByEmpno&amp;quot; resultMap=&amp;quot;empMap&amp;quot; &amp;gt;
        select * from emp where empno =#&amp;#123;empno&amp;#125;
    &amp;lt;/select&amp;gt;
&amp;lt;/mapper&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;2-一对一关联查询&#34;&gt;&lt;a href=&#34;#2-一对一关联查询&#34; class=&#34;headerlink&#34; title=&#34;2 一对一关联查询&#34;&gt;&lt;/a&gt;2 一对一关联查询&lt;/h3&gt;&lt;p&gt;数据准备: 创建项目表和项目记录表&lt;/p&gt;
&lt;img data-src=&#34;/2022/10/07/ORM/Mybatis/image-20220617200808312.png&#34; class=&#34;&#34; title=&#34;image-20220617200808312&#34;&gt;



&lt;pre&gt;&lt;code class=&#34;sql&#34;&gt;CREATE TABLE `projects`  (
  `pid` int(2) NOT NULL AUTO_INCREMENT,
  `pname` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL,
  `money` int(11) NULL DEFAULT NULL,
  PRIMARY KEY (`pid`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = Dynamic;
INSERT INTO `projects` VALUES (1, &amp;#39; ***大学OA&amp;#39;, 500000);
INSERT INTO `projects` VALUES (2, &amp;#39;学生选课系统&amp;#39;, 100000);
INSERT INTO `projects` VALUES (3, &amp;#39;讲师测评系统&amp;#39;, 20000);
INSERT INTO `projects` VALUES (4, &amp;#39;线上问答系统 &amp;#39;, 20000);
CREATE TABLE `projectrecord`  (
  `empno` int(4) NOT NULL,
  `pid` int(2) NOT NULL,
  PRIMARY KEY (`empno`, `pid`) USING BTREE,
  INDEX `fk_project_pro`(`pid`) USING BTREE,
  CONSTRAINT `fk_emp_pro` FOREIGN KEY (`empno`) REFERENCES `emp` (`EMPNO`) ON DELETE CASCADE ON UPDATE CASCADE,
  CONSTRAINT `fk_project_pro` FOREIGN KEY (`pid`) REFERENCES `projects` (`pid`) ON DELETE CASCADE ON UPDATE CASCADE
) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = Dynamic;
INSERT INTO `projectrecord` VALUES (7369, 1);
INSERT INTO `projectrecord` VALUES (7521, 1);
INSERT INTO `projectrecord` VALUES (7369, 2);
INSERT INTO `projectrecord` VALUES (7499, 2);
INSERT INTO `projectrecord` VALUES (7521, 2);
INSERT INTO `projectrecord` VALUES (7369, 3);
INSERT INTO `projectrecord` VALUES (7499, 3);
INSERT INTO `projectrecord` VALUES (7521, 3);
INSERT INTO `projectrecord` VALUES (7369, 4);
INSERT INTO `projectrecord` VALUES (7499, 4);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;需求:根据编号查询员工信息及所在的部门信息&lt;/p&gt;
&lt;p&gt;实体类添加一个部门作为属性&lt;/p&gt;
&lt;p&gt;实体类&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;@AllArgsConstructor
@NoArgsConstructor
@Data
public class Emp implements Serializable &amp;#123;
    private Integer empno;
    private String ename;
    private String job;
    private Integer mgr;
    private Date hiredate;
    private Double sal;
    private Double comm;
    private Integer deptno;
    // 组合一个Dept对象作为自己的属性
    private Dept dept;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;接口&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;public interface EmpMapper &amp;#123;
    /**
     * 根据员工编号查询员工的所有信息并携带所在的部门信息
     * @param empno 要查询的员工编号
     * @return Emp对象,组合了Dept对象作为属性,对部门信息进行存储
     */
    Emp findEmpJoinDeptByEmpno(int empno);
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;映射文件&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot; ?&amp;gt;
&amp;lt;!DOCTYPE mapper
        PUBLIC &amp;quot;-//mybatis.org//DTD Mapper 3.0//EN&amp;quot;
        &amp;quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&amp;quot;&amp;gt;
&amp;lt;mapper namespace=&amp;quot;com.msb.mapper.EmpMapper&amp;quot;&amp;gt;
    &amp;lt;!--Emp findEmpJoinDeptByEmpno(int empno);--&amp;gt;
    &amp;lt;resultMap id=&amp;quot;empJoinDept&amp;quot; type=&amp;quot;emp&amp;quot;&amp;gt;
        &amp;lt;!--设置emp本身的八个属性的映射关系--&amp;gt;
        &amp;lt;id property=&amp;quot;empno&amp;quot; column=&amp;quot;empno&amp;quot;&amp;gt;&amp;lt;/id&amp;gt;
        &amp;lt;result property=&amp;quot;ename&amp;quot; column=&amp;quot;ename&amp;quot;&amp;gt;&amp;lt;/result&amp;gt;
        &amp;lt;result property=&amp;quot;job&amp;quot; column=&amp;quot;job&amp;quot;&amp;gt;&amp;lt;/result&amp;gt;
        &amp;lt;result property=&amp;quot;sal&amp;quot; column=&amp;quot;sal&amp;quot;&amp;gt;&amp;lt;/result&amp;gt;
        &amp;lt;result property=&amp;quot;hiredate&amp;quot; column=&amp;quot;hiredate&amp;quot;&amp;gt;&amp;lt;/result&amp;gt;
        &amp;lt;result property=&amp;quot;mgr&amp;quot; column=&amp;quot;mgr&amp;quot;&amp;gt;&amp;lt;/result&amp;gt;
        &amp;lt;result property=&amp;quot;comm&amp;quot; column=&amp;quot;comm&amp;quot;&amp;gt;&amp;lt;/result&amp;gt;
        &amp;lt;result property=&amp;quot;deptno&amp;quot; column=&amp;quot;deptno&amp;quot;&amp;gt;&amp;lt;/result&amp;gt;
        &amp;lt;!--
        association 处理一对一
        封装一对一信息关系的标签
        property  emp类的属性名
        javaType  用哪个类的对象给属性赋值
        --&amp;gt;
        &amp;lt;association property=&amp;quot;dept&amp;quot; javaType=&amp;quot;dept&amp;quot;&amp;gt;
            &amp;lt;id column=&amp;quot;deptno&amp;quot; property=&amp;quot;deptno&amp;quot;&amp;gt;&amp;lt;/id&amp;gt;
            &amp;lt;result column=&amp;quot;dname&amp;quot; property=&amp;quot;dname&amp;quot;&amp;gt;&amp;lt;/result&amp;gt;
            &amp;lt;result column=&amp;quot;loc&amp;quot; property=&amp;quot;loc&amp;quot;&amp;gt;&amp;lt;/result&amp;gt;
        &amp;lt;/association&amp;gt;
    &amp;lt;/resultMap&amp;gt;
    &amp;lt;select id=&amp;quot;findEmpJoinDeptByEmpno&amp;quot; resultMap=&amp;quot;empJoinDept&amp;quot; &amp;gt;
        select * from
        emp e
        left join dept  d
        on e.deptno =d.deptno
        where empno = #&amp;#123;empno&amp;#125;
    &amp;lt;/select&amp;gt;
&amp;lt;/mapper&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;测试代码&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;@Test
public void testOneToOne() throws ParseException &amp;#123;
    EmpMapper mapper = sqlSession.getMapper(EmpMapper.class);
    Emp emp = mapper.findEmpJoinDeptByEmpno(7499);
    System.out.println(emp);
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3 一对多关联查询&lt;/p&gt;
&lt;p&gt;根据部门号查询部门信息及该部门的所有员工信息&lt;/p&gt;
&lt;p&gt;实体类&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;@Data
@AllArgsConstructor
@NoArgsConstructor
public class Dept implements Serializable &amp;#123;
    private Integer deptno;
    private String dname;
    private String loc;
    // 组合一个Emp的List集合作为属性
    private List&amp;lt;Emp&amp;gt; empList;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;接口&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;package com.msb.mapper;
import com.msb.pojo.Dept;
/**
 * @Author: Ma HaiYang
 * @Description: MircoMessage:Mark_7001
 */
public interface DeptMapper &amp;#123;
    /**
     * 根据部门编号查询部门信息及该部分的所有员工信息
     * @param deptno 要查询的部门编号
     * @return Dept对象,内部组合了一个Emp的List属性用于封装部门的所有员工信息
     */
    Dept findDeptJoinEmpsByDeptno(int deptno);
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;映射文件&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot; ?&amp;gt;
&amp;lt;!DOCTYPE mapper
        PUBLIC &amp;quot;-//mybatis.org//DTD Mapper 3.0//EN&amp;quot;
        &amp;quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&amp;quot;&amp;gt;
&amp;lt;mapper namespace=&amp;quot;com.msb.mapper.DeptMapper&amp;quot;&amp;gt;
    &amp;lt;!--Dept findDeptJoinEmpsByDeptno(int deptno);--&amp;gt;
    &amp;lt;resultMap id=&amp;quot;deptJoinEmps&amp;quot; type=&amp;quot;dept&amp;quot;&amp;gt;
        &amp;lt;id column=&amp;quot;deptno&amp;quot; property=&amp;quot;deptno&amp;quot;&amp;gt;&amp;lt;/id&amp;gt;
        &amp;lt;result column=&amp;quot;dname&amp;quot; property=&amp;quot;dname&amp;quot;&amp;gt;&amp;lt;/result&amp;gt;
        &amp;lt;result column=&amp;quot;loc&amp;quot; property=&amp;quot;loc&amp;quot;&amp;gt;&amp;lt;/result&amp;gt;
        &amp;lt;!--处理一对多关系的标签--&amp;gt;
        &amp;lt;collection property=&amp;quot;empList&amp;quot; ofType=&amp;quot;emp&amp;quot; &amp;gt;
            &amp;lt;!--设置emp本身的八个属性的映射关系--&amp;gt;
            &amp;lt;id property=&amp;quot;empno&amp;quot; column=&amp;quot;empno&amp;quot;&amp;gt;&amp;lt;/id&amp;gt;
            &amp;lt;result property=&amp;quot;ename&amp;quot; column=&amp;quot;ename&amp;quot;&amp;gt;&amp;lt;/result&amp;gt;
            &amp;lt;result property=&amp;quot;job&amp;quot; column=&amp;quot;job&amp;quot;&amp;gt;&amp;lt;/result&amp;gt;
            &amp;lt;result property=&amp;quot;sal&amp;quot; column=&amp;quot;sal&amp;quot;&amp;gt;&amp;lt;/result&amp;gt;
            &amp;lt;result property=&amp;quot;hiredate&amp;quot; column=&amp;quot;hiredate&amp;quot;&amp;gt;&amp;lt;/result&amp;gt;
            &amp;lt;result property=&amp;quot;mgr&amp;quot; column=&amp;quot;mgr&amp;quot;&amp;gt;&amp;lt;/result&amp;gt;
            &amp;lt;result property=&amp;quot;comm&amp;quot; column=&amp;quot;comm&amp;quot;&amp;gt;&amp;lt;/result&amp;gt;
            &amp;lt;result property=&amp;quot;deptno&amp;quot; column=&amp;quot;deptno&amp;quot;&amp;gt;&amp;lt;/result&amp;gt;
        &amp;lt;/collection&amp;gt;
    &amp;lt;/resultMap&amp;gt;
    &amp;lt;select id=&amp;quot;findDeptJoinEmpsByDeptno&amp;quot; resultMap=&amp;quot;deptJoinEmps&amp;quot;&amp;gt;
        select * from dept d left join emp e on d.deptno =e.deptno where d.deptno =#&amp;#123;deptno&amp;#125;
    &amp;lt;/select&amp;gt;
&amp;lt;/mapper&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;测试代码&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;@Test
public void testOneToMany() throws ParseException &amp;#123;
    DeptMapper mapper = sqlSession.getMapper(DeptMapper.class);
    Dept dept = mapper.findDeptJoinEmpsByDeptno(20);
    System.out.println(dept);
    System.out.println(&amp;quot;---------&amp;quot;);
    List&amp;lt;Emp&amp;gt; empList = dept.getEmpList();
    empList.forEach(System.out::println);
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;4 多对多关联查询&lt;/p&gt;
&lt;p&gt;根据项目编号查询项目信息,以及参与到该项目之中的所有的员工信息&lt;/p&gt;
&lt;p&gt;实体类&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;@NoArgsConstructor
@AllArgsConstructor
@Data
public class Project  implements Serializable &amp;#123;
    private Integer pid;
    private String pname;
    private Integer money;
    // 组合一个ProjectRecord对象集合作为属性
    private List&amp;lt;ProjectRecord&amp;gt; projectRecords;
&amp;#125;
@Data
@AllArgsConstructor
@NoArgsConstructor
public class ProjectRecord implements Serializable &amp;#123;
    private Integer empno;
    private Integer pid;
    // 组合一个Emp对象作为属性
    private Emp emp;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;接口&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;package com.msb.mapper;
import com.msb.pojo.Emp;
import com.msb.pojo.Project;
/**
 * @Author: Ma HaiYang
 * @Description: MircoMessage:Mark_7001
 */
public interface ProjectMapper &amp;#123;
    /**
     * 根据项目编号查询一个项目信息及参与该项目的所有员工信息
     * @param pid 项目编号
     * @return 所有信息封装的Project对象
     */
    Project findProjectJoinEmpsByPid(int pid);
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;映射文件&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;xml&#34;&gt;&amp;lt;!DOCTYPE mapper
        PUBLIC &amp;quot;-//mybatis.org//DTD Mapper 3.0//EN&amp;quot;
        &amp;quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&amp;quot;&amp;gt;
&amp;lt;mapper namespace=&amp;quot;com.msb.mapper.ProjectMapper&amp;quot;&amp;gt;
    &amp;lt;!--Project findProjectJoinEmpsByPid(int pid);--&amp;gt;
    &amp;lt;resultMap id=&amp;quot;projectJoinEmps&amp;quot; type=&amp;quot;project&amp;quot;&amp;gt;
        &amp;lt;id column=&amp;quot;pid&amp;quot; property=&amp;quot;pid&amp;quot;&amp;gt;&amp;lt;/id&amp;gt;
        &amp;lt;result column=&amp;quot;pname&amp;quot; property=&amp;quot;pname&amp;quot;&amp;gt;&amp;lt;/result&amp;gt;
        &amp;lt;result column=&amp;quot;money&amp;quot; property=&amp;quot;money&amp;quot;&amp;gt;&amp;lt;/result&amp;gt;
        &amp;lt;!--一对多 集合属性 collection--&amp;gt;
        &amp;lt;collection property=&amp;quot;projectRecords&amp;quot; ofType=&amp;quot;projectRecord&amp;quot;&amp;gt;
            &amp;lt;id column=&amp;quot;empno&amp;quot; property=&amp;quot;empno&amp;quot;&amp;gt;&amp;lt;/id&amp;gt;
            &amp;lt;id column=&amp;quot;pid&amp;quot; property=&amp;quot;pid&amp;quot;&amp;gt;&amp;lt;/id&amp;gt;
            &amp;lt;!--一对一 --&amp;gt;
            &amp;lt;association property=&amp;quot;emp&amp;quot; javaType=&amp;quot;emp&amp;quot;&amp;gt;
                &amp;lt;id property=&amp;quot;empno&amp;quot; column=&amp;quot;empno&amp;quot;&amp;gt;&amp;lt;/id&amp;gt;
                &amp;lt;result property=&amp;quot;ename&amp;quot; column=&amp;quot;ename&amp;quot;&amp;gt;&amp;lt;/result&amp;gt;
                &amp;lt;result property=&amp;quot;job&amp;quot; column=&amp;quot;job&amp;quot;&amp;gt;&amp;lt;/result&amp;gt;
                &amp;lt;result property=&amp;quot;sal&amp;quot; column=&amp;quot;sal&amp;quot;&amp;gt;&amp;lt;/result&amp;gt;
                &amp;lt;result property=&amp;quot;hiredate&amp;quot; column=&amp;quot;hiredate&amp;quot;&amp;gt;&amp;lt;/result&amp;gt;
                &amp;lt;result property=&amp;quot;mgr&amp;quot; column=&amp;quot;mgr&amp;quot;&amp;gt;&amp;lt;/result&amp;gt;
                &amp;lt;result property=&amp;quot;comm&amp;quot; column=&amp;quot;comm&amp;quot;&amp;gt;&amp;lt;/result&amp;gt;
                &amp;lt;result property=&amp;quot;deptno&amp;quot; column=&amp;quot;deptno&amp;quot;&amp;gt;&amp;lt;/result&amp;gt;
            &amp;lt;/association&amp;gt;
        &amp;lt;/collection&amp;gt;
    &amp;lt;/resultMap&amp;gt;
    &amp;lt;select id=&amp;quot;findProjectJoinEmpsByPid&amp;quot;  resultMap=&amp;quot;projectJoinEmps&amp;quot;&amp;gt;
        select * from
        project p
        left join projectrecord pr
        on p.pid = pr.pid
        left join emp e
        on e.empno = pr.empno
        where p.pid= #&amp;#123;pid&amp;#125;
    &amp;lt;/select&amp;gt;
&amp;lt;/mapper&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;测试代码&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;@Test
public void testManyToMany() throws ParseException &amp;#123;
    ProjectMapper mapper = sqlSession.getMapper(ProjectMapper.class);
    Project project = mapper.findProjectJoinEmpsByPid(2);
    System.out.println(project.getPid());
    System.out.println(project.getPname());
    System.out.println(project.getMoney());
    List&amp;lt;ProjectRecord&amp;gt; projectRecords = project.getProjectRecords();
    for (ProjectRecord projectRecord : projectRecords) &amp;#123;
        Emp emp = projectRecord.getEmp();
        System.out.println(emp);
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;2-级联查询&#34;&gt;&lt;a href=&#34;#2-级联查询&#34; class=&#34;headerlink&#34; title=&#34;2 级联查询&#34;&gt;&lt;/a&gt;2 级联查询&lt;/h2&gt;&lt;p&gt;级联查询，顾名思义，就是利于数据库表间的外键关联关系进行自动的级联查询操作。使用MyBatis实现级联查询，除了实体类增加关联属性外，还需要在映射文件中进行配置。&lt;/p&gt;
&lt;h3 id=&#34;1-立即加载&#34;&gt;&lt;a href=&#34;#1-立即加载&#34; class=&#34;headerlink&#34; title=&#34;1 立即加载&#34;&gt;&lt;/a&gt;1 立即加载&lt;/h3&gt;&lt;h3 id=&#34;2-延迟加载&#34;&gt;&lt;a href=&#34;#2-延迟加载&#34; class=&#34;headerlink&#34; title=&#34;2 延迟加载&#34;&gt;&lt;/a&gt;2 延迟加载&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;延迟加载，又称按需加载&lt;/strong&gt;。延迟加载的内容等到真正使用时才去进行加载（查询）。多用在关联对象或集合中。&lt;/p&gt;
&lt;p&gt;延迟加载的好处：先从单表查询、需要时再从关联表去关联查询，大大降低数据库在单位时间内的查询工作量,将工作在时间上的分配更加均匀，而且单表要比关联查询多张表速度要快。&lt;/p&gt;
&lt;p&gt;延迟加载的设置&lt;/p&gt;
&lt;p&gt;第一步：全局开关：在sqlMapConfig.xml中打开延迟加载的开关。配置完成后所有的association和collection元素都生效&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;xml&#34;&gt;  &amp;lt;settings&amp;gt;
      &amp;lt;setting name=&amp;quot;lazyLoadingEnabled&amp;quot; value=&amp;quot;true&amp;quot;/&amp;gt;
      &amp;lt;setting name=&amp;quot;aggressiveLazyLoading&amp;quot; value=&amp;quot;true&amp;quot;/&amp;gt;
  &amp;lt;/settings&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;font color=#008000&gt;lazyLoadingEnabled&lt;/font&gt;:是否开启延迟加载。是Mybatis是否启用懒加载的全局开关。当开启时，所有关联对象都会延迟加载。特定关联关系中可通过设置fetchType属性来覆盖该项的开关状态&lt;/p&gt;
&lt;p&gt;&lt;font color=#008000 &gt;aggressiveLazyLoading&lt;/font&gt;：当开启时，任何方法的调用都会懒加载对象的所有属性。否则，每个属性会按需加载,&lt;/p&gt;
&lt;p&gt;第二步：分开关：指定的association和collection元素中配置&lt;font color=#0000FF&gt;fetchType&lt;/font&gt;属性。eager：表示立刻加载；lazy：表示延迟加载。&lt;strong&gt;将覆盖全局延迟设置。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;3-总结&#34;&gt;&lt;a href=&#34;#3-总结&#34; class=&#34;headerlink&#34; title=&#34;3 总结&#34;&gt;&lt;/a&gt;3 总结&lt;/h2&gt;&lt;h4 id=&#34;resultMap中的常见属性&#34;&gt;&lt;a href=&#34;#resultMap中的常见属性&#34; class=&#34;headerlink&#34; title=&#34;resultMap中的常见属性&#34;&gt;&lt;/a&gt;resultMap中的常见属性&lt;/h4&gt;&lt;table style=&#34;text-align: center;&#34; cellpadding=&#34;30&#34; &gt;
    &lt;tr style=&#34;background-color:#E2EFD9 ;&#34;&gt;
            &lt;td&gt;property&lt;/td&gt;
            &lt;td&gt;需要映射到JavaBean 的属性名称&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td &gt;javaType&lt;/td&gt;
            &lt;td&gt;property的类型，一个完整的类名，或者是一个类型别名。如果你匹配的是一个JavaBean，那MyBatis 通常会自行检测到&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr style=&#34;background-color:#E2EFD9 ;&#34;&gt;
            &lt;td&gt;column&lt;/td&gt;
            &lt;td&gt;数据表的列名或者列别名&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;jdbcType&lt;/td&gt;
            &lt;td&gt;column在数据库表中的类型。这个属性只在insert,update   或delete 的时候针对允许空的列有用。JDBC 需要这项，但MyBatis 不需要&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr style=&#34;background-color:#E2EFD9 ;&#34;&gt;
            &lt;td&gt;typeHandler&lt;/td&gt;
            &lt;td&gt;使用这个属性可以覆写类型处理器，实现javaType、jdbcType之间的相互转换。一般可以省略，会探测到使用的什么类型的typeHandler进行处理&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;fetchType&lt;/td&gt;
            &lt;td&gt;自动延迟加载&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr style=&#34;background-color:#E2EFD9 ;&#34;&gt;
            &lt;td&gt;select&lt;/td&gt;
            &lt;td&gt;association、collection的属性，使用哪个查询查询属性的值，要求指定namespace+id的全名称&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;ofType&lt;/td&gt;
            &lt;td&gt;collection的属性，指明集合中元素的类型（即泛型类型）&lt;/td&gt;
        &lt;/tr&gt;
    &lt;/table&gt;




&lt;h4 id=&#34;级联查询和多表查询的比较及其选择&#34;&gt;&lt;a href=&#34;#级联查询和多表查询的比较及其选择&#34; class=&#34;headerlink&#34; title=&#34;级联查询和多表查询的比较及其选择&#34;&gt;&lt;/a&gt;级联查询和多表查询的比较及其选择&lt;/h4&gt;&lt;table style=&#34;text-align: center;&#34; cellpadding=&#34;30&#34; &gt;
    &lt;tr style=&#34;background-color:#E2EFD9 ;&#34;&gt;
            &lt;td&gt;SQL语句数量&lt;/td&gt;
        &lt;td&gt;多条&lt;/td&gt;
        &lt;td&gt;一条&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td &gt;性能&lt;/td&gt;
        &lt;td&gt;性能低&lt;/td&gt;
        &lt;td&gt;性能高&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr style=&#34;background-color:#E2EFD9 ;&#34;&gt;
        &lt;td&gt;延迟加载&lt;/td&gt;
        &lt;td&gt;立即加载、延迟加载&lt;/td&gt;
        &lt;td&gt;只有立即加载&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;灵活性&lt;/td&gt;
        &lt;td&gt;更灵活&lt;/td&gt;
        &lt;td&gt;不灵活&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr style=&#34;background-color:#E2EFD9 ;&#34;&gt;
        &lt;td&gt;SQL难易度&lt;/td&gt;
        &lt;td&gt;简单&lt;/td&gt;
        &lt;td&gt;复杂&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;选择依据&lt;/td&gt;
        &lt;td&gt;简单、灵活&lt;/td&gt;
        &lt;td&gt;高性能&lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;




&lt;p&gt;&lt;strong&gt;ResultType和ResultMap使用场景&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;pre&gt;&lt;code&gt;如果你做的是单表的查询并且封装的实体和数据库的字段一一对应   resultType
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;pre&gt;&lt;code&gt;如果实体封装的属性和数据库的字段不一致  resultMap
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;pre&gt;&lt;code&gt; 使用N+1级联查询的时候  resultMap
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;pre&gt;&lt;code&gt;使用的是多表的连接查询  resultMap
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;一对一关联映射的实现&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;pre&gt;&lt;code&gt;实例：学生和学生证、雇员和工牌
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;pre&gt;&lt;code&gt;数据库层次：主键关联或者外键关联（参看之前内容）
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;pre&gt;&lt;code&gt; MyBatis层次：在映射文件的设置双方均使用association即可，用法相同
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;多对多映射的实现&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;pre&gt;&lt;code&gt;实例：学生和课程、用户和角色
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;pre&gt;&lt;code&gt; 数据库层次：引入一个中间表将一个多对多转为两个一对多
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;pre&gt;&lt;code&gt; MyBatis层次
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;方法1：在映射文件的设置双方均使用collection即可，不用引入中间类&lt;/p&gt;
&lt;p&gt;方法2：引入中间类和中间类的映射文件，按照两个一对多处理&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;自关联映射&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;pre&gt;&lt;code&gt;实例：Emp表中的员工和上级。一般是一对多关联
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;pre&gt;&lt;code&gt;数据库层次：外键参考当前表的主键（比如mgr参考empno）
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;MyBatis层次：按照一对多处理，但是增加的属性都写到一个实体类中，增加的映射也都写到一个映射文件中&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;9-MyBatis注解开发&#34;&gt;&lt;a href=&#34;#9-MyBatis注解开发&#34; class=&#34;headerlink&#34; title=&#34;9 MyBatis注解开发&#34;&gt;&lt;/a&gt;9 MyBatis注解开发&lt;/h1&gt;&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;public interface DeptMapper &amp;#123;
    Dept findDeptByDeptno(int deptno);
    @Select(&amp;quot;select * from dept where deptno =#&amp;#123;deptno&amp;#125;&amp;quot;)
    Dept findByDeptno(int deptno);
    int updateDept(Dept dept);
    int addDept(Dept dept);
    @Delete(&amp;quot;delete from dept where deptno =#&amp;#123;deptno&amp;#125;&amp;quot;)
    int removeDept(int deptno);
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;1.使用注解没有实现Java代码和SQL语句的解耦&lt;/p&gt;
&lt;p&gt;2.无法实现SQL语句的动态拼接&lt;/p&gt;
&lt;p&gt;3.进行多表的查询时定制ResultMap比较麻烦&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注解和XML的优缺点&lt;/strong&gt;&lt;/p&gt;
&lt;table style=&#34;text-align: center;&#34; cellpadding=&#34;30&#34; &gt;
    &lt;tr style=&#34;background-color:#E2EFD9 ;&#34;&gt;
            &lt;td&gt;优点&lt;/td&gt;
        &lt;td&gt;类和类之间的解耦&lt;/td&gt;
        &lt;td&gt;简化配置&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td &gt; &lt;/td&gt;
        &lt;td&gt;利于修改。直接修改XML文件，无需到源代码中修改。&lt;/td&gt;
        &lt;td&gt;使用起来直观且容易，提升开发效率&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr style=&#34;background-color:#E2EFD9 ;&#34;&gt;
        &lt;td&gt;&lt;/td&gt;
        &lt;td&gt;配置集中在XML中，对象间关系一目了然，利于快速了解项目和维护&lt;/td&gt;
        &lt;td&gt;类型安全，编译器进行校验，不用等到运行期才会发现错误&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;&lt;/td&gt;
        &lt;td&gt;容易和其他系统进行数据交交换&lt;/td&gt;
        &lt;td&gt;注解的解析可以不依赖于第三方库，可以直接使用Java自带的反射&lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;






&lt;h1 id=&#34;10-缓存&#34;&gt;&lt;a href=&#34;#10-缓存&#34; class=&#34;headerlink&#34; title=&#34;10 缓存&#34;&gt;&lt;/a&gt;10 缓存&lt;/h1&gt;&lt;img data-src=&#34;/2022/10/07/ORM/Mybatis/image-20220617211853352.png&#34; class=&#34;&#34; title=&#34;image-20220617211853352&#34;&gt;

&lt;blockquote&gt;
&lt;p&gt;​	是一种临时存储少量数据至内存或者是磁盘的一种技术.减少数据的加载次数,可以降低工作量,提高程序响应速度&lt;/p&gt;
&lt;p&gt;​	缓存的重要性是不言而喻的。mybatis的缓存将相同查询条件的SQL语句执行一遍后所得到的结果存在内存或者某种缓存介质当中，当下次遇到一模一样的查询SQL时候不在执行SQL与数据库交互，而是直接从缓存中获取结果，减少服务器的压力；尤其是在查询越多、缓存命中率越高的情况下，使用缓存对性能的提高更明显。&lt;/p&gt;
&lt;p&gt;​	MyBatis允许使用缓存，缓存一般放置在高速读&amp;#x2F;写的存储器上，比如服务器的内存，能够有效的提供系统性能。MyBatis分为&lt;font color=#FF0000&gt;一级缓存和二级缓存&lt;/font&gt;，同时也可配置关于缓存设置。&lt;/p&gt;
&lt;p&gt;​	一级存储是SqlSession上的缓存，二级缓存是在SqlSessionFactory(namespace)上的缓存。默认情况下，MyBatis开启一级缓存，没有开启二级缓存。当数据量大的时候可以借助一些第三方缓存框架或Redis缓存来协助保存Mybatis的二级缓存数据。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;img data-src=&#34;/2022/10/07/ORM/Mybatis/image-20220617211938471.png&#34; class=&#34;&#34; title=&#34;image-20220617211938471&#34;&gt;



&lt;h2 id=&#34;1-一级缓存&#34;&gt;&lt;a href=&#34;#1-一级缓存&#34; class=&#34;headerlink&#34; title=&#34;1 一级缓存&#34;&gt;&lt;/a&gt;1 一级缓存&lt;/h2&gt;&lt;p&gt;一级存储是SqlSession上的缓存，默认开启，是一种内存型缓存,不要求实体类对象实现Serializable接口。&lt;/p&gt;
&lt;p&gt;缓存中的数据使用键值对形式存储数据&lt;/p&gt;
&lt;p&gt;&amp;#x3D;&amp;#x3D;namespace + sqlid + args + offset     &amp;gt;&amp;gt;&amp;gt;   hash 值作为键,查询出的结果作为值&amp;#x3D;&amp;#x3D;&lt;/p&gt;
&lt;img data-src=&#34;/2022/10/07/ORM/Mybatis/image-20220617212008075.png&#34; class=&#34;&#34; title=&#34;image-20220617212008075&#34;&gt;

&lt;p&gt;测试 代码&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;@Test
public void testFindDeptByDetpno()   &amp;#123;
    EmpMapper mapper = sqlSession.getMapper(EmpMapper.class);
    Emp emp = mapper.findByEmpno(7521);
    System.out.println(emp);
    // 中间发生了增删改或者是调用了SqlSession调用了commit,会自动清空缓存
    sqlSession.commit();// 增删改的时候调用
    EmpMapper mapper2 = sqlSession.getMapper(EmpMapper.class);
    Emp emp2 = mapper2.findByEmpno(7521);
    System.out.println(emp2); 
    
    System.out.println(emp==emp2);// 没有commit之前为True
    System.out.println(mapper==mapper2);// false 表示确实产生了两个代理对象
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;2-二级缓存&#34;&gt;&lt;a href=&#34;#2-二级缓存&#34; class=&#34;headerlink&#34; title=&#34;2 二级缓存&#34;&gt;&lt;/a&gt;2 二级缓存&lt;/h2&gt;&lt;p&gt;二级缓存是以namespace为标记的缓存，可以是由一个SqlSessionFactory创建的SqlSession之间共享缓存数据。默认并不开启。下面的代码中创建了两个SqlSession，执行相同的SQL语句，尝试让第二个SqlSession使用第一个SqlSession查询后缓存的数据。要求实体类必须实现序列化接口&lt;/p&gt;
&lt;img data-src=&#34;/2022/10/07/ORM/Mybatis/image-20220617212052512.png&#34; class=&#34;&#34; title=&#34;image-20220617212052512&#34;&gt;



&lt;p&gt;接口&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;public interface EmpMapper &amp;#123;
    Emp findByEmpno(int empno);
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;映射文件&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;xml&#34;&gt;&amp;lt;mapper namespace=&amp;quot;com.msb.mapper.EmpMapper&amp;quot;&amp;gt;
    &amp;lt;cache/&amp;gt;
    &amp;lt;select id=&amp;quot;findByEmpno&amp;quot; resultType=&amp;quot;emp&amp;quot; useCache=&amp;quot;true&amp;quot; flushCache=&amp;quot;false&amp;quot;&amp;gt;
        select * from emp where empno =#&amp;#123;empno&amp;#125;
    &amp;lt;/select&amp;gt;
&amp;lt;/mapper&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;测试 代码&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;package com.msb.test;
import com.msb.mapper.EmpMapper;
import com.msb.pojo.Emp;
import org.apache.ibatis.io.Resources;
import org.apache.ibatis.session.SqlSession;
import org.apache.ibatis.session.SqlSessionFactory;
import org.apache.ibatis.session.SqlSessionFactoryBuilder;
import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import java.io.IOException;
import java.io.InputStream;
/**
 * @Author: Ma HaiYang
 * @Description: MircoMessage:Mark_7001
 */
public class Test3 &amp;#123;
    private SqlSession sqlSession;
    private SqlSession sqlSession2;
    @Before
    public void init()&amp;#123;
        SqlSessionFactoryBuilder ssfb =new SqlSessionFactoryBuilder();
        InputStream resourceAsStream = null;
        try &amp;#123;
            resourceAsStream = Resources.getResourceAsStream(&amp;quot;sqlMapConfig.xml&amp;quot;);
        &amp;#125; catch (IOException e) &amp;#123;
            e.printStackTrace();
        &amp;#125;
        SqlSessionFactory factory=ssfb.build(resourceAsStream) ;
        sqlSession=factory.openSession();
        sqlSession2=factory.openSession();
    &amp;#125;
    @Test
    public void testFindDeptByDetpno()   &amp;#123;
        EmpMapper mapper = sqlSession.getMapper(EmpMapper.class);
        Emp emp = mapper.findByEmpno(7521);
        System.out.println(emp);
        // SqlSession提交之后,才会将查询的结果放入二级缓存
        sqlSession.commit();
        EmpMapper mapper2 = sqlSession2.getMapper(EmpMapper.class);
        Emp emp2 = mapper2.findByEmpno(7521);
        System.out.println(emp2);
    &amp;#125;
    @After
    public void release()&amp;#123;
        // 关闭SQLSession
        sqlSession.close();
        sqlSession2.close();
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​	其中的commit()，执行该命令后才会将该SqlSession的查询结果从一级缓存中放入二级缓存，供其他SqlSession使用。另外执行SqlSession的close()也会将该SqlSession的查询结果从一级缓存中放入二级缓存。两种方式区别在当前SqlSession是否关闭了。&lt;/p&gt;
&lt;p&gt;执行结果显示进行了两次对数据库的SQL查询，说明二级缓存并没有开启。需要进行如下步骤完成开启。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;全局开关：在sqlMapConfig.xml文件中的&lt;font color=blue&gt;&lt;settings&gt;&lt;/font&gt;标签配置开启二级缓存&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;xml&#34;&gt;&amp;lt;settings&amp;gt;
    &amp;lt;setting name=&amp;quot;cacheEnabled&amp;quot; value=&amp;quot;true&amp;quot;/&amp;gt;
&amp;lt;/settings&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;cacheEnabled的默认值就是true，所以这步的设置可以省略。&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;分开关：在要开启二级缓存的mapper文件中开启缓存：&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;xml&#34;&gt;&amp;lt;mapper namespace=&amp;quot;com.msb.mapper.EmployeeMapper&amp;quot;&amp;gt;
    &amp;lt;cache/&amp;gt;
&amp;lt;/mapper&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;二级缓存未必完全使用内存,有可能占用硬盘存储,缓存中存储的JavaBean对象必须实现序列化接口,&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;public class Emp implements  Serializable &amp;#123;  &amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;经过设置后，查询结果如图所示。发现第一个SqlSession会首先去二级缓存中查找，如果不存在，就查询数据库，&lt;font color=#FF0000&gt;在commit()或者close()的时候将数据放入到二级缓存&lt;/font&gt;。第二个SqlSession执行相同SQL语句查询时就直接从二级缓存中获取了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​	1)    MyBatis的二级缓存的缓存介质有多种多样，而并不一定是在内存中，所以需要对JavaBean对象实现序列化接口。&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;二级缓存是以 namespace 为单位的，不同 namespace 下的操作互不影响&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;​	3)    加入Cache元素后，会对相应命名空间所有的select元素查询结果进行缓存，而其中的insert、update、delete在操作是会清空整个namespace的缓存。&lt;/p&gt;
&lt;p&gt;​	4)    cache 有一些可选的属性 type, eviction, flushInterval, size, readOnly, blocking。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;xml&#34;&gt;&amp;lt;cache type=&amp;quot;&amp;quot; readOnly=&amp;quot;&amp;quot; eviction=&amp;quot;&amp;quot;flushInterval=&amp;quot;&amp;quot;size=&amp;quot;&amp;quot;blocking=&amp;quot;&amp;quot;/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&amp;lt;cache type&amp;#x3D;”” readOnly&amp;#x3D;”” eviction&amp;#x3D;””flushInterval&amp;#x3D;””size&amp;#x3D;””blocking&amp;#x3D;””&amp;#x2F;&amp;gt;&lt;/p&gt;
&lt;table style=&#34;text-align: center;&#34; cellpadding=&#34;30&#34; &gt;
    &lt;style&gt;
        td {
            text-align:center;
        }
        p {
          text-align:center;
        }
    &lt;/style&gt;
    &lt;tr style=&#34;background-color:#E2EFD9 ;&#34;&gt;
            &lt;td&gt;type&lt;/td&gt;
         &lt;td&gt;&lt;p&gt;自定义缓存类，要求实现org.apache.ibatis.cache.Cache接口&lt;/p&gt;&lt;/td&gt;
            &lt;td&gt;null&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;readOnly&lt;/td&gt;
            &lt;td &gt;&lt;p&gt;是否只读&lt;/p&gt;
                &lt;p&gt; true:给所有调用者返回缓存对象的相同实例。因此这些对象不能被修改。 &lt;/p&gt;
                &lt;span&gt; 这提供了很重要的性能优势。&lt;/span&gt;
                &lt;p&gt;false:会返回缓存对象的拷贝(通过序列化)。&lt;/p&gt;
                &lt;p&gt; 这会慢一些,但是安全&lt;/p&gt;
            &lt;/td&gt;
            &lt;td&gt;false&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr style=&#34;background-color:#E2EFD9 ;&#34;&gt;
            &lt;td&gt;eviction&lt;/td&gt;
            &lt;td&gt;	 
                &lt;p&gt;缓存策略&lt;br&gt;LRU（默认） – 最近最少使用：移除最长时间不被使用的对象。&lt;/p&gt;
                &lt;p&gt;FIFO – 先进先出：按对象进入缓存的顺序来移除它们。&lt;/p&gt;
                &lt;p&gt;SOFT – 软引用：基于垃圾回收器状态和软引用规则移除对象。&lt;/p&gt;
                &lt;p&gt;WEAK – 弱引用：更积极地基于垃圾收集器状态和弱引用规则移除对象。&lt;/p&gt;
            &lt;/td&gt;
            &lt;td&gt;LRU&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;flushInterval&lt;/td&gt;
            &lt;td&gt;&lt;p&gt;
                    刷新间隔，毫秒为单位。默认为null，也就是没有刷新间隔，
                &lt;/p&gt;
                &lt;p&gt;
                    只有执行update、insert、delete语句才会刷新
                &lt;/p&gt;
            &lt;/td&gt;
            &lt;td&gt;null&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr style=&#34;background-color:#E2EFD9 ;&#34;&gt;
             &lt;td&gt;size&lt;/td&gt;
            &lt;td&gt;&lt;p&gt;缓存对象个数&lt;p&gt;&lt;/td&gt;
            &lt;td&gt;1024&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;blocking&lt;/td&gt;
            &lt;td&gt;
                &lt;p&gt;是否使用阻塞性缓存BlockingCache&lt;/p&gt;
                &lt;p&gt;true：在查询缓存时锁住对应的Key，如果缓存命中了则会释放对应的锁，&lt;/p&gt;
                &lt;span&gt;否则会在查询数据库以后再释放锁，&lt;/span&gt;
                &lt;p&gt;保证只有一个线程到数据库中查找指定key对应的数据&lt;/p&gt;
                &lt;p&gt;false：不使用阻塞性缓存，性能更好&lt;/p&gt;
            &lt;/td&gt;
            &lt;td&gt;false&lt;/td&gt;
        &lt;/tr&gt;
&lt;/table&gt;





&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;如果在加入Cache元素的前提下让个别select 元素不使用缓存，可以使用useCache属性，设置为false。useCache控制当前sql语句是否启用缓存  flushCache控制当前sql执行一次后是否刷新缓存&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;xml&#34;&gt;&amp;lt;select id=&amp;quot;findByEmpno&amp;quot; resultType=&amp;quot;emp&amp;quot; useCache=&amp;quot;true&amp;quot; flushCache=&amp;quot;false&amp;quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;3-三方缓存&#34;&gt;&lt;a href=&#34;#3-三方缓存&#34; class=&#34;headerlink&#34; title=&#34;3 三方缓存&#34;&gt;&lt;/a&gt;3 三方缓存&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;分布式缓存框架：我们系统为了提高系统并发和性能，一般对系统进行分布式部署（集群部署方式）不适用分布缓存， 缓存的数据在各个服务单独存储，不方便系统开发。所以要使用分布式缓存对缓存数据进行集中管理.ehcache,redis ,memcache缓存框架。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Ehcache：是一种广泛使用的开源java分布式缓存。主要面向通用缓存，javaEE 和 轻量级容器。它具有内存和磁盘存储功能。被用于大型复杂分布式web application的&lt;/p&gt;
&lt;p&gt;这里的三方缓存是作为二级缓存使用的&lt;/p&gt;
&lt;p&gt;导入依赖的jar文件&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;xml&#34;&gt; &amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.mybatis.caches&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;mybatis-ehcache&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.0.2&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;net.sf.ehcache&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;ehcache&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;2.10.1&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.slf4j&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;slf4j-nop&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.7.2&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;去各自的sql映射文件里,开启二级缓存,并把缓存类型指定为EhcacheCache&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;xml&#34;&gt; &amp;lt;cache type=&amp;quot;org.mybatis.caches.ehcache.EhcacheCache&amp;quot;/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在资源目录下放置一个缓存配置文件,文件名为: ehcache.xml 内容如下&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;
&amp;lt;ehcache xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot;
         xsi:noNamespaceSchemaLocation=&amp;quot;ehcache.xsd&amp;quot;
         updateCheck=&amp;quot;true&amp;quot; monitoring=&amp;quot;autodetect&amp;quot;
         dynamicConfig=&amp;quot;true&amp;quot;&amp;gt;
    &amp;lt;diskStore path=&amp;quot;D:\msb\ehcache&amp;quot; /&amp;gt;
    &amp;lt;defaultCache
            maxElementsInMemory=&amp;quot;1000&amp;quot;
            maxElementsOnDisk=&amp;quot;10000000&amp;quot;
            eternal=&amp;quot;false&amp;quot;
            overflowToDisk=&amp;quot;true&amp;quot;
            timeToIdleSeconds=&amp;quot;120&amp;quot;
            timeToLiveSeconds=&amp;quot;120&amp;quot;
            diskExpiryThreadIntervalSeconds=&amp;quot;120&amp;quot;
            memoryStoreEvictionPolicy=&amp;quot;LRU&amp;quot;&amp;gt;
    &amp;lt;/defaultCache&amp;gt;
&amp;lt;/ehcache&amp;gt;
        &amp;lt;!--  Cache配置
        ·           name：Cache的唯一标识
        ·           maxElementsInMemory：内存中最大缓存对象数。
        ·           maxElementsOnDisk：磁盘中最大缓存对象数，若是0表示无穷大。
        ·           eternal：Element是否永久有效，一但设置了，timeout将不起作用。
        ·           overflowToDisk：配置此属性，当内存中Element数量达到maxElementsInMemory时，Ehcache将会Element写到磁盘中。
        ·           timeToIdleSeconds：设置Element在失效前的允许闲置时间。仅当element不是永久有效时使用，可选属性，默认值是0，也就是可闲置时间无穷大。
        ·           timeToLiveSeconds：设置Element在失效前允许存活时间。最大时间介于创建时间和失效时间之间。仅当element不是永久有效时使用，默认是0.，也就是element存活时间无穷大。
        ·           diskExpiryThreadIntervalSeconds：磁盘失效线程运行时间间隔，默认是120秒。
        ·           diskSpoolBufferSizeMB：这个参数设置DiskStore（磁盘缓存）的缓存区大小。默认是30MB。每个Cache都应该有自己的一个缓冲区。
        ·           memoryStoreEvictionPolicy：当达到maxElementsInMemory限制时，Ehcache将会根据指定的策略去清理内存。默认策略是LRU（最近最少使用）。你可以设置为FIFO（先进先出）或是LFU（较少使用）。     --&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;11-逆向工程&#34;&gt;&lt;a href=&#34;#11-逆向工程&#34; class=&#34;headerlink&#34; title=&#34;11 逆向工程&#34;&gt;&lt;/a&gt;11 逆向工程&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;MyBatisPlus 内容，简略分析，可以参考后面具体内容&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;MyBatis的一个主要的特点就是需要程序员自己编写SQL，那么如果表太多的话，难免会很麻烦，所以MyBatis官方提供了一个逆向工程，可以针对单表自动生成MyBatis执行所需要的代码（包括mapper.xml，mapper.java，pojo）。一般在开发中，常用的逆向工程方式是通过数据库的表生成代码。&lt;/p&gt;
&lt;p&gt;创建maven项目导入逆向工程依赖&lt;/p&gt;
&lt;img data-src=&#34;/2022/10/07/ORM/Mybatis/image-20220617221042957.png&#34; class=&#34;&#34; title=&#34;image-20220617221042957&#34;&gt;

&lt;pre&gt;&lt;code class=&#34;xml&#34;&gt;&amp;lt;dependencies&amp;gt;
  
    &amp;lt;!-- mysql驱动包 --&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;mysql&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;mysql-connector-java&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;8.0.16&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;!-- 日志包，方便查看执行信息--&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.slf4j&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;slf4j-log4j12&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;1.6.1&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;!-- 代码生成工具jar --&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.mybatis.generator&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;mybatis-generator-core&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;1.3.2&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;
&amp;lt;/dependencies&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;配置逆向工程配置文件 在resources目录下放置一个名为generatorConfig.xml的配置文件,文件内容如下&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;
&amp;lt;!DOCTYPE generatorConfiguration
  PUBLIC &amp;quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&amp;quot;
  &amp;quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&amp;quot;&amp;gt;
&amp;lt;generatorConfiguration&amp;gt;
   &amp;lt;context id=&amp;quot;testTables&amp;quot; targetRuntime=&amp;quot;MyBatis3&amp;quot;&amp;gt;
      &amp;lt;commentGenerator&amp;gt;
         &amp;lt;!-- 是否去除自动生成的注释 true：是 ： false:否 --&amp;gt;
         &amp;lt;property name=&amp;quot;suppressAllComments&amp;quot; value=&amp;quot;true&amp;quot; /&amp;gt;
      &amp;lt;/commentGenerator&amp;gt;
      &amp;lt;!--数据库连接的信息：驱动类、连接地址、用户名、密码 --&amp;gt;
      &amp;lt;!-- &amp;lt;jdbcConnection driverClass=&amp;quot;com.mysql.jdbc.Driver&amp;quot;
         connectionURL=&amp;quot;jdbc:mysql://localhost:3306/mybatis&amp;quot; userId=&amp;quot;root&amp;quot;
         password=&amp;quot;123&amp;quot;&amp;gt;
      &amp;lt;/jdbcConnection&amp;gt; --&amp;gt;
       &amp;lt;jdbcConnection driverClass=&amp;quot;com.mysql.cj.jdbc.Driver&amp;quot;
         connectionURL=&amp;quot;jdbc:mysql://127.0.0.1:3306/mydb?useSSL=false&amp;amp;amp;useUnicode=true&amp;amp;amp;characterEncoding=UTF-8&amp;amp;amp;serverTimezone=Asia/Shanghai&amp;amp;amp;allowPublicKeyRetrieval=true&amp;quot;
         userId=&amp;quot;root&amp;quot;
         password=&amp;quot;root&amp;quot;&amp;gt;
      &amp;lt;/jdbcConnection&amp;gt; 
      &amp;lt;!-- 默认false，把JDBC DECIMAL 和 NUMERIC 类型解析为 Integer，为 true时把JDBC DECIMAL 和 
         NUMERIC 类型解析为java.math.BigDecimal --&amp;gt;
      &amp;lt;javaTypeResolver&amp;gt;
         &amp;lt;property name=&amp;quot;forceBigDecimals&amp;quot; value=&amp;quot;false&amp;quot; /&amp;gt;
      &amp;lt;/javaTypeResolver&amp;gt;
      &amp;lt;!-- targetProject:生成PO类的位置 --&amp;gt;
      &amp;lt;javaModelGenerator targetPackage=&amp;quot;com.msb.pojo&amp;quot;
         targetProject=&amp;quot;.\src&amp;quot;&amp;gt;
         &amp;lt;!-- enableSubPackages:是否让schema作为包的后缀 --&amp;gt;
         &amp;lt;property name=&amp;quot;enableSubPackages&amp;quot; value=&amp;quot;false&amp;quot; /&amp;gt;
         &amp;lt;!-- 从数据库返回的值被清理前后的空格 --&amp;gt;
         &amp;lt;property name=&amp;quot;trimStrings&amp;quot; value=&amp;quot;true&amp;quot; /&amp;gt;
      &amp;lt;/javaModelGenerator&amp;gt;
        &amp;lt;!-- targetProject:mapper映射文件生成的位置 --&amp;gt;
      &amp;lt;sqlMapGenerator targetPackage=&amp;quot;com.msb.mapper&amp;quot;
         targetProject=&amp;quot;.\src&amp;quot;&amp;gt;
         &amp;lt;!-- enableSubPackages:是否让schema作为包的后缀 --&amp;gt;
         &amp;lt;property name=&amp;quot;enableSubPackages&amp;quot; value=&amp;quot;false&amp;quot; /&amp;gt;
      &amp;lt;/sqlMapGenerator&amp;gt;
      &amp;lt;!-- targetPackage：mapper接口生成的位置 --&amp;gt;
      &amp;lt;javaClientGenerator type=&amp;quot;XMLMAPPER&amp;quot;
         targetPackage=&amp;quot;com.msb.mapper&amp;quot;
         targetProject=&amp;quot;.\src&amp;quot;&amp;gt;
         &amp;lt;!-- enableSubPackages:是否让schema作为包的后缀 --&amp;gt;
         &amp;lt;property name=&amp;quot;enableSubPackages&amp;quot; value=&amp;quot;false&amp;quot; /&amp;gt;
      &amp;lt;/javaClientGenerator&amp;gt;
      &amp;lt;!-- 指定数据库表 --&amp;gt;
      
      &amp;lt;table tableName=&amp;quot;dept&amp;quot; domainObjectName=&amp;quot;Dept&amp;quot;
       enableCountByExample=&amp;quot;false&amp;quot; enableUpdateByExample=&amp;quot;false&amp;quot; enableDeleteByExample=&amp;quot;false&amp;quot;    
               enableSelectByExample=&amp;quot;false&amp;quot; selectByExampleQueryId=&amp;quot;false&amp;quot; &amp;gt;
               &amp;lt;columnOverride column=&amp;quot;id&amp;quot; javaType=&amp;quot;Integer&amp;quot; /&amp;gt;
         &amp;lt;/table&amp;gt;
      
   &amp;lt;/context&amp;gt;
&amp;lt;/generatorConfiguration&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在resources目录下放置一个名为log4j.properties的配置文件,文件内容如下&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;properties&#34;&gt;log4j.rootLogger=debug,stdout
log4j.appender.stdout=org.apache.log4j.ConsoleAppender
log4j.appender.stdout.Target=System.err
log4j.appender.stdout.layout=org.apache.log4j.SimpleLayout
log4j.appender.logfile=org.apache.log4j.FileAppender
log4j.appender.logfile.File=d:/msb.log
log4j.appender.logfile.layout=org.apache.log4j.PatternLayout
log4j.appender.logfile.layout.ConversionPattern=%d&amp;#123;yyyy-MM-dd HH:mm:ss&amp;#125; %l %F %p %m%n
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行逆向工程代码&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;package com.msb.gennerator;
import org.mybatis.generator.api.MyBatisGenerator;
import org.mybatis.generator.config.Configuration;
import org.mybatis.generator.config.xml.ConfigurationParser;
import org.mybatis.generator.internal.DefaultShellCallback;
import java.io.File;
import java.util.ArrayList;
import java.util.List;
/**
 *
 */
public class GeneratorSqlmap &amp;#123;
    public void generator() throws Exception&amp;#123;
        List&amp;lt;String&amp;gt; warnings = new ArrayList&amp;lt;String&amp;gt;();
        boolean overwrite = true;
        File configFile = new File(&amp;quot;D:\\ideaProjects\\reverse\\target\\classes\\generatorConfig.xml&amp;quot;);
        ConfigurationParser cp = new ConfigurationParser(warnings);
        Configuration config = cp.parseConfiguration(configFile);
        DefaultShellCallback callback = new DefaultShellCallback(overwrite);
        MyBatisGenerator myBatisGenerator = new MyBatisGenerator(config,
                callback, warnings);
        myBatisGenerator.generate(null);
    &amp;#125;
    public static void main(String[] args) throws Exception &amp;#123;
        try &amp;#123;
            GeneratorSqlmap generatorSqlmap = new GeneratorSqlmap();
            generatorSqlmap.generator();
        &amp;#125; catch (Exception e) &amp;#123;
            e.printStackTrace();
        &amp;#125;
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;生成的实体类和Mapper接口和Mapper映射文件,包含了基本的CURD功能,哪里需要文件就放哪里&lt;/p&gt;
&lt;img data-src=&#34;/2022/10/07/ORM/Mybatis/image-20220617221208040-1665157666426.png&#34; class=&#34;&#34; title=&#34;image-20220617221208040&#34;&gt;

&lt;h1 id=&#34;12-main目录下配置文件打包问题&#34;&gt;&lt;a href=&#34;#12-main目录下配置文件打包问题&#34; class=&#34;headerlink&#34; title=&#34;12 main目录下配置文件打包问题&#34;&gt;&lt;/a&gt;12 main目录下配置文件打包问题&lt;/h1&gt;&lt;pre&gt;&lt;code class=&#34;xml&#34;&gt;&amp;lt;build&amp;gt;
    &amp;lt;!--告诉maven将项目源码中的xml文件也进行编译，并放到编译目录中--&amp;gt;
    &amp;lt;resources&amp;gt;
        &amp;lt;resource&amp;gt;
            &amp;lt;directory&amp;gt;src/main/java&amp;lt;/directory&amp;gt;
            &amp;lt;includes&amp;gt;
                &amp;lt;include&amp;gt;**/*.xml&amp;lt;/include&amp;gt;
            &amp;lt;/includes&amp;gt;
            &amp;lt;filtering&amp;gt;true&amp;lt;/filtering&amp;gt;
        &amp;lt;/resource&amp;gt;
        &amp;lt;resource&amp;gt;
            &amp;lt;directory&amp;gt;src/main/resources&amp;lt;/directory&amp;gt;
            &amp;lt;filtering&amp;gt;true&amp;lt;/filtering&amp;gt;
        &amp;lt;/resource&amp;gt;
    &amp;lt;/resources&amp;gt;
&amp;lt;/build&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;div id=&#34;gitalk-container&#34;&gt;&lt;/div&gt;
&lt;script src=&#34;https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js&#34;&gt;&lt;/script&gt;&lt;link rel=&#34;stylesheet&#34; href=&#34;https://unpkg.com/gitalk/dist/gitalk.css&#34;&gt;&lt;script src=&#34;https://unpkg.com/gitalk/dist/gitalk.min.js&#34;&gt;&lt;/script&gt;

		&lt;script&gt;
		var gitalkConfig = {&#34;clientID&#34;:&#34;eda74f740080fa01d0b5&#34;,&#34;clientSecret&#34;:&#34;c994dd2162a1dadaefbf078fcab49361438a7aca&#34;,&#34;repo&#34;:&#34;comments001&#34;,&#34;owner&#34;:&#34;onlymarryu&#34;,&#34;admin&#34;:[&#34;onlymarryu&#34;],&#34;distractionFreeMode&#34;:true,&#34;proxy&#34;:&#34;https://winter-rain-5b30.wudu-bk.workers.dev&#34;};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render(&#34;gitalk-container&#34;);
	    &lt;/script&gt;</content>
        <category term="框架" />
        <category term="ORM" />
        <updated>2022-10-06T16:00:00.000Z</updated>
    </entry>
</feed>
