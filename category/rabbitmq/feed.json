{
    "version": "https://jsonfeed.org/version/1",
    "title": "雾都博客 • All posts by \"rabbitmq\" category",
    "description": "记录美食每刻",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/2022/10/07/RabbitMQ/",
            "url": "http://example.com/2022/10/07/RabbitMQ/",
            "title": "RabbitMQ",
            "date_published": "2022-10-06T16:00:00.000Z",
            "content_html": "<h2 id=\"主要内容\"><a class=\"anchor\" href=\"#主要内容\">#</a> <strong>主要内容</strong></h2>\n<ol>\n<li>\n<p>AMQP 简介</p>\n</li>\n<li>\n<p>RabbitMQ 简介</p>\n</li>\n<li>\n<p>RabbitMQ 原理</p>\n</li>\n<li>\n<p>Erlang 安装</p>\n</li>\n<li>\n<p>安装 RabbitMQ</p>\n</li>\n<li>\n<p>RabbitMQ 账户管理</p>\n</li>\n<li>\n<p>交换器</p>\n</li>\n</ol>\n<h2 id=\"学习目标\"><a class=\"anchor\" href=\"#学习目标\">#</a> <strong>学习目标</strong></h2>\n<table>\n<thead>\n<tr>\n<th>知识点</th>\n<th>要求</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>AMQP 简介</td>\n<td>掌握</td>\n</tr>\n<tr>\n<td>RabbmitMQ 简介</td>\n<td>掌握</td>\n</tr>\n<tr>\n<td>RabbitMQ 原理</td>\n<td>掌握</td>\n</tr>\n<tr>\n<td>Erlang 安装</td>\n<td>掌握</td>\n</tr>\n<tr>\n<td>安装 RabbitMQ</td>\n<td>掌握</td>\n</tr>\n<tr>\n<td>RabbitMQ 账户管理</td>\n<td>掌握</td>\n</tr>\n<tr>\n<td>交换器</td>\n<td>掌握</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"一-amqp简介\"><a class=\"anchor\" href=\"#一-amqp简介\">#</a> 一、 <strong>AMQP 简介</strong></h3>\n<h4 id=\"1-amqp是什么\"><a class=\"anchor\" href=\"#1-amqp是什么\">#</a> 1 <strong>AMQP 是什么？</strong></h4>\n<p>​\tAMQP (Advanced Message Queuing Protocol, 高级消息队列协议) 是进程之间传递异步消息的网络协议。</p>\n<h3 id=\"2-amqp工作过程\"><a class=\"anchor\" href=\"#2-amqp工作过程\">#</a> 2 <strong>AMQP 工作过程</strong></h3>\n<p>​\t发布者 (Publisher) 发布消息 (Message), 经过交换机 (Exchange)，交换机根据路由规则将收到消息分发给交换机绑定的队列 (Queue)，最后 AMQP 代理会将消息投递给订阅了此队列的消费者，或者消费者按照需求自行获取。</p>\n<p><img data-src=\"/2022/10/07/RabbitMQ/RabbitMQ-01.jpg\" class=\"\"></p>\n<h3 id=\"3-队列\"><a class=\"anchor\" href=\"#3-队列\">#</a> 3 <strong>队列</strong></h3>\n<p>​\t队列是数据结构中概念。数据存储在一个队列中，数据是有顺序的，先进的先出，后进后出。其中一侧负责进数据，另一侧负责出数据。</p>\n<p>MQ（消息队列）很多功能都是基于此队列结构实现的！</p>\n<h3 id=\"二-rabbitmq简介\"><a class=\"anchor\" href=\"#二-rabbitmq简介\">#</a> 二、 <strong>RabbitMQ 简介</strong></h3>\n<h4 id=\"1-rabbitmq介绍\"><a class=\"anchor\" href=\"#1-rabbitmq介绍\">#</a> 1 <strong>RabbitMQ 介绍</strong></h4>\n<p>​\tRabbitMQ 是由 Erlang 语言编写的基于 AMQP 的消息中间件。而消息中间件作为分布式系统重要组件之一，可以解决应用耦合，异步消息，流量削峰等问题。</p>\n<h5 id=\"11-解决应用耦合\"><a class=\"anchor\" href=\"#11-解决应用耦合\">#</a> 1.1 <strong>解决应用耦合</strong></h5>\n<h6 id=\"111-不使用mq时\"><a class=\"anchor\" href=\"#111-不使用mq时\">#</a> 1.1.1 <strong>不使用 MQ 时</strong></h6>\n<p><img data-src=\"/2022/10/07/RabbitMQ/RabbitMQ-03.jpg\" class=\"\"></p>\n<h6 id=\"112-使用mq解决耦合\"><a class=\"anchor\" href=\"#112-使用mq解决耦合\">#</a> 1.1.2 <strong>使用 MQ 解决耦合</strong></h6>\n<p><img data-src=\"/2022/10/07/RabbitMQ/RabbitMQ-04.jpg\" class=\"\"></p>\n<h4 id=\"2-rabbitmq适用场景\"><a class=\"anchor\" href=\"#2-rabbitmq适用场景\">#</a> 2 <strong>RabbitMQ 适用场景</strong></h4>\n<p>​\t排队算法：使用消息队列特性</p>\n<p>​\t秒杀活动：使用消息队列特性</p>\n<p>​\t消息分发：使用消息异步特性</p>\n<p>​\t异步处理：使用消息异步特性</p>\n<p>​\t数据同步：使用消息异步特性</p>\n<p>​\t处理耗时任务：使用消息异步特性</p>\n<p>​\t流量销峰</p>\n<h3 id=\"三-rabbitmq原理\"><a class=\"anchor\" href=\"#三-rabbitmq原理\">#</a> 三、 <strong>RabbitMQ 原理</strong></h3>\n<p><img data-src=\"/2022/10/07/RabbitMQ/RabbitMQ-05.jpg\" class=\"\"></p>\n<table>\n<thead>\n<tr>\n<th>1.Message</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>消息。消息是不具名的，它由消息头消息体组成。消息体是不透明的，而消息头则由一系列可选属性组成，这些属性包括：routing-key (路由键)、priority (相对于其他消息的优先权)、delivery-mode (指出消息可能持久性存储) 等。</td>\n</tr>\n<tr>\n<td><strong>2</strong>.<strong>Publisher</strong></td>\n</tr>\n<tr>\n<td>消息的生产者。也是一个向交换器发布消息的客户端应用程序。</td>\n</tr>\n<tr>\n<td><strong>3</strong>.<strong>Consumer</strong></td>\n</tr>\n<tr>\n<td>消息的消费者。表示一个从消息队列中取得消息的客户端应用程序。</td>\n</tr>\n<tr>\n<td><strong>4.Exchange</strong></td>\n</tr>\n<tr>\n<td>交换器。用来接收生产者发送的消息并将这些消息路由给服务器中的队列。三种常用的交换器类型 1. direct (发布与订阅 完全匹配) 2. fanout (广播) 3. topic (主题，规则匹配)</td>\n</tr>\n<tr>\n<td><strong>5.Binding</strong></td>\n</tr>\n<tr>\n<td>绑定。用于消息队列和交换器之间的关联。一个绑定就是基于路由键将交换器和消息队列连接起来的路由规则，所以可以将交换器理解成一个由绑定构成的路由表。</td>\n</tr>\n<tr>\n<td><strong>6.Queue</strong></td>\n</tr>\n<tr>\n<td>消息队列。用来保存消息直到发送给消费者。它是消息的容器，也是消息的终点。一个消息可投入一个或多个队列。消息一直在队列里面，等待消费者链接到这个队列将其取走。</td>\n</tr>\n<tr>\n<td><strong>7.Routing-key</strong></td>\n</tr>\n<tr>\n<td>路由键。RabbitMQ 决定消息该投递到哪个队列的规则。（也可以理解为队列的名称，路由键是 key，队列是 value）队列通过路由键绑定到交换器。消息发送到 MQ 服务器时，消息将拥有一个路由键，即便是空的，RabbitMQ 也会将其和绑定使用的路由键进行匹配。如果相匹配，消息将会投递到该队列。如果不匹配，消息将会进入黑洞。</td>\n</tr>\n<tr>\n<td><strong>8.Connection</strong></td>\n</tr>\n<tr>\n<td>链接。指 rabbit 服务器和服务建立的 TCP 链接。</td>\n</tr>\n<tr>\n<td><strong>9.Channel</strong></td>\n</tr>\n<tr>\n<td>信道。1，Channel 中文叫做信道，是 TCP 里面的虚拟链接。例如：电缆相当于 TCP，信道是一个独立光纤束，一条 TCP 连接上创建多条信道是没有问题的。2，TCP 一旦打开，就会创建 AMQP 信道。3，无论是发布消息、接收消息、订阅队列，这些动作都是通过信道完成的。</td>\n</tr>\n<tr>\n<td><strong>10.Virtual Host</strong></td>\n</tr>\n<tr>\n<td>虚拟主机。表示一批交换器，消息队列和相关对象。虚拟主机是共享相同的身份认证和加密环境的独立服务器域。每个 vhost 本质上就是一个 mini 版的 RabbitMQ 服务器，拥有自己的队列、交换器、绑定和权限机制。vhost 是 AMQP 概念的基础，必须在链接时指定，RabbitMQ 默认的 vhost 是 **/**</td>\n</tr>\n<tr>\n<td><strong>11.Borker</strong></td>\n</tr>\n<tr>\n<td>表示消息队列服务器实体。</td>\n</tr>\n<tr>\n<td><strong>12. 交换器和队列的关系</strong></td>\n</tr>\n<tr>\n<td>交换器是通过路由键和队列绑定在一起的，如果消息拥有的路由键跟队列和交换器的路由键匹配，那么消息就会被路由到该绑定的队列中。     也就是说，消息到队列的过程中，消息首先会经过交换器，接下来交换器在通过路由键匹配分发消息到具体的队列中。     路由键可以理解为匹配的规则。</td>\n</tr>\n<tr>\n<td><strong>13.RabbitMQ 为什么需要信道？为什么不是 TCP 直接通信？</strong></td>\n</tr>\n<tr>\n<td>1. TCP 的创建和销毁开销特别大。创建需要 3 次握手，销毁需要 4 次分手。2. 如果不用信道，那应用程序就会以 TCP 链接 Rabbit，高峰时每秒成千上万条链接会造成资源巨大的浪费，而且操作系统每秒处理 TCP 链接数也是有限制的，必定造成性能瓶颈。3. 信道的原理是一条线程一条通道，多条线程多条通道同用一条 TCP 链接。一条 TCP 链接可以容纳无限的信道，即使每秒成千上万的请求也不会成为性能的瓶颈。</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"四-erlang安装\"><a class=\"anchor\" href=\"#四-erlang安装\">#</a> 四、 <strong>Erlang 安装</strong></h3>\n<p>​\tRabbitMQ 是使用 Erlang 语言编写的，所以需要先配置 Erlang</p>\n<h4 id=\"1-修改主机名\"><a class=\"anchor\" href=\"#1-修改主机名\">#</a> 1 <strong>修改主机名</strong></h4>\n<p>​\tRabbitMQ 是通过主机名进行访问的，必须指定能访问的主机名。</p>\n<pre><code>  vim /etc/sysconfig/network\n</code></pre>\n<p><img data-src=\"/2022/10/07/RabbitMQ/RabbitMQ-06.jpg\" class=\"\"></p>\n<pre><code>  vim /etc/hosts\n</code></pre>\n<p>​\t新添加了一行，前面为服务器 ip，空格后面添加计算机主机名</p>\n<p><img data-src=\"/2022/10/07/RabbitMQ/RabbitMQ-07.jpg\" class=\"\"></p>\n<h4 id=\"2-安装依赖\"><a class=\"anchor\" href=\"#2-安装依赖\">#</a> 2 <strong>安装依赖</strong></h4>\n<pre><code>  yum -y install make gcc gcc-c++ kernel-devel m4 ncurses-devel openssl-devel unixODBC unixODBC-devel\n</code></pre>\n<h4 id=\"3-上传并解压\"><a class=\"anchor\" href=\"#3-上传并解压\">#</a> 3 <strong>上传并解压</strong></h4>\n<p>​\t上传 otp_src_22.0.tar.gz 到 /usr/local/tmp 目录中，进入目录并解压。</p>\n<pre><code>解压时注意，此压缩包不具有gzip属性，解压参数没有z，只有xf\n</code></pre>\n<pre><code>  cd /usr/local/tmp\n  tar xf otp_src_22.0.tar.gz -C /usr/local/tmp\n</code></pre>\n<h4 id=\"4-配置参数\"><a class=\"anchor\" href=\"#4-配置参数\">#</a> 4 <strong>配置参数</strong></h4>\n<p>​\t先新建 /usr/local/erlang 文件夹，作为安装文件夹</p>\n<pre><code>  mkdir -p /usr/local/erlang\n</code></pre>\n<p>​\t 进入文件夹</p>\n<pre><code>  cd otp_src_22.0\n</code></pre>\n<p>​\t 配置参数</p>\n<pre><code>  ./configure --prefix=/usr/local/erlang --with-ssl --enable-threads --enable-smp-support --enable-kernel-poll --enable-hipe --without-javac\n</code></pre>\n<h4 id=\"5-编译并安装\"><a class=\"anchor\" href=\"#5-编译并安装\">#</a> 5 <strong>编译并安装</strong></h4>\n<p>​\t编译</p>\n<pre><code>  make\n</code></pre>\n<p>​\t 安装</p>\n<pre><code>  make install\n</code></pre>\n<h4 id=\"6-修改环境变量\"><a class=\"anchor\" href=\"#6-修改环境变量\">#</a> 6 <strong>修改环境变量</strong></h4>\n<p>​\t修改 /etc/profile 文件</p>\n<pre><code> vim /etc/profile\n</code></pre>\n<p>​\t 在文件中添加下面代码</p>\n<pre><code>export PATH=$PATH:/usr/local/erlang/bin\n</code></pre>\n<p>​\t运行文件，让修改内容生效</p>\n<pre><code>  source /etc/profile\n</code></pre>\n<h4 id=\"7-查看配置是否成功\"><a class=\"anchor\" href=\"#7-查看配置是否成功\">#</a> 7 <strong>查看配置是否成功</strong></h4>\n<pre><code>  erl -version\n</code></pre>\n<p><img data-src=\"/2022/10/07/RabbitMQ/RabbitMQ-08.jpg\" class=\"\"></p>\n<h3 id=\"五-安装rabbitmq\"><a class=\"anchor\" href=\"#五-安装rabbitmq\">#</a> 五、 <strong>安装 RabbitMQ</strong></h3>\n<h4 id=\"1-上传并解压\"><a class=\"anchor\" href=\"#1-上传并解压\">#</a> 1 <strong>上传并解压</strong></h4>\n<p>​\t上传 rabbitmq-server-generic-unix-3.7.18.tar.xz 到 /usr/loca/tmp 中</p>\n<pre><code>  cd /usr/local/tmp\n  tar xf rabbitmq-server-generic-unix-3.7.18.tar.xz\n</code></pre>\n<h4 id=\"2-复制到local下\"><a class=\"anchor\" href=\"#2-复制到local下\">#</a> 2 <strong>复制到 local 下</strong></h4>\n<p>​\t复制解压文件到 /usr/local 下，命名为 rabbitmq</p>\n<pre><code>  cp -r rabbitmq_server-3.7.18 /usr/local/rabbitmq\n</code></pre>\n<h4 id=\"3-配置环境变量\"><a class=\"anchor\" href=\"#3-配置环境变量\">#</a> 3 <strong>配置环境变量</strong></h4>\n<pre><code>  vim /etc/profile\n</code></pre>\n<p>​\t在文件中添加</p>\n<pre><code>export PATH=$PATH:/usr/local/rabbitmq/sbin\n</code></pre>\n<p>​\t解析文件</p>\n<pre><code># source /etc/profile\n</code></pre>\n<h4 id=\"4-开启web管理插件\"><a class=\"anchor\" href=\"#4-开启web管理插件\">#</a> 4 <strong>开启 web 管理插件</strong></h4>\n<p>​\t进入 rabbitmq/sbin 目录</p>\n<pre><code># cd /usr/local/rabbitmq/sbin\n</code></pre>\n<pre><code>查看插件列表\n</code></pre>\n<pre><code># ./rabbitmq-plugins list\n</code></pre>\n<pre><code>生效管理插件\n</code></pre>\n<pre><code># ./rabbitmq-plugins enable rabbitmq_management\n</code></pre>\n<h4 id=\"5-后台运行\"><a class=\"anchor\" href=\"#5-后台运行\">#</a> 5 <strong>后台运行</strong></h4>\n<p>​\t启动 rabbitmq。</p>\n<pre><code># ./rabbitmq-server -detached\n</code></pre>\n<p>​\t停止命令，如果无法停止，使用 kill -9 进程号进行关闭</p>\n<pre><code># ./rabbitmqctl stop_app\n</code></pre>\n<h4 id=\"6-查看web管理界面\"><a class=\"anchor\" href=\"#6-查看web管理界面\">#</a> 6 <strong>查看 web 管理界面</strong></h4>\n<p>​\t默认可以在安装 rabbitmq 的电脑上通过用户名：guest 密码 guest 进行访问 web 管理界面</p>\n<p>​\t端口号：15672（放行端口，或关闭防火墙）</p>\n<p>​\t在虚拟机浏览器中输入：</p>\n<p>​\t<span class=\"exturl\" data-url=\"aHR0cDovL2xvY2FsaG9zdDoxNTY3Mg==\">http://localhost:15672</span></p>\n<h3 id=\"六-rabbitmq账户管理\"><a class=\"anchor\" href=\"#六-rabbitmq账户管理\">#</a> 六、 <strong>RabbitMq 账户管理</strong></h3>\n<h4 id=\"1-创建账户\"><a class=\"anchor\" href=\"#1-创建账户\">#</a> 1 <strong>创建账户</strong></h4>\n<p>​\t语法：./rabbitmqctl add_user username password</p>\n<pre><code># cd /usr/local/rabbitmq/sbin\n# ./rabbitmqctl add_user mashibing mashibing\n</code></pre>\n<h4 id=\"2-给用户授予管理员角色\"><a class=\"anchor\" href=\"#2-给用户授予管理员角色\">#</a> 2 <strong>给用户授予管理员角色</strong></h4>\n<p>​\t其中 smallming 为新建用户的用户名</p>\n<pre><code># ./rabbitmqctl set_user_tags mashibing administrator\n</code></pre>\n<h4 id=\"3-给用户授权\"><a class=\"anchor\" href=\"#3-给用户授权\">#</a> 3 <strong>给用户授权</strong></h4>\n<p>​\t“/” 表示虚拟机</p>\n<p>​\tmashibing 表示用户名</p>\n<p>​\t&quot;.<em>&quot; &quot;.</em>&quot;&quot;.*&quot; 表示完整权限</p>\n<pre><code># ./rabbitmqctl set_permissions -p &quot;/&quot; mashibing &quot;.*&quot; &quot;.*&quot; &quot;.*&quot;\n</code></pre>\n<h4 id=\"4-登录\"><a class=\"anchor\" href=\"#4-登录\">#</a> 4 <strong>登录</strong></h4>\n<p>​\t使用新建账户和密码在 windows 中访问 rabbitmq 并登录</p>\n<p>​\t在浏览器地址栏输入：</p>\n<p>​\t<span class=\"exturl\" data-url=\"aHR0cDovL2lwOjE1NjcyLw==\">http://ip:15672/</span></p>\n<pre><code>用户名：mashibing\n</code></pre>\n<p>​\t密码：mashibing</p>\n<h3 id=\"七-交换器交换机\"><a class=\"anchor\" href=\"#七-交换器交换机\">#</a> 七、 <strong>交换器（交换机）</strong></h3>\n<p>​\t交换器负责接收客户端传递过来的消息，并转发到对应的队列中。在 RabbitMQ 中支持四种交换器</p>\n<p>​\t1.Direct Exchange：直连交换器（默认）</p>\n<p>​\t2.Fanout Exchange：扇形交换器</p>\n<p>​\t3.Topic Exchange：主题交换器</p>\n<p>​\t4.Header Exchange：首部交换器。</p>\n<p>​\t在 RabbitMq 的 Web 管理界面中 Exchanges 选项卡就可以看见这四个交换器。</p>\n<p><img data-src=\"/2022/10/07/RabbitMQ/RabbitMQ-09.jpg\" class=\"\"></p>\n<h4 id=\"1-direct交换器\"><a class=\"anchor\" href=\"#1-direct交换器\">#</a> 1 <strong>direct 交换器</strong></h4>\n<p>​\tdirect 交换器是 RabbitMQ 默认交换器。默认会进行公平调度。所有接受者依次从消息队列中获取值。Publisher 给哪个队列发消息，就一定是给哪个队列发送消息。对交换器绑定的其他队列没有任何影响。</p>\n<p>​\t（代码演示）一个队列需要绑定多个消费者</p>\n<p>​\t需要使用注解 / API：</p>\n<p>​\torg.springframework.amqp.core.Queue: 队列</p>\n<p>​\tAmqpTemplate：操作 RabbitMQ 的接口。负责发送或接收消息</p>\n<p>​\t@RabbitListener (queues = &quot;&quot;) 注解某个方法为接收消息方法</p>\n<h4 id=\"11-代码实现\"><a class=\"anchor\" href=\"#11-代码实现\">#</a> 1.1 <strong>代码实现</strong></h4>\n<h5 id=\"111-新建项目publisher\"><a class=\"anchor\" href=\"#111-新建项目publisher\">#</a> 1.1.1 <strong>新建项目 Publisher</strong></h5>\n<h6 id=\"1111-添加依赖\"><a class=\"anchor\" href=\"#1111-添加依赖\">#</a> 1.1.1.1 <strong>添加依赖</strong></h6>\n<pre><code>&lt;parent&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;\n    &lt;version&gt;2.2.2.RELEASE&lt;/version&gt;\n&lt;/parent&gt;\n\n&lt;dependencies&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;\n    &lt;/dependency&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;\n    &lt;/dependency&gt;\n&lt;/dependencies&gt;\n</code></pre>\n<h6 id=\"1112-编写配置文件\"><a class=\"anchor\" href=\"#1112-编写配置文件\">#</a> 1.1.1.2 <strong>编写配置文件</strong></h6>\n<p>​\t新建 application.yml.</p>\n<p>​\thost: 默认值 localhost</p>\n<p>​\tusername 默认值：guest</p>\n<p>​\tpassword 默认值：guest</p>\n<pre><code>spring:\n  rabbitmq:\n    host: 192.168.1.195\n    username: mashibing\n    password: mashibing\n</code></pre>\n<h6 id=\"1113-编写配置类\"><a class=\"anchor\" href=\"#1113-编写配置类\">#</a> 1.1.1.3 <strong>编写配置类</strong></h6>\n<p>新建 com.config.RabbitmqConfig</p>\n<p>​\t队列的创建只有没有这个队列的时候需要编写。以后没有这个 queue () 方法也可以。</p>\n<pre><code>@Configuration\npublic class RabbitmqConfig &#123;\n    @Bean\n    protected Queue queue()&#123;\n        Queue queue = new Queue(&quot;myqueue&quot;);\n        return queue;\n    &#125;\n&#125;\n</code></pre>\n<h6 id=\"1114-编写启动类\"><a class=\"anchor\" href=\"#1114-编写启动类\">#</a> 1.1.1.4 <strong>编写启动类</strong></h6>\n<p>略</p>\n<h6 id=\"1115-编写测试类\"><a class=\"anchor\" href=\"#1115-编写测试类\">#</a> 1.1.1.5 <strong>编写测试类</strong></h6>\n<p>SpringBoot 整合 Spring-AMQP 后包含内置对象 AmqpTemplate</p>\n<pre><code>@SpringBootTest(classes = PublisherApplication.class)\n@RunWith(SpringJUnit4ClassRunner.class)\npublic class MyTest &#123;\n    @Autowired\n    private AmqpTemplate amqpTemplate;\n\n    @Test\n    public void test()&#123;\n        amqpTemplate.convertAndSend(&quot;myqueue&quot;,&quot;这是内容1&quot;);\n        System.out.println(&quot;发送成功&quot;);\n    &#125;\n&#125;\n</code></pre>\n<h5 id=\"112-创建consumer\"><a class=\"anchor\" href=\"#112-创建consumer\">#</a> 1.1.2 <strong>创建 Consumer</strong></h5>\n<p>​\t新建项目 consumer</p>\n<h6 id=\"1121-添加依赖\"><a class=\"anchor\" href=\"#1121-添加依赖\">#</a> 1.1.2.1 <strong>添加依赖</strong></h6>\n<p>​\t和 Publisher 一样</p>\n<h6 id=\"1122-编写配置文件\"><a class=\"anchor\" href=\"#1122-编写配置文件\">#</a> 1.1.2.2 <strong>编写配置文件</strong></h6>\n<p>​\t和 Publisher 一样</p>\n<h6 id=\"1123-编写监听器方法\"><a class=\"anchor\" href=\"#1123-编写监听器方法\">#</a> 1.1.2.3 <strong>编写监听器方法</strong></h6>\n<p>​\t注意：</p>\n<p>​\t类上要有 @Componet，项目启动时此类生效。</p>\n<p>​\t@RabbitListener 监听指定队列。</p>\n<pre><code>@Component\npublic class DemoReceive &#123;\n\n    @RabbitListener(queues = &quot;myqueue&quot;)\n    public void demo(String msg)&#123;\n        System.out.println(&quot;获取到的消息1111：&quot;+msg);\n    &#125;\n\n    @RabbitListener(queues = &quot;myqueue&quot;)\n    public void demo2(String msg)&#123;\n        System.out.println(&quot;获取到的消息2222：&quot;+msg);\n    &#125;\n&#125;\n</code></pre>\n<h6 id=\"1124-新建启动类\"><a class=\"anchor\" href=\"#1124-新建启动类\">#</a> 1.1.2.4 <strong>新建启动类</strong></h6>\n<p>​\t略。启动后此项目一直处于运行状态。属于长连接。</p>\n<h4 id=\"2-fanout交换器\"><a class=\"anchor\" href=\"#2-fanout交换器\">#</a> 2 <strong>fanout 交换器</strong></h4>\n<p>​\t扇形交换器，实际上做的事情就是广播，fanout 会把消息发送给所有的绑定在当前交换器上的队列。且每个队列消息中第一个 Consumer 能收到消息。</p>\n<p>​\t（代码演示）一个交换器需要绑定多个队列</p>\n<p>​\t需要使用注解 / API：</p>\n<p>​\tFanoutExchange：fanout 交换器</p>\n<p>​\tBinding：绑定交换器和队列</p>\n<p>​\tBindingBuilder：Binding 的构建器</p>\n<p>​\tamq.fanout: 内置 fanout 交换器名称</p>\n<h4 id=\"21-代码\"><a class=\"anchor\" href=\"#21-代码\">#</a> 2.1 <strong>代码</strong></h4>\n<h5 id=\"211-publisher\"><a class=\"anchor\" href=\"#211-publisher\">#</a> 2.1.1 <strong>Publisher</strong></h5>\n<h6 id=\"2111-修改配置类\"><a class=\"anchor\" href=\"#2111-修改配置类\">#</a> 2.1.1.1 <strong>修改配置类</strong></h6>\n<pre><code>@Bean\nprotected Queue fanoutQuque1()&#123;\n    return new Queue(&quot;fanout1&quot;);\n&#125;\n\n@Bean\nprotected Queue fanoutQuque2()&#123;\n    return new Queue(&quot;fanout2&quot;);\n&#125;\n\n@Bean\nprotected FanoutExchange fanoutExchange()&#123;\n    return new FanoutExchange(&quot;amq.fanout&quot;);\n&#125;\n\n@Bean\nprotected Binding fanoutBinding(Queue fanoutQuque1,FanoutExchange fanoutExchange)&#123;\n    return BindingBuilder.bind(fanoutQuque1).to(fanoutExchange);\n&#125;\n\n@Bean\nprotected Binding fanoutBinding2(Queue fanoutQuque2,FanoutExchange fanoutExchange)&#123;\n    return BindingBuilder.bind(fanoutQuque2).to(fanoutExchange);\n&#125;\n</code></pre>\n<h5 id=\"212-编写发送方法\"><a class=\"anchor\" href=\"#212-编写发送方法\">#</a> 2.1.2 <strong>编写发送方法</strong> ****</h5>\n<p>​\t第二个参数 routingKey 对于 fanout 没有意义的</p>\n<pre><code>@Test\npublic void test2()&#123;\n    amqpTemplate.convertAndSend(&quot;amq.fanout&quot;,&quot;asdfadsf&quot;,&quot;fanout msg&quot;);\n    System.out.println(&quot;发送成功&quot;);\n&#125;\n</code></pre>\n<h5 id=\"213-consumer\"><a class=\"anchor\" href=\"#213-consumer\">#</a> 2.1.3 <strong>Consumer</strong></h5>\n<p>​\tConsumer 代码和 Direct 完全相同。一个队列给一个监听方法即可。</p>\n<h4 id=\"3-topic交换器\"><a class=\"anchor\" href=\"#3-topic交换器\">#</a> 3 <strong>topic 交换器</strong></h4>\n<p>​\t允许在路由键（RoutingKey）中出现匹配规则。</p>\n<p>​\t路由键的写法和包写法相同。com.msb.xxxx.xxx 格式。</p>\n<p>​\t在绑定时可以带有下面特殊符号，中间可以出现:</p>\n<p>​\t* : 代表一个单词（两个。之间内容）</p>\n<p>​\t# : 0 个或多个字符</p>\n<p>​\t接收方依然是公平调度，同一个队列中内容轮换获取值。</p>\n<p>​\t需要使用注解 / API：</p>\n<p>​\tTopicExchange：Topic 交换器</p>\n<p>​\tamq.topic: 内置 topic 交换器名称</p>\n<h4 id=\"31-代码\"><a class=\"anchor\" href=\"#31-代码\">#</a> 3.1 <strong>代码</strong></h4>\n<h5 id=\"311-publisher\"><a class=\"anchor\" href=\"#311-publisher\">#</a> 3.1.1 <strong>Publisher</strong></h5>\n<h6 id=\"3111-配置类\"><a class=\"anchor\" href=\"#3111-配置类\">#</a> 3.1.1.1 <strong>配置类。</strong></h6>\n<p>​\t之所以建立两个队列目的是为了演示使用 Topic 完成 Fanout 效果。</p>\n<pre><code>@Bean\nprotected Queue topicQueue() &#123;\n    return new Queue(&quot;topic1&quot;);\n&#125;\n\n@Bean\nprotected Queue topicQueue2() &#123;\n    return new Queue(&quot;topic2&quot;);\n&#125;\n\n@Bean\nprotected TopicExchange topicExchange() &#123;\n    return new TopicExchange(&quot;amq.topic&quot;);\n&#125;\n\n@Bean\nprotected Binding topicBinding(Queue topicQueue, TopicExchange topicExchange) &#123;\n    return BindingBuilder.bind(topicQueue).to(topicExchange).with(&quot;com.a&quot;);\n&#125;\n\n@Bean\nprotected Binding topicBinding2(Queue topicQueue2, TopicExchange topicExchange) &#123;\n    return BindingBuilder.bind(topicQueue2).to(topicExchange).with(&quot;com.#&quot;);\n&#125;\n</code></pre>\n<h6 id=\"3112-发送消息\"><a class=\"anchor\" href=\"#3112-发送消息\">#</a> 3.1.1.2 <strong>发送消息</strong></h6>\n<p>​\t第二个参数为路由键，匹配配置类中绑定时的路由规则。</p>\n<pre><code>@Test\npublic void test3()&#123;\n    amqpTemplate.convertAndSend(&quot;amq.topic&quot;,&quot;com.bjsxt.a.b&quot;,&quot;topic msg&quot;);\n    System.out.println(&quot;发送成功&quot;);\n&#125;\n</code></pre>\n<p>3.1.2 <strong>Consumer</strong></p>\n<p>​\tConsumer 代码与以前一样，注意队列名称 topic1,topic2 不要写路由键名称。(queues 取值)</p>\n<pre><code>@RabbitListener(queues = &quot;topic2&quot;)\npublic void demo10(String msg)&#123;\n    System.out.println(&quot;topic2-2:&quot;+msg);\n&#125;\n</code></pre>\n<h3 id=\"八-传递对象类型参数\"><a class=\"anchor\" href=\"#八-传递对象类型参数\">#</a> 八、 <strong>传递对象类型参数</strong></h3>\n<p>​\t如果消息是对象类型，此对象的类型必须进行序列化，且需要给定序列化值</p>\n<pre><code>public class People implements Serializable \n&#123;\n    public static final long serialVersionUID=1L;\n&#125;\n</code></pre>\n",
            "tags": [
                "分布式",
                "中间件",
                "RabbitMQ"
            ]
        }
    ]
}