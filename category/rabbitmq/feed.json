{
    "version": "https://jsonfeed.org/version/1",
    "title": "记录“美食”每刻 • All posts by \"rabbitmq\" category",
    "description": "记录“美食”每刻",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/2022/10/07/RabbitMQ/",
            "url": "http://example.com/2022/10/07/RabbitMQ/",
            "title": "RabbitMQ",
            "date_published": "2022-10-06T16:00:00.000Z",
            "content_html": "<h2 id=\"主要内容\"><a href=\"#主要内容\" class=\"headerlink\" title=\"主要内容\"></a><strong>主要内容</strong></h2><ol>\n<li><p>AMQP简介</p>\n</li>\n<li><p>RabbitMQ简介</p>\n</li>\n<li><p>RabbitMQ原理</p>\n</li>\n<li><p>Erlang安装</p>\n</li>\n<li><p>安装RabbitMQ</p>\n</li>\n<li><p>RabbitMQ账户管理</p>\n</li>\n<li><p>交换器</p>\n</li>\n</ol>\n<h2 id=\"学习目标\"><a href=\"#学习目标\" class=\"headerlink\" title=\"学习目标\"></a><strong>学习目标</strong></h2><table>\n<thead>\n<tr>\n<th>知识点</th>\n<th>要求</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>AMQP简介</td>\n<td>掌握</td>\n</tr>\n<tr>\n<td>RabbmitMQ简介</td>\n<td>掌握</td>\n</tr>\n<tr>\n<td>RabbitMQ原理</td>\n<td>掌握</td>\n</tr>\n<tr>\n<td>Erlang安装</td>\n<td>掌握</td>\n</tr>\n<tr>\n<td>安装RabbitMQ</td>\n<td>掌握</td>\n</tr>\n<tr>\n<td>RabbitMQ账户管理</td>\n<td>掌握</td>\n</tr>\n<tr>\n<td>交换器</td>\n<td>掌握</td>\n</tr>\n</tbody></table>\n<h3 id=\"一、-AMQP简介\"><a href=\"#一、-AMQP简介\" class=\"headerlink\" title=\"一、 AMQP简介\"></a>一、 <strong>AMQP简介</strong></h3><h4 id=\"1-AMQP是什么\"><a href=\"#1-AMQP是什么\" class=\"headerlink\" title=\"1 AMQP是什么?\"></a>1 <strong>AMQP是什么?</strong></h4><p>​\tAMQP(Advanced Message Queuing Protocol,高级消息队列协议)是进程之间传递异步消息的网络协议。</p>\n<h3 id=\"2-AMQP工作过程\"><a href=\"#2-AMQP工作过程\" class=\"headerlink\" title=\"2 AMQP工作过程\"></a>2 <strong>AMQP工作过程</strong></h3><p>​\t发布者(Publisher)发布消息(Message),经过交换机(Exchange)，交换机根据路由规则将收到消息分发给交换机绑定的队列(Queue)，最后AMQP代理会将消息投递给订阅了此队列的消费者，或者消费者按照需求自行获取。</p>\n<img data-src=\"/2022/10/07/RabbitMQ/RabbitMQ-01.jpg\" class=\"\">\n\n\n<h3 id=\"3-队列\"><a href=\"#3-队列\" class=\"headerlink\" title=\"3 队列\"></a>3 <strong>队列</strong></h3><p>​\t队列是数据结构中概念。数据存储在一个队列中，数据是有顺序的，先进的先出，后进后出。其中一侧负责进数据，另一侧负责出数据。</p>\n<p>MQ（消息队列）很多功能都是基于此队列结构实现的!</p>\n<h3 id=\"二、-RabbitMQ简介\"><a href=\"#二、-RabbitMQ简介\" class=\"headerlink\" title=\"二、 RabbitMQ简介\"></a>二、 <strong>RabbitMQ简介</strong></h3><h4 id=\"1-RabbitMQ介绍\"><a href=\"#1-RabbitMQ介绍\" class=\"headerlink\" title=\"1 RabbitMQ介绍\"></a>1 <strong>RabbitMQ介绍</strong></h4><p>​\tRabbitMQ是由Erlang语言编写的基于AMQP的消息中间件。而消息中间件作为分布式系统重要组件之一，可以解决应用耦合，异步消息，流量削峰等问题。</p>\n<h5 id=\"1-1-解决应用耦合\"><a href=\"#1-1-解决应用耦合\" class=\"headerlink\" title=\"1.1 解决应用耦合\"></a>1.1 <strong>解决应用耦合</strong></h5><h6 id=\"1-1-1-不使用MQ时\"><a href=\"#1-1-1-不使用MQ时\" class=\"headerlink\" title=\"1.1.1 不使用MQ时\"></a>1.1.1 <strong>不使用MQ时</strong></h6><img data-src=\"/2022/10/07/RabbitMQ/RabbitMQ-03.jpg\" class=\"\">\n\n\n<h6 id=\"1-1-2-使用MQ解决耦合\"><a href=\"#1-1-2-使用MQ解决耦合\" class=\"headerlink\" title=\"1.1.2 使用MQ解决耦合\"></a>1.1.2 <strong>使用MQ解决耦合</strong></h6><img data-src=\"/2022/10/07/RabbitMQ/RabbitMQ-04.jpg\" class=\"\">\n\n\n<h4 id=\"2-RabbitMQ适用场景\"><a href=\"#2-RabbitMQ适用场景\" class=\"headerlink\" title=\"2 RabbitMQ适用场景\"></a>2 <strong>RabbitMQ适用场景</strong></h4><p>​\t排队算法 : 使用消息队列特性</p>\n<p>​\t秒杀活动 : 使用消息队列特性</p>\n<p>​\t消息分发 : 使用消息异步特性</p>\n<p>​\t异步处理 : 使用消息异步特性</p>\n<p>​\t数据同步 : 使用消息异步特性</p>\n<p>​\t处理耗时任务 : 使用消息异步特性</p>\n<p>​\t流量销峰</p>\n<h3 id=\"三、-RabbitMQ原理\"><a href=\"#三、-RabbitMQ原理\" class=\"headerlink\" title=\"三、 RabbitMQ原理\"></a>三、 <strong>RabbitMQ原理</strong></h3><img data-src=\"/2022/10/07/RabbitMQ/RabbitMQ-05.jpg\" class=\"\">\n\n\n<table>\n<thead>\n<tr>\n<th>1.Message</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>消息。消息是不具名的，它由消息头消息体组成。消息体是不透明的，而消息头则由一系列可选属性组成，这些属性包括：routing-key(路由键)、priority(相对于其他消息的优先权)、delivery-mode(指出消息可能持久性存储)等。</td>\n</tr>\n<tr>\n<td><strong>2</strong>.<strong>Publisher</strong></td>\n</tr>\n<tr>\n<td>消息的生产者。也是一个向交换器发布消息的客户端应用程序。</td>\n</tr>\n<tr>\n<td><strong>3</strong>.<strong>Consumer</strong></td>\n</tr>\n<tr>\n<td>消息的消费者。表示一个从消息队列中取得消息的客户端应用程序。</td>\n</tr>\n<tr>\n<td><strong>4.Exchange</strong></td>\n</tr>\n<tr>\n<td>交换器。用来接收生产者发送的消息并将这些消息路由给服务器中的队列。三种常用的交换器类型1. direct(发布与订阅 完全匹配)2. fanout(广播)3. topic(主题，规则匹配)</td>\n</tr>\n<tr>\n<td><strong>5.Binding</strong></td>\n</tr>\n<tr>\n<td>绑定。用于消息队列和交换器之间的关联。一个绑定就是基于路由键将交换器和消息队列连接起来的路由规则，所以可以将交换器理解成一个由绑定构成的路由表。</td>\n</tr>\n<tr>\n<td><strong>6.Queue</strong></td>\n</tr>\n<tr>\n<td>消息队列。用来保存消息直到发送给消费者。它是消息的容器，也是消息的终点。一个消息可投入一个或多个队列。消息一直在队列里面，等待消费者链接到这个队列将其取走。</td>\n</tr>\n<tr>\n<td><strong>7.Routing-key</strong></td>\n</tr>\n<tr>\n<td>路由键。RabbitMQ决定消息该投递到哪个队列的规则。（也可以理解为队列的名称，路由键是key，队列是value）队列通过路由键绑定到交换器。消息发送到MQ服务器时，消息将拥有一个路由键，即便是空的，RabbitMQ也会将其和绑定使用的路由键进行匹配。如果相匹配，消息将会投递到该队列。如果不匹配，消息将会进入黑洞。</td>\n</tr>\n<tr>\n<td><strong>8.Connection</strong></td>\n</tr>\n<tr>\n<td>链接。指rabbit服务器和服务建立的TCP链接。</td>\n</tr>\n<tr>\n<td><strong>9.Channel</strong></td>\n</tr>\n<tr>\n<td>信道。1，Channel中文叫做信道，是TCP里面的虚拟链接。例如：电缆相当于TCP，信道是一个独立光纤束，一条TCP连接上创建多条信道是没有问题的。2，TCP一旦打开，就会创建AMQP信道。3，无论是发布消息、接收消息、订阅队列，这些动作都是通过信道完成的。</td>\n</tr>\n<tr>\n<td><strong>10.Virtual Host</strong></td>\n</tr>\n<tr>\n<td>虚拟主机。表示一批交换器，消息队列和相关对象。虚拟主机是共享相同的身份认证和加密环境的独立服务器域。每个vhost本质上就是一个mini版的RabbitMQ服务器，拥有自己的队列、交换器、绑定和权限机制。vhost是AMQP概念的基础，必须在链接时指定，RabbitMQ默认的vhost是**&#x2F;**</td>\n</tr>\n<tr>\n<td><strong>11.Borker</strong></td>\n</tr>\n<tr>\n<td>表示消息队列服务器实体。</td>\n</tr>\n<tr>\n<td><strong>12.交换器和队列的关系</strong></td>\n</tr>\n<tr>\n<td>交换器是通过路由键和队列绑定在一起的，如果消息拥有的路由键跟队列和交换器的路由键匹配，那么消息就会被路由到该绑定的队列中。     也就是说，消息到队列的过程中，消息首先会经过交换器，接下来交换器在通过路由键匹配分发消息到具体的队列中。     路由键可以理解为匹配的规则。</td>\n</tr>\n<tr>\n<td><strong>13.RabbitMQ为什么需要信道？为什么不是TCP直接通信？</strong></td>\n</tr>\n<tr>\n<td>1. TCP的创建和销毁开销特别大。创建需要3次握手，销毁需要4次分手。2. 如果不用信道，那应用程序就会以TCP链接Rabbit，高峰时每秒成千上万条链接会造成资源巨大的浪费，而且操作系统每秒处理TCP链接数也是有限制的，必定造成性能瓶颈。3. 信道的原理是一条线程一条通道，多条线程多条通道同用一条TCP链接。一条TCP链接可以容纳无限的信道，即使每秒成千上万的请求也不会成为性能的瓶颈。</td>\n</tr>\n</tbody></table>\n<h3 id=\"四、-Erlang安装\"><a href=\"#四、-Erlang安装\" class=\"headerlink\" title=\"四、 Erlang安装\"></a>四、 <strong>Erlang安装</strong></h3><p>​\tRabbitMQ是使用Erlang语言编写的，所以需要先配置Erlang</p>\n<h4 id=\"1-修改主机名\"><a href=\"#1-修改主机名\" class=\"headerlink\" title=\"1 修改主机名\"></a>1 <strong>修改主机名</strong></h4><p>​\tRabbitMQ是通过主机名进行访问的，必须指定能访问的主机名。</p>\n<pre><code>  vim /etc/sysconfig/network\n</code></pre>\n<img data-src=\"/2022/10/07/RabbitMQ/RabbitMQ-06.jpg\" class=\"\">\n\n\n<pre><code>  vim /etc/hosts\n</code></pre>\n<p>​\t新添加了一行，前面为服务器ip，空格后面添加计算机主机名</p>\n<img data-src=\"/2022/10/07/RabbitMQ/RabbitMQ-07.jpg\" class=\"\">\n\n\n<h4 id=\"2-安装依赖\"><a href=\"#2-安装依赖\" class=\"headerlink\" title=\"2 安装依赖\"></a>2 <strong>安装依赖</strong></h4><pre><code>  yum -y install make gcc gcc-c++ kernel-devel m4 ncurses-devel openssl-devel unixODBC unixODBC-devel\n</code></pre>\n<h4 id=\"3-上传并解压\"><a href=\"#3-上传并解压\" class=\"headerlink\" title=\"3 上传并解压\"></a>3 <strong>上传并解压</strong></h4><p>​\t上传otp_src_22.0.tar.gz到&#x2F;usr&#x2F;local&#x2F;tmp目录中，进入目录并解压。</p>\n<pre><code> 解压时注意，此压缩包不具有gzip属性，解压参数没有z，只有xf\n</code></pre>\n<pre><code>  cd /usr/local/tmp\n  tar xf otp_src_22.0.tar.gz -C /usr/local/tmp\n</code></pre>\n<h4 id=\"4-配置参数\"><a href=\"#4-配置参数\" class=\"headerlink\" title=\"4 配置参数\"></a>4 <strong>配置参数</strong></h4><p>​\t先新建&#x2F;usr&#x2F;local&#x2F;erlang文件夹，作为安装文件夹</p>\n<pre><code>  mkdir -p /usr/local/erlang\n</code></pre>\n<p>​\t 进入文件夹</p>\n<pre><code>  cd otp_src_22.0\n</code></pre>\n<p>​\t 配置参数</p>\n<pre><code>  ./configure --prefix=/usr/local/erlang --with-ssl --enable-threads --enable-smp-support --enable-kernel-poll --enable-hipe --without-javac\n</code></pre>\n<h4 id=\"5-编译并安装\"><a href=\"#5-编译并安装\" class=\"headerlink\" title=\"5 编译并安装\"></a>5 <strong>编译并安装</strong></h4><p>​\t编译 </p>\n<pre><code>  make\n</code></pre>\n<p>​\t 安装</p>\n<pre><code>  make install\n</code></pre>\n<h4 id=\"6-修改环境变量\"><a href=\"#6-修改环境变量\" class=\"headerlink\" title=\"6 修改环境变量\"></a>6 <strong>修改环境变量</strong></h4><p>​\t修改&#x2F;etc&#x2F;profile文件</p>\n<pre><code> vim /etc/profile\n</code></pre>\n<p>​\t 在文件中添加下面代码 </p>\n<pre><code>export PATH=$PATH:/usr/local/erlang/bin\n</code></pre>\n<p>​\t运行文件，让修改内容生效</p>\n<pre><code>  source /etc/profile\n</code></pre>\n<h4 id=\"7-查看配置是否成功\"><a href=\"#7-查看配置是否成功\" class=\"headerlink\" title=\"7 查看配置是否成功\"></a>7 <strong>查看配置是否成功</strong></h4><pre><code>  erl -version\n</code></pre>\n<img data-src=\"/2022/10/07/RabbitMQ/RabbitMQ-08.jpg\" class=\"\">\n\n\n<h3 id=\"五、-安装RabbitMQ\"><a href=\"#五、-安装RabbitMQ\" class=\"headerlink\" title=\"五、 安装RabbitMQ\"></a>五、 <strong>安装RabbitMQ</strong></h3><h4 id=\"1-上传并解压\"><a href=\"#1-上传并解压\" class=\"headerlink\" title=\"1 上传并解压\"></a>1 <strong>上传并解压</strong></h4><p>​\t上传rabbitmq-server-generic-unix-3.7.18.tar.xz到&#x2F;usr&#x2F;loca&#x2F;tmp中</p>\n<pre><code>  cd /usr/local/tmp\n  tar xf rabbitmq-server-generic-unix-3.7.18.tar.xz\n</code></pre>\n<h4 id=\"2-复制到local下\"><a href=\"#2-复制到local下\" class=\"headerlink\" title=\"2 复制到local下\"></a>2 <strong>复制到local下</strong></h4><p>​\t复制解压文件到&#x2F;usr&#x2F;local下，命名为rabbitmq</p>\n<pre><code>  cp -r rabbitmq_server-3.7.18 /usr/local/rabbitmq\n</code></pre>\n<h4 id=\"3-配置环境变量\"><a href=\"#3-配置环境变量\" class=\"headerlink\" title=\"3 配置环境变量\"></a>3 <strong>配置环境变量</strong></h4><pre><code>  vim /etc/profile\n</code></pre>\n<p>​\t在文件中添加 </p>\n<pre><code>export PATH=$PATH:/usr/local/rabbitmq/sbin\n</code></pre>\n<p>​\t解析文件</p>\n<pre><code># source /etc/profile\n</code></pre>\n<h4 id=\"4-开启web管理插件\"><a href=\"#4-开启web管理插件\" class=\"headerlink\" title=\"4 开启web管理插件\"></a>4 <strong>开启web管理插件</strong></h4><p>​\t进入rabbitmq&#x2F;sbin目录</p>\n<pre><code># cd /usr/local/rabbitmq/sbin\n</code></pre>\n<pre><code> 查看插件列表\n</code></pre>\n<pre><code># ./rabbitmq-plugins list\n</code></pre>\n<pre><code> 生效管理插件\n</code></pre>\n<pre><code># ./rabbitmq-plugins enable rabbitmq_management\n</code></pre>\n<h4 id=\"5-后台运行\"><a href=\"#5-后台运行\" class=\"headerlink\" title=\"5 后台运行\"></a>5 <strong>后台运行</strong></h4><p>​\t启动rabbitmq。</p>\n<pre><code># ./rabbitmq-server -detached\n</code></pre>\n<p>​\t停止命令，如果无法停止，使用kill -9 进程号进行关闭</p>\n<pre><code># ./rabbitmqctl stop_app\n</code></pre>\n<h4 id=\"6-查看web管理界面\"><a href=\"#6-查看web管理界面\" class=\"headerlink\" title=\"6 查看web管理界面\"></a>6 <strong>查看web管理界面</strong></h4><p>​\t默认可以在安装rabbitmq的电脑上通过用户名：guest密码guest进行访问web管理界面</p>\n<p>​\t端口号：15672（放行端口，或关闭防火墙）</p>\n<p>​\t在虚拟机浏览器中输入：</p>\n<p>​\t<span class=\"exturl\" data-url=\"aHR0cDovL2xvY2FsaG9zdDoxNTY3Mi8=\">http://localhost:15672</span></p>\n<h3 id=\"六、-RabbitMq账户管理\"><a href=\"#六、-RabbitMq账户管理\" class=\"headerlink\" title=\"六、 RabbitMq账户管理\"></a>六、 <strong>RabbitMq账户管理</strong></h3><h4 id=\"1-创建账户\"><a href=\"#1-创建账户\" class=\"headerlink\" title=\"1 创建账户\"></a>1 <strong>创建账户</strong></h4><p>​\t语法：.&#x2F;rabbitmqctl add_user username password</p>\n<pre><code># cd /usr/local/rabbitmq/sbin\n# ./rabbitmqctl add_user mashibing mashibing\n</code></pre>\n<h4 id=\"2-给用户授予管理员角色\"><a href=\"#2-给用户授予管理员角色\" class=\"headerlink\" title=\"2 给用户授予管理员角色\"></a>2 <strong>给用户授予管理员角色</strong></h4><p>​\t其中smallming为新建用户的用户名</p>\n<pre><code># ./rabbitmqctl set_user_tags mashibing administrator\n</code></pre>\n<h4 id=\"3-给用户授权\"><a href=\"#3-给用户授权\" class=\"headerlink\" title=\"3 给用户授权\"></a>3 <strong>给用户授权</strong></h4><p>​\t“&#x2F;” 表示虚拟机</p>\n<p>​\tmashibing 表示用户名</p>\n<p>​\t“.<em>“ “.</em>“ “.*” 表示完整权限</p>\n<pre><code># ./rabbitmqctl set_permissions -p &quot;/&quot; mashibing &quot;.*&quot; &quot;.*&quot; &quot;.*&quot;\n</code></pre>\n<h4 id=\"4-登录\"><a href=\"#4-登录\" class=\"headerlink\" title=\"4 登录\"></a>4 <strong>登录</strong></h4><p>​\t使用新建账户和密码在windows中访问rabbitmq并登录 </p>\n<p>​\t在浏览器地址栏输入：</p>\n<p>​\t<span class=\"exturl\" data-url=\"aHR0cDovL2lwOjE1NjcyLw==\">http://ip:15672/</span></p>\n<pre><code> 用户名：mashibing\n</code></pre>\n<p>​\t密码：mashibing</p>\n<h3 id=\"七、-交换器（交换机）\"><a href=\"#七、-交换器（交换机）\" class=\"headerlink\" title=\"七、 交换器（交换机）\"></a>七、 <strong>交换器（交换机）</strong></h3><p>​\t交换器负责接收客户端传递过来的消息，并转发到对应的队列中。在RabbitMQ中支持四种交换器</p>\n<p>​\t1.Direct Exchange：直连交换器（默认）</p>\n<p>​\t2.Fanout Exchange：扇形交换器</p>\n<p>​\t3.Topic Exchange：主题交换器</p>\n<p>​\t4.Header Exchange：首部交换器。</p>\n<p>​\t在RabbitMq的Web管理界面中Exchanges选项卡就可以看见这四个交换器。</p>\n<img data-src=\"/2022/10/07/RabbitMQ/RabbitMQ-09.jpg\" class=\"\">\n\n\n<h4 id=\"1-direct交换器\"><a href=\"#1-direct交换器\" class=\"headerlink\" title=\"1 direct交换器\"></a>1 <strong>direct交换器</strong></h4><p>​\tdirect交换器是RabbitMQ默认交换器。默认会进行公平调度。所有接受者依次从消息队列中获取值。Publisher给哪个队列发消息，就一定是给哪个队列发送消息。对交换器绑定的其他队列没有任何影响。</p>\n<p>​\t（代码演示）一个队列需要绑定多个消费者</p>\n<p>​\t需要使用注解&#x2F;API：</p>\n<p>​\torg.springframework.amqp.core.Queue:队列</p>\n<p>​\tAmqpTemplate：操作RabbitMQ的接口。负责发送或接收消息</p>\n<p>​\t@RabbitListener(queues &#x3D; “”) 注解某个方法为接收消息方法</p>\n<h4 id=\"1-1-代码实现\"><a href=\"#1-1-代码实现\" class=\"headerlink\" title=\"1.1 代码实现\"></a>1.1 <strong>代码实现</strong></h4><h5 id=\"1-1-1-新建项目Publisher\"><a href=\"#1-1-1-新建项目Publisher\" class=\"headerlink\" title=\"1.1.1 新建项目Publisher\"></a>1.1.1 <strong>新建项目Publisher</strong></h5><h6 id=\"1-1-1-1-添加依赖\"><a href=\"#1-1-1-1-添加依赖\" class=\"headerlink\" title=\"1.1.1.1 添加依赖\"></a>1.1.1.1 <strong>添加依赖</strong></h6><pre><code>&lt;parent&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;\n    &lt;version&gt;2.2.2.RELEASE&lt;/version&gt;\n&lt;/parent&gt;\n\n&lt;dependencies&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;\n    &lt;/dependency&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;\n    &lt;/dependency&gt;\n&lt;/dependencies&gt;\n</code></pre>\n<h6 id=\"1-1-1-2-编写配置文件\"><a href=\"#1-1-1-2-编写配置文件\" class=\"headerlink\" title=\"1.1.1.2 编写配置文件\"></a>1.1.1.2 <strong>编写配置文件</strong></h6><p>​\t新建application.yml.</p>\n<p>​\thost:默认值localhost</p>\n<p>​\tusername默认值：guest</p>\n<p>​\tpassword默认值：guest\t</p>\n<pre><code>spring:\n  rabbitmq:\n    host: 192.168.1.195\n    username: mashibing\n    password: mashibing\n</code></pre>\n<h6 id=\"1-1-1-3-编写配置类\"><a href=\"#1-1-1-3-编写配置类\" class=\"headerlink\" title=\"1.1.1.3 编写配置类\"></a>1.1.1.3 <strong>编写配置类</strong></h6><p>新建com.config.RabbitmqConfig</p>\n<p>​\t队列的创建只有没有这个队列的时候需要编写。以后没有这个queue()方法也可以。</p>\n<pre><code>@Configuration\npublic class RabbitmqConfig &#123;\n    @Bean\n    protected Queue queue()&#123;\n        Queue queue = new Queue(&quot;myqueue&quot;);\n        return queue;\n    &#125;\n&#125;\n</code></pre>\n<h6 id=\"1-1-1-4-编写启动类\"><a href=\"#1-1-1-4-编写启动类\" class=\"headerlink\" title=\"1.1.1.4 编写启动类\"></a>1.1.1.4 <strong>编写启动类</strong></h6><p>略</p>\n<h6 id=\"1-1-1-5-编写测试类\"><a href=\"#1-1-1-5-编写测试类\" class=\"headerlink\" title=\"1.1.1.5 编写测试类\"></a>1.1.1.5 <strong>编写测试类</strong></h6><p>SpringBoot整合Spring-AMQP后包含内置对象AmqpTemplate</p>\n<pre><code>@SpringBootTest(classes = PublisherApplication.class)\n@RunWith(SpringJUnit4ClassRunner.class)\npublic class MyTest &#123;\n    @Autowired\n    private AmqpTemplate amqpTemplate;\n\n    @Test\n    public void test()&#123;\n        amqpTemplate.convertAndSend(&quot;myqueue&quot;,&quot;这是内容1&quot;);\n        System.out.println(&quot;发送成功&quot;);\n    &#125;\n&#125;\n</code></pre>\n<h5 id=\"1-1-2-创建Consumer\"><a href=\"#1-1-2-创建Consumer\" class=\"headerlink\" title=\"1.1.2 创建Consumer\"></a>1.1.2 <strong>创建Consumer</strong></h5><p>​\t新建项目consumer</p>\n<h6 id=\"1-1-2-1-添加依赖\"><a href=\"#1-1-2-1-添加依赖\" class=\"headerlink\" title=\"1.1.2.1 添加依赖\"></a>1.1.2.1 <strong>添加依赖</strong></h6><p>​\t和Publisher一样</p>\n<h6 id=\"1-1-2-2-编写配置文件\"><a href=\"#1-1-2-2-编写配置文件\" class=\"headerlink\" title=\"1.1.2.2 编写配置文件\"></a>1.1.2.2 <strong>编写配置文件</strong></h6><p>​\t和Publisher一样</p>\n<h6 id=\"1-1-2-3-编写监听器方法\"><a href=\"#1-1-2-3-编写监听器方法\" class=\"headerlink\" title=\"1.1.2.3 编写监听器方法\"></a>1.1.2.3 <strong>编写监听器方法</strong></h6><p>​\t注意：</p>\n<p>​\t类上要有@Componet，项目启动时此类生效。</p>\n<p>​\t@RabbitListener 监听指定队列。</p>\n<pre><code>@Component\npublic class DemoReceive &#123;\n\n    @RabbitListener(queues = &quot;myqueue&quot;)\n    public void demo(String msg)&#123;\n        System.out.println(&quot;获取到的消息1111：&quot;+msg);\n    &#125;\n\n    @RabbitListener(queues = &quot;myqueue&quot;)\n    public void demo2(String msg)&#123;\n        System.out.println(&quot;获取到的消息2222：&quot;+msg);\n    &#125;\n&#125;\n</code></pre>\n<h6 id=\"1-1-2-4-新建启动类\"><a href=\"#1-1-2-4-新建启动类\" class=\"headerlink\" title=\"1.1.2.4 新建启动类\"></a>1.1.2.4 <strong>新建启动类</strong></h6><p>​\t略。启动后此项目一直处于运行状态。属于长连接。</p>\n<h4 id=\"2-fanout交换器\"><a href=\"#2-fanout交换器\" class=\"headerlink\" title=\"2 fanout交换器\"></a>2 <strong>fanout交换器</strong></h4><p>​\t扇形交换器，实际上做的事情就是广播，fanout会把消息发送给所有的绑定在当前交换器上的队列。且每个队列消息中第一个Consumer能收到消息。</p>\n<p>​\t（代码演示）一个交换器需要绑定多个队列</p>\n<p>​\t需要使用注解&#x2F;API：</p>\n<p>​\tFanoutExchange：fanout交换器</p>\n<p>​\tBinding：绑定交换器和队列</p>\n<p>​\tBindingBuilder：Binding的构建器</p>\n<p>​\tamq.fanout:内置fanout交换器名称</p>\n<h4 id=\"2-1-代码\"><a href=\"#2-1-代码\" class=\"headerlink\" title=\"2.1 代码\"></a>2.1 <strong>代码</strong></h4><h5 id=\"2-1-1-Publisher\"><a href=\"#2-1-1-Publisher\" class=\"headerlink\" title=\"2.1.1 Publisher\"></a>2.1.1 <strong>Publisher</strong></h5><h6 id=\"2-1-1-1-修改配置类\"><a href=\"#2-1-1-1-修改配置类\" class=\"headerlink\" title=\"2.1.1.1 修改配置类\"></a>2.1.1.1 <strong>修改配置类</strong></h6><pre><code>@Bean\nprotected Queue fanoutQuque1()&#123;\n    return new Queue(&quot;fanout1&quot;);\n&#125;\n\n@Bean\nprotected Queue fanoutQuque2()&#123;\n    return new Queue(&quot;fanout2&quot;);\n&#125;\n\n@Bean\nprotected FanoutExchange fanoutExchange()&#123;\n    return new FanoutExchange(&quot;amq.fanout&quot;);\n&#125;\n\n@Bean\nprotected Binding fanoutBinding(Queue fanoutQuque1,FanoutExchange fanoutExchange)&#123;\n    return BindingBuilder.bind(fanoutQuque1).to(fanoutExchange);\n&#125;\n\n@Bean\nprotected Binding fanoutBinding2(Queue fanoutQuque2,FanoutExchange fanoutExchange)&#123;\n    return BindingBuilder.bind(fanoutQuque2).to(fanoutExchange);\n&#125;\n</code></pre>\n<h5 id=\"2-1-2-编写发送方法\"><a href=\"#2-1-2-编写发送方法\" class=\"headerlink\" title=\"2.1.2 编写发送方法****\"></a>2.1.2 <strong>编写发送方法</strong>****</h5><p>​\t第二个参数routingKey对于fanout没有意义的</p>\n<pre><code>@Test\npublic void test2()&#123;\n    amqpTemplate.convertAndSend(&quot;amq.fanout&quot;,&quot;asdfadsf&quot;,&quot;fanout msg&quot;);\n    System.out.println(&quot;发送成功&quot;);\n&#125;\n</code></pre>\n<h5 id=\"2-1-3-Consumer\"><a href=\"#2-1-3-Consumer\" class=\"headerlink\" title=\"2.1.3 Consumer\"></a>2.1.3 <strong>Consumer</strong></h5><p>​\tConsumer代码和Direct完全相同。一个队列给一个监听方法即可。</p>\n<h4 id=\"3-topic交换器\"><a href=\"#3-topic交换器\" class=\"headerlink\" title=\"3 topic交换器\"></a>3 <strong>topic交换器</strong></h4><p>​\t允许在路由键（RoutingKey）中出现匹配规则。</p>\n<p>​\t路由键的写法和包写法相同。com.msb.xxxx.xxx格式。</p>\n<p>​\t在绑定时可以带有下面特殊符号，中间可以出现:</p>\n<p>​\t* : 代表一个单词（两个.之间内容）</p>\n<p>​\t# : 0个或多个字符</p>\n<p>​\t接收方依然是公平调度，同一个队列中内容轮换获取值。</p>\n<p>​\t需要使用注解&#x2F;API：</p>\n<p>​\tTopicExchange：Topic交换器</p>\n<p>​\tamq.topic:内置topic交换器名称</p>\n<h4 id=\"3-1-代码\"><a href=\"#3-1-代码\" class=\"headerlink\" title=\"3.1 代码\"></a>3.1 <strong>代码</strong></h4><h5 id=\"3-1-1-Publisher\"><a href=\"#3-1-1-Publisher\" class=\"headerlink\" title=\"3.1.1 Publisher\"></a>3.1.1 <strong>Publisher</strong></h5><h6 id=\"3-1-1-1-配置类。\"><a href=\"#3-1-1-1-配置类。\" class=\"headerlink\" title=\"3.1.1.1 配置类。\"></a>3.1.1.1 <strong>配置类。</strong></h6><p>​\t之所以建立两个队列目的是为了演示使用Topic完成Fanout效果。</p>\n<pre><code>@Bean\nprotected Queue topicQueue() &#123;\n    return new Queue(&quot;topic1&quot;);\n&#125;\n\n@Bean\nprotected Queue topicQueue2() &#123;\n    return new Queue(&quot;topic2&quot;);\n&#125;\n\n@Bean\nprotected TopicExchange topicExchange() &#123;\n    return new TopicExchange(&quot;amq.topic&quot;);\n&#125;\n\n@Bean\nprotected Binding topicBinding(Queue topicQueue, TopicExchange topicExchange) &#123;\n    return BindingBuilder.bind(topicQueue).to(topicExchange).with(&quot;com.a&quot;);\n&#125;\n\n@Bean\nprotected Binding topicBinding2(Queue topicQueue2, TopicExchange topicExchange) &#123;\n    return BindingBuilder.bind(topicQueue2).to(topicExchange).with(&quot;com.#&quot;);\n&#125;\n</code></pre>\n<h6 id=\"3-1-1-2-发送消息\"><a href=\"#3-1-1-2-发送消息\" class=\"headerlink\" title=\"3.1.1.2 发送消息\"></a>3.1.1.2 <strong>发送消息</strong></h6><p>​\t第二个参数为路由键，匹配配置类中绑定时的路由规则。</p>\n<pre><code>@Test\npublic void test3()&#123;\n    amqpTemplate.convertAndSend(&quot;amq.topic&quot;,&quot;com.bjsxt.a.b&quot;,&quot;topic msg&quot;);\n    System.out.println(&quot;发送成功&quot;);\n&#125;\n</code></pre>\n<p> 3.1.2 <strong>Consumer</strong></p>\n<p>​\tConsumer代码与以前一样，注意队列名称topic1,topic2不要写路由键名称。( queues取值)</p>\n<pre><code>@RabbitListener(queues = &quot;topic2&quot;)\npublic void demo10(String msg)&#123;\n    System.out.println(&quot;topic2-2:&quot;+msg);\n&#125;\n</code></pre>\n<h3 id=\"八、-传递对象类型参数\"><a href=\"#八、-传递对象类型参数\" class=\"headerlink\" title=\"八、 传递对象类型参数\"></a>八、 <strong>传递对象类型参数</strong></h3><p>​\t如果消息是对象类型，此对象的类型必须进行序列化，且需要给定序列化值</p>\n<pre><code>public class People implements Serializable \n&#123;\n    public static final long serialVersionUID=1L;\n&#125;\n</code></pre>\n",
            "tags": [
                "分布式",
                "中间件",
                "RabbitMQ"
            ]
        }
    ]
}