<?xml version="1.0"?>
<rss version="2.0">
    <channel>
        <title>记录“美食”每刻 • Posts by &#34;rabbitmq&#34; category</title>
        <link>http://example.com</link>
        <description>记录“美食”每刻</description>
        <language>zh-CN</language>
        <pubDate>Fri, 07 Oct 2022 00:00:00 +0800</pubDate>
        <lastBuildDate>Fri, 07 Oct 2022 00:00:00 +0800</lastBuildDate>
        <category>分布式</category>
        <category>Dubbo</category>
        <category>FastDFS</category>
        <category>中间件</category>
        <category>RabbitMQ</category>
        <category>Solr</category>
        <category>快速搜索</category>
        <category>RPC</category>
        <category>JavaSE</category>
        <category>-JavaSE</category>
        <category>博客</category>
        <category>环境搭建</category>
        <category>框架</category>
        <category>ORM</category>
        <category>Spring</category>
        <category>SpringBoot</category>
        <category>SpringMVC</category>
        <category>SpringSecurity</category>
        <category>Redis基础</category>
        <category>NoSQL数据库</category>
        <item>
            <guid isPermalink="true">http://example.com/2022/10/07/Distribution/RabbitMQ/</guid>
            <title>RabbitMQ</title>
            <link>http://example.com/2022/10/07/Distribution/RabbitMQ/</link>
            <category>分布式</category>
            <category>中间件</category>
            <category>RabbitMQ</category>
            <pubDate>Fri, 07 Oct 2022 00:00:00 +0800</pubDate>
            <description><![CDATA[ &lt;h2 id=&#34;主要内容&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#主要内容&#34;&gt;#&lt;/a&gt; &lt;strong&gt;主要内容&lt;/strong&gt;&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;AMQP 简介&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;RabbitMQ 简介&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;RabbitMQ 原理&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Erlang 安装&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;安装 RabbitMQ&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;RabbitMQ 账户管理&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;交换器&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;学习目标&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#学习目标&#34;&gt;#&lt;/a&gt; &lt;strong&gt;学习目标&lt;/strong&gt;&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;知识点&lt;/th&gt;
&lt;th&gt;要求&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;AMQP 简介&lt;/td&gt;
&lt;td&gt;掌握&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;RabbmitMQ 简介&lt;/td&gt;
&lt;td&gt;掌握&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;RabbitMQ 原理&lt;/td&gt;
&lt;td&gt;掌握&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Erlang 安装&lt;/td&gt;
&lt;td&gt;掌握&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;安装 RabbitMQ&lt;/td&gt;
&lt;td&gt;掌握&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;RabbitMQ 账户管理&lt;/td&gt;
&lt;td&gt;掌握&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;交换器&lt;/td&gt;
&lt;td&gt;掌握&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;一-amqp简介&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#一-amqp简介&#34;&gt;#&lt;/a&gt; 一、 &lt;strong&gt;AMQP 简介&lt;/strong&gt;&lt;/h3&gt;
&lt;h4 id=&#34;1-amqp是什么&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#1-amqp是什么&#34;&gt;#&lt;/a&gt; 1 &lt;strong&gt;AMQP 是什么？&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;​	AMQP (Advanced Message Queuing Protocol, 高级消息队列协议) 是进程之间传递异步消息的网络协议。&lt;/p&gt;
&lt;h3 id=&#34;2-amqp工作过程&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#2-amqp工作过程&#34;&gt;#&lt;/a&gt; 2 &lt;strong&gt;AMQP 工作过程&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;​	发布者 (Publisher) 发布消息 (Message), 经过交换机 (Exchange)，交换机根据路由规则将收到消息分发给交换机绑定的队列 (Queue)，最后 AMQP 代理会将消息投递给订阅了此队列的消费者，或者消费者按照需求自行获取。&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;/2022/10/07/Distribution/RabbitMQ/RabbitMQ-01.jpg&#34; class=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;3-队列&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#3-队列&#34;&gt;#&lt;/a&gt; 3 &lt;strong&gt;队列&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;​	队列是数据结构中概念。数据存储在一个队列中，数据是有顺序的，先进的先出，后进后出。其中一侧负责进数据，另一侧负责出数据。&lt;/p&gt;
&lt;p&gt;MQ（消息队列）很多功能都是基于此队列结构实现的！&lt;/p&gt;
&lt;h3 id=&#34;二-rabbitmq简介&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#二-rabbitmq简介&#34;&gt;#&lt;/a&gt; 二、 &lt;strong&gt;RabbitMQ 简介&lt;/strong&gt;&lt;/h3&gt;
&lt;h4 id=&#34;1-rabbitmq介绍&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#1-rabbitmq介绍&#34;&gt;#&lt;/a&gt; 1 &lt;strong&gt;RabbitMQ 介绍&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;​	RabbitMQ 是由 Erlang 语言编写的基于 AMQP 的消息中间件。而消息中间件作为分布式系统重要组件之一，可以解决应用耦合，异步消息，流量削峰等问题。&lt;/p&gt;
&lt;h5 id=&#34;11-解决应用耦合&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#11-解决应用耦合&#34;&gt;#&lt;/a&gt; 1.1 &lt;strong&gt;解决应用耦合&lt;/strong&gt;&lt;/h5&gt;
&lt;h6 id=&#34;111-不使用mq时&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#111-不使用mq时&#34;&gt;#&lt;/a&gt; 1.1.1 &lt;strong&gt;不使用 MQ 时&lt;/strong&gt;&lt;/h6&gt;
&lt;p&gt;&lt;img data-src=&#34;/2022/10/07/Distribution/RabbitMQ/RabbitMQ-03.jpg&#34; class=&#34;&#34;&gt;&lt;/p&gt;
&lt;h6 id=&#34;112-使用mq解决耦合&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#112-使用mq解决耦合&#34;&gt;#&lt;/a&gt; 1.1.2 &lt;strong&gt;使用 MQ 解决耦合&lt;/strong&gt;&lt;/h6&gt;
&lt;p&gt;&lt;img data-src=&#34;/2022/10/07/Distribution/RabbitMQ/RabbitMQ-04.jpg&#34; class=&#34;&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;2-rabbitmq适用场景&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#2-rabbitmq适用场景&#34;&gt;#&lt;/a&gt; 2 &lt;strong&gt;RabbitMQ 适用场景&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;​	排队算法：使用消息队列特性&lt;/p&gt;
&lt;p&gt;​	秒杀活动：使用消息队列特性&lt;/p&gt;
&lt;p&gt;​	消息分发：使用消息异步特性&lt;/p&gt;
&lt;p&gt;​	异步处理：使用消息异步特性&lt;/p&gt;
&lt;p&gt;​	数据同步：使用消息异步特性&lt;/p&gt;
&lt;p&gt;​	处理耗时任务：使用消息异步特性&lt;/p&gt;
&lt;p&gt;​	流量销峰&lt;/p&gt;
&lt;h3 id=&#34;三-rabbitmq原理&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#三-rabbitmq原理&#34;&gt;#&lt;/a&gt; 三、 &lt;strong&gt;RabbitMQ 原理&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;img data-src=&#34;/2022/10/07/Distribution/RabbitMQ/RabbitMQ-05.jpg&#34; class=&#34;&#34;&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;1.Message&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;消息。消息是不具名的，它由消息头消息体组成。消息体是不透明的，而消息头则由一系列可选属性组成，这些属性包括：routing-key (路由键)、priority (相对于其他消息的优先权)、delivery-mode (指出消息可能持久性存储) 等。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;2&lt;/strong&gt;.&lt;strong&gt;Publisher&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;消息的生产者。也是一个向交换器发布消息的客户端应用程序。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;3&lt;/strong&gt;.&lt;strong&gt;Consumer&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;消息的消费者。表示一个从消息队列中取得消息的客户端应用程序。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;4.Exchange&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;交换器。用来接收生产者发送的消息并将这些消息路由给服务器中的队列。三种常用的交换器类型 1. direct (发布与订阅 完全匹配) 2. fanout (广播) 3. topic (主题，规则匹配)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;5.Binding&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;绑定。用于消息队列和交换器之间的关联。一个绑定就是基于路由键将交换器和消息队列连接起来的路由规则，所以可以将交换器理解成一个由绑定构成的路由表。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;6.Queue&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;消息队列。用来保存消息直到发送给消费者。它是消息的容器，也是消息的终点。一个消息可投入一个或多个队列。消息一直在队列里面，等待消费者链接到这个队列将其取走。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;7.Routing-key&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;路由键。RabbitMQ 决定消息该投递到哪个队列的规则。（也可以理解为队列的名称，路由键是 key，队列是 value）队列通过路由键绑定到交换器。消息发送到 MQ 服务器时，消息将拥有一个路由键，即便是空的，RabbitMQ 也会将其和绑定使用的路由键进行匹配。如果相匹配，消息将会投递到该队列。如果不匹配，消息将会进入黑洞。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;8.Connection&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;链接。指 rabbit 服务器和服务建立的 TCP 链接。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;9.Channel&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;信道。1，Channel 中文叫做信道，是 TCP 里面的虚拟链接。例如：电缆相当于 TCP，信道是一个独立光纤束，一条 TCP 连接上创建多条信道是没有问题的。2，TCP 一旦打开，就会创建 AMQP 信道。3，无论是发布消息、接收消息、订阅队列，这些动作都是通过信道完成的。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;10.Virtual Host&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;虚拟主机。表示一批交换器，消息队列和相关对象。虚拟主机是共享相同的身份认证和加密环境的独立服务器域。每个 vhost 本质上就是一个 mini 版的 RabbitMQ 服务器，拥有自己的队列、交换器、绑定和权限机制。vhost 是 AMQP 概念的基础，必须在链接时指定，RabbitMQ 默认的 vhost 是 **/**&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;11.Borker&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;表示消息队列服务器实体。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;12. 交换器和队列的关系&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;交换器是通过路由键和队列绑定在一起的，如果消息拥有的路由键跟队列和交换器的路由键匹配，那么消息就会被路由到该绑定的队列中。     也就是说，消息到队列的过程中，消息首先会经过交换器，接下来交换器在通过路由键匹配分发消息到具体的队列中。     路由键可以理解为匹配的规则。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;13.RabbitMQ 为什么需要信道？为什么不是 TCP 直接通信？&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1. TCP 的创建和销毁开销特别大。创建需要 3 次握手，销毁需要 4 次分手。2. 如果不用信道，那应用程序就会以 TCP 链接 Rabbit，高峰时每秒成千上万条链接会造成资源巨大的浪费，而且操作系统每秒处理 TCP 链接数也是有限制的，必定造成性能瓶颈。3. 信道的原理是一条线程一条通道，多条线程多条通道同用一条 TCP 链接。一条 TCP 链接可以容纳无限的信道，即使每秒成千上万的请求也不会成为性能的瓶颈。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;四-erlang安装&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#四-erlang安装&#34;&gt;#&lt;/a&gt; 四、 &lt;strong&gt;Erlang 安装&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;​	RabbitMQ 是使用 Erlang 语言编写的，所以需要先配置 Erlang&lt;/p&gt;
&lt;h4 id=&#34;1-修改主机名&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#1-修改主机名&#34;&gt;#&lt;/a&gt; 1 &lt;strong&gt;修改主机名&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;​	RabbitMQ 是通过主机名进行访问的，必须指定能访问的主机名。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  vim /etc/sysconfig/network
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img data-src=&#34;/2022/10/07/Distribution/RabbitMQ/RabbitMQ-06.jpg&#34; class=&#34;&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  vim /etc/hosts
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​	新添加了一行，前面为服务器 ip，空格后面添加计算机主机名&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;/2022/10/07/Distribution/RabbitMQ/RabbitMQ-07.jpg&#34; class=&#34;&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;2-安装依赖&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#2-安装依赖&#34;&gt;#&lt;/a&gt; 2 &lt;strong&gt;安装依赖&lt;/strong&gt;&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;  yum -y install make gcc gcc-c++ kernel-devel m4 ncurses-devel openssl-devel unixODBC unixODBC-devel
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;3-上传并解压&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#3-上传并解压&#34;&gt;#&lt;/a&gt; 3 &lt;strong&gt;上传并解压&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;​	上传 otp_src_22.0.tar.gz 到 /usr/local/tmp 目录中，进入目录并解压。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;解压时注意，此压缩包不具有gzip属性，解压参数没有z，只有xf
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;  cd /usr/local/tmp
  tar xf otp_src_22.0.tar.gz -C /usr/local/tmp
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;4-配置参数&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#4-配置参数&#34;&gt;#&lt;/a&gt; 4 &lt;strong&gt;配置参数&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;​	先新建 /usr/local/erlang 文件夹，作为安装文件夹&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  mkdir -p /usr/local/erlang
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​	 进入文件夹&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  cd otp_src_22.0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​	 配置参数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  ./configure --prefix=/usr/local/erlang --with-ssl --enable-threads --enable-smp-support --enable-kernel-poll --enable-hipe --without-javac
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;5-编译并安装&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#5-编译并安装&#34;&gt;#&lt;/a&gt; 5 &lt;strong&gt;编译并安装&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;​	编译&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  make
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​	 安装&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  make install
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;6-修改环境变量&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#6-修改环境变量&#34;&gt;#&lt;/a&gt; 6 &lt;strong&gt;修改环境变量&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;​	修改 /etc/profile 文件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; vim /etc/profile
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​	 在文件中添加下面代码&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;export PATH=$PATH:/usr/local/erlang/bin
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​	运行文件，让修改内容生效&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  source /etc/profile
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;7-查看配置是否成功&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#7-查看配置是否成功&#34;&gt;#&lt;/a&gt; 7 &lt;strong&gt;查看配置是否成功&lt;/strong&gt;&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;  erl -version
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img data-src=&#34;/2022/10/07/Distribution/RabbitMQ/RabbitMQ-08.jpg&#34; class=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;五-安装rabbitmq&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#五-安装rabbitmq&#34;&gt;#&lt;/a&gt; 五、 &lt;strong&gt;安装 RabbitMQ&lt;/strong&gt;&lt;/h3&gt;
&lt;h4 id=&#34;1-上传并解压&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#1-上传并解压&#34;&gt;#&lt;/a&gt; 1 &lt;strong&gt;上传并解压&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;​	上传 rabbitmq-server-generic-unix-3.7.18.tar.xz 到 /usr/loca/tmp 中&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  cd /usr/local/tmp
  tar xf rabbitmq-server-generic-unix-3.7.18.tar.xz
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;2-复制到local下&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#2-复制到local下&#34;&gt;#&lt;/a&gt; 2 &lt;strong&gt;复制到 local 下&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;​	复制解压文件到 /usr/local 下，命名为 rabbitmq&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  cp -r rabbitmq_server-3.7.18 /usr/local/rabbitmq
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;3-配置环境变量&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#3-配置环境变量&#34;&gt;#&lt;/a&gt; 3 &lt;strong&gt;配置环境变量&lt;/strong&gt;&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;  vim /etc/profile
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​	在文件中添加&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;export PATH=$PATH:/usr/local/rabbitmq/sbin
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​	解析文件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# source /etc/profile
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;4-开启web管理插件&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#4-开启web管理插件&#34;&gt;#&lt;/a&gt; 4 &lt;strong&gt;开启 web 管理插件&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;​	进入 rabbitmq/sbin 目录&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# cd /usr/local/rabbitmq/sbin
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;查看插件列表
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;# ./rabbitmq-plugins list
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;生效管理插件
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;# ./rabbitmq-plugins enable rabbitmq_management
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;5-后台运行&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#5-后台运行&#34;&gt;#&lt;/a&gt; 5 &lt;strong&gt;后台运行&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;​	启动 rabbitmq。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# ./rabbitmq-server -detached
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​	停止命令，如果无法停止，使用 kill -9 进程号进行关闭&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# ./rabbitmqctl stop_app
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;6-查看web管理界面&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#6-查看web管理界面&#34;&gt;#&lt;/a&gt; 6 &lt;strong&gt;查看 web 管理界面&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;​	默认可以在安装 rabbitmq 的电脑上通过用户名：guest 密码 guest 进行访问 web 管理界面&lt;/p&gt;
&lt;p&gt;​	端口号：15672（放行端口，或关闭防火墙）&lt;/p&gt;
&lt;p&gt;​	在虚拟机浏览器中输入：&lt;/p&gt;
&lt;p&gt;​	&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cDovL2xvY2FsaG9zdDoxNTY3Mg==&#34;&gt;http://localhost:15672&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&#34;六-rabbitmq账户管理&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#六-rabbitmq账户管理&#34;&gt;#&lt;/a&gt; 六、 &lt;strong&gt;RabbitMq 账户管理&lt;/strong&gt;&lt;/h3&gt;
&lt;h4 id=&#34;1-创建账户&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#1-创建账户&#34;&gt;#&lt;/a&gt; 1 &lt;strong&gt;创建账户&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;​	语法：./rabbitmqctl add_user username password&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# cd /usr/local/rabbitmq/sbin
# ./rabbitmqctl add_user mashibing mashibing
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;2-给用户授予管理员角色&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#2-给用户授予管理员角色&#34;&gt;#&lt;/a&gt; 2 &lt;strong&gt;给用户授予管理员角色&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;​	其中 smallming 为新建用户的用户名&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# ./rabbitmqctl set_user_tags mashibing administrator
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;3-给用户授权&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#3-给用户授权&#34;&gt;#&lt;/a&gt; 3 &lt;strong&gt;给用户授权&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;​	“/” 表示虚拟机&lt;/p&gt;
&lt;p&gt;​	mashibing 表示用户名&lt;/p&gt;
&lt;p&gt;​	&amp;quot;.&lt;em&gt;&amp;quot; &amp;quot;.&lt;/em&gt;&amp;quot;&amp;quot;.*&amp;quot; 表示完整权限&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# ./rabbitmqctl set_permissions -p &amp;quot;/&amp;quot; mashibing &amp;quot;.*&amp;quot; &amp;quot;.*&amp;quot; &amp;quot;.*&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;4-登录&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#4-登录&#34;&gt;#&lt;/a&gt; 4 &lt;strong&gt;登录&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;​	使用新建账户和密码在 windows 中访问 rabbitmq 并登录&lt;/p&gt;
&lt;p&gt;​	在浏览器地址栏输入：&lt;/p&gt;
&lt;p&gt;​	&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cDovL2lwOjE1NjcyLw==&#34;&gt;http://ip:15672/&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;用户名：mashibing
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​	密码：mashibing&lt;/p&gt;
&lt;h3 id=&#34;七-交换器交换机&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#七-交换器交换机&#34;&gt;#&lt;/a&gt; 七、 &lt;strong&gt;交换器（交换机）&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;​	交换器负责接收客户端传递过来的消息，并转发到对应的队列中。在 RabbitMQ 中支持四种交换器&lt;/p&gt;
&lt;p&gt;​	1.Direct Exchange：直连交换器（默认）&lt;/p&gt;
&lt;p&gt;​	2.Fanout Exchange：扇形交换器&lt;/p&gt;
&lt;p&gt;​	3.Topic Exchange：主题交换器&lt;/p&gt;
&lt;p&gt;​	4.Header Exchange：首部交换器。&lt;/p&gt;
&lt;p&gt;​	在 RabbitMq 的 Web 管理界面中 Exchanges 选项卡就可以看见这四个交换器。&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;/2022/10/07/Distribution/RabbitMQ/RabbitMQ-09.jpg&#34; class=&#34;&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;1-direct交换器&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#1-direct交换器&#34;&gt;#&lt;/a&gt; 1 &lt;strong&gt;direct 交换器&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;​	direct 交换器是 RabbitMQ 默认交换器。默认会进行公平调度。所有接受者依次从消息队列中获取值。Publisher 给哪个队列发消息，就一定是给哪个队列发送消息。对交换器绑定的其他队列没有任何影响。&lt;/p&gt;
&lt;p&gt;​	（代码演示）一个队列需要绑定多个消费者&lt;/p&gt;
&lt;p&gt;​	需要使用注解 / API：&lt;/p&gt;
&lt;p&gt;​	org.springframework.amqp.core.Queue: 队列&lt;/p&gt;
&lt;p&gt;​	AmqpTemplate：操作 RabbitMQ 的接口。负责发送或接收消息&lt;/p&gt;
&lt;p&gt;​	@RabbitListener (queues = &amp;quot;&amp;quot;) 注解某个方法为接收消息方法&lt;/p&gt;
&lt;h4 id=&#34;11-代码实现&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#11-代码实现&#34;&gt;#&lt;/a&gt; 1.1 &lt;strong&gt;代码实现&lt;/strong&gt;&lt;/h4&gt;
&lt;h5 id=&#34;111-新建项目publisher&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#111-新建项目publisher&#34;&gt;#&lt;/a&gt; 1.1.1 &lt;strong&gt;新建项目 Publisher&lt;/strong&gt;&lt;/h5&gt;
&lt;h6 id=&#34;1111-添加依赖&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#1111-添加依赖&#34;&gt;#&lt;/a&gt; 1.1.1.1 &lt;strong&gt;添加依赖&lt;/strong&gt;&lt;/h6&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;parent&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-boot-starter-parent&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;2.2.2.RELEASE&amp;lt;/version&amp;gt;
&amp;lt;/parent&amp;gt;

&amp;lt;dependencies&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-boot-starter-test&amp;lt;/artifactId&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-boot-starter-amqp&amp;lt;/artifactId&amp;gt;
    &amp;lt;/dependency&amp;gt;
&amp;lt;/dependencies&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h6 id=&#34;1112-编写配置文件&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#1112-编写配置文件&#34;&gt;#&lt;/a&gt; 1.1.1.2 &lt;strong&gt;编写配置文件&lt;/strong&gt;&lt;/h6&gt;
&lt;p&gt;​	新建 application.yml.&lt;/p&gt;
&lt;p&gt;​	host: 默认值 localhost&lt;/p&gt;
&lt;p&gt;​	username 默认值：guest&lt;/p&gt;
&lt;p&gt;​	password 默认值：guest&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;spring:
  rabbitmq:
    host: 192.168.1.195
    username: mashibing
    password: mashibing
&lt;/code&gt;&lt;/pre&gt;
&lt;h6 id=&#34;1113-编写配置类&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#1113-编写配置类&#34;&gt;#&lt;/a&gt; 1.1.1.3 &lt;strong&gt;编写配置类&lt;/strong&gt;&lt;/h6&gt;
&lt;p&gt;新建 com.config.RabbitmqConfig&lt;/p&gt;
&lt;p&gt;​	队列的创建只有没有这个队列的时候需要编写。以后没有这个 queue () 方法也可以。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Configuration
public class RabbitmqConfig &amp;#123;
    @Bean
    protected Queue queue()&amp;#123;
        Queue queue = new Queue(&amp;quot;myqueue&amp;quot;);
        return queue;
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h6 id=&#34;1114-编写启动类&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#1114-编写启动类&#34;&gt;#&lt;/a&gt; 1.1.1.4 &lt;strong&gt;编写启动类&lt;/strong&gt;&lt;/h6&gt;
&lt;p&gt;略&lt;/p&gt;
&lt;h6 id=&#34;1115-编写测试类&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#1115-编写测试类&#34;&gt;#&lt;/a&gt; 1.1.1.5 &lt;strong&gt;编写测试类&lt;/strong&gt;&lt;/h6&gt;
&lt;p&gt;SpringBoot 整合 Spring-AMQP 后包含内置对象 AmqpTemplate&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@SpringBootTest(classes = PublisherApplication.class)
@RunWith(SpringJUnit4ClassRunner.class)
public class MyTest &amp;#123;
    @Autowired
    private AmqpTemplate amqpTemplate;

    @Test
    public void test()&amp;#123;
        amqpTemplate.convertAndSend(&amp;quot;myqueue&amp;quot;,&amp;quot;这是内容1&amp;quot;);
        System.out.println(&amp;quot;发送成功&amp;quot;);
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;112-创建consumer&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#112-创建consumer&#34;&gt;#&lt;/a&gt; 1.1.2 &lt;strong&gt;创建 Consumer&lt;/strong&gt;&lt;/h5&gt;
&lt;p&gt;​	新建项目 consumer&lt;/p&gt;
&lt;h6 id=&#34;1121-添加依赖&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#1121-添加依赖&#34;&gt;#&lt;/a&gt; 1.1.2.1 &lt;strong&gt;添加依赖&lt;/strong&gt;&lt;/h6&gt;
&lt;p&gt;​	和 Publisher 一样&lt;/p&gt;
&lt;h6 id=&#34;1122-编写配置文件&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#1122-编写配置文件&#34;&gt;#&lt;/a&gt; 1.1.2.2 &lt;strong&gt;编写配置文件&lt;/strong&gt;&lt;/h6&gt;
&lt;p&gt;​	和 Publisher 一样&lt;/p&gt;
&lt;h6 id=&#34;1123-编写监听器方法&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#1123-编写监听器方法&#34;&gt;#&lt;/a&gt; 1.1.2.3 &lt;strong&gt;编写监听器方法&lt;/strong&gt;&lt;/h6&gt;
&lt;p&gt;​	注意：&lt;/p&gt;
&lt;p&gt;​	类上要有 @Componet，项目启动时此类生效。&lt;/p&gt;
&lt;p&gt;​	@RabbitListener 监听指定队列。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Component
public class DemoReceive &amp;#123;

    @RabbitListener(queues = &amp;quot;myqueue&amp;quot;)
    public void demo(String msg)&amp;#123;
        System.out.println(&amp;quot;获取到的消息1111：&amp;quot;+msg);
    &amp;#125;

    @RabbitListener(queues = &amp;quot;myqueue&amp;quot;)
    public void demo2(String msg)&amp;#123;
        System.out.println(&amp;quot;获取到的消息2222：&amp;quot;+msg);
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h6 id=&#34;1124-新建启动类&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#1124-新建启动类&#34;&gt;#&lt;/a&gt; 1.1.2.4 &lt;strong&gt;新建启动类&lt;/strong&gt;&lt;/h6&gt;
&lt;p&gt;​	略。启动后此项目一直处于运行状态。属于长连接。&lt;/p&gt;
&lt;h4 id=&#34;2-fanout交换器&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#2-fanout交换器&#34;&gt;#&lt;/a&gt; 2 &lt;strong&gt;fanout 交换器&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;​	扇形交换器，实际上做的事情就是广播，fanout 会把消息发送给所有的绑定在当前交换器上的队列。且每个队列消息中第一个 Consumer 能收到消息。&lt;/p&gt;
&lt;p&gt;​	（代码演示）一个交换器需要绑定多个队列&lt;/p&gt;
&lt;p&gt;​	需要使用注解 / API：&lt;/p&gt;
&lt;p&gt;​	FanoutExchange：fanout 交换器&lt;/p&gt;
&lt;p&gt;​	Binding：绑定交换器和队列&lt;/p&gt;
&lt;p&gt;​	BindingBuilder：Binding 的构建器&lt;/p&gt;
&lt;p&gt;​	amq.fanout: 内置 fanout 交换器名称&lt;/p&gt;
&lt;h4 id=&#34;21-代码&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#21-代码&#34;&gt;#&lt;/a&gt; 2.1 &lt;strong&gt;代码&lt;/strong&gt;&lt;/h4&gt;
&lt;h5 id=&#34;211-publisher&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#211-publisher&#34;&gt;#&lt;/a&gt; 2.1.1 &lt;strong&gt;Publisher&lt;/strong&gt;&lt;/h5&gt;
&lt;h6 id=&#34;2111-修改配置类&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#2111-修改配置类&#34;&gt;#&lt;/a&gt; 2.1.1.1 &lt;strong&gt;修改配置类&lt;/strong&gt;&lt;/h6&gt;
&lt;pre&gt;&lt;code&gt;@Bean
protected Queue fanoutQuque1()&amp;#123;
    return new Queue(&amp;quot;fanout1&amp;quot;);
&amp;#125;

@Bean
protected Queue fanoutQuque2()&amp;#123;
    return new Queue(&amp;quot;fanout2&amp;quot;);
&amp;#125;

@Bean
protected FanoutExchange fanoutExchange()&amp;#123;
    return new FanoutExchange(&amp;quot;amq.fanout&amp;quot;);
&amp;#125;

@Bean
protected Binding fanoutBinding(Queue fanoutQuque1,FanoutExchange fanoutExchange)&amp;#123;
    return BindingBuilder.bind(fanoutQuque1).to(fanoutExchange);
&amp;#125;

@Bean
protected Binding fanoutBinding2(Queue fanoutQuque2,FanoutExchange fanoutExchange)&amp;#123;
    return BindingBuilder.bind(fanoutQuque2).to(fanoutExchange);
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;212-编写发送方法&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#212-编写发送方法&#34;&gt;#&lt;/a&gt; 2.1.2 &lt;strong&gt;编写发送方法&lt;/strong&gt; ****&lt;/h5&gt;
&lt;p&gt;​	第二个参数 routingKey 对于 fanout 没有意义的&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Test
public void test2()&amp;#123;
    amqpTemplate.convertAndSend(&amp;quot;amq.fanout&amp;quot;,&amp;quot;asdfadsf&amp;quot;,&amp;quot;fanout msg&amp;quot;);
    System.out.println(&amp;quot;发送成功&amp;quot;);
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;213-consumer&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#213-consumer&#34;&gt;#&lt;/a&gt; 2.1.3 &lt;strong&gt;Consumer&lt;/strong&gt;&lt;/h5&gt;
&lt;p&gt;​	Consumer 代码和 Direct 完全相同。一个队列给一个监听方法即可。&lt;/p&gt;
&lt;h4 id=&#34;3-topic交换器&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#3-topic交换器&#34;&gt;#&lt;/a&gt; 3 &lt;strong&gt;topic 交换器&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;​	允许在路由键（RoutingKey）中出现匹配规则。&lt;/p&gt;
&lt;p&gt;​	路由键的写法和包写法相同。com.msb.xxxx.xxx 格式。&lt;/p&gt;
&lt;p&gt;​	在绑定时可以带有下面特殊符号，中间可以出现:&lt;/p&gt;
&lt;p&gt;​	* : 代表一个单词（两个。之间内容）&lt;/p&gt;
&lt;p&gt;​	# : 0 个或多个字符&lt;/p&gt;
&lt;p&gt;​	接收方依然是公平调度，同一个队列中内容轮换获取值。&lt;/p&gt;
&lt;p&gt;​	需要使用注解 / API：&lt;/p&gt;
&lt;p&gt;​	TopicExchange：Topic 交换器&lt;/p&gt;
&lt;p&gt;​	amq.topic: 内置 topic 交换器名称&lt;/p&gt;
&lt;h4 id=&#34;31-代码&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#31-代码&#34;&gt;#&lt;/a&gt; 3.1 &lt;strong&gt;代码&lt;/strong&gt;&lt;/h4&gt;
&lt;h5 id=&#34;311-publisher&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#311-publisher&#34;&gt;#&lt;/a&gt; 3.1.1 &lt;strong&gt;Publisher&lt;/strong&gt;&lt;/h5&gt;
&lt;h6 id=&#34;3111-配置类&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#3111-配置类&#34;&gt;#&lt;/a&gt; 3.1.1.1 &lt;strong&gt;配置类。&lt;/strong&gt;&lt;/h6&gt;
&lt;p&gt;​	之所以建立两个队列目的是为了演示使用 Topic 完成 Fanout 效果。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Bean
protected Queue topicQueue() &amp;#123;
    return new Queue(&amp;quot;topic1&amp;quot;);
&amp;#125;

@Bean
protected Queue topicQueue2() &amp;#123;
    return new Queue(&amp;quot;topic2&amp;quot;);
&amp;#125;

@Bean
protected TopicExchange topicExchange() &amp;#123;
    return new TopicExchange(&amp;quot;amq.topic&amp;quot;);
&amp;#125;

@Bean
protected Binding topicBinding(Queue topicQueue, TopicExchange topicExchange) &amp;#123;
    return BindingBuilder.bind(topicQueue).to(topicExchange).with(&amp;quot;com.a&amp;quot;);
&amp;#125;

@Bean
protected Binding topicBinding2(Queue topicQueue2, TopicExchange topicExchange) &amp;#123;
    return BindingBuilder.bind(topicQueue2).to(topicExchange).with(&amp;quot;com.#&amp;quot;);
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h6 id=&#34;3112-发送消息&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#3112-发送消息&#34;&gt;#&lt;/a&gt; 3.1.1.2 &lt;strong&gt;发送消息&lt;/strong&gt;&lt;/h6&gt;
&lt;p&gt;​	第二个参数为路由键，匹配配置类中绑定时的路由规则。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Test
public void test3()&amp;#123;
    amqpTemplate.convertAndSend(&amp;quot;amq.topic&amp;quot;,&amp;quot;com.bjsxt.a.b&amp;quot;,&amp;quot;topic msg&amp;quot;);
    System.out.println(&amp;quot;发送成功&amp;quot;);
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3.1.2 &lt;strong&gt;Consumer&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​	Consumer 代码与以前一样，注意队列名称 topic1,topic2 不要写路由键名称。(queues 取值)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@RabbitListener(queues = &amp;quot;topic2&amp;quot;)
public void demo10(String msg)&amp;#123;
    System.out.println(&amp;quot;topic2-2:&amp;quot;+msg);
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;八-传递对象类型参数&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#八-传递对象类型参数&#34;&gt;#&lt;/a&gt; 八、 &lt;strong&gt;传递对象类型参数&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;​	如果消息是对象类型，此对象的类型必须进行序列化，且需要给定序列化值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class People implements Serializable 
&amp;#123;
    public static final long serialVersionUID=1L;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;

&lt;div id=&#34;gitalk-container&#34;&gt;&lt;/div&gt;
&lt;script src=&#34;https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js&#34;&gt;&lt;/script&gt;&lt;link rel=&#34;stylesheet&#34; href=&#34;https://unpkg.com/gitalk/dist/gitalk.css&#34;&gt;&lt;script src=&#34;https://unpkg.com/gitalk/dist/gitalk.min.js&#34;&gt;&lt;/script&gt;

		&lt;script&gt;
		var gitalkConfig = {&#34;clientID&#34;:&#34;eda74f740080fa01d0b5&#34;,&#34;clientSecret&#34;:&#34;c994dd2162a1dadaefbf078fcab49361438a7aca&#34;,&#34;repo&#34;:&#34;comments001&#34;,&#34;owner&#34;:&#34;onlymarryu&#34;,&#34;admin&#34;:[&#34;onlymarryu&#34;],&#34;distractionFreeMode&#34;:false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render(&#34;gitalk-container&#34;);
	    &lt;/script&gt; ]]></description>
        </item>
    </channel>
</rss>
