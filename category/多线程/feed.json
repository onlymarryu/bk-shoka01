{
    "version": "https://jsonfeed.org/version/1",
    "title": "记录“美食”每刻 • All posts by \"多线程\" category",
    "description": "记录“美食”每刻",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/2022/10/07/%E7%AC%AC13%E7%AB%A0%E5%A4%9A%E7%BA%BF%E7%A8%8B/",
            "url": "http://example.com/2022/10/07/%E7%AC%AC13%E7%AB%A0%E5%A4%9A%E7%BA%BF%E7%A8%8B/",
            "title": "第13章多线程",
            "date_published": "2022-10-06T16:00:00.000Z",
            "content_html": "<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p>【1】程序，进程，线程<br>➢程序(program)：是为完成特定任务、用某种语言编写的一组指令的集合,是一段静态的代码。 （程序是静态的）</p>\n<p>➢进程(process)：是程序的一次执行过程。正在运行的一个程序，进程作为资源分配的单位，在内存中会为每个进程分配不同的内存区域。 （进程是动态的）是一个动的过程 ，进程的生命周期  :  有它自身的产生、存在和消亡的过程</p>\n<p>➢线程(thread)，进程可进一步细化为线程， 是一个程序内部的一条执行路径。<br>若一个进程同一时间并行执行多个线程，就是支持多线程的。</p>\n<img data-src=\"/2022/10/07/%E7%AC%AC13%E7%AB%A0%E5%A4%9A%E7%BA%BF%E7%A8%8B/image-20220618194135831.png\" class=\"\">\n\n\n\n<p>【2】单核CPU与多核CPU的任务执行：</p>\n<img data-src=\"/2022/10/07/%E7%AC%AC13%E7%AB%A0%E5%A4%9A%E7%BA%BF%E7%A8%8B/image-20220618194141865.png\" class=\"\">\n\n\n<img data-src=\"/2022/10/07/%E7%AC%AC13%E7%AB%A0%E5%A4%9A%E7%BA%BF%E7%A8%8B/image-20220618194149206.png\" class=\"\">\n\n\n\n\n<p>【3】并行和并发：<br>并行：多个CPU同时执行多个任务<br>并发：一个CPU“同时”执行多个任务（采用时间片切换）</p>\n<h1 id=\"1-创建线程的三种方式\"><a href=\"#1-创建线程的三种方式\" class=\"headerlink\" title=\"1 创建线程的三种方式\"></a>1 创建线程的三种方式</h1><h2 id=\"第一种：继承Thread类\"><a href=\"#第一种：继承Thread类\" class=\"headerlink\" title=\"第一种：继承Thread类\"></a>第一种：继承Thread类</h2><p>【1】在学习多线程一章之前，以前的代码是单线程的吗？不是，以前也是有三个线程同时执行的。</p>\n<img data-src=\"/2022/10/07/%E7%AC%AC13%E7%AB%A0%E5%A4%9A%E7%BA%BF%E7%A8%8B/image-20220618194435926.png\" class=\"\">\n\n\n<p>【2】现在我想自己制造多线程—》创建线程 ？？<br>线程类–》线程对象</p>\n<img data-src=\"/2022/10/07/%E7%AC%AC13%E7%AB%A0%E5%A4%9A%E7%BA%BF%E7%A8%8B/image-20220618194442238.png\" class=\"\">\n\n\n<pre><code class=\"java\">/**\n * 线程类叫：TestThread，不是说你名字中带线程单词你就具备多线程能力了（争抢资源能力）\n * 现在想要具备能力，继承一个类：Thread，具备了争抢资源的能力\n */\npublic class TestThread extends Thread&#123;\n    /*\n    一会线程对象就要开始争抢资源了，这个线程要执行的任务到底是啥？这个任务你要放在方法中\n    但是这个方法不能是随便写的一个方法，必须是重写Thread类中的run方法\n    然后线程的任务/逻辑写在run方法中\n     */\n    @Override\n    public void run() &#123;\n        //输出1-10\n        for (int i = 1; i &lt;= 10 ; i++) &#123;\n            System.out.println(i);\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<pre><code class=\"java\">public class Test &#123;\n    //这是main方法，程序的入口\n    public static void main(String[] args) &#123;\n        //主线程中也要输出十个数：\n        for (int i = 1; i &lt;= 10 ; i++) &#123;\n            System.out.println(&quot;main1-----&quot;+i);\n        &#125;\n        //制造其他线程，要跟主线程争抢资源：\n        //具体的线程对象：子线程\n        TestThread tt = new TestThread();\n        //tt.run();//调用run方法，想要执行线程中的任务 --&gt;这个run方法不能直接调用，直接调用就会被当做一个普通方法\n        //想要tt子线程真正起作用比如要启动线程：\n        tt.start();//start()是Thread类中的方法\n        //主线程中也要输出十个数：\n        for (int i = 1; i &lt;= 10 ; i++) &#123;\n            System.out.println(&quot;main2-----&quot;+i);\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>运行结果：</p>\n<img data-src=\"/2022/10/07/%E7%AC%AC13%E7%AB%A0%E5%A4%9A%E7%BA%BF%E7%A8%8B/image-20220618194526775.png\" class=\"\">\n\n\n<h3 id=\"设置读取线程名字\"><a href=\"#设置读取线程名字\" class=\"headerlink\" title=\"设置读取线程名字\"></a>设置读取线程名字</h3><p>【1】setName,getName方法来进行设置读取：</p>\n<pre><code class=\"java\">/**\n * 线程类叫：TestThread，不是说你名字中带线程单词你就具备多线程能力了（争抢资源能力）\n * 现在想要具备能力，继承一个类：Thread，具备了争抢资源的能力\n */\npublic class TestThread extends Thread&#123;\n    /*\n    一会线程对象就要开始争抢资源了，这个线程要执行的任务到底是啥？这个任务你要放在方法中\n    但是这个方法不能是随便写的一个方法，必须是重写Thread类中的run方法\n    然后线程的任务/逻辑写在run方法中\n     */\n    @Override\n    public void run() &#123;\n        //输出1-10\n        for (int i = 1; i &lt;= 10 ; i++) &#123;\n            System.out.println(this.getName()+i);\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<pre><code class=\"java\">public class Test &#123;\n    //这是main方法，程序的入口\n    public static void main(String[] args) &#123;\n        //给main方法这个主线程设置名字：\n        //Thread.currentThread()作用获取当前正在执行的线程\n        Thread.currentThread().setName(&quot;主线程&quot;);\n        //主线程中也要输出十个数：\n        for (int i = 1; i &lt;= 10 ; i++) &#123;\n            System.out.println(Thread.currentThread().getName()+&quot;1-------&quot;+i);\n        &#125;\n        //制造其他线程，要跟主线程争抢资源：\n        //具体的线程对象：子线程\n        TestThread tt = new TestThread();\n        tt.setName(&quot;子线程&quot;);\n        //tt.run();//调用run方法，想要执行线程中的任务 --&gt;这个run方法不能直接调用，直接调用就会被当做一个普通方法\n        //想要tt子线程真正起作用比如要启动线程：\n        tt.start();//start()是Thread类中的方法\n        //主线程中也要输出十个数：\n        for (int i = 1; i &lt;= 10 ; i++) &#123;\n            System.out.println(Thread.currentThread().getName()+&quot;2-------&quot;+i);\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>【2】通过构造器设置 名字：</p>\n<pre><code class=\"java\">/**\n * 线程类叫：TestThread，不是说你名字中带线程单词你就具备多线程能力了（争抢资源能力）\n * 现在想要具备能力，继承一个类：Thread，具备了争抢资源的能力\n */\npublic class TestThread extends Thread&#123;\n    public TestThread(String name)&#123;\n        super(name);//调用父类的有参构造器\n    &#125;\n    /*\n    一会线程对象就要开始争抢资源了，这个线程要执行的任务到底是啥？这个任务你要放在方法中\n    但是这个方法不能是随便写的一个方法，必须是重写Thread类中的run方法\n    然后线程的任务/逻辑写在run方法中\n     */\n    @Override\n    public void run() &#123;\n        //输出1-10\n        for (int i = 1; i &lt;= 10 ; i++) &#123;\n            System.out.println(this.getName()+i);\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"习题：买火车票\"><a href=\"#习题：买火车票\" class=\"headerlink\" title=\"习题：买火车票\"></a>习题：买火车票</h3><p>【1】原理：每个窗口都是一个线程对象：</p>\n<img data-src=\"/2022/10/07/%E7%AC%AC13%E7%AB%A0%E5%A4%9A%E7%BA%BF%E7%A8%8B/image-20220618194717605.png\" class=\"\">\n\n\n\n\n\n<p>【2】代码：</p>\n<pre><code class=\"java\">public class BuyTicketThread extends Thread &#123;\n    public BuyTicketThread(String name)&#123;\n        super(name);\n    &#125;\n    //一共10张票：\n    static int ticketNum = 10;//多个对象共享10张票\n    //每个窗口都是一个线程对象：每个对象执行的代码放入run方法中\n    @Override\n    public void run() &#123;\n        //每个窗口后面有100个人在抢票：\n        for (int i = 1; i &lt;= 100 ; i++) &#123;\n            if(ticketNum &gt; 0)&#123;//对票数进行判断，票数大于零我们才抢票\n                System.out.println(&quot;我在&quot;+this.getName()+&quot;买到了从北京到哈尔滨的第&quot; + ticketNum-- + &quot;张车票&quot;);\n            &#125;\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<pre><code class=\"java\">public class Test &#123;\n    public static void main(String[] args) &#123;\n        //多个窗口抢票：三个窗口三个线程对象：\n        BuyTicketThread t1 = new BuyTicketThread(&quot;窗口1&quot;);\n        t1.start();\n        BuyTicketThread t2 = new BuyTicketThread(&quot;窗口2&quot;);\n        t2.start();\n        BuyTicketThread t3 = new BuyTicketThread(&quot;窗口3&quot;);\n        t3.start();\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"第二种：实现Runnable接口\"><a href=\"#第二种：实现Runnable接口\" class=\"headerlink\" title=\"第二种：实现Runnable接口\"></a>第二种：实现Runnable接口</h2><p>【1】代码：</p>\n<pre><code class=\"java\">/**\n * TestThread实现了这个接口，才会变成一个线程类\n */\npublic class TestThread implements Runnable&#123;\n    @Override\n    public void run() &#123;\n        //输出1-10数字：\n        for (int i = 1; i &lt;= 10 ; i++) &#123;\n            System.out.println(Thread.currentThread().getName()+&quot;----&quot;+i);\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<pre><code class=\"java\">public class Test &#123;\n    public static void main(String[] args) &#123;\n        //创建子线程对象：\n        TestThread tt = new TestThread();\n        Thread t = new Thread(tt,&quot;子线程&quot;);\n        t.start();\n        //主线程里面也是打印1-10数字：\n        for (int i = 1; i &lt;= 10 ; i++) &#123;\n            System.out.println(Thread.currentThread().getName()+&quot;---&quot;+i);\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>运行结果：</p>\n<img data-src=\"/2022/10/07/%E7%AC%AC13%E7%AB%A0%E5%A4%9A%E7%BA%BF%E7%A8%8B/image-20220618194854683.png\" class=\"\">\n\n\n<h3 id=\"习题：买火车票-1\"><a href=\"#习题：买火车票-1\" class=\"headerlink\" title=\"习题：买火车票\"></a>习题：买火车票</h3><p>【1】代码：</p>\n<pre><code class=\"java\">public class BuyTicketThread implements Runnable &#123;\n    int ticketNum = 10;\n    @Override\n    public void run() &#123;\n        for (int i = 1; i &lt;= 100 ; i++) &#123;\n            if(ticketNum &gt; 0)&#123;\n                System.out.println(&quot;我在&quot;+Thread.currentThread().getName()+&quot;买到了北京到哈尔滨的第&quot; + ticketNum-- + &quot;张车票&quot;);\n            &#125;\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<pre><code class=\"java\">public class Test &#123;\n    //这是main方法，程序的入口\n    public static void main(String[] args) &#123;\n        //定义一个线程对象：\n        BuyTicketThread t = new BuyTicketThread();\n        //窗口1买票：\n        Thread t1 = new Thread(t,&quot;窗口1&quot;);\n        t1.start();\n        //窗口2买票：\n        Thread t2 = new Thread(t,&quot;窗口2&quot;);\n        t2.start();\n        //窗口3买票：\n        Thread t3 = new Thread(t,&quot;窗口3&quot;);\n        t3.start();\n    &#125;\n&#125;\n</code></pre>\n<p>【2】实际开发中，方式1 继承Thread类   还是  方式2 实现Runnable接口这种方式多呢？–》方式2</p>\n<p>（1）方式1的话有 Java单继承的局限性，因为继承了Thread类，就不能再继承其它的类了</p>\n<p>（2）方式2的共享资源的能力也会强一些，不需要非得加个static来修饰</p>\n<p>【3】Thread类 Runnable接口 有联系吗？</p>\n<img data-src=\"/2022/10/07/%E7%AC%AC13%E7%AB%A0%E5%A4%9A%E7%BA%BF%E7%A8%8B/image-20220618195007939.png\" class=\"\">\n\n\n<p>对比第一种和第二种创建线程的方式发现，无论第一种继承Thread类的方式还是第二种实现Runnable接口的方式，都需要有一个run方法，<br>但是这个run方法有不足：</p>\n<img data-src=\"/2022/10/07/%E7%AC%AC13%E7%AB%A0%E5%A4%9A%E7%BA%BF%E7%A8%8B/image-20220618195022846.png\" class=\"\">\n\n\n<p>（1）没有返回值<br>（2）不能抛出异常</p>\n<p>基于上面的两个不足，在JDK1.5以后出现了第三种创建线程的方式：实现Callable接口：</p>\n<p>实现Callable接口好处：（1）有返回值  （2）能抛出异常<br>缺点：线程创建比较麻烦</p>\n<pre><code class=\"java\">public class TestRandomNum implements Callable&lt;Integer&gt; &#123;\n    /*\n    1.实现Callable接口，可以不带泛型，如果不带泛型，那么call方式的返回值就是Object类型\n    2.如果带泛型，那么call的返回值就是泛型对应的类型\n    3.从call方法看到：方法有返回值，可以跑出异常\n     */\n    @Override\n    public Integer call() throws Exception &#123;\n        return new Random().nextInt(10);//返回10以内的随机数\n    &#125;\n&#125;\nclass Test&#123;\n    //这是main方法，程序的入口\n    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;\n        //定义一个线程对象：\n        TestRandomNum trn = new TestRandomNum();\n        FutureTask ft = new FutureTask(trn);\n        Thread t = new Thread(ft);\n        t.start();\n        //获取线程得到的返回值：\n        Object obj = ft.get();\n        System.out.println(obj);\n    &#125;\n&#125;\n</code></pre>\n<h1 id=\"2-线程的生命周期\"><a href=\"#2-线程的生命周期\" class=\"headerlink\" title=\"2 线程的生命周期\"></a>2 线程的生命周期</h1><p>【1】线程声明周期：线程开始–》线程消亡<br>【2】线程经历哪些阶段：</p>\n<img data-src=\"/2022/10/07/%E7%AC%AC13%E7%AB%A0%E5%A4%9A%E7%BA%BF%E7%A8%8B/image-20220618195248025.png\" class=\"\">\n\n\n<h1 id=\"3-线程常见方法\"><a href=\"#3-线程常见方法\" class=\"headerlink\" title=\"3 线程常见方法\"></a>3 线程常见方法</h1><p>（1）start() :  启动当前线程，表面上调用start方法，实际在调用线程里面的run方法</p>\n<p>（2）run() : 线程类 继承 Thread类 或者 实现Runnable接口的时候，都要重新实现这个run方法，run方法里面是线程要执行的内容</p>\n<p>（3）currentThread :Thread类中一个静态方法：获取当前正在执行的线程</p>\n<p>（4）setName 设置线程名字</p>\n<p>（5）getName 读取线程名字</p>\n<h2 id=\"设置优先级\"><a href=\"#设置优先级\" class=\"headerlink\" title=\"设置优先级\"></a>设置优先级</h2><p>【1】同优先级别的线程，采取的策略就是先到先服务，使用时间片策略</p>\n<p>【2】如果优先级别高，被CPU调度的概率就高</p>\n<p>【3】级别：1-10   默认的级别为5</p>\n<img data-src=\"/2022/10/07/%E7%AC%AC13%E7%AB%A0%E5%A4%9A%E7%BA%BF%E7%A8%8B/image-20220618195340695.png\" class=\"\">\n\n\n\n\n\n<p>【4】代码：</p>\n<pre><code class=\"java\">public class TestThread01 extends Thread &#123;\n    @Override\n    public void run() &#123;\n        for (int i = 1; i &lt;= 10; i++) &#123;\n            System.out.println(i);\n        &#125;\n    &#125;\n&#125;\nclass TestThread02 extends Thread&#123;\n    @Override\n    public void run() &#123;\n        for (int i = 20; i &lt;= 30 ; i++) &#123;\n            System.out.println(i);\n        &#125;\n    &#125;\n&#125;\nclass Test&#123;\n    //这是main方法，程序的入口\n    public static void main(String[] args) &#123;\n        //创建两个子线程，让这两个子线程争抢资源：\n        TestThread01 t1 = new TestThread01();\n        t1.setPriority(10);//优先级别高\n        t1.start();\n        TestThread02 t2 = new TestThread02();\n        t2.setPriority(1);//优先级别低\n        t2.start();\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"join\"><a href=\"#join\" class=\"headerlink\" title=\"join\"></a>join</h2><p>join方法：当一个线程调用了join方法，这个线程就会先被执行，它执行结束以后才可以去执行其余的线程。</p>\n<blockquote>\n<p>注意：必须先start，再join才有效。</p>\n</blockquote>\n<pre><code class=\"java\">public class TestThread extends Thread &#123;\n    public TestThread(String name)&#123;\n        super(name);\n    &#125;\n    @Override\n    public void run() &#123;\n        for (int i = 1; i &lt;= 10 ; i++) &#123;\n            System.out.println(this.getName()+&quot;----&quot;+i);\n        &#125;\n    &#125;\n&#125;\nclass Test&#123;\n    //这是main方法，程序的入口\n    public static void main(String[] args) throws InterruptedException &#123;\n        for (int i = 1; i &lt;= 100 ; i++) &#123;\n            System.out.println(&quot;main-----&quot;+i);\n            if(i == 6)&#123;\n                //创建子线程：\n                TestThread tt = new TestThread(&quot;子线程&quot;);\n                tt.start();\n                tt.join();//“半路杀出个程咬金”\n            &#125;\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"sleep\"><a href=\"#sleep\" class=\"headerlink\" title=\"sleep\"></a>sleep</h2><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9nby56YmouY29tL25ld3MvMjAxNDYuaHRtbA==\">https://go.zbj.com/news/20146.html</span> （段子）</p>\n<p>【1】sleep : 人为的制造阻塞事件</p>\n<pre><code class=\"java\">public class Test01 &#123;\n    //这是main方法，程序的入口\n    public static void main(String[] args) &#123;\n        try &#123;\n            Thread.sleep(3000);\n        &#125; catch (InterruptedException e) &#123;\n            e.printStackTrace();\n        &#125;\n        System.out.println(&quot;00000000000000&quot;);\n    &#125;\n&#125;\n</code></pre>\n<p>【2】案例：完成秒表功能：</p>\n<pre><code class=\"java\">public class Test02 &#123;\n    //这是main方法，程序的入口\n    public static void main(String[] args) &#123;\n        //2.定义一个时间格式：\n        DateFormat df = new SimpleDateFormat(&quot;HH:mm:ss&quot;);\n        while(true)&#123;\n            //1.获取当前时间：\n            Date d = new Date();\n            //3.按照上面定义的格式将Date类型转为指定格式的字符串：\n            System.out.println(df.format(d));\n            try &#123;\n                Thread.sleep(1000);\n            &#125; catch (InterruptedException e) &#123;\n                e.printStackTrace();\n            &#125;\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"setDaemon\"><a href=\"#setDaemon\" class=\"headerlink\" title=\"setDaemon\"></a>setDaemon</h2><p>【1】设置伴随线程<br>将子线程设置为主线程的伴随线程，主线程停止的时候，子线程也不要继续执行了<br>案例：皇上 –》驾崩 —》妃子陪葬</p>\n<pre><code class=\"java\">public class TestThread extends Thread &#123;\n    @Override\n    public void run() &#123;\n        for (int i = 1; i &lt;= 1000 ; i++) &#123;\n            System.out.println(&quot;子线程----&quot;+i);\n        &#125;\n    &#125;\n&#125;\nclass Test&#123;\n    //这是main方法，程序的入口\n    public static void main(String[] args) &#123;\n        //创建并启动子线程：\n        TestThread tt = new TestThread();\n        tt.setDaemon(true);//设置伴随线程  注意：先设置，再启动\n        tt.start();\n        //主线程中还要输出1-10的数字：\n        for (int i = 1; i &lt;= 10 ; i++) &#123;\n            System.out.println(&quot;main---&quot;+i);\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>结果：</p>\n<img data-src=\"/2022/10/07/%E7%AC%AC13%E7%AB%A0%E5%A4%9A%E7%BA%BF%E7%A8%8B/image-20220618195552686.png\" class=\"\">\n\n\n<h2 id=\"stop\"><a href=\"#stop\" class=\"headerlink\" title=\"stop\"></a>stop</h2><pre><code class=\"java\">public class Demo &#123;\n    //这是main方法，程序的入口\n    public static void main(String[] args) &#123;\n        for (int i = 1; i &lt;= 100 ; i++) &#123;\n            if(i == 6)&#123;\n                Thread.currentThread().stop();//过期方法，不建议使用\n            &#125;\n            System.out.println(i);\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<h1 id=\"4-线程安全问题\"><a href=\"#4-线程安全问题\" class=\"headerlink\" title=\"4 线程安全问题\"></a>4 线程安全问题</h1><h2 id=\"方法1：同步代码块\"><a href=\"#方法1：同步代码块\" class=\"headerlink\" title=\"方法1：同步代码块\"></a>方法1：同步代码块</h2><p>【1】同步代码块演示1：</p>\n<pre><code class=\"java\">package com.msb.test04;\n/**\n * @author : msb-zhaoss\n */\npublic class BuyTicketThread implements Runnable &#123;\n    int ticketNum = 10;\n    @Override\n    public void run() &#123;\n        //此处有1000行代码\n        for (int i = 1; i &lt;= 100 ; i++) &#123;\n            synchronized (this)&#123;//把具有安全隐患的代码锁住即可，如果锁多了就会效率低 --》this就是这个锁\n                if(ticketNum &gt; 0)&#123;\n                    System.out.println(&quot;我在&quot;+Thread.currentThread().getName()+&quot;买到了北京到哈尔滨的第&quot; + ticketNum-- + &quot;张车票&quot;);\n                &#125;\n            &#125;\n        &#125;\n        //此处有1000行代码\n    &#125;\n&#125;\n</code></pre>\n<p>【2】同步代码块演示2：</p>\n<pre><code class=\"java\">public class BuyTicketThread extends Thread &#123;\n    public BuyTicketThread(String name)&#123;\n        super(name);\n    &#125;\n    //一共10张票：\n    static int ticketNum = 10;//多个对象共享10张票\n    //每个窗口都是一个线程对象：每个对象执行的代码放入run方法中\n    @Override\n    public void run() &#123;\n        //每个窗口后面有100个人在抢票：\n        for (int i = 1; i &lt;= 100 ; i++) &#123;\n            synchronized (BuyTicketThread.class)&#123;//锁必须多个线程用的是同一把锁！！！\n                if(ticketNum &gt; 0)&#123;//对票数进行判断，票数大于零我们才抢票\n                    System.out.println(&quot;我在&quot;+this.getName()+&quot;买到了从北京到哈尔滨的第&quot; + ticketNum-- + &quot;张车票&quot;);\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"方法2：同步方法\"><a href=\"#方法2：同步方法\" class=\"headerlink\" title=\"方法2：同步方法\"></a>方法2：同步方法</h2><p>【1】代码展示：</p>\n<pre><code class=\"java\">public class BuyTicketThread implements Runnable &#123;\n    int ticketNum = 10;\n    @Override\n    public void run() &#123;\n        //此处有1000行代码\n        for (int i = 1; i &lt;= 100 ; i++) &#123;\n            buyTicket();\n        &#125;\n        //此处有1000行代码\n    &#125;\n    public synchronized void buyTicket()&#123;//锁住的是this\n        if(ticketNum &gt; 0)&#123;\n            System.out.println(&quot;我在&quot;+Thread.currentThread().getName()+&quot;买到了北京到哈尔滨的第&quot; + ticketNum-- + &quot;张车票&quot;);\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<pre><code class=\"java\">public class BuyTicketThread extends Thread &#123;\n    public BuyTicketThread(String name)&#123;\n        super(name);\n    &#125;\n    //一共10张票：\n    static int ticketNum = 10;//多个对象共享10张票\n    //每个窗口都是一个线程对象：每个对象执行的代码放入run方法中\n    @Override\n    public void run() &#123;\n        //每个窗口后面有100个人在抢票：\n        for (int i = 1; i &lt;= 100 ; i++) &#123;\n            buyTicket();\n        &#125;\n    &#125;\n    public static synchronized void buyTicket()&#123;//锁住的  同步监视器： BuyTicketThread.class\n        if(ticketNum &gt; 0)&#123;//对票数进行判断，票数大于零我们才抢票\n            System.out.println(&quot;我在&quot;+Thread.currentThread().getName()+&quot;买到了从北京到哈尔滨的第&quot; + ticketNum-- + &quot;张车票&quot;);\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>【2】总结：<br>总结1：<br>多线程在争抢资源，就要实现线程的同步（就要进行加锁，并且这个锁必须是共享的，必须是唯一的。<br>咱们的锁一般都是引用数据类型的。</p>\n<p>目的：解决了线程安全问题。</p>\n<p>总结2：关于同步方法</p>\n<ol>\n<li>不要将run()定义为同步方法</li>\n<li>非静态同步方法的同步监视器是this<br>静态同步方法的同步监视器是 类名.class 字节码信息对象</li>\n<li>同步代码块的效率要高于同步方法<br>原因：同步方法是将线程挡在了方法的外部，而同步代码块锁将线程挡在了代码块的外部，但是却是方法的内部</li>\n<li>同步方法的锁是this，一旦锁住一个方法，就锁住了所有的同步方法；同步代码块只是锁住使用该同步监视器的代码块，而没有锁住使用其他监视器的代码块</li>\n</ol>\n<h2 id=\"方法3：Lock锁\"><a href=\"#方法3：Lock锁\" class=\"headerlink\" title=\"方法3：Lock锁\"></a>方法3：Lock锁</h2><p>【1】Lock锁引入：<br>JDK1.5后新增新一代的线程同步方式:Lock锁<br>与采用synchronized相比，lock可提供多种锁方案，更灵活</p>\n<p>synchronized是Java中的关键字，这个关键字的识别是靠JVM来识别完成的呀。是虚拟机级别的。<br>但是Lock锁是API级别的，提供了相应的接口和对应的实现类，这个方式更灵活，表现出来的性能优于之前的方式。</p>\n<p>【2】代码演示：</p>\n<pre><code class=\"java\">public class BuyTicketThread implements Runnable &#123;\n    int ticketNum = 10;\n    //拿来一把锁：\n    Lock lock = new ReentrantLock();//多态  接口=实现类  可以使用不同的实现类\n    @Override\n    public void run() &#123;\n        //此处有1000行代码\n        for (int i = 1; i &lt;= 100 ; i++) &#123;\n            //打开锁：\n            lock.lock();\n            try&#123;\n                if(ticketNum &gt; 0)&#123;\n                    System.out.println(&quot;我在&quot;+Thread.currentThread().getName()+&quot;买到了北京到哈尔滨的第&quot; + ticketNum-- + &quot;张车票&quot;);\n                &#125;\n            &#125;catch (Exception ex)&#123;\n                ex.printStackTrace();\n            &#125;finally &#123;\n                //关闭锁：---&gt;即使有异常，这个锁也可以得到释放\n                lock.unlock();\n            &#125;\n        &#125;\n        //此处有1000行代码\n    &#125;\n&#125;\n</code></pre>\n<p>【3】 Lock和synchronized的区别</p>\n<pre><code>    1.Lock是显式锁（手动开启和关闭锁，别忘记关闭锁），synchronized是隐式锁\n    2.Lock只有代码块锁，synchronized有代码块锁和方法锁\n    3.使用Lock锁，JVM将花费较少的时间来调度线程，性能更好。并且具有更好的扩展性（提供更多的子类）\n</code></pre>\n<p>【4】优先使用顺序：</p>\n<pre><code>    Lock----同步代码块（已经进入了方法体，分配了相应资源）----同步方法（在方法体之外）\n</code></pre>\n<h2 id=\"线程同步的优缺点\"><a href=\"#线程同步的优缺点\" class=\"headerlink\" title=\"线程同步的优缺点\"></a>线程同步的优缺点</h2><p>【1】对比：<br>线程安全，效率低<br>线程不安全，效率高</p>\n<p>【2】可能造成死锁：<br>死锁</p>\n<blockquote>\n<p>不同的线程分别占用对方需要的同步资源不放弃，都在等待对方放弃自己需要的同步资源，就形成了线程的死锁<br>出现死锁后，不会出现异常，不会出现提示，只是所有的线程都处于阻塞状态，无法继续</p>\n</blockquote>\n<p>【3】代码演示：</p>\n<pre><code class=\"java\">public class TestDeadLock implements Runnable &#123;\n    public int flag = 1;\n    static Object o1 = new Object(),o2 = new Object();\n        \n        \n    public void run()&#123;\n        System.out.println(&quot;flag=&quot; + flag);\n        // 当flag==1锁住o1\n        if (flag == 1) &#123;\n            synchronized (o1) &#123;\n                try &#123;\n                    Thread.sleep(500);\n                &#125; catch (Exception e) &#123;\n                    e.printStackTrace();\n                &#125;\n                // 只要锁住o2就完成\n                synchronized (o2) &#123;\n                    System.out.println(&quot;2&quot;);\n                &#125;\n            &#125;\n        &#125;\n        // 如果flag==0锁住o2\n        if (flag == 0) &#123;\n            synchronized (o2) &#123;\n                try &#123;\n                    Thread.sleep(500);\n                &#125; catch (Exception e) &#123;\n                    e.printStackTrace();\n                &#125;\n                // 只要锁住o1就完成\n                synchronized (o1) &#123;\n                    System.out.println(&quot;3&quot;);\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n        \n        \n    public static void main(String[] args) &#123;\n        // 实例2个线程类\n        TestDeadLock td1 = new TestDeadLock();\n        TestDeadLock td2 = new TestDeadLock();\n        td1.flag = 1;\n        td2.flag = 0;\n        // 开启2个线程\n        Thread t1 = new Thread(td1);\n        Thread t2 = new Thread(td2);\n        t1.start();\n        t2.start();\n    &#125;\n&#125;\n</code></pre>\n<p>【4】解决方法： 减少同步资源的定义，避免嵌套同步</p>\n<h1 id=\"5-线程通信问题\"><a href=\"#5-线程通信问题\" class=\"headerlink\" title=\"5 线程通信问题\"></a>5 线程通信问题</h1><p>应用场景：生产者和消费者问题<br>假设仓库中只能存放一件产品，生产者将生产出来的产品放入仓库，消费者将仓库中产品取走消费<br>如果仓库中没有产品，则生产者将产品放入仓库，否则停止生产并等待，直到仓库中的产品被消费者取走为止<br>如果仓库中放有产品，则消费者可以将产品取走消费，否则停止消费并等待，直到仓库中再次放入产品为止</p>\n<img data-src=\"/2022/10/07/%E7%AC%AC13%E7%AB%A0%E5%A4%9A%E7%BA%BF%E7%A8%8B/image-20220618200150740.png\" class=\"\">\n\n\n<p>代码结果展示：</p>\n<img data-src=\"/2022/10/07/%E7%AC%AC13%E7%AB%A0%E5%A4%9A%E7%BA%BF%E7%A8%8B/image-20220618200157334.png\" class=\"\">\n\n\n<p>代码：<br>1.商品：属性：品牌 ，名字<br>2.线程1：生产者<br>3.线程2：消费者</p>\n<h2 id=\"分解1\"><a href=\"#分解1\" class=\"headerlink\" title=\"分解1\"></a>分解1</h2><p>出现问题：<br>1.生产者和消费者没有交替输出</p>\n<p>2.打印数据错乱<br>哈尔滨 - null<br>费列罗啤酒<br>哈尔滨巧克力<br>—-没有加同步</p>\n<p>代码展示：</p>\n<pre><code class=\"java\">public class Product &#123;//商品类\n    //品牌\n    private String brand;\n    //名字\n    private String name;\n    //setter,getter方法；\n    public String getBrand() &#123;\n        return brand;\n    &#125;\n    public void setBrand(String brand) &#123;\n        this.brand = brand;\n    &#125;\n    public String getName() &#123;\n        return name;\n    &#125;\n    public void setName(String name) &#123;\n        this.name = name;\n    &#125;\n&#125;\n</code></pre>\n<pre><code class=\"java\">public class ProducerThread extends Thread&#123;//生产者线程\n    //共享商品：\n    private Product p;\n    public ProducerThread(Product p) &#123;\n        this.p = p;\n    &#125;\n    @Override\n    public void run() &#123;\n        for (int i = 1; i &lt;= 10 ; i++) &#123;//生产十个商品 i:生产的次数\n            if(i % 2 == 0)&#123;\n                //生产费列罗巧克力\n                p.setBrand(&quot;费列罗&quot;);\n                try &#123;\n                    Thread.sleep(100);\n                &#125; catch (InterruptedException e) &#123;\n                    e.printStackTrace();\n                &#125;\n                p.setName(&quot;巧克力&quot;);\n            &#125;else&#123;\n                //生产哈尔滨啤酒\n                p.setBrand(&quot;哈尔滨&quot;);\n                try &#123;\n                    Thread.sleep(100);\n                &#125; catch (InterruptedException e) &#123;\n                    e.printStackTrace();\n                &#125;\n                p.setName(&quot;啤酒&quot;);\n            &#125;\n            //将生产信息做一个打印：\n            System.out.println(&quot;生产者生产了：&quot; + p.getBrand() + &quot;---&quot; + p.getName());\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<pre><code class=\"java\">public class CustomerThread extends Thread&#123;//消费者线程\n    //共享商品：\n    private Product p;\n    public CustomerThread(Product p) &#123;\n        this.p = p;\n    &#125;\n    @Override\n    public void run() &#123;\n        for (int i = 1; i &lt;= 10 ; i++) &#123;//i:消费次数\n            System.out.println(&quot;消费者消费了：&quot; + p.getBrand() + &quot;---&quot; + p.getName());\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"分解2\"><a href=\"#分解2\" class=\"headerlink\" title=\"分解2\"></a>分解2</h2><p>【1】利用同步代码块解决问题：</p>\n<pre><code class=\"java\">public class ProducerThread extends Thread&#123;//生产者线程\n    //共享商品：\n    private Product p;\n    public ProducerThread(Product p) &#123;\n        this.p = p;\n    &#125;\n    @Override\n    public void run() &#123;\n        for (int i = 1; i &lt;= 10 ; i++) &#123;//生产十个商品 i:生产的次数\n            synchronized (p)&#123;\n                if(i % 2 == 0)&#123;\n                    //生产费列罗巧克力\n                    p.setBrand(&quot;费列罗&quot;);\n                    try &#123;\n                        Thread.sleep(100);\n                    &#125; catch (InterruptedException e) &#123;\n                        e.printStackTrace();\n                    &#125;\n                    p.setName(&quot;巧克力&quot;);\n                &#125;else&#123;\n                    //生产哈尔滨啤酒\n                    p.setBrand(&quot;哈尔滨&quot;);\n                    try &#123;\n                        Thread.sleep(100);\n                    &#125; catch (InterruptedException e) &#123;\n                        e.printStackTrace();\n                    &#125;\n                    p.setName(&quot;啤酒&quot;);\n                &#125;\n                //将生产信息做一个打印：\n                System.out.println(&quot;生产者生产了：&quot; + p.getBrand() + &quot;---&quot; + p.getName());\n            &#125;\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<pre><code class=\"java\">public class CustomerThread extends Thread&#123;//消费者线程\n    //共享商品：\n    private Product p;\n    public CustomerThread(Product p) &#123;\n        this.p = p;\n    &#125;\n    @Override\n    public void run() &#123;\n        for (int i = 1; i &lt;= 10 ; i++) &#123;//i:消费次数\n            synchronized (p)&#123;\n                System.out.println(&quot;消费者消费了：&quot; + p.getBrand() + &quot;---&quot; + p.getName());\n            &#125;\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>【2】利用同步方法解决问题：</p>\n<pre><code class=\"java\">public class Product &#123;//商品类\n    //品牌\n    private String brand;\n    //名字\n    private String name;\n    //setter,getter方法；\n    public String getBrand() &#123;\n        return brand;\n    &#125;\n    public void setBrand(String brand) &#123;\n        this.brand = brand;\n    &#125;\n    public String getName() &#123;\n        return name;\n    &#125;\n    public void setName(String name) &#123;\n        this.name = name;\n    &#125;\n    //生产商品\n    public synchronized void setProduct(String brand,String name)&#123;\n        this.setBrand(brand);\n        try &#123;\n            Thread.sleep(100);\n        &#125; catch (InterruptedException e) &#123;\n            e.printStackTrace();\n        &#125;\n        this.setName(name);\n        //将生产信息做一个打印：\n        System.out.println(&quot;生产者生产了：&quot; + this.getBrand() + &quot;---&quot; + this.getName());\n    &#125;\n    //消费商品：\n    public synchronized void getProduct()&#123;\n        System.out.println(&quot;消费者消费了：&quot; + this.getBrand() + &quot;---&quot; + this.getName());\n    &#125;\n&#125;\n</code></pre>\n<pre><code class=\"java\">public class CustomerThread extends Thread&#123;//消费者线程\n    //共享商品：\n    private Product p;\n    public CustomerThread(Product p) &#123;\n        this.p = p;\n    &#125;\n    @Override\n    public void run() &#123;\n        for (int i = 1; i &lt;= 10 ; i++) &#123;//i:消费次数\n            p.getProduct();;\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<pre><code class=\"java\">public class ProducerThread extends Thread&#123;//生产者线程\n    //共享商品：\n    private Product p;\n    public ProducerThread(Product p) &#123;\n        this.p = p;\n    &#125;\n    @Override\n    public void run() &#123;\n        for (int i = 1; i &lt;= 10 ; i++) &#123;//生产十个商品 i:生产的次数\n            if(i % 2 == 0)&#123;\n                p.setProduct(&quot;费列罗&quot;,&quot;巧克力&quot;);\n            &#125;else&#123;\n                p.setProduct(&quot;哈尔滨&quot;,&quot;啤酒&quot;);\n            &#125;\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>（这个else中的代码在分解3中 演示了错误）</p>\n<h2 id=\"分解3\"><a href=\"#分解3\" class=\"headerlink\" title=\"分解3\"></a>分解3</h2><p>【1】原理：</p>\n<img data-src=\"/2022/10/07/%E7%AC%AC13%E7%AB%A0%E5%A4%9A%E7%BA%BF%E7%A8%8B/image-20220618200412158.png\" class=\"\">\n\n\n\n<p>【2】代码：</p>\n<pre><code class=\"java\">public class Product &#123;//商品类\n    //品牌\n    private String brand;\n    //名字\n    private String name;\n    //引入一个灯：true:红色  false 绿色\n    boolean flag = false;//默认情况下没有商品 让生产者先生产  然后消费者再消费\n    //setter,getter方法；\n    public String getBrand() &#123;\n        return brand;\n    &#125;\n    public void setBrand(String brand) &#123;\n        this.brand = brand;\n    &#125;\n    public String getName() &#123;\n        return name;\n    &#125;\n    public void setName(String name) &#123;\n        this.name = name;\n    &#125;\n    //生产商品\n    public synchronized void setProduct(String brand,String name)&#123;\n        if(flag == true)&#123;//灯是红色，证明有商品，生产者不生产，等着消费者消费\n            try &#123;\n                wait();\n            &#125; catch (InterruptedException e) &#123;\n                e.printStackTrace();\n            &#125;\n        &#125;\n        //灯是绿色的，就生产：\n        this.setBrand(brand);\n        try &#123;\n            Thread.sleep(100);\n        &#125; catch (InterruptedException e) &#123;\n            e.printStackTrace();\n        &#125;\n        this.setName(name);\n        //将生产信息做一个打印：\n        System.out.println(&quot;生产者生产了：&quot; + this.getBrand() + &quot;---&quot; + this.getName());\n        //生产完以后，灯变色：变成红色：\n        flag = true;\n        //告诉消费者赶紧来消费：\n        notify();\n    &#125;\n    //消费商品：\n    public synchronized void getProduct()&#123;\n        if(!flag)&#123;//flag == false没有商品，等待生产者生产：\n            try &#123;\n                wait();\n            &#125; catch (InterruptedException e) &#123;\n                e.printStackTrace();\n            &#125;\n        &#125;\n        //有商品，消费：\n        System.out.println(&quot;消费者消费了：&quot; + this.getBrand() + &quot;---&quot; + this.getName());\n        //消费完：灯变色：\n        flag = false;\n        //通知生产者生产：\n        notify();\n    &#125;\n&#125;\n</code></pre>\n<p>【3】原理：</p>\n<img data-src=\"/2022/10/07/%E7%AC%AC13%E7%AB%A0%E5%A4%9A%E7%BA%BF%E7%A8%8B/image-20220618200442747.png\" class=\"\">\n\n\n<p>注意：wait方法和notify方法  是必须放在同步方法或者同步代码块中才生效的 （因为在同步的基础上进行线程的通信才是有效的）<br>注意：sleep和wait的区别：sleep进入阻塞状态没有释放锁，wait进入阻塞状态但是同时释放了锁<br>【4】线程生命周期完整图：</p>\n<img data-src=\"/2022/10/07/%E7%AC%AC13%E7%AB%A0%E5%A4%9A%E7%BA%BF%E7%A8%8B/image-20220618200450798.png\" class=\"\">\n\n\n<h2 id=\"Loc锁情况下的线程通信\"><a href=\"#Loc锁情况下的线程通信\" class=\"headerlink\" title=\"Loc锁情况下的线程通信\"></a>Loc锁情况下的线程通信</h2><p>Condition是在Java 1.5中才出现的，它用来替代传统的Object的wait()、notify()实现线程间的协作，相比使用Object的wait()、notify()，使用Condition1的await()、signal()这种方式实现线程间协作更加安全和高效。</p>\n<p>它的更强大的地方在于：能够更加精细的控制多线程的休眠与唤醒。对于同一个锁，我们可以创建多个Condition，在不同的情况下使用不同的Condition</p>\n<p>一个Condition包含一个等待队列。一个Lock可以产生多个Condition，所以可以有多个等待队列。</p>\n<p>在Object的监视器模型上，一个对象拥有一个同步队列和等待队列，<font color=\"red\">而Lock（同步器）拥有一个同步队列和多个等待队列</font>。</p>\n<p>Object中的wait(),notify(),notifyAll()方法是和”同步锁”(synchronized关键字)捆绑使用的；而Condition是需要与”互斥锁”&#x2F;“共享锁”捆绑使用的。</p>\n<p>调用Condition的await()、signal()、signalAll()方法，都必须在lock保护之内，<font color=\"red\">就是说必须在lock.lock()和lock.unlock之间才可以使用 </font></p>\n<p>· Conditon中的await()对应Object的wait()；</p>\n<p>· Condition中的signal()对应Object的notify()；<br>· Condition中的signalAll()对应Object的notifyAll()。</p>\n<p>void await()  throws InterruptedException</p>\n<p>造成当前线程在接到信号或被中断之前一直处于等待状态。</p>\n<p>与此 Condition 相关的锁以原子方式释放，并且出于线程调度的目的，将禁用当前线程，且在发生以下四种情况之一 以前，当前线程将一直处于休眠状态：</p>\n<p>· 其他某个线程调用此 Condition 的 signal() 方法，并且碰巧将当前线程选为被唤醒的线程；或者<br>· 其他某个线程调用此 Condition 的 signalAll() 方法；或者<br>· 其他某个线程中断当前线程，且支持中断线程的挂起；或者<br>· 发生“虚假唤醒”</p>\n<p>在所有情况下，在此方法可以返回当前线程之前，都必须重新获取与此条件有关的锁。在线程返回时，可以保证它保持此锁。</p>\n<p>void <strong>signal()</strong></p>\n<p>唤醒一个等待线程。</p>\n<p>如果所有的线程都在等待此条件，则选择其中的一个唤醒。在从 await 返回之前，该线程必须重新获取锁。</p>\n<p>void <strong>signalAll()</strong></p>\n<p>唤醒所有等待线程。</p>\n<p>如果所有的线程都在等待此条件，则唤醒所有线程。在从 await 返回之前，每个线程都必须重新获取锁。</p>\n<p>更改代码：</p>\n<img data-src=\"/2022/10/07/%E7%AC%AC13%E7%AB%A0%E5%A4%9A%E7%BA%BF%E7%A8%8B/image-20220618200641119.png\" class=\"\">\n\n\n<pre><code class=\"java\">public class Product &#123;//商品类\n    //品牌\n    private String brand;\n    //名字\n    private String name;\n    //声明一个Lock锁：\n    Lock lock = new ReentrantLock();\n    //搞一个生产者的等待队列：\n    Condition produceCondition = lock.newCondition();\n    //搞一个消费者的等待队列：\n    Condition consumeCondition = lock.newCondition();\n    //引入一个灯：true:红色  false 绿色\n    boolean flag = false;//默认情况下没有商品 让生产者先生产  然后消费者再消费\n    //setter,getter方法；\n    public String getBrand() &#123;\n        return brand;\n    &#125;\n    public void setBrand(String brand) &#123;\n        this.brand = brand;\n    &#125;\n    public String getName() &#123;\n        return name;\n    &#125;\n    public void setName(String name) &#123;\n        this.name = name;\n    &#125;\n    //生产商品\n    public void setProduct(String brand,String name)&#123;\n        lock.lock();\n        try&#123;\n            if(flag == true)&#123;//灯是红色，证明有商品，生产者不生产，等着消费者消费\n                try &#123;\n                    //wait();\n                    //生产者阻塞，生产者进入等待队列中\n                    produceCondition.await();\n                &#125; catch (InterruptedException e) &#123;\n                    e.printStackTrace();\n                &#125;\n            &#125;\n            //灯是绿色的，就生产：\n            this.setBrand(brand);\n            try &#123;\n                Thread.sleep(100);\n            &#125; catch (InterruptedException e) &#123;\n                e.printStackTrace();\n            &#125;\n            this.setName(name);\n            //将生产信息做一个打印：\n            System.out.println(&quot;生产者生产了：&quot; + this.getBrand() + &quot;---&quot; + this.getName());\n            //生产完以后，灯变色：变成红色：\n            flag = true;\n            //告诉消费者赶紧来消费：\n            //notify();\n            consumeCondition.signal();\n        &#125;finally &#123;\n            lock.unlock();\n        &#125;\n    &#125;\n    //消费商品：\n    public void getProduct()&#123;\n        lock.lock();\n        try&#123;\n            if(!flag)&#123;//flag == false没有商品，等待生产者生产：\n                try &#123;\n                   // wait();\n                    //消费者等待，消费者线程进入等待队列：\n                    consumeCondition.await();\n                &#125; catch (InterruptedException e) &#123;\n                    e.printStackTrace();\n                &#125;\n            &#125;\n            //有商品，消费：\n            System.out.println(&quot;消费者消费了：&quot; + this.getBrand() + &quot;---&quot; + this.getName());\n            //消费完：灯变色：\n            flag = false;\n            //通知生产者生产：\n            //notify();\n            produceCondition.signal();\n        &#125;finally &#123;\n            lock.unlock();\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<h1 id=\"未完成！！！！！！！！！！\"><a href=\"#未完成！！！！！！！！！！\" class=\"headerlink\" title=\"未完成！！！！！！！！！！\"></a>未完成！！！！！！！！！！</h1>",
            "tags": [
                "JavaSE"
            ]
        }
    ]
}