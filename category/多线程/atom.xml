<?xml version="1.0"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>http://example.com</id>
    <title>记录“美食”每刻 • Posts by &#34;多线程&#34; category</title>
    <link href="http://example.com" />
    <updated>2022-10-06T16:00:00.000Z</updated>
    <category term="博客" />
    <category term="环境搭建" />
    <category term="分布式" />
    <category term="Dubbo" />
    <category term="FastDFS" />
    <category term="MySQL" />
    <category term="数据库基础" />
    <category term="数据库基本知识" />
    <category term="数据库" />
    <category term="框架" />
    <category term="ORM" />
    <category term="RPC" />
    <category term="中间件" />
    <category term="RabbitMQ" />
    <category term="Redis基础" />
    <category term="NoSQL数据库" />
    <category term="Solr" />
    <category term="快速搜索" />
    <category term="Spring" />
    <category term="SpringBoot" />
    <category term="SpringMVC" />
    <category term="SpringSecurity" />
    <category term="JavaSE" />
    <category term="-JavaSE" />
    <entry>
        <id>http://example.com/2022/10/07/%E7%AC%AC13%E7%AB%A0%E5%A4%9A%E7%BA%BF%E7%A8%8B/</id>
        <title>第13章多线程</title>
        <link rel="alternate" href="http://example.com/2022/10/07/%E7%AC%AC13%E7%AB%A0%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
        <content type="html">&lt;h1 id=&#34;简介&#34;&gt;&lt;a href=&#34;#简介&#34; class=&#34;headerlink&#34; title=&#34;简介&#34;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;【1】程序，进程，线程&lt;br&gt;➢程序(program)：是为完成特定任务、用某种语言编写的一组指令的集合,是一段静态的代码。 （程序是静态的）&lt;/p&gt;
&lt;p&gt;➢进程(process)：是程序的一次执行过程。正在运行的一个程序，进程作为资源分配的单位，在内存中会为每个进程分配不同的内存区域。 （进程是动态的）是一个动的过程 ，进程的生命周期  :  有它自身的产生、存在和消亡的过程&lt;/p&gt;
&lt;p&gt;➢线程(thread)，进程可进一步细化为线程， 是一个程序内部的一条执行路径。&lt;br&gt;若一个进程同一时间并行执行多个线程，就是支持多线程的。&lt;/p&gt;
&lt;img data-src=&#34;/2022/10/07/%E7%AC%AC13%E7%AB%A0%E5%A4%9A%E7%BA%BF%E7%A8%8B/image-20220618194135831.png&#34; class=&#34;&#34;&gt;



&lt;p&gt;【2】单核CPU与多核CPU的任务执行：&lt;/p&gt;
&lt;img data-src=&#34;/2022/10/07/%E7%AC%AC13%E7%AB%A0%E5%A4%9A%E7%BA%BF%E7%A8%8B/image-20220618194141865.png&#34; class=&#34;&#34;&gt;


&lt;img data-src=&#34;/2022/10/07/%E7%AC%AC13%E7%AB%A0%E5%A4%9A%E7%BA%BF%E7%A8%8B/image-20220618194149206.png&#34; class=&#34;&#34;&gt;




&lt;p&gt;【3】并行和并发：&lt;br&gt;并行：多个CPU同时执行多个任务&lt;br&gt;并发：一个CPU“同时”执行多个任务（采用时间片切换）&lt;/p&gt;
&lt;h1 id=&#34;1-创建线程的三种方式&#34;&gt;&lt;a href=&#34;#1-创建线程的三种方式&#34; class=&#34;headerlink&#34; title=&#34;1 创建线程的三种方式&#34;&gt;&lt;/a&gt;1 创建线程的三种方式&lt;/h1&gt;&lt;h2 id=&#34;第一种：继承Thread类&#34;&gt;&lt;a href=&#34;#第一种：继承Thread类&#34; class=&#34;headerlink&#34; title=&#34;第一种：继承Thread类&#34;&gt;&lt;/a&gt;第一种：继承Thread类&lt;/h2&gt;&lt;p&gt;【1】在学习多线程一章之前，以前的代码是单线程的吗？不是，以前也是有三个线程同时执行的。&lt;/p&gt;
&lt;img data-src=&#34;/2022/10/07/%E7%AC%AC13%E7%AB%A0%E5%A4%9A%E7%BA%BF%E7%A8%8B/image-20220618194435926.png&#34; class=&#34;&#34;&gt;


&lt;p&gt;【2】现在我想自己制造多线程—》创建线程 ？？&lt;br&gt;线程类–》线程对象&lt;/p&gt;
&lt;img data-src=&#34;/2022/10/07/%E7%AC%AC13%E7%AB%A0%E5%A4%9A%E7%BA%BF%E7%A8%8B/image-20220618194442238.png&#34; class=&#34;&#34;&gt;


&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;/**
 * 线程类叫：TestThread，不是说你名字中带线程单词你就具备多线程能力了（争抢资源能力）
 * 现在想要具备能力，继承一个类：Thread，具备了争抢资源的能力
 */
public class TestThread extends Thread&amp;#123;
    /*
    一会线程对象就要开始争抢资源了，这个线程要执行的任务到底是啥？这个任务你要放在方法中
    但是这个方法不能是随便写的一个方法，必须是重写Thread类中的run方法
    然后线程的任务/逻辑写在run方法中
     */
    @Override
    public void run() &amp;#123;
        //输出1-10
        for (int i = 1; i &amp;lt;= 10 ; i++) &amp;#123;
            System.out.println(i);
        &amp;#125;
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;public class Test &amp;#123;
    //这是main方法，程序的入口
    public static void main(String[] args) &amp;#123;
        //主线程中也要输出十个数：
        for (int i = 1; i &amp;lt;= 10 ; i++) &amp;#123;
            System.out.println(&amp;quot;main1-----&amp;quot;+i);
        &amp;#125;
        //制造其他线程，要跟主线程争抢资源：
        //具体的线程对象：子线程
        TestThread tt = new TestThread();
        //tt.run();//调用run方法，想要执行线程中的任务 --&amp;gt;这个run方法不能直接调用，直接调用就会被当做一个普通方法
        //想要tt子线程真正起作用比如要启动线程：
        tt.start();//start()是Thread类中的方法
        //主线程中也要输出十个数：
        for (int i = 1; i &amp;lt;= 10 ; i++) &amp;#123;
            System.out.println(&amp;quot;main2-----&amp;quot;+i);
        &amp;#125;
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;img data-src=&#34;/2022/10/07/%E7%AC%AC13%E7%AB%A0%E5%A4%9A%E7%BA%BF%E7%A8%8B/image-20220618194526775.png&#34; class=&#34;&#34;&gt;


&lt;h3 id=&#34;设置读取线程名字&#34;&gt;&lt;a href=&#34;#设置读取线程名字&#34; class=&#34;headerlink&#34; title=&#34;设置读取线程名字&#34;&gt;&lt;/a&gt;设置读取线程名字&lt;/h3&gt;&lt;p&gt;【1】setName,getName方法来进行设置读取：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;/**
 * 线程类叫：TestThread，不是说你名字中带线程单词你就具备多线程能力了（争抢资源能力）
 * 现在想要具备能力，继承一个类：Thread，具备了争抢资源的能力
 */
public class TestThread extends Thread&amp;#123;
    /*
    一会线程对象就要开始争抢资源了，这个线程要执行的任务到底是啥？这个任务你要放在方法中
    但是这个方法不能是随便写的一个方法，必须是重写Thread类中的run方法
    然后线程的任务/逻辑写在run方法中
     */
    @Override
    public void run() &amp;#123;
        //输出1-10
        for (int i = 1; i &amp;lt;= 10 ; i++) &amp;#123;
            System.out.println(this.getName()+i);
        &amp;#125;
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;public class Test &amp;#123;
    //这是main方法，程序的入口
    public static void main(String[] args) &amp;#123;
        //给main方法这个主线程设置名字：
        //Thread.currentThread()作用获取当前正在执行的线程
        Thread.currentThread().setName(&amp;quot;主线程&amp;quot;);
        //主线程中也要输出十个数：
        for (int i = 1; i &amp;lt;= 10 ; i++) &amp;#123;
            System.out.println(Thread.currentThread().getName()+&amp;quot;1-------&amp;quot;+i);
        &amp;#125;
        //制造其他线程，要跟主线程争抢资源：
        //具体的线程对象：子线程
        TestThread tt = new TestThread();
        tt.setName(&amp;quot;子线程&amp;quot;);
        //tt.run();//调用run方法，想要执行线程中的任务 --&amp;gt;这个run方法不能直接调用，直接调用就会被当做一个普通方法
        //想要tt子线程真正起作用比如要启动线程：
        tt.start();//start()是Thread类中的方法
        //主线程中也要输出十个数：
        for (int i = 1; i &amp;lt;= 10 ; i++) &amp;#123;
            System.out.println(Thread.currentThread().getName()+&amp;quot;2-------&amp;quot;+i);
        &amp;#125;
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;【2】通过构造器设置 名字：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;/**
 * 线程类叫：TestThread，不是说你名字中带线程单词你就具备多线程能力了（争抢资源能力）
 * 现在想要具备能力，继承一个类：Thread，具备了争抢资源的能力
 */
public class TestThread extends Thread&amp;#123;
    public TestThread(String name)&amp;#123;
        super(name);//调用父类的有参构造器
    &amp;#125;
    /*
    一会线程对象就要开始争抢资源了，这个线程要执行的任务到底是啥？这个任务你要放在方法中
    但是这个方法不能是随便写的一个方法，必须是重写Thread类中的run方法
    然后线程的任务/逻辑写在run方法中
     */
    @Override
    public void run() &amp;#123;
        //输出1-10
        for (int i = 1; i &amp;lt;= 10 ; i++) &amp;#123;
            System.out.println(this.getName()+i);
        &amp;#125;
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;习题：买火车票&#34;&gt;&lt;a href=&#34;#习题：买火车票&#34; class=&#34;headerlink&#34; title=&#34;习题：买火车票&#34;&gt;&lt;/a&gt;习题：买火车票&lt;/h3&gt;&lt;p&gt;【1】原理：每个窗口都是一个线程对象：&lt;/p&gt;
&lt;img data-src=&#34;/2022/10/07/%E7%AC%AC13%E7%AB%A0%E5%A4%9A%E7%BA%BF%E7%A8%8B/image-20220618194717605.png&#34; class=&#34;&#34;&gt;





&lt;p&gt;【2】代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;public class BuyTicketThread extends Thread &amp;#123;
    public BuyTicketThread(String name)&amp;#123;
        super(name);
    &amp;#125;
    //一共10张票：
    static int ticketNum = 10;//多个对象共享10张票
    //每个窗口都是一个线程对象：每个对象执行的代码放入run方法中
    @Override
    public void run() &amp;#123;
        //每个窗口后面有100个人在抢票：
        for (int i = 1; i &amp;lt;= 100 ; i++) &amp;#123;
            if(ticketNum &amp;gt; 0)&amp;#123;//对票数进行判断，票数大于零我们才抢票
                System.out.println(&amp;quot;我在&amp;quot;+this.getName()+&amp;quot;买到了从北京到哈尔滨的第&amp;quot; + ticketNum-- + &amp;quot;张车票&amp;quot;);
            &amp;#125;
        &amp;#125;
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;public class Test &amp;#123;
    public static void main(String[] args) &amp;#123;
        //多个窗口抢票：三个窗口三个线程对象：
        BuyTicketThread t1 = new BuyTicketThread(&amp;quot;窗口1&amp;quot;);
        t1.start();
        BuyTicketThread t2 = new BuyTicketThread(&amp;quot;窗口2&amp;quot;);
        t2.start();
        BuyTicketThread t3 = new BuyTicketThread(&amp;quot;窗口3&amp;quot;);
        t3.start();
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;第二种：实现Runnable接口&#34;&gt;&lt;a href=&#34;#第二种：实现Runnable接口&#34; class=&#34;headerlink&#34; title=&#34;第二种：实现Runnable接口&#34;&gt;&lt;/a&gt;第二种：实现Runnable接口&lt;/h2&gt;&lt;p&gt;【1】代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;/**
 * TestThread实现了这个接口，才会变成一个线程类
 */
public class TestThread implements Runnable&amp;#123;
    @Override
    public void run() &amp;#123;
        //输出1-10数字：
        for (int i = 1; i &amp;lt;= 10 ; i++) &amp;#123;
            System.out.println(Thread.currentThread().getName()+&amp;quot;----&amp;quot;+i);
        &amp;#125;
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;public class Test &amp;#123;
    public static void main(String[] args) &amp;#123;
        //创建子线程对象：
        TestThread tt = new TestThread();
        Thread t = new Thread(tt,&amp;quot;子线程&amp;quot;);
        t.start();
        //主线程里面也是打印1-10数字：
        for (int i = 1; i &amp;lt;= 10 ; i++) &amp;#123;
            System.out.println(Thread.currentThread().getName()+&amp;quot;---&amp;quot;+i);
        &amp;#125;
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;img data-src=&#34;/2022/10/07/%E7%AC%AC13%E7%AB%A0%E5%A4%9A%E7%BA%BF%E7%A8%8B/image-20220618194854683.png&#34; class=&#34;&#34;&gt;


&lt;h3 id=&#34;习题：买火车票-1&#34;&gt;&lt;a href=&#34;#习题：买火车票-1&#34; class=&#34;headerlink&#34; title=&#34;习题：买火车票&#34;&gt;&lt;/a&gt;习题：买火车票&lt;/h3&gt;&lt;p&gt;【1】代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;public class BuyTicketThread implements Runnable &amp;#123;
    int ticketNum = 10;
    @Override
    public void run() &amp;#123;
        for (int i = 1; i &amp;lt;= 100 ; i++) &amp;#123;
            if(ticketNum &amp;gt; 0)&amp;#123;
                System.out.println(&amp;quot;我在&amp;quot;+Thread.currentThread().getName()+&amp;quot;买到了北京到哈尔滨的第&amp;quot; + ticketNum-- + &amp;quot;张车票&amp;quot;);
            &amp;#125;
        &amp;#125;
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;public class Test &amp;#123;
    //这是main方法，程序的入口
    public static void main(String[] args) &amp;#123;
        //定义一个线程对象：
        BuyTicketThread t = new BuyTicketThread();
        //窗口1买票：
        Thread t1 = new Thread(t,&amp;quot;窗口1&amp;quot;);
        t1.start();
        //窗口2买票：
        Thread t2 = new Thread(t,&amp;quot;窗口2&amp;quot;);
        t2.start();
        //窗口3买票：
        Thread t3 = new Thread(t,&amp;quot;窗口3&amp;quot;);
        t3.start();
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;【2】实际开发中，方式1 继承Thread类   还是  方式2 实现Runnable接口这种方式多呢？–》方式2&lt;/p&gt;
&lt;p&gt;（1）方式1的话有 Java单继承的局限性，因为继承了Thread类，就不能再继承其它的类了&lt;/p&gt;
&lt;p&gt;（2）方式2的共享资源的能力也会强一些，不需要非得加个static来修饰&lt;/p&gt;
&lt;p&gt;【3】Thread类 Runnable接口 有联系吗？&lt;/p&gt;
&lt;img data-src=&#34;/2022/10/07/%E7%AC%AC13%E7%AB%A0%E5%A4%9A%E7%BA%BF%E7%A8%8B/image-20220618195007939.png&#34; class=&#34;&#34;&gt;


&lt;p&gt;对比第一种和第二种创建线程的方式发现，无论第一种继承Thread类的方式还是第二种实现Runnable接口的方式，都需要有一个run方法，&lt;br&gt;但是这个run方法有不足：&lt;/p&gt;
&lt;img data-src=&#34;/2022/10/07/%E7%AC%AC13%E7%AB%A0%E5%A4%9A%E7%BA%BF%E7%A8%8B/image-20220618195022846.png&#34; class=&#34;&#34;&gt;


&lt;p&gt;（1）没有返回值&lt;br&gt;（2）不能抛出异常&lt;/p&gt;
&lt;p&gt;基于上面的两个不足，在JDK1.5以后出现了第三种创建线程的方式：实现Callable接口：&lt;/p&gt;
&lt;p&gt;实现Callable接口好处：（1）有返回值  （2）能抛出异常&lt;br&gt;缺点：线程创建比较麻烦&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;public class TestRandomNum implements Callable&amp;lt;Integer&amp;gt; &amp;#123;
    /*
    1.实现Callable接口，可以不带泛型，如果不带泛型，那么call方式的返回值就是Object类型
    2.如果带泛型，那么call的返回值就是泛型对应的类型
    3.从call方法看到：方法有返回值，可以跑出异常
     */
    @Override
    public Integer call() throws Exception &amp;#123;
        return new Random().nextInt(10);//返回10以内的随机数
    &amp;#125;
&amp;#125;
class Test&amp;#123;
    //这是main方法，程序的入口
    public static void main(String[] args) throws ExecutionException, InterruptedException &amp;#123;
        //定义一个线程对象：
        TestRandomNum trn = new TestRandomNum();
        FutureTask ft = new FutureTask(trn);
        Thread t = new Thread(ft);
        t.start();
        //获取线程得到的返回值：
        Object obj = ft.get();
        System.out.println(obj);
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;2-线程的生命周期&#34;&gt;&lt;a href=&#34;#2-线程的生命周期&#34; class=&#34;headerlink&#34; title=&#34;2 线程的生命周期&#34;&gt;&lt;/a&gt;2 线程的生命周期&lt;/h1&gt;&lt;p&gt;【1】线程声明周期：线程开始–》线程消亡&lt;br&gt;【2】线程经历哪些阶段：&lt;/p&gt;
&lt;img data-src=&#34;/2022/10/07/%E7%AC%AC13%E7%AB%A0%E5%A4%9A%E7%BA%BF%E7%A8%8B/image-20220618195248025.png&#34; class=&#34;&#34;&gt;


&lt;h1 id=&#34;3-线程常见方法&#34;&gt;&lt;a href=&#34;#3-线程常见方法&#34; class=&#34;headerlink&#34; title=&#34;3 线程常见方法&#34;&gt;&lt;/a&gt;3 线程常见方法&lt;/h1&gt;&lt;p&gt;（1）start() :  启动当前线程，表面上调用start方法，实际在调用线程里面的run方法&lt;/p&gt;
&lt;p&gt;（2）run() : 线程类 继承 Thread类 或者 实现Runnable接口的时候，都要重新实现这个run方法，run方法里面是线程要执行的内容&lt;/p&gt;
&lt;p&gt;（3）currentThread :Thread类中一个静态方法：获取当前正在执行的线程&lt;/p&gt;
&lt;p&gt;（4）setName 设置线程名字&lt;/p&gt;
&lt;p&gt;（5）getName 读取线程名字&lt;/p&gt;
&lt;h2 id=&#34;设置优先级&#34;&gt;&lt;a href=&#34;#设置优先级&#34; class=&#34;headerlink&#34; title=&#34;设置优先级&#34;&gt;&lt;/a&gt;设置优先级&lt;/h2&gt;&lt;p&gt;【1】同优先级别的线程，采取的策略就是先到先服务，使用时间片策略&lt;/p&gt;
&lt;p&gt;【2】如果优先级别高，被CPU调度的概率就高&lt;/p&gt;
&lt;p&gt;【3】级别：1-10   默认的级别为5&lt;/p&gt;
&lt;img data-src=&#34;/2022/10/07/%E7%AC%AC13%E7%AB%A0%E5%A4%9A%E7%BA%BF%E7%A8%8B/image-20220618195340695.png&#34; class=&#34;&#34;&gt;





&lt;p&gt;【4】代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;public class TestThread01 extends Thread &amp;#123;
    @Override
    public void run() &amp;#123;
        for (int i = 1; i &amp;lt;= 10; i++) &amp;#123;
            System.out.println(i);
        &amp;#125;
    &amp;#125;
&amp;#125;
class TestThread02 extends Thread&amp;#123;
    @Override
    public void run() &amp;#123;
        for (int i = 20; i &amp;lt;= 30 ; i++) &amp;#123;
            System.out.println(i);
        &amp;#125;
    &amp;#125;
&amp;#125;
class Test&amp;#123;
    //这是main方法，程序的入口
    public static void main(String[] args) &amp;#123;
        //创建两个子线程，让这两个子线程争抢资源：
        TestThread01 t1 = new TestThread01();
        t1.setPriority(10);//优先级别高
        t1.start();
        TestThread02 t2 = new TestThread02();
        t2.setPriority(1);//优先级别低
        t2.start();
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;join&#34;&gt;&lt;a href=&#34;#join&#34; class=&#34;headerlink&#34; title=&#34;join&#34;&gt;&lt;/a&gt;join&lt;/h2&gt;&lt;p&gt;join方法：当一个线程调用了join方法，这个线程就会先被执行，它执行结束以后才可以去执行其余的线程。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注意：必须先start，再join才有效。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;public class TestThread extends Thread &amp;#123;
    public TestThread(String name)&amp;#123;
        super(name);
    &amp;#125;
    @Override
    public void run() &amp;#123;
        for (int i = 1; i &amp;lt;= 10 ; i++) &amp;#123;
            System.out.println(this.getName()+&amp;quot;----&amp;quot;+i);
        &amp;#125;
    &amp;#125;
&amp;#125;
class Test&amp;#123;
    //这是main方法，程序的入口
    public static void main(String[] args) throws InterruptedException &amp;#123;
        for (int i = 1; i &amp;lt;= 100 ; i++) &amp;#123;
            System.out.println(&amp;quot;main-----&amp;quot;+i);
            if(i == 6)&amp;#123;
                //创建子线程：
                TestThread tt = new TestThread(&amp;quot;子线程&amp;quot;);
                tt.start();
                tt.join();//“半路杀出个程咬金”
            &amp;#125;
        &amp;#125;
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;sleep&#34;&gt;&lt;a href=&#34;#sleep&#34; class=&#34;headerlink&#34; title=&#34;sleep&#34;&gt;&lt;/a&gt;sleep&lt;/h2&gt;&lt;p&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9nby56YmouY29tL25ld3MvMjAxNDYuaHRtbA==&#34;&gt;https://go.zbj.com/news/20146.html&lt;/span&gt; （段子）&lt;/p&gt;
&lt;p&gt;【1】sleep : 人为的制造阻塞事件&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;public class Test01 &amp;#123;
    //这是main方法，程序的入口
    public static void main(String[] args) &amp;#123;
        try &amp;#123;
            Thread.sleep(3000);
        &amp;#125; catch (InterruptedException e) &amp;#123;
            e.printStackTrace();
        &amp;#125;
        System.out.println(&amp;quot;00000000000000&amp;quot;);
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;【2】案例：完成秒表功能：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;public class Test02 &amp;#123;
    //这是main方法，程序的入口
    public static void main(String[] args) &amp;#123;
        //2.定义一个时间格式：
        DateFormat df = new SimpleDateFormat(&amp;quot;HH:mm:ss&amp;quot;);
        while(true)&amp;#123;
            //1.获取当前时间：
            Date d = new Date();
            //3.按照上面定义的格式将Date类型转为指定格式的字符串：
            System.out.println(df.format(d));
            try &amp;#123;
                Thread.sleep(1000);
            &amp;#125; catch (InterruptedException e) &amp;#123;
                e.printStackTrace();
            &amp;#125;
        &amp;#125;
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;setDaemon&#34;&gt;&lt;a href=&#34;#setDaemon&#34; class=&#34;headerlink&#34; title=&#34;setDaemon&#34;&gt;&lt;/a&gt;setDaemon&lt;/h2&gt;&lt;p&gt;【1】设置伴随线程&lt;br&gt;将子线程设置为主线程的伴随线程，主线程停止的时候，子线程也不要继续执行了&lt;br&gt;案例：皇上 –》驾崩 —》妃子陪葬&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;public class TestThread extends Thread &amp;#123;
    @Override
    public void run() &amp;#123;
        for (int i = 1; i &amp;lt;= 1000 ; i++) &amp;#123;
            System.out.println(&amp;quot;子线程----&amp;quot;+i);
        &amp;#125;
    &amp;#125;
&amp;#125;
class Test&amp;#123;
    //这是main方法，程序的入口
    public static void main(String[] args) &amp;#123;
        //创建并启动子线程：
        TestThread tt = new TestThread();
        tt.setDaemon(true);//设置伴随线程  注意：先设置，再启动
        tt.start();
        //主线程中还要输出1-10的数字：
        for (int i = 1; i &amp;lt;= 10 ; i++) &amp;#123;
            System.out.println(&amp;quot;main---&amp;quot;+i);
        &amp;#125;
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;结果：&lt;/p&gt;
&lt;img data-src=&#34;/2022/10/07/%E7%AC%AC13%E7%AB%A0%E5%A4%9A%E7%BA%BF%E7%A8%8B/image-20220618195552686.png&#34; class=&#34;&#34;&gt;


&lt;h2 id=&#34;stop&#34;&gt;&lt;a href=&#34;#stop&#34; class=&#34;headerlink&#34; title=&#34;stop&#34;&gt;&lt;/a&gt;stop&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;public class Demo &amp;#123;
    //这是main方法，程序的入口
    public static void main(String[] args) &amp;#123;
        for (int i = 1; i &amp;lt;= 100 ; i++) &amp;#123;
            if(i == 6)&amp;#123;
                Thread.currentThread().stop();//过期方法，不建议使用
            &amp;#125;
            System.out.println(i);
        &amp;#125;
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;4-线程安全问题&#34;&gt;&lt;a href=&#34;#4-线程安全问题&#34; class=&#34;headerlink&#34; title=&#34;4 线程安全问题&#34;&gt;&lt;/a&gt;4 线程安全问题&lt;/h1&gt;&lt;h2 id=&#34;方法1：同步代码块&#34;&gt;&lt;a href=&#34;#方法1：同步代码块&#34; class=&#34;headerlink&#34; title=&#34;方法1：同步代码块&#34;&gt;&lt;/a&gt;方法1：同步代码块&lt;/h2&gt;&lt;p&gt;【1】同步代码块演示1：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;package com.msb.test04;
/**
 * @author : msb-zhaoss
 */
public class BuyTicketThread implements Runnable &amp;#123;
    int ticketNum = 10;
    @Override
    public void run() &amp;#123;
        //此处有1000行代码
        for (int i = 1; i &amp;lt;= 100 ; i++) &amp;#123;
            synchronized (this)&amp;#123;//把具有安全隐患的代码锁住即可，如果锁多了就会效率低 --》this就是这个锁
                if(ticketNum &amp;gt; 0)&amp;#123;
                    System.out.println(&amp;quot;我在&amp;quot;+Thread.currentThread().getName()+&amp;quot;买到了北京到哈尔滨的第&amp;quot; + ticketNum-- + &amp;quot;张车票&amp;quot;);
                &amp;#125;
            &amp;#125;
        &amp;#125;
        //此处有1000行代码
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;【2】同步代码块演示2：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;public class BuyTicketThread extends Thread &amp;#123;
    public BuyTicketThread(String name)&amp;#123;
        super(name);
    &amp;#125;
    //一共10张票：
    static int ticketNum = 10;//多个对象共享10张票
    //每个窗口都是一个线程对象：每个对象执行的代码放入run方法中
    @Override
    public void run() &amp;#123;
        //每个窗口后面有100个人在抢票：
        for (int i = 1; i &amp;lt;= 100 ; i++) &amp;#123;
            synchronized (BuyTicketThread.class)&amp;#123;//锁必须多个线程用的是同一把锁！！！
                if(ticketNum &amp;gt; 0)&amp;#123;//对票数进行判断，票数大于零我们才抢票
                    System.out.println(&amp;quot;我在&amp;quot;+this.getName()+&amp;quot;买到了从北京到哈尔滨的第&amp;quot; + ticketNum-- + &amp;quot;张车票&amp;quot;);
                &amp;#125;
            &amp;#125;
        &amp;#125;
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;方法2：同步方法&#34;&gt;&lt;a href=&#34;#方法2：同步方法&#34; class=&#34;headerlink&#34; title=&#34;方法2：同步方法&#34;&gt;&lt;/a&gt;方法2：同步方法&lt;/h2&gt;&lt;p&gt;【1】代码展示：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;public class BuyTicketThread implements Runnable &amp;#123;
    int ticketNum = 10;
    @Override
    public void run() &amp;#123;
        //此处有1000行代码
        for (int i = 1; i &amp;lt;= 100 ; i++) &amp;#123;
            buyTicket();
        &amp;#125;
        //此处有1000行代码
    &amp;#125;
    public synchronized void buyTicket()&amp;#123;//锁住的是this
        if(ticketNum &amp;gt; 0)&amp;#123;
            System.out.println(&amp;quot;我在&amp;quot;+Thread.currentThread().getName()+&amp;quot;买到了北京到哈尔滨的第&amp;quot; + ticketNum-- + &amp;quot;张车票&amp;quot;);
        &amp;#125;
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;public class BuyTicketThread extends Thread &amp;#123;
    public BuyTicketThread(String name)&amp;#123;
        super(name);
    &amp;#125;
    //一共10张票：
    static int ticketNum = 10;//多个对象共享10张票
    //每个窗口都是一个线程对象：每个对象执行的代码放入run方法中
    @Override
    public void run() &amp;#123;
        //每个窗口后面有100个人在抢票：
        for (int i = 1; i &amp;lt;= 100 ; i++) &amp;#123;
            buyTicket();
        &amp;#125;
    &amp;#125;
    public static synchronized void buyTicket()&amp;#123;//锁住的  同步监视器： BuyTicketThread.class
        if(ticketNum &amp;gt; 0)&amp;#123;//对票数进行判断，票数大于零我们才抢票
            System.out.println(&amp;quot;我在&amp;quot;+Thread.currentThread().getName()+&amp;quot;买到了从北京到哈尔滨的第&amp;quot; + ticketNum-- + &amp;quot;张车票&amp;quot;);
        &amp;#125;
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;【2】总结：&lt;br&gt;总结1：&lt;br&gt;多线程在争抢资源，就要实现线程的同步（就要进行加锁，并且这个锁必须是共享的，必须是唯一的。&lt;br&gt;咱们的锁一般都是引用数据类型的。&lt;/p&gt;
&lt;p&gt;目的：解决了线程安全问题。&lt;/p&gt;
&lt;p&gt;总结2：关于同步方法&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;不要将run()定义为同步方法&lt;/li&gt;
&lt;li&gt;非静态同步方法的同步监视器是this&lt;br&gt;静态同步方法的同步监视器是 类名.class 字节码信息对象&lt;/li&gt;
&lt;li&gt;同步代码块的效率要高于同步方法&lt;br&gt;原因：同步方法是将线程挡在了方法的外部，而同步代码块锁将线程挡在了代码块的外部，但是却是方法的内部&lt;/li&gt;
&lt;li&gt;同步方法的锁是this，一旦锁住一个方法，就锁住了所有的同步方法；同步代码块只是锁住使用该同步监视器的代码块，而没有锁住使用其他监视器的代码块&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;方法3：Lock锁&#34;&gt;&lt;a href=&#34;#方法3：Lock锁&#34; class=&#34;headerlink&#34; title=&#34;方法3：Lock锁&#34;&gt;&lt;/a&gt;方法3：Lock锁&lt;/h2&gt;&lt;p&gt;【1】Lock锁引入：&lt;br&gt;JDK1.5后新增新一代的线程同步方式:Lock锁&lt;br&gt;与采用synchronized相比，lock可提供多种锁方案，更灵活&lt;/p&gt;
&lt;p&gt;synchronized是Java中的关键字，这个关键字的识别是靠JVM来识别完成的呀。是虚拟机级别的。&lt;br&gt;但是Lock锁是API级别的，提供了相应的接口和对应的实现类，这个方式更灵活，表现出来的性能优于之前的方式。&lt;/p&gt;
&lt;p&gt;【2】代码演示：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;public class BuyTicketThread implements Runnable &amp;#123;
    int ticketNum = 10;
    //拿来一把锁：
    Lock lock = new ReentrantLock();//多态  接口=实现类  可以使用不同的实现类
    @Override
    public void run() &amp;#123;
        //此处有1000行代码
        for (int i = 1; i &amp;lt;= 100 ; i++) &amp;#123;
            //打开锁：
            lock.lock();
            try&amp;#123;
                if(ticketNum &amp;gt; 0)&amp;#123;
                    System.out.println(&amp;quot;我在&amp;quot;+Thread.currentThread().getName()+&amp;quot;买到了北京到哈尔滨的第&amp;quot; + ticketNum-- + &amp;quot;张车票&amp;quot;);
                &amp;#125;
            &amp;#125;catch (Exception ex)&amp;#123;
                ex.printStackTrace();
            &amp;#125;finally &amp;#123;
                //关闭锁：---&amp;gt;即使有异常，这个锁也可以得到释放
                lock.unlock();
            &amp;#125;
        &amp;#125;
        //此处有1000行代码
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;【3】 Lock和synchronized的区别&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    1.Lock是显式锁（手动开启和关闭锁，别忘记关闭锁），synchronized是隐式锁
    2.Lock只有代码块锁，synchronized有代码块锁和方法锁
    3.使用Lock锁，JVM将花费较少的时间来调度线程，性能更好。并且具有更好的扩展性（提供更多的子类）
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;【4】优先使用顺序：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    Lock----同步代码块（已经进入了方法体，分配了相应资源）----同步方法（在方法体之外）
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;线程同步的优缺点&#34;&gt;&lt;a href=&#34;#线程同步的优缺点&#34; class=&#34;headerlink&#34; title=&#34;线程同步的优缺点&#34;&gt;&lt;/a&gt;线程同步的优缺点&lt;/h2&gt;&lt;p&gt;【1】对比：&lt;br&gt;线程安全，效率低&lt;br&gt;线程不安全，效率高&lt;/p&gt;
&lt;p&gt;【2】可能造成死锁：&lt;br&gt;死锁&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;不同的线程分别占用对方需要的同步资源不放弃，都在等待对方放弃自己需要的同步资源，就形成了线程的死锁&lt;br&gt;出现死锁后，不会出现异常，不会出现提示，只是所有的线程都处于阻塞状态，无法继续&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;【3】代码演示：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;public class TestDeadLock implements Runnable &amp;#123;
    public int flag = 1;
    static Object o1 = new Object(),o2 = new Object();
        
        
    public void run()&amp;#123;
        System.out.println(&amp;quot;flag=&amp;quot; + flag);
        // 当flag==1锁住o1
        if (flag == 1) &amp;#123;
            synchronized (o1) &amp;#123;
                try &amp;#123;
                    Thread.sleep(500);
                &amp;#125; catch (Exception e) &amp;#123;
                    e.printStackTrace();
                &amp;#125;
                // 只要锁住o2就完成
                synchronized (o2) &amp;#123;
                    System.out.println(&amp;quot;2&amp;quot;);
                &amp;#125;
            &amp;#125;
        &amp;#125;
        // 如果flag==0锁住o2
        if (flag == 0) &amp;#123;
            synchronized (o2) &amp;#123;
                try &amp;#123;
                    Thread.sleep(500);
                &amp;#125; catch (Exception e) &amp;#123;
                    e.printStackTrace();
                &amp;#125;
                // 只要锁住o1就完成
                synchronized (o1) &amp;#123;
                    System.out.println(&amp;quot;3&amp;quot;);
                &amp;#125;
            &amp;#125;
        &amp;#125;
    &amp;#125;
        
        
    public static void main(String[] args) &amp;#123;
        // 实例2个线程类
        TestDeadLock td1 = new TestDeadLock();
        TestDeadLock td2 = new TestDeadLock();
        td1.flag = 1;
        td2.flag = 0;
        // 开启2个线程
        Thread t1 = new Thread(td1);
        Thread t2 = new Thread(td2);
        t1.start();
        t2.start();
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;【4】解决方法： 减少同步资源的定义，避免嵌套同步&lt;/p&gt;
&lt;h1 id=&#34;5-线程通信问题&#34;&gt;&lt;a href=&#34;#5-线程通信问题&#34; class=&#34;headerlink&#34; title=&#34;5 线程通信问题&#34;&gt;&lt;/a&gt;5 线程通信问题&lt;/h1&gt;&lt;p&gt;应用场景：生产者和消费者问题&lt;br&gt;假设仓库中只能存放一件产品，生产者将生产出来的产品放入仓库，消费者将仓库中产品取走消费&lt;br&gt;如果仓库中没有产品，则生产者将产品放入仓库，否则停止生产并等待，直到仓库中的产品被消费者取走为止&lt;br&gt;如果仓库中放有产品，则消费者可以将产品取走消费，否则停止消费并等待，直到仓库中再次放入产品为止&lt;/p&gt;
&lt;img data-src=&#34;/2022/10/07/%E7%AC%AC13%E7%AB%A0%E5%A4%9A%E7%BA%BF%E7%A8%8B/image-20220618200150740.png&#34; class=&#34;&#34;&gt;


&lt;p&gt;代码结果展示：&lt;/p&gt;
&lt;img data-src=&#34;/2022/10/07/%E7%AC%AC13%E7%AB%A0%E5%A4%9A%E7%BA%BF%E7%A8%8B/image-20220618200157334.png&#34; class=&#34;&#34;&gt;


&lt;p&gt;代码：&lt;br&gt;1.商品：属性：品牌 ，名字&lt;br&gt;2.线程1：生产者&lt;br&gt;3.线程2：消费者&lt;/p&gt;
&lt;h2 id=&#34;分解1&#34;&gt;&lt;a href=&#34;#分解1&#34; class=&#34;headerlink&#34; title=&#34;分解1&#34;&gt;&lt;/a&gt;分解1&lt;/h2&gt;&lt;p&gt;出现问题：&lt;br&gt;1.生产者和消费者没有交替输出&lt;/p&gt;
&lt;p&gt;2.打印数据错乱&lt;br&gt;哈尔滨 - null&lt;br&gt;费列罗啤酒&lt;br&gt;哈尔滨巧克力&lt;br&gt;—-没有加同步&lt;/p&gt;
&lt;p&gt;代码展示：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;public class Product &amp;#123;//商品类
    //品牌
    private String brand;
    //名字
    private String name;
    //setter,getter方法；
    public String getBrand() &amp;#123;
        return brand;
    &amp;#125;
    public void setBrand(String brand) &amp;#123;
        this.brand = brand;
    &amp;#125;
    public String getName() &amp;#123;
        return name;
    &amp;#125;
    public void setName(String name) &amp;#123;
        this.name = name;
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;public class ProducerThread extends Thread&amp;#123;//生产者线程
    //共享商品：
    private Product p;
    public ProducerThread(Product p) &amp;#123;
        this.p = p;
    &amp;#125;
    @Override
    public void run() &amp;#123;
        for (int i = 1; i &amp;lt;= 10 ; i++) &amp;#123;//生产十个商品 i:生产的次数
            if(i % 2 == 0)&amp;#123;
                //生产费列罗巧克力
                p.setBrand(&amp;quot;费列罗&amp;quot;);
                try &amp;#123;
                    Thread.sleep(100);
                &amp;#125; catch (InterruptedException e) &amp;#123;
                    e.printStackTrace();
                &amp;#125;
                p.setName(&amp;quot;巧克力&amp;quot;);
            &amp;#125;else&amp;#123;
                //生产哈尔滨啤酒
                p.setBrand(&amp;quot;哈尔滨&amp;quot;);
                try &amp;#123;
                    Thread.sleep(100);
                &amp;#125; catch (InterruptedException e) &amp;#123;
                    e.printStackTrace();
                &amp;#125;
                p.setName(&amp;quot;啤酒&amp;quot;);
            &amp;#125;
            //将生产信息做一个打印：
            System.out.println(&amp;quot;生产者生产了：&amp;quot; + p.getBrand() + &amp;quot;---&amp;quot; + p.getName());
        &amp;#125;
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;public class CustomerThread extends Thread&amp;#123;//消费者线程
    //共享商品：
    private Product p;
    public CustomerThread(Product p) &amp;#123;
        this.p = p;
    &amp;#125;
    @Override
    public void run() &amp;#123;
        for (int i = 1; i &amp;lt;= 10 ; i++) &amp;#123;//i:消费次数
            System.out.println(&amp;quot;消费者消费了：&amp;quot; + p.getBrand() + &amp;quot;---&amp;quot; + p.getName());
        &amp;#125;
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;分解2&#34;&gt;&lt;a href=&#34;#分解2&#34; class=&#34;headerlink&#34; title=&#34;分解2&#34;&gt;&lt;/a&gt;分解2&lt;/h2&gt;&lt;p&gt;【1】利用同步代码块解决问题：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;public class ProducerThread extends Thread&amp;#123;//生产者线程
    //共享商品：
    private Product p;
    public ProducerThread(Product p) &amp;#123;
        this.p = p;
    &amp;#125;
    @Override
    public void run() &amp;#123;
        for (int i = 1; i &amp;lt;= 10 ; i++) &amp;#123;//生产十个商品 i:生产的次数
            synchronized (p)&amp;#123;
                if(i % 2 == 0)&amp;#123;
                    //生产费列罗巧克力
                    p.setBrand(&amp;quot;费列罗&amp;quot;);
                    try &amp;#123;
                        Thread.sleep(100);
                    &amp;#125; catch (InterruptedException e) &amp;#123;
                        e.printStackTrace();
                    &amp;#125;
                    p.setName(&amp;quot;巧克力&amp;quot;);
                &amp;#125;else&amp;#123;
                    //生产哈尔滨啤酒
                    p.setBrand(&amp;quot;哈尔滨&amp;quot;);
                    try &amp;#123;
                        Thread.sleep(100);
                    &amp;#125; catch (InterruptedException e) &amp;#123;
                        e.printStackTrace();
                    &amp;#125;
                    p.setName(&amp;quot;啤酒&amp;quot;);
                &amp;#125;
                //将生产信息做一个打印：
                System.out.println(&amp;quot;生产者生产了：&amp;quot; + p.getBrand() + &amp;quot;---&amp;quot; + p.getName());
            &amp;#125;
        &amp;#125;
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;public class CustomerThread extends Thread&amp;#123;//消费者线程
    //共享商品：
    private Product p;
    public CustomerThread(Product p) &amp;#123;
        this.p = p;
    &amp;#125;
    @Override
    public void run() &amp;#123;
        for (int i = 1; i &amp;lt;= 10 ; i++) &amp;#123;//i:消费次数
            synchronized (p)&amp;#123;
                System.out.println(&amp;quot;消费者消费了：&amp;quot; + p.getBrand() + &amp;quot;---&amp;quot; + p.getName());
            &amp;#125;
        &amp;#125;
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;【2】利用同步方法解决问题：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;public class Product &amp;#123;//商品类
    //品牌
    private String brand;
    //名字
    private String name;
    //setter,getter方法；
    public String getBrand() &amp;#123;
        return brand;
    &amp;#125;
    public void setBrand(String brand) &amp;#123;
        this.brand = brand;
    &amp;#125;
    public String getName() &amp;#123;
        return name;
    &amp;#125;
    public void setName(String name) &amp;#123;
        this.name = name;
    &amp;#125;
    //生产商品
    public synchronized void setProduct(String brand,String name)&amp;#123;
        this.setBrand(brand);
        try &amp;#123;
            Thread.sleep(100);
        &amp;#125; catch (InterruptedException e) &amp;#123;
            e.printStackTrace();
        &amp;#125;
        this.setName(name);
        //将生产信息做一个打印：
        System.out.println(&amp;quot;生产者生产了：&amp;quot; + this.getBrand() + &amp;quot;---&amp;quot; + this.getName());
    &amp;#125;
    //消费商品：
    public synchronized void getProduct()&amp;#123;
        System.out.println(&amp;quot;消费者消费了：&amp;quot; + this.getBrand() + &amp;quot;---&amp;quot; + this.getName());
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;public class CustomerThread extends Thread&amp;#123;//消费者线程
    //共享商品：
    private Product p;
    public CustomerThread(Product p) &amp;#123;
        this.p = p;
    &amp;#125;
    @Override
    public void run() &amp;#123;
        for (int i = 1; i &amp;lt;= 10 ; i++) &amp;#123;//i:消费次数
            p.getProduct();;
        &amp;#125;
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;public class ProducerThread extends Thread&amp;#123;//生产者线程
    //共享商品：
    private Product p;
    public ProducerThread(Product p) &amp;#123;
        this.p = p;
    &amp;#125;
    @Override
    public void run() &amp;#123;
        for (int i = 1; i &amp;lt;= 10 ; i++) &amp;#123;//生产十个商品 i:生产的次数
            if(i % 2 == 0)&amp;#123;
                p.setProduct(&amp;quot;费列罗&amp;quot;,&amp;quot;巧克力&amp;quot;);
            &amp;#125;else&amp;#123;
                p.setProduct(&amp;quot;哈尔滨&amp;quot;,&amp;quot;啤酒&amp;quot;);
            &amp;#125;
        &amp;#125;
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;（这个else中的代码在分解3中 演示了错误）&lt;/p&gt;
&lt;h2 id=&#34;分解3&#34;&gt;&lt;a href=&#34;#分解3&#34; class=&#34;headerlink&#34; title=&#34;分解3&#34;&gt;&lt;/a&gt;分解3&lt;/h2&gt;&lt;p&gt;【1】原理：&lt;/p&gt;
&lt;img data-src=&#34;/2022/10/07/%E7%AC%AC13%E7%AB%A0%E5%A4%9A%E7%BA%BF%E7%A8%8B/image-20220618200412158.png&#34; class=&#34;&#34;&gt;



&lt;p&gt;【2】代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;public class Product &amp;#123;//商品类
    //品牌
    private String brand;
    //名字
    private String name;
    //引入一个灯：true:红色  false 绿色
    boolean flag = false;//默认情况下没有商品 让生产者先生产  然后消费者再消费
    //setter,getter方法；
    public String getBrand() &amp;#123;
        return brand;
    &amp;#125;
    public void setBrand(String brand) &amp;#123;
        this.brand = brand;
    &amp;#125;
    public String getName() &amp;#123;
        return name;
    &amp;#125;
    public void setName(String name) &amp;#123;
        this.name = name;
    &amp;#125;
    //生产商品
    public synchronized void setProduct(String brand,String name)&amp;#123;
        if(flag == true)&amp;#123;//灯是红色，证明有商品，生产者不生产，等着消费者消费
            try &amp;#123;
                wait();
            &amp;#125; catch (InterruptedException e) &amp;#123;
                e.printStackTrace();
            &amp;#125;
        &amp;#125;
        //灯是绿色的，就生产：
        this.setBrand(brand);
        try &amp;#123;
            Thread.sleep(100);
        &amp;#125; catch (InterruptedException e) &amp;#123;
            e.printStackTrace();
        &amp;#125;
        this.setName(name);
        //将生产信息做一个打印：
        System.out.println(&amp;quot;生产者生产了：&amp;quot; + this.getBrand() + &amp;quot;---&amp;quot; + this.getName());
        //生产完以后，灯变色：变成红色：
        flag = true;
        //告诉消费者赶紧来消费：
        notify();
    &amp;#125;
    //消费商品：
    public synchronized void getProduct()&amp;#123;
        if(!flag)&amp;#123;//flag == false没有商品，等待生产者生产：
            try &amp;#123;
                wait();
            &amp;#125; catch (InterruptedException e) &amp;#123;
                e.printStackTrace();
            &amp;#125;
        &amp;#125;
        //有商品，消费：
        System.out.println(&amp;quot;消费者消费了：&amp;quot; + this.getBrand() + &amp;quot;---&amp;quot; + this.getName());
        //消费完：灯变色：
        flag = false;
        //通知生产者生产：
        notify();
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;【3】原理：&lt;/p&gt;
&lt;img data-src=&#34;/2022/10/07/%E7%AC%AC13%E7%AB%A0%E5%A4%9A%E7%BA%BF%E7%A8%8B/image-20220618200442747.png&#34; class=&#34;&#34;&gt;


&lt;p&gt;注意：wait方法和notify方法  是必须放在同步方法或者同步代码块中才生效的 （因为在同步的基础上进行线程的通信才是有效的）&lt;br&gt;注意：sleep和wait的区别：sleep进入阻塞状态没有释放锁，wait进入阻塞状态但是同时释放了锁&lt;br&gt;【4】线程生命周期完整图：&lt;/p&gt;
&lt;img data-src=&#34;/2022/10/07/%E7%AC%AC13%E7%AB%A0%E5%A4%9A%E7%BA%BF%E7%A8%8B/image-20220618200450798.png&#34; class=&#34;&#34;&gt;


&lt;h2 id=&#34;Loc锁情况下的线程通信&#34;&gt;&lt;a href=&#34;#Loc锁情况下的线程通信&#34; class=&#34;headerlink&#34; title=&#34;Loc锁情况下的线程通信&#34;&gt;&lt;/a&gt;Loc锁情况下的线程通信&lt;/h2&gt;&lt;p&gt;Condition是在Java 1.5中才出现的，它用来替代传统的Object的wait()、notify()实现线程间的协作，相比使用Object的wait()、notify()，使用Condition1的await()、signal()这种方式实现线程间协作更加安全和高效。&lt;/p&gt;
&lt;p&gt;它的更强大的地方在于：能够更加精细的控制多线程的休眠与唤醒。对于同一个锁，我们可以创建多个Condition，在不同的情况下使用不同的Condition&lt;/p&gt;
&lt;p&gt;一个Condition包含一个等待队列。一个Lock可以产生多个Condition，所以可以有多个等待队列。&lt;/p&gt;
&lt;p&gt;在Object的监视器模型上，一个对象拥有一个同步队列和等待队列，&lt;font color=&#34;red&#34;&gt;而Lock（同步器）拥有一个同步队列和多个等待队列&lt;/font&gt;。&lt;/p&gt;
&lt;p&gt;Object中的wait(),notify(),notifyAll()方法是和”同步锁”(synchronized关键字)捆绑使用的；而Condition是需要与”互斥锁”&amp;#x2F;“共享锁”捆绑使用的。&lt;/p&gt;
&lt;p&gt;调用Condition的await()、signal()、signalAll()方法，都必须在lock保护之内，&lt;font color=&#34;red&#34;&gt;就是说必须在lock.lock()和lock.unlock之间才可以使用 &lt;/font&gt;&lt;/p&gt;
&lt;p&gt;· Conditon中的await()对应Object的wait()；&lt;/p&gt;
&lt;p&gt;· Condition中的signal()对应Object的notify()；&lt;br&gt;· Condition中的signalAll()对应Object的notifyAll()。&lt;/p&gt;
&lt;p&gt;void await()  throws InterruptedException&lt;/p&gt;
&lt;p&gt;造成当前线程在接到信号或被中断之前一直处于等待状态。&lt;/p&gt;
&lt;p&gt;与此 Condition 相关的锁以原子方式释放，并且出于线程调度的目的，将禁用当前线程，且在发生以下四种情况之一 以前，当前线程将一直处于休眠状态：&lt;/p&gt;
&lt;p&gt;· 其他某个线程调用此 Condition 的 signal() 方法，并且碰巧将当前线程选为被唤醒的线程；或者&lt;br&gt;· 其他某个线程调用此 Condition 的 signalAll() 方法；或者&lt;br&gt;· 其他某个线程中断当前线程，且支持中断线程的挂起；或者&lt;br&gt;· 发生“虚假唤醒”&lt;/p&gt;
&lt;p&gt;在所有情况下，在此方法可以返回当前线程之前，都必须重新获取与此条件有关的锁。在线程返回时，可以保证它保持此锁。&lt;/p&gt;
&lt;p&gt;void &lt;strong&gt;signal()&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;唤醒一个等待线程。&lt;/p&gt;
&lt;p&gt;如果所有的线程都在等待此条件，则选择其中的一个唤醒。在从 await 返回之前，该线程必须重新获取锁。&lt;/p&gt;
&lt;p&gt;void &lt;strong&gt;signalAll()&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;唤醒所有等待线程。&lt;/p&gt;
&lt;p&gt;如果所有的线程都在等待此条件，则唤醒所有线程。在从 await 返回之前，每个线程都必须重新获取锁。&lt;/p&gt;
&lt;p&gt;更改代码：&lt;/p&gt;
&lt;img data-src=&#34;/2022/10/07/%E7%AC%AC13%E7%AB%A0%E5%A4%9A%E7%BA%BF%E7%A8%8B/image-20220618200641119.png&#34; class=&#34;&#34;&gt;


&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;public class Product &amp;#123;//商品类
    //品牌
    private String brand;
    //名字
    private String name;
    //声明一个Lock锁：
    Lock lock = new ReentrantLock();
    //搞一个生产者的等待队列：
    Condition produceCondition = lock.newCondition();
    //搞一个消费者的等待队列：
    Condition consumeCondition = lock.newCondition();
    //引入一个灯：true:红色  false 绿色
    boolean flag = false;//默认情况下没有商品 让生产者先生产  然后消费者再消费
    //setter,getter方法；
    public String getBrand() &amp;#123;
        return brand;
    &amp;#125;
    public void setBrand(String brand) &amp;#123;
        this.brand = brand;
    &amp;#125;
    public String getName() &amp;#123;
        return name;
    &amp;#125;
    public void setName(String name) &amp;#123;
        this.name = name;
    &amp;#125;
    //生产商品
    public void setProduct(String brand,String name)&amp;#123;
        lock.lock();
        try&amp;#123;
            if(flag == true)&amp;#123;//灯是红色，证明有商品，生产者不生产，等着消费者消费
                try &amp;#123;
                    //wait();
                    //生产者阻塞，生产者进入等待队列中
                    produceCondition.await();
                &amp;#125; catch (InterruptedException e) &amp;#123;
                    e.printStackTrace();
                &amp;#125;
            &amp;#125;
            //灯是绿色的，就生产：
            this.setBrand(brand);
            try &amp;#123;
                Thread.sleep(100);
            &amp;#125; catch (InterruptedException e) &amp;#123;
                e.printStackTrace();
            &amp;#125;
            this.setName(name);
            //将生产信息做一个打印：
            System.out.println(&amp;quot;生产者生产了：&amp;quot; + this.getBrand() + &amp;quot;---&amp;quot; + this.getName());
            //生产完以后，灯变色：变成红色：
            flag = true;
            //告诉消费者赶紧来消费：
            //notify();
            consumeCondition.signal();
        &amp;#125;finally &amp;#123;
            lock.unlock();
        &amp;#125;
    &amp;#125;
    //消费商品：
    public void getProduct()&amp;#123;
        lock.lock();
        try&amp;#123;
            if(!flag)&amp;#123;//flag == false没有商品，等待生产者生产：
                try &amp;#123;
                   // wait();
                    //消费者等待，消费者线程进入等待队列：
                    consumeCondition.await();
                &amp;#125; catch (InterruptedException e) &amp;#123;
                    e.printStackTrace();
                &amp;#125;
            &amp;#125;
            //有商品，消费：
            System.out.println(&amp;quot;消费者消费了：&amp;quot; + this.getBrand() + &amp;quot;---&amp;quot; + this.getName());
            //消费完：灯变色：
            flag = false;
            //通知生产者生产：
            //notify();
            produceCondition.signal();
        &amp;#125;finally &amp;#123;
            lock.unlock();
        &amp;#125;
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;未完成！！！！！！！！！！&#34;&gt;&lt;a href=&#34;#未完成！！！！！！！！！！&#34; class=&#34;headerlink&#34; title=&#34;未完成！！！！！！！！！！&#34;&gt;&lt;/a&gt;未完成！！！！！！！！！！&lt;/h1&gt;</content>
        <category term="JavaSE" />
        <updated>2022-10-06T16:00:00.000Z</updated>
    </entry>
</feed>
