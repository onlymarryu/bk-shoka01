{
    "version": "https://jsonfeed.org/version/1",
    "title": "记录“美食”每刻 • All posts by \"rpc\" category",
    "description": "记录“美食”每刻",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/2022/10/07/RPC/",
            "url": "http://example.com/2022/10/07/RPC/",
            "title": "RPC",
            "date_published": "2022-10-06T16:00:00.000Z",
            "content_html": "<h1 id=\"【RPC】\"><a href=\"#【RPC】\" class=\"headerlink\" title=\"【RPC】\"></a>【RPC】</h1><h2 id=\"主要内容\"><a href=\"#主要内容\" class=\"headerlink\" title=\"主要内容\"></a>主要内容</h2><ol>\n<li><p>项目结构变化</p>\n</li>\n<li><p>RPC简介</p>\n</li>\n<li><p>RMI实现RPC</p>\n</li>\n<li><p>HttpClient实现RPC</p>\n</li>\n<li><p>Zookeeper安装</p>\n</li>\n<li><p>Zookeeper客户端常用命令</p>\n</li>\n<li><p>向Zookeeper中注册内容</p>\n</li>\n<li><p>从Zookeeper中发现内容</p>\n</li>\n<li><p>手写RPC框架</p>\n</li>\n</ol>\n<h2 id=\"学习目标\"><a href=\"#学习目标\" class=\"headerlink\" title=\"学习目标\"></a>学习目标</h2><table>\n<thead>\n<tr>\n<th>知识点</th>\n<th>要求</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>项目架构变化</td>\n<td>掌握</td>\n</tr>\n<tr>\n<td>RPC简介</td>\n<td>掌握</td>\n</tr>\n<tr>\n<td>RMI实现RPC</td>\n<td>掌握</td>\n</tr>\n<tr>\n<td>HttpClient实现RPC</td>\n<td>了解</td>\n</tr>\n<tr>\n<td>Zookeeper安装</td>\n<td>掌握</td>\n</tr>\n<tr>\n<td>Zookeeper客户端常用命令</td>\n<td>掌握</td>\n</tr>\n<tr>\n<td>向Zookeeper中注册内容</td>\n<td>掌握</td>\n</tr>\n<tr>\n<td>从zookeeper中发现内容</td>\n<td>掌握</td>\n</tr>\n<tr>\n<td>手写RPC框架</td>\n<td>掌握</td>\n</tr>\n</tbody></table>\n<h3 id=\"一、今天学什么？为什么讲？\"><a href=\"#一、今天学什么？为什么讲？\" class=\"headerlink\" title=\"一、今天学什么？为什么讲？\"></a>一、今天学什么？为什么讲？</h3><p>​\t 现在学习RPC。后期学习的Dubbo是一个RPC框架，学习好现在的内容，学习Dubbo将会变得容易一些。</p>\n<h3 id=\"二、项目架构变化\"><a href=\"#二、项目架构变化\" class=\"headerlink\" title=\"二、项目架构变化\"></a>二、项目架构变化</h3><h4 id=\"1-单体架构\"><a href=\"#1-单体架构\" class=\"headerlink\" title=\"1     单体架构\"></a>1     单体架构</h4><h5 id=\"1-1-架构图\"><a href=\"#1-1-架构图\" class=\"headerlink\" title=\"1.1   架构图\"></a>1.1   架构图</h5><p>​\t单体架构就是一个项目里面包含这个项目中全部代码。一个应用搞定全部功能。</p>\n<p>​\tDNS 服务器可以是单映射，也可以配置多个映射。</p>\n<img data-src=\"/2022/10/07/RPC/rpc-01.png\" class=\"\">\n\n\n<h5 id=\"1-2-软件代码结构\"><a href=\"#1-2-软件代码结构\" class=\"headerlink\" title=\"1.2   软件代码结构\"></a>1.2   软件代码结构</h5><p>​\t在单体架构项目中，团队都是通过包(package)进行区分每个模块。</p>\n<p>​\t总体包结构：com.msb.*.分层包。</p>\n<pre><code>项目名：\n  -- com\n    --msb\n      -- common\n        -- utils\n      --user\n        -- controller\n        -- service\n        -- mapper\n      -- sys\n        -- controller\n        -- service\n        -- mapper\n</code></pre>\n<h4 id=\"1-3-优缺点\"><a href=\"#1-3-优缺点\" class=\"headerlink\" title=\"1.3   优缺点\"></a>1.3   优缺点</h4><h5 id=\"1-3-1-优点\"><a href=\"#1-3-1-优点\" class=\"headerlink\" title=\"1.3.1    优点\"></a>1.3.1    优点</h5><p>​\t部署简单</p>\n<p>​\t维护方便</p>\n<p>​\t成本低</p>\n<h5 id=\"1-3-2-缺点\"><a href=\"#1-3-2-缺点\" class=\"headerlink\" title=\"1.3.2    缺点\"></a>1.3.2    缺点</h5><p>​\t当项目规模大、用户访问频率高、并发量大、数据量大时，会大大降低程序执行效率，甚至出现服务器宕机等情况。</p>\n<h4 id=\"1-4-适用项目\"><a href=\"#1-4-适用项目\" class=\"headerlink\" title=\"1.4   适用项目\"></a>1.4   适用项目</h4><p>传统管理项目，小型互联网项目。</p>\n<h4 id=\"2-分布式架构\"><a href=\"#2-分布式架构\" class=\"headerlink\" title=\"2     分布式架构\"></a>2     分布式架构</h4><h5 id=\"2-1-架构图（简易版）\"><a href=\"#2-1-架构图（简易版）\" class=\"headerlink\" title=\"2.1   架构图（简易版）\"></a>2.1   架构图（简易版）</h5><p>​\t分布式架构会把一个项目按照特定要求（多按照模块或功能）拆分成多个项目，每个项目分别部署到不同的服务器上。</p>\n<img data-src=\"/2022/10/07/RPC/rpc-02.png\" class=\"\">\n\n\n<h5 id=\"2-2-软件代码结构\"><a href=\"#2-2-软件代码结构\" class=\"headerlink\" title=\"2.2   软件代码结构\"></a>2.2   软件代码结构</h5><pre><code>项目1：\n  --com.msb.xxx\n    -- controller\n    -- service\n    -- mapper\n项目2\n  --com.msb.mmm\n    -- controller\n    -- service\n    -- mapper\n</code></pre>\n<h4 id=\"2-3-优缺点\"><a href=\"#2-3-优缺点\" class=\"headerlink\" title=\"2.3   优缺点\"></a>2.3   优缺点</h4><h5 id=\"2-3-1-优点\"><a href=\"#2-3-1-优点\" class=\"headerlink\" title=\"2.3.1    优点\"></a>2.3.1    优点</h5><p>​\t增大了系统可用性。减少单点故障，导致整个应用不可用。</p>\n<p>​\t增加重用性。因为模块化，所以重用性更高。</p>\n<p>​\t增加可扩展性。有新的模块增加新的项目即可。</p>\n<p>​\t增加每个模块的负载能力。因为每个模块都是一个项目，所以每个模块的负载能力更强。</p>\n<h5 id=\"2-3-2-缺点\"><a href=\"#2-3-2-缺点\" class=\"headerlink\" title=\"2.3.2    缺点\"></a>2.3.2    缺点</h5><p>​\t成本更高。</p>\n<p>​\t架构更加复杂。</p>\n<p>​\t整体响应之间变长，一些业务需要多项目通信后给出结果。</p>\n<p>​\t吞吐量更大。吞吐量&#x3D; 请求数&#x2F;秒。</p>\n<h4 id=\"2-4-待解决问题\"><a href=\"#2-4-待解决问题\" class=\"headerlink\" title=\"2.4   待解决问题\"></a>2.4   待解决问题</h4><p>​\t分布式架构中各个模块如何进行通信？</p>\n<p>​\t可以使用Http协议，也可以使用RPC协议通信，也可以使用其他的通信方式。我们本阶段使用的是RPC协议，因为它比HTTP更适合项目内部通信。</p>\n<h3 id=\"三、RPC简介\"><a href=\"#三、RPC简介\" class=\"headerlink\" title=\"三、RPC简介\"></a>三、RPC简介</h3><h4 id=\"1-RFC\"><a href=\"#1-RFC\" class=\"headerlink\" title=\"1     RFC\"></a>1     RFC</h4><p>​\tRFC(Request For Comments) 是由互联网工程任务组(IETF)发布的文件集。文件集中每个文件都有自己唯一编号，例如：rfc1831。目前RFC文件由互联网协会(Internet Society，ISOC)赞助发型。</p>\n<p>​\tRPC就收集到了rfc 1831中。可以通过下面网址查看：</p>\n<p>​\t<span class=\"exturl\" data-url=\"aHR0cHM6Ly9kYXRhdHJhY2tlci5pZXRmLm9yZy9kb2MvcmZjMTgzMS8=\">https://datatracker.ietf.org/doc/rfc1831/</span></p>\n<h4 id=\"2-RPC\"><a href=\"#2-RPC\" class=\"headerlink\" title=\"2     RPC\"></a>2     RPC</h4><p>​\tRPC在rfc 1831中收录 ，RPC（Remote Procedure Call） 远程过程调用协议</p>\n<p>​\tRPC协议规定允许互联网中一台主机程序调用另一台主机程序，而程序员无需对这个交互过程进行编程。在RPC协议中强调当A程序调用B程序中功能或方法时，A是不知道B中方法具体实现的。</p>\n<p>​\tRPC是上层协议，底层可以基于TCP协议，也可以基于HTTP协议。一般我们说RPC都是基于RPC的具体实现，如：Dubbo框架。从广义上讲只要是满足网络中进行通讯调用都统称为RPC，甚至HTTP协议都可以说是RPC的具体实现，但是具体分析看来RPC协议要比HTTP协议更加高效，基于RPC的框架功能更多。</p>\n<p>​\tRPC协议是基于分布式架构而出现的，所以RPC在分布式项目中有着得天独厚的优势。</p>\n<h4 id=\"3-RPC和HTTP对比\"><a href=\"#3-RPC和HTTP对比\" class=\"headerlink\" title=\"3     RPC和HTTP对比\"></a>3     RPC和HTTP对比</h4><h5 id=\"3-1-具体实现\"><a href=\"#3-1-具体实现\" class=\"headerlink\" title=\"3.1   具体实现\"></a>3.1   具体实现</h5><p>​\tRPC：可以基于TCP协议，也可以基于HTTP协议。</p>\n<p>​\tHTTP：基于HTTP协议</p>\n<h5 id=\"3-2-效率\"><a href=\"#3-2-效率\" class=\"headerlink\" title=\"3.2   效率\"></a>3.2   效率</h5><p>​\tRPC：自定义具体实现可以减少很多无用的报文内容，使得报文体积更小。</p>\n<p>​\tHTTP：如果是HTTP 1.1 报文中很多内容都是无用的。如果是HTTP2.0以后和RPC相差不大，比RPC少的可能就是一些服务治理等功能。</p>\n<h5 id=\"3-3-连接方式\"><a href=\"#3-3-连接方式\" class=\"headerlink\" title=\"3.3   连接方式\"></a>3.3   连接方式</h5><p>​\tRPC：长连接支持。</p>\n<p>​\tHTTP：每次连接都是<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vbmV2ZXJtb3Jld2FuZy9wLzg5MDY4MzMuaHRtbA==\">三次握手四次挥手</span>。</p>\n<h5 id=\"3-4-性能\"><a href=\"#3-4-性能\" class=\"headerlink\" title=\"3.4   性能\"></a>3.4   性能</h5><p>​\tRPC可以基于很多序列化方式。如：thrift</p>\n<p>​\tHTTP 主要是通过JSON，序列化和反序列效率更低。</p>\n<h5 id=\"3-5-注册中心\"><a href=\"#3-5-注册中心\" class=\"headerlink\" title=\"3.5   注册中心\"></a>3.5   注册中心</h5><p>​\tRPC ：一般RPC框架都带有注册中心。</p>\n<p>​\tHTTP：都是直连。</p>\n<h5 id=\"3-6-负载均衡\"><a href=\"#3-6-负载均衡\" class=\"headerlink\" title=\"3.6   负载均衡\"></a>3.6   负载均衡</h5><p>​\tRPC：绝大多数RPC框架都带有负载均衡测量。</p>\n<p>​\tHTTP：一般都需要借助第三方工具。如：nginx</p>\n<h5 id=\"3-7-综合结论\"><a href=\"#3-7-综合结论\" class=\"headerlink\" title=\"3.7   综合结论\"></a>3.7   综合结论</h5><p>​\tRPC框架一般都带有丰富的服务治理等功能，更适合企业内部接口调用。而HTTP更适合多平台之间相互调用。</p>\n<h3 id=\"四、HttpClient实现RPC\"><a href=\"#四、HttpClient实现RPC\" class=\"headerlink\" title=\"四、HttpClient实现RPC\"></a>四、HttpClient实现RPC</h3><h4 id=\"1-HttpClient简介\"><a href=\"#1-HttpClient简介\" class=\"headerlink\" title=\"1     HttpClient简介\"></a>1     HttpClient简介</h4><p>​\t在JDK中java.net包下提供了用户HTTP访问的基本功能，但是它缺少灵活性或许多应用所需要的功能。</p>\n<p>​\tHttpClient起初是Apache Jakarta Common 的子项目。用来提供高效的、最新的、功能丰富的支持 HTTP 协议的客户端编程工具包，并且它支持 HTTP 协议最新的版本。2007年成为顶级项目。</p>\n<p>​\t通俗解释：HttpClient可以实现使用Java代码完成标准HTTP请求及响应。</p>\n<h4 id=\"2-代码实现\"><a href=\"#2-代码实现\" class=\"headerlink\" title=\"2     代码实现\"></a>2     代码实现</h4><h5 id=\"2-1-服务端\"><a href=\"#2-1-服务端\" class=\"headerlink\" title=\"2.1   服务端\"></a>2.1   服务端</h5><p>​\t新建项目HttpClientServer</p>\n<h5 id=\"2-1-1-新建控制器\"><a href=\"#2-1-1-新建控制器\" class=\"headerlink\" title=\"2.1.1    新建控制器\"></a>2.1.1    新建控制器</h5><p>com.msb.controller.DemoController</p>\n<pre><code class=\"java\">@Controller\npublic class DemoController &#123;\n    @RequestMapping(&quot;/demo&quot;)\n    @ResponseBody\n    public String demo(String param)&#123;\n        return &quot;demo&quot;+param;\n    &#125;\n&#125;\n</code></pre>\n<h5 id=\"2-1-2-新建启动器\"><a href=\"#2-1-2-新建启动器\" class=\"headerlink\" title=\"2.1.2    新建启动器\"></a>2.1.2    新建启动器</h5><p>​\t新建启动器</p>\n<p>com.msb.HttpClientServerApplication</p>\n<pre><code class=\"java\">@SpringBootApplication\npublic class HttpClientServerApplication &#123;\n    public static void main(String[] args) &#123;\n    SpringApplication.run(HttpClientServerApplication.class,args);\n    &#125;\n&#125;\n</code></pre>\n<h4 id=\"2-2-客户端\"><a href=\"#2-2-客户端\" class=\"headerlink\" title=\"2.2   客户端\"></a>2.2   客户端</h4><p>​\t新建HttpClientDemo项目</p>\n<h5 id=\"2-2-1-添加依赖\"><a href=\"#2-2-1-添加依赖\" class=\"headerlink\" title=\"2.2.1    添加依赖\"></a>2.2.1    添加依赖</h5><pre><code class=\"xml\"> &lt;dependency&gt;\n        &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt;\n        &lt;artifactId&gt;httpclient&lt;/artifactId&gt;\n        &lt;version&gt;4.5.10&lt;/version&gt;\n &lt;/dependency&gt;\n</code></pre>\n<h5 id=\"2-2-2-新建类\"><a href=\"#2-2-2-新建类\" class=\"headerlink\" title=\"2.2.2    新建类\"></a>2.2.2    新建类</h5><p>​\t新建com.msb.HttpClientDemo，编写主方法。</p>\n<h6 id=\"2-2-2-1-使用GET方法访问\"><a href=\"#2-2-2-1-使用GET方法访问\" class=\"headerlink\" title=\"2.2.2.1 使用GET方法访问\"></a>2.2.2.1 使用GET方法访问</h6><pre><code class=\"java\">public static void main(String[] args) &#123;\n    try &#123;\n        //创建http工具（理解成:浏览器） 发起请求，解析响应\n        CloseableHttpClient httpClient = HttpClients.createDefault();\n        //请求路径\n        URIBuilder uriBuilder = new URIBuilder(&quot;http://localhost:8080/demo&quot;);\n        uriBuilder.addParameter(&quot;param&quot;, &quot;get123&quot;);\n        //创建HttpGet请求对象\n        HttpGet get = new HttpGet(uriBuilder.build());\n        //创建响应对象\n        CloseableHttpResponse response = httpClient.execute(get);\n        //由于响应体是字符串，因此把HttpEntity类型转换为字符串类型，并设置字符编码\n        String result = EntityUtils.toString(response.getEntity(), &quot;utf-8&quot;);\n        //输出结果\n        System.out.println(result);\n        //释放资源\n        response.close();\n        httpClient.close();\n    &#125; catch (URISyntaxException e) &#123;\n        e.printStackTrace();\n    &#125; catch (IOException e) &#123;\n        e.printStackTrace();\n    &#125;\n&#125;\n</code></pre>\n<h6 id=\"2-2-2-2-使用POST方式访问\"><a href=\"#2-2-2-2-使用POST方式访问\" class=\"headerlink\" title=\"2.2.2.2 使用POST方式访问\"></a>2.2.2.2 使用POST方式访问</h6><pre><code class=\"java\">public class HttpClientDemo &#123;\n    public static void main(String[] args) &#123;\n        try &#123;\n            //创建http工具（理解成:浏览器） 发起请求，解析响应\n            CloseableHttpClient httpClient = HttpClients.createDefault();\n            //创建HttpPOST请求对象\n            HttpPost post = new HttpPost(&quot;http://localhost:8080/demo&quot;);\n            //所有请求参数\n            List&lt;NameValuePair&gt; params = new ArrayList&lt;&gt;();\n            params.add(new BasicNameValuePair(&quot;param&quot;,&quot;123&quot;));\n            //创建HttpEntity接口的文本实现类的对象，放入参数并设置编码\n            HttpEntity httpEntity = new UrlEncodedFormEntity(params,&quot;utf-8&quot;);\n            //放入到HttpPost对象中\n            post.setEntity(httpEntity);            \n            //创建响应对象\n            CloseableHttpResponse response = httpClient.execute(post);\n            //由于响应体是字符串，因此把HttpEntity类型转换为字符串类型\n            String result = EntityUtils.toString(response.getEntity());\n            //输出结果\n            System.out.println(result);\n            //释放资源\n            response.close();\n            httpClient.close();\n        &#125; catch (IOException e) &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<h4 id=\"3-Jackson用法\"><a href=\"#3-Jackson用法\" class=\"headerlink\" title=\"3. Jackson用法\"></a>3. Jackson用法</h4><h5 id=\"3-1-把对象转换为json字符串\"><a href=\"#3-1-把对象转换为json字符串\" class=\"headerlink\" title=\"3.1   把对象转换为json字符串\"></a>3.1   把对象转换为json字符串</h5><pre><code class=\"java\">ObjectMapper objectMapper = new ObjectMapper();\nPeople peo = new People();\nobjectMapper.writeValueAsString(peo);\n</code></pre>\n<h5 id=\"3-2-把json字符串转换为对象\"><a href=\"#3-2-把json字符串转换为对象\" class=\"headerlink\" title=\"3.2   把json字符串转换为对象\"></a>3.2   把json字符串转换为对象</h5><pre><code class=\"java\">ObjectMapper objectMapper = new ObjectMapper();\nPeople peo = objectMapper.readValue(content, People.class);\n</code></pre>\n<h5 id=\"3-3-把json字符串转换为List集合\"><a href=\"#3-3-把json字符串转换为List集合\" class=\"headerlink\" title=\"3.3   把json字符串转换为List集合\"></a>3.3   把json字符串转换为List集合</h5><pre><code class=\"java\">ObjectMapper objectMapper = new ObjectMapper();\nJavaType javaType = objectMapper.getTypeFactory().constructParametricType(List.class, People.class);\nList&lt;People&gt; list = objectMapper.readValue(content, javaType);\n</code></pre>\n<h4 id=\"4-HttpClient请求包含JSON\"><a href=\"#4-HttpClient请求包含JSON\" class=\"headerlink\" title=\"4     HttpClient请求包含JSON\"></a>4     HttpClient请求包含JSON</h4><h5 id=\"4-1-java代码实现\"><a href=\"#4-1-java代码实现\" class=\"headerlink\" title=\"4.1   java代码实现\"></a>4.1   java代码实现</h5><pre><code class=\"java\">public class HttpClientDemo &#123;\n    public static void main(String[] args) &#123;\n        try &#123;\n            CloseableHttpClient httpClient = HttpClients.createDefault();\n            HttpPost post = new HttpPost(&quot;http://localhost:8080/demo&quot;);\n            HttpEntity httpEntity= null;\n            String json = &quot;&#123;&#125;&quot;;\n            StringEntity entity = new StringEntity(json, ContentType.APPLICATION_JSON);\n            post.setEntity(entity);\n            CloseableHttpResponse response = httpClient.execute(post);\n            String result = EntityUtils.toString(response.getEntity());\n            System.out.println(result);\n            response.close();\n            httpClient.close();\n        &#125; catch (IOException e) &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n&#125;\n\n @Test\n    public void testInputSteam()&#123;\n        try &#123;\n\n            CloseableHttpClient httpClient = HttpClients.createDefault();\n\n            URIBuilder uriBuilder = new URIBuilder(&quot;http://localhost:8080/demo4&quot;);\n\n            HttpPost httpPost = new HttpPost(uriBuilder.build());\n            //创建集合\n            List&lt;User&gt; users = new ArrayList&lt;&gt;();\n            users.add(new User(2,&quot;李四&quot;));\n            users.add(new User(1,&quot;张三&quot;));\n            //将集合对象转化成JSON字符串\n            ObjectMapper objectMapper = new ObjectMapper();\n            String UserJson = objectMapper.writeValueAsString(users);\n            System.out.println(UserJson);\n            StringEntity stringEntity = new StringEntity(UserJson, \t\t  ContentType.APPLICATION_JSON);\n            //设置请求体\n            httpPost.setEntity(stringEntity);\n            CloseableHttpResponse response= httpClient.execute(httpPost);\n            String result = EntityUtils.toString(response.getEntity());\n            System.out.println(result);\n\n            response.close();\n            httpClient.close();\n        &#125; catch (Exception e) &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n</code></pre>\n<h4 id=\"5-控制器接口参数\"><a href=\"#5-控制器接口参数\" class=\"headerlink\" title=\"5     控制器接口参数\"></a>5     控制器接口参数</h4><p>​\t@RequestBody把请求体中流数据转换为指定的对象。多用在请求参数是json数据且请求的Content-Type&#x3D;”application&#x2F;json”</p>\n<pre><code class=\"java\">@RequestMapping(&quot;/demo4&quot;)\n@ResponseBody\npublic String demo4(@RequestBody List&lt;People&gt; list) &#123;\n    System.out.println(list);\n    return list.toString();\n&#125;\n</code></pre>\n<h4 id=\"6-Ajax发送json参数写法\"><a href=\"#6-Ajax发送json参数写法\" class=\"headerlink\" title=\"6   Ajax发送json参数写法\"></a>6   Ajax发送json参数写法</h4><pre><code class=\"html\">var json = &#39;[&#123;&quot;id&quot;:123,&quot;name&quot;:&quot;msb&quot;&#125;,&#123;&quot;id&quot;:123,&quot;name&quot;:&quot;mashibing&quot;&#125;]&#39;;\n $.ajax(&#123;\n     url:&#39;/demo5&#39;,\n     type:&#39;post&#39;,\n     success:function(data)&#123;\n         alert(data);\n         for(var i = 0 ;i&lt;data.length;i++)&#123;\n\n             alert(data[i].id +&quot;  &quot;+data[i].name);\n         &#125;\n     &#125;,\n     contentType:&#39;application/json&#39;,//请求体中内容类型\n     dataType:&#39;json&#39;,//响应内容类型。\n     data:json\n &#125;);\n</code></pre>\n<h4 id=\"7-跨域\"><a href=\"#7-跨域\" class=\"headerlink\" title=\"7     跨域\"></a>7     跨域</h4><p>​\t跨域：协议、ip、端口中只要有一个不同就是跨域请求。</p>\n<p>​\t同源策略：浏览器默认只允许ajax访问同源(协议、ip、端口都相同)内容。</p>\n<p>​\t解决同源策略：</p>\n<p>​\t在控制器接口上添加@CrossOrigin。表示允许跨域。本质在响应头中添加Access-Control-Allow-Origin: *</p>\n<pre><code class=\"html\">var json = &#39;[&#123;&quot;id&quot;:123,&quot;name&quot;:&quot;msb&quot;&#125;,&#123;&quot;id&quot;:456,&quot;name&quot;:&quot;mashibing&quot;&#125;]&#39;;\n $.ajax(&#123;\n     url:&#39;/demo5&#39;,\n     type:&#39;post&#39;,\n     success:function(data)&#123;\n         alert(data);\n         for(var i = 0 ;i&lt;data.length;i++)&#123;\n\n             alert(data[i].id +&quot;  &quot;+data[i].name);\n         &#125;\n     &#125;,\n     contentType:&#39;application/json&#39;,//请求体中内容类型\n     dataType:&#39;json&#39;,//响应内容类型。\n     data:json\n &#125;);\n</code></pre>\n<h3 id=\"五、RMI实现RPC\"><a href=\"#五、RMI实现RPC\" class=\"headerlink\" title=\"五、RMI实现RPC\"></a>五、RMI实现RPC</h3><h4 id=\"1-RMI简-介\"><a href=\"#1-RMI简-介\" class=\"headerlink\" title=\"1     RMI简 介\"></a>1     RMI简 介</h4><p>​\tRMI(Remote Method Invocation) 远程方法调用。</p>\n<p>​\tRMI是从JDK1.2推出的功能，它可以实现在一个Java应用中可以像调用本地方法一样调用另一个服务器中Java应用（JVM）中的内容。</p>\n<p>​\tRMI 是Java语言的远程调用，无法实现跨语言。</p>\n<h4 id=\"2-执行流程\"><a href=\"#2-执行流程\" class=\"headerlink\" title=\"2     执行流程\"></a>2     执行流程</h4><img data-src=\"/2022/10/07/RPC/rpc-03.png\" class=\"\">\n\n\n<p>​\tRegistry(注册表)是放置所有服务器对象的命名空间。 每次服务端创建一个对象时，它都会使用bind()或rebind()方法注册该对象。 这些是使用称为绑定名称的唯一名称注册的。 </p>\n<p>​\t要调用远程对象，客户端需要该对象的引用。即通过服务端绑定的名称从注册表中获取对象(lookup()方法)。</p>\n<h4 id=\"3-API介绍\"><a href=\"#3-API介绍\" class=\"headerlink\" title=\"3     API介绍\"></a>3     API介绍</h4><h5 id=\"3-1-Remote\"><a href=\"#3-1-Remote\" class=\"headerlink\" title=\"3.1   Remote\"></a>3.1   Remote</h5><p>​\tjava.rmi.Remote 定义了此接口为远程调用接口。如果接口被外部调用，需要继承此接口。</p>\n<pre><code class=\"java\">public interface Remote&#123;&#125;\n</code></pre>\n<h4 id=\"3-2-RemoteException\"><a href=\"#3-2-RemoteException\" class=\"headerlink\" title=\"3.2   RemoteException\"></a>3.2   RemoteException</h4><p>​\tjava.rmi.RemoteException</p>\n<p>​\t继承了Remote接口的接口中，如果方法是允许被远程调用的，需要抛出此异常。</p>\n<h4 id=\"3-3-UnicastRemoteObject\"><a href=\"#3-3-UnicastRemoteObject\" class=\"headerlink\" title=\"3.3   UnicastRemoteObject\"></a>3.3   UnicastRemoteObject</h4><p>​\tjava.rmi.server.UnicastRemoteObject</p>\n<p>​\t此类实现了Remote接口和Serializable接口。</p>\n<p>​\t自定义接口实现类除了实现自定义接口还需要继承此类。</p>\n<h4 id=\"3-4-LocateRegistry\"><a href=\"#3-4-LocateRegistry\" class=\"headerlink\" title=\"3.4   LocateRegistry\"></a>3.4   LocateRegistry</h4><p>​\tjava.rmi.registry.LocateRegistry</p>\n<p>​\t可以通过LocateRegistry在本机上创建Registry，通过特定的端口就可以访问这个Registry。</p>\n<h4 id=\"3-5-Naming\"><a href=\"#3-5-Naming\" class=\"headerlink\" title=\"3.5   Naming\"></a>3.5   Naming</h4><p>​\tjava.rmi.Naming</p>\n<p>​\tNaming定义了发布内容可访问RMI名称。也是通过Naming获取到指定的远程方法。</p>\n<h4 id=\"4-代码实现\"><a href=\"#4-代码实现\" class=\"headerlink\" title=\"4     代码实现\"></a>4     代码实现</h4><h5 id=\"4-1-服务端创建\"><a href=\"#4-1-服务端创建\" class=\"headerlink\" title=\"4.1   服务端创建\"></a>4.1   服务端创建</h5><p>​\t创建RmiServer项目</p>\n<h5 id=\"4-1-1-编写接口\"><a href=\"#4-1-1-编写接口\" class=\"headerlink\" title=\"4.1.1    编写接口\"></a>4.1.1    编写接口</h5><p>​\tcom.msb.service.DemoService 编写</p>\n<pre><code class=\"java\">public interface DemoService extends Remote &#123;\n    String demo(String demo) throws RemoteException;\n&#125;\n</code></pre>\n<h5 id=\"4-1-2-编写实现类\"><a href=\"#4-1-2-编写实现类\" class=\"headerlink\" title=\"4.1.2    编写实现类\"></a>4.1.2    编写实现类</h5><p>​\tcom.msb.service.impl.DemoServiceImpl 编写。</p>\n<p>​\t注意：构造方法是public的。默认生成protected</p>\n<pre><code class=\"java\">public class DemoServiceImpl extends UnicastRemoteObject implements DemoService &#123;\n    public DemoServiceImpl() throws RemoteException &#123;\n    &#125;\n    @Override\n    public String demo(String demo) throws RemoteException &#123;\n        return demo+&quot;123&quot;;\n    &#125;\n&#125;\n</code></pre>\n<h5 id=\"4-1-3-编写主方法\"><a href=\"#4-1-3-编写主方法\" class=\"headerlink\" title=\"4.1.3    编写主方法\"></a>4.1.3    编写主方法</h5><p>​\t编写com.msb.DemoServer类，生成主方法</p>\n<pre><code class=\"java\">public class DemoServiceImpl extends UnicastRemoteObject implements DemoService &#123;\n    public DemoServiceImpl() throws RemoteException &#123;\n    &#125;\n    @Override\n    public String demo(String demo) throws RemoteException &#123;\n        return demo+&quot;123&quot;;\n    &#125;\n&#125;\n</code></pre>\n<pre><code class=\"java\">public class DemoStart &#123;\n    public static void main(String[] args) &#123;\n        try &#123;\n            //1创建接口实现类\n            RmiDemo rmiDemo = new RmiDemoImpl();\n            //2创建注册表\n            LocateRegistry.createRegistry(8099);\n            //3绑定服务\n            Naming.bind(&quot;rmi://localhost:8099/rmiDemo&quot;,rmiDemo);\n\n            System.out.println(&quot;服务器启动！&quot;);\n        &#125; catch (RemoteException e) &#123;\n            e.printStackTrace();\n        &#125; catch (AlreadyBoundException e) &#123;\n            e.printStackTrace();\n        &#125; catch (MalformedURLException e) &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<h5 id=\"4-1-4-运行项目\"><a href=\"#4-1-4-运行项目\" class=\"headerlink\" title=\"4.1.4    运行项目\"></a>4.1.4    运行项目</h5><p>​\t运行后项目，项目一直处于启动状态，表示可以远程访问此项目中的远程方法。</p>\n<h4 id=\"4-2-创建客户端代码\"><a href=\"#4-2-创建客户端代码\" class=\"headerlink\" title=\"4.2   创建客户端代码\"></a>4.2   创建客户端代码</h4><p>​\t创建项目RmiClient</p>\n<h5 id=\"4-2-1-复制服务端接口\"><a href=\"#4-2-1-复制服务端接口\" class=\"headerlink\" title=\"4.2.1    复制服务端接口\"></a>4.2.1    复制服务端接口</h5><p>​\t把服务端com.msb.service.DemoService粘贴到项目中</p>\n<h5 id=\"4-2-2-创建主方法类\"><a href=\"#4-2-2-创建主方法类\" class=\"headerlink\" title=\"4.2.2    创建主方法类\"></a>4.2.2    创建主方法类</h5><p>​\t新建com.msb.DemoClient</p>\n<pre><code class=\"java\">public class DemoServiceImpl extends UnicastRemoteObject implements DemoService &#123;\n    public DemoServiceImpl() throws RemoteException &#123;\n    &#125;\n    @Override\n    public String demo(String demo) throws RemoteException &#123;\n        return demo+&quot;123&quot;;\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"六、Zookeeper安装\"><a href=\"#六、Zookeeper安装\" class=\"headerlink\" title=\"六、Zookeeper安装\"></a>六、Zookeeper安装</h3><h4 id=\"1-Zookeeper简介\"><a href=\"#1-Zookeeper简介\" class=\"headerlink\" title=\"1     Zookeeper简介\"></a>1     Zookeeper简介</h4><p>​\tzookeeper分布式管理软件。常用它做注册中心（依赖zookeeper的发布&#x2F;订阅功能）、配置文件中心、分布式锁配置、集群管理等。</p>\n<p>​\tzookeeper一共就有两个版本。主要使用的是java语言写的。</p>\n<h4 id=\"2-安装\"><a href=\"#2-安装\" class=\"headerlink\" title=\"2     安装\"></a>2     安装</h4><h5 id=\"2-1-上传压缩文件\"><a href=\"#2-1-上传压缩文件\" class=\"headerlink\" title=\"2.1   上传压缩文件\"></a>2.1   上传压缩文件</h5><p>​\t上传到 &#x2F;usr&#x2F;local&#x2F;tmp中</p>\n<h4 id=\"2-2-解压\"><a href=\"#2-2-解压\" class=\"headerlink\" title=\"2.2   解压\"></a>2.2   解压</h4><pre><code class=\"sh\">tar zxf apache-zookeeper-3.5.5-bin.tar.gz\ncp -r apache-zookeeper-3.5.5-bin ../zookeeper\n</code></pre>\n<h4 id=\"2-3-新建data目录\"><a href=\"#2-3-新建data目录\" class=\"headerlink\" title=\"2.3   新建data目录\"></a>2.3   新建data目录</h4><p>进入到zookeeper中</p>\n<pre><code class=\"sh\">cd /usr/local/zookeeper\nmkdir data\n</code></pre>\n<h4 id=\"2-4-修改配置文件\"><a href=\"#2-4-修改配置文件\" class=\"headerlink\" title=\"2.4   修改配置文件\"></a>2.4   修改配置文件</h4><p>进入conf中</p>\n<pre><code class=\"sh\">cd conf\ncp zoo_sample.cfg zoo.cfg\nvim zoo.cfg\n</code></pre>\n<p>修改dataDir为data文件夹路径</p>\n<pre><code class=\"sh\">dataDir=/usr/local/zookeeper/data\n</code></pre>\n<h4 id=\"2-5-启动zookeeper\"><a href=\"#2-5-启动zookeeper\" class=\"headerlink\" title=\"2.5   启动zookeeper\"></a>2.5   启动zookeeper</h4><p>进入bin文件夹</p>\n<pre><code class=\"sh\">cd /usr/local/zookeeper/bin\n./zkServer.sh start\n</code></pre>\n<p>通过status查看启动状态。稍微有个等待时间</p>\n<p># .&#x2F;zkServer.sh status</p>\n<h3 id=\"六、Zookeeper安装-Docker\"><a href=\"#六、Zookeeper安装-Docker\" class=\"headerlink\" title=\"六、Zookeeper安装(Docker)\"></a>六、Zookeeper安装(Docker)</h3><p><strong>资料：</strong></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuY25ibG9ncy5jb20va2luZ2tvby9wLzg3MzI0NDguaHRtbA==\">https://www.cnblogs.com/kingkoo/p/8732448.html</span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL2F2ODA4NzQ2NjY/ZnJvbT1zZWFyY2gmYW1wO3NlaWQ9MTYyOTE0NTAyNTIxMTk5OTEwNCZhbXA7c3BtX2lkX2Zyb209MzMzLjMzNy4wLjA=\">https://www.bilibili.com/video/av80874666?from=search&amp;seid=1629145025211999104&amp;spm_id_from=333.337.0.0</span></p>\n<h4 id=\"1-Zookeeper简介-1\"><a href=\"#1-Zookeeper简介-1\" class=\"headerlink\" title=\"1     Zookeeper简介\"></a>1     Zookeeper简介</h4><p>​\tzookeeper分布式管理软件。常用它做注册中心（依赖zookeeper的发布&#x2F;订阅功能）、配置文件中心、分布式锁配置、集群管理等。</p>\n<p>​\tzookeeper一共就有两个版本。主要使用的是java语言写的。</p>\n<h4 id=\"2-安装-1\"><a href=\"#2-安装-1\" class=\"headerlink\" title=\"2     安装\"></a>2     安装</h4><h5 id=\"2-1-拉取镜像\"><a href=\"#2-1-拉取镜像\" class=\"headerlink\" title=\"2.1   拉取镜像\"></a>2.1   拉取镜像</h5><ul>\n<li><p>自定义zookeeper目录</p>\n<pre><code class=\"shell\">mkdir /root/zookeeper\n\nmkdir /root/zookeeper/data #原因参照上面 -在docker中data其实也不用在宿主机行自己生成(目前如此)\n\n#仓库官网查看版本或者用命令直接查\ndocker search zookeeper\n\n#拉取特定版本（3.5）\ndocker pull zookeeper:3.5\n</code></pre>\n</li>\n</ul>\n<h4 id=\"2-2-创建并启动容器\"><a href=\"#2-2-创建并启动容器\" class=\"headerlink\" title=\"2.2 创建并启动容器\"></a>2.2 创建并启动容器</h4><p>​\t<strong>注：就目前而且 好像直接在docker中使用 zookeeper 不需要过多的配置，直接用命令创建吧，下面的解释先不看，具体原因后面补充</strong></p>\n<p>命令：</p>\n<pre><code class=\"shell\">docker run -d --name zookeeper -v /root/zookeeper/data:/data -p 2181:2181 --restart always zookeeper:3.5\n</code></pre>\n<ul>\n<li><code>--restart always</code>：始终重启</li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vYWdlb3ZiL3AvMTUzMjg3OTYuaHRtbA==\">https://www.cnblogs.com/ageovb/p/15328796.html</span></li>\n</ul>\n<p><strong>解释</strong></p>\n<ul>\n<li><p>1、这里为啥只挂载了 data 目录–》因为当我们 没有直接的安装压缩包时，我们的就没有配置文件，所以我们直接生成，容器中就回自动生成conf文件，其中就有我们需要的 一系列配置文件，我们第一次创建的时候就可以如此，我们在进<strong>行配置文件的修改完成</strong>后，要将所有配置文件放到我们  bash 目录中的 conf 文件中去。</p>\n</li>\n<li><p>2、第一次进入容器</p>\n<ul>\n<li><p>在bash目录下进入bin 目录然后输入开启客户端命令</p>\n<pre><code class=\"shell\">./zkCli.sh\n</code></pre>\n</li>\n</ul>\n</li>\n<li><p>3、第二次进入容器</p>\n<pre><code class=\"shell\">docker exec -it zookeeper /bin/bash  -p    端口号\n或\ndocker exec -it zookeeper zkCli.sh\n</code></pre>\n</li>\n</ul>\n<p><strong>只看到这就可*，容器创建成功就可以直接用了，还没有出现问题。有待补充</strong></p>\n<h4 id=\"2-3-修改配置文件\"><a href=\"#2-3-修改配置文件\" class=\"headerlink\" title=\"2.3   修改配置文件\"></a>2.3   修改配置文件</h4><ul>\n<li>配置文件来源<ul>\n<li>1、可以去我们的资料中直接解压出<strong>conf</strong>目录粘贴到我们的 zookeeper 目录中去</li>\n<li>2、可以直接进行第 3 步，完事之后直接会在容器中生成。找到conf文件，修改其中的 zoo.cfg文件，</li>\n</ul>\n</li>\n</ul>\n<p>进入容器后，找到conf中的 **zoo.cfg文件，接下来就是修改 <strong>dataDir</strong> 路径为容器中的 data文件目录。</p>\n<p>前提是要下载 vim ，因为容器中没有，命令是：</p>\n<pre><code class=\"sh\">apt-get update\n\napt-get install -y vim\n\ncd conf\n# 没有zoo.cfg 就先拷贝 zoo_sample.cfg 两个其实是一个文件，内容相同\n#cp zoo_sample.cfg zoo.cfg\nvim zoo.cfg\n</code></pre>\n<p>修改dataDir为data文件夹路径</p>\n<pre><code class=\"sh\">dataDir=/usr/local/zookeeper/data\n</code></pre>\n<h3 id=\"注：docker集群搭建在solr笔记中\"><a href=\"#注：docker集群搭建在solr笔记中\" class=\"headerlink\" title=\"注：docker集群搭建在solr笔记中\"></a>注：docker集群搭建在solr笔记中</h3><h3 id=\"七、Zookeeper客户端常用命令\"><a href=\"#七、Zookeeper客户端常用命令\" class=\"headerlink\" title=\"七、Zookeeper客户端常用命令\"></a>七、Zookeeper客户端常用命令</h3><p>​\t进入到.&#x2F;zkCli.sh命令行工具后，可以使用下面常用命令</p>\n<h4 id=\"1-ls\"><a href=\"#1-ls\" class=\"headerlink\" title=\"1    ls\"></a>1    ls</h4><p>​\tls [-s][-R] &#x2F;path</p>\n<p>​\t-s 详细信息，替代老版的ls2</p>\n<p>​\t-R 当前目录和子目录中内容都罗列出来</p>\n<p>​\t例如：ls -R &#x2F; 显示根目录下所有内容</p>\n<h4 id=\"2-create\"><a href=\"#2-create\" class=\"headerlink\" title=\"2     create\"></a>2     create</h4><p>​\tcreate &#x2F;path [data]</p>\n<p>​\t[data] 包含内容</p>\n<p>​\t创建指定路径信息</p>\n<p>​\t例如：create &#x2F;demo 创建&#x2F;demo</p>\n<h4 id=\"3-get\"><a href=\"#3-get\" class=\"headerlink\" title=\"3     get\"></a>3     get</h4><p>​\tget [-s] &#x2F;path</p>\n<p>​\t[-s] 详细信息</p>\n<p>​\t查看指定路径下内容。</p>\n<p>​\t例如： get -s &#x2F;demo</p>\n<img data-src=\"/2022/10/07/RPC/rpc-04.png\" class=\"\">\n\n\n<p>​\tnull:存放的数据</p>\n<p>​\tcZxid:创建时zxid(znode每次改变时递增的事务id)</p>\n<p>​\tctime:创建时间戳</p>\n<p>​\tmZxid:最近一次更新的zxid</p>\n<p>​\tmtime:最近一次更新的时间戳</p>\n<p>​\tpZxid:子节点的zxid</p>\n<p>​\tcversion:子节点更新次数</p>\n<p>​\tdataversion:节点数据更新次数</p>\n<p>​\taclVersion:节点ACL(授权信息)的更新次数</p>\n<p>​\tephemeralOwner:如果该节点为ephemeral节点(临时，生命周期与session一样), ephemeralOwner值表示与该节点绑定的session id. 如果该节点不是ephemeral节点, ephemeralOwner值为0.</p>\n<p>​\tdataLength:节点数据字节数</p>\n<p>​\tnumChildren:子节点数量</p>\n<h4 id=\"4-set\"><a href=\"#4-set\" class=\"headerlink\" title=\"4     set\"></a>4     set</h4><p>​\tset &#x2F;path data</p>\n<p>​\t设置节点内容</p>\n<h4 id=\"5-delete\"><a href=\"#5-delete\" class=\"headerlink\" title=\"5     delete\"></a>5     delete</h4><p>​\tdelete &#x2F;path</p>\n<p>​\t删除节点</p>\n<h3 id=\"八、向Zookeeper中注册内容\"><a href=\"#八、向Zookeeper中注册内容\" class=\"headerlink\" title=\"八、向Zookeeper中注册内容\"></a>八、向Zookeeper中注册内容</h3><p>​\t新建项目ZookeeperClient</p>\n<h4 id=\"1-创建-x2F-demo\"><a href=\"#1-创建-x2F-demo\" class=\"headerlink\" title=\"1     创建&#x2F;demo\"></a>1     创建&#x2F;demo</h4><p>​\t使用zookeeper的客户端命令工具创建&#x2F;demo</p>\n<pre><code class=\"sh\">./zkCli.sh\ncreate /demos\n</code></pre>\n<h4 id=\"2-添加依赖\"><a href=\"#2-添加依赖\" class=\"headerlink\" title=\"2     添加依赖\"></a>2     添加依赖</h4><pre><code class=\"xml\">    &lt;dependency&gt;\n        &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt;\n        &lt;artifactId&gt;zookeeper&lt;/artifactId&gt;\n        &lt;version&gt;3.5.5&lt;/version&gt;\n    &lt;/dependency&gt;\n</code></pre>\n<h4 id=\"3-编写代码\"><a href=\"#3-编写代码\" class=\"headerlink\" title=\"3     编写代码\"></a>3     编写代码</h4><p>​\t创建类com.msb.MyApp。</p>\n<p>​\tZooDefs.Ids.OPEN_ACL_UNSAFE 表示权限。</p>\n<p>​\tCreateMode.PERSISTENT_SEQUENTIAL 永久存储，文件内容编号递增。</p>\n<pre><code class=\"java\">public class SendContent &#123;\n    public static void main(String[] args) &#123;\n        try &#123;\n            /**\n             * 创建ZooKeeper对象\n             * param1: zookeeper_IP+端口号\n             * param2: 访问超时设置---时间设置长一点\n             * param3: 通过观察者模式发出访问回复，当连接成功后，编写成功信息\n             */\n            ZooKeeper zooKeeper = new ZooKeeper(\n                    &quot;192.168.88.128:2181&quot;,\n                    1000000,\n                    new Watcher() &#123;\n                        @Override\n                        public void process(WatchedEvent watchedEvent) &#123;\n                            System.out.println(&quot;获取链接&quot;);\n                        &#125;\n                    &#125;\n            );\n\n            /**\n             * 发送内容  向zookeeper服务器中\n             * param1: 发送的文件\n             * param2: 发送的内容(要转变成Bytes[])\n             * param3: 权限\n             * param4: 内容的模式\n             */\n            String result = zooKeeper.create(\n                    &quot;/demos/rmi_address&quot;,\n                    &quot;rmi:localhost:8080/demoService&quot;.getBytes(),\n                    ZooDefs.Ids.OPEN_ACL_UNSAFE,\n                    CreateMode.PERSISTENT_SEQUENTIAL\n            );\n\n            System.out.println(&quot;result  -&gt; &quot;+result);\n        &#125; catch (IOException e) &#123;\n            e.printStackTrace();\n        &#125; catch (KeeperException e) &#123;\n            e.printStackTrace();\n        &#125; catch (InterruptedException e) &#123;\n            e.printStackTrace();\n        &#125;\n\n    &#125;\n&#125;\n</code></pre>\n<h4 id=\"4-查看上传数据\"><a href=\"#4-查看上传数据\" class=\"headerlink\" title=\"4     查看上传数据\"></a>4     查看上传数据</h4><p>​\tls -R &#x2F;            :查看列表</p>\n<p>​\tget  &#x2F;demo&#x2F;nn0000000002     :查看内容</p>\n<h3 id=\"九、-从zookeeper中发现内容\"><a href=\"#九、-从zookeeper中发现内容\" class=\"headerlink\" title=\"九、    从zookeeper中发现内容\"></a>九、    从zookeeper中发现内容</h3><p>​\t在原有项目中新建一个类，类中编写主方法。</p>\n<pre><code class=\"java\">public static void main(String[] args) &#123;\n    try &#123;\n        ZooKeeper zookeeper = new ZooKeeper(&quot;192.168.32.128:2181&quot;, 10000, new Watcher() &#123;\n            @Override\n            public void process(WatchedEvent watchedEvent) &#123;\n                System.out.println(&quot;获取连接&quot;);\n            &#125;\n        &#125;);\n        //获取列表\n        List&lt;String&gt; list = zookeeper.getChildren(&quot;/demo&quot;, false);\n        for (String child : list) &#123;\n            byte[] result = zookeeper.getData(&quot;/demo/&quot; + child, false, null);\n            System.out.println(new String(result));\n        &#125;\n    &#125; catch (IOException e) &#123;\n        e.printStackTrace();\n    &#125; catch (KeeperException e) &#123;\n        e.printStackTrace();\n    &#125; catch (InterruptedException e) &#123;\n        e.printStackTrace();\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"十、手写RPC框架\"><a href=\"#十、手写RPC框架\" class=\"headerlink\" title=\"十、手写RPC框架\"></a>十、手写RPC框架</h3><p>​\t使用Zookeeper作为注册中心，RMI作为连接技术，手写RPC框架。</p>\n<h4 id=\"1-创建项目ParentDemo\"><a href=\"#1-创建项目ParentDemo\" class=\"headerlink\" title=\"1     创建项目ParentDemo\"></a>1     创建项目ParentDemo</h4><p>​\t创建父项目ParentDemo。</p>\n<p>​\t包含3个聚合子项目。</p>\n<p>​\tpojo: service中需要的实体类</p>\n<p>​\tservice：包含被serviceimpl和consumer依赖的接口。</p>\n<p>​\tserviceimpl:provider提供的服务内容</p>\n<p>​\tconsumer：消费者，调用服务内容。</p>\n<h4 id=\"2-在父项目中添加依赖\"><a href=\"#2-在父项目中添加依赖\" class=\"headerlink\" title=\"2     在父项目中添加依赖\"></a>2     在父项目中添加依赖</h4><pre><code class=\"java\">public static void main(String[] args) &#123;\n    try &#123;\n        ZooKeeper zookeeper = new ZooKeeper(&quot;192.168.32.128:2181&quot;, 10000, new Watcher() &#123;\n            @Override\n            public void process(WatchedEvent watchedEvent) &#123;\n                System.out.println(&quot;获取连接&quot;);\n            &#125;\n        &#125;);\n        //获取列表\n        List&lt;String&gt; list = zookeeper.getChildren(&quot;/demo&quot;, false);\n        for (String child : list) &#123;\n            byte[] result = zookeeper.getData(&quot;/demo/&quot; + child, false, null);\n            System.out.println(new String(result));\n        &#125;\n    &#125; catch (IOException e) &#123;\n        e.printStackTrace();\n    &#125; catch (KeeperException e) &#123;\n        e.printStackTrace();\n    &#125; catch (InterruptedException e) &#123;\n        e.printStackTrace();\n    &#125;\n&#125;\n</code></pre>\n<h4 id=\"3-创建service项目\"><a href=\"#3-创建service项目\" class=\"headerlink\" title=\"3     创建service项目\"></a>3     创建service项目</h4><h4 id=\"4-创建DemoService接口\"><a href=\"#4-创建DemoService接口\" class=\"headerlink\" title=\"4     创建DemoService接口\"></a>4     创建DemoService接口</h4><p>​\t创建com.msb.DemoService</p>\n<pre><code class=\"java\">public interface DemoService extends Remote &#123;\n    String demo(String param) throws RemoteException;\n&#125;\n</code></pre>\n<h4 id=\"5-创建serviceimpl项目\"><a href=\"#5-创建serviceimpl项目\" class=\"headerlink\" title=\"5     创建serviceimpl项目\"></a>5     创建serviceimpl项目</h4><p>​\t此项目编写接口具体实现，RMI服务发布和把信息发送到Zookeeper中。</p>\n<p>​\t项目结构如下：</p>\n<p>​\t在pom.xml中添加对service项目的依赖</p>\n<pre><code class=\"xml\">&lt;dependencies&gt;\n    &lt;dependency&gt;\n        &lt;artifactId&gt;service&lt;/artifactId&gt;\n        &lt;groupId&gt;com.msb&lt;/groupId&gt;\n        &lt;version&gt;1.0.0&lt;/version&gt;\n    &lt;/dependency&gt;\n&lt;/dependencies&gt;\n</code></pre>\n<h4 id=\"6-创建DemoServiceImpl\"><a href=\"#6-创建DemoServiceImpl\" class=\"headerlink\" title=\"6     创建DemoServiceImpl\"></a>6     创建DemoServiceImpl</h4><p>​\t创建com.bjsxt.service.impl.DemoServiceImpl</p>\n<pre><code class=\"java\">public class DemoServiceImpl extends UnicastRemoteObject implements DemoService &#123;\n    public DemoServiceImpl() throws RemoteException &#123;\n    &#125;\n\n    @Override\n    public String demo(String param) throws RemoteException&#123;\n        return param+&quot;123&quot;;\n    &#125;\n&#125;\n</code></pre>\n<h4 id=\"7-创建RmiRun\"><a href=\"#7-创建RmiRun\" class=\"headerlink\" title=\"7     创建RmiRun\"></a>7     创建RmiRun</h4><p>​\t创建com.msb.RmiRun。实现RMI服务的发布和Zookeeper消息的发布。</p>\n<pre><code class=\"java\">public class RmiRun &#123;\n    public static void main(String[] args) &#123;\n        try &#123;\n            DemoService demoService = new DemoServiceImpl();\n            LocateRegistry.createRegistry(8888);\n            String url = &quot;rmi://localhost:8888/demoService&quot;;\n            Naming.bind(url,demoService);\n            ZooKeeper zookeeper = new ZooKeeper(&quot;192.168.32.128:2181&quot;, 10000, new Watcher() &#123;\n                @Override\n                public void process(WatchedEvent watchedEvent) &#123;\n                    System.out.println(&quot;获取连接&quot;);\n                &#125;\n            &#125;);\n            String content = zookeeper.create(&quot;/demo/demoService&quot;,url.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n            System.out.println(&quot;服务发布成功。。。。&quot;);\n        &#125; catch (AlreadyBoundException e) &#123;\n            e.printStackTrace();\n        &#125; catch (IOException e) &#123;\n            e.printStackTrace();\n        &#125; catch (KeeperException e) &#123;\n            e.printStackTrace();\n        &#125; catch (InterruptedException e) &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<h4 id=\"8-创建Consumer项目\"><a href=\"#8-创建Consumer项目\" class=\"headerlink\" title=\"8     创建Consumer项目\"></a>8     创建Consumer项目</h4><p>​\t新建consumer项目，此项目需要从zookeeper中获取rmi信息，并调用rmi服务</p>\n<p>​\t在pom.xml中添加对service项目的依赖</p>\n<pre><code class=\"xml\">&lt;dependencies&gt;\n    &lt;dependency&gt;\n        &lt;artifactId&gt;service&lt;/artifactId&gt;\n        &lt;groupId&gt;com.msb&lt;/groupId&gt;\n        &lt;version&gt;1.0.0&lt;/version&gt;\n    &lt;/dependency&gt;\n&lt;/dependencies&gt;\n</code></pre>\n<h4 id=\"9-创建接口和实现类\"><a href=\"#9-创建接口和实现类\" class=\"headerlink\" title=\"9     创建接口和实现类\"></a>9     创建接口和实现类</h4><p>​\t创建com.msb.service.ConsumerService接口</p>\n<p>​\t创建com.msb.service.impl.ConsumerServiceImpl实现类 </p>\n<pre><code class=\"java\">public interface ConsumerService &#123;\n    String consumerService(String param);\n&#125;\n</code></pre>\n<pre><code class=\"java\">@Service\npublic class ConsumerServiceImpl implements ConsumerService &#123;\n    @Override\n    public String consumerService(String param) &#123;\n        try &#123;\n            ZooKeeper zookeeper = new ZooKeeper(&quot;192.168.32.128:2181&quot;, 10000, new Watcher() &#123;\n                @Override\n                public void process(WatchedEvent watchedEvent) &#123;\n                    System.out.println(&quot;获取连接&quot;);\n                &#125;\n            &#125;);\n            byte[] urlByte = zookeeper.getData(&quot;/demo/demoService&quot;, false, null);\n            DemoService demoService =(DemoService) Naming.lookup(new String(urlByte));\n            String result = demoService.demo(param);\n            System.out.println(result);\n            return result;\n        &#125; catch (IOException e) &#123;\n            e.printStackTrace();\n        &#125; catch (KeeperException e) &#123;\n            e.printStackTrace();\n        &#125; catch (InterruptedException e) &#123;\n            e.printStackTrace();\n        &#125; catch (NotBoundException e) &#123;\n            e.printStackTrace();\n        &#125;\n        return null;\n    &#125;\n&#125;\n</code></pre>\n<h4 id=\"10-创建控制器\"><a href=\"#10-创建控制器\" class=\"headerlink\" title=\"10  创建控制器\"></a>10  创建控制器</h4><p>​\t创建com.msb.controller.DemoController控制器</p>\n<pre><code class=\"java\">@Controller\npublic class DemoController &#123;\n\n    @Autowired\n    private ConsumerService consumerService;\n\n    @RequestMapping(&quot;/demo&quot;)\n    @ResponseBody\n    public String demo(String param)&#123;\n        return consumerService.consumerService(param);\n    &#125;\n&#125;\n</code></pre>\n<h4 id=\"11-创建启动器\"><a href=\"#11-创建启动器\" class=\"headerlink\" title=\"11  创建启动器\"></a>11  创建启动器</h4><p>​\t创建com.msb.ConsumerApplication</p>\n<pre><code class=\"java\">@SpringBootApplication\npublic class ConsumerApplication &#123;\n    public static void main(String[] args) &#123;\n        SpringApplication.run(ConsumerApplication.class,args);\n    &#125;\n&#125;\n</code></pre>\n<h4 id=\"12-测试\"><a href=\"#12-测试\" class=\"headerlink\" title=\"12  测试\"></a>12  测试</h4><p>​\t在浏览器输入：<span class=\"exturl\" data-url=\"aHR0cDovL2xvY2FsaG9zdDo4MDgwL2RlbW8/cGFyYW09ZGVtbw==\">http://localhost:8080/demo?param=demo</span></p>\n<p>​\t观察结果是否是：demo123</p>\n",
            "tags": [
                "分布式",
                "RPC"
            ]
        }
    ]
}