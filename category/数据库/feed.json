{
    "version": "https://jsonfeed.org/version/1",
    "title": "记录“美食”每刻 • All posts by \"数据库\" category",
    "description": "记录“美食”每刻",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/2022/10/07/DataBase/Redis/Redis/",
            "url": "http://example.com/2022/10/07/DataBase/Redis/Redis/",
            "title": "Redis基础",
            "date_published": "2022-10-06T16:00:00.000Z",
            "content_html": "<h1 id=\"redis\"><a class=\"anchor\" href=\"#redis\">#</a> Redis</h1>\n<h2 id=\"一redis简介\"><a class=\"anchor\" href=\"#一redis简介\">#</a> 一.Redis 简介</h2>\n<h3 id=\"1nosql简介\"><a class=\"anchor\" href=\"#1nosql简介\">#</a> 1.NoSQL 简介</h3>\n<p>​\t目前市场主流数据存储都是使用关系型数据库。每次操作关系型数据库时都是 I/O 操作，I/O 操作是主要影响程序执行性能原因之一，连接数据库关闭数据库都是消耗性能的过程。尽量减少对数据库的操作，能够明显的提升程序运行效率。</p>\n<p>​\t针对上面的问题，市场上就出现了各种 NoSQL (Not Only SQL, 不仅仅可以使用关系型数据库) 数据库，它们的宣传口号：不是什么样的场景都必须使用关系型数据库，一些特定的场景使用 NoSQL 数据库更好。</p>\n<p>常见 NoSQL 数据库：</p>\n<p>​\tmemcached ：键值对，内存型数据库，所有数据都在内存中。</p>\n<p>​\tRedis: 和 Memcached 类似，还具备持久化能力。</p>\n<p>​\tHBase：以列作为存储。</p>\n<p>​\tMongoDB：以 Document 做存储。</p>\n<h3 id=\"2redis简介\"><a class=\"anchor\" href=\"#2redis简介\">#</a> 2.<strong>Redis 简介</strong></h3>\n<p>​\tRedis 是以 Key-Value 形式进行存储的 NoSQL 数据库。</p>\n<p>​\tRedis 是使用 C 语言进行编写的。</p>\n<p>​\t平时操作的数据都在内存中，效率特高，读的效率 110000/s，写 81000/s，所以多把 Redis 当做缓存工具使用。</p>\n<p>​\tRedis 以 solt（槽）作为数据存储单元，每个槽中可以存储 N 多个键值对。Redis 中固定具有 16384。理论上可以实现一个槽是一个 Redis。每个向 Redis 存储数据的 key 都会进行 crc16 算法得出一个值后对 16384 取余就是这个 key 存放的 solt 位置。</p>\n<p>​\t同时通过 Redis Sentinel 提供高可用，通过 Redis Cluster 提供自动分区。</p>\n<h2 id=\"二-redis单机版安装\"><a class=\"anchor\" href=\"#二-redis单机版安装\">#</a> 二. Redis 单机版安装</h2>\n<p>​\t1. 安装依赖 C 语言依赖</p>\n<p>​\tredis 使用 C 语言编写，所以需要安装 C 语言库</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>yum <span class=\"token function\">install</span> <span class=\"token parameter variable\">-y</span> gcc-c++ automake autoconf libtool <span class=\"token function\">make</span> tcl</pre></td></tr></table></figure><p>​\t2. 上传并解压</p>\n<p>​\t把 redis-5.0.5.tar.gz 上传到 /usr/local/tmp 中</p>\n<p>​\t解压文件</p>\n<pre><code># cd /usr/local/tmp\n\n# tar zxf redis-5.0.5.tar.gz\n</code></pre>\n<p>​\t3. 编译并安装</p>\n<p>​\t进入解压文件夹</p>\n<pre><code>\n# cd /usr/local/tmp/redis-5.0.5/\n\n</code></pre>\n<p>​\t编译</p>\n<pre><code>\n# make\n\n</code></pre>\n<p>​\t安装</p>\n<pre><code>\n# make install PREFIX=/usr/local/redis\n\n</code></pre>\n<p>​\t4. 开启守护进程</p>\n<p>​\t复制 cd /usr/local/tmp/redis-5.0.5 / 中 redis.conf 配置文件</p>\n<pre><code>\n# cp redis.conf /usr/local/redis/bin/\n\n</code></pre>\n<p>​\t修改配置文件</p>\n<pre><code># cd /usr/local/redis/bin/\n\n# vim redis.conf\n\n</code></pre>\n<p>​\t把 daemonize 的值由 no 修改为 yes</p>\n<p><img data-src=\"/2022/10/07/DataBase/Redis/Redis/Redis-01.jpg\" class=\"\"></p>\n<p>​\t5. 修改外部访问</p>\n<p>​\t在 redis5 中需要修改配置文件 redis.conf 允许外部访问。需要修改两处。</p>\n<p>​\t注释掉下面</p>\n<p>​\tbind 127.0.0.1</p>\n<pre><code>#bind 127.0.0.1\n\n</code></pre>\n<p>​\tprotected-mode yes 改成 no</p>\n<p><img data-src=\"/2022/10/07/DataBase/Redis/Redis/Redis-02.jpg\" class=\"\"></p>\n<p>​\t6. 启动并测试</p>\n<p>​\t启动 redis</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>./redis-server redis.conf</pre></td></tr></table></figure><p>​\t重启 redis</p>\n<pre><code>./redis-cli shutdown\n\n./redis-server redis.conf\n\n</code></pre>\n<p>​\t启动客户端工具</p>\n<p>​\t在 redis5 中客户端工具对命令会有提供功能。</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>./redis-cli</pre></td></tr></table></figure><h2 id=\"二-docker安装redis\"><a class=\"anchor\" href=\"#二-docker安装redis\">#</a> 二.、docker 安装 Redis</h2>\n<p>1、拉取镜像文件</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">docker</span> pull redis<span class=\"token punctuation\">[</span>:<span class=\"token punctuation\">(</span>版本号<span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span></pre></td></tr></table></figure><p>2、去 gitee 库中下载 redis 配置文件（docker 不自带配置文件）【也可不进行此步骤】</p>\n<p><strong>建议看完，先别操作，再看三，看完三之后再决定如何操作</strong></p>\n<p>然后按照文章内容进行，忽略下载。</p>\n<p>文章地址： <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuamI1MS5uZXQvYXJ0aWNsZS8yMDMyNzQuaHRt\">https://www.jb51.net/article/203274.htm</span></p>\n<p>、</p>\n<p></p>\n<p>3、创建一个 redis 服务容器</p>\n<p><strong>第二步进行了的</strong></p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">docker</span> run <span class=\"token parameter variable\">-p</span> <span class=\"token number\">6379</span>:6379 <span class=\"token parameter variable\">--name</span> myredis <span class=\"token parameter variable\">-v</span> /usr/local/docker/redis.conf:/etc/redis/redis.conf <span class=\"token parameter variable\">-v</span> /usr/local/docker/data:/data <span class=\"token parameter variable\">-d</span> redis redis-server /etc/redis/redis.conf <span class=\"token parameter variable\">--appendonly</span> <span class=\"token function\">yes</span></pre></td></tr></table></figure><p><strong>第二步没有进行的</strong></p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">docker</span> run <span class=\"token parameter variable\">-p</span> <span class=\"token number\">6379</span>:6379 <span class=\"token parameter variable\">--name</span> myredis <span class=\"token parameter variable\">-v</span> /root/myredis/data:/data <span class=\"token parameter variable\">-v</span> /root/myredis/conf/redis.conf:/usr/local/etc/redis/redis.conf <span class=\"token parameter variable\">-d</span> redis redis-server /usr/local/etc/redis/redis.conf <span class=\"token parameter variable\">--appendonly</span> <span class=\"token function\">yes</span></pre></td></tr></table></figure><p><strong>区别：</strong></p>\n<p>​\t其实也没有什么区别，只是映射的文件不同，也可以将第二步的文件直接创建到第二种创建服务容器的配置文件地址中去，这样也可使用第二个创建方式。</p>\n<p></p>\n<p></p>\n<h2 id=\"三redis常用的五大类型\"><a class=\"anchor\" href=\"#三redis常用的五大类型\">#</a> 三.Redis 常用的五大类型</h2>\n<p>​\t Redis 不仅仅支持简单的 k/v 类型的数据，同时还提供 list，set，zset，hash 等数据结构的存储，它还支持数据的备份，即 master-slave 模式的数据备份，同样 Redis 支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用。</p>\n<p>​        Redis 支持的五大数据类型包括 String（字符串  用法： 键  值），Hash（哈希 类似 Java 中的 map  用法： 键  键值对），List（列表  用法：键 集合 不可以重复），Set（集合 用法：键 集合 可以重复），Zset（sorted set 有序集合    用法： 键  值 值）</p>\n<h3 id=\"string字符串\"><a class=\"anchor\" href=\"#string字符串\">#</a> String（字符串）</h3>\n<p>​\tstring 是 redis 最基本的类型，你可以理解成与 Memcached 一模一样的类型，一个 key 对应一个 value。string 类型是二进制安全的。意思是 redis 的 string 可以包含任何数据。比如 jpg 图片或者序列化的对象。string 类型是 Redis 最基本的数据类型，string 类型的值最大能存储 512MB。</p>\n<p>应用场景：</p>\n<p>​\tString 是最常用的一种数据类型，普通的 key/value 存储都可以归为此类，value 其实不仅是 String，</p>\n<p>也可以是数字：比如想知道什么时候封锁一个 IP 地址 (访问超过几次)。</p>\n<h3 id=\"hash哈希\"><a class=\"anchor\" href=\"#hash哈希\">#</a> Hash（哈希）</h3>\n<p>​\tRedis hash 是一个键值 (key=&gt;value) 对集合。</p>\n<p>​\tRedis hash 是一个 string 类型的 field 和 value 的映射表，hash 特别适合用于存储对象。</p>\n<p>​\t使用场景：存储、读取、修改用户属性</p>\n<p>​\t我们简单举个实例来描述下 Hash 的应用场景，比如我们要存储一个用户信息对象数据，包含以下信息：    用户 ID，为查找的 key，</p>\n<p>​    \t存储的 value 用户对象包含姓名 name，年龄 age，生日 birthday 等信息，  如果用普通的 key/value 结构来存储，主要有以下 2 种存储方式：</p>\n<p>​    \t第一种方式将用户 ID 作为查找 key, 把其他信息封装成一个对象以序列化的方式存储，</p>\n<p>​           如：set u001 &quot;李三，18,20010101&quot;</p>\n<p>​     \t这种方式的缺点是，增加了序列化 / 反序列化的开销，并且在需要修改其中一项信息时，需要把整个对象取回，并且修改操作需要对并发进行保护，引入 CAS 等复杂问题。</p>\n<p>​     \t第二种方法是这个用户信息对象有多少成员就存成多少个 key-value 对儿，用用户 ID + 对应属性的名称作为唯一标识来取得对应属性的值，</p>\n<p>​       \t如：mset user:001:name &quot;李三&quot;user:001:age18 user:001:birthday &quot;20010101&quot;  虽然省去了序列化开销和并发问题，但是用户 ID 为重复存储，如果存在大量这样的数据，内存浪费还是非常可观的。</p>\n<p>​    \t那么 Redis 提供的 Hash 很好的解决了这个问题。</p>\n<h3 id=\"list列表\"><a class=\"anchor\" href=\"#list列表\">#</a> List（列表）</h3>\n<p>​\tRedis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）。</p>\n<p>应用场景：</p>\n<pre><code> Redis list的应用场景非常多，也是Redis最重要的数据结构之一。  \n</code></pre>\n<p>​    \t我们可以轻松地实现最新消息排行等功能。</p>\n<pre><code> Lists的另一个应用就是消息队列，可以利用Lists的PUSH操作，将任务存在Lists中，然后工作线程再用POP操作将任务取出进行执行。  \n</code></pre>\n<h3 id=\"set集合\"><a class=\"anchor\" href=\"#set集合\">#</a> Set（集合）</h3>\n<p>​\tRedis 的 Set 是 string 类型的无序集合。</p>\n<p>​\t使用场景：1. 共同好友、二度好友</p>\n<p>​\t\t\t   2. 利用唯一性，可以统计访问网站的所有独立 IP</p>\n<pre><code> Redis set对外提供的功能与list类似是一个列表的功能，特殊之处在于set是可以自动排重的，当你需要存储一个列表数据，又不希望出现重复数据时，set是一个很好的选择，并且set提供了判断某个成员是否在一个set集合内的重要接口，这个也是list所不能提供的。  \n\n\n\n\n 比如在微博应用中，每个人的好友存在一个集合（set）中，这样求两个人的共同好友的操作，可能就只需要用求交集命令即可。  \n</code></pre>\n<p>​    \tRedis 还为集合提供了求交集、并集、差集等操作，可以非常方便的实</p>\n<pre><code>实现方式：  \n</code></pre>\n<p>​    \tset 的内部实现是一个 value 永远为 null 的 HashMap，实际就是通过计算 hash 的方式来快速排重的，这也是 set 能提供判断一个成员是否在集合内的原因。</p>\n<h3 id=\"zsetsorted-set有序集合\"><a class=\"anchor\" href=\"#zsetsorted-set有序集合\">#</a> zset (sorted set：有序集合)</h3>\n<pre><code>Redis zset 和 set 一样也是string类型元素的集合,且不允许重复的成员。不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。zset的成员是唯一的,但分数(score)却可以重复。\n</code></pre>\n<p>使用场景：1. 带有权重的元素，比如一个游戏的用户得分排行榜</p>\n<p>​\t\t   2. 比较复杂的数据结构，一般用到的场景不算太多</p>\n<h2 id=\"四-redis常用命令\"><a class=\"anchor\" href=\"#四-redis常用命令\">#</a> 四. Redis 常用命令</h2>\n<p>Redis 命令相关手册有很多，下面为其中比较好用的两个</p>\n<p>1.<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cucmVkaXMubmV0LmNuL29yZGVyLw==\">https://www.redis.net.cn/order/</span></p>\n<p>2.<span class=\"exturl\" data-url=\"aHR0cDovL2RvYy5yZWRpc2ZhbnMuY29tL3RleHQtaW4=\">http://doc.redisfans.com/text-in</span></p>\n<h3 id=\"1-key操作\"><a class=\"anchor\" href=\"#1-key操作\">#</a> 1. Key 操作</h3>\n<h4 id=\"11-exists\"><a class=\"anchor\" href=\"#11-exists\">#</a> 1.1  exists</h4>\n<p>​\t判断 key 是否存在。</p>\n<p>​\t语法：exists key 名称</p>\n<p>​\t返回值：存在返回数字，不存在返回 0</p>\n<h4 id=\"12-expire\"><a class=\"anchor\" href=\"#12-expire\">#</a> 1.2 expire</h4>\n<p>​\t设置 key 的过期时间，单位秒</p>\n<p>​\t语法：expire key 秒数</p>\n<p>​\t返回值：成功返回 1，失败返回 0</p>\n<h4 id=\"13-ttl\"><a class=\"anchor\" href=\"#13-ttl\">#</a> 1.3 ttl</h4>\n<p>​\t查看 key 的剩余过期时间</p>\n<p>​\t语法：ttl key</p>\n<p>​\t返回值：返回剩余时间，如果不过期返回 - 1</p>\n<h4 id=\"14-del\"><a class=\"anchor\" href=\"#14-del\">#</a> 1.4 del</h4>\n<p>​\t根据 key 删除键值对。</p>\n<p>​\t语法：del key</p>\n<p>​\t返回值：被删除 key 的数量</p>\n<h3 id=\"2-字符串值string\"><a class=\"anchor\" href=\"#2-字符串值string\">#</a> 2. <strong>字符串值 (String)</strong></h3>\n<h4 id=\"21-set\"><a class=\"anchor\" href=\"#21-set\">#</a> 2.1 <strong>set</strong></h4>\n<p>​\t设置指定 key 的值</p>\n<p>​\t语法：set key value</p>\n<p>​\t返回值：成功 OK</p>\n<h4 id=\"22-get\"><a class=\"anchor\" href=\"#22-get\">#</a> 2.2 <strong>get</strong></h4>\n<p>​\t获取指定 key 的值</p>\n<p>​\t语法：get key</p>\n<p>​\t返回值：key 的值。不存在返回 nil</p>\n<h4 id=\"23-setnx\"><a class=\"anchor\" href=\"#23-setnx\">#</a> 2.3 <strong>setnx</strong></h4>\n<p>​\t当且仅当 key 不存在时才新增。</p>\n<p>​\t语法：setnx key value</p>\n<p>​\t返回值：不存在时返回 1，存在返回 0</p>\n<h4 id=\"24-setex\"><a class=\"anchor\" href=\"#24-setex\">#</a> 2.4 <strong>setex</strong></h4>\n<p>​\t设置 key 的存活时间，无论是否存在指定 key 都能新增，如果存在 key 覆盖旧值。同时必须指定过期时间。</p>\n<p>​\t语法：setex key seconds value</p>\n<p>​\t返回值：OK</p>\n<h3 id=\"3哈希表hash\"><a class=\"anchor\" href=\"#3哈希表hash\">#</a> 3.<strong> 哈希表 (Hash)</strong></h3>\n<p>​\tHash 类型的值中包含多组 field value。</p>\n<p><img data-src=\"/2022/10/07/DataBase/Redis/Redis/Redis-03.jpg\" class=\"\"></p>\n<h4 id=\"31-hset\"><a class=\"anchor\" href=\"#31-hset\">#</a> 3.1 <strong>hset</strong></h4>\n<p>​\t给 key 中 field 设置值。</p>\n<p>​\t语法：hset key field value</p>\n<p>​\t返回值：成功 1，失败 0</p>\n<h4 id=\"32-hget\"><a class=\"anchor\" href=\"#32-hget\">#</a> 3.2 <strong>hget</strong></h4>\n<p>​\t获取 key 中某个 field 的值</p>\n<p>​\t语法：hget key field</p>\n<p>​\t返回值：返回 field 的内容</p>\n<h4 id=\"33-hmset\"><a class=\"anchor\" href=\"#33-hmset\">#</a> 3.3 <strong>hmset</strong></h4>\n<p>​\t给 key 中多个 filed 设置值</p>\n<p>​\t语法：hmset key field value field value</p>\n<p>​\t返回值：成功 OK</p>\n<h4 id=\"34-hmget\"><a class=\"anchor\" href=\"#34-hmget\">#</a> 3.4 <strong>hmget</strong></h4>\n<p>​\t一次获取 key 中多个 field 的值</p>\n<p>​\t语法：hmget key field field</p>\n<p>​\t返回值：value 列表</p>\n<h4 id=\"35-hvals\"><a class=\"anchor\" href=\"#35-hvals\">#</a> 3.5 <strong>hvals</strong></h4>\n<p>​\t获取 key 中所有 field 的值</p>\n<p>​\t语法：hvals key</p>\n<p>​\t返回值：value 列表</p>\n<h4 id=\"36-hgetall\"><a class=\"anchor\" href=\"#36-hgetall\">#</a> 3.6 <strong>hgetall</strong></h4>\n<p>​\t获取所有 field 和 value</p>\n<p>​\t语法：hgetall key</p>\n<p>​\t返回值：field 和 value 交替显示列表</p>\n<h4 id=\"37-hdel\"><a class=\"anchor\" href=\"#37-hdel\">#</a> 3.7 <strong>hdel</strong></h4>\n<p>​\t删除 key 中任意个 field</p>\n<p>​\t语法：hdel key field field</p>\n<p>​\t返回值：成功删除 field 的数量</p>\n<h3 id=\"4-列表list\"><a class=\"anchor\" href=\"#4-列表list\">#</a> 4. <strong>列表（List）</strong></h3>\n<h4 id=\"41-rpush\"><a class=\"anchor\" href=\"#41-rpush\">#</a> 4.1 <strong>Rpush</strong></h4>\n<p>​\t向列表末尾中插入一个或多个值</p>\n<p>​\t语法；rpush key value value</p>\n<p>​\t返回值：列表长度</p>\n<h4 id=\"42-lrange\"><a class=\"anchor\" href=\"#42-lrange\">#</a> 4.2 <strong>lrange</strong></h4>\n<p>​\t返回列表中指定区间内的值。可以使用 - 1 代表列表末尾</p>\n<p>​\t语法：lrange list 0 -1</p>\n<p>​\t返回值：查询到的值</p>\n<h4 id=\"43-lpush\"><a class=\"anchor\" href=\"#43-lpush\">#</a> 4.3 <strong>lpush</strong></h4>\n<p>​\t将一个或多个值插入到列表前面</p>\n<p>​\t语法：lpush key value value</p>\n<p>​\t返回值：列表长度</p>\n<h4 id=\"44-llen\"><a class=\"anchor\" href=\"#44-llen\">#</a> 4.4 <strong>llen</strong></h4>\n<p>​\t获取列表长度</p>\n<p>​\t语法：llen key</p>\n<p>​\t返回值：列表长度</p>\n<h4 id=\"45-lrem\"><a class=\"anchor\" href=\"#45-lrem\">#</a> 4.5 <strong>lrem</strong></h4>\n<p>​\t删除列表中元素。count 为正数表示从左往右删除的数量。负数从右往左删除的数量。</p>\n<p>​\t语法：lrem key count value</p>\n<p>​\t返回值：删除数量。</p>\n<h3 id=\"5-集合set\"><a class=\"anchor\" href=\"#5-集合set\">#</a> 5 <strong>集合 (Set)</strong></h3>\n<p>​\tset 和 java 中集合一样。</p>\n<h4 id=\"51-sadd\"><a class=\"anchor\" href=\"#51-sadd\">#</a> 5.1 <strong>sadd</strong></h4>\n<p>​\t向集合中添加内容。不允许重复。</p>\n<p>​\t语法：sadd key value value value</p>\n<p>​\t返回值：集合长度</p>\n<h4 id=\"52-scard\"><a class=\"anchor\" href=\"#52-scard\">#</a> 5.2 <strong>scard</strong></h4>\n<p>​\t返回集合元素数量</p>\n<p>​\t语法：scard key</p>\n<p>​\t返回值：集合长度</p>\n<h4 id=\"53-smembers\"><a class=\"anchor\" href=\"#53-smembers\">#</a> 5.3 **smembers **</h4>\n<p>​\t查看集合中元素内容</p>\n<p>​\t语法：smembers key</p>\n<p>​\t返回值：集合中元素</p>\n<h3 id=\"6-有序集合sorted-set\"><a class=\"anchor\" href=\"#6-有序集合sorted-set\">#</a> 6 .<strong> 有序集合（Sorted Set）</strong></h3>\n<p>​\t有序集合中每个 value 都有一个分数（score），根据分数进行排序。</p>\n<h4 id=\"61-zadd\"><a class=\"anchor\" href=\"#61-zadd\">#</a> 6.1 <strong>zadd</strong></h4>\n<p>​\t向有序集合中添加数据</p>\n<p>​\t语法：zadd key score value score value</p>\n<p>​\t返回值：长度</p>\n<p></p>\n<h4 id=\"62-zrange\"><a class=\"anchor\" href=\"#62-zrange\">#</a> 6.2 <strong>zrange</strong></h4>\n<p>​\t返回区间内容想・，withscores 表示带有分数</p>\n<p>​\t语法：zrange key 区间 [withscores]</p>\n<p>​\t返回值：值列表</p>\n<p></p>\n<p></p>\n<h2 id=\"五-redis持久化策略\"><a class=\"anchor\" href=\"#五-redis持久化策略\">#</a> 五、 <strong>Redis 持久化策略</strong></h2>\n<p>​\tRedis 不仅仅是一个内存型数据库，还具备持久化能力。</p>\n<h3 id=\"1-rdb\"><a class=\"anchor\" href=\"#1-rdb\">#</a> 1. <strong>RDB</strong></h3>\n<p>​\trdb 模式是默认模式，可以在指定的时间间隔内生成数据快照（snapshot），默认保存到 dump.rdb 文件中。当 redis 重启后会自动加载 dump.rdb 文件中内容到内存中。</p>\n<p>​\t用户可以使用 SAVE（同步）或 BGSAVE（异步）手动保存数据。</p>\n<p>​\t可以设置服务器配置的 save 选项，让服务器每隔一段时间自动执行一次 BGSAVE 命令，可以通过 save 选项设置多个保存条件，但只要其中任意一个条件被满足，服务器就会执行 BGSAVE 命令。</p>\n<p>例如：</p>\n<p>save 900 1</p>\n<p>save 300 10</p>\n<p>save 60 10000</p>\n<p>那么只要满足以下三个条件中的任意一个，BGSAVE 命令就会被执行</p>\n<p>服务器在 900 秒之内，对数据库进行了至少 1 次修改</p>\n<p>服务器在 300 秒之内，对数据库进行了至少 10 次修改</p>\n<p>服务器在 60 秒之内，对数据库进行了至少 10000 次修改</p>\n<h4 id=\"11-优点\"><a class=\"anchor\" href=\"#11-优点\">#</a> 1.1 <strong>优点</strong></h4>\n<p>​\trdb 文件是一个紧凑文件，直接使用 rdb 文件就可以还原数据。</p>\n<p>​\t数据保存会由一个子进程进行保存，不影响父进程。</p>\n<p>​\t恢复数据的效率要高于 aof</p>\n<h4 id=\"12-缺点\"><a class=\"anchor\" href=\"#12-缺点\">#</a> 1.2 <strong>缺点</strong></h4>\n<p>​\t每次保存点之间导致 redis 不可意料的关闭，可能会丢失数据。</p>\n<p>​\t由于每次保存数据都需要 fork () 子进程，在数据量比较大时可能会比较耗费性能。</p>\n<h3 id=\"2-aof\"><a class=\"anchor\" href=\"#2-aof\">#</a> 2 <strong>AOF</strong></h3>\n<p>​\tAOF 默认是关闭的，需要在配置文件中开启 AOF。Redis 支持 AOF 和 RDB 同时生效，如果同时存在，AOF 优先级高于 RDB（Redis 重新启动时会使用 AOF 进行数据恢复）</p>\n<p>​\t监听执行的命令，如果发现执行了修改数据的操作，同时直接同步到数据库文件中。</p>\n<h4 id=\"21-优点\"><a class=\"anchor\" href=\"#21-优点\">#</a> 2.1 <strong>优点</strong></h4>\n<p>​\t相对 RDB 数据更加安全。</p>\n<h4 id=\"22-缺点\"><a class=\"anchor\" href=\"#22-缺点\">#</a> 2.2 <strong>缺点</strong></h4>\n<p>​\t相同数据集 AOF 要大于 RDB。</p>\n<p>​\t相对 RDB 可能会慢一些。</p>\n<h4 id=\"23-开启办法\"><a class=\"anchor\" href=\"#23-开启办法\">#</a> 2.3 <strong>开启办法</strong></h4>\n<p>​\t修改 redis.conf 中</p>\n<pre><code>\n# 默认no\n\nappendonly yes\n\n# aof文件名\n\nappendfilename &quot;appendonly.aof&quot;\n\n</code></pre>\n<h2 id=\"六-redis主从复制\"><a class=\"anchor\" href=\"#六-redis主从复制\">#</a> 六. <strong>Redis 主从复制</strong></h2>\n<p>​\tRedis 支持集群功能。为了保证单一节点可用性，redis 支持主从复制功能。每个节点有 N 个复制品（replica），其中一个复制品是主（master），另外 N-1 个复制品是从（Slave），也就是说 Redis 支持一主多从。</p>\n<p>​\t一个主可有多个从，而一个从又可以看成主，它还可以有多个从。</p>\n<p><img data-src=\"/2022/10/07/DataBase/Redis/Redis/Redis-04.jpg\" class=\"\"></p>\n<h3 id=\"1-主从优点\"><a class=\"anchor\" href=\"#1-主从优点\">#</a> 1. <strong>主从优点</strong></h3>\n<p>​\t增加单一节点的健壮性，从而提升整个集群的稳定性。（Redis 中当超过 1/2 节点不可用时，整个集群不可用）</p>\n<p>​\t从节点可以对主节点数据备份，提升容灾能力。</p>\n<p>​\t读写分离。在 redis 主从中，主节点一般用作写（具备读的能力），从节点只能读，利用这个特性实现读写分离，写用主，读用从。</p>\n<h4 id=\"11-一主多从搭建\"><a class=\"anchor\" href=\"#11-一主多从搭建\">#</a> 1.1 <strong>一主多从搭建</strong></h4>\n<p>​\t在已经搭建的单机版 redis 基础上进行操作。</p>\n<p>​\t并且关闭 redis 单机版</p>\n<pre><code>\n./redis-cli shutdown\n\n</code></pre>\n<h4 id=\"12-新建目录\"><a class=\"anchor\" href=\"#12-新建目录\">#</a> 1.2 <strong>新建目录</strong></h4>\n<pre><code>\n# mkdir /usr/local/replica\n\n</code></pre>\n<h4 id=\"13-复制目录\"><a class=\"anchor\" href=\"#13-复制目录\">#</a> 1.3 <strong>复制目录</strong></h4>\n<p>​\t把之前安装的 redis 单机版中 bin 目录复制三份，分别叫做：master、slave1、slave2</p>\n<pre><code>\n# cp -r /usr/local/redis/bin /usr/local/replica/master\n\n# cp -r /usr/local/redis/bin /usr/local/replica/slave1\n\n# cp -r /usr/local/redis/bin /usr/local/replica/slave2\n\n</code></pre>\n<h4 id=\"14-修改从的配置文件\"><a class=\"anchor\" href=\"#14-修改从的配置文件\">#</a> 1.4 <strong>修改从的配置文件</strong></h4>\n<p>​\t修改 2 个从的 redis.conf，指定主节点 ip 和端口。并修改自身端口号防止和其他 redis 冲突。</p>\n<pre><code>\n# vim /usr/local/replica/slave1/redis.conf\n\n</code></pre>\n<p>​\t指定主节点 ip 和端口</p>\n<pre><code>\nreplicaof 192.168.93.10 6379\n\n</code></pre>\n<p>​\t修改自己端口</p>\n<pre><code>\nport 6380\n\n</code></pre>\n<pre><code>\n# vim /usr/local/replica/slave2/redis.conf\n\n</code></pre>\n<p>​\t指定主节点 ip 和端口</p>\n<pre><code>\nreplicaof 192.168.93.10 6379\n\n</code></pre>\n<p>​\t修改自己端口</p>\n<pre><code>\nport 6381\n\n</code></pre>\n<h4 id=\"15-启动三个redis实例\"><a class=\"anchor\" href=\"#15-启动三个redis实例\">#</a> 1.5 <strong>启动三个 redis 实例</strong></h4>\n<p>​\t注意：一定要关闭单机的 redis，否则端口冲突。</p>\n<pre><code>\n# cd /usr/local/replica\n\n# vim startup.sh\n\n</code></pre>\n<p>​\t在文件中添加下面内容</p>\n<pre><code>\ncd /usr/local/replica/master/\n\n./redis-server redis.conf\n\n  cd /usr/local/replica/slave1\n\n./redis-server redis.conf\n\n  cd /usr/local/replica/slave2\n\n./redis-server redis.conf\n\n</code></pre>\n<pre><code>赋予权限\n</code></pre>\n<pre><code>\n# chmod a+x startup.sh\n\n</code></pre>\n<p>​\t开启</p>\n<pre><code>\n# ./startup.sh\n\n</code></pre>\n<h4 id=\"16-查看启动状态\"><a class=\"anchor\" href=\"#16-查看启动状态\">#</a> 1.6 <strong>查看启动状态</strong></h4>\n<pre><code>\n# ps aux|grep redis\n\n</code></pre>\n<p><img data-src=\"/2022/10/07/DataBase/Redis/Redis/Redis-05.jpg\" class=\"\"></p>\n<h4 id=\"17-测试\"><a class=\"anchor\" href=\"#17-测试\">#</a> 1.7 <strong>测试</strong> *</h4>\n<pre><code>\n# cd /usr/local/replica/master/\n\n# ./redis-cli \n\n</code></pre>\n<p><img data-src=\"/2022/10/07/DataBase/Redis/Redis/Redis-06.jpg\" class=\"\"></p>\n<p>​\t在客户端命令行模式下，添加一条数据：</p>\n<p><img data-src=\"/2022/10/07/DataBase/Redis/Redis/Redis-07.jpg\" class=\"\"></p>\n<p>​\t进去 slave 查看数据是否同步。</p>\n<pre><code>\n# cd /usr/local/replica/slave1\n\n# ./redis-cli -p 6380\n\n</code></pre>\n<p><img data-src=\"/2022/10/07/DataBase/Redis/Redis/Redis-08.jpg\" class=\"\"></p>\n<h3 id=\"2-docker下操作\"><a class=\"anchor\" href=\"#2-docker下操作\">#</a> 2、docker 下操作</h3>\n<p>​\t可以自定义<strong> redis.conf</strong> 文件只写要修改的，不改的就别写，这里主要是要书写<strong>新的端口号</strong>以及<strong>父节点</strong>的<strong> ip 和端口</strong></p>\n<p>** 注意：** 所有修改必须在容器外，容器内修改无效，在退出重启的那一刻就已经还原了</p>\n<p>我们通常使用  CP 来修改</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">docker</span>  <span class=\"token function\">cp</span>  本机文件路径   容器id: 容器内文件路径</pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token comment\">#所有路径是所在文件夹路径，并不是文件的路径，简单来说就是写到文件夹所在路径即可，不需要指定特定文件</span></pre></td></tr></table></figure><h4 id=\"1-修改端口号\"><a class=\"anchor\" href=\"#1-修改端口号\">#</a> 1、修改端口号</h4>\n<p>同上</p>\n<h4 id=\"2-指定父节点\"><a class=\"anchor\" href=\"#2-指定父节点\">#</a> 2、指定父节点</h4>\n<p>同上</p>\n<h4 id=\"3-重启\"><a class=\"anchor\" href=\"#3-重启\">#</a> 3、重启</h4>\n<p><strong>（如果在启动前修改不需要，这里是指已经启动了的容器，在修改之后的操作）</strong></p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">docker</span> restart 容器id</pre></td></tr></table></figure><h4 id=\"4-测试并查看\"><a class=\"anchor\" href=\"#4-测试并查看\">#</a> 4、测试并查看</h4>\n<p>・同上</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>role</pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>或者</pre></td></tr><tr><td data-num=\"6\"></td><td><pre></pre></td></tr><tr><td data-num=\"7\"></td><td><pre></pre></td></tr><tr><td data-num=\"8\"></td><td><pre></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>info replication</pre></td></tr></table></figure><h2 id=\"七-哨兵sentinel\"><a class=\"anchor\" href=\"#七-哨兵sentinel\">#</a> 七.  <strong>哨兵（Sentinel）</strong></h2>\n<p>​\t在 redis 主从默认是只有主具备写的能力，而从只能读。如果主宕机，整个节点不具备写能力。但是如果这是让一个从变成主，整个节点就可以继续工作。即使之前的主恢复过来也当做这个节点的从即可。</p>\n<p>​\tRedis 的哨兵就是帮助监控整个节点的，当节点主宕机等情况下，帮助重新选取主。</p>\n<p>​\tRedis 中哨兵支持单哨兵和多哨兵。单哨兵是只要这个哨兵发现 master 宕机了，就直接选取另一个 master。而多哨兵是根据我们设定，达到一定数量哨兵认为 master 宕机后才会进行重新选取主。我们以多哨兵演示。</p>\n<h3 id=\"1-没有哨兵下主从效果\"><a class=\"anchor\" href=\"#1-没有哨兵下主从效果\">#</a> 1. <strong>没有哨兵下主从效果</strong></h3>\n<p>​\t只要杀掉主，整个节点无法在写数据，从身份不会变化，主的信息还是以前的信息。</p>\n<p><img data-src=\"/2022/10/07/DataBase/Redis/Redis/Redis-09.jpg\" class=\"\"></p>\n<h3 id=\"2搭建多哨兵\"><a class=\"anchor\" href=\"#2搭建多哨兵\">#</a> 2.<strong> 搭建多哨兵</strong></h3>\n<p>​\t前提：安装了单机的 redis</p>\n<h4 id=\"21-新建目录\"><a class=\"anchor\" href=\"#21-新建目录\">#</a> 2.1 <strong>新建目录</strong></h4>\n<pre><code>\n# mkdir /usr/local/sentinel\n\n</code></pre>\n<h4 id=\"22-复制redis\"><a class=\"anchor\" href=\"#22-复制redis\">#</a> 2.2 <strong>复制 redis</strong></h4>\n<pre><code>\n# cp -r /usr/local/redis/bin/* /usr/local/sentinel\n\n</code></pre>\n<h4 id=\"23-复制配置文件\"><a class=\"anchor\" href=\"#23-复制配置文件\">#</a> 2.3 <strong>复制配置文件</strong></h4>\n<p>​\t从 redis 解压目录中复制 sentinel 配置文件</p>\n<pre><code>\n# cd /usr/local/tmp/redis-5.0.5/\n\n# cp sentinel.conf /usr/local/sentinel/\n\n</code></pre>\n<h4 id=\"24-修改配置文件\"><a class=\"anchor\" href=\"#24-修改配置文件\">#</a> 2.4 <strong>修改配置文件</strong></h4>\n<pre><code>\n# cd /usr/local/sentinel\n\n# vim sentinel.conf\n\n\n\nport 26379\n\ndaemonize yes\n\n#这个提示里面的/var/log/redis/redis.log日志文件指的是容器中的文件，千万别理解为宿主机中的路径，如果你在宿主机创建此文件并授权，最后结果也是一样的，理解这一点很重要。\n\nlogfile “/usr/local/sentinel/26379.log”\n\n\n\nsentinel monitor mymaster 192.168.93.10 6379 2\n\n</code></pre>\n<p>​\t复制 sentinel.conf，命名为 sentinel-26380.conf</p>\n<pre><code>\n# cp sentinel.conf sentinel-26380.conf\n\n# vim sentinel-26380.conf\n\n\n\nport 26380\n\ndaemonize yes\n\nlogfile “/usr/local/sentinel/26380.log”\n\nsentinel monitor mymaster 192.168.93.10 6379 2\n\n</code></pre>\n<p>复制 sentinel.conf，命名为 sentinel-26381.conf</p>\n<pre><code>\n# cp sentinel.conf sentinel-26381.conf\n\n# vim sentinel-26381.conf\n\n\n\nport 26381\n\ndaemonize yes\n\nlogfile “/usr/local/sentinel/26381.log”\n\nsentinel monitor mymaster 192.168.93.10 6379 2\n\n</code></pre>\n<h4 id=\"25-启动主从\"><a class=\"anchor\" href=\"#25-启动主从\">#</a> 2.5 <strong>启动主从</strong></h4>\n<p>​\t如果已经启动状态，忽略下面命令。如果启动部分，全部 kill 后重新启动。</p>\n<p>​\t使用 kill 杀死全部 redis</p>\n<pre><code>\n# ps aux|grep redis\n\n# kill -9 进程号\n\n</code></pre>\n<p>​\t启动 redis 主从</p>\n<pre><code>\n# cd /usr/local/replica\n\n# ./startup.sh\n\n</code></pre>\n<h4 id=\"26-启动三个哨兵\"><a class=\"anchor\" href=\"#26-启动三个哨兵\">#</a> 2.6 <strong>启动三个哨兵</strong></h4>\n<pre><code>\n# cd /usr/local/sentinel\n\n# ./redis-sentinel sentinel.conf\n\n# ./redis-sentinel sentinel-26380.conf\n\n# ./redis-sentinel sentinel-26381.conf\n\n</code></pre>\n<h4 id=\"27-查看日志\"><a class=\"anchor\" href=\"#27-查看日志\">#</a> 2.7 <strong>查看日志</strong></h4>\n<pre><code>\n# cat 26379.log\n\n</code></pre>\n<h4 id=\"28-测试宕机\"><a class=\"anchor\" href=\"#28-测试宕机\">#</a> 2.8 <strong>测试宕机</strong></h4>\n<p>​\t查看 redis 进程号</p>\n<pre><code>\n# ps aux|grep redis\n\n</code></pre>\n<p>​\t杀死主进程号</p>\n<pre><code>\n# kill -9 进程号\n\n</code></pre>\n<p>​\t查看日志，短暂延迟后会发现，出现新的主。</p>\n<pre><code>\n# cat 26379.log\n\n</code></pre>\n<h2 id=\"八-集群cluster-nt-have-doc\"><a class=\"anchor\" href=\"#八-集群cluster-nt-have-doc\">#</a> 八。集群 (Cluster)--nt have doc</h2>\n<p>​\t前提：已经安装好 redis 单机版。</p>\n<p>​\t当集群中超过或等于 1/2 节点不可用时，整个集群不可用。为了搭建稳定集群，都采用奇数节点。</p>\n<h3 id=\"1-复制redis配置文件\"><a class=\"anchor\" href=\"#1-复制redis配置文件\">#</a> 1 .<strong> 复制 redis 配置文件</strong></h3>\n<p>​\t从 /usr/local/redis/bin 下把 redis.conf 复制到当前目录中，命名为 redis-7001.conf</p>\n<pre><code>\n# cp /usr/local/redis/bin/redis.conf /usr/local/redis/bin/redis-7001.conf\n\n</code></pre>\n<h3 id=\"2-修改redis-7001conf\"><a class=\"anchor\" href=\"#2-修改redis-7001conf\">#</a> 2. <strong>修改 redis-7001.conf</strong></h3>\n<pre><code>\n# cd /usr/local/redis/bin\n\n# vim redis-7001.conf\n\n</code></pre>\n<p>​\t需要修改如下</p>\n<pre><code>\nport 7001\n\ncluster-enabled yes\n\ncluster-config-file nodes-7001.conf\n\ncluster-node-timeout 15000\n\n# appendonly yes 如果开启aof默认，需要修改为yes。如果使用rdb，此处不需要修改\n\ndaemonize yes\n\nprotected-mode no\n\npidfile /var/run/redis_7001.pid\n\n</code></pre>\n<h3 id=\"3-复制配置文件并修改内容\"><a class=\"anchor\" href=\"#3-复制配置文件并修改内容\">#</a> 3 .<strong> 复制配置文件，并修改内容</strong></h3>\n<p>​\t把 redis-7001.conf 复制 5 份，分别叫做 redis-7002.conf、redis-7003.conf、redis-7004.conf、redis-7005.conf、redis-7006.conf</p>\n<pre><code>\n# cp redis-7001.conf redis-7002.conf\n\n# cp redis-7001.conf redis-7003.conf\n\n# cp redis-7001.conf redis-7004.conf\n\n# cp redis-7001.conf redis-7005.conf\n\n# cp redis-7001.conf redis-7006.conf\n\n</code></pre>\n<pre><code>新复制的5个配置文件都需要需改三处。\n</code></pre>\n<p>​\t例如 nodes-7002.conf 中需要把所有 7001 都换成 7002。</p>\n<p>​\t可以使用 :% s/7001/7002/g 进行全局修改。</p>\n<pre><code>\nport 7002\n\ncluster-config-file nodes-7002.conf\n\npidfile /var/run/redis_7002.pid\n\n</code></pre>\n<h3 id=\"4-启动6个redis\"><a class=\"anchor\" href=\"#4-启动6个redis\">#</a> 4 .<strong> 启动 6 个 redis</strong></h3>\n<p>​\t可以使用 redis-server 结合 6 个配置文件进行启动 6 个实例。</p>\n<p>​\t执行之前一定要先删除 dump.rdb</p>\n<pre><code>\n# rm -f dump.rdb\n\n# vim startup.sh\n\n\n\n./redis-server redis-7001.conf\n\n./redis-server redis-7002.conf\n\n./redis-server redis-7003.conf\n\n./redis-server redis-7004.conf\n\n./redis-server redis-7005.conf\n\n./redis-server redis-7006.conf\n\n\n\n\n\n# chmod a+x startup.sh\n\n# ./startup.sh\n\n</code></pre>\n<h3 id=\"5-查看启动状态\"><a class=\"anchor\" href=\"#5-查看启动状态\">#</a> 5. <strong>查看启动状态</strong></h3>\n<p><img data-src=\"/2022/10/07/DataBase/Redis/Redis/Redis-10.jpg\" class=\"\"></p>\n<h3 id=\"6-建立集群\"><a class=\"anchor\" href=\"#6-建立集群\">#</a> 6. <strong>建立集群</strong></h3>\n<p>​\t在 redis3 的时候需要借助 ruby 脚本实现集群。在 redis5 中可以使用自带的 redis-cli 实现集群功能，比 redis3 的时候更加方便了。</p>\n<p>​\t建议配置静态 ip，ip 改变集群失效</p>\n<pre><code>\n./redis-cli --cluster create 192.168.93.10:7001 192.168.93.10:7002 192.168.93.10:7003 192.168.93.10:7004 192.168.93.10:7005 192.168.93.10:7006 --cluster-replicas 1\n\n</code></pre>\n<h3 id=\"7-测试\"><a class=\"anchor\" href=\"#7-测试\">#</a> 7. <strong>测试</strong></h3>\n<p>​\t集群测试时，千万不要忘记最后一个 - c 参数。</p>\n<pre><code>\n# ./redis-cli -p 7001 -c\n\n# set age 18\n\n</code></pre>\n<h3 id=\"8-编写关闭脚本\"><a class=\"anchor\" href=\"#8-编写关闭脚本\">#</a> 8 .<strong> 编写关闭脚本</strong></h3>\n<pre><code>\n# vim stop.sh\n\n# chmod a+x stop.sh\n\n\n\n./redis-cli -p 7001 shutdown\n\n./redis-cli -p 7002 shutdown\n\n./redis-cli -p 7003 shutdown\n\n./redis-cli -p 7004 shutdown\n\n./redis-cli -p 7005 shutdown\n\n./redis-cli -p 7006 shutdown\n\n</code></pre>\n<h2 id=\"八-集群cluster-pathdocker\"><a class=\"anchor\" href=\"#八-集群cluster-pathdocker\">#</a> 八。集群 (Cluster)-PATH:docker</h2>\n<p>​\t<strong>注：<strong>1. 如果是配置修改之前</strong>已经创建过的集群时</strong>，要先进行第七步操作。</p>\n<p>​\t\t\t2. 要是想重启集群可以省略第一步，但是得<strong>先删除已经创建的容器</strong>，重新进行 2、3（合并也行）</p>\n<h3 id=\"0-创建网络\"><a class=\"anchor\" href=\"#0-创建网络\">#</a> 0、创建网络</h3>\n<p>** 目的：** 让宿主机可以访问到自身</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">docker</span> network create net-redis <span class=\"token parameter variable\">--subnet</span> <span class=\"token number\">172.38</span>.0.0/16</pre></td></tr></table></figure><p>补充：关于虚拟机的三种网路连接方式区别</p>\n<p><span class=\"exturl\" data-url=\"aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYmlmZW5nbWlhb3podWFuL2FydGljbGUvZGV0YWlscy83OTg4NzY5Mj9zcG09MTAwMS4yMTAxLjMwMDEuNjY2MS4xJmFtcDt1dG1fbWVkaXVtPWRpc3RyaWJ1dGUucGNfcmVsZXZhbnRfdDAubm9uZS10YXNrLWJsb2ctMg==\">http://blog.csdn.net/bifengmiaozhuan/article/details/79887692?spm=1001.2101.3001.6661.1&amp;utm_medium=distribute.pc_relevant_t0.none-task-blog-2</span><sub>default</sub>CTRLIST<sub>Rate-1.pc_relevant_default&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2</sub>default<sub>CTRLIST</sub>Rate-1.pc_relevant_default&amp;utm_relevant_index=1</p>\n<p></p>\n<h3 id=\"1-创建并修改配置文件\"><a class=\"anchor\" href=\"#1-创建并修改配置文件\">#</a> 1、创建并修改配置文件</h3>\n<p><strong>注：</strong></p>\n<pre><code>\nIn certain deployments, Redis Cluster nodes address discovery fails, because addresses are NAT-ted or because ports are forwarded (the typical case is Docker and other containers).\n\n\n\n在某些部署中，Redis群集节点地址发现失败，因为地址是NAT，或者端口是转发的（典型情况是Docker和其他容器）。\n\n\n\nIn order to make Redis Cluster working in such environments, a static configuration where each node knows its public address is needed. The following two options are used for this scope, and are:\n\n\n\n为了让Redis集群在这样的环境中工作，需要一种静态配置，其中每个节点都知道自己的公共地址。以下两个选项用于此范围，分别是：\n\n\n\ncluster-announce-ip\n\n\n\ncluster-announce-port\n\n---------------------------------------------------------------------------------------\n\n你的docker内网是172，你宿主的IP是192网段\n\n\n\n根据redis的配置文件中的解释\n\n\n\n要在你的配置文件上加上上面的2个配置\n\n</code></pre>\n<p>** 方法一：** 参考上面的方法一样行。</p>\n<p>** 方法二：** 使用脚本</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">#cat &lt;&lt;EOF EOF 在这里没有特殊的含义，你可以使用 FOE 或 000 等；</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token comment\">#表示以 cat &lt;&lt;EOF 开始输入以 EOF 结束结束输入</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token comment\">#cat > 创建文件，并把标准输入输出到后面的 filename 文件</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre></pre></td></tr><tr><td data-num=\"7\"></td><td><pre></pre></td></tr><tr><td data-num=\"8\"></td><td><pre></pre></td></tr><tr><td data-num=\"9\"></td><td><pre></pre></td></tr><tr><td data-num=\"10\"></td><td><pre></pre></td></tr><tr><td data-num=\"11\"></td><td><pre> * cluster-announce-ip\t\t\t\t\t<span class=\"token number\">192.168</span>.1.195\t<span class=\"token comment\">#* 群集 ip</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre></pre></td></tr><tr><td data-num=\"13\"></td><td><pre> * cluster-announce-port\t\t\t\t<span class=\"token number\">700</span><span class=\"token variable\">$&#123;port&#125;</span>\t\t<span class=\"token comment\">#* 群集总线端口</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre></pre></td></tr><tr><td data-num=\"15\"></td><td><pre> * cluster-announce-bus-port<span class=\"token comment\">#* 群集 ip    1700$&#123;port&#125;\t   #* 群集公布端口</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre></pre></td></tr><tr><td data-num=\"17\"></td><td><pre><span class=\"token comment\"># 集群 ip 是固定 + 10000</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre></pre></td></tr><tr><td data-num=\"19\"></td><td><pre></pre></td></tr><tr><td data-num=\"20\"></td><td><pre></pre></td></tr><tr><td data-num=\"21\"></td><td><pre><span class=\"token comment\"># 可以使用 :  % s/7001/7002/g     进行全局修改。 --- 将全局的 7001 修改成 7002</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre></pre></td></tr><tr><td data-num=\"23\"></td><td><pre></pre></td></tr><tr><td data-num=\"24\"></td><td><pre></pre></td></tr><tr><td data-num=\"25\"></td><td><pre><span class=\"token keyword\">for</span> <span class=\"token for-or-select variable\">port</span> <span class=\"token keyword\">in</span> <span class=\"token variable\"><span class=\"token variable\">$(</span><span class=\"token function\">seq</span> <span class=\"token number\">1</span> <span class=\"token number\">6</span><span class=\"token variable\">)</span></span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">\\</span> </pre></td></tr><tr><td data-num=\"26\"></td><td><pre></pre></td></tr><tr><td data-num=\"27\"></td><td><pre><span class=\"token keyword\">do</span> <span class=\"token punctuation\">\\</span></pre></td></tr><tr><td data-num=\"28\"></td><td><pre></pre></td></tr><tr><td data-num=\"29\"></td><td><pre><span class=\"token function\">mkdir</span>  <span class=\"token parameter variable\">-p</span>  /root/myredis/conf700<span class=\"token variable\">$&#123;port&#125;</span></pre></td></tr><tr><td data-num=\"30\"></td><td><pre></pre></td></tr><tr><td data-num=\"31\"></td><td><pre><span class=\"token function\">touch</span>  /root/myredis/conf700<span class=\"token variable\">$&#123;port&#125;</span>/redis.conf</pre></td></tr><tr><td data-num=\"32\"></td><td><pre></pre></td></tr><tr><td data-num=\"33\"></td><td><pre><span class=\"token function\">cat</span> <span class=\"token operator\">&lt;&lt;</span><span class=\"token string\">TTT<span class=\"token bash punctuation\"> <span class=\"token operator\">></span> /root/myredis/conf700<span class=\"token variable\">$&#123;port&#125;</span>/redis.conf port <span class=\"token number\">6379</span></span></pre></td></tr><tr><td data-num=\"34\"></td><td><pre></pre></td></tr><tr><td data-num=\"35\"></td><td><pre>bind 0.0.0.0</pre></td></tr><tr><td data-num=\"36\"></td><td><pre></pre></td></tr><tr><td data-num=\"37\"></td><td><pre>port 700<span class=\"token variable\">$&#123;port&#125;</span></pre></td></tr><tr><td data-num=\"38\"></td><td><pre></pre></td></tr><tr><td data-num=\"39\"></td><td><pre>cluster-enabled yes</pre></td></tr><tr><td data-num=\"40\"></td><td><pre></pre></td></tr><tr><td data-num=\"41\"></td><td><pre>cluster-config-file nodes-700<span class=\"token variable\">$&#123;port&#125;</span>.conf</pre></td></tr><tr><td data-num=\"42\"></td><td><pre></pre></td></tr><tr><td data-num=\"43\"></td><td><pre>cluster-node-timeout 15000</pre></td></tr><tr><td data-num=\"44\"></td><td><pre></pre></td></tr><tr><td data-num=\"45\"></td><td><pre>protected-mode no</pre></td></tr><tr><td data-num=\"46\"></td><td><pre></pre></td></tr><tr><td data-num=\"47\"></td><td><pre>pidfile /var/run/redis_ 700<span class=\"token variable\">$&#123;port&#125;</span>.pid</pre></td></tr><tr><td data-num=\"48\"></td><td><pre></pre></td></tr><tr><td data-num=\"49\"></td><td><pre>cluster-announce-ip  192.168.1.195 </pre></td></tr><tr><td data-num=\"50\"></td><td><pre></pre></td></tr><tr><td data-num=\"51\"></td><td><pre>cluster-announce-port  700$&#123;port) </pre></td></tr><tr><td data-num=\"52\"></td><td><pre></pre></td></tr><tr><td data-num=\"53\"></td><td><pre>cluster-announce-bus-port 1700$&#123;port) </pre></td></tr><tr><td data-num=\"54\"></td><td><pre></pre></td></tr><tr><td data-num=\"55\"></td><td><pre>appendonly yes </pre></td></tr><tr><td data-num=\"56\"></td><td><pre></pre></td></tr><tr><td data-num=\"57\"></td><td><pre>TTT</span> </pre></td></tr><tr><td data-num=\"58\"></td><td><pre></pre></td></tr><tr><td data-num=\"59\"></td><td><pre><span class=\"token keyword\">done</span></pre></td></tr></table></figure><h3 id=\"2-创建容器\"><a class=\"anchor\" href=\"#2-创建容器\">#</a> 2、创建容器</h3>\n<p>** 方法一：** 手动创建容器，并启动</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">docker</span> run <span class=\"token parameter variable\">-p</span> <span class=\"token number\">7001</span>:7001   <span class=\"token parameter variable\">-p</span> <span class=\"token number\">17001</span>:17001  <span class=\"token parameter variable\">--name</span> redis7001  <span class=\"token parameter variable\">-v</span> /root/myredis/conf7001/redis.conf:/etc/redis/redis.conf <span class=\"token parameter variable\">-v</span> /root/myredis/data7001:/data <span class=\"token parameter variable\">-d</span> redis redis-server /etc/redis/redis.conf <span class=\"token parameter variable\">--appendonly</span> <span class=\"token function\">yes</span></pre></td></tr></table></figure><p>​\t7002 ~~~7006 同上，自行修改参数</p>\n<p>** 方法二：** 脚本一键启动，效果同上</p>\n<p>​\t<strong>注意：</strong></p>\n<ul>\n<li>\n<p>其中要指定两个端口号 **-p 1700<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mrow><mi>p</mi><mi>o</mi><mi>r</mi><mi>t</mi></mrow><mo>:</mo><mn>1700</mn></mrow><annotation encoding=\"application/x-tex\">{port}:1700</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.80952em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">p</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"mord mathnormal\">t</span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\">7</span><span class=\"mord\">0</span><span class=\"mord\">0</span></span></span></span> {port}** 不要忘记，否则会在创建几群的时候出现  **Waiting for the cluster to join   ** 。【具体原因，我还没查出来，后面补充】</p>\n</li>\n<li>\n<p>在 docker 创建集群容器的时候，<strong>一定要</strong> 指定  ip</p>\n</li>\n</ul>\n<p><strong>补充：</strong></p>\n<ul>\n<li>那肯定是你端口没有开启，不要质疑，这里的端口不是 7000-7005，而是 17000-17005，因为 redis 设置集群的端口号是”redis 端口 + 10000“，这个非常重要。并且 7001:7006 也是必须打开的。</li>\n</ul>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">for</span> <span class=\"token for-or-select variable\">port</span> <span class=\"token keyword\">in</span> <span class=\"token variable\"><span class=\"token variable\">$(</span><span class=\"token function\">seq</span> <span class=\"token number\">1</span> <span class=\"token number\">6</span><span class=\"token variable\">)</span></span><span class=\"token punctuation\">;</span>  <span class=\"token punctuation\">\\</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">do</span> <span class=\"token punctuation\">\\</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token function\">docker</span> run <span class=\"token parameter variable\">-p</span> <span class=\"token number\">700</span><span class=\"token variable\">$&#123;port&#125;</span>:700<span class=\"token variable\">$&#123;port&#125;</span>   <span class=\"token parameter variable\">-p</span> <span class=\"token number\">1700</span><span class=\"token variable\">$&#123;port&#125;</span>:1700<span class=\"token variable\">$&#123;port&#125;</span>  <span class=\"token parameter variable\">--name</span> redis700<span class=\"token variable\">$&#123;port&#125;</span>  <span class=\"token punctuation\">\\</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token parameter variable\">-v</span> /root/redis/redis700<span class=\"token variable\">$&#123;port&#125;</span>.conf:/etc/redis/redis.conf <span class=\"token punctuation\">\\</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token parameter variable\">-v</span> /root/redis/data700<span class=\"token variable\">$&#123;port&#125;</span>:/data <span class=\"token punctuation\">\\</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token parameter variable\">-d</span> <span class=\"token parameter variable\">--ip</span> <span class=\"token number\">192.168</span>.1.195 redis redis-server /etc/redis/redis.conf </pre></td></tr><tr><td data-num=\"12\"></td><td><pre></pre></td></tr><tr><td data-num=\"13\"></td><td><pre><span class=\"token keyword\">done</span></pre></td></tr></table></figure><h3 id=\"3-进入容器\"><a class=\"anchor\" href=\"#3-进入容器\">#</a> 3、进入容器</h3>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">docker</span> <span class=\"token builtin class-name\">exec</span> <span class=\"token parameter variable\">-it</span> redis7001 /bin/bash</pre></td></tr></table></figure><h3 id=\"4-创建集群\"><a class=\"anchor\" href=\"#4-创建集群\">#</a> 4、创建集群</h3>\n<p>​\t** 注：** 有一步操作，要自行进行确认，一定要输入 <strong>yes</strong> 而不是 <strong>y</strong> 或者其他之类的，除了 yes 一律视为 <strong>no</strong> 。</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>redis-cli <span class=\"token parameter variable\">--cluster</span> create <span class=\"token number\">192.168</span>.1.195:7001 <span class=\"token number\">192.168</span>.1.195:7002 <span class=\"token number\">192.168</span>.1.195:7003 <span class=\"token number\">192.168</span>.1.195:7004 <span class=\"token number\">192.168</span>.1.195:7005 <span class=\"token number\">192.168</span>.1.195:7006 --cluster-replicas <span class=\"token number\">1</span></pre></td></tr></table></figure><h3 id=\"5-测试\"><a class=\"anchor\" href=\"#5-测试\">#</a> 5、测试</h3>\n<p>​\t集群测试时，千万不要忘记最后一个 - c 参数。</p>\n<pre><code class=\"language-shel\">\nredis-cli -p 7001 -c\n\n</code></pre>\n<h3 id=\"6-关闭集群\"><a class=\"anchor\" href=\"#6-关闭集群\">#</a> 6、关闭集群</h3>\n<p><strong>方法一：</strong></p>\n<p>​\t自行手动一个一个停止，并且删除容器</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">docker</span> stop redis7001 <span class=\"token comment\">#7002 ~~~7006</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token function\">docker</span> <span class=\"token function\">rm</span> <span class=\"token parameter variable\">-f</span> redis7001</pre></td></tr></table></figure><p><strong>方法二：</strong></p>\n<p>​\t脚本程序，一劳永逸</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">for</span> <span class=\"token for-or-select variable\">port</span> <span class=\"token keyword\">in</span> <span class=\"token variable\"><span class=\"token variable\">$(</span><span class=\"token function\">seq</span> <span class=\"token number\">1</span> <span class=\"token number\">6</span><span class=\"token variable\">)</span></span><span class=\"token punctuation\">;</span>  <span class=\"token punctuation\">\\</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">do</span> <span class=\"token punctuation\">\\</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token function\">docker</span> stop redis700<span class=\"token variable\">$&#123;port&#125;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token function\">docker</span> <span class=\"token function\">rm</span> <span class=\"token parameter variable\">-f</span> redis700<span class=\"token variable\">$&#123;port&#125;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token keyword\">done</span></pre></td></tr></table></figure><h3 id=\"7-清空集群文件\"><a class=\"anchor\" href=\"#7-清空集群文件\">#</a> 7、清空集群文件</h3>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">for</span> <span class=\"token for-or-select variable\">port</span> <span class=\"token keyword\">in</span> <span class=\"token variable\"><span class=\"token variable\">$(</span><span class=\"token function\">seq</span> <span class=\"token number\">1</span> <span class=\"token number\">6</span><span class=\"token variable\">)</span></span><span class=\"token punctuation\">;</span>  <span class=\"token punctuation\">\\</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">do</span> <span class=\"token punctuation\">\\</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token function\">rm</span>  <span class=\"token parameter variable\">-rf</span>  ./data700<span class=\"token variable\">$&#123;port&#125;</span>/* </pre></td></tr><tr><td data-num=\"6\"></td><td><pre></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token keyword\">done</span></pre></td></tr></table></figure><h2 id=\"九-jedis\"><a class=\"anchor\" href=\"#九-jedis\">#</a> 九. <strong>Jedis</strong></h2>\n<p>​\tRedis 给 Java 语言提供了客户端 API，称之为 Jedis。</p>\n<p>​\tJedis API 和 Redis 命令几乎是一样的。</p>\n<p>​\t例如：Redis 对 String 值新增时 set 命令，Jedis 中也是 set 方法。所以本课程中没有重点把所有方法进行演示，重要演示 Jedis 如何使用。</p>\n<p>​\tJedis API 特别简单，基本上都是创建对象调用方法即可。</p>\n<h3 id=\"1-单机版\"><a class=\"anchor\" href=\"#1-单机版\">#</a> 1. <strong>单机版</strong></h3>\n<pre><code>\npublic void testStandalone()&#123;\n\n    Jedis jedis = new Jedis(&quot;192.168.93.10&quot;,6379);\n\n    jedis.set(&quot;name&quot;,&quot;msb-standalone&quot;);\n\n    String value = jedis.get(&quot;name&quot;);\n\n    System.out.println(value);\n\n&#125;\n\n</code></pre>\n<h3 id=\"2-带有连接池\"><a class=\"anchor\" href=\"#2-带有连接池\">#</a> 2. <strong>带有连接池</strong></h3>\n<pre><code>\npublic void testPool()&#123;\n\n    JedisPoolConfig jedisPoolConfig = new JedisPoolConfig();\n\n    jedisPoolConfig.setMaxTotal(20);\n\n    jedisPoolConfig.setMaxIdle(5);\n\n    jedisPoolConfig.setMinIdle(3);\n\n    JedisPool jedisPool = new JedisPool(jedisPoolConfig,&quot;192.168.93.10&quot;,6379);\n\n    Jedis jedis = jedisPool.getResource();\n\n    jedis.set(&quot;name&quot;,&quot;msb-pool&quot;);\n\n    String value = jedis.get(&quot;name&quot;);\n\n    System.out.println(value);\n\n&#125;\n\n</code></pre>\n<h3 id=\"3-集群\"><a class=\"anchor\" href=\"#3-集群\">#</a> 3. <strong>集群</strong></h3>\n<pre><code>\npublic void testCluster()&#123;\n\n    Set&lt;HostAndPort&gt; set = new HashSet&lt;&gt;();\n\n    set.add(new HostAndPort(&quot;192.168.93.10&quot;,7001));\n\n    set.add(new HostAndPort(&quot;192.168.93.10&quot;,7002));\n\n    set.add(new HostAndPort(&quot;192.168.93.10&quot;,7003));\n\n    set.add(new HostAndPort(&quot;192.168.93.10&quot;,7004));\n\n    set.add(new HostAndPort(&quot;192.168.93.10&quot;,7005));\n\n    set.add(new HostAndPort(&quot;192.168.93.10&quot;,7006));\n\n    JedisCluster jedisCluster = new JedisCluster(set);\n\n    jedisCluster.set(&quot;name&quot;,&quot;bjmsb&quot;);\n\n    String value = jedisCluster.get(&quot;name&quot;);\n\n    System.out.println(value);\n\n&#125;\n\n</code></pre>\n<h2 id=\"十-使用springboot整合springdataredis操作redis\"><a class=\"anchor\" href=\"#十-使用springboot整合springdataredis操作redis\">#</a> 十. <strong>使用 SpringBoot 整合 SpringDataRedis 操作 redis</strong></h2>\n<p>​\tSpring Data 是 Spring 公司的顶级项目，里面包含了 N 多个二级子项目，这些子项目都是相对独立的项目。每个子项目是对不同 API 的封装。</p>\n<p>​\t所有 Spring Boot 整合 Spring Data xxxx 的启动器都叫做 spring-boot-starter-data-xxxx</p>\n<p>​\tSpring Data 好处很方便操作对象类型。</p>\n<p>​\t把 Redis 不同值得类型放到一个 opsForXXX 方法中。</p>\n<p>​\t\topsForValue : String 值</p>\n<p>​\t\topsForList : 列表 List</p>\n<p>​\t\topsForHash: 哈希表 Hash</p>\n<p>​\t\topsForZSet: 有序集合 Sorted Set</p>\n<p>​\t\topsForSet : 集合</p>\n<h3 id=\"1-添加依赖\"><a class=\"anchor\" href=\"#1-添加依赖\">#</a> 1. <strong>添加依赖</strong></h3>\n<pre><code>\n \t&lt;parent&gt;\n\n        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n\n        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;\n\n        &lt;version&gt;2.2.2.RELEASE&lt;/version&gt;\n\n    &lt;/parent&gt;\n\n\n\n    &lt;dependencies&gt;\n\n        &lt;dependency&gt;\n\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n\n            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;\n\n        &lt;/dependency&gt;\n\n        &lt;dependency&gt;\n\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n\n            &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;\n\n            &lt;version&gt;2.2.5.RELEASE&lt;/version&gt;\n\n        &lt;/dependency&gt;\n\n        &lt;dependency&gt;\n\n            &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;\n\n            &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;\n\n            &lt;version&gt;2.1.1&lt;/version&gt;\n\n        &lt;/dependency&gt;\n\n        &lt;dependency&gt;\n\n            &lt;groupId&gt;mysql&lt;/groupId&gt;\n\n            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;\n\n            &lt;version&gt;5.1.47&lt;/version&gt;\n\n        &lt;/dependency&gt;\n\n        &lt;dependency&gt;\n\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n\n            &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;\n\n            &lt;version&gt;2.2.2.RELEASE&lt;/version&gt;\n\n        &lt;/dependency&gt;\n\n        &lt;dependency&gt;\n\n            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;\n\n            &lt;artifactId&gt;lombok&lt;/artifactId&gt;\n\n            &lt;version&gt;1.18.20&lt;/version&gt;\n\n        &lt;/dependency&gt;\n\n        &lt;dependency&gt;\n\n            &lt;groupId&gt;redis.clients&lt;/groupId&gt;\n\n            &lt;artifactId&gt;jedis&lt;/artifactId&gt;\n\n            &lt;version&gt;3.3.0&lt;/version&gt;\n\n        &lt;/dependency&gt;\n\n    &lt;/dependencies&gt;\n\n</code></pre>\n<h3 id=\"2-配置配置文件\"><a class=\"anchor\" href=\"#2-配置配置文件\">#</a> 2. <strong>配置配置文件</strong></h3>\n<p><strong>注：</strong></p>\n<ul>\n<li>\n<p>spring.redis.host=localhost 默认值</p>\n</li>\n<li>\n<p>spring.redis.port=6379 端口号默认值</p>\n</li>\n</ul>\n<pre><code>\nmybatis:\n\n  mapper-locations: classpath:mybatis/*\n\n  type-aliases-package: com.msb.pojo\n\nspring:\n\n  datasource:\n\n    url: jdbc:mysql://localhost:3306/mydb\n\n    username: root\n\n    password: root\n\n    driver-class-name: com.mysql.jdbc.Driver\n\n  redis:\n\n    host: 192.168.1.195\n\n    cluster:\n\n      nodes: 192.168.1.195:7001,192.168.1.195:7002,192.168.1.195:7003,192.168.1.195:7004,192.168.1.195:7005,192.168.1.195:7006\n\n</code></pre>\n<h3 id=\"3编写配置类可直接复制\"><a class=\"anchor\" href=\"#3编写配置类可直接复制\">#</a> 3.<strong> 编写配置类</strong>（可直接复制）</h3>\n<pre><code>\n@Configuration\n\npublic class RedisConfig &#123;\n\n    @Bean\n\n    public RedisTemplate&lt;String,Object&gt; redisTemplate(RedisConnectionFactory \t\t  factory)&#123;\n\n        RedisTemplate&lt;String,Object&gt; redisTemplate = new RedisTemplate&lt;&gt;();\n\n        redisTemplate.setConnectionFactory(factory);\n\n        redisTemplate.setKeySerializer(new StringRedisSerializer());\n\n        redisTemplate.setValueSerializer(new Jackson2JsonRedisSerializer&lt;Object&gt;(Object.class));\n\n        return redisTemplate;\n\n    &#125;\n\n&#125;\n\n</code></pre>\n<h3 id=\"4-编写代码\"><a class=\"anchor\" href=\"#4-编写代码\">#</a> 4. <strong>编写代码</strong></h3>\n<h4 id=\"41-编写对象新增\"><a class=\"anchor\" href=\"#41-编写对象新增\">#</a> 4.1 <strong>编写对象新增</strong></h4>\n<pre><code>\n@Autowired\n\nprivate RedisTemplate&lt;String, Object&gt; redisTemplate;\n\n\n\n@Test\n\npublic void testString() &#123;\n\n    People peo = new People(1, &quot;张三&quot;);\n\n    redisTemplate.opsForValue().set(&quot;peo1&quot;, peo);\n\n&#125;\n\n</code></pre>\n<h4 id=\"42-编写对象获取\"><a class=\"anchor\" href=\"#42-编写对象获取\">#</a> 4.2 <strong>编写对象获取</strong></h4>\n<p>此处必须编写值序列化器。不指定时返回类型为 LinkedHashMap</p>\n<pre><code>\n@Test\n\npublic void testGetString() &#123;\n\n    redisTemplate.setValueSerializer(new Jackson2JsonRedisSerializer&lt;People&gt;(People.class));\n\n    People peo = (People) redisTemplate.opsForValue().get(&quot;peo1&quot;);\n\n    System.out.println(peo);\n\n&#125;\n\n</code></pre>\n<h4 id=\"43-编写list\"><a class=\"anchor\" href=\"#43-编写list\">#</a> 4.3 <strong>编写 List</strong></h4>\n<pre><code>\n@Test\n\npublic void testList() &#123;\n\n    List&lt;People&gt; list = new ArrayList&lt;&gt;();\n\n    list.add(new People(1, &quot;张三&quot;));\n\n    list.add(new People(2, &quot;李四&quot;));\n\n    redisTemplate.opsForValue().set(&quot;list2&quot;, list);\n\n&#125;\n\n</code></pre>\n<h4 id=\"44-编写list取值\"><a class=\"anchor\" href=\"#44-编写list取值\">#</a> 4.4 <strong>编写 List 取值</strong></h4>\n<pre><code>\n@Test\n\npublic void testGetList()&#123;\n\n    redisTemplate.setValueSerializer(new Jackson2JsonRedisSerializer&lt;List&gt;(List.class));\n\n    List&lt;People&gt; list2 = (List&lt;People&gt;) redisTemplate.opsForValue().get(&quot;list2&quot;);\n\n    System.out.println(list2);\n\n&#125;\n\n</code></pre>\n<h2 id=\"十一-使用redis效果\"><a class=\"anchor\" href=\"#十一-使用redis效果\">#</a> 十一. <strong>使用 Redis 效果</strong></h2>\n<p>​\t使用缓存流程</p>\n<p>​\t1. 先判断缓存中是否存在。如果存在直接从缓存中取出数据。不执行 2，3 步骤</p>\n<p>​\t2. 如果不存在，从 mysql 中获取数据</p>\n<p>​\t3. 获取数据后，把数据缓存到 redis 中</p>\n<p><img data-src=\"/2022/10/07/DataBase/Redis/Redis/Redis-11.jpg\" class=\"\"></p>\n\n<div id=\"gitalk-container\"></div>\n<script src=\"https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js\"></script><link rel=\"stylesheet\" href=\"https://unpkg.com/gitalk/dist/gitalk.css\"><script src=\"https://unpkg.com/gitalk/dist/gitalk.min.js\"></script>\n\n\t\t<script>\n\t\tvar gitalkConfig = {\"clientID\":\"eda74f740080fa01d0b5\",\"clientSecret\":\"c994dd2162a1dadaefbf078fcab49361438a7aca\",\"repo\":\"comments001\",\"owner\":\"onlymarryu\",\"admin\":[\"onlymarryu\"],\"distractionFreeMode\":true,\"proxy\":\"https://winter-rain-5b30.wudu-bk.workers.dev/https://github.com/login/oauth/access_token\"};\n\t    gitalkConfig.id = md5(location.pathname);\n\t\tvar gitalk = new Gitalk(gitalkConfig);\n\t    gitalk.render(\"gitalk-container\");\n\t    </script>",
            "tags": [
                "分布式",
                "中间件",
                "Redis基础",
                "NoSQL数据库"
            ]
        }
    ]
}