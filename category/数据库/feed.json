{
    "version": "https://jsonfeed.org/version/1",
    "title": "记录“美食”每刻 • All posts by \"数据库\" category",
    "description": "记录“美食”每刻",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/2022/10/14/MySQL_Create/",
            "url": "http://example.com/2022/10/14/MySQL_Create/",
            "title": "MySQL基础",
            "date_published": "2022-10-14T09:50:50.743Z",
            "content_html": "<h1 id=\"MySQL安装\"><a href=\"#MySQL安装\" class=\"headerlink\" title=\"MySQL安装\"></a>MySQL安装</h1><h2 id=\"1、卸载原来的版本\"><a href=\"#1、卸载原来的版本\" class=\"headerlink\" title=\"1、卸载原来的版本\"></a>1、卸载原来的版本</h2><h3 id=\"1、查看mysql的安装情况\"><a href=\"#1、查看mysql的安装情况\" class=\"headerlink\" title=\"1、查看mysql的安装情况\"></a>1、查看mysql的安装情况</h3><pre><code class=\"sh\">rpm -qa | grep -i mysql\n</code></pre>\n<img data-src=\"/2022/10/14/MySQL_Create/1570605325400.png\" class=\"\" width=\"1570605325400\">\n\n<h3 id=\"2、删除上图安装的软件\"><a href=\"#2、删除上图安装的软件\" class=\"headerlink\" title=\"2、删除上图安装的软件\"></a>2、删除上图安装的软件</h3><pre><code class=\"sh\">rpm -ev --nodeps mysql57-community-release-el5-7.noarch\nrpm -ev --nodeps mysql-community-server-5.7.18-1.el5.x86_64\nrpm -ev --nodeps mysql-community-client-5.7.18-1.el5.x86_64\nrpm -ev --nodeps mysql-community-libs-5.7.18-1.el5.x86_64\nrpm -ev --nodeps mysql-community-common-5.7.18-1.el5.x86_64\nrpm -ev --nodeps mysql-5.7.18-1.el5.x86_64\nrpm -ev --nodeps mysql-community-libs-compat-5.7.18-1.el5.x86_64\n</code></pre>\n<h3 id=\"3、都删除成功之后，查找相关的mysql的文件\"><a href=\"#3、都删除成功之后，查找相关的mysql的文件\" class=\"headerlink\" title=\"3、都删除成功之后，查找相关的mysql的文件\"></a>3、都删除成功之后，查找相关的mysql的文件</h3><pre><code class=\"sh\">find / -name mysql\n</code></pre>\n<img data-src=\"/2022/10/14/MySQL_Create/1570605553095.png\" class=\"\" width=\"1570605553095\">\n\n<h3 id=\"4、删除全部文件\"><a href=\"#4、删除全部文件\" class=\"headerlink\" title=\"4、删除全部文件\"></a>4、删除全部文件</h3><pre><code class=\"sh\">rm -rf /etc/selinux/targeted/active/modules/100/mysql\nrm -rf /root/mysql\nrm -rf /root/mysql/data/mysql\nrm -rf /var/lib/mysql\nrm -rf /var/lib/mysql/mysql\nrm -rf /usr/share/mysql\n</code></pre>\n<h3 id=\"5、再次执行命令\"><a href=\"#5、再次执行命令\" class=\"headerlink\" title=\"5、再次执行命令\"></a>5、再次执行命令</h3><pre><code class=\"shell\">rpm -qa | grep -i mysql\n#如果没有显式则表示卸载完成\n</code></pre>\n<h2 id=\"2、删除mariadb-libs-不可省略\"><a href=\"#2、删除mariadb-libs-不可省略\" class=\"headerlink\" title=\"2、删除mariadb-libs(不可省略)\"></a>2、删除mariadb-libs(不可省略)</h2><pre><code class=\"sh\"># 检查mariadb-libs\nrpm -qa|grep mariadb\n# 卸载mariadb-libs\nyum remove -y mariadb-libs\n</code></pre>\n<h2 id=\"3、安装MySQL\"><a href=\"#3、安装MySQL\" class=\"headerlink\" title=\"3、安装MySQL\"></a>3、安装MySQL</h2><h3 id=\"1，输入\"><a href=\"#1，输入\" class=\"headerlink\" title=\"1，输入\"></a>1，输入</h3><p>wegt <span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXYubXlzcWwuY29tL2dldC9teXNxbCVFNyU4OSU4OCVFNiU5QyVBQyVFNSU4RiVCNy1jb21tdW5pdHktcmVsZWFzZS1lbCVFNSVBNCVBNyVFNyU4OSU4OCVFNiU5QyVBQy0lRTUlQjAlOEYlRTclODklODglRTYlOUMlQUMubm9hcmNoLnJwbQ==\">https://dev.mysql.com/get/mysql版本号-community-release-el大版本-小版本.noarch.rpm</span></p>\n<pre><code class=\"sh\">wget https://dev.mysql.com/get/mysql57-community-release-el5-7.noarch.rpm\n</code></pre>\n<h3 id=\"2、安装数据源\"><a href=\"#2、安装数据源\" class=\"headerlink\" title=\"2、安装数据源\"></a>2、安装数据源</h3><pre><code class=\"sh\">yum install -y mysql57-community-release-el5-7.noarch.rpm\n</code></pre>\n<h3 id=\"3、查看mysql源是否安装成功\"><a href=\"#3、查看mysql源是否安装成功\" class=\"headerlink\" title=\"3、查看mysql源是否安装成功\"></a>3、查看mysql源是否安装成功</h3><pre><code class=\"sh\">yum repolist enabled | grep &quot;mysql.*-community.*&quot;\n</code></pre>\n<h3 id=\"4、安装数据库\"><a href=\"#4、安装数据库\" class=\"headerlink\" title=\"4、安装数据库\"></a>4、安装数据库</h3><pre><code class=\"sh\">yum install -y  mysql-community-server\n\n\n\n# 如果过期可以在运行安装程序之前导入密钥\nrpm --import https://repo.mysql.com/RPM-GPG-KEY-mysql-2022\n</code></pre>\n<h3 id=\"5、启动mysql\"><a href=\"#5、启动mysql\" class=\"headerlink\" title=\"5、启动mysql\"></a>5、启动mysql</h3><pre><code class=\"sh\"># centos7\nsystemctl restart mysqld\nsystemctl status mysqld\n\n\n# centos6\nservice mysqld start\nservice mysqld status\n</code></pre>\n<h3 id=\"6、显示mysql的随机密码\"><a href=\"#6、显示mysql的随机密码\" class=\"headerlink\" title=\"6、显示mysql的随机密码\"></a>6、显示mysql的随机密码</h3><pre><code class=\"sh\">grep &#39;temporary password&#39; /var/log/mysqld.log\n</code></pre>\n<img data-src=\"/2022/10/14/MySQL_Create/image-20220827193405451.png\" class=\"\" title=\"image-20220827193405451\">\n\n<h3 id=\"7、登录并修改mysql密码\"><a href=\"#7、登录并修改mysql密码\" class=\"headerlink\" title=\"7、登录并修改mysql密码\"></a>7、登录并修改mysql密码</h3><p>登录：mysql -u root -p     然后输入上面生成的密码</p>\n<p><strong><em>修改自定义密码，设置自己想要的密码</em></strong></p>\n<pre><code class=\"sql\">-- ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;密码&#39;;\n\nALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;root&#39;;\n</code></pre>\n<p><strong><em>失败了的话就修改策略，将策略降低一下就可以了</em></strong></p>\n<p>查看密码策略：</p>\n<pre><code class=\"sql\">SHOW VARIABLES LIKE &#39;%validate_password%&#39;;\n</code></pre>\n<p>修改密码策略</p>\n<pre><code class=\"sql\">-- 修改密码长度：（长度）\nset global validate_password.length=1;\nset global validate_password_length=1;\n-- 修改密码等级：（等级）\nset global validate_password.policy=0;\nset global validate_password_policy=0;\n</code></pre>\n<h2 id=\"4、其他配置\"><a href=\"#4、其他配置\" class=\"headerlink\" title=\"4、其他配置\"></a>4、其他配置</h2><h3 id=\"1-开机自启\"><a href=\"#1-开机自启\" class=\"headerlink\" title=\"1.开机自启\"></a>1.开机自启</h3><pre><code class=\"sh\"># 开机启动\nsystemctl enable mysql\n# 关闭自动启动\nsystemctl disable mysqld\n</code></pre>\n<h3 id=\"2-远程连接\"><a href=\"#2-远程连接\" class=\"headerlink\" title=\"2.远程连接\"></a>2.远程连接</h3><h4 id=\"方法一、创建一个用户-支持远程连接\"><a href=\"#方法一、创建一个用户-支持远程连接\" class=\"headerlink\" title=\"方法一、创建一个用户 支持远程连接\"></a>方法一、创建一个用户 支持远程连接</h4><p>①登录 ：mysql -u root -p</p>\n<p>②创建用户： create user ‘aaa‘@’%’ identified by ‘123456’;</p>\n<p>③授权所有权限给user这个新用户 ：grant all on <em>.</em> to ‘aaa‘@’%’;</p>\n<p>④退出mysql：quit;</p>\n<h4 id=\"方法二、设置root用户支持远程连接\"><a href=\"#方法二、设置root用户支持远程连接\" class=\"headerlink\" title=\"方法二、设置root用户支持远程连接\"></a>方法二、设置root用户支持远程连接</h4><p>①登录：mysql -u root -p （ 注：系统提示输入数据库root用户的密码，输入完成后即进入mysql控制台，这个命令的第一个mysql是执行命令，第二个mysql是系统数据名称，不一样的。）</p>\n<p>②设置权限：</p>\n<p>赋予权限格式： grant 权限 on 数据库对象 to 用户@IP(或者相应正则)</p>\n<pre><code class=\"sql\">-- 新建用户规则或者直接修改root用户的规则 ，2 选一\nuse mysql;\n\n-- 这里表示赋予该用户所有数据库所有表（*.*表示所有表），%表示所有IP地址。\nGRANT ALL PRIVILEGES ON *.* TO &#39;root&#39;@&#39;%&#39; IDENTIFIED BY &#39;123456&#39; WITH GRANT OPTION;\n-- 使root能再任何host访问\nupdate user set host = &#39;%&#39; where user = &#39;root&#39;;      \n\n-- 刷新\nFLUSH PRIVILEGES;\n</code></pre>\n<p>③查看：</p>\n<pre><code class=\"sql\">use mysql;\nSELECT HOST,USER FROM USER;\n</code></pre>\n<img data-src=\"/2022/10/14/MySQL_Create/920952e9041b4af1a8a49eb64e0f4430.jpeg\" class=\"\" title=\"img\">\n\n<p> ④退出mysql：quit;</p>\n<h2 id=\"其他安装方式\"><a href=\"#其他安装方式\" class=\"headerlink\" title=\"其他安装方式\"></a>其他安装方式</h2><h3 id=\"docker\"><a href=\"#docker\" class=\"headerlink\" title=\"docker\"></a>docker</h3><h4 id=\"1、查询镜像\"><a href=\"#1、查询镜像\" class=\"headerlink\" title=\"1、查询镜像\"></a>1、查询镜像</h4><pre><code class=\"shell\">docker search mysql\n</code></pre>\n<h4 id=\"2、拉取镜像\"><a href=\"#2、拉取镜像\" class=\"headerlink\" title=\"2、拉取镜像\"></a>2、拉取镜像</h4><pre><code class=\"shell\">docker pull mysql:5.7\n</code></pre>\n<h4 id=\"3、构建容器\"><a href=\"#3、构建容器\" class=\"headerlink\" title=\"3、构建容器\"></a>3、构建容器</h4><p>先自己创建配置文件基础模板（<strong>要是后期要修改配置文件必须加入 模板中的两个元素，不然容器启动会出错</strong>）</p>\n<pre><code class=\"shell\">mkdir -p /root/mysql/conf\nvim  /root/mysql/conf/my.cnf\n</code></pre>\n<p><strong>模板内容：</strong></p>\n<pre><code class=\"shell\">!includedir /etc/mysql/conf.d/\n!includedir /etc/mysql/mysql.conf.d/\n\n[mysql]\ndefault-character-set=utf8mb4\n[mysqld]\ncharacter_set_server=utf8mb4\ninit_connect=&#39;SET NAMES utf8&#39;\nlower_case_table_names = 1\n</code></pre>\n<p><strong>构建容器</strong></p>\n<pre><code class=\"shell\">docker run \\\n-p 3306:3306 \\\n-v /root/mysql/data:/var/lib/mysql \\\n-v /root/mysql/logs:/logs \\\n-v /root/mysql/conf/my.cnf:/etc/mysql/my.cnf \\\n-e MYSQL_ROOT_PASSWORD=root \\\n--name mysql \\\n--hostname node1 \\\n--restart=always \\\n-d mysql:5.7\n</code></pre>\n<p><strong>注</strong>：出错时将本地映射文件检查一下，要是不需要配置，只需映射直接删掉就可，以后再改配置文件</p>\n<h4 id=\"4、进入容器\"><a href=\"#4、进入容器\" class=\"headerlink\" title=\"4、进入容器\"></a>4、进入容器</h4><pre><code class=\"shell\">docker exec -it mysql /bin/bash\n或者\ndocker exec -it mysql mysql -uroot -p\n</code></pre>\n<h3 id=\"docker-compose\"><a href=\"#docker-compose\" class=\"headerlink\" title=\"docker-compose\"></a>docker-compose</h3><blockquote>\n<p>前提安装了 docker-compose</p>\n</blockquote>\n<h4 id=\"配置-docker-comose-yml-文件\"><a href=\"#配置-docker-comose-yml-文件\" class=\"headerlink\" title=\"配置  docker-comose.yml 文件\"></a>配置  docker-comose.yml 文件</h4><p>5.7：</p>\n<pre><code class=\"yml\">version: &quot;3.0&quot;\nservices:\n  mysql8:\n    image: mysql:5.7.32\n    container_name: my_db57\n    restart: always\n    volumes:\n      - ./db:/var/lib/mysql\n      - ./conf/my.cnf:/etc/my.cnf\n      # 数据库初始化脚本，当Mysql容器首次启动时，会在 /docker-entrypoint-initdb.d目录下扫描 .sh，.sql，.sql.gz类型的文件。如果这些类型的文件存在，将执行它们来初始化一个数据库；\n      - ./init/:/docker-entrypoint-initdb.d/\n    environment:\n      - MYSQL_ROOT_PASSWORD=123456\n      # 指定初始化sql文件的数据库，简单来书就是新建一个数据库\n      - MYSQL_DATABASE=my_db\n      - TZ=Asia/Shanghai\n    ports:\n      - 3311:3306\n</code></pre>\n<p>8.0</p>\n<pre><code class=\"yml\">version: &quot;3.0&quot;\nservices:\n  mysql8:\n    image: mysql:8.0.25\n    container_name: my_db8\n    restart: always\n    volumes:\n      - ./db:/var/lib/mysql\n      - ./conf/my.cnf:/etc/my.cnf\n      # 数据库初始化脚本，当Mysql容器首次启动时，会在 /docker-entrypoint-initdb.d目录下扫描 .sh，.sql，.sql.gz类型的文件。如果这些类型的文件存在，将执行它们来初始化一个数据库；\n      - ./init/:/docker-entrypoint-initdb.d/\n    environment:\n      - MYSQL_ROOT_PASSWORD=123456\n      # 指定初始化sql文件的数据库，简单来书就是新建一个数据库\n      - MYSQL_DATABASE=my_db\n      - TZ=Asia/Shanghai\n    ports:\n      - 3301:3306\n</code></pre>\n<h4 id=\"配置文件-my-cnf\"><a href=\"#配置文件-my-cnf\" class=\"headerlink\" title=\"配置文件 my.cnf\"></a>配置文件 my.cnf</h4><p>5.7：</p>\n<pre><code class=\"shell\">[mysql]\n# 设置mysql客户端默认字符集\ndefault-character-set=utf8mb4\n\n[mysqld]\ndatadir=/var/lib/mysql\nsocket=/var/lib/mysql/mysql.sock\n\nsymbolic-links=0\n\nlog-error=/var/log/mysqld.log\npid-file=/var/run/mysqld/mysqld.pid\n# 服务端使用的字符集默认为8比特编码的latin1字符集\ncharacter-set-server=utf8mb4\n\n# 创建新表时将使用的默认存储引擎\ndefault-storage-engine=INNODB\n</code></pre>\n<p>8.0：</p>\n<pre><code class=\"shell\">[mysql]\n# 设置mysql客户端默认字符集\ndefault-character-set=utf8mb4\n[mysqld]\n# 允许最大连接数\nmax_connections=200\n\n# 服务端使用的字符集默认为8比特编码的latin1字符集\ncharacter-set-server=utf8mb4\n\n# 创建新表时将使用的默认存储引擎\ndefault-storage-engine=INNODB\n</code></pre>\n<h4 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h4><p>1、Can’t create&#x2F;write to file ‘&#x2F;var&#x2F;run&#x2F;mysqld&#x2F;mysqld.pid</p>\n<p>去配置文件中找到 errorlog的地址，查看错误日志</p>\n<img data-src=\"/2022/10/14/MySQL_Create/20190602012200812.png\" class=\"\" title=\"img\">\n\n<p>错误原因为：&#x2F;var&#x2F;run&#x2F;mysqld&#x2F;目录的拥有者为root，mysql不能在其中创建文件</p>\n<p>使用如下命令修改目录使用者</p>\n<pre><code class=\"shell\"># 先查看目录是否存在\nls -ld /var/run/mysqld/\n# 权限\nchown mysql.mysql /var/run/mysqld/\n# 修改后重启mysql服务\n/etc/init.d/mysqld start\n</code></pre>\n",
            "tags": [
                "MySQL",
                "数据库基础",
                "数据库基本知识"
            ]
        },
        {
            "id": "http://example.com/2022/10/07/MySQL_Super/",
            "url": "http://example.com/2022/10/07/MySQL_Super/",
            "title": "MySQL高级部分",
            "date_published": "2022-10-06T16:00:00.000Z",
            "content_html": "<h1 id=\"MySQL性能调优\"><a href=\"#MySQL性能调优\" class=\"headerlink\" title=\"MySQL性能调优\"></a>MySQL性能调优</h1><blockquote>\n<p>环境：CentOS7.5\t\t\t\t\t Version：MySQL57.39</p>\n</blockquote>\n<h1 id=\"主要内容\"><a href=\"#主要内容\" class=\"headerlink\" title=\"主要内容\"></a>主要内容</h1><p><a href=\"#MySQL%E7%9A%84%E6%9E%B6%E6%9E%84%E4%BB%8B%E7%BB%8D\">1、MySQL的架构介绍</a></p>\n<p><a href=\"#%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%E5%88%86%E6%9E%90\">2、索引优化分析</a></p>\n<p><a href=\"#%E6%9F%A5%E8%AF%A2%E6%88%AA%E5%8F%96%E5%88%86%E6%9E%90\">3、查询截取分析</a></p>\n<p><a href=\"#MySQL%E7%9A%84%E9%94%81%E6%9C%BA%E5%88%B6\">4、MySQL的锁机制</a></p>\n<div name=MySQL的架构介绍 >\n\n\n<h1 id=\"MySQL文件目录结构\"><a href=\"#MySQL文件目录结构\" class=\"headerlink\" title=\"MySQL文件目录结构\"></a>MySQL文件目录结构</h1><table>\n<thead>\n<tr>\n<th align=\"left\">路径</th>\n<th align=\"left\">解释</th>\n<th align=\"left\">备注</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">&#x2F;var&#x2F;lib&#x2F;mysql&#x2F;</td>\n<td align=\"left\">mysql数据库文件的存放路径</td>\n<td align=\"left\">&#x2F;var&#x2F;lib&#x2F;mysql&#x2F;atguidgu.cloud.pid</td>\n</tr>\n<tr>\n<td align=\"left\">&#x2F;usr&#x2F;share&#x2F;mysql</td>\n<td align=\"left\">配置文件目录</td>\n<td align=\"left\">mysql.server命令及配置及文件</td>\n</tr>\n<tr>\n<td align=\"left\">&#x2F;usr&#x2F;bin&#x2F;</td>\n<td align=\"left\">相关命令目录</td>\n<td align=\"left\">mysqladmin 、mysqldump等相关命令</td>\n</tr>\n<tr>\n<td align=\"left\">&#x2F;ect&#x2F;init.d&#x2F;mysql</td>\n<td align=\"left\">启停相关脚本</td>\n<td align=\"left\"></td>\n</tr>\n</tbody></table>\n<h1 id=\"主要配置文件\"><a href=\"#主要配置文件\" class=\"headerlink\" title=\"主要配置文件\"></a>主要配置文件</h1><p>1、二进制日志 log-bin ：主从复制</p>\n<p>2、错误日志 log-error ：默认是关闭的，记录严重的警告和错误信息，每次启动和关闭的详细信息等</p>\n<p>3、查询日志 log ：默认关闭，记录查询的SQL语句，如果开启就会降低mysql的整体性能</p>\n<p>4、数据文件 : </p>\n<ul>\n<li><p>系统</p>\n<ul>\n<li>Windows：本地安装的目录下&#x2F;data  目录下可以挑选很多库</li>\n<li>Windows：本地安装的目录下&#x2F;data  目录下可以挑选很多库</li>\n</ul>\n</li>\n<li><p>frm文件： 存放表结构</p>\n</li>\n<li><p>myd文件：存放表数据</p>\n</li>\n<li><p>myi文件： 存放表索引</p>\n</li>\n</ul>\n<h1 id=\"逻辑架构\"><a href=\"#逻辑架构\" class=\"headerlink\" title=\"逻辑架构\"></a>逻辑架构</h1><img data-src=\"/2022/10/07/MySQL_Super/image-20220816182921842-1660960902142.png\" class=\"\">\n\n\n\n\n<h2 id=\"1-连接层\"><a href=\"#1-连接层\" class=\"headerlink\" title=\"1.连接层\"></a>1.连接层</h2><p>​\t最上层是一些客户端和连接服务，包含本地sock通信和大多数基于客户端&#x2F;服务端工具实现的类似于tcplip的通信。主要完成一些类似于连接处理、授权认证、及相关的安全方案。在该层上引入了线程池的概念，为通过认证安全接入的客户端提供线程。同样在该层上可以实现基于SSL的安全链接。服务器也会为安全接入的每个客户端验证它所具有的操作权限。</p>\n<h2 id=\"⒉服务层\"><a href=\"#⒉服务层\" class=\"headerlink\" title=\"⒉服务层\"></a>⒉服务层</h2><p>​\t第二层架构主要完成大多少的核心服务功能，如SQL接口，并完成缓存的查询，SQL的分析和优化及部分内置函数的执行。所有跨存储引擎的功能也在这一层实现，如过程、函数等。在该层，服务器会解析查询并创建相应的内部解析树，并对其完成相应的优化如确定查询表的顺序，是否利用索引等，最后生成相应的执行操作。如果是select语句，服务器还会查询内部的缓存。如果缓存空间足够大，这样在解决大量读操作的环境中能够很好的提升系统的性能。</p>\n<h2 id=\"3-引擎层\"><a href=\"#3-引擎层\" class=\"headerlink\" title=\"3.引擎层\"></a>3.引擎层</h2><p>​\t存储引擎层，存储引擎真正的负责了MySQL中数据的存储和提取，服务器通过API与存储引擎进行通信。不同的存储引擎具有的功能不同，这样我们可以根据自己的实际需要进行选取。后面介绍MylSAM和InnoDB</p>\n<p>常用的存储引擎：MyISAM、InnoDB(最常用)</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">对比项</th>\n<th align=\"center\">MylSAM</th>\n<th align=\"center\">InnoDB</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">主外键</td>\n<td align=\"center\">不支持</td>\n<td align=\"center\">支持</td>\n</tr>\n<tr>\n<td align=\"left\">事务</td>\n<td align=\"center\">不馳</td>\n<td align=\"center\">支持</td>\n</tr>\n<tr>\n<td align=\"left\">行表锁</td>\n<td align=\"center\">表锁，即使操作一条记录也会锁住整 个表，不适合高并发的操作</td>\n<td align=\"center\">行锁,操作时只锁某一行，不对其它 行有影响， 适合高并发的操作</td>\n</tr>\n<tr>\n<td align=\"left\">緩存</td>\n<td align=\"center\">只緩存索引，不缓存真实数据</td>\n<td align=\"center\">不仅缓存索引还要缓存真实数据，对 内存要求较高，而且内存大小对性能 有决定性的影响</td>\n</tr>\n<tr>\n<td align=\"left\">表空间</td>\n<td align=\"center\">小</td>\n<td align=\"center\">大</td>\n</tr>\n<tr>\n<td align=\"left\">关注点</td>\n<td align=\"center\">性能</td>\n<td align=\"center\">事务</td>\n</tr>\n<tr>\n<td align=\"left\">默认安装</td>\n<td align=\"center\">Y</td>\n<td align=\"center\">Y</td>\n</tr>\n</tbody></table>\n<h2 id=\"4-存储层\"><a href=\"#4-存储层\" class=\"headerlink\" title=\"4.存储层\"></a>4.存储层</h2><p>​\t数据存储层，主要是将数据存储在运行于裸设备的文件系统之上，并完成与存储引擎的交互。</p>\n<img data-src=\"/2022/10/07/MySQL_Super/image-20220816181915861-1660960902143.png\" class=\"\">\n\n\n<h2 id=\"连接器\"><a href=\"#连接器\" class=\"headerlink\" title=\"连接器\"></a>连接器</h2><p>▪  连接器负责跟客户端建立连接，获取权限、维持和管理连接<br>– 用户名密码验证<br>– 查询权限信息，分配对应的权限<br>– 可以使用show processlist查看现在的连接<br>– 如果太长时间没有动静，  就会自动断开，通过wait_timeout控制，默认8小时<br>▪  连接可以分为两类：<br>– 长连接：推荐使用，但是要周期性的断开长连接</p>\n<p>– 短链接：</p>\n<h2 id=\"查询缓存\"><a href=\"#查询缓存\" class=\"headerlink\" title=\"查询缓存\"></a>查询缓存</h2><p>▪  当执行查询语句的时候，会先去查询缓存中查看结果，之前执行 过的sql语句及其结果可能以key-value的形式存储在缓存中，如 果能找到则直接返回，如果找不到，就继续执行后续的阶段。<br>&#x3D;&#x3D;▪  但是，不推荐使用查询缓存：&#x3D;&#x3D;<br>– 1、查询缓存的失效比较频繁，只要表更新，缓存就会清空</p>\n<p>– 2、缓存对应新更新的数据命中率比较低</p>\n<h2 id=\"分析器\"><a href=\"#分析器\" class=\"headerlink\" title=\"分析器\"></a>分析器</h2><p>▪  词法分析：  Mysql需要把输入的字符串进行识别每个部分代表什 么意思<br>– 把字符串 T 识别成 表名 T<br>– 把字符串 ID 识别成 列ID<br>▪  语法分析：</p>\n<p>▪  根据语法规则判断这个sql语句是否满足mysql的语法，如果不符 合就会报错“You have an error in your SQL synta”</p>\n<h2 id=\"优化器\"><a href=\"#优化器\" class=\"headerlink\" title=\"优化器\"></a>优化器</h2><p>▪  在具体执行SQL语句之前，要先经过优化器的处理<br>– 当表中有多个索引的时候，决定用哪个索引<br>– 当sql语句需要做多表关联的时候，  决定表的连接顺序<br>– 等等<br>▪ 不同的执行方式对SQL语句的执行效率影响很大<br>– RBO:基于规则的优化</p>\n<p>– CBO:基于成本的优化</p>\n<h1 id=\"SQL性能下降原因\"><a href=\"#SQL性能下降原因\" class=\"headerlink\" title=\"SQL性能下降原因\"></a>SQL性能下降原因</h1><ol>\n<li>查询语句写的烂</li>\n<li>索引失效</li>\n<li>关联查询太多 join </li>\n<li>服务器调优及各个参数设置（缓冲、线程数）</li>\n<li>……….etc</li>\n</ol>\n<h1 id=\"SQL语句机读过程\"><a href=\"#SQL语句机读过程\" class=\"headerlink\" title=\"SQL语句机读过程\"></a>SQL语句机读过程</h1><p>人工：</p>\n<pre><code class=\"sql\">    SELECT DISTINCT\n        &lt;SELECT_list&gt;\n    FROM\n        &lt;left_table&gt; &lt;join_type&gt;\n    Join &lt;right_table&gt; on &lt;join_condition&gt;\n    WHERE \n        &lt;WHERE_Condition&gt;\n    GROUP BY\n        &lt;group_by_list&gt;\n    HAVING\n        &lt;having_condition&gt;\n    ORDER BY\n        &lt;order_by_condition&gt;\n    LIMIT &lt;limit_num&gt;\n</code></pre>\n<p>机器：</p>\n<img data-src=\"/2022/10/07/MySQL_Super/image-20220816200725202-1660960902143.png\" class=\"\">\n\n\n<p>注意第一步是 from –&gt; on –&gt; join –&gt;where –&gt;group by –&gt;having –&gt;select –&gt;order by –&gt;limit</p>\n<pre><code class=\"sql\">    from &lt;left table&gt;\n        on &lt;on_condition&gt;\n    &lt;join_type&gt; join &lt;join_table&gt;\n    where &lt;where_condition&gt;\n    group by &lt;group_by_list&gt;\n        &lt;sum()avg()等聚合函数&gt;\n    having &lt;having_condition&gt;\n    select &lt;select_list&gt;\n    distinct\n    order by &lt;order_by_condition&gt;\n    limit &lt;limit_number&gt;\n</code></pre>\n<h2 id=\"on和where的区别？\"><a href=\"#on和where的区别？\" class=\"headerlink\" title=\"on和where的区别？\"></a>on和where的区别？</h2><p>​\t简单地说，当有外关联表时，on主要是针对外关联表进行筛选，主表保留，当没有关联表时，二者作用相同。</p>\n<p>例如在左外连时，首先执行on，筛选掉外连表中不符合on表达式的数据，而where的筛选是对主表的筛选。</p>\n<h1 id=\"MySql执行顺序理解\"><a href=\"#MySql执行顺序理解\" class=\"headerlink\" title=\"MySql执行顺序理解\"></a>MySql执行顺序理解</h1><p>第一步：加载from子句的前两个表计算笛卡尔积，生成虚拟表vt1；</p>\n<p>第二步：筛选关联表符合on表达式的数据，保留主表，生成虚拟表vt2；</p>\n<p>第三步：如果使用的是外连接，执行on的时候，会将主表中不符合on条件的数据也加载进来，做为外部行</p>\n<p>第四步：如果from子句中的表数量大于2，则重复第一步到第三步，直至所有的表都加载完毕，更新vt3；</p>\n<p>第五步：执行where表达式，筛选掉不符合条件的数据生成vt4；</p>\n<p>第六步：执行group by子句。group by 子句执行过后，会对子句组合成唯一值并且对每个唯一值只包含一行，生成vt5,。一旦执行group by，后面的所有步骤只能得到vt5中的列（group by的子句包含的列）和聚合函数。</p>\n<p>第七步：执行聚合函数，生成vt6；</p>\n<p>第八步：执行having表达式，筛选vt6中的数据。having是唯一一个在分组后的条件筛选，生成vt7;</p>\n<p>第九步：从vt7中筛选列，生成vt8；</p>\n<p>第十步：执行distinct，对vt8去重，生成vt9。其实执行过group by后就没必要再去执行distinct，因为分组后，每组只会有一条数据，并且每条数据都不相同。</p>\n<p>第十一步：对vt9进行排序，此处返回的不是一个虚拟表，而是一个游标，记录了数据的排序顺序，此处可以使用别名；</p>\n<p>第十二步：执行limit语句，将结果返回给客户端</p>\n<div name=索引优化分析 >\n\n\n<h1 id=\"索引\"><a href=\"#索引\" class=\"headerlink\" title=\"索引\"></a>索引</h1><p>​\tMySQL官方对索引的定义为：索引(Index）是帮助MySQL高效获取数据的数据结构。可以得到索引的本质:&#x3D;&#x3D;索引是数据结构&#x3D;&#x3D;。</p>\n<p><font color=red >可以简单理解为 “排好序的快速查找数据结构”</font></p>\n<p>一般来说索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上</p>\n<p>我们平常所说的&#x3D;&#x3D;索引，如果没有特别指明，都是指B树(多路搜索树，并不一定是二叉的)结构组织的索引&#x3D;&#x3D;。其中聚集索引，次要索引，复合索引，前缀索引，唯一索引默认都是使用B+树索引，统称索引。当然，除了B+树这种类型的索引之外还有哈稀索引(hash，index)等。</p>\n<p>简单来说&#x3D;&#x3D;最大的作用&#x3D;&#x3D;就是 &#x3D;&#x3D;排序&#x3D;&#x3D; 和 &#x3D;&#x3D;查询&#x3D;&#x3D; </p>\n<h2 id=\"目的\"><a href=\"#目的\" class=\"headerlink\" title=\"目的\"></a>目的</h2><p>提高查询效率，可以类比字典，<br>如果要查“mysql”这个单询，我们肯定需要定位到m字母，然后从下往下找到y字母，再找到剩下的sql。<br>如果没有索引，那么你可能需要a—-z，如果我想找到Java开头的单词呢?或者Oracle开头的单词呢?<br>是不是觉得如果没有索引，这个事情根本无法完成?</p>\n<h2 id=\"详解\"><a href=\"#详解\" class=\"headerlink\" title=\"详解\"></a>详解</h2><p>​\t在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引。</p>\n<p>下图就是一种可能的索引方式示例:</p>\n<img data-src=\"/2022/10/07/MySQL_Super/image-20220816211711261-1660960902143.png\" class=\"\">\n\n\n<p>​\t\t\t\t左边是数据表，一共有两列七条记录，最左边的是数据记录的物理地址</p>\n<p>​\t为了加快Col2的查找，可以维护一个右边所示的二叉查找树，每个节点分别包含索引键值和一个指向对应数据记录物理地址的指针，这样就可以运用二叉查找在一定的复杂度内获取到相应数据，从而快速的检索出符合条件的记录.</p>\n<h2 id=\"优劣\"><a href=\"#优劣\" class=\"headerlink\" title=\"优劣\"></a>优劣</h2><p>优势：</p>\n<p>​\t类似大学图书馆建书目索引，提高数据检索的效率，降低数据库的IO成本</p>\n<p>​\t 通过索引列对数据进行排序，降低数据排序的成本，降低了CPU的消耗</p>\n<p>劣势：</p>\n<p>​\t1、实际上索引也是一张表，该表保存了主键与索引字段，并指向实体表的记录，所以索引列也是要占用空间</p>\n<p>​\t2、虽然索引大大提高了查询速度，同时却会降低更新表的速度，如对表进行INSERT、UPDATE和DELETE。因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件每次更新添加了索引列的字段，<br>都会调整因为更新所带来的键值变化后的索引信息<br>​\t3、索引只是提高效率的一个因素，如果你的MySQL有大数据量的表，就需要花时间研究建立最优秀的索引</p>\n<h2 id=\"分类\"><a href=\"#分类\" class=\"headerlink\" title=\"分类\"></a>分类</h2><ul>\n<li>单值索引：即一个索引只包含单个列，一个表可以有多个单列索引</li>\n<li>唯一索引：索引列的值必须唯一，但允许有空值</li>\n<li>复合索引：即一个索引包含多个列</li>\n</ul>\n<h2 id=\"基本语法\"><a href=\"#基本语法\" class=\"headerlink\" title=\"基本语法\"></a>基本语法</h2><ul>\n<li><p>创建：</p>\n<ul>\n<li>CREATE\t [UNIQUE ]INDEX  \tindexName   \tON   \tmytable(columnname(length));</li>\n<li>CREATE\t [UNIQUE ]INDEX      indexName   \tON   \tmytable(columnname(length));</li>\n</ul>\n<p>\t</p>\n</li>\n<li><p>删除 </p>\n<ul>\n<li>DROP \tINDEX \t[indexName] \tON \tmytable;</li>\n</ul>\n</li>\n<li><p>查看  </p>\n<ul>\n<li>SHOW \t\tINDEX \t\tFROM \t\ttable_name\\G</li>\n</ul>\n</li>\n<li><p>使用ALTER命令</p>\n</li>\n</ul>\n<h2 id=\"MySQL索引结构\"><a href=\"#MySQL索引结构\" class=\"headerlink\" title=\"MySQL索引结构\"></a>MySQL索引结构</h2><ul>\n<li><p>BTree索引</p>\n</li>\n<li><p>Hash索引</p>\n</li>\n<li><p>Full-Text全文索引</p>\n</li>\n<li><p>R-Tree索引</p>\n</li>\n</ul>\n<h2 id=\"哪些情况下需要创建索引\"><a href=\"#哪些情况下需要创建索引\" class=\"headerlink\" title=\"哪些情况下需要创建索引\"></a>哪些情况下需要创建索引</h2><ol>\n<li><p>主键自动建立唯一索引</p>\n</li>\n<li><p>频繁作为查询条件的字段应该创建索引</p>\n</li>\n<li><p>查询中与其它表关联的字段，外键关系建立索引</p>\n</li>\n<li><p>频繁更新的字段不适合创建索引or因为每次更新不单单是更新了记录还会更新索引</p>\n</li>\n<li><p>Where条件里用不到的字段不创建索引</p>\n</li>\n<li><p>单键&#x2F;组合索引的选择问题，who?(在高并发下倾向创建组合索引)</p>\n</li>\n<li><p>查询中排序的字段，排序字段若通过索引去访问将大大提高排序速度</p>\n</li>\n<li><p>查询中统计或者分组字段</p>\n</li>\n</ol>\n<h2 id=\"哪些情况不建索引\"><a href=\"#哪些情况不建索引\" class=\"headerlink\" title=\"哪些情况不建索引\"></a>哪些情况不建索引</h2><ol>\n<li><p>表记录太少</p>\n</li>\n<li><p>经常增删改的表</p>\n<p> Why:提高了查询速度，同时却会降低更新表的速度，如对表进行INSERT、UPDATE和DELETE。因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件</p>\n</li>\n<li><p>数据重复且分布平均的表字段，因此应该只为最经常查询和最经常排序的数据列建立索引。注意，如果某个数据列包含许多重复的内容，为它建立索引就没有太大的实际效果。</p>\n</li>\n</ol>\n<h1 id=\"性能分析\"><a href=\"#性能分析\" class=\"headerlink\" title=\"性能分析\"></a>性能分析</h1><h2 id=\"MySql-Query-Optimizer\"><a href=\"#MySql-Query-Optimizer\" class=\"headerlink\" title=\"MySql Query Optimizer\"></a>MySql Query Optimizer</h2><ol>\n<li><p>Mysql中有专门负责优化SELECT语句的优化器模块，主要功能:通过计算分析系统中收集到的统计信息，为客户端请求的Query提供他认为最优的执行计划（他认为最优的数据检索方式，但不见得是DBA认为是最优的，这部分最耗费时间)</p>\n</li>\n<li><p>当客户端向MySQL请求一条Query，命令解析器模块完成请求分类，区别出是SELECT并转发给MySQLQuery Optimizer时，MySQL Query Optimizer首先会对整条Query进行优化，处理掉一些常量表达式的预算，直接换算成常量值。并对Query中的查询条件进行简化和转换，如去掉一些无用或显而易见的条件、结构调整等。然后分析Query 中的Hint信息(如果有），看显示Hint信息是否可以完全确定该Query 的执行计划。如果没有Hint 或Hint 信息还不足以完全确定执行计划，则会读取所涉及对象的统计信息，根据Query进行写相应的计算分析，然后再得出最后的执行计划。</p>\n</li>\n</ol>\n<h2 id=\"MysQL常见瓶颈\"><a href=\"#MysQL常见瓶颈\" class=\"headerlink\" title=\"MysQL常见瓶颈\"></a>MysQL常见瓶颈</h2><p>CPU:CPU在饱和的时候一般发生在数据装入内存或从磁盘上读取数据时候</p>\n<p>IO:磁盘I&#x2F;O瓶颈发生在装入数据远大于内存容量的时候</p>\n<p>服务器硬件的性能瓶颈: top,free, iostat和vmstat来查看系统的性能状态</p>\n<h2 id=\"Explain\"><a href=\"#Explain\" class=\"headerlink\" title=\"Explain\"></a>Explain</h2><h3 id=\"作用\"><a href=\"#作用\" class=\"headerlink\" title=\"作用\"></a>作用</h3><p>​\t查看执行计划</p>\n<p>​\t使用EXPLAIN关键字可以模拟优化器执行sQL查询语句，从而知道MySQL是如何处理你的SQL语句的。分析你的查询语句或是表结构的性能瓶颈</p>\n<h3 id=\"作用范围\"><a href=\"#作用范围\" class=\"headerlink\" title=\"作用范围\"></a>作用范围</h3><ol>\n<li><p>表的读取顺序   __ id__</p>\n</li>\n<li><p>数据读取操作的操作类型哪些索引可以使用  <strong>possible key</strong></p>\n</li>\n<li><p>哪些索引被实际使用表之间的引用  <strong>key</strong></p>\n</li>\n<li><p>每张表有多少行被优化器查询    <strong>rows</strong></p>\n</li>\n<li><p>表之间的引用 <strong>table</strong></p>\n</li>\n<li><p>每张表有多少行被优化     <strong>rows</strong></p>\n</li>\n</ol>\n<h3 id=\"使用方法\"><a href=\"#使用方法\" class=\"headerlink\" title=\"使用方法\"></a>使用方法</h3><p>explain + SQL语句</p>\n<h3 id=\"执行计划包含的信息\"><a href=\"#执行计划包含的信息\" class=\"headerlink\" title=\"执行计划包含的信息\"></a>执行计划包含的信息</h3><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXYubXlzcWwuY29tL2RvYy9yZWZtYW4vNS43L2VuL2V4cGxhaW4tb3V0cHV0Lmh0bWwjZXhwbGFpbl9zZWxlY3RfdHlwZQ==\">MySQL ：： MySQL 5.7 参考手册 ：： 8.8.2 EXPLAIN 输出格式</span></p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">列</th>\n<th align=\"center\">JSON名称</th>\n<th align=\"center\">意义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">id</td>\n<td align=\"center\">select_id</td>\n<td align=\"center\">标识符SELECT</td>\n</tr>\n<tr>\n<td align=\"center\"><a href=\"#select_type\">select type</a></td>\n<td align=\"center\">没有</td>\n<td align=\"center\">类型SELECT</td>\n</tr>\n<tr>\n<td align=\"center\">table</td>\n<td align=\"center\">table_name</td>\n<td align=\"center\">输出行的表</td>\n</tr>\n<tr>\n<td align=\"center\">partitions</td>\n<td align=\"center\">partitions</td>\n<td align=\"center\">匹配的分区</td>\n</tr>\n<tr>\n<td align=\"center\"><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXYubXlzcWwuY29tL2RvYy9yZWZtYW4vNS43L2VuL2V4cGxhaW4tb3V0cHV0Lmh0bWwjZXhwbGFpbi1qb2luLXR5cGVz\">type</span></td>\n<td align=\"center\">access_type</td>\n<td align=\"center\">联接頰</td>\n</tr>\n<tr>\n<td align=\"center\">possible keys</td>\n<td align=\"center\">possible_keys</td>\n<td align=\"center\">可供选择的可能索引</td>\n</tr>\n<tr>\n<td align=\"center\">key</td>\n<td align=\"center\">key</td>\n<td align=\"center\">实际选择的索引</td>\n</tr>\n<tr>\n<td align=\"center\">key 丄en</td>\n<td align=\"center\">key_length</td>\n<td align=\"center\">所选密钥的长度</td>\n</tr>\n<tr>\n<td align=\"center\">ref</td>\n<td align=\"center\">ref</td>\n<td align=\"center\">与索引相比的列</td>\n</tr>\n<tr>\n<td align=\"center\">rows</td>\n<td align=\"center\">rows</td>\n<td align=\"center\">要检查的行的估计值</td>\n</tr>\n<tr>\n<td align=\"center\">filtered</td>\n<td align=\"center\">filtered</td>\n<td align=\"center\">符合某条件的记录数百分比。</td>\n</tr>\n<tr>\n<td align=\"center\">Extra</td>\n<td align=\"center\">None</td>\n<td align=\"center\">附加信息</td>\n</tr>\n</tbody></table>\n<h3 id=\"字段解释\"><a href=\"#字段解释\" class=\"headerlink\" title=\"字段解释\"></a>字段解释</h3><h4 id=\"id\"><a href=\"#id\" class=\"headerlink\" title=\"id\"></a>id</h4><p>id相同，执行顺序由上至下</p>\n<p>id不同，如果是子查询，id的序号会递增，id值越大优先级越高，越先被执行</p>\n<p>null 为结果集的整合</p>\n<p>总结：</p>\n<ul>\n<li>id如果相同，可以认为是一组，从上往下顺序执行;</li>\n<li>id值越大，优先级越高，越先执行</li>\n</ul>\n<h4 id=\"select-type\"><a href=\"#select-type\" class=\"headerlink\" title=\"select_type\"></a>select_type</h4><p><a href=\"#select_type\">见下方附录</a></p>\n<h4 id=\"type\"><a href=\"#type\" class=\"headerlink\" title=\"type\"></a>type</h4><table>\n<thead>\n<tr>\n<th align=\"center\">类型</th>\n<th align=\"center\">性能</th>\n<th>注释</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">system</td>\n<td align=\"center\">1</td>\n<td>&#x3D;&#x3D;表只有一行记录&#x3D;&#x3D;(等于系统表),这是const类型的特例，平时不会出现，可忽略</td>\n</tr>\n<tr>\n<td align=\"center\">const</td>\n<td align=\"center\">2</td>\n<td>表示该表最多有一个匹配行通过索引一次就找到了,const用于比较primary key或者<br/>unique索引。因为只匹配一行数据，所以很快如将主键置于where列表中<br/>MySQL就能将该查询转换为一个常量</td>\n</tr>\n<tr>\n<td align=\"center\">eq_ref</td>\n<td align=\"center\">3</td>\n<td>&#x3D;&#x3D;唯一性索引&#x3D;&#x3D;扫描，对于&#x3D;&#x3D;每个索引键，表中只有一条记录与之匹配&#x3D;&#x3D;。常见于主键或唯一索引扫描</td>\n</tr>\n<tr>\n<td align=\"center\">ref</td>\n<td align=\"center\">4</td>\n<td>&#x3D;&#x3D;非唯一性索引&#x3D;&#x3D;扫描，&#x3D;&#x3D;返回匹配某个单独值的所有行&#x3D;&#x3D;.<br/>本质上也是一种索引访问，它返回所有匹配某个单独值的行，然而， <br/>它可能会找到多个符合条件的行，所以他应该属于查找和扫描的混合体</td>\n</tr>\n<tr>\n<td align=\"center\">range</td>\n<td align=\"center\">5</td>\n<td>&#x3D;&#x3D;只检索给定范围的行,使用一个索引来选择行&#x3D;&#x3D;。key列显示使用了哪个索引，<br/>一般就是在你的where语句中出现了between、&lt;、&gt;、in等的查询  <br/>这种范围扫描索引扫描比全表扫描要好，因为它只需要开始于索引的某一点，<br/>而结束语另一点，不用扫描全部索引</td>\n</tr>\n<tr>\n<td align=\"center\">index</td>\n<td align=\"center\">6</td>\n<td>联接类型与 <a href=\"https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#jointype_all\"><code>ALL</code></a> 相同，只是扫描了索引树。这以两种方式发生：<code>index</code> <br/>Full Index Scan，index与ALL区别为index类型只遍历索引树。这通常比ALL快，<br/>因为索引文件通常比数据文件小。(也就是说虽然all和Index都是读全表，<br/>但index是从索引中读取的，而all是从硬盘中读的)</td>\n</tr>\n<tr>\n<td align=\"center\">all</td>\n<td align=\"center\">7</td>\n<td>将遍历全表以找到匹配的行</td>\n</tr>\n</tbody></table>\n<p><font color=red>一般来说，得保证查询至少要达到 range 级别，最好能达到 ref </font></p>\n<h4 id=\"possible-key\"><a href=\"#possible-key\" class=\"headerlink\" title=\"possible_key\"></a>possible_key</h4><p>显示可能应用在这张表中的索引，一个或多个</p>\n<p>查询涉及到的字段上若存在索引，则该索引将被列出，<font color=red>但不一定被查询实际使用</font>。</p>\n<h4 id=\"key\"><a href=\"#key\" class=\"headerlink\" title=\"key\"></a>key</h4><p>&#x3D;&#x3D;实际使用的索引。如果为NULL，则没有使用索引&#x3D;&#x3D;</p>\n<p>查询中若使用了覆盖索引，则该索引仅出现在key列表中</p>\n<p><font color=red>引申：</font></p>\n<p>覆盖索引：简单来说就是你查询到的字段数目和你建立索引所对应字段相同且数量相同</p>\n<h4 id=\"key-len\"><a href=\"#key-len\" class=\"headerlink\" title=\"key_len\"></a>key_len</h4><p>​\t表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度。在不损失精确性的情况下，&#x3D;&#x3D;长度越短越好&#x3D;&#x3D;<br>​\tkey_len显示的值为索刳字段的最大可能长度，<font color=red>并非实际使用长度</font>，即key_len是根据表定义计算而得，不是通过表内检索出的</p>\n<h4 id=\"ref\"><a href=\"#ref\" class=\"headerlink\" title=\"ref\"></a>ref</h4><p>​\t显示索引的哪一列被使用了，如果可能的话，是一个常数。哪些列或常量被用于查找索引列上的值</p>\n<h4 id=\"rows\"><a href=\"#rows\" class=\"headerlink\" title=\"rows\"></a>rows</h4><p>​\t根据表统计信息及索引选用情况，大致估算出找到所需的记录所需要读取的行数</p>\n<h4 id=\"extra\"><a href=\"#extra\" class=\"headerlink\" title=\"extra\"></a>extra</h4><p>包含不适合在其他列中显示但十分重要的额外信息</p>\n<ul>\n<li><p>Using filesort(<font color=red>索引本来就是排序和查找,这种等于只用了一半,而且排序本身就比较耗时</font>)</p>\n<p>  说明mysq|会对数据使用一个外部的索引排序，而不是按照表内的索引顺序进行读取。</p>\n<p>  MySQL中无法利用索引完成的排序操作称为“文件排序”</p>\n</li>\n<li><p>Using temporay(<font color=red>严重影响性能</font>)</p>\n<p>  使了用临时表保存中间结果,MySQL在对查询结果排序时使用临时表。</p>\n<p>  常见于排序orderby和分组查询groupby。</p>\n</li>\n<li><p>Using  index</p>\n<p>  表示相应的select操作中使用了覆盖索引(Covering Index)，避免访问了表的数据行，效率不错!如果同时出现</p>\n<p>  using where，表明索引被用来执行索引键值的查找;</p>\n<p>  如果没有同时出现using where，表明索引用来读取数据而非执行查找动作。</p>\n<p>  <strong>&#x3D;&#x3D;覆盖索引(Covering Index)&#x3D;&#x3D;</strong></p>\n<p>  理解方式：就是select的数据列只用从索引中就能够取得，不必读取数据行，MySQL可 以利用索引返回select列表中的字段，而不必根据索引再次读取数据文件,换句话说查询列要被所建的索引覆盖。</p>\n<p>  &#x3D;&#x3D;<strong>注意:</strong>&#x3D;&#x3D;<br>  如果要使用覆盖索引，一-定 要注意select列表中只取出需要的列，不可   **&#x3D;&#x3D;Select   <em>&#x3D;&#x3D;</em>*<br>  因为如果将所有字段一起做索引会导致索引文件过大，查询性能下降。</p>\n</li>\n</ul>\n<h1 id=\"索引优化\"><a href=\"#索引优化\" class=\"headerlink\" title=\"索引优化\"></a>索引优化</h1><h2 id=\"单表优化\"><a href=\"#单表优化\" class=\"headerlink\" title=\"单表优化\"></a>单表优化</h2><p>准备</p>\n<pre><code class=\"sql\">CREATE TABLE IF NOT EXISTS article (\nid INT(10) UNSIGNED NOT NULL PRIMARY KEY auto_INCREMENT,\nauthor_id INT(10) UNSIGNED NOT NULL,\ncategory_id INT(10) UNSIGNED NOT NULL,\nviews INT(10) UNSIGNED NOT NULL,\ncomments INT(10) UNSIGNED NOT NULL,\ntitle VARBINARY(255) NOT NULL,\ncontent TEXT NOT NULL\n);\n\nINSERT INTO article ( author_id ,category_id ,views ,comments ,title,content ) VALUES\n(1, 1, 1, 1,&#39;1&#39;,&#39;1&#39;),\n(2,2, 2,2, &#39;2&#39;,&#39;2&#39;),\n(1, 1,3,3, &#39;3&#39;,&#39;3&#39;);\n\n\n-- ----------------------------------------------\n-- 01\nexplain select id,author_id\nfrom article \nwhere category_id =1 and comments &gt;1 \norder by views desc \nlimit 1\\G\n-- 01-1\ncreate index idx_id_article_ccv on article(category_id,comments,views);\ndrop index idx_id_article_ccv on article;\ncreate index idx_id_article_cv on article(category_id,views);\ndrop index idx_id_article_cv on article;\n-- 查看之后发现因为 &gt; 1 的原因导致我们索引失效 我们直接放弃这个字段从三个改为两个字段的索引，性能更优\nexplain select id,author_id from article where category_id =1 and comments &gt;1  order by views desc limit 1 ;\nexplain select id,author_id from article where category_id =1 and comments =1  order by views desc limit 1 ;\n</code></pre>\n<h2 id=\"双表优化\"><a href=\"#双表优化\" class=\"headerlink\" title=\"双表优化\"></a>双表优化</h2><pre><code class=\"sql\">CREATE TABLE IF NOT EXISTS `class`(\n`id` INT(10) UNSIGNED NOT NULL AUTO_INCREMENT,\n`card`INT(10) UNSIGNED NOT NULL,\n PRIMARY KEY (id)\n );\ncreate TABLE IF NOT EXISTS `book` (\n`bookid` INT(10) UNSIGNED NOT NULL AUTO_INCREMENT,\n`card`  INT(10) UNSIGNED NOT NULL,\n PRIMARY KEY (bookid)\n);\nINSERT INTO class(card) VALUES(FLOOR(1 + (rand() * 20)));\nINSERT INTO class(card) VALUES(FLOOR(1 + (rand() * 20)));\nINSERT INTO class(card) VALUES(FLOOR(1 + (rand() * 20)));\nINSERT INTO class(card) VALUES(FLOOR(1 + (rand() * 20)));\nINSERT INTO class(card) VALUES(FLOOR(1 + (rand() * 20)));\nINSERT INTO class(card) VALUES(FLOOR(1 + (rand() * 20)));\nINSERT INTO class(card) VALUES(FLOOR(1 + (rand() * 20)));\nINSERT INTO class(card) VALUES(FLOOR(1 + (rand() * 20)));\nINSERT INTO book(card) VALUES(FLOOR(1 + (rand() * 20)));\nINSERT INTO book(card) VALUES(FLOOR(1 + (rand() * 20)));\nINSERT INTO book(card) VALUES(FLOOR(1 + (rand() * 20)));\nINSERT INTO book(card) VALUES(FLOOR(1 + (rand() * 20)));\nINSERT INTO book(card) VALUES(FLOOR(1 + (rand() * 20)));\nINSERT INTO book(card) VALUES(FLOOR(1 + (rand() * 20)));\nINSERT INTO book(card) VALUES(FLOOR(1 + (rand() * 20)));\nINSERT INTO book(card) VALUES(FLOOR(1 + (rand() * 20)));\n-- ----------------------------------------------\nselect * from book;\nselect * from class;\n\n-- type=all\nshow index from book;\nshow index from class;\n\ncreate index idx_card on  book(card);\ncreate index idx_card on  class(card);\ndrop index idx_card on  book;\ndrop index idx_card on  class;\n\nexplain select * from  book left join class on class.card=book.card;\n\nexplain select * from  class left join book on class.card=book.card;\n</code></pre>\n<p><strong>左连接</strong></p>\n<img data-src=\"/2022/10/07/MySQL_Super/image-20220818221306990-1660960902143.png\" class=\"\">\n\n\n<p>结果显示，在没有用索引的状况下我们的索引类型均为ALL。</p>\n<p>因为是&#x3D;&#x3D;左连接&#x3D;&#x3D;的缘故我们的&#x3D;&#x3D;左表是根据右表搜索行&#x3D;&#x3D;的，&#x3D;&#x3D;左边一定都有&#x3D;&#x3D;,所以&#x3D;&#x3D;右边是我们的关键点&#x3D;&#x3D;，一定需要建立索引。</p>\n<img data-src=\"/2022/10/07/MySQL_Super/image-20220818221831192-1660960902143.png\" class=\"\">\n\n\n<p>可以看到第二行的type变为了ref，rows 也变成了优化比较明显。这是由左连接特性决定的。LEFT  JOIN条件用于确定如何从右表搜索行。所以右边是我们的关键点,-定需要建立索引。</p>\n<p><strong>同理可证右连接</strong><br>因为RIGHTJOIN条件用于确定如何从左表搜索行，右边一定都有,所以左边是我们的关键点，一定需要建立索引。</p>\n<h2 id=\"三表优化\"><a href=\"#三表优化\" class=\"headerlink\" title=\"三表优化\"></a>三表优化</h2><pre><code class=\"sql\">CREATE TABLE IF NOT EXISTS phone(\n    phoneid INT(10) UNSIGNED NOT null AUTO_INCREMENT,\n    card INT(10) UNSIGNED NOT NULL,\n    PRIMARY KEY (phoneid)\n) ENGINE = INNODB;\nINSERT INTO phone(card) VALUES(FLOOR(1 + (RAND() * 20)));\nINSERT INTO phone(card) VALUES(FLOOR(1 + (RAND() * 20)));\nINSERT INTO phone(card) VALUES(FLOOR(1 + (RAND() * 20)));\nINSERT INTO phone(card) VALUES(FLOOR(1 + (RAND() * 20)));\nINSERT INTO phone(card) VALUES(FLOOR(1 + (RAND() * 20)));\nINSERT INTO phone(card) VALUES(FLOOR(1 + (RAND() * 20)));\nINSERT INTO phone(card) VALUES(FLOOR(1 + (RAND() * 20)));\nINSERT INTO phone(card) VALUES(FLOOR(1 + (RAND() * 20)));\nINSERT INTO phone(card) VALUES(FLOOR(1 + (RAND() * 20)));\nINSERT INTO phone(card) VALUES(FLOOR(1 + (RAND() * 20)));\nINSERT INTO phone(card) VALUES(FLOOR(1 + (RAND() * 20)));\nINSERT INTO phone(card) VALUES(FLOOR(1 + (RAND() * 20)));\nINSERT INTO phone(card) VALUES(FLOOR(1 + (RAND() * 20)));\n-- --------===============================================\nselect * from phone;\n\nalter table class add index X (card); \nalter table phone add index Y (card); \ndrop index X on class;\ndrop index Y on phone;\n\nexplain select * from class left join book on class.card = book.card join phone on book.card = phone.card;\n\nshow index from phone;\nshow index from book;\nshow index from class;\n</code></pre>\n<p>初始结果</p>\n<img data-src=\"/2022/10/07/MySQL_Super/image-20220818222159241-1660960902143.png\" class=\"\">\n\n\n<p>优化后</p>\n<img data-src=\"/2022/10/07/MySQL_Super/image-20220818222905733-1660960902143.png\" class=\"\">\n\n\n<p>后2行的type都是ref且总rows优化很好效果不错。</p>\n<p>因此索引最好设置在需要经常查询的字段中</p>\n<p>解释：不论是class还是phone都是需要book.card来确定而且在第二个join中还需要全部扫描book所以尽管他是一个与class的左连接，理论上要给book建立一个索引，但是因为phone的关系我们倒不如给phone和class做索引，减少可以减少的，book反正要全表无所谓。</p>\n<p>总结就是&#x3D;&#x3D;小结果集推动大结果集&#x3D;&#x3D;就可以起到优化作用</p>\n<h2 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"[结论]\"></a>[结论]</h2><p>Join语句的优化</p>\n<p>尽可能减少Join语句中的NestedL oop的循环总次数;“ 永远用小结果集驱动大的结果集”。</p>\n<p>优先优化Nested L oop的内层循环;</p>\n<p>保证Join语句中被驱动表上Join条件 字段已经被索引;</p>\n<p>当无法保证被驱动表的Join条件字段被索引且内存资源充足的前提下，不要太吝惜JoinBuffer的设置;</p>\n<h1 id=\"索引失效\"><a href=\"#索引失效\" class=\"headerlink\" title=\"索引失效\"></a>索引失效</h1><ol>\n<li>全值匹配我最爱</li>\n</ol>\n<blockquote>\n<p>​\t每个索引字段都存在</p>\n</blockquote>\n<ol start=\"2\">\n<li>最佳左前缀法则(&#x3D;&#x3D;where条件&#x3D;&#x3D;)</li>\n</ol>\n<blockquote>\n<p>​\t如果索引了多列(&#x3D;&#x3D;3个及以上&#x3D;&#x3D;)，要遵守最左前缀法则。指的是查询&#x3D;&#x3D;从索引的最左前列开始&#x3D;&#x3D;并且&#x3D;&#x3D;不跳过索引中的列&#x3D;&#x3D;。<br>​\t简单来说就是&#x3D;&#x3D;每个字段的带头大哥不能丢，中间兄弟不能断&#x3D;&#x3D; </p>\n<pre><code class=\"sql\">drop table if exists tbl_user;\ncreate table if not exists tbl_user(\nid int(10) primary key auto_increment,\nname varchar(20) not null,\nage int(10),\n    sex int(2) check( sex in (1,2)),\nemail varchar(20)\n);\n-- 添加测试数据\ndelete from  tbl_user;\ninsert into tbl_user(name,age,sex,email) values \n(&#39;aa11aa&#39;,12,1,&#39;123@qq.com&#39;),(&#39;aa22aa&#39;,22,2,&#39;456@qq.com&#39;),(&#39;aa33aa&#39;,32,2,&#39;789@qq.com&#39;);\n(&#39;aa11aa&#39;,22,1,&#39;123@qq.com&#39;),(&#39;aa22aa&#39;,22,1,&#39;456@qq.com&#39;),(&#39;aa33aa&#39;,32,1,&#39;789@qq.com&#39;);\n-- 走索引且key_len越来越长\nexplain select * from tbl_user where name = &#39;aa11aa&#39;;\nexplain select * from tbl_user where name = &#39;aa11aa&#39; and age = 11;\nexplain select * from tbl_user where name = &#39;aa11aa&#39; and age = 11 and sex = 1;\n\n-- 走索引\nexplain select * from tbl_user where name = &#39;aa11aa&#39;  and sex = 1;\n-- 不走索引带头大哥没了\nexplain select * from tbl_user where age = 11 and sex = 1;\n</code></pre>\n</blockquote>\n<ol start=\"3\">\n<li><p>不在索引列上做任何操作(计算、函数(自动or手动)类型转换)，会导致索引失效而转向全表扫描 </p>\n</li>\n<li><p>存储引擎 &#x3D;&#x3D;不能使用索引中范围条件&#x3D;&#x3D;<font color=red>右边的列</font> (&#x3D;&#x3D;自己是最后一个&#x3D;&#x3D;)</p>\n<pre><code class=\"sql\">-- 范围条件\nalter table tbl_user add index idx_tbl_user_age_sex_email (age,sex,email);\n-- 全部走了索引\nexplain select age from tbl_user ;\nexplain select age,sex from tbl_user ;\nexplain select age,sex,email from tbl_user ;\n-- 部分走了索引\nexplain select age from tbl_user where sex &gt; 1;\nexplain select age,sex from tbl_user where sex &gt; 1;\nexplain select age,sex,email from tbl_user where sex &gt; 1;\n</code></pre>\n</li>\n<li><p>&#x3D;&#x3D;尽量使用覆盖索引&#x3D;&#x3D;(只访问索引的查询(索引列和查询列一致))， 减少 select  *</p>\n</li>\n<li><p>mysql在&#x3D;&#x3D;使用不等于(!&#x3D;或者&lt;&gt; )&#x3D;&#x3D;的时候&#x3D;&#x3D;无法使用索引&#x3D;&#x3D;会导致&#x3D;&#x3D;全表扫描团&#x3D;&#x3D;</p>\n</li>\n<li><p>is null ,is not null也无法使用索引</p>\n</li>\n<li><p>like&#x3D;&#x3D;以通配符开头(&#x3D;&#x3D;’%abc…)mysq|&#x3D;&#x3D;索引失效&#x3D;&#x3D;会变成全表扫描的操作。(&#x3D;&#x3D;放右边可以&#x3D;&#x3D;)</p>\n<p> <strong>问题:解决like’%字符串%’时索引不被使用的方法??</strong></p>\n<pre><code class=\"sql\">-- 建立索引\nalter table tbl_user add index idx_tbl_user_name_age (name,age);\n\n-- 测试\nselect * from tbl_user;\n-- 走索引\nexplain select id from tbl_user where name like &#39;%aa%&#39;;\nexplain select name from tbl_user where name like &#39;%aa%&#39;;\nexplain select age from tbl_user where name like &#39;%aa%&#39;;\n-- 走索引\nexplain select id,name from tbl_user where name like &#39;%aa%&#39;;\nexplain select id,name,age from tbl_user where name like &#39;%aa%&#39;;\nexplain select name,age from tbl_user where name like &#39;%aa%&#39;;\n-- 不走索引\nexplain select * from tbl_user where name like &#39;%aa%&#39;;\nexplain select id,name,email from tbl_user where name like &#39;%aa%&#39;;\nexplain select id,name,age,email from tbl_user where name like &#39;%aa%&#39;;\n</code></pre>\n</li>\n<li><p>&#x3D;&#x3D;字符串不加单引号索引失效&#x3D;&#x3D;</p>\n</li>\n<li><p>少用or，用它来连接时会索引失效</p>\n</li>\n</ol>\n<h2 id=\"面试题\"><a href=\"#面试题\" class=\"headerlink\" title=\"面试题\"></a>面试题</h2><pre><code class=\"sql\">-- indexc1234\nselect * from test03 where c1=&#39;a1&#39; and c2=&#39;a2&#39; and c5=&#39;a5&#39; order by c3,c2;\nselect * from test03 where c1=&#39;a1&#39; and c5=&#39;a5&#39; order by c3,c2;\n</code></pre>\n<p><em><strong>这两种SQL的区别在哪？</strong></em></p>\n<blockquote>\n<p>都走了索引，但是在第2条SQL会产生文件的内排序，为什么呢？这是因为本来应该是自动的顺序排列，即c1,c2,c3…..默认，但是我们写了 order by 所以产生了内排。但是同样第1条SQL为什么没有呢？因为我们在where 条件中使用了他让他固定成了一个常量 constant ，即 c3虽然一直在动，但是c2已经固定没有了排序的过程所以不会产生内排的步骤</p>\n<pre><code class=\"sql\">drop table if exists t1;\ncreate table t1(\n    id int(10) primary key auto_increment,\n    c1 int(10),\n    c2 int(10),\n    c3 int(10),\n    c4 int(10),\n    c5 int(10)\n);\ninsert into t1(c1,c2,c3,c4,c5) values\n(1,1,1,1,1)\n(2,2,2,2,2),\n(3,3,3,3,3),\n(4,4,4,4,4),\n(5,5,5,5,5);\n\nalter table t1 add index idx_c1234 (c1,c2,c3,c4); \nexplain select * from t1 where c1 =1 and c2 = 1 and c4 = 1 ORDER BY c3,c2 desc;\nexplain select * from t1 where c1 =1 and c4 = 1 ORDER BY c3,c2 ;  \n</code></pre>\n</blockquote>\n<p>结果：</p>\n<img data-src=\"/2022/10/07/MySQL_Super/image-20220818213253106-1660960902143.png\" class=\"\">\n\n\n<p><em><strong>同理论证gourp by</strong></em></p>\n<ul>\n<li>分组之前比排序，可能会产生临时表的产生</li>\n</ul>\n<img data-src=\"/2022/10/07/MySQL_Super/image-20220818213434892-1660960902143.png\" class=\"\">\n\n\n\n\n<h2 id=\"建议\"><a href=\"#建议\" class=\"headerlink\" title=\"建议\"></a>建议</h2><ul>\n<li><p>对于单键索引，尽量选择针对当前query过滤性更好的索引</p>\n</li>\n<li><p>在选择组合索引的时候，当前Query中过滤性最好的字段在索引字段顺序中，位置越靠前越好。</p>\n</li>\n<li><p>在选择组合索引的时候，尽量选择可以能够包含当前query中的where字句中更多字段的索引</p>\n</li>\n<li><p>尽可能通过分析统计信息和调整query的写法来达到选择合适索引的目的</p>\n</li>\n</ul>\n<h2 id=\"口诀\"><a href=\"#口诀\" class=\"headerlink\" title=\"口诀\"></a>口诀</h2><p>全值匹配我最爱\t，最左前缀要遵守;</p>\n<p>帶头大哥不能死\t，中间兄弟不能断;</p>\n<p>索引列上少计算\t，范围之后全失效;</p>\n<p>LIKE百分写最右\t，覆盖索引不写星;</p>\n<p>不等空值还有or     ，索引失效要少用;</p>\n<p>VAR的引号不可丢，SQL高级也不难 !</p>\n<div name=查询截取分析 >\n\n\n<h1 id=\"查询截取分析\"><a href=\"#查询截取分析\" class=\"headerlink\" title=\"查询截取分析\"></a>查询截取分析</h1><h2 id=\"内容：\"><a href=\"#内容：\" class=\"headerlink\" title=\"内容：\"></a>内容：</h2><p>​\t查询优化</p>\n<p>​\t慢查询日志</p>\n<p>​\t批量数据脚本</p>\n<p>​\tshow profile</p>\n<p>​\t全局查询日志</p>\n<h2 id=\"工作一般流程-分析过程\"><a href=\"#工作一般流程-分析过程\" class=\"headerlink\" title=\"工作一般流程(分析过程)\"></a>工作一般流程(分析过程)</h2><ol>\n<li>观察，至少跑1天，看看生产的慢SQL情况。</li>\n<li>开启慢查询日志，设置阙值，比如超过5秒钟的就是慢SQL，并将它抓取出来。</li>\n<li>explain+慢SQL分析</li>\n<li>show profile</li>\n<li>运维经理or DBA，进行SQL数据库服务器的参数调优。。</li>\n</ol>\n<p>&#x3D;&#x3D;总结&#x3D;&#x3D;</p>\n<ol>\n<li><p>慢查询的开启并捕获</p>\n</li>\n<li><p>explain+慢SQL分析</p>\n</li>\n<li><p>show profile查询SQL在Mysql服务器里面的执行细节和生命周期情况</p>\n</li>\n<li><p>SQL数据库服务器的参数调优。</p>\n</li>\n</ol>\n<h2 id=\"查询优化\"><a href=\"#查询优化\" class=\"headerlink\" title=\"查询优化\"></a>查询优化</h2><h3 id=\"永远小表驱动大表-即小的数据集驱动大的数据集\"><a href=\"#永远小表驱动大表-即小的数据集驱动大的数据集\" class=\"headerlink\" title=\"永远小表驱动大表,即小的数据集驱动大的数据集\"></a>永远小表驱动大表,即小的数据集驱动大的数据集</h3><p>小表驱动大表，类似嵌套循环 Nested Loop</p>\n<h4 id=\"Case-1：\"><a href=\"#Case-1：\" class=\"headerlink\" title=\"Case 1：\"></a>Case 1：</h4><pre><code class=\"java\">for(int i =5;;)&#123;\n    for(int j = 1000;;)&#123;\n        \n    &#125;\n&#125;\nfor(int i =1000;;)&#123;\n    for(int j = 5;;)&#123;\n        \n    &#125;\n&#125;\n</code></pre>\n<p>两个简单的 for循环，但是在SQL中我们就应该选择 第一个循环而不是第二个</p>\n<ul>\n<li>小的循环在外层,表连接需要5次</li>\n<li>大的循环在外层,表连接需要1000次,浪费数据库资源</li>\n</ul>\n<p><strong>总结:</strong> 小表驱动大表的主要目的是通过减少表连接创建的次数,加快查询速度.</p>\n<h4 id=\"Case-2\"><a href=\"#Case-2\" class=\"headerlink\" title=\"Case 2\"></a>Case 2</h4><pre><code class=\"sql\">select * from A where  id in (select id from B)\n-- 等价于\nfor select id from B\nfor select * from A where A.id = B.id\nfor（B)&#123;\n    for(A)&#123;\n        A.id=B.id\n    &#125;\n&#125;\n</code></pre>\n<p>当B表的数据集小于A表的数据集时，用in优于exists。</p>\n<pre><code class=\"sql\">select * from A where exists (select 1 from B where B.id = A.id)\n-- 等价于\nfor select* from A\nfor select * from B where B.id = A.id\nfor（A)&#123;\n    for(B)&#123;\n        A.id=B.id\n    &#125;\n&#125;\n</code></pre>\n<p>当A表的数据集小于B表的数据集时，用exists优于in。</p>\n<p>注意:A表与B表的ID字段应建立索引。</p>\n<ul>\n<li>EXISTS</li>\n</ul>\n<blockquote>\n<p>语法：SELECT .….. FROM table WHERE EXISTS (subquery)</p>\n</blockquote>\n<p>​\t该语法可以理解为。&#x3D;&#x3D;将主查询的数据，放到子查询中做条件验证，根据验证结果（TRUE或FALSE)来决定主查询的数据结果是否得以保留&#x3D;&#x3D;。 </p>\n<ul>\n<li>提示<ol>\n<li>&#x3D;&#x3D;EXSTS (stbuey)只返回TRUE或FALSE，因此子查询中的 SELECT *也可以是 SELECT  1或是 SELECT ‘X’。官方说法是：实际执行时会忽略SELECT清单，因此没有区别&#x3D;&#x3D;</li>\n<li>EXSTS子查询的实际执行过程可能经过了优化而不是我们理解上的逐条对比，如果担忧效率问题，可进行实际检验以确定是否有效率问题。</li>\n<li>EXISTS子查询往往也可以用条件表达式、其他子查询或者JOIN来替代，&#x3D;&#x3D;何种最优需要具体问题具体分析&#x3D;&#x3D;</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"为排序使用索引OrdeBy优化\"><a href=\"#为排序使用索引OrdeBy优化\" class=\"headerlink\" title=\"为排序使用索引OrdeBy优化\"></a>为排序使用索引OrdeBy优化</h3><p>MySQL支持&#x3D;&#x3D;二种方式的排序&#x3D;&#x3D;，&#x3D;&#x3D;FileSort&#x3D;&#x3D;和&#x3D;&#x3D;Index&#x3D;&#x3D;，&#x3D;&#x3D;Index效率高。&#x3D;&#x3D;</p>\n<p>它指MySQL扫描索引本身完成排序。FileSort方式效率较低。</p>\n<p><font color=red>ORDER BY满足两情况，会使用Index方式排序：</font></p>\n<ul>\n<li><p>ORDER BY语句使用索引最左前列</p>\n</li>\n<li><p>使用where 字句与Order By字句条件列组合满足&#x3D;&#x3D;索引最左前列&#x3D;&#x3D;</p>\n</li>\n</ul>\n<p>建议：</p>\n<p>​\t尽量使用Index方式排序，避免使用FileSort方式排序尽可能在索引列上完成排序操作，遵照索引建的最佳左前缀</p>\n<p><font color=red>如果不在索引列上，filesort有两种算法：mysql就要启动双路排序和单路排序</font></p>\n<p>&#x3D;&#x3D;<em>双路排序</em>&#x3D;&#x3D;</p>\n<blockquote>\n<p>MySQL 4.1之前是使用双路排序,字面意思就是两次扫描磁盘，最终得到数据，<br>读取行指针和orderby列，对他们进行排序，然后扫描已经排序好的列表，按照列表中的值重新从列表中读取对应的数据输出</p>\n<p>从磁盘取排序字段，在buffer进行排序，再从磁盘取其他字段。</p>\n<p>取一批数据， 要对磁盘进行了两次扫描，众所周知，I\\O是很耗时的，所以在mysql4.1之后，出现了第二种改进的算法，就是单路排序</p>\n</blockquote>\n<p>&#x3D;&#x3D;<em>单路排序</em>&#x3D;&#x3D;</p>\n<blockquote>\n<p>从磁盘读取查询需要的所有列，按照order by列在buffer对它们进行排序，然后扫描排序后的列表进行输出，它的效率更快一些，避免了第二次读取数据。并且把随机IO变成了顺序I0,但是它会使用更多的空间，因为它把每一行都保存在内存中了。</p>\n</blockquote>\n<p>结论：</p>\n<p>​\t<strong>由于单路是后出的，总体而言好过双路!</strong></p>\n<p>引申出来的问题：</p>\n<blockquote>\n<p>​\t在sort_buffer中，方法B比方法A要多占用很多空间，因为方法B是把所有字段都取出,所以有可能取出的数据的总大小超出了sort_buffer的容量，导致每次只能取sort_buffer容量大小的数据，进行排序（创建tmp文件，多路合并〉，排完再取取 sort_buffer 容量大小，再排……从而多次I&#x2F;O。本来想省一次I&#x2F;O操作，反而导致了大量的I&#x2F;O操作，反而得不偿失。</p>\n</blockquote>\n<p>优化策略</p>\n<ul>\n<li>增大sort_buffer_size参数的设置</li>\n<li>增大max_length_for_sort_data参数的设置</li>\n</ul>\n<p><font color=red>提高Order By的速度</font></p>\n<ol>\n<li><p>Order by时select是一个大忌只Query需要的字段，这点非常重要。在这里的影响是:</p>\n<ol>\n<li>当Query的字段共小总和小于max_length_for_sort_data而且排序字段不是TEXTIBLOB类型时，会用改进后的算法——单路排序，否则用老算法——多路排序。</li>\n<li>两种算法的数据都有可能超出sort_buffer的容量，超出之后，会创建tmp文件进行合并排序，导致多次IO，但是用单路排序算法的风险会更大一些,所以要提高sort_buffer_size.</li>\n</ol>\n</li>\n<li><p>尝试提高sort_buffer_size<br> 不管用哪种算法，提高这个参数都会提高效率，当然，要根据系统的能力去提高，因为这个参数是针对每个进程的</p>\n</li>\n<li><p>尝试提高max_length_for_sort_data<br> 提高这个参数，会增加用改进算法的概率。但是如果设的太高，数据总容量超出sort_buffer_size的概率就增大，明显症状是高的磁盘I&#x2F;O活动和低的处理器使用率.</p>\n</li>\n</ol>\n<h3 id=\"Group-By\"><a href=\"#Group-By\" class=\"headerlink\" title=\"Group By\"></a>Group By</h3><p> group by实质是&#x3D;&#x3D;先排序&#x3D;&#x3D;后进行&#x3D;&#x3D;分组&#x3D;&#x3D;，&#x3D;&#x3D;遵照索引建的最佳左前缀&#x3D;&#x3D;</p>\n<p>当无法使用索引列，增大max_length_for_sort_data参数的设置+增大sort_buffer_size参数的设置</p>\n<p>where高于having，能写在where限定的条件就不要去having限定了。</p>\n<p>其余均和Order by相同</p>\n<h2 id=\"慢查询日志\"><a href=\"#慢查询日志\" class=\"headerlink\" title=\"慢查询日志\"></a>慢查询日志</h2><ul>\n<li><p>MySQL的慢查询日志是MySQL提供的一种日志记录，它用来记录在MySQL中响应时间超过阀值的语句, 具体指运行时间超过long_query_time值的SQL，则会被记录到慢查询日志中。</p>\n</li>\n<li><p>具体指运行时间超过long_query_time值的SQL，则会被记录到慢查询日志中。long_query_time的默认值为10，意思是运行10秒以上的语句。</p>\n</li>\n<li><p>由他来查看哪些SQL超出了我们的最大忍耐时间值，比如一条sql执行超过5秒钟，我们就算慢SQL，希望能收集超过5秒的sql，结合之前explain进行全面分析。</p>\n</li>\n</ul>\n<h3 id=\"操作说明\"><a href=\"#操作说明\" class=\"headerlink\" title=\"操作说明\"></a>操作说明</h3><p><font color=red>默认情况下，MySQL数据库没有开启慢查询日志</font>，需要我们手动来设置这个参数。</p>\n<p><font color=red>当然，如果不是调优需要的话，一般不建议启动该参数</font>，因为开启慢查询日志会或多或少带来一定的性能影响。慢查询日志支持将日志记录写入文件</p>\n<h3 id=\"查看是否开启及开启\"><a href=\"#查看是否开启及开启\" class=\"headerlink\" title=\"查看是否开启及开启\"></a>查看是否开启及开启</h3><p>默认：</p>\n<pre><code class=\"sql\">show variables like &#39;%slow_query_log%&#39;; -- OFF关闭\n</code></pre>\n<img data-src=\"/2022/10/07/MySQL_Super/image-20220819170427373-1660960902143.png\" class=\"\">\n\n\n<p>开启</p>\n<p>开启了慢查询日志只对当前数据库生效，如果MySQL重启后则会失效。</p>\n<pre><code class=\"sql\">set global slow_query_log=1;\n</code></pre>\n<p>如果要永久生效，就必须修改配置文件my.cnf（其它系统变量也是如此)</p>\n<p>修改my.cnf文件，[mysqld]下增加或修改参数<br>slow_query_log和slow_query_log_file后，然后重启MySQL服务器。也即将如下两行配置进my.cnf文件</p>\n<pre><code class=\"sh\">slow_query_log =1\nslow_query_log_file=/var/lib/mysqlslow-slow.log\n</code></pre>\n<p>关于慢查询的参数slow_query_log_file，它指定慢查询日志文件的存放路径，<font color=red>系统默认会给一个缺省的文件host_name-slow.log</font>(如果没有指定参数slow_query_log_file的话)</p>\n<h3 id=\"那么开启了慢查询日志后，什么样的SQL才会记录到慢查询日志里面呢\"><a href=\"#那么开启了慢查询日志后，什么样的SQL才会记录到慢查询日志里面呢\" class=\"headerlink\" title=\"那么开启了慢查询日志后，什么样的SQL才会记录到慢查询日志里面呢?\"></a>那么开启了慢查询日志后，什么样的SQL才会记录到慢查询日志里面呢?</h3><p>这个是由参数long_query_time控制，默认情况下long_query_time的值为10秒，命令:</p>\n<pre><code class=\"sql\">SHoW VARIABLES LIKE &#39;long_query_time%;\n</code></pre>\n<img data-src=\"/2022/10/07/MySQL_Super/image-20220819171026557-1660960902143.png\" class=\"\">\n\n\n\n<p>可以使用命令修改，也可以在my.cnf参数里面修改。</p>\n<p>假如运行时间正好等于long_query_time的情况，并不会被记录下来。也就是说，在mysql源码里是<font color=red>判断大于long_query_time，而非大于等于</font>。</p>\n<h3 id=\"Case\"><a href=\"#Case\" class=\"headerlink\" title=\"Case\"></a>Case</h3><ol>\n<li>查看当前多少秒算慢</li>\n</ol>\n<pre><code class=\"sql\">SHOW VARIABLES LIKE &#39;long_query_time%&#39;;\n</code></pre>\n<ol start=\"2\">\n<li>设置慢的阙值时间</li>\n</ol>\n<pre><code class=\"sql\">set global long_query_time=3;\n</code></pre>\n<img data-src=\"/2022/10/07/MySQL_Super/image-20220819171344450-1660960902143.png\" class=\"\">\n\n\n<ol start=\"3\">\n<li>为什么设置后看不出变化?</li>\n</ol>\n<p>需要&#x3D;&#x3D;重新连接或新开一个会话&#x3D;&#x3D;才能看到修改值</p>\n<pre><code class=\"sql\">SHow VARIABLES LIKE &#39;long _query_time%&#39;;\n\nshow global variables like &#39;long_query_time&#39;;\n</code></pre>\n<ol start=\"4\">\n<li>记录慢SQL并后续分析R</li>\n</ol>\n<pre><code class=\"sql\">select sleep(4);-- 睡4s\n-- 查看日志\n</code></pre>\n<img data-src=\"/2022/10/07/MySQL_Super/image-20220819171955968-1660960902143.png\" class=\"\">\n\n\n<ol start=\"5\">\n<li>查询当前系统中有多少条慢查询记录冒R</li>\n</ol>\n<pre><code class=\"sql\">show global status like &#39;%Slow_queries%&#39;;\n</code></pre>\n<img data-src=\"/2022/10/07/MySQL_Super/image-20220819172043683-1660960902143.png\" class=\"\">\n\n\n<h3 id=\"配置版\"><a href=\"#配置版\" class=\"headerlink\" title=\"配置版\"></a>配置版</h3><p>【mysqld】下配置:</p>\n<pre><code class=\"sh\"># 开启查询日志\nslow_query_log=1;\n# 日志地址\nslow_query_log_file=/var/lib/mysql/atguigu-slow.log\n# 最大的查询时间，超过就算是慢查询\nlong_query_time=3;\n# 日志输出\nlog_output=FILE\n</code></pre>\n<h3 id=\"日志分析工具—mysqldumpslow\"><a href=\"#日志分析工具—mysqldumpslow\" class=\"headerlink\" title=\"日志分析工具—mysqldumpslow\"></a>日志分析工具—mysqldumpslow</h3><p>​\t在生产环境中，如果要手工分析日志，查找、分析SQL，显然是个体力活，MySQL提供了日志分析工具mysqldumpslow </p>\n<p>查看mysqldumpslow的帮助信息</p>\n<pre><code class=\"sh\">mysqldumpslow --help\n</code></pre>\n<table>\n<thead>\n<tr>\n<th align=\"center\">常用参数</th>\n<th align=\"center\">注解</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">s</td>\n<td align=\"center\">是表示按照何种方式排序</td>\n</tr>\n<tr>\n<td align=\"center\">c</td>\n<td align=\"center\">访问次数</td>\n</tr>\n<tr>\n<td align=\"center\">l</td>\n<td align=\"center\">锁定时间</td>\n</tr>\n<tr>\n<td align=\"center\">r</td>\n<td align=\"center\">返回记录</td>\n</tr>\n<tr>\n<td align=\"center\">t</td>\n<td align=\"center\">查询时间</td>\n</tr>\n<tr>\n<td align=\"center\">al</td>\n<td align=\"center\">平均锁定时间</td>\n</tr>\n<tr>\n<td align=\"center\">ar</td>\n<td align=\"center\">平均返回记录数</td>\n</tr>\n<tr>\n<td align=\"center\">at</td>\n<td align=\"center\">平均查询时间</td>\n</tr>\n<tr>\n<td align=\"center\">t</td>\n<td align=\"center\">即为返回前面多少条的数据;</td>\n</tr>\n<tr>\n<td align=\"center\">g</td>\n<td align=\"center\">后边搭配一个正则匹配模式，大小写不敏感的;</td>\n</tr>\n</tbody></table>\n<pre><code class=\"sh\">得到返回记录集最多的10个SQL\nmysqldumpslow -s r -t 10 /var/lib/mysql/atguigu-slow.log\n\n得到访问次数最多的10个SQL\nmysqldumpslow -s c -t 10 /var/lib/mysql/atguigu-slow.log\n\n得到按照时间排序的前10条里面含有左连接的查询语句\nmysqldumpslow -s t -t 10 -g &quot;left join&quot;lar/lib/mysql/atguigu-slow.log\n\n另外建议在使用这些命令时结合|和more使用，否则有可能出现爆屏情况\nmysqldumpslow -s r -t 10 /ar/lib/mysql/atguigu-slow.log | more\n</code></pre>\n<h2 id=\"批量数据脚本\"><a href=\"#批量数据脚本\" class=\"headerlink\" title=\"批量数据脚本\"></a>批量数据脚本</h2><p>1.建表(dept,emp)</p>\n<p>2.设置参数log_bin_trust_function_creatorst</p>\n<pre><code class=\"sql\">-- 创建函数，假如报错:This function has none of DETERMINISTIC\n\n-- 由于开启过慢查询日志，因为我们开启了bin-log,我们就必须为我们的function指定一个参数。\nshow variables like &#39;log_bin_trust_function_creators&#39;;\nset global log_bin_trust_function_creators=1;\n-- 这样添加了参数以后，如果mysqld重启，上述参数又会消失，永久方法:\nI\nwindows下my.ini[mysqld]加上log_bin_trust_function_creators=1\nlinux下letc/my.cnf 下my.cnf[mysqld]加上log_bin_trust_function_creators=1\n</code></pre>\n<p>3.创建函数,保证每条数据都不同</p>\n<p>随机产生字符串</p>\n<p>随机产生部门编号</p>\n<pre><code class=\"sql\">DELIMITER $$\nCREATE FUNCTION rand_string(n lNT) RETURNS VARCHAR(255）\nBEGIN\n    DECLARE chars_str VARCHAR(100) DEFAULT &#39;abcdefghijlklmnoparstuvwxyABCDEFJHIJKLMNOPQRSTUWWXYZ&#39;;\n    DECLARE return_str VARCHAR(255) DEFAULT &#39;&#39; ;\n    DECLARE i INT DEFAULT 0;\n    WHILE i &lt; n DO\n        SET return_str =CONCAT(return_str,SUBSTRING(chars_str,FLOOR(1+RAND()*52),1);\n        SET i =i+ 1;\n    END WHILE;\n    RETURN return_str;\nEND\n$$\nDFLIMITER ;\n                               \ndelimiter $$\nCREATE FUNCTLON rand_num( )RETURNS INT(5)\nBEGIN\n    DECLARE i int default 0;\n    SET i = FLOOR(100+RAND()*10);\n    RETURN i;\nEND \ndelimiter $$\nDFLIMITER ;\n</code></pre>\n<p>4.创建存储过程</p>\n<pre><code class=\"sql\">创建往emp表中插入数据的存储过程\nDELIMITER $$\nCREATE PROCEDURE insert_emp(IN START INT(10),IN max_num INT(10))\nBEGIN\n    DECLARE i INT DEFAULT 0;\n    #set autocomnit = 0 把autocommit设置成0\n    SET autocommit =0;\n    REPEAT\n    SET i=i+ 1;\n    INSERT INTo emp(empno，ename , job ,mgr ,hiredate ,sal ,comm ,deptno ) values((SEAR+i) ,rand_string(6), &#39;sAESLsy&#39;,0001,now(),1000,0,10);\n    UNTIL i = max_num;\n    END REPEAT;\n    COMMIT;\nEND \n$$\nDFLIMITER ;\n\n创建往dept表中插入数据的存储过程\nDFLIMITER $$\nCREATE PROCEDURE insert_dept(IN START INT(10),IN max_num lNT(10))\nBEGIN\n    DECLARE i lNT DEFAULT 0;\n    SET autocommit = 0;\n    REPEAT\n    SETi= i+1;\n    INSERT INTO dept (deptno ,dname,loc ) VALUES((START+i) ,rand_string(10),rand_string(8);\n    UNTIL i = max_num;\n    END REPEAT;COMMIT;\nEND $$\nDFLIMITER ;\n</code></pre>\n<p>5.调用存储过程</p>\n<pre><code class=\"sql\">call insert_emp(10001,50000);\ncall inser_dept(100,10);\n</code></pre>\n<h2 id=\"Show-profile\"><a href=\"#Show-profile\" class=\"headerlink\" title=\"Show profile\"></a>Show profile</h2><p>是什么:是mysql提供可以用来分析当前会话中语句执行的资源消耗情况。可以用于SQL的调优的测量</p>\n<p>官网: <span class=\"exturl\" data-url=\"aHR0cDovL2Rldi5teXNxbC5jb20vZG9jL3JlZm1hbi81LjUvZW4vc2hvdy1wcm9maWxlLmh0bWw=\">http://dev.mysql.com/doc/refman/5.5/en/show-profile.html</span></p>\n<p>默认情况下，参数处于关闭状态，并保存最近15次的运行结果</p>\n<p>分析步骤</p>\n<p>1.是否支持，看看当前的mysql版本是否支持</p>\n<pre><code class=\"sql\">show variables like &#39;profiling&#39;;\n-- 默认是关闭，使用前需要开启\n</code></pre>\n<p>2.开启功能，默认是关闭，使用前需要开启</p>\n<pre><code class=\"sql\">set profiling=on;\nshow variables like &#39;profiling&#39;;\n</code></pre>\n<p>3.运行SQL</p>\n<pre><code class=\"sql\">select * from emp;\n\nselect * from emp e join dept d on e.deptno =d.deptno;\n\nselect * from emp group by id%10 limit 1500;\n\nselect * from emp group by id%20 order by 5;\n</code></pre>\n<p>4.查看结果，show profiles;</p>\n<pre><code class=\"sql\">show profiles;\n</code></pre>\n<img data-src=\"/2022/10/07/MySQL_Super/image-20220819180736190-1660960902143.png\" class=\"\">\n\n\n<p>5.诊断SQL， </p>\n<pre><code class=\"sql\">show profile cpu,block io for query 3;-- 最后数字是上一步前面的SQL的Id;\n</code></pre>\n<table>\n<thead>\n<tr>\n<th align=\"center\">常用参数</th>\n<th>注释</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">ALL</td>\n<td>显示所有的开销信息</td>\n</tr>\n<tr>\n<td align=\"center\">BLOCK IO</td>\n<td>显示块IO相关开销</td>\n</tr>\n<tr>\n<td align=\"center\">CONTEXT SWITCHES</td>\n<td>上下文切换相关开销</td>\n</tr>\n<tr>\n<td align=\"center\">CPU</td>\n<td>显示CPU相关开销信息</td>\n</tr>\n<tr>\n<td align=\"center\">IPC</td>\n<td>显示发送和接收相关开销信息</td>\n</tr>\n<tr>\n<td align=\"center\">MEMORY</td>\n<td>显示内存相关开销信息</td>\n</tr>\n<tr>\n<td align=\"center\">PAGE FAULTS</td>\n<td>显示页面错误相关开销信息|</td>\n</tr>\n<tr>\n<td align=\"center\">SOURCE</td>\n<td>显示和Source_function，Source_file，Source_line相关的开销信息</td>\n</tr>\n<tr>\n<td align=\"center\">SWAPS</td>\n<td>显示交换次数相关开销的信息</td>\n</tr>\n</tbody></table>\n<img data-src=\"/2022/10/07/MySQL_Super/image-20220819182050124-1660960902143.png\" class=\"\">\n\n\n<p>6.日常开发需要注意的结论</p>\n<ul>\n<li><p>converting HEAP to MyISAM     查询结果太大，内存都不够用了往磁盘上搬了。</p>\n</li>\n<li><p>Creating tmp table       创建临时表</p>\n<ul>\n<li>拷贝数据到临时表</li>\n<li>用完再删除</li>\n</ul>\n</li>\n<li><p>Copying to tmp table on disk      把内存中临时表复制到磁盘，危险!! !</p>\n</li>\n<li><p>locked    (死锁)</p>\n</li>\n</ul>\n<h2 id=\"全局查询日志\"><a href=\"#全局查询日志\" class=\"headerlink\" title=\"全局查询日志\"></a>全局查询日志</h2><p><font color=red><strong>永远不要在生产环境开启这个功能</strong>。</font></p>\n<p>配置启用</p>\n<pre><code class=\"sh\">#在mysql的my.cnf中，设置如下:\n#开启\ngeneral_log=1\n#记录日志文件的路径\ngeneral_log_file=/path/logfile\n#输出格式\nlog_output=FILE\n</code></pre>\n<p>编码启用</p>\n<pre><code class=\"sql\">-- 命令\nset global general_log=1;\nset global log_output=&#39;TABLE&#39;;\n\n-- 此后，你所编写的sql语句，将会记录到mysql库里的general_log表，可以用下面的命令查看\nselect * from mysql.general_lpg;\n</code></pre>\n<div name=MySQL的锁机制>\n\n\n<h1 id=\"MySQL锁机制\"><a href=\"#MySQL锁机制\" class=\"headerlink\" title=\"MySQL锁机制\"></a>MySQL锁机制</h1><p>概述：锁是计算机协调多个进程或线程并发访问某一资源的机制。在数据库中，除传统的计算资源〈如CPU、RAM、V&#x2F;O等）的争用以外，数据也是一种供许多用户共享的资源。如何保证数据并发访问的一致性、有效性是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。从这个角度来说，锁对数据库而言显得尤其重要，也更加复杂。[</p>\n<p>打个比方，我们到淘宝上买一件商品，商品只有一件库存，这个时候如果还有另一个人买，那么如何解决是你买到还是另一个人买到的问题?</p>\n<img data-src=\"/2022/10/07/MySQL_Super/image-20220819183900802-1660960902143.png\" class=\"\">\n\n\n<p>这里肯定要用到事务，我们先从库存表中取出物品数量，然后插入订单，付款后插入付款表信息，然后更新商品数量。在这个过程中，使用锁可以对有限的资源进行保护，解决隔离和并发的矛盾。</p>\n<h2 id=\"锁的分类\"><a href=\"#锁的分类\" class=\"headerlink\" title=\"锁的分类\"></a>锁的分类</h2><ul>\n<li><p>从对数据操作的粒度分</p>\n<ul>\n<li>表锁(偏读，解决幻读(一个事务中对数据添加、删除，并且多次查询，每次结果不都相同))</li>\n<li>行锁(偏写，解决重复读(一个事务中对一条数据多次修改，并且多次查询，每次结果不都相同))</li>\n</ul>\n</li>\n<li><p>从对数据操作的类型（读\\写)分</p>\n<ul>\n<li>&#x3D;&#x3D;读锁(共享锁)&#x3D;&#x3D;：针对同一份数据，多个读操作可以同时进行而不会互相影响。</li>\n<li>&#x3D;&#x3D;写锁(排它锁)&#x3D;&#x3D;：当前写操作没有完成前，它会阻断其他写锁和读锁。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"读锁-案例介绍\"><a href=\"#读锁-案例介绍\" class=\"headerlink\" title=\"读锁(案例介绍)\"></a>读锁(案例介绍)</h2><p>准备：</p>\n<pre><code class=\"sql\">create table mylock(\nid int not null primary key auto_increment,\nname varchar(20)\n)engine myisam;\n\ninsert into mylock(name) values(&#39;a&#39;);\ninsert into mylock(name) values(&#39;b&#39;);\ninsert into mylock(name) values(&#39;c&#39;);\ninsert into mylock(name) values(&#39;d&#39;);\ninsert into mylock(name) values(&#39;e&#39;);\nselect * from mylock;\n\nCREATE TABLE `book` ( \n    `bookid` int(10) unsigned NOT NULL AUTO_INCREMENT,\n    `card` int(10) unsigned NOT NULL,\n    PRIMARY KEY (`bookid`),\n    KEY `idx_card` (`card`)\n) ENGINE=InnoDB AUTO_INCREMENT=9 DEFAULT CHARSET=utf8;\ninsert into book(card) values(1);\ninsert into book(card) values(2);\ninsert into book(card) values(3);\ninsert into book(card) values(4);\ninsert into book(card) values(5);\n</code></pre>\n<pre><code class=\"sql\">-- 手动添加表锁\n-- 语法：lock table Table_1_Name  read/write,Table_2_name read/write,..;\nlock table mylock read ;\n\n-- 查看锁\nshow open tables;\n\n-- 释放锁\nunlock tables;\n    \nselect * from mylock;\t\n-- 读锁没有释放之前这个回话只能读取这个读锁表，其他回话可以查询或者更新未锁定的表\n-- 其他回话插入或者更新表的时候会进入阻塞状态，直至锁的释放\nupdate mylock set name = &#39;aa&#39; where id =1;\nselect * from book;\n</code></pre>\n<h2 id=\"写锁-案例介绍\"><a href=\"#写锁-案例介绍\" class=\"headerlink\" title=\"写锁(案例介绍)\"></a>写锁(案例介绍)</h2><p>Session 1(产生锁)</p>\n<pre><code class=\"sql\">lock table mylock write;\n\nselect * from mylock; --ok\n\nupdate mylock set name =&#39;aa&#39; where  id =1; -- ok\n\nselect * from book;\n/*\nERROR 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &#39;uplock tables&#39; at line 1\n*/\n\nunlock tables; \n</code></pre>\n<p>Session 2</p>\n<pre><code class=\"sql\"> select * from mylock; -- block 阻塞住了 ,直至锁的释放才看到了\n</code></pre>\n<h2 id=\"读写结论\"><a href=\"#读写结论\" class=\"headerlink\" title=\"读写结论\"></a>读写结论</h2><p>MyISAM在执行查询语句〈SELECT)前，会自动给涉及的所有表加读锁，在执行增删改操作前，会自动给涉及的表加写锁。</p>\n<p>MySQL的表级锁有两种模式:</p>\n<p>​\t表共享读锁(Table Read Lock)</p>\n<p>​\t表独享读锁(Table Write Lock)</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">lock_type</th>\n<th align=\"center\">是否共享</th>\n<th align=\"center\">读锁</th>\n<th align=\"center\">写锁</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">读锁</td>\n<td align=\"center\">是</td>\n<td align=\"center\">是</td>\n<td align=\"center\">否</td>\n</tr>\n<tr>\n<td align=\"center\">写锁</td>\n<td align=\"center\">是</td>\n<td align=\"center\">否</td>\n<td align=\"center\">否</td>\n</tr>\n</tbody></table>\n<p>&#x3D;&#x3D;结论:&#x3D;&#x3D;</p>\n<p>结合上表，所以对MyISAM表进行操作，会有以下情况:</p>\n<p>1、对MyISAM表的读操作〈加读锁)，不会阻塞其他进程对同一表的读请求，但会阻塞对同一表的写请求。只有当读锁释放后，才会执行其它进程的写操作。</p>\n<p>2、对MyISAM表的写操作（加写锁)，会阻塞其他进程对同一表的读和写操作，只有当写锁释放后，才会执行其它进程的读写操作。</p>\n<p><font color=red><strong>简而言之，就是读锁会阻塞写，但是不会堵塞读。而写锁则会把读和写都堵塞</strong>。</font></p>\n<h2 id=\"表锁-案例介绍\"><a href=\"#表锁-案例介绍\" class=\"headerlink\" title=\"表锁(案例介绍)\"></a>表锁(案例介绍)</h2><p>【如何分析表锁定】<br>可以通过检查table_locks_waited和table_locks_immedlate状态变量来分析系统上的表锁定:</p>\n<pre><code class=\"sql\">show status like &#39;table%&#39;;\n</code></pre>\n<img data-src=\"/2022/10/07/MySQL_Super/image-20220819205444832-1660960902143.png\" class=\"\">\n\n\n<p>这里有两个状态变量记录MySQL内部表级锁定的情况，两个变量说明如下:</p>\n<p><font color=blue>T<strong>able_locks_immediate:产生表级锁定的次数，表示可以立即获取锁的查询次数，每立即获取锁值加1</strong></font></p>\n<p><font color=blue><strong>Table_locks_waited:出现表级锁定争用而发生等待的次数(不能立即获取锁的次数，每等待一次锁值加1),</strong><br><strong>此值高则说明存在着较严重的表级锁争用情况;</strong></font></p>\n<p><font color=red><strong>此外，<u><em><strong>Myisam</strong></em></u>的读写锁调度是写优先，这也是<u><em><strong>myisam</strong></em></u>不适合做写为主表的引擎。因为写锁后，其他线程不能做任何操作，大量的更新会使查询很难得到锁，从而造成永远阻塞</strong></font></p>\n<h2 id=\"行锁-案例介绍\"><a href=\"#行锁-案例介绍\" class=\"headerlink\" title=\"行锁(案例介绍)\"></a>行锁(案例介绍)</h2><h3 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h3><blockquote>\n<p>​\t偏向InnoDB存储引擎，开销大，加锁慢;会出现死锁;锁定粒度最小，发生锁冲突的概率最低,并发度也最高。</p>\n<p>​\tInnoDB与MyISAM的最大不同有两点:</p>\n<p>​\t一、是支持事务（TRANSACTION);</p>\n<p>​\t二、是采用了行级锁</p>\n</blockquote>\n<h3 id=\"事务知识复习\"><a href=\"#事务知识复习\" class=\"headerlink\" title=\"事务知识复习\"></a>事务知识复习</h3><h4 id=\"四大特性\"><a href=\"#四大特性\" class=\"headerlink\" title=\"四大特性\"></a>四大特性</h4><p>事务是由一组SQL语句组成的逻辑处理单元，事务具有以下4个属性，通常简称为事务的ACID属性。</p>\n<ul>\n<li><p><font color=red>原子性（Atomicity)</font>﹔事务是一个原子操作单元，其对数据的修改，要么全都执行，要么全都不执行。</p>\n</li>\n<li><p><font color=red>一致性（Consistent)</font>:在事务开始和完成时，数据都必须保持一致状态。这意味着所有相关的数据规则都必须应用于事务的修改，以保持数据的完整性;事务结束时，所有的内部数据结构（如B树索引或双向链表）也都必须是正确的。</p>\n</li>\n<li><p><font color=red>隔离性（lsolation)</font>:数据库系统提供一定的隔离机制，保证事务在不受外部并发操作影响的“独立”环境执行。这意味着事务处理过程中的中间状态对外部是不可见的，反之亦然。</p>\n</li>\n<li><p><font color=red>持久性（Durable)</font>:事务完成之后，它对于数据的修改是永久性的，即使出现系统故障也能够保持。</p>\n</li>\n</ul>\n<h4 id=\"并发带来的问题\"><a href=\"#并发带来的问题\" class=\"headerlink\" title=\"并发带来的问题\"></a>并发带来的问题</h4><p>更新丢失(Lost Update)</p>\n<blockquote>\n<p>当两个或多个事务选择同一行，然后基于最初选定的值更新该行时，由于每个事务都不知道其他事务的存在，就会发生丢失更新问题――最后的更新覆盖了由其他事务所做的更新。<br>例如，两个程序员修改同一java文件。每程序员独立地更改其副本，然后保存更改后的副本，这样就覆盖了原始文档。最后保存其更改副本的编辑人员覆盖前一个程序员所做的更改。<br>如果在一个程序员完成并提交事务之前，另一个程序员不能访问同一文件，则可避免此问题。</p>\n</blockquote>\n<p>脏读(Dirty Reads)</p>\n<blockquote>\n<p>简单来说就是 读了未提交的，此时事务级别在最低，改善方法就是提高级别即可</p>\n</blockquote>\n<p>不可重复读(Non-Repeatable Reads)</p>\n<blockquote>\n<p>简单来说就是在一个事务中多次读取某些数据，数据的条数没有变，但是数据却变了。</p>\n<p>重在修改</p>\n</blockquote>\n<p>幻读(Phantom Reads)</p>\n<blockquote>\n<p>简单来说就是在一个事务中多次读取某些数据，数据的条数变了</p>\n<p>重在添加、删除</p>\n</blockquote>\n<h4 id=\"事务的隔离级别\"><a href=\"#事务的隔离级别\" class=\"headerlink\" title=\"事务的隔离级别\"></a>事务的隔离级别</h4><img data-src=\"/2022/10/07/MySQL_Super/image-20220819211429410-1660960902143.png\" class=\"\">\n\n\n\n\n<h4 id=\"面试题-1\"><a href=\"#面试题-1\" class=\"headerlink\" title=\"面试题\"></a>面试题</h4><p>不可重复读和幻读的区别？如何解决？</p>\n<blockquote>\n<p>​\t他们都是在一个事务中对某些数据进行多次读取，但是不可重复读的问题重在多次读取的数据不都一致；幻读重在多次读取确得到不一样数据量的数据</p>\n<p>解决办法：</p>\n<p>​\t重复读加行数</p>\n<p>​\t幻读加表锁</p>\n</blockquote>\n<h3 id=\"案例分析\"><a href=\"#案例分析\" class=\"headerlink\" title=\"案例分析\"></a>案例分析</h3><p>准备</p>\n<pre><code class=\"sql\">create table test_innodb_lock (\na int(11),\nb varchar(16)\n)engine=innodb;I\n\ninsert into test_innodb_lock values(1,&#39;b2&#39;);\ninsert into test_innodb_lock values(3,&#39;3&#39;);\ninsert into test_innodb_lock values(4,&#39;4000&#39;);\ninsert into test_innodb_lock values(5,&#39;5000&#39;);\ninsert into test_innodb_lock values(6,&#39;6000&#39;);\ninsert into test_innodb_lock values(7,&#39;7000&#39;);\ninsert into test_innodb_lock values(8,&#39;80O0&#39;);\ninsert into test_innodb_lock values(9,&#39;9000&#39;);\ninsert into test_innodb_lock values(10,&#39;b1&#39;);\n\ncreate index test_innodb_a_ind  on test_innodb_lock(a);\ncreate index test_innodb_b_ind  on test_innodb_lock(b);\n-- 打开两个会话 并且都关闭自动提交\nset autocommit=0;\n</code></pre>\n<h4 id=\"行锁演示\"><a href=\"#行锁演示\" class=\"headerlink\" title=\"行锁演示\"></a>行锁演示</h4><table  border=\"1px solid red;\" >\n    <tr >\n        <th>Session 1</th>\n        <th>Session 2</th>\n        <th>explain  </th>\n    </tr>\n    <tr>\n        <th style=\"text-align:center; \" colspan='3'>case 1</th>\n    </tr>\n    <tr>\n        <td>\n            <img data-src= \"https://gitee.com/zjj3366/zjj3366/raw/master/docs/imgs/DataBase_MysqlSuper/image-20220819233537212.png\"/><br/>\n            <p style=\"text-align:center; \">\n                关闭 Session 1 的自动提交\n            </p><br/>\n        </td>\n        <td>\n            <img data-src= \"https://gitee.com/zjj3366/zjj3366/raw/master/docs/imgs/DataBase_MysqlSuper/image-20220819230937872.png\"/><br/>\n            <p>\n                关闭 Session 2 的自动提交\n            </p>\n        </td>\n        <td>\n             <p style=\"text-align:center; \">\n                目的是:模拟高并发的情况下事务的处理情况，就好比一个SQL在修改但是没又被提交\n            </p><br/>\n            <p style=\"text-align:center; \">\n                在Innodb引擎作用下默认行锁，可以自动锁住我们当行数据保证数据的准确性\n            </p>\n        </td>\n    </tr>\n    <tr>\n      <th colspan=\"3\" style=\"text-align:center;\"  >case 2</th>\n    </tr>\n    <tr>\n        <td>\n            <img data-src= \"https://gitee.com/zjj3366/zjj3366/raw/master/docs/imgs/DataBase_MysqlSuper/image-20220819234521630.png\"/><br/>\n            <p style=\"text-align:center; \">\n                Session 1 修改a=4的数据，不提交\n            </p>\n        </td>\n        <td>\n            <img data-src= \"https://gitee.com/zjj3366/zjj3366/raw/master/docs/imgs/DataBase_MysqlSuper/image-20220819233807979.png \"/><br/>\n            <p style=\"text-align:center; \">\n                Session 2 无法查询到原有数据\n            </p>\n        </td>\n        <td>\n            <p>\n            </p>\n        </td>\n    </tr>\n    <tr>\n      <th colspan=\"3\"  style=\"text-align:center;\" >case 3</th>\n    </tr>\n    <tr>\n        <td>\n            <img data-src= \"https://gitee.com/zjj3366/zjj3366/raw/master/docs/imgs/DataBase_MysqlSuper/image-20220819234824459.png\"/><br/>\n            <p style=\"text-align:center; \">\n                Session 1 提交事务\n            </p>\n        </td>\n        <td>\n            <img data-src= \"https://gitee.com/zjj3366/zjj3366/raw/master/docs/imgs/DataBase_MysqlSuper/image-20220819234803742.png \"/><br/>\n            <p style=\"text-align:center; \">\n                Session 2 提交事务()\n            </p>\n        </td>\n        <td>\n            <p style=\"text-align:center; \">>\n                Session 2 这里也可以当做是清除之前数据库累计事务\n            </p>\n            <br/>\n            <p style=\"text-align:center; \">\n               如果不提交，我们的Session 2 还是原来的数据\n            </p>\n        </td>\n    </tr>\n    <tr>\n      <th colspan=\"3\" style=\"text-align:center;\" >case 4</th>\n    </tr>\n    <tr>\n        <td>\n            <img data-src= \"https://gitee.com/zjj3366/zjj3366/raw/master/docs/imgs/DataBase_MysqlSuper/image-20220819235205871.png \"/>\n            <br/>\n            <p style=\"text-align:center; \">\n                Session 1 修改a=4的数据，不提交\n            </p>\n        </td>\n        <td>\n            <img data-src= \"https://gitee.com/zjj3366/zjj3366/raw/master/docs/imgs/DataBase_MysqlSuper/image-20220819235132716.png\"/><br/>            \n            <p style=\"text-align:center; \">\n                Session 2 修改a=9的数据，不提交\n            </p>\n        </td>\n        <td>\n            <p style=\"text-align:center; \">\n                两个 Session 操作不同的数据，互补影响，充分的体现了行锁的作用\n            </p>\n        </td>\n    </tr>\n    <tr>\n      <th colspan=\"3\" style=\"text-align:center;\" >case 5</th>\n    </tr>\n    <tr>\n        <td>\n            <img data-src= \"https://gitee.com/zjj3366/zjj3366/raw/master/docs/imgs/DataBase_MysqlSuper/image-20220820093552303.png \"/>\n            <br/>\n            <p style=\"text-align:center; \">\n                Session 1 修改a=1的数据，不提交\n            </p>\n        </td>\n        <td>\n            <img data-src= \"https://gitee.com/zjj3366/zjj3366/raw/master/docs/imgs/DataBase_MysqlSuper/image-20220820093614653.png\"/><br/>            \n            <p style=\"text-align:center; \">\n                Session 2 修改a=1的数据，不提交\n            </p>\n        </td>\n        <td>\n            <p style=\"text-align:center; \">\n                两个 Session 操作相同的数据，互相影响\n            </p><br/>\n            <p style=\"text-align:center; \">\n                Session2 在 Session1 没有提交之前，直接处于阻塞状态\n            </p>\n        </td>\n    </tr>\n    <tr>\n      <th colspan=\"3\" style=\"text-align:center;\" >case 5</th>\n    </tr>\n    <tr>\n        <td>\n            <img data-src= \"https://gitee.com/zjj3366/zjj3366/raw/master/docs/imgs/DataBase_MysqlSuper/image-20220819235205871.png \"/>\n            <br/>\n            <p style=\"text-align:center; \">\n                Session 1 修改a=4的数据，不提交\n            </p>\n        </td>\n        <td>\n            <img data-src= \"https://gitee.com/zjj3366/zjj3366/raw/master/docs/imgs/DataBase_MysqlSuper/image-20220819235132716.png\"/><br/>            \n            <p style=\"text-align:center; \">\n                Session 2 修改a=9的数据，不提交\n            </p>\n        </td>\n        <td>\n            <p style=\"text-align:center; \">\n                两个 Session 操作不同的数据，互补影响，充分的体现了行锁的作用\n            </p>\n        </td>\n    </tr>\n</table>\n\n\n\n\n\n\n<h4 id=\"索引失效导致行锁变成表锁\"><a href=\"#索引失效导致行锁变成表锁\" class=\"headerlink\" title=\"索引失效导致行锁变成表锁\"></a>索引失效导致行锁变成表锁</h4><table  border=\"1px solid red;\" >\n    <tr >\n        <th>Session 1</th>\n        <th>Session 2</th>\n        <th>explain  </th>\n    </tr>\n    <tr>\n        <td>\n            <img data-src= \"https://gitee.com/zjj3366/zjj3366/raw/master/docs/imgs/DataBase_MysqlSuper/image-20220820000724418.png\"/><br/>\n        </td>\n        <td>\n            <img data-src= \"https://gitee.com/zjj3366/zjj3366/raw/master/docs/imgs/DataBase_MysqlSuper/image-20220820000816926.png\"/><br/>\n        </td>\n        <td>\n            <p style=\"text-align:center; \">        \n                我们在最开始准备阶段，就创建了关于a ,b 的索引(单索引)\n            </p><br/>\n            <p style=\"text-align:center; \">        \n                我们之前说过，在where上不要进行隐式转换，这样会导致索引失效\n            </p><br/>\n            <p style=\"text-align:center; \">        \n                从这个例子中我们左边进行了隐式操作，导致索引失效，第二个 Session\n            </p><br/>\n            <p style=\"text-align:center; \">        \n                直接进入到了阻塞状态，<a font=\"color:'red'\">表明了我们的索引失效让行锁变成了表锁</a>\n            </p>\n        </td>\n    </tr>\n    <tr>\n        <td>\n            <img data-src= \"https://gitee.com/zjj3366/zjj3366/raw/master/docs/imgs/DataBase_MysqlSuper/image-20220820000801075.png\"/><br/>\n        </td>\n        <td>\n            <img data-src= \"https://gitee.com/zjj3366/zjj3366/raw/master/docs/imgs/DataBase_MysqlSuper/image-20220820000837775.png\"/><br/>\n        </td>\n        <td>\n            <p style=\"text-align:center; \">        \n               上面的例子中直至Session 1 回话结束，这时候释放了锁\n            </p><br/>\n            <p style=\"text-align:center; \">        \n              我们的 Session 2 才接受到了锁，进入了表\n            </p><br/>\n            <p style=\"text-align:center; \">        \n               这个例子充分的表明了，我们在操作中一定要注意索引失效的问题\n            </p><br/>\n            <p style=\"text-align:center; \">        \n                他有可能会导致我们效率更低\n            </p>\n        </td>\n    </tr>\n</table>\n\n\n\n\n\n<h4 id=\"间隙锁的危害\"><a href=\"#间隙锁的危害\" class=\"headerlink\" title=\"间隙锁的危害\"></a>间隙锁的危害</h4><p>【概念】</p>\n<p>​\t当我们用范围条件而不是相等条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据记录的索引项加锁;对于键值在条件范围内但并木存在的记录，叫做“间隙（GAP)”，</p>\n<p>InnoDB也会对这个“间隙”加锁，这种锁机制就是所谓的间隙锁（Next-Key锁）。</p>\n<p>【危害】<br>因为Query执行过程中通过过范围查找的话，他会锁定整个范围内所有的索引键值，即使这个键值并不存在间隙锁有一个比较致命的弱点，就是当锁定一个范围键值之后，即使某些不存在的键值也会被无辜的锁定，<br>而造成在锁定的时候无<br>法插入锁定键值范围内的任何数据。在某些场景下这可能会对性能造成很大的危害</p>\n<pre><code class=\"sql\">-- session 1\nupdate t1 set b=&#39;12312&#39; where a&gt;1 and a&lt;8;\n\n-- session 2\ninsert into t1 values(5,&#39;asda&#39;);\n</code></pre>\n<img data-src=\"/2022/10/07/MySQL_Super/image-20220820001444127-1660960902143.png\" class=\"\">\n\n\n<p>明显的看到在Session 1执行结束之后，执行Session 2 即使他们操作的不是同一行也会因为间隙锁的缘故锁定这一行，即使不存在也是如此，直到commit之后 Session 2才反应</p>\n<h4 id=\"如何锁定一行\"><a href=\"#如何锁定一行\" class=\"headerlink\" title=\"如何锁定一行\"></a>如何锁定一行</h4><pre><code class=\"sql\">/*\nselect xoo.... for update锁定某一行后，其它的操作会械阻塞，直到锁定行的会话提交commit\n*/\nbegin;\nselect * from test_innodb_lock where a = 8 for update;\ncommit;\n</code></pre>\n<h3 id=\"案例结论\"><a href=\"#案例结论\" class=\"headerlink\" title=\"案例结论\"></a>案例结论</h3><p>​\tInnodb存储引擎由于实现了行级锁定，虽然在锁定机制的实现方面所带来的性能损耗可能比表级锁定会要更高一些，但是在整体并发处理能力方面要远远优于MyISAM的表级锁定的。当系统并发量较高的时候，Innodb的整体性能和MyIlSAM相比就会有比较明显的优势了。</p>\n<p>​\t但是，Innodb的行级锁定同样也有其脆弱的一面，当我们使用不当的时候，可能会让Innodb的整体性能表现不仅不能比MyISAM高，甚至可能会更差。(索引失效行锁变表锁)</p>\n<h3 id=\"如何分析行锁定\"><a href=\"#如何分析行锁定\" class=\"headerlink\" title=\"如何分析行锁定\"></a>如何分析行锁定</h3><p>通过检查InnoDB_row_lock状态变量来分析系统上的行锁的争夺情况</p>\n<pre><code class=\"sql\">show status like &#39;innodb_row_lock%&#39;;\n</code></pre>\n<img data-src=\"/2022/10/07/MySQL_Super/image-20220820002244586-1660960902143.png\" class=\"\">\n\n\n<p>对各个状态量的说明如下:</p>\n<p>Innodb_row_lock_current_waits：当前正在等待锁定的数量;</p>\n<p>Innodb_row_lock_time：队系统启动到现在锁定总时间长度;</p>\n<p>Innodb_row_lock_time_avg：每次等待所花平均时间;</p>\n<p>Innodb_row_lock_time_max：从系统启动到现在等待最常的一次所花的时间;</p>\n<p>Innodb_row_lock_waits：系统启动后到现在总共等待的次数;</p>\n<p>对于这5个状态变量，比较重要的主要是</p>\n<p><font color=red>Innodb_row_lock_time_avg（等待平均时长）</font>，</p>\n<p><font color=red>Innodb_row_lock_waits（等待总次数)</font> ，</p>\n<p><font color=red>lnnodb_row_lock_time（等待总时长）这三项</font>。</p>\n<p>尤其是当等踌次数很高，而且每次等待时长也不小的时候，我们就需要分析系统中为什么会有如此多的等待<br>然后根据分析结果着手指定优化计划。</p>\n<h3 id=\"优化意见\"><a href=\"#优化意见\" class=\"headerlink\" title=\"优化意见\"></a>优化意见</h3><ol>\n<li><p>尽可能让所有数据检索都通过索引来完成，避免无索引行锁升级为表锁。</p>\n</li>\n<li><p>合理设计索引，尽量缩小锁的范围</p>\n</li>\n<li><p>尽可能较少检索条件，避免间隙锁</p>\n</li>\n<li><p>尽量控制事务大小，减少锁定资源量和时间长度</p>\n</li>\n<li><p>尽可能低级别事务隔离</p>\n</li>\n</ol>\n<h2 id=\"页锁-案例介绍\"><a href=\"#页锁-案例介绍\" class=\"headerlink\" title=\"页锁(案例介绍)\"></a>页锁(案例介绍)</h2><p>开销和加锁时间界于表锁和行锁之间;会出现死锁;锁定粒度界于表锁和行锁之间，并发度一般。</p>\n<h1 id=\"附录\"><a href=\"#附录\" class=\"headerlink\" title=\"附录\"></a>附录</h1><div name=select_type>\n    <a style=\"color:red; \" >Select_Type</a>\n</div>\n\n<table>\n<thead>\n<tr>\n<th align=\"center\">select_type价值</th>\n<th align=\"center\">JSON名称</th>\n<th align=\"center\">意义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">SIMPLE</td>\n<td align=\"center\">没有</td>\n<td align=\"center\">简单选择（不使用UNION或子查询）</td>\n</tr>\n<tr>\n<td align=\"center\">PRIMARY</td>\n<td align=\"center\">没有</td>\n<td align=\"center\">多层子查询中最外层选择</td>\n</tr>\n<tr>\n<td align=\"center\">UNION</td>\n<td align=\"center\">没有</td>\n<td align=\"center\">联盟中的第二个或稍后的SELECT语句<br/>若第二个SELECT出现在UNION之后，则被标记为UNION;<br/>若UNION包含在FROM子句的子查询中,外层SELECT将被标记为:DERIVED</td>\n</tr>\n<tr>\n<td align=\"center\">DEPENDENT UNION</td>\n<td align=\"center\">dependent(true)</td>\n<td align=\"center\">UNION中的第二个或更高版本的SELECT语句，依赖于外部查询</td>\n</tr>\n<tr>\n<td align=\"center\">UNION RESULT</td>\n<td align=\"center\">union_result</td>\n<td align=\"center\">从UNION表获取结果的SELECT</td>\n</tr>\n<tr>\n<td align=\"center\">SUBQUERY</td>\n<td align=\"center\">没有</td>\n<td align=\"center\">子查询中的第一个SELECT<br/>在SELECT 或 WHERE列表中包含了子查询</td>\n</tr>\n<tr>\n<td align=\"center\">DEPENDENT SUBQUERY</td>\n<td align=\"center\">dependent(true)</td>\n<td align=\"center\">子查询中的第一个SELECT,依赖于外部查询</td>\n</tr>\n<tr>\n<td align=\"center\">DERIVED</td>\n<td align=\"center\">没有</td>\n<td align=\"center\">派生表<br/>在FROM列表中包含的子查询被标记为DERIVED(衍生)MySQL会递归执行这些子查询，把结果放在临时表里。</td>\n</tr>\n<tr>\n<td align=\"center\">MATERIALIZED</td>\n<td align=\"center\">material!zed_from_subquery</td>\n<td align=\"center\">实例化子查询</td>\n</tr>\n<tr>\n<td align=\"center\">UNCACHEABLE SU3QUERY</td>\n<td align=\"center\">cacheable(false)</td>\n<td align=\"center\">无法缓存其结果并且必须为外部查询的每一行重新计算其结果的子查询</td>\n</tr>\n<tr>\n<td align=\"center\">UNCACHEABLE UNION</td>\n<td align=\"center\">cacheable(false)</td>\n<td align=\"center\">在属于不可缓存子查询的UNION中的第二个或更高版本选择（请参见UNCACHEABLE SUBQUERY）</td>\n</tr>\n</tbody></table>\n",
            "tags": [
                "MySQL",
                "数据库"
            ]
        },
        {
            "id": "http://example.com/2022/10/07/Redis/",
            "url": "http://example.com/2022/10/07/Redis/",
            "title": "Redis基础",
            "date_published": "2022-10-06T16:00:00.000Z",
            "content_html": "<h1 id=\"Redis\"><a href=\"#Redis\" class=\"headerlink\" title=\"Redis\"></a>Redis</h1><h3 id=\"一-Redis简介\"><a href=\"#一-Redis简介\" class=\"headerlink\" title=\"一.Redis简介\"></a>一.Redis简介</h3><h4 id=\"1-NoSQL简介\"><a href=\"#1-NoSQL简介\" class=\"headerlink\" title=\"1.NoSQL简介\"></a>1.NoSQL简介</h4><p>​\t目前市场主流数据存储都是使用关系型数据库。每次操作关系型数据库时都是I&#x2F;O操作，I&#x2F;O操作是主要影响程序执行性能原因之一，连接数据库关闭数据库都是消耗性能的过程。尽量减少对数据库的操作，能够明显的提升程序运行效率。</p>\n<p>​\t针对上面的问题，市场上就出现了各种NoSQL(Not Only SQL,不仅仅可以使用关系型数据库)数据库，它们的宣传口号：不是什么样的场景都必须使用关系型数据库，一些特定的场景使用NoSQL数据库更好。</p>\n<p>常见NoSQL数据库：</p>\n<p>​\tmemcached ：键值对，内存型数据库，所有数据都在内存中。</p>\n<p>​\tRedis:和Memcached类似，还具备持久化能力。</p>\n<p>​\tHBase：以列作为存储。</p>\n<p>​\tMongoDB：以Document做存储。</p>\n<h4 id=\"2-Redis简介\"><a href=\"#2-Redis简介\" class=\"headerlink\" title=\"2.Redis简介\"></a>2.<strong>Redis简介</strong></h4><p>​\tRedis是以Key-Value形式进行存储的NoSQL数据库。</p>\n<p>​\tRedis是使用C语言进行编写的。</p>\n<p>​\t平时操作的数据都在内存中，效率特高，读的效率110000&#x2F;s，写81000&#x2F;s，所以多把Redis当做缓存工具使用。</p>\n<p>​\tRedis以solt（槽）作为数据存储单元，每个槽中可以存储N多个键值对。Redis中固定具有16384。理论上可以实现一个槽是一个Redis。每个向Redis存储数据的key都会进行crc16算法得出一个值后对16384取余就是这个key存放的solt位置。</p>\n<p>​\t同时通过Redis Sentinel提供高可用，通过Redis Cluster提供自动分区。</p>\n<h3 id=\"二-Redis单机版安装\"><a href=\"#二-Redis单机版安装\" class=\"headerlink\" title=\"二. Redis单机版安装\"></a>二. Redis单机版安装</h3><p>​\t1.安装依赖C语言依赖</p>\n<p>​\tredis使用C语言编写，所以需要安装C语言库</p>\n<pre><code># yum install -y gcc-c++ automake autoconf libtool make tcl \n</code></pre>\n<p>​\t</p>\n<p>​\t2.上传并解压</p>\n<p>​\t把redis-5.0.5.tar.gz上传到&#x2F;usr&#x2F;local&#x2F;tmp中</p>\n<p>​\t解压文件</p>\n<pre><code># cd /usr/local/tmp\n\n# tar zxf redis-5.0.5.tar.gz\n</code></pre>\n<p>​\t3.编译并安装</p>\n<p>​\t进入解压文件夹</p>\n<pre><code># cd /usr/local/tmp/redis-5.0.5/\n</code></pre>\n<p>​\t编译</p>\n<pre><code># make\n</code></pre>\n<p>​\t安装\t</p>\n<pre><code># make install PREFIX=/usr/local/redis\n</code></pre>\n<p>​\t4.开启守护进程</p>\n<p>​\t复制cd &#x2F;usr&#x2F;local&#x2F;tmp&#x2F;redis-5.0.5&#x2F;中redis.conf配置文件\t</p>\n<pre><code># cp redis.conf /usr/local/redis/bin/\n</code></pre>\n<p>​\t修改配置文件\t</p>\n<pre><code># cd /usr/local/redis/bin/\n\n# vim redis.conf\n</code></pre>\n<p>​\t把daemonize的值由no修改为yes</p>\n<img data-src=\"/2022/10/07/Redis/Redis-01.jpg\" class=\"\">\n\n<p>​\t5.修改外部访问</p>\n<p>​\t在redis5中需要修改配置文件redis.conf允许外部访问。需要修改两处。</p>\n<p>​\t注释掉下面</p>\n<p>​\tbind 127.0.0.1</p>\n<pre><code>#bind 127.0.0.1\n</code></pre>\n<p>​\tprotected-mode yes 改成 no</p>\n<img data-src=\"/2022/10/07/Redis/Redis-02.jpg\" class=\"\">\n\n<p>​\t6.启动并测试</p>\n<p>​\t启动redis</p>\n<pre><code class=\"shell\">./redis-server redis.conf\n</code></pre>\n<p>​\t重启redis</p>\n<pre><code>./redis-cli shutdown\n./redis-server redis.conf\n</code></pre>\n<p>​\t启动客户端工具</p>\n<p>​\t在redis5中客户端工具对命令会有提供功能。</p>\n<pre><code class=\"shell\">./redis-cli \n</code></pre>\n<h3 id=\"二-、docker安装Redis\"><a href=\"#二-、docker安装Redis\" class=\"headerlink\" title=\"二.、docker安装Redis\"></a>二.、docker安装Redis</h3><p>1、拉取镜像文件</p>\n<pre><code class=\"shell\">docker pull redis[:(版本号)]\n</code></pre>\n<p>2、去gitee库中下载redis配置文件（docker不自带配置文件）【也可不进行此步骤】</p>\n<p><strong>建议看完，先别操作，再看三，看完三之后再决定如何操作</strong></p>\n<p>然后按照文章内容进行，忽略下载。</p>\n<p>文章地址： <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuamI1MS5uZXQvYXJ0aWNsZS8yMDMyNzQuaHRt\">https://www.jb51.net/article/203274.htm</span> </p>\n<p>、</p>\n<p><img data-src=\"C:\\Users\\Lenovo\\AppData\\Roaming\\Typora\\typora-user-images\\1645177895314.png\" alt=\"1645177895314\"></p>\n<p>3、创建一个redis 服务容器 </p>\n<p><strong>第二步进行了的</strong></p>\n<pre><code class=\"shell\">docker run -p 6379:6379 --name myredis -v /usr/local/docker/redis.conf:/etc/redis/redis.conf -v /usr/local/docker/data:/data -d redis redis-server /etc/redis/redis.conf --appendonly yes\n</code></pre>\n<p><strong>第二步没有进行的</strong></p>\n<pre><code class=\"shell\">docker run -p 6379:6379 --name myredis -v /root/myredis/data:/data -v /root/myredis/conf/redis.conf:/usr/local/etc/redis/redis.conf -d redis redis-server /usr/local/etc/redis/redis.conf --appendonly yes\n</code></pre>\n<p><strong>区别：</strong></p>\n<p>​\t其实也没有什么区别，只是映射的文件不同，也可以将第二步的文件直接创建到第二种创建服务容器的配置文件地址中去，这样也可使用第二个创建方式。</p>\n<p><img data-src=\"C:\\Users\\Lenovo\\AppData\\Roaming\\Typora\\typora-user-images\\1645177877202.png\" alt=\"1645177877202\"></p>\n<p><img data-src=\"C:\\Users\\Lenovo\\AppData\\Roaming\\Typora\\typora-user-images\\1645177918077.png\" alt=\"1645177918077\"></p>\n<h3 id=\"三-Redis常用的五大类型\"><a href=\"#三-Redis常用的五大类型\" class=\"headerlink\" title=\"三.Redis常用的五大类型\"></a>三.Redis常用的五大类型</h3><p>​\t Redis不仅仅支持简单的k&#x2F;v类型的数据，同时还提供list，set，zset，hash等数据结构的存储，它还支持数据的备份，即master-slave模式的数据备份，同样Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用。</p>\n<p>​        Redis支持的五大数据类型包括String（字符串  用法： 键  值），Hash（哈希 类似Java中的 map  用法： 键  键值对），List（列表  用法：键 集合 不可以重复），Set（集合 用法：键 集合 可以重复），Zset（sorted set 有序集合    用法： 键  值 值）</p>\n<h4 id=\"String（字符串）\"><a href=\"#String（字符串）\" class=\"headerlink\" title=\"String（字符串）\"></a>String（字符串）</h4><p>​\tstring 是 redis 最基本的类型，你可以理解成与 Memcached 一模一样的类型，一个 key 对应一个 value。string 类型是二进制安全的。意思是 redis 的 string 可以包含任何数据。比如jpg图片或者序列化的对象。string 类型是 Redis 最基本的数据类型，string 类型的值最大能存储 512MB。</p>\n<p>应用场景：  </p>\n<p>​\tString是最常用的一种数据类型，普通的key&#x2F;value存储都可以归为此类，value其实不仅是String，  </p>\n<p>也可以是数字：比如想知道什么时候封锁一个IP地址(访问超过几次)。</p>\n<h4 id=\"Hash（哈希）\"><a href=\"#Hash（哈希）\" class=\"headerlink\" title=\"Hash（哈希）\"></a>Hash（哈希）</h4><p>​\tRedis hash 是一个键值(key&#x3D;&gt;value)对集合。</p>\n<p>​\tRedis hash 是一个 string 类型的 field 和 value 的映射表，hash 特别适合用于存储对象。</p>\n<p>​\t使用场景：存储、读取、修改用户属性</p>\n<p>​\t我们简单举个实例来描述下Hash的应用场景，比如我们要存储一个用户信息对象数据，包含以下信息：    用户ID，为查找的key，  </p>\n<p>​    \t存储的value用户对象包含姓名name，年龄age，生日birthday 等信息，  如果用普通的key&#x2F;value结构来存储，主要有以下2种存储方式：  </p>\n<p>​    \t第一种方式将用户ID作为查找key,把其他信息封装成一个对象以序列化的方式存储，  </p>\n<p>​           如：set u001 “李三,18,20010101”  </p>\n<p>​     \t这种方式的缺点是，增加了序列化&#x2F;反序列化的开销，并且在需要修改其中一项信息时，需要把整个对象取回，并且修改操作需要对并发进行保护，引入CAS等复杂问题。  </p>\n<p>​     \t第二种方法是这个用户信息对象有多少成员就存成多少个key-value对儿，用用户ID+对应属性的名称作为唯一标识来取得对应属性的值，  </p>\n<p>​       \t如：mset user:001:name “李三 “user:001:age18 user:001:birthday “20010101”  虽然省去了序列化开销和并发问题，但是用户ID为重复存储，如果存在大量这样的数据，内存浪费还是非常可观的。  </p>\n<p>​    \t那么Redis提供的Hash很好的解决了这个问题。</p>\n<h4 id=\"List（列表）\"><a href=\"#List（列表）\" class=\"headerlink\" title=\"List（列表）\"></a>List（列表）</h4><p>​\tRedis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）。</p>\n<p>应用场景：  </p>\n<pre><code>    Redis list的应用场景非常多，也是Redis最重要的数据结构之一。  \n</code></pre>\n<p>​    \t我们可以轻松地实现最新消息排行等功能。  </p>\n<pre><code>   Lists的另一个应用就是消息队列，可以利用Lists的PUSH操作，将任务存在Lists中，然后工作线程再用POP操作将任务取出进行执行。  \n</code></pre>\n<h4 id=\"Set（集合）\"><a href=\"#Set（集合）\" class=\"headerlink\" title=\"Set（集合）\"></a>Set（集合）</h4><p>​\tRedis的Set是string类型的无序集合。</p>\n<p>​\t使用场景：1.共同好友、二度好友 </p>\n<p>​\t\t\t   2. 利用唯一性，可以统计访问网站的所有独立 IP </p>\n<pre><code>  Redis set对外提供的功能与list类似是一个列表的功能，特殊之处在于set是可以自动排重的，当你需要存储一个列表数据，又不希望出现重复数据时，set是一个很好的选择，并且set提供了判断某个成员是否在一个set集合内的重要接口，这个也是list所不能提供的。  \n \n  比如在微博应用中，每个人的好友存在一个集合（set）中，这样求两个人的共同好友的操作，可能就只需要用求交集命令即可。  \n</code></pre>\n<p>​    \tRedis还为集合提供了求交集、并集、差集等操作，可以非常方便的实  </p>\n<pre><code>  实现方式：  \n</code></pre>\n<p>​    \tset 的内部实现是一个 value永远为null的HashMap，实际就是通过计算hash的方式来快速排重的，这也是set能提供判断一个成员是否在集合内的原因。 </p>\n<h4 id=\"zset-sorted-set：有序集合\"><a href=\"#zset-sorted-set：有序集合\" class=\"headerlink\" title=\"zset(sorted set：有序集合)\"></a>zset(sorted set：有序集合)</h4><pre><code> Redis zset 和 set 一样也是string类型元素的集合,且不允许重复的成员。不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。zset的成员是唯一的,但分数(score)却可以重复。\n</code></pre>\n<p>使用场景：1.带有权重的元素，比如一个游戏的用户得分排行榜 </p>\n<p>​\t\t   2.比较复杂的数据结构，一般用到的场景不算太多</p>\n<h3 id=\"四-Redis常用命令\"><a href=\"#四-Redis常用命令\" class=\"headerlink\" title=\"四. Redis常用命令\"></a>四. Redis常用命令</h3><p>Redis命令相关手册有很多，下面为其中比较好用的两个</p>\n<p>  1.<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cucmVkaXMubmV0LmNuL29yZGVyLw==\">https://www.redis.net.cn/order/</span></p>\n<p>  2.<span class=\"exturl\" data-url=\"aHR0cDovL2RvYy5yZWRpc2ZhbnMuY29tL3RleHQtaW4=\">http://doc.redisfans.com/text-in</span></p>\n<h4 id=\"1-Key操作\"><a href=\"#1-Key操作\" class=\"headerlink\" title=\"1. Key操作\"></a>1. Key操作</h4><h5 id=\"1-1-exists\"><a href=\"#1-1-exists\" class=\"headerlink\" title=\"1.1  exists\"></a>1.1  exists</h5><p>​\t判断key是否存在。</p>\n<p>​\t语法：exists key名称</p>\n<p>​\t返回值：存在返回数字，不存在返回0</p>\n<h5 id=\"1-2-expire\"><a href=\"#1-2-expire\" class=\"headerlink\" title=\"1.2 expire\"></a>1.2 expire</h5><p>​\t设置key的过期时间，单位秒</p>\n<p>​\t语法：expire key 秒数</p>\n<p>​\t返回值：成功返回1，失败返回0</p>\n<h5 id=\"1-3-ttl\"><a href=\"#1-3-ttl\" class=\"headerlink\" title=\"1.3 ttl\"></a>1.3 ttl</h5><p>​\t查看key的剩余过期时间</p>\n<p>​\t语法：ttl key</p>\n<p>​\t返回值：返回剩余时间，如果不过期返回-1</p>\n<h5 id=\"1-4-del\"><a href=\"#1-4-del\" class=\"headerlink\" title=\"1.4 del\"></a>1.4 del</h5><p>​\t根据key删除键值对。</p>\n<p>​\t语法：del key</p>\n<p>​\t返回值：被删除key的数量</p>\n<h4 id=\"2-字符串值-String\"><a href=\"#2-字符串值-String\" class=\"headerlink\" title=\"2. 字符串值(String)\"></a>2. <strong>字符串值(String)</strong></h4><h5 id=\"2-1-set\"><a href=\"#2-1-set\" class=\"headerlink\" title=\"2.1 set\"></a>2.1 <strong>set</strong></h5><p>​\t设置指定key的值</p>\n<p>​\t语法：set key value</p>\n<p>​\t返回值：成功OK</p>\n<h5 id=\"2-2-get\"><a href=\"#2-2-get\" class=\"headerlink\" title=\"2.2 get\"></a>2.2 <strong>get</strong></h5><p>​\t获取指定key的值</p>\n<p>​\t语法：get key</p>\n<p>​\t返回值：key的值。不存在返回nil</p>\n<h5 id=\"2-3-setnx\"><a href=\"#2-3-setnx\" class=\"headerlink\" title=\"2.3 setnx\"></a>2.3 <strong>setnx</strong></h5><p>​\t当且仅当key不存在时才新增。</p>\n<p>​\t语法：setnx key value</p>\n<p>​\t返回值：不存在时返回1，存在返回0</p>\n<h5 id=\"2-4-setex\"><a href=\"#2-4-setex\" class=\"headerlink\" title=\"2.4 setex\"></a>2.4 <strong>setex</strong></h5><p>​\t设置key的存活时间，无论是否存在指定key都能新增，如果存在key覆盖旧值。同时必须指定过期时间。</p>\n<p>​\t语法：setex key seconds value</p>\n<p>​\t返回值：OK</p>\n<h4 id=\"3-哈希表-Hash\"><a href=\"#3-哈希表-Hash\" class=\"headerlink\" title=\"3.哈希表(Hash)\"></a>3.<strong>哈希表(Hash)</strong></h4><p>​\tHash类型的值中包含多组field value。</p>\n<img data-src=\"/2022/10/07/Redis/Redis-03.jpg\" class=\"\">\n\n<h5 id=\"3-1-hset\"><a href=\"#3-1-hset\" class=\"headerlink\" title=\"3.1 hset\"></a>3.1 <strong>hset</strong></h5><p>​\t给key中field设置值。</p>\n<p>​\t语法：hset key field value</p>\n<p>​\t返回值：成功1，失败0</p>\n<h5 id=\"3-2-hget\"><a href=\"#3-2-hget\" class=\"headerlink\" title=\"3.2 hget\"></a>3.2 <strong>hget</strong></h5><p>​\t获取key中某个field的值</p>\n<p>​\t语法：hget key field </p>\n<p>​\t返回值：返回field的内容</p>\n<h5 id=\"3-3-hmset\"><a href=\"#3-3-hmset\" class=\"headerlink\" title=\"3.3 hmset\"></a>3.3 <strong>hmset</strong></h5><p>​\t给key中多个filed设置值</p>\n<p>​\t语法：hmset key field value field value</p>\n<p>​\t返回值：成功OK</p>\n<h5 id=\"3-4-hmget\"><a href=\"#3-4-hmget\" class=\"headerlink\" title=\"3.4 hmget\"></a>3.4 <strong>hmget</strong></h5><p>​\t一次获取key中多个field的值</p>\n<p>​\t语法：hmget key field field</p>\n<p>​\t返回值：value列表</p>\n<h5 id=\"3-5-hvals\"><a href=\"#3-5-hvals\" class=\"headerlink\" title=\"3.5 hvals\"></a>3.5 <strong>hvals</strong></h5><p>​\t获取key中所有field的值</p>\n<p>​\t语法：hvals key</p>\n<p>​\t返回值：value列表</p>\n<h5 id=\"3-6-hgetall\"><a href=\"#3-6-hgetall\" class=\"headerlink\" title=\"3.6 hgetall\"></a>3.6 <strong>hgetall</strong></h5><p>​\t获取所有field和value</p>\n<p>​\t语法：hgetall key</p>\n<p>​\t返回值：field和value交替显示列表</p>\n<h5 id=\"3-7-hdel\"><a href=\"#3-7-hdel\" class=\"headerlink\" title=\"3.7 hdel\"></a>3.7 <strong>hdel</strong></h5><p>​\t删除key中任意个field</p>\n<p>​\t语法：hdel key field field</p>\n<p>​\t返回值：成功删除field的数量</p>\n<h4 id=\"4-列表（List）\"><a href=\"#4-列表（List）\" class=\"headerlink\" title=\"4. 列表（List）\"></a>4. <strong>列表（List）</strong></h4><h5 id=\"4-1-Rpush\"><a href=\"#4-1-Rpush\" class=\"headerlink\" title=\"4.1 Rpush\"></a>4.1 <strong>Rpush</strong></h5><p>​\t向列表末尾中插入一个或多个值</p>\n<p>​\t语法；rpush key value value</p>\n<p>​\t返回值：列表长度</p>\n<h5 id=\"4-2-lrange\"><a href=\"#4-2-lrange\" class=\"headerlink\" title=\"4.2 lrange\"></a>4.2 <strong>lrange</strong></h5><p>​\t返回列表中指定区间内的值。可以使用-1代表列表末尾</p>\n<p>​\t语法：lrange list 0 -1</p>\n<p>​\t返回值：查询到的值</p>\n<h5 id=\"4-3-lpush\"><a href=\"#4-3-lpush\" class=\"headerlink\" title=\"4.3 lpush\"></a>4.3 <strong>lpush</strong></h5><p>​\t将一个或多个值插入到列表前面</p>\n<p>​\t语法：lpush key value value</p>\n<p>​\t返回值：列表长度</p>\n<h5 id=\"4-4-llen\"><a href=\"#4-4-llen\" class=\"headerlink\" title=\"4.4 llen\"></a>4.4 <strong>llen</strong></h5><p>​\t获取列表长度</p>\n<p>​\t语法：llen key</p>\n<p>​\t返回值：列表长度</p>\n<h5 id=\"4-5-lrem\"><a href=\"#4-5-lrem\" class=\"headerlink\" title=\"4.5 lrem\"></a>4.5 <strong>lrem</strong></h5><p>​\t删除列表中元素。count为正数表示从左往右删除的数量。负数从右往左删除的数量。</p>\n<p>​\t语法：lrem key count value</p>\n<p>​\t返回值：删除数量。</p>\n<h4 id=\"5-集合-Set\"><a href=\"#5-集合-Set\" class=\"headerlink\" title=\"5 集合(Set)\"></a>5 <strong>集合(Set)</strong></h4><p>​\tset和java中集合一样。</p>\n<h5 id=\"5-1-sadd\"><a href=\"#5-1-sadd\" class=\"headerlink\" title=\"5.1 sadd\"></a>5.1 <strong>sadd</strong></h5><p>​\t向集合中添加内容。不允许重复。</p>\n<p>​\t语法：sadd key value value value</p>\n<p>​\t返回值：集合长度</p>\n<h5 id=\"5-2-scard\"><a href=\"#5-2-scard\" class=\"headerlink\" title=\"5.2 scard\"></a>5.2 <strong>scard</strong></h5><p>​\t返回集合元素数量</p>\n<p>​\t语法：scard key</p>\n<p>​\t返回值：集合长度</p>\n<h5 id=\"5-3-smembers\"><a href=\"#5-3-smembers\" class=\"headerlink\" title=\"5.3 **smembers **\"></a>5.3 **smembers **</h5><p>​\t查看集合中元素内容</p>\n<p>​\t语法：smembers key</p>\n<p>​\t返回值：集合中元素</p>\n<h4 id=\"6-有序集合（Sorted-Set）\"><a href=\"#6-有序集合（Sorted-Set）\" class=\"headerlink\" title=\"6 .有序集合（Sorted Set）\"></a>6 .<strong>有序集合（Sorted Set）</strong></h4><p>​\t有序集合中每个value都有一个分数（score），根据分数进行排序。</p>\n<h5 id=\"6-1-zadd\"><a href=\"#6-1-zadd\" class=\"headerlink\" title=\"6.1 zadd\"></a>6.1 <strong>zadd</strong></h5><p>​\t向有序集合中添加数据</p>\n<p>​\t语法：zadd key score value score value</p>\n<p>​\t返回值：长度</p>\n<p><img data-src=\"C:\\Users\\Lenovo\\AppData\\Roaming\\Typora\\typora-user-images\\1645195960858.png\" alt=\"1645195960858\"></p>\n<h5 id=\"6-2-zrange\"><a href=\"#6-2-zrange\" class=\"headerlink\" title=\"6.2 zrange\"></a>6.2 <strong>zrange</strong></h5><p>​\t返回区间内容想·，withscores表示带有分数</p>\n<p>​\t语法：zrange key 区间 [withscores]</p>\n<p>​\t返回值：值列表</p>\n<p><img data-src=\"C:\\Users\\Lenovo\\AppData\\Roaming\\Typora\\typora-user-images\\1645195940696.png\" alt=\"1645195940696\"></p>\n<p><img data-src=\"C:\\Users\\Lenovo\\AppData\\Roaming\\Typora\\typora-user-images\\1645195926902.png\" alt=\"1645195926902\"></p>\n<h3 id=\"五、-Redis持久化策略\"><a href=\"#五、-Redis持久化策略\" class=\"headerlink\" title=\"五、 Redis持久化策略\"></a>五、 <strong>Redis持久化策略</strong></h3><p>​\tRedis不仅仅是一个内存型数据库，还具备持久化能力。</p>\n<h4 id=\"1-RDB\"><a href=\"#1-RDB\" class=\"headerlink\" title=\"1. RDB\"></a>1. <strong>RDB</strong></h4><p>​\trdb模式是默认模式，可以在指定的时间间隔内生成数据快照（snapshot），默认保存到dump.rdb文件中。当redis重启后会自动加载dump.rdb文件中内容到内存中。</p>\n<p>​\t用户可以使用SAVE（同步）或BGSAVE（异步）手动保存数据。</p>\n<p>​\t可以设置服务器配置的save选项，让服务器每隔一段时间自动执行一次BGSAVE命令，可以通过save选项设置多个保存条件，但只要其中任意一个条件被满足，服务器就会执行BGSAVE命令。<br>　　\t例如：<br>　　\tsave 900 1<br>　　\tsave 300 10<br>　　\tsave 60 10000<br>　　那么只要满足以下三个条件中的任意一个，BGSAVE命令就会被执行<br>　　服务器在900秒之内，对数据库进行了至少1次修改<br>　　服务器在300秒之内，对数据库进行了至少10次修改<br>　　服务器在60秒之内，对数据库进行了至少10000次修改</p>\n<h5 id=\"1-1-优点\"><a href=\"#1-1-优点\" class=\"headerlink\" title=\"1.1 优点\"></a>1.1 <strong>优点</strong></h5><p>​\trdb文件是一个紧凑文件，直接使用rdb文件就可以还原数据。</p>\n<p>​\t数据保存会由一个子进程进行保存，不影响父进程。</p>\n<p>​\t恢复数据的效率要高于aof</p>\n<h5 id=\"1-2-缺点\"><a href=\"#1-2-缺点\" class=\"headerlink\" title=\"1.2 缺点\"></a>1.2 <strong>缺点</strong></h5><p>​\t每次保存点之间导致redis不可意料的关闭，可能会丢失数据。</p>\n<p>​\t由于每次保存数据都需要fork()子进程，在数据量比较大时可能会比较耗费性能。</p>\n<h4 id=\"2-AOF\"><a href=\"#2-AOF\" class=\"headerlink\" title=\"2 AOF\"></a>2 <strong>AOF</strong></h4><p>​\tAOF默认是关闭的，需要在配置文件中开启AOF。Redis支持AOF和RDB同时生效，如果同时存在，AOF优先级高于RDB（Redis重新启动时会使用AOF进行数据恢复）</p>\n<p>​\t监听执行的命令，如果发现执行了修改数据的操作，同时直接同步到数据库文件中。</p>\n<h5 id=\"2-1-优点\"><a href=\"#2-1-优点\" class=\"headerlink\" title=\"2.1 优点\"></a>2.1 <strong>优点</strong></h5><p>​\t相对RDB数据更加安全。</p>\n<h5 id=\"2-2-缺点\"><a href=\"#2-2-缺点\" class=\"headerlink\" title=\"2.2 缺点\"></a>2.2 <strong>缺点</strong></h5><p>​\t相同数据集AOF要大于RDB。</p>\n<p>​\t相对RDB可能会慢一些。</p>\n<h5 id=\"2-3-开启办法\"><a href=\"#2-3-开启办法\" class=\"headerlink\" title=\"2.3 开启办法\"></a>2.3 <strong>开启办法</strong></h5><p>​\t修改redis.conf中</p>\n<pre><code># 默认no\nappendonly yes\n# aof文件名\nappendfilename &quot;appendonly.aof&quot;\n</code></pre>\n<h3 id=\"六-Redis主从复制\"><a href=\"#六-Redis主从复制\" class=\"headerlink\" title=\"六. Redis主从复制\"></a>六. <strong>Redis主从复制</strong></h3><p>​\tRedis支持集群功能。为了保证单一节点可用性，redis支持主从复制功能。每个节点有N个复制品（replica），其中一个复制品是主（master），另外N-1个复制品是从（Slave），也就是说Redis支持一主多从。</p>\n<p>​\t一个主可有多个从，而一个从又可以看成主，它还可以有多个从。</p>\n<img data-src=\"/2022/10/07/Redis/Redis-04.jpg\" class=\"\">\n\n<h4 id=\"1-主从优点\"><a href=\"#1-主从优点\" class=\"headerlink\" title=\"1. 主从优点\"></a>1. <strong>主从优点</strong></h4><p>​\t增加单一节点的健壮性，从而提升整个集群的稳定性。（Redis中当超过1&#x2F;2节点不可用时，整个集群不可用）</p>\n<p>​\t从节点可以对主节点数据备份，提升容灾能力。</p>\n<p>​\t读写分离。在redis主从中，主节点一般用作写（具备读的能力），从节点只能读，利用这个特性实现读写分离，写用主，读用从。</p>\n<h5 id=\"1-1-一主多从搭建\"><a href=\"#1-1-一主多从搭建\" class=\"headerlink\" title=\"1.1 一主多从搭建\"></a>1.1 <strong>一主多从搭建</strong></h5><p>​\t在已经搭建的单机版redis基础上进行操作。</p>\n<p>​\t并且关闭redis单机版</p>\n<pre><code>./redis-cli shutdown\n</code></pre>\n<h5 id=\"1-2-新建目录\"><a href=\"#1-2-新建目录\" class=\"headerlink\" title=\"1.2 新建目录\"></a>1.2 <strong>新建目录</strong></h5><pre><code># mkdir /usr/local/replica\n</code></pre>\n<h5 id=\"1-3-复制目录\"><a href=\"#1-3-复制目录\" class=\"headerlink\" title=\"1.3 复制目录\"></a>1.3 <strong>复制目录</strong></h5><p>​\t把之前安装的redis单机版中bin目录复制三份，分别叫做：master、slave1、slave2</p>\n<pre><code># cp -r /usr/local/redis/bin /usr/local/replica/master\n# cp -r /usr/local/redis/bin /usr/local/replica/slave1\n# cp -r /usr/local/redis/bin /usr/local/replica/slave2\n</code></pre>\n<h5 id=\"1-4-修改从的配置文件\"><a href=\"#1-4-修改从的配置文件\" class=\"headerlink\" title=\"1.4 修改从的配置文件\"></a>1.4 <strong>修改从的配置文件</strong></h5><p>​\t修改2个从的redis.conf，指定主节点ip和端口。并修改自身端口号防止和其他redis冲突。</p>\n<pre><code># vim /usr/local/replica/slave1/redis.conf\n</code></pre>\n<p>​\t指定主节点ip和端口</p>\n<pre><code>replicaof 192.168.93.10 6379\n</code></pre>\n<p>​\t修改自己端口</p>\n<pre><code>port 6380\n</code></pre>\n<pre><code># vim /usr/local/replica/slave2/redis.conf\n</code></pre>\n<p>​\t指定主节点ip和端口</p>\n<pre><code>replicaof 192.168.93.10 6379\n</code></pre>\n<p>​\t修改自己端口</p>\n<pre><code>port 6381\n</code></pre>\n<h5 id=\"1-5-启动三个redis实例\"><a href=\"#1-5-启动三个redis实例\" class=\"headerlink\" title=\"1.5 启动三个redis实例\"></a>1.5 <strong>启动三个redis实例</strong></h5><p>​\t注意：一定要关闭单机的redis，否则端口冲突。</p>\n<pre><code># cd /usr/local/replica\n# vim startup.sh\n</code></pre>\n<p>​\t在文件中添加下面内容</p>\n<pre><code>cd /usr/local/replica/master/\n./redis-server redis.conf\n  cd /usr/local/replica/slave1\n./redis-server redis.conf\n  cd /usr/local/replica/slave2\n./redis-server redis.conf\n</code></pre>\n<pre><code> 赋予权限\n</code></pre>\n<pre><code># chmod a+x startup.sh\n</code></pre>\n<p>​\t开启</p>\n<pre><code># ./startup.sh\n</code></pre>\n<h5 id=\"1-6-查看启动状态\"><a href=\"#1-6-查看启动状态\" class=\"headerlink\" title=\"1.6 查看启动状态\"></a>1.6 <strong>查看启动状态</strong></h5><pre><code># ps aux|grep redis\n</code></pre>\n<img data-src=\"/2022/10/07/Redis/Redis-05.jpg\" class=\"\">\n\n<h5 id=\"1-7-测试\"><a href=\"#1-7-测试\" class=\"headerlink\" title=\"1.7 测试*\"></a>1.7 <strong>测试</strong>*</h5><pre><code># cd /usr/local/replica/master/\n# ./redis-cli \n</code></pre>\n<img data-src=\"/2022/10/07/Redis/Redis-06.jpg\" class=\"\">\n\n<p>​\t在客户端命令行模式下，添加一条数据：</p>\n<img data-src=\"/2022/10/07/Redis/Redis-07.jpg\" class=\"\">\n\n<p>​\t进去slave查看数据是否同步。</p>\n<pre><code># cd /usr/local/replica/slave1\n# ./redis-cli -p 6380\n</code></pre>\n<img data-src=\"/2022/10/07/Redis/Redis-08.jpg\" class=\"\">\n\n<h4 id=\"2、docker下操作\"><a href=\"#2、docker下操作\" class=\"headerlink\" title=\"2、docker下操作\"></a>2、docker下操作</h4><p>​\t可以自定义<strong>redis.conf</strong>文件只写要修改的，不改的就别写，这里主要是要书写<strong>新的端口号</strong>以及<strong>父节点</strong>的<strong>ip和端口</strong></p>\n<p><strong>注意：</strong>所有修改必须在容器外，容器内修改无效，在退出重启的那一刻就已经还原了</p>\n<p>我们通常使用  CP 来修改</p>\n<pre><code class=\"shell\">docker  cp  本机文件路径   容器id: 容器内文件路径\n#所有路径是所在文件夹路径，并不是文件的路径，简单来说就是写到文件夹所在路径即可，不需要指定特定文件\n</code></pre>\n<h5 id=\"1、修改端口号\"><a href=\"#1、修改端口号\" class=\"headerlink\" title=\"1、修改端口号\"></a>1、修改端口号</h5><p>同上</p>\n<h5 id=\"2、指定父节点\"><a href=\"#2、指定父节点\" class=\"headerlink\" title=\"2、指定父节点\"></a>2、指定父节点</h5><p>同上</p>\n<h5 id=\"3、重启\"><a href=\"#3、重启\" class=\"headerlink\" title=\"3、重启\"></a>3、重启</h5><p><strong>（如果在启动前修改不需要，这里是指已经启动了的容器，在修改之后的操作）</strong></p>\n<pre><code class=\"shell\">docker restart 容器id\n</code></pre>\n<h5 id=\"4、测试并查看\"><a href=\"#4、测试并查看\" class=\"headerlink\" title=\"4、测试并查看\"></a>4、测试并查看</h5><p>·同上</p>\n<pre><code class=\"shell\">role\n\n或者\n\ninfo replication\n</code></pre>\n<h3 id=\"七-哨兵（Sentinel）\"><a href=\"#七-哨兵（Sentinel）\" class=\"headerlink\" title=\"七.  哨兵（Sentinel）\"></a>七.  <strong>哨兵（Sentinel）</strong></h3><p>​\t在redis主从默认是只有主具备写的能力，而从只能读。如果主宕机，整个节点不具备写能力。但是如果这是让一个从变成主，整个节点就可以继续工作。即使之前的主恢复过来也当做这个节点的从即可。</p>\n<p>​\tRedis的哨兵就是帮助监控整个节点的，当节点主宕机等情况下，帮助重新选取主。</p>\n<p>​\tRedis中哨兵支持单哨兵和多哨兵。单哨兵是只要这个哨兵发现master宕机了，就直接选取另一个master。而多哨兵是根据我们设定，达到一定数量哨兵认为master宕机后才会进行重新选取主。我们以多哨兵演示。</p>\n<h4 id=\"1-没有哨兵下主从效果\"><a href=\"#1-没有哨兵下主从效果\" class=\"headerlink\" title=\"1. 没有哨兵下主从效果\"></a>1. <strong>没有哨兵下主从效果</strong></h4><p>​\t只要杀掉主，整个节点无法在写数据，从身份不会变化，主的信息还是以前的信息。</p>\n<img data-src=\"/2022/10/07/Redis/Redis-09.jpg\" class=\"\">\n\n<h4 id=\"2-搭建多哨兵\"><a href=\"#2-搭建多哨兵\" class=\"headerlink\" title=\"2.搭建多哨兵\"></a>2.<strong>搭建多哨兵</strong></h4><p>​\t前提：安装了单机的redis</p>\n<h5 id=\"2-1-新建目录\"><a href=\"#2-1-新建目录\" class=\"headerlink\" title=\"2.1 新建目录\"></a>2.1 <strong>新建目录</strong></h5><pre><code># mkdir /usr/local/sentinel\n</code></pre>\n<h5 id=\"2-2-复制redis\"><a href=\"#2-2-复制redis\" class=\"headerlink\" title=\"2.2 复制redis\"></a>2.2 <strong>复制redis</strong></h5><pre><code># cp -r /usr/local/redis/bin/* /usr/local/sentinel\n</code></pre>\n<h5 id=\"2-3-复制配置文件\"><a href=\"#2-3-复制配置文件\" class=\"headerlink\" title=\"2.3 复制配置文件\"></a>2.3 <strong>复制配置文件</strong></h5><p>​\t从redis解压目录中复制sentinel配置文件</p>\n<pre><code># cd /usr/local/tmp/redis-5.0.5/\n# cp sentinel.conf /usr/local/sentinel/\n</code></pre>\n<h5 id=\"2-4-修改配置文件\"><a href=\"#2-4-修改配置文件\" class=\"headerlink\" title=\"2.4 修改配置文件\"></a>2.4 <strong>修改配置文件</strong></h5><pre><code># cd /usr/local/sentinel\n# vim sentinel.conf\n\nport 26379\ndaemonize yes\n#这个提示里面的/var/log/redis/redis.log日志文件指的是容器中的文件，千万别理解为宿主机中的路径，如果你在宿主机创建此文件并授权，最后结果也是一样的，理解这一点很重要。\nlogfile “/usr/local/sentinel/26379.log”\n\nsentinel monitor mymaster 192.168.93.10 6379 2\n</code></pre>\n<p>​\t复制sentinel.conf，命名为sentinel-26380.conf</p>\n<pre><code># cp sentinel.conf sentinel-26380.conf\n# vim sentinel-26380.conf\n\nport 26380\ndaemonize yes\nlogfile “/usr/local/sentinel/26380.log”\nsentinel monitor mymaster 192.168.93.10 6379 2\n</code></pre>\n<p>复制sentinel.conf，命名为sentinel-26381.conf</p>\n<pre><code># cp sentinel.conf sentinel-26381.conf\n# vim sentinel-26381.conf\n\nport 26381\ndaemonize yes\nlogfile “/usr/local/sentinel/26381.log”\nsentinel monitor mymaster 192.168.93.10 6379 2\n</code></pre>\n<h5 id=\"2-5-启动主从\"><a href=\"#2-5-启动主从\" class=\"headerlink\" title=\"2.5 启动主从\"></a>2.5 <strong>启动主从</strong></h5><p>​\t如果已经启动状态，忽略下面命令。如果启动部分，全部kill后重新启动。</p>\n<p>​\t使用kill杀死全部redis</p>\n<pre><code># ps aux|grep redis\n# kill -9 进程号\n</code></pre>\n<p>​\t启动redis主从</p>\n<pre><code># cd /usr/local/replica\n# ./startup.sh\n</code></pre>\n<h5 id=\"2-6-启动三个哨兵\"><a href=\"#2-6-启动三个哨兵\" class=\"headerlink\" title=\"2.6 启动三个哨兵\"></a>2.6 <strong>启动三个哨兵</strong></h5><pre><code># cd /usr/local/sentinel\n# ./redis-sentinel sentinel.conf\n# ./redis-sentinel sentinel-26380.conf\n# ./redis-sentinel sentinel-26381.conf\n</code></pre>\n<h5 id=\"2-7-查看日志\"><a href=\"#2-7-查看日志\" class=\"headerlink\" title=\"2.7 查看日志\"></a>2.7 <strong>查看日志</strong></h5><pre><code># cat 26379.log\n</code></pre>\n<h5 id=\"2-8-测试宕机\"><a href=\"#2-8-测试宕机\" class=\"headerlink\" title=\"2.8 测试宕机\"></a>2.8 <strong>测试宕机</strong></h5><p>​\t查看redis进程号</p>\n<pre><code># ps aux|grep redis\n</code></pre>\n<p>​\t杀死主进程号</p>\n<pre><code># kill -9 进程号\n</code></pre>\n<p>​\t查看日志，短暂延迟后会发现，出现新的主。</p>\n<pre><code># cat 26379.log\n</code></pre>\n<h3 id=\"八-集群-Cluster-–nt-have-doc\"><a href=\"#八-集群-Cluster-–nt-have-doc\" class=\"headerlink\" title=\"八. 集群(Cluster)–nt have doc\"></a>八. 集群(Cluster)–nt have doc</h3><p>​\t前提：已经安装好redis单机版。</p>\n<p>​\t当集群中超过或等于1&#x2F;2节点不可用时，整个集群不可用。为了搭建稳定集群，都采用奇数节点。</p>\n<h4 id=\"1-复制redis配置文件\"><a href=\"#1-复制redis配置文件\" class=\"headerlink\" title=\"1 .复制redis配置文件\"></a>1 .<strong>复制redis配置文件</strong></h4><p>​\t从&#x2F;usr&#x2F;local&#x2F;redis&#x2F;bin下把redis.conf复制到当前目录中，命名为redis-7001.conf</p>\n<pre><code># cp /usr/local/redis/bin/redis.conf /usr/local/redis/bin/redis-7001.conf\n</code></pre>\n<h4 id=\"2-修改redis-7001-conf\"><a href=\"#2-修改redis-7001-conf\" class=\"headerlink\" title=\"2. 修改redis-7001.conf\"></a>2. <strong>修改redis-7001.conf</strong></h4><pre><code># cd /usr/local/redis/bin\n# vim redis-7001.conf\n</code></pre>\n<p>​\t需要修改如下</p>\n<pre><code>port 7001\ncluster-enabled yes\ncluster-config-file nodes-7001.conf\ncluster-node-timeout 15000\n# appendonly yes 如果开启aof默认，需要修改为yes。如果使用rdb，此处不需要修改\ndaemonize yes\nprotected-mode no\npidfile /var/run/redis_7001.pid\n</code></pre>\n<h3 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h3><h4 id=\"3-复制配置文件，并修改内容\"><a href=\"#3-复制配置文件，并修改内容\" class=\"headerlink\" title=\"3 .复制配置文件，并修改内容\"></a>3 .<strong>复制配置文件，并修改内容</strong></h4><p>​\t把redis-7001.conf 复制5份，分别叫做redis-7002.conf、redis-7003.conf、redis-7004.conf、redis-7005.conf、redis-7006.conf </p>\n<pre><code># cp redis-7001.conf redis-7002.conf\n# cp redis-7001.conf redis-7003.conf\n# cp redis-7001.conf redis-7004.conf\n# cp redis-7001.conf redis-7005.conf\n# cp redis-7001.conf redis-7006.conf\n</code></pre>\n<pre><code> 新复制的5个配置文件都需要需改三处。\n</code></pre>\n<p>​\t例如nodes-7002.conf中需要把所有7001都换成7002。</p>\n<p>​\t可以使用 :%s&#x2F;7001&#x2F;7002&#x2F;g 进行全局修改。 </p>\n<pre><code>port 7002\ncluster-config-file nodes-7002.conf\npidfile /var/run/redis_7002.pid\n</code></pre>\n<h4 id=\"4-启动6个redis\"><a href=\"#4-启动6个redis\" class=\"headerlink\" title=\"4 .启动6个redis\"></a>4 .<strong>启动6个redis</strong></h4><p>​\t可以使用redis-server结合6个配置文件进行启动6个实例。</p>\n<p>​\t执行之前一定要先删除dump.rdb</p>\n<pre><code># rm -f dump.rdb\n# vim startup.sh\n\n./redis-server redis-7001.conf\n./redis-server redis-7002.conf\n./redis-server redis-7003.conf\n./redis-server redis-7004.conf\n./redis-server redis-7005.conf\n./redis-server redis-7006.conf\n\n\n# chmod a+x startup.sh\n# ./startup.sh\n</code></pre>\n<h4 id=\"5-查看启动状态\"><a href=\"#5-查看启动状态\" class=\"headerlink\" title=\"5. 查看启动状态\"></a>5. <strong>查看启动状态</strong></h4><img data-src=\"/2022/10/07/Redis/Redis-10.jpg\" class=\"\">\n\n<h4 id=\"6-建立集群\"><a href=\"#6-建立集群\" class=\"headerlink\" title=\"6. 建立集群\"></a>6. <strong>建立集群</strong></h4><p>​\t在redis3的时候需要借助ruby脚本实现集群。在redis5中可以使用自带的redis-cli实现集群功能，比redis3的时候更加方便了。</p>\n<p>​\t建议配置静态ip，ip改变集群失效</p>\n<pre><code>./redis-cli --cluster create 192.168.93.10:7001 192.168.93.10:7002 192.168.93.10:7003 192.168.93.10:7004 192.168.93.10:7005 192.168.93.10:7006 --cluster-replicas 1\n</code></pre>\n<h4 id=\"7-测试\"><a href=\"#7-测试\" class=\"headerlink\" title=\"7. 测试\"></a>7. <strong>测试</strong></h4><p>​\t集群测试时，千万不要忘记最后一个-c参数。</p>\n<pre><code># ./redis-cli -p 7001 -c\n# set age 18\n</code></pre>\n<h4 id=\"8-编写关闭脚本\"><a href=\"#8-编写关闭脚本\" class=\"headerlink\" title=\"8 .编写关闭脚本\"></a>8 .<strong>编写关闭脚本</strong></h4><pre><code># vim stop.sh\n# chmod a+x stop.sh\n\n./redis-cli -p 7001 shutdown\n./redis-cli -p 7002 shutdown\n./redis-cli -p 7003 shutdown\n./redis-cli -p 7004 shutdown\n./redis-cli -p 7005 shutdown\n./redis-cli -p 7006 shutdown\n</code></pre>\n<h3 id=\"八-集群-Cluster-PATH-docker\"><a href=\"#八-集群-Cluster-PATH-docker\" class=\"headerlink\" title=\"八. 集群(Cluster)-PATH:docker\"></a>八. 集群(Cluster)-PATH:docker</h3><p>​\t<strong>注：</strong>1.如果是配置修改之前<strong>已经创建过的集群时</strong>，要先进行第七步操作。</p>\n<p>​\t\t\t2.要是想重启集群可以省略第一步，但是得<strong>先删除已经创建的容器</strong>，重新进行2、3（合并也行）</p>\n<h4 id=\"0、创建网络\"><a href=\"#0、创建网络\" class=\"headerlink\" title=\"0、创建网络\"></a>0、创建网络</h4><p><strong>目的：</strong>让宿主机可以访问到自身</p>\n<pre><code class=\"shell\">docker network create net-redis --subnet 172.38.0.0/16\n</code></pre>\n<p>补充：关于虚拟机的三种网路连接方式区别</p>\n<p> <span class=\"exturl\" data-url=\"aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYmlmZW5nbWlhb3podWFuL2FydGljbGUvZGV0YWlscy83OTg4NzY5Mj9zcG09MTAwMS4yMTAxLjMwMDEuNjY2MS4xJmFtcDt1dG1fbWVkaXVtPWRpc3RyaWJ1dGUucGNfcmVsZXZhbnRfdDAubm9uZS10YXNrLWJsb2ctMn5kZWZhdWx0fkNUUkxJU1R+UmF0ZS0xLnBjX3JlbGV2YW50X2RlZmF1bHQmYW1wO2RlcHRoXzEtdXRtX3NvdXJjZT1kaXN0cmlidXRlLnBjX3JlbGV2YW50X3QwLm5vbmUtdGFzay1ibG9nLTJ+ZGVmYXVsdH5DVFJMSVNUflJhdGUtMS5wY19yZWxldmFudF9kZWZhdWx0JmFtcDt1dG1fcmVsZXZhbnRfaW5kZXg9MQ==\">http://blog.csdn.net/bifengmiaozhuan/article/details/79887692?spm=1001.2101.3001.6661.1&amp;utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1.pc_relevant_default&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1.pc_relevant_default&amp;utm_relevant_index=1</span> </p>\n<p><img data-src=\"C:\\Users\\Lenovo\\AppData\\Roaming\\Typora\\typora-user-images\\1645532994890.png\" alt=\"1645532994890\"></p>\n<h4 id=\"1、创建并修改配置文件\"><a href=\"#1、创建并修改配置文件\" class=\"headerlink\" title=\"1、创建并修改配置文件\"></a>1、创建并修改配置文件</h4><p><strong>注：</strong></p>\n<pre><code>In certain deployments, Redis Cluster nodes address discovery fails, because addresses are NAT-ted or because ports are forwarded (the typical case is Docker and other containers).\n\n在某些部署中，Redis群集节点地址发现失败，因为地址是NAT，或者端口是转发的（典型情况是Docker和其他容器）。\n\nIn order to make Redis Cluster working in such environments, a static configuration where each node knows its public address is needed. The following two options are used for this scope, and are:\n\n为了让Redis集群在这样的环境中工作，需要一种静态配置，其中每个节点都知道自己的公共地址。以下两个选项用于此范围，分别是：\n\ncluster-announce-ip\n\ncluster-announce-port\n---------------------------------------------------------------------------------------\n你的docker内网是172，你宿主的IP是192网段\n\n根据redis的配置文件中的解释\n\n要在你的配置文件上加上上面的2个配置\n</code></pre>\n<p><strong>方法一：</strong>参考上面的方法一样行。</p>\n<p><strong>方法二：</strong>使用脚本</p>\n<pre><code class=\"shell\">#cat &lt;&lt;EOF EOF在这里没有特殊的含义，你可以使用FOE或000等;\n#表示以cat &lt;&lt;EOF 开始输入以 EOF 结束结束输入\n#cat&gt;创建文件，并把标准输入输出到后面的filename文件\n\n\n# * cluster-announce-ip\t\t\t\t\t192.168.1.195\t#*群集ip\n# * cluster-announce-port\t\t\t\t700$&#123;port&#125;\t\t#*群集总线端口\n# * cluster-announce-bus-port#*群集ip    1700$&#123;port&#125;\t   #*群集公布端口\n# 集群 ip 是固定+10000\n\n# 可以使用 :  %s/7001/7002/g     进行全局修改。 ---将全局的7001修改成7002\n\nfor port in $(seq 1 6); \\ \ndo \\\nmkdir  -p  /root/myredis/conf700$&#123;port&#125;\ntouch  /root/myredis/conf700$&#123;port&#125;/redis.conf\ncat &lt;&lt;TTT &gt; /root/myredis/conf700$&#123;port&#125;/redis.conf port 6379\nbind 0.0.0.0\nport 700$&#123;port&#125;\ncluster-enabled yes\ncluster-config-file nodes-700$&#123;port&#125;.conf\ncluster-node-timeout 15000\nprotected-mode no\npidfile /var/run/redis_ 700$&#123;port&#125;.pid\ncluster-announce-ip  192.168.1.195 \ncluster-announce-port  700$&#123;port) \ncluster-announce-bus-port 1700$&#123;port) \nappendonly yes \nTTT \ndone\n</code></pre>\n<h4 id=\"2、创建容器\"><a href=\"#2、创建容器\" class=\"headerlink\" title=\"2、创建容器\"></a>2、创建容器</h4><p><strong>方法一：</strong>手动创建容器，并启动</p>\n<pre><code class=\"shell\">docker run -p 7001:7001   -p 17001:17001  --name redis7001  -v /root/myredis/conf7001/redis.conf:/etc/redis/redis.conf -v /root/myredis/data7001:/data -d redis redis-server /etc/redis/redis.conf --appendonly yes\n</code></pre>\n<p>​\t7002 ~~~7006同上，自行修改参数</p>\n<p><strong>方法二：</strong>脚本一键启动，效果同上</p>\n<p>​\t<strong>注意：</strong></p>\n<ul>\n<li>其中要指定两个端口号**-p 1700${port}:1700${port}**不要忘记，否则会在创建几群的时候出现  **Waiting for the cluster to join   ** 。【具体原因，我还没查出来，后面补充】</li>\n<li>在docker创建集群容器的时候，<strong>一定要</strong> 指定  ip</li>\n</ul>\n<p><strong>补充：</strong></p>\n<ul>\n<li>那肯定是你端口没有开启，不要质疑，这里的端口不是7000-7005，而是17000-17005，因为redis设置集群的端口号是”redis端口+10000“，这个非常重要。并且7001:7006也是必须打开的。</li>\n</ul>\n<pre><code class=\"shell\">for port in $(seq 1 6);  \\\ndo \\\ndocker run -p 700$&#123;port&#125;:700$&#123;port&#125;   -p 1700$&#123;port&#125;:1700$&#123;port&#125;  --name redis700$&#123;port&#125;  \\\n-v /root/redis/redis700$&#123;port&#125;.conf:/etc/redis/redis.conf \\\n-v /root/redis/data700$&#123;port&#125;:/data \\\n-d --ip 192.168.1.195 redis redis-server /etc/redis/redis.conf \ndone\n</code></pre>\n<h4 id=\"3、进入容器\"><a href=\"#3、进入容器\" class=\"headerlink\" title=\"3、进入容器\"></a>3、进入容器</h4><pre><code class=\"shell\">docker exec -it redis7001 /bin/bash\n</code></pre>\n<h4 id=\"4、创建集群\"><a href=\"#4、创建集群\" class=\"headerlink\" title=\"4、创建集群\"></a>4、创建集群</h4><p>​\t<strong>注：</strong>有一步操作，要自行进行确认，一定要输入 <strong>yes</strong> 而不是 <strong>y</strong> 或者其他之类的，除了 yes一律视为 <strong>no</strong> 。</p>\n<pre><code class=\"shell\">redis-cli --cluster create 192.168.1.195:7001 192.168.1.195:7002 192.168.1.195:7003 192.168.1.195:7004 192.168.1.195:7005 192.168.1.195:7006 --cluster-replicas 1\n</code></pre>\n<h4 id=\"5、测试\"><a href=\"#5、测试\" class=\"headerlink\" title=\"5、测试\"></a>5、测试</h4><p>​\t集群测试时，千万不要忘记最后一个-c参数。</p>\n<pre><code class=\"shel\">redis-cli -p 7001 -c\n</code></pre>\n<h4 id=\"6、关闭集群\"><a href=\"#6、关闭集群\" class=\"headerlink\" title=\"6、关闭集群\"></a>6、关闭集群</h4><p><strong>方法一：</strong></p>\n<p>​\t自行手动一个一个停止，并且删除容器</p>\n<pre><code class=\"shell\">docker stop redis7001 #7002 ~~~7006\n\ndocker rm -f redis7001\n</code></pre>\n<p><strong>方法二：</strong></p>\n<p>​\t脚本程序，一劳永逸</p>\n<pre><code class=\"shell\">for port in $(seq 1 6);  \\\ndo \\\ndocker stop redis700$&#123;port&#125;\ndocker rm -f redis700$&#123;port&#125;\ndone\n</code></pre>\n<h4 id=\"7、清空集群文件\"><a href=\"#7、清空集群文件\" class=\"headerlink\" title=\"7、清空集群文件\"></a>7、清空集群文件</h4><pre><code class=\"shell\">for port in $(seq 1 6);  \\\ndo \\\nrm  -rf  ./data700$&#123;port&#125;/* \ndone\n</code></pre>\n<h3 id=\"九-Jedis\"><a href=\"#九-Jedis\" class=\"headerlink\" title=\"九. Jedis\"></a>九. <strong>Jedis</strong></h3><p>​\tRedis给Java语言提供了客户端API，称之为Jedis。</p>\n<p>​\tJedis API和Redis 命令几乎是一样的。</p>\n<p>​\t例如：Redis对String值新增时set命令，Jedis中也是set方法。所以本课程中没有重点把所有方法进行演示，重要演示Jedis如何使用。</p>\n<p>​\tJedis API特别简单，基本上都是创建对象调用方法即可。</p>\n<h4 id=\"1-单机版\"><a href=\"#1-单机版\" class=\"headerlink\" title=\"1. 单机版\"></a>1. <strong>单机版</strong></h4><pre><code>public void testStandalone()&#123;\n    Jedis jedis = new Jedis(&quot;192.168.93.10&quot;,6379);\n    jedis.set(&quot;name&quot;,&quot;msb-standalone&quot;);\n    String value = jedis.get(&quot;name&quot;);\n    System.out.println(value);\n&#125;\n</code></pre>\n<h4 id=\"2-带有连接池\"><a href=\"#2-带有连接池\" class=\"headerlink\" title=\"2. 带有连接池\"></a>2. <strong>带有连接池</strong></h4><pre><code>public void testPool()&#123;\n    JedisPoolConfig jedisPoolConfig = new JedisPoolConfig();\n    jedisPoolConfig.setMaxTotal(20);\n    jedisPoolConfig.setMaxIdle(5);\n    jedisPoolConfig.setMinIdle(3);\n    JedisPool jedisPool = new JedisPool(jedisPoolConfig,&quot;192.168.93.10&quot;,6379);\n    Jedis jedis = jedisPool.getResource();\n    jedis.set(&quot;name&quot;,&quot;msb-pool&quot;);\n    String value = jedis.get(&quot;name&quot;);\n    System.out.println(value);\n&#125;\n</code></pre>\n<h4 id=\"3-集群\"><a href=\"#3-集群\" class=\"headerlink\" title=\"3. 集群\"></a>3. <strong>集群</strong></h4><pre><code>public void testCluster()&#123;\n    Set&lt;HostAndPort&gt; set = new HashSet&lt;&gt;();\n    set.add(new HostAndPort(&quot;192.168.93.10&quot;,7001));\n    set.add(new HostAndPort(&quot;192.168.93.10&quot;,7002));\n    set.add(new HostAndPort(&quot;192.168.93.10&quot;,7003));\n    set.add(new HostAndPort(&quot;192.168.93.10&quot;,7004));\n    set.add(new HostAndPort(&quot;192.168.93.10&quot;,7005));\n    set.add(new HostAndPort(&quot;192.168.93.10&quot;,7006));\n    JedisCluster jedisCluster = new JedisCluster(set);\n    jedisCluster.set(&quot;name&quot;,&quot;bjmsb&quot;);\n    String value = jedisCluster.get(&quot;name&quot;);\n    System.out.println(value);\n&#125;\n</code></pre>\n<h3 id=\"十-使用SpringBoot整合SpringDataRedis操作redis\"><a href=\"#十-使用SpringBoot整合SpringDataRedis操作redis\" class=\"headerlink\" title=\"十. 使用SpringBoot整合SpringDataRedis操作redis\"></a>十. <strong>使用SpringBoot整合SpringDataRedis操作redis</strong></h3><p>​\tSpring Data是Spring公司的顶级项目，里面包含了N多个二级子项目，这些子项目都是相对独立的项目。每个子项目是对不同API的封装。</p>\n<p>​\t所有Spring Boot整合Spring Data xxxx的启动器都叫做spring-boot-starter-data-xxxx</p>\n<p>​\tSpring Data 好处很方便操作对象类型。</p>\n<p>​\t把Redis不同值得类型放到一个opsForXXX方法中。</p>\n<p>​\t\topsForValue : String值</p>\n<p>​\t\topsForList : 列表List</p>\n<p>​\t\topsForHash: 哈希表Hash</p>\n<p>​\t\topsForZSet: 有序集合Sorted Set</p>\n<p>​\t\topsForSet : 集合</p>\n<h4 id=\"1-添加依赖\"><a href=\"#1-添加依赖\" class=\"headerlink\" title=\"1. 添加依赖\"></a>1. <strong>添加依赖</strong></h4><pre><code>     &lt;parent&gt;\n        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;\n        &lt;version&gt;2.2.2.RELEASE&lt;/version&gt;\n    &lt;/parent&gt;\n\n    &lt;dependencies&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;\n            &lt;version&gt;2.2.5.RELEASE&lt;/version&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;\n            &lt;version&gt;2.1.1&lt;/version&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;mysql&lt;/groupId&gt;\n            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;\n            &lt;version&gt;5.1.47&lt;/version&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;\n            &lt;version&gt;2.2.2.RELEASE&lt;/version&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;\n            &lt;artifactId&gt;lombok&lt;/artifactId&gt;\n            &lt;version&gt;1.18.20&lt;/version&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;redis.clients&lt;/groupId&gt;\n            &lt;artifactId&gt;jedis&lt;/artifactId&gt;\n            &lt;version&gt;3.3.0&lt;/version&gt;\n        &lt;/dependency&gt;\n    &lt;/dependencies&gt;\n</code></pre>\n<h4 id=\"2-配置配置文件\"><a href=\"#2-配置配置文件\" class=\"headerlink\" title=\"2. 配置配置文件\"></a>2. <strong>配置配置文件</strong></h4><p><strong>注：</strong></p>\n<ul>\n<li><p>spring.redis.host&#x3D;localhost 默认值</p>\n</li>\n<li><p>spring.redis.port&#x3D;6379 端口号默认值</p>\n</li>\n</ul>\n<pre><code>mybatis:\n  mapper-locations: classpath:mybatis/*\n  type-aliases-package: com.msb.pojo\nspring:\n  datasource:\n    url: jdbc:mysql://localhost:3306/mydb\n    username: root\n    password: root\n    driver-class-name: com.mysql.jdbc.Driver\n  redis:\n    host: 192.168.1.195\n    cluster:\n      nodes: 192.168.1.195:7001,192.168.1.195:7002,192.168.1.195:7003,192.168.1.195:7004,192.168.1.195:7005,192.168.1.195:7006\n</code></pre>\n<h4 id=\"3-编写配置类（可直接复制）\"><a href=\"#3-编写配置类（可直接复制）\" class=\"headerlink\" title=\"3.编写配置类（可直接复制）\"></a>3.<strong>编写配置类</strong>（可直接复制）</h4><pre><code>@Configuration\npublic class RedisConfig &#123;\n    @Bean\n    public RedisTemplate&lt;String,Object&gt; redisTemplate(RedisConnectionFactory \t\t  factory)&#123;\n        RedisTemplate&lt;String,Object&gt; redisTemplate = new RedisTemplate&lt;&gt;();\n        redisTemplate.setConnectionFactory(factory);\n        redisTemplate.setKeySerializer(new StringRedisSerializer());\n        redisTemplate.setValueSerializer(new Jackson2JsonRedisSerializer&lt;Object&gt;(Object.class));\n        return redisTemplate;\n    &#125;\n&#125;\n</code></pre>\n<h4 id=\"4-编写代码\"><a href=\"#4-编写代码\" class=\"headerlink\" title=\"4. 编写代码\"></a>4. <strong>编写代码</strong></h4><h5 id=\"4-1-编写对象新增\"><a href=\"#4-1-编写对象新增\" class=\"headerlink\" title=\"4.1 编写对象新增\"></a>4.1 <strong>编写对象新增</strong></h5><pre><code>@Autowired\nprivate RedisTemplate&lt;String, Object&gt; redisTemplate;\n\n@Test\npublic void testString() &#123;\n    People peo = new People(1, &quot;张三&quot;);\n    redisTemplate.opsForValue().set(&quot;peo1&quot;, peo);\n&#125;\n</code></pre>\n<h5 id=\"4-2-编写对象获取\"><a href=\"#4-2-编写对象获取\" class=\"headerlink\" title=\"4.2 编写对象获取\"></a>4.2 <strong>编写对象获取</strong></h5><p>此处必须编写值序列化器。不指定时返回类型为LinkedHashMap</p>\n<pre><code>@Test\npublic void testGetString() &#123;\n    redisTemplate.setValueSerializer(new Jackson2JsonRedisSerializer&lt;People&gt;(People.class));\n    People peo = (People) redisTemplate.opsForValue().get(&quot;peo1&quot;);\n    System.out.println(peo);\n&#125;\n</code></pre>\n<h5 id=\"4-3-编写List\"><a href=\"#4-3-编写List\" class=\"headerlink\" title=\"4.3 编写List\"></a>4.3 <strong>编写List</strong></h5><pre><code>@Test\npublic void testList() &#123;\n    List&lt;People&gt; list = new ArrayList&lt;&gt;();\n    list.add(new People(1, &quot;张三&quot;));\n    list.add(new People(2, &quot;李四&quot;));\n    redisTemplate.opsForValue().set(&quot;list2&quot;, list);\n&#125;\n</code></pre>\n<h5 id=\"4-4-编写List取值\"><a href=\"#4-4-编写List取值\" class=\"headerlink\" title=\"4.4 编写List取值\"></a>4.4 <strong>编写List取值</strong></h5><pre><code>@Test\npublic void testGetList()&#123;\n    redisTemplate.setValueSerializer(new Jackson2JsonRedisSerializer&lt;List&gt;(List.class));\n    List&lt;People&gt; list2 = (List&lt;People&gt;) redisTemplate.opsForValue().get(&quot;list2&quot;);\n    System.out.println(list2);\n&#125;\n</code></pre>\n<h3 id=\"十一-使用Redis效果\"><a href=\"#十一-使用Redis效果\" class=\"headerlink\" title=\"十一. 使用Redis效果\"></a>十一. <strong>使用Redis效果</strong></h3><p>​\t使用缓存流程</p>\n<p>​\t1. 先判断缓存中是否存在。如果存在直接从缓存中取出数据。不执行2，3步骤</p>\n<p>​\t2. 如果不存在，从mysql中获取数据</p>\n<p>​\t3. 获取数据后，把数据缓存到redis中</p>\n<img data-src=\"/2022/10/07/Redis/Redis-11.jpg\" class=\"\">",
            "tags": [
                "分布式",
                "中间件",
                "Redis基础",
                "NoSQL数据库"
            ]
        }
    ]
}