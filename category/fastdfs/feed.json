{
    "version": "https://jsonfeed.org/version/1",
    "title": "记录“美食”每刻 • All posts by \"fastdfs\" category",
    "description": "记录“美食”每刻",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/2022/10/07/FastDFS/",
            "url": "http://example.com/2022/10/07/FastDFS/",
            "title": "FastDFS",
            "date_published": "2022-10-06T16:00:00.000Z",
            "content_html": "<h1 id=\"分布式文件存储系统FastDFS\"><a href=\"#分布式文件存储系统FastDFS\" class=\"headerlink\" title=\"分布式文件存储系统FastDFS\"></a>分布式文件存储系统FastDFS</h1><h1 id=\"一、分布式文件存储\"><a href=\"#一、分布式文件存储\" class=\"headerlink\" title=\"一、分布式文件存储\"></a>一、分布式文件存储</h1><h2 id=\"1-分布式文件存储的由来\"><a href=\"#1-分布式文件存储的由来\" class=\"headerlink\" title=\"1.分布式文件存储的由来\"></a>1.分布式文件存储的由来</h2><p>&amp;emsp;&amp;emsp;在我们的项目中有很多需要存储的内容出现，比如图片，视频，文件等等，在早期的时候用户量不大，产生的文件也不是很多，这时我们可以把文件和服务程序放在一个服务器中。</p>\n<img data-src=\"/2022/10/07/FastDFS/66d2beee9a4e47c08aa9552530a9c996.png\" class=\"\">\n\n\n<p>&amp;emsp;&amp;emsp;后面随着文件越来越多，服务器的资源会被文件资源大量占据，从而影响到服务器的稳定，这时我们可以单独的把文件服务器拆出来。</p>\n<img data-src=\"/2022/10/07/FastDFS/8097b0f16465452b9f9b460e2149aa0d.png\" class=\"\">\n\n\n<p>&amp;emsp;&amp;emsp;拆解出来后，文件服务的使用不会影响到我们的系统服务的稳定，但是当用户量越来越大，存储的文件就会越来越多，这时如果还是单台的文件服务，比如100T的文件，这时是存储不下去的，这时就产生了我们将的分布式文件存储，</p>\n<img data-src=\"/2022/10/07/FastDFS/fff16a09675d40ac926d42be9385d461.png\" class=\"\">\n\n\n<p>&amp;emsp;&amp;emsp;也就是我们解决如何将这100T的文件分散的存储到各个节点上，然后当我们需要读取文件的时候又能非常快的帮我们把文件找到。这个就是分布式文件系统帮我们解决的问题了。</p>\n<h2 id=\"2-常见的分布式存储框架\"><a href=\"#2-常见的分布式存储框架\" class=\"headerlink\" title=\"2.常见的分布式存储框架\"></a>2.常见的分布式存储框架</h2><p>&amp;emsp;&amp;emsp;接下来我们看看在国内常用的分布式存储的框架选择有哪些</p>\n<table>\n<thead>\n<tr>\n<th>分布式框架</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>FastDFS</td>\n<td>我们介绍的主角，国产</td>\n</tr>\n<tr>\n<td>HDFS</td>\n<td>Hadoop组件中分布式存储框架</td>\n</tr>\n<tr>\n<td>MinIO</td>\n<td>MinIO是在Apache下的产品，最适合存储非结构化的数据，<br />比如照片，视频，日志文件，备份和容器等。</td>\n</tr>\n<tr>\n<td>阿里云对象存储</td>\n<td>当然我们还可以花费一点费用来使用其他厂商提供的对象存储服务</td>\n</tr>\n</tbody></table>\n<p>&amp;emsp;&amp;emsp;好了就介绍这么几个，其他的我们也用不到了。</p>\n<h1 id=\"二、FastDFS介绍\"><a href=\"#二、FastDFS介绍\" class=\"headerlink\" title=\"二、FastDFS介绍\"></a>二、FastDFS介绍</h1><p>&amp;emsp;&amp;emsp;FastDFS是余庆国人开发的一个开源的轻量级分布式文件系统，它对文件进行管理，功能包括：文件存储、文件同步、文件访问（文件上传、文件下载）等，解决了大容量存储和负载均衡的问题。特别适合以文件为载体的在线服务，如相册网站、视频网站等等。</p>\n<p>&amp;emsp;&amp;emsp;FastDFS为互联网量身定制，充分考虑了冗余备份、负载均衡、线性扩容等机制，并注重高可用、高性能等指标，使用FastDFS很容易搭建一套高性能的文件服务器集群提供文件上传、下载等服务。</p>\n<p>FastDFS的特点：</p>\n<ul>\n<li>FastDFS是一个轻量级的开源分布式文件系统</li>\n<li>FastDFS主要解决了大容量的文件存储和高并发访问的问题，文件存取时实现了负载均衡</li>\n<li>FastDFS实现了软件方式的RAID，可以使用廉价的IDE硬盘进行存储</li>\n<li>支持存储服务器在线扩容</li>\n<li>支持相同内容的文件只保存一份，节约磁盘空间</li>\n<li>FastDFS只能通过Client API访问，不支持POSIX访问方式</li>\n<li>FastDFS特别适合大中型网站使用，用来存储资源文件（如：图片、文档、音频、视频等等）</li>\n</ul>\n<p>架构图：</p>\n<img data-src=\"/2022/10/07/FastDFS/92362218a5024b7c9e9141b754756b79.png\" class=\"\">\n\n\n<p>相关术语讲解：</p>\n<table>\n<thead>\n<tr>\n<th>名词</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Tracker Server</td>\n<td>跟踪服务器，主要做调度工作，在访问上起负载均衡的作用。<br />记录storage server的状态，是连接Client和Storage server的枢纽</td>\n</tr>\n<tr>\n<td>Storage Server</td>\n<td>存储服务器，文件和meta data都保存到存储服务器上</td>\n</tr>\n<tr>\n<td>group</td>\n<td>组，也可称为卷。同组内服务器上的文件是完全相同的</td>\n</tr>\n<tr>\n<td>文件标识</td>\n<td>包括两部分：组名和文件名（包含路径）</td>\n</tr>\n<tr>\n<td>meta-data</td>\n<td>文件相关属性，键值对（Key Value Pair）方式，如：width&#x3D;1024,heigth&#x3D;768</td>\n</tr>\n</tbody></table>\n<p>架构解读：</p>\n<ul>\n<li>只有两个角色，tracker server和storage server，不需要存储文件索引信息。</li>\n<li>所有服务器都是对等的，不存在Master-Slave关系。</li>\n<li>存储服务器采用分组方式，同组内存储服务器上的文件完全相同（RAID 1）。</li>\n<li>不同组的storage server之间不会相互通信。</li>\n<li>由storage server主动向tracker server报告状态信息，tracker server之间不会相互通信。</li>\n</ul>\n<h1 id=\"三、FastDFS安装\"><a href=\"#三、FastDFS安装\" class=\"headerlink\" title=\"三、FastDFS安装\"></a>三、FastDFS安装</h1><img data-src=\"/2022/10/07/FastDFS/b60ca697c06d4425b7cd228b98dc3d19.png\" class=\"\">\n\n\n<p>&amp;emsp;&amp;emsp;FastDFS的安装我们还是通过Docker来安装实现吧，直接在Linux上还装还是比较繁琐的，但就学习而言Docker安装还是非常高效的。Docker环境请自行安装哦，不清楚的可以看看我的Docker专题的内容。<a href=\"Docker%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99\" title=\"Docker学习资料\">https://blog.csdn.net/qq_38526573&#x2F;category_9619681.html</a></p>\n<h2 id=\"1-拉取镜像文件\"><a href=\"#1-拉取镜像文件\" class=\"headerlink\" title=\"1.拉取镜像文件\"></a>1.拉取镜像文件</h2><p>&amp;emsp;&amp;emsp;首先我们可以通过 <code>docker search fastdfs</code> 来查询下有哪些镜像文件。</p>\n<img data-src=\"/2022/10/07/FastDFS/5a06a59eb24d4f9e847a4badeef871ac.png\" class=\"\">\n\n\n<p>&amp;emsp;&amp;emsp;我们看到搜索到的镜像还是蛮多的，这里我们使用 <code>delron/fastdfs</code> 你也可以尝试使用其他的镜像来安装，你也可以制作自己的镜像来给别人使用哦，只是不同的镜像在使用的时候配置会有一些不一样，有些镜像没有提供Nginx的相关配置，使用的时候会繁琐一点。接下来通过 <code>docker pull delron/fastdfs</code>命令把镜像拉取下来。</p>\n<pre><code class=\"shell\">docker pull delron/fastdfs\n</code></pre>\n<img data-src=\"/2022/10/07/FastDFS/5e5b85b3dc9a432abf615b27868fc7bf.png\" class=\"\">\n\n\n<h2 id=\"2-构建Tracker服务\"><a href=\"#2-构建Tracker服务\" class=\"headerlink\" title=\"2.构建Tracker服务\"></a>2.构建Tracker服务</h2><p>&amp;emsp;&amp;emsp;首先我们需要通过Docker命令来创建Tracker服务。命令为</p>\n<pre><code class=\"shell\">docker run -d --name tracker --network=host -v /mydata/fastdfs/tracker:/var/fdfs delron/fastdfs tracker\n</code></pre>\n<p>&amp;emsp;&amp;emsp;tracker服务默认的端口为22122，-v 实现了容器和本地目录的挂载操作。</p>\n<img data-src=\"/2022/10/07/FastDFS/694d42632bf6410a806df9aa43e836c0.png\" class=\"\">\n\n\n<h2 id=\"3-构建Storage服务\"><a href=\"#3-构建Storage服务\" class=\"headerlink\" title=\"3.构建Storage服务\"></a>3.构建Storage服务</h2><p>&amp;emsp;&amp;emsp;接下来创建Storage服务，具体的执行命令如下</p>\n<pre><code class=\"shell\">docker run -d --name storage --network=host  -e TRACKER_SERVER=192.168.1.195:22122 -v /mydata/fastdfs/storage:/var/fdfs -e GROUP_NAME=group1 delron/fastdfs storage\n</code></pre>\n<p>&amp;emsp;&amp;emsp;在执行上面命令的时候要注意对应的修改下，其中TRACKER_SERVER中的ip要修改为你的Tracker服务所在的服务IP地址。</p>\n<img data-src=\"/2022/10/07/FastDFS/dc2bdf85d0f24fe18a32efbe4caa2d27.png\" class=\"\">\n\n\n<p>&amp;emsp;&amp;emsp;默认情况下在Storage服务中是帮我们安装了Nginx服务的，相关的端口为</p>\n<table>\n<thead>\n<tr>\n<th>服务</th>\n<th>默认端口</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>tracker</td>\n<td>22122</td>\n</tr>\n<tr>\n<td>storage</td>\n<td>23000</td>\n</tr>\n<tr>\n<td>Nginx</td>\n<td>8888</td>\n</tr>\n</tbody></table>\n<p>&amp;emsp;&amp;emsp;当然如果你发现这些相关的端口被占用了，或者想要对应的修改端口信息也可以的。要修改你可以先进入容器中查看下相关的配置文件信息。</p>\n<img data-src=\"/2022/10/07/FastDFS/da5cc21445e840baa85580ba420db94d.png\" class=\"\">\n\n\n<p>&amp;emsp;&amp;emsp;然后查看storage.conf文件</p>\n<img data-src=\"/2022/10/07/FastDFS/63862499980b408195291de047048566.png\" class=\"\">\n\n\n<p>&amp;emsp;&amp;emsp;这个是storage监听的Nginx的端口8888，如果要修改那么我们还需要修改Nginx中的服务配置，这块的配置在 <code>/usr/local/nginx/conf</code>目录下</p>\n<img data-src=\"/2022/10/07/FastDFS/f866c08177be4fd48bfd9a582ec78779.png\" class=\"\">\n\n\n<p>&amp;emsp;&amp;emsp;查看下文件</p>\n<img data-src=\"/2022/10/07/FastDFS/dc7c5888363a400b9308f3ba64cca9ac.png\" class=\"\">\n\n\n<p>所以要修改端口号的话，这两个位置都得修改了。当然本文我们就使用默认的端口号来使用了。</p>\n<h2 id=\"4-测试图片上传\"><a href=\"#4-测试图片上传\" class=\"headerlink\" title=\"4.测试图片上传\"></a>4.测试图片上传</h2><p>&amp;emsp;&amp;emsp;好了，安装我们已经完成了，那么到底是否可以使用呢？我们来测试下。首先在虚拟机的&#x2F;mydata&#x2F;fastdfs&#x2F;storage下保存一张图片。</p>\n<img data-src=\"/2022/10/07/FastDFS/ff2ea2626bb34acd810fbb8d9438129a.png\" class=\"\">\n\n\n<p>&amp;emsp;&amp;emsp;然后我们再进入到storage容器中。并且进入到 <code>/var/fdfs</code>目录下,可以看到我们挂载的文件了</p>\n<img data-src=\"/2022/10/07/FastDFS/cb8a96fb9bb644328880ca70378a7fc2.png\" class=\"\">\n\n\n<p>&amp;emsp;&amp;emsp;然后执行如下命令即可完成图片的上传操作</p>\n<pre><code class=\"shell\">/usr/bin/fdfs_upload_file /etc/fdfs/client.conf 1.jpg\n</code></pre>\n<img data-src=\"/2022/10/07/FastDFS/0fd0e82898bb45178eca4eef9a412745.png\" class=\"\">\n\n\n<p>&amp;emsp;&amp;emsp;通过上面的提示我们看到文件上传成功了，而且返回了文件在storage中存储的信息。这时我们就可以通过这个信息来拼接访问的地址在浏览器中访问了：<span class=\"exturl\" data-url=\"aHR0cDovLzE5Mi4xNjguNTYuMTAwOjg4ODgvZ3JvdXAxL00wMC8wMC8wMC93S2c0WkdIY0tMU0FYaWJhQUFlek11VXJsUzgyMzUuanBn\">http://192.168.56.100:8888/group1/M00/00/00/wKg4ZGHcKLSAXibaAAezMuUrlS8235.jpg</span></p>\n<img data-src=\"/2022/10/07/FastDFS/b34e823e956f410297bfd1218ebc0231.png\" class=\"\">\n\n\n<p>&amp;emsp;&amp;emsp;好了到这儿FastDFS的服务安装成功了。</p>\n<h1 id=\"四、客户端操作\"><a href=\"#四、客户端操作\" class=\"headerlink\" title=\"四、客户端操作\"></a>四、客户端操作</h1><h2 id=\"1-Fastdfs-java-client\"><a href=\"#1-Fastdfs-java-client\" class=\"headerlink\" title=\"1.Fastdfs-java-client\"></a>1.Fastdfs-java-client</h2><p>&amp;emsp;&amp;emsp;首先我们来看下如何实现FastDFS中提供的JavaAPI来直接实现对应的文件上传和下载操作。</p>\n<h3 id=\"1-1-文件上传\"><a href=\"#1-1-文件上传\" class=\"headerlink\" title=\"1.1 文件上传\"></a>1.1 文件上传</h3><p>&amp;emsp;&amp;emsp;先来看下文件上传的流程</p>\n<img data-src=\"/2022/10/07/FastDFS/c1da19dbbe994f55b20371ba0806d694.png\" class=\"\">\n\n\n<p>&amp;emsp;&amp;emsp;上传流程的文字梳理为：</p>\n<ol>\n<li>客户端访问Tracker</li>\n<li>Tracker 返回Storage的ip和端口</li>\n<li>客户端直接访问Storage，把文件内容和元数据发送过去。</li>\n<li>Storage返回文件存储id。包含了组名和文件名</li>\n</ol>\n<p>&amp;emsp;&amp;emsp;首先创建一个普通的maven项目，然后引入对应的依赖</p>\n<pre><code class=\"xml\">&lt;dependencies&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;cn.bestwu&lt;/groupId&gt;\n        &lt;artifactId&gt;fastdfs-client-java&lt;/artifactId&gt;\n        &lt;version&gt;1.27&lt;/version&gt;\n    &lt;/dependency&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;\n        &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt;\n        &lt;version&gt;3.4&lt;/version&gt;\n    &lt;/dependency&gt;\n&lt;/dependencies&gt;\n</code></pre>\n<p>&amp;emsp;&amp;emsp;然后编写FastDFS的配置文件，内容如下：注意ip修改为你自己对应的ip即可</p>\n<pre><code class=\"xml\">connect_timeout = 10\nnetwork_timeout = 30\ncharset = UTF-8\nhttp.tracker_http_port = 8080\ntracker_server = 192.168.56.100:22122\n</code></pre>\n<img data-src=\"/2022/10/07/FastDFS/3c54c7b41f2a4ac2b420b65beafd10d2.png\" class=\"\">\n\n\n<p>&amp;emsp;&amp;emsp;然后导入对应的工具类，在工具类中完成了StorageClient的实例化，并提供了相关的上传和下载的方法。</p>\n<pre><code class=\"java\">package com.bobo.fastdfs.config;\n\nimport org.apache.commons.lang3.StringUtils;\nimport org.csource.common.NameValuePair;\nimport org.csource.fastdfs.*;\n\nimport java.io.*;\n\npublic class FastDFSClient &#123;\n    private static final String CONF_FILENAME = Thread.currentThread().getContextClassLoader().getResource(&quot;&quot;).getPath() + &quot;fdfs_client.conf&quot;;\n\n    private static StorageClient storageClient = null;\n\n    /**\n     * 只加载一次.\n     */\n    static &#123;\n        try &#123;\n            ClientGlobal.init(CONF_FILENAME);\n            TrackerClient trackerClient = new TrackerClient(ClientGlobal.g_tracker_group);\n            TrackerServer trackerServer = trackerClient.getConnection();\n            StorageServer storageServer = trackerClient.getStoreStorage(trackerServer);\n            storageClient = new StorageClient(trackerServer, storageServer);\n        &#125; catch (Exception e) &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n\n    /**\n     *\n     * @param inputStream\n     *    上传的文件输入流\n     * @param fileName\n     *    上传的文件原始名\n     * @return\n     */\n    public static String[] uploadFile(InputStream inputStream, String fileName) &#123;\n        try &#123;\n            // 文件的元数据\n            NameValuePair[] meta_list = new NameValuePair[2];\n            // 第一组元数据，文件的原始名称\n            meta_list[0] = new NameValuePair(&quot;file name&quot;, fileName);\n            // 第二组元数据\n            meta_list[1] = new NameValuePair(&quot;file length&quot;, inputStream.available()+&quot;&quot;);\n            // 准备字节数组\n            byte[] file_buff = null;\n            if (inputStream != null) &#123;\n                // 查看文件的长度\n                int len = inputStream.available();\n                // 创建对应长度的字节数组\n                file_buff = new byte[len];\n                // 将输入流中的字节内容，读到字节数组中。\n                inputStream.read(file_buff);\n            &#125;\n            // 上传文件。参数含义：要上传的文件的内容（使用字节数组传递），上传的文件的类型（扩展名），元数据\n            String[] fileids = storageClient.upload_file(file_buff, getFileExt(fileName), meta_list);\n            return fileids;\n        &#125; catch (Exception ex) &#123;\n            ex.printStackTrace();\n            return null;\n        &#125;\n    &#125;\n\n    /**\n     *\n     * @param file\n     *            文件\n     * @param fileName\n     *            文件名\n     * @return 返回Null则为失败\n     */\n    public static String[] uploadFile(File file, String fileName) &#123;\n        FileInputStream fis = null;\n        try &#123;\n            NameValuePair[] meta_list = null; // new NameValuePair[0];\n            fis = new FileInputStream(file);\n            byte[] file_buff = null;\n            if (fis != null) &#123;\n                int len = fis.available();\n                file_buff = new byte[len];\n                fis.read(file_buff);\n            &#125;\n\n            String[] fileids = storageClient.upload_file(file_buff, getFileExt(fileName), meta_list);\n            return fileids;\n        &#125; catch (Exception ex) &#123;\n            return null;\n        &#125;finally&#123;\n            if (fis != null)&#123;\n                try &#123;\n                    fis.close();\n                &#125; catch (IOException e) &#123;\n                    e.printStackTrace();\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n\n    /**\n     * 根据组名和远程文件名来删除一个文件\n     *\n     * @param groupName\n     *            例如 &quot;group1&quot; 如果不指定该值，默认为group1\n     * @param remoteFileName\n     *            例如&quot;M00/00/00/wKgxgk5HbLvfP86RAAAAChd9X1Y736.jpg&quot;\n     * @return 0为成功，非0为失败，具体为错误代码\n     */\n    public static int deleteFile(String groupName, String remoteFileName) &#123;\n        try &#123;\n            int result = storageClient.delete_file(groupName == null ? &quot;group1&quot; : groupName, remoteFileName);\n            return result;\n        &#125; catch (Exception ex) &#123;\n            return 0;\n        &#125;\n    &#125;\n\n    /**\n     * 修改一个已经存在的文件\n     *\n     * @param oldGroupName\n     *            旧的组名\n     * @param oldFileName\n     *            旧的文件名\n     * @param file\n     *            新文件\n     * @param fileName\n     *            新文件名\n     * @return 返回空则为失败\n     */\n    public static String[] modifyFile(String oldGroupName, String oldFileName, File file, String fileName) &#123;\n        String[] fileids = null;\n        try &#123;\n            // 先上传\n            fileids = uploadFile(file, fileName);\n            if (fileids == null) &#123;\n                return null;\n            &#125;\n            // 再删除\n            int delResult = deleteFile(oldGroupName, oldFileName);\n            if (delResult != 0) &#123;\n                return null;\n            &#125;\n        &#125; catch (Exception ex) &#123;\n            return null;\n        &#125;\n        return fileids;\n    &#125;\n\n    /**\n     * 文件下载\n     *\n     * @param groupName 卷名\n     * @param remoteFileName 文件名\n     * @return 返回一个流\n     */\n    public static InputStream downloadFile(String groupName, String remoteFileName) &#123;\n        try &#123;\n            byte[] bytes = storageClient.download_file(groupName, remoteFileName);\n            InputStream inputStream = new ByteArrayInputStream(bytes);\n            return inputStream;\n        &#125; catch (Exception ex) &#123;\n            return null;\n        &#125;\n    &#125;\n\n    public static NameValuePair[] getMetaDate(String groupName, String remoteFileName)&#123;\n        try&#123;\n            NameValuePair[] nvp = storageClient.get_metadata(groupName, remoteFileName);\n            return nvp;\n        &#125;catch(Exception ex)&#123;\n            ex.printStackTrace();\n            return null;\n        &#125;\n    &#125;\n\n    /**\n     * 获取文件后缀名（不带点）.\n     *\n     * @return 如：&quot;jpg&quot; or &quot;&quot;.\n     */\n    private static String getFileExt(String fileName) &#123;\n        if (StringUtils.isBlank(fileName) || !fileName.contains(&quot;.&quot;)) &#123;\n            return &quot;&quot;;\n        &#125; else &#123;\n            return fileName.substring(fileName.lastIndexOf(&quot;.&quot;) + 1); // 不带最后的点\n        &#125;\n    &#125;\n\n&#125;\n</code></pre>\n<p>&amp;emsp;&amp;emsp;然后我们就可以来测试上传的操作了。</p>\n<pre><code class=\"java\">    public static void main(String[] args) &#123;\n        try &#123;\n            File file = new File(&quot;D:/2.jpg&quot;);\n            InputStream is = new FileInputStream(file);\n            String fileName = UUID.randomUUID().toString()+&quot;.jpg&quot;;\n            String[] result = FastDFSClient.uploadFile(is, fileName);\n            System.out.println(Arrays.toString(result));\n        &#125; catch (Exception e) &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n</code></pre>\n<img data-src=\"/2022/10/07/FastDFS/6d7d9ff0b42e4e1daae06e47dab3793f.png\" class=\"\">\n\n\n<p>访问即可：<span class=\"exturl\" data-url=\"aHR0cDovLzE5Mi4xNjguNTYuMTAwOjg4ODgvZ3JvdXAxL00wMC8wMC8wMC93S2c0WkdIY1VFNkFaQTJVQUFXOGRJWDVwNTAzNzQuanBn\">http://192.168.56.100:8888/group1/M00/00/00/wKg4ZGHcUE6AZA2UAAW8dIX5p50374.jpg</span></p>\n<p>&amp;emsp;&amp;emsp;返回后的字符串的结构说明</p>\n<img data-src=\"/2022/10/07/FastDFS/5cec7e1344324b8dbd8050715d40b32f.png\" class=\"\">\n\n\n<h3 id=\"1-2-文件下载\"><a href=\"#1-2-文件下载\" class=\"headerlink\" title=\"1.2 文件下载\"></a>1.2 文件下载</h3><p>&amp;emsp;&amp;emsp;文件下载的流程，如下</p>\n<img data-src=\"/2022/10/07/FastDFS/04cba11544044479996f178ed8e41768.png\" class=\"\">\n\n\n<p>&amp;emsp;&amp;emsp;文件下载的流程为：</p>\n<ol>\n<li>client询问tracker需要下载的文件的storage，参数为文件的标识(group加文件名)。</li>\n<li>tracker根据客户端的参数返回一台可用的storage。</li>\n<li>client根据返回的storage直接完成对应的文件的下载。</li>\n</ol>\n<p>&amp;emsp;&amp;emsp;有了上面的基础，文件下载就非常简单了，我们只需要根据前面上传的文件的group和文件的存储路径就可以通过StorageClient中提供的downloadFile方法把对应的文件下载下来了，具体的代码如下</p>\n<pre><code class=\"java\">    /**\n     * 文件下载\n     */\n    public static void downloadFile()&#123;\n        try &#123;\n            InputStream is = FastDFSClient\n                    .downloadFile(&quot;group1&quot;, &quot;M00/00/00/wKg4ZGHcUE6AZA2UAAW8dIX5p50374.jpg&quot;);\n            OutputStream os = new FileOutputStream(new File(&quot;D:/12.jpg&quot;));\n            int index = 0 ;\n            while((index = is.read())!=-1)&#123;\n                os.write(index);\n            &#125;\n            os.flush();\n            os.close();\n            is.close();\n        &#125; catch (Exception e) &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n</code></pre>\n<p>注意：StorageClient是线程不安全的。那么我们的解决方案</p>\n<ol>\n<li>对文件的操作的每个方法我们做同步处理</li>\n<li>每次操作文件的时候我们都获取一个新的StorageClient对象</li>\n</ol>\n<p>第一种方式效率肯定是最低的，第二种方式每次都要建立新的连接效率同样的会受到影响，这时最好的方式其实是把StorageClient交给我们自定义的连接池来管理</p>\n<h2 id=\"2-SpringBoot整合\"><a href=\"#2-SpringBoot整合\" class=\"headerlink\" title=\"2.SpringBoot整合\"></a>2.SpringBoot整合</h2><p>&amp;emsp;&amp;emsp;我们在实际工作中基本都是和SpringBoot整合在一起来使用的，那么我们就来看看FastDFS是如何在SpringBoot项目中来使用的。首先创建一个普通的SpringBoot项目，然后导入fastdfs-spring-boot-starter这个依赖。</p>\n<pre><code class=\"xml\">    &lt;dependencies&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;\n            &lt;scope&gt;test&lt;/scope&gt;\n        &lt;/dependency&gt;\n\n        &lt;dependency&gt;\n            &lt;groupId&gt;com.luhuiguo&lt;/groupId&gt;\n            &lt;artifactId&gt;fastdfs-spring-boot-starter&lt;/artifactId&gt;\n            &lt;version&gt;0.2.0&lt;/version&gt;\n        &lt;/dependency&gt;\n    &lt;/dependencies&gt;\n</code></pre>\n<p>&amp;emsp;&amp;emsp;既然是一个starter，那么必然会在spring.factories文件中提供对应的自动配置类。</p>\n<img data-src=\"/2022/10/07/FastDFS/807e18ab743d4dcea0128bfc9f967a22.png\" class=\"\">\n\n\n<p>&amp;emsp;&amp;emsp;可以看到给我们提供的配置类为FdfsAutoConfiguration进入后可以看到帮我们注入了很多的核心对象。</p>\n<img data-src=\"/2022/10/07/FastDFS/74a13becccb94ff8841c542cf0b9ce98.png\" class=\"\">\n\n\n<p>&amp;emsp;&amp;emsp;然后可以看到系统提供的配置信息，前缀为 <code>fdfs</code></p>\n<img data-src=\"/2022/10/07/FastDFS/ef9e211d1145444c8b8348d2e73a6a76.png\" class=\"\">\n\n\n<p>&amp;emsp;&amp;emsp;然后我们就可以在application.properties中配置FastDFS的配置信息了。</p>\n<img data-src=\"/2022/10/07/FastDFS/aa2dde964afc4909a7214239a269b65b.png\" class=\"\">\n\n\n<p>&amp;emsp;&amp;emsp;配置完成后我们就可以测试文件的上传下载操作了</p>\n<pre><code class=\"java\">@SpringBootTest\nclass FastDfsSpringBootApplicationTests &#123;\n\n    @Autowired\n    public FastFileStorageClient storageClient;\n\n\n    @Test\n    void contextLoads() throws Exception&#123;\n        File file = new File(&quot;d:\\\\2.jpg&quot;);\n        StorePath path = storageClient.uploadFile(null,new FileInputStream(file),file.length(),file.getName());\n        System.out.println(path.getFullPath());\n    &#125;\n\n&#125;\n</code></pre>\n<p>文件操作成功</p>\n<img data-src=\"/2022/10/07/FastDFS/781603ff01b4486c8775ee45639420f4.png\" class=\"\">\n\n",
            "tags": [
                "分布式",
                "FastDFS"
            ]
        }
    ]
}