{
    "version": "https://jsonfeed.org/version/1",
    "title": "记录“美食”每刻 • All posts by \"springboot\" category",
    "description": "记录“美食”每刻",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/2022/10/07/Spring_Family/SpringBoot/",
            "url": "http://example.com/2022/10/07/Spring_Family/SpringBoot/",
            "title": "SpringBoot",
            "date_published": "2022-10-06T16:00:00.000Z",
            "content_html": "<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><h2 id=\"原有Spring优缺点分析\"><a href=\"#原有Spring优缺点分析\" class=\"headerlink\" title=\"原有Spring优缺点分析\"></a>原有Spring优缺点分析</h2><p>优点：</p>\n<blockquote>\n<p>Spring是Java企业版（JAVAEE)开发的一种相对简单的方法，通过依赖注入和面向切面编程，用简单 的Java对象实现了EJB&#x3D;&#x3D;(Enterprise Java Beans技术的简称, 又被称为企业Java Beans)&#x3D;&#x3D;的功能</p>\n</blockquote>\n<p>缺点：</p>\n<ul>\n<li>虽然Spring的组件<strong>代码是轻量级</strong>的，但它的<strong>配置却是重量级</strong>的</li>\n<li><strong>依赖管理</strong>也是一件耗时耗力的事情，会产生版本不兼容的问题</li>\n</ul>\n<h2 id=\"SpringBoot概念简介\"><a href=\"#SpringBoot概念简介\" class=\"headerlink\" title=\"SpringBoot概念简介\"></a>SpringBoot概念简介</h2><blockquote>\n<p>Spring Boot是Spring公司的一个顶级项目，和Spring Framework是一个级别的。<br>Spring Boot实际上是利用Spring Framework 4 自动配置特性完成。编写项目时不需要编写xml文件。发展到现在，Spring Boot已经具有很很大的生态圈，各种主流技术已经都提供了Spring Boot的启动器。</p>\n</blockquote>\n<h2 id=\"什么是启动器\"><a href=\"#什么是启动器\" class=\"headerlink\" title=\"什么是启动器\"></a>什么是启动器</h2><blockquote>\n<p>Spring框架在项目中作用是Spring整合各种其他技术，让其他技术使用更加方便。Spring Boot的启动器<strong>实际上就是一个依赖</strong>。这个依赖中包含了整个这个技术的相关jar包，还包含了这个技术的自动配置，以前绝大多数XML配置都不需要配置了。当然了，启动器中自动配置无法实现所有内容的自动配置，在使用Spring Boot时还需要进行少量的配置（这个配置不是在xml中了，而是在properties或yml中即可）。如果是<strong>Spring自己封装的启动器</strong>的artifact id<strong>名字满足：spring-boot-starter-<em>xxxx</em></strong>，如果是<strong>第三方公司提供的启动</strong>满足：<strong><em>xxxx</em>-spring-boot-starter</strong>。以后每次使用Spring Boot整合其他技术时首先需要考虑导入启动器。</p>\n</blockquote>\n<h1 id=\"Spring-Boot优点\"><a href=\"#Spring-Boot优点\" class=\"headerlink\" title=\"Spring Boot优点\"></a>Spring Boot优点</h1><p>①　使用Spring Boot可以创建独立的Spring应用程序<br>②　在Spring Boot中<strong>直接嵌入了Tomcat</strong>、Jetty、Undertow等Web  容器，在使用SpringBoot做Web开发时<strong>不需要部署WAR文件</strong><br>③　通过提供自己的启动器(Starter)依赖，简化项目构建配置<br>④　尽量的自动配置Spring和第三方库<br>⑤　绝对没有代码生成，也不需要XML配置文件</p>\n<h1 id=\"Spring-Boot的核心\"><a href=\"#Spring-Boot的核心\" class=\"headerlink\" title=\"Spring Boot的核心\"></a>Spring Boot的核心</h1><p><strong>起步依赖</strong>：起步依赖本质上是一个Maven项目对象模型（Project Object Model，POM），定义了对其他库的传递依赖，这些东西加在一起即支持某项功能。 简单的说，起步依赖就是将具备某种功能的坐标打包到一起，并提供一些默认的功能。</p>\n<p><strong>自动配置</strong> ：Spring Boot的自动配置是一个运行时（更准确地说，是应用程序启动时）的过程，考虑了众多因素，才决定 Spring配置应该用哪个，不该用哪个。该过程是Spring自动完成的。</p>\n<h1 id=\"启动原理分析\"><a href=\"#启动原理分析\" class=\"headerlink\" title=\"启动原理分析\"></a>启动原理分析</h1><img data-src=\"/2022/10/07/Spring_Family/SpringBoot/%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE.jpg\" class=\"\">\n\n\n\n\n<pre><code class=\"java\">static class Registrar implements ImportBeanDefinitionRegistrar, DeterminableImports &#123;\n    @Override\n    public void registerBeanDefinitions(AnnotationMetadata metadata, BeanDefinitionRegistry registry) &#123;\n        register(registry, new PackageImports(metadata).getPackageNames().toArray(new String[0]));\n    &#125;\n    @Override\n    public Set&lt;Object&gt; determineImports(AnnotationMetadata metadata) &#123;\n        return Collections.singleton(new PackageImports(metadata));\n    &#125;\n&#125;\n</code></pre>\n<p>将配置类@SpringBootApplication标注的类所在包及下面所有子包里的所有组件扫描到spring容器</p>\n<pre><code class=\"java\">protected List&lt;String&gt; getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes) &#123;\n        List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(getSpringFactoriesLoaderFactoryClass(),\n                getBeanClassLoader());\n        Assert.notEmpty(configurations, &quot;No auto configuration classes found in META-INF/spring.factories. If you &quot;\n                + &quot;are using a custom packaging, make sure that file is correct.&quot;);\n        return configurations;\n    &#125;\n</code></pre>\n<p><strong>通过 getCandidateConfigurations读取自带的配置文件，得到他们的全路径名，通过反射创建他们</strong></p>\n<h1 id=\"异常处理和拦截器\"><a href=\"#异常处理和拦截器\" class=\"headerlink\" title=\"异常处理和拦截器\"></a>异常处理和拦截器</h1><p><strong>均与SpringMVC中处理一致</strong></p>\n<h1 id=\"分页\"><a href=\"#分页\" class=\"headerlink\" title=\"分页\"></a>分页</h1><p>主要参数：</p>\n<p>当前页 、一页n个(每页的数量)、 总条数</p>\n<h2 id=\"属性介绍\"><a href=\"#属性介绍\" class=\"headerlink\" title=\"属性介绍\"></a>属性介绍</h2><table>\n<thead>\n<tr>\n<th align=\"center\">属性名</th>\n<th align=\"center\">类型</th>\n<th align=\"center\">默认值</th>\n<th align=\"center\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">overflow</td>\n<td align=\"center\">boolean</td>\n<td align=\"center\">false</td>\n<td align=\"center\">溢出总页数后是否进行处理<br/>(默认不处理,参见 <code>插件#continuePage</code> 方法)</td>\n</tr>\n<tr>\n<td align=\"center\">maxLimit</td>\n<td align=\"center\">Long</td>\n<td align=\"center\"></td>\n<td align=\"center\">单页分页条数限制<br/>(默认无限制,参见 <code>插件#handlerLimit</code> 方法)</td>\n</tr>\n<tr>\n<td align=\"center\">dbType</td>\n<td align=\"center\">DbType</td>\n<td align=\"center\"></td>\n<td align=\"center\">数据库类型<br/>(根据类型获取应使用的分页方言,参见 <code>插件#findIDialect</code> 方法)</td>\n</tr>\n<tr>\n<td align=\"center\">dialect</td>\n<td align=\"center\">IDialect</td>\n<td align=\"center\"></td>\n<td align=\"center\">方言实现类<br/>(参见 <code>插件#findIDialect</code> 方法)</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>建议单一数据库类型的均设置 dbType</p>\n</blockquote>\n<pre><code class=\"java\">    @GetMapping(&quot;/test&quot;)\n    public Response test()&#123;\n        Page&lt;Produce&gt; producePage = new Page&lt;&gt;(1,1);\n        Page&lt;Produce&gt; page = produceService.page(producePage);\n        System.out.println(producePage == page);\n        List&lt;Produce&gt; records = page.getRecords();\n        for (Produce record : records) &#123;\n            System.out.println(record);\n        &#125;\n        return new Response&lt;&gt;(records, ResultEnum.SUCCESS);\n    &#125;\n</code></pre>\n<img data-src=\"/2022/10/07/Spring_Family/SpringBoot/656c18aaaf9ed11fee9b9f1576cc840f.png\" class=\"\">\n\n\n<p>默认是会查询总条数，都有get、set方法，可以根据自己的需求设置（点开Page类看看）</p>\n<img data-src=\"/2022/10/07/Spring_Family/SpringBoot/d0e0280ca8a9d46a4a41c4a1de89ab3c.png\" class=\"\">\n\n\n\n\n\n\n\n\n\n\n<h1 id=\"项目打包和部署\"><a href=\"#项目打包和部署\" class=\"headerlink\" title=\"项目打包和部署\"></a>项目打包和部署</h1><h2 id=\"打包\"><a href=\"#打包\" class=\"headerlink\" title=\"打包\"></a>打包</h2><p>SpringBoot项目打包在linux服务器中运行:<br>    ①jar类型项目会打成jar包:<br>    jar类型项目使用SpringBoot打包插件打包时，会在打成的jar中内置一个tomcat的jar。所以我们可以使用jdk直接运行该jar项目可，jar项目中有一个功能，将功能代码放到其内置的tomcat中运行。我们直接使用浏览器访问即可。<br>    ②war类型项目会打成war包:<br>    在打包时需要将内置的tomcat插件排除，配置servlet的依赖。将war正常的放到tomcat服务器中运行即可。</p>\n<img data-src=\"/2022/10/07/Spring_Family/SpringBoot/image-20220718170542347.png\" class=\"\">\n\n\n<h2 id=\"部署\"><a href=\"#部署\" class=\"headerlink\" title=\"部署\"></a>部署</h2><p><strong>注：这里是部署到Tomcat（war），jar直接编译启动</strong></p>\n<h3 id=\"第一步：\"><a href=\"#第一步：\" class=\"headerlink\" title=\"第一步：\"></a>第一步：</h3><pre><code>在部署到Tomcat 之前我们要将我们项目中的Tomcat(==它在Web中==)去掉，但是我们在项目中又有可能要使用他提供的jar包 HttpServlet 之类的，所以我们还需要再将它手动导入，但是他不需要他打包。\n</code></pre>\n<pre><code class=\"xml\">&lt;!--配置SpringBoot的web启动器--&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;\n    &lt;!--排除web启动中自动依赖的tomcat插件--&gt;\n    &lt;exclusions&gt;\n        &lt;exclusion&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;\n        &lt;/exclusion&gt;\n    &lt;/exclusions&gt;\n&lt;/dependency&gt;\n\n&lt;!--\n    手动依赖tomcat插件，但是表明项目打包时该依赖不会被打进去，目的主要是保证开发阶段本地SpringBoot\n    项目可以正常运行\n--&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;\n    &lt;!--打包的时候可以不用包进去，别的设施会提供。事实上该依赖理论上可以参与编译，测试，运行等周期。\n        相当于compile，但是打包阶段做了exclude操作--&gt;\n    &lt;scope&gt;provided&lt;/scope&gt;\n&lt;/dependency&gt;\n</code></pre>\n<h3 id=\"第二步：\"><a href=\"#第二步：\" class=\"headerlink\" title=\"第二步：\"></a>第二步：</h3><p>SpringBoot的<strong>启动类继承SpringBootServletInitializer</strong>，并<strong>重写configure</strong></p>\n<pre><code class=\"java\">@SpringBootApplication\npublic class MyApplication extends SpringBootServletInitializer &#123;\n    //重写配置方法\n    @Override\n    protected SpringApplicationBuilder configure(SpringApplicationBuilder application) &#123;\n        return application.sources(MyApplication.class);\n    &#125;\n    public static void main(String[] args) &#123;\n        //启动SpringBoot\n        SpringApplication.run(MyApplication.class,args);\n    &#125;\n&#125;\n</code></pre>\n<p>使用package命令打包项目，并将war包放到tomcat下的webapps下，启动tomcat即可。</p>\n<h3 id=\"注：\"><a href=\"#注：\" class=\"headerlink\" title=\"注：\"></a>注：</h3><ul>\n<li>部署到tomcat之后我们的URL就会变化，tomcat会自动编译war包，我们的<strong>项目名和war包同名</strong>，所以不想改变提前修改</li>\n<li><strong>端口号也是tomcat的端口号</strong>（tomcat&#x2F;conf&#x2F;server.xml）</li>\n</ul>\n<h1 id=\"面试题\"><a href=\"#面试题\" class=\"headerlink\" title=\"面试题\"></a>面试题</h1><h2 id=\"SpringBoot约定大于配置理解\"><a href=\"#SpringBoot约定大于配置理解\" class=\"headerlink\" title=\"SpringBoot约定大于配置理解\"></a>SpringBoot约定大于配置理解</h2><p>约定大于配置是一种开发原则，就是减少人为的配置，直接用默认的配置就能获得我们想要的结果。<br>　　SpringBoot的约定大于配置，按我的理解是：对比SpringMVC，需要在web.xml里面配置前端控制器，还需要在核心配置文件（*-servlet.xml）中配置视图解析器啥的，更要配置第三方的Tomcat服务器。而SpringBoot就不需要我们配置这些，他内嵌了Tomcat服务器，我们只需要在Maven配置文件（Pom.xml）里面导入SpringMVC所需要的依赖就可以了。<br>　　这就是SpringBoot的优势，在传统所需要配置的地方，SpringBoot都进行了约定（配置好了），开发人员能配置得更少，更直接地开发项目，写业务逻辑代码。<br>spring boot和maven的约定大于配置体现 点：<br>　　1.maven的目录文件结构<br>　　1）默认有resources文件夹,存放资源配置文件。src-main-resources,src-main-java<br>默认的编译生成的类都在targetwen。<br>　　2）默认有target文件夹，将生成class文件盒编程生成的jar存放在target文件夹下</p>\n<p>2.spring boot默认的配置文件必须是，也只能是application.命名的yml文件或者properties文件，且唯一</p>\n<p>1）spring boot默认只会去src-main-resources文件夹下去找application配置文件</p>\n<p>这个问题呢，我从四个方面来回答。</p>\n<p>首先，约定优于配置是一种软件设计的范式，它的核心思想，是减少软件开发人员对于配置项的。从而让开发人员更加聚焦在业务逻辑上</p>\n<p>第二个呢，Spring boot就是约定优于配置这一理念下的产物，它类似于spring框架下的一个脚手架，通过spring boot，我们可以快速开发基于spring生态下的应用程序。基于传统的spring框架开发web应用的时候，我们需要做很多和业务无关，并且只需要做一次的配置项，比如</p>\n<ol>\n<li><p>管理架包的依赖</p>\n</li>\n<li><p>web.xml的维护</p>\n</li>\n<li><p>spring MVC中的一个叫 Dispatch-Servlet.x ml 配置项的一个维护</p>\n</li>\n<li><p>应用需要自己手动去部署到web容器</p>\n</li>\n<li><p>第三方组件集成到spring IOC容器中，我们需要做配置项的维护</p>\n</li>\n</ol>\n<p>而在SpringBoot中，我们不再需要去做这些繁琐的配置，因为SpringBoot已经帮我们自动完成了，而完成这样一个动作的前提就是基于&#x3D;&#x3D;约定优于配置&#x3D;&#x3D;这样一个思想。</p>\n<p>最后呢，Spring boot约定优于配置的体现有很多，</p>\n<p>比如第一个spring boat start启动依赖，它能够帮助我们管理所有的jar包版本。</p>\n<p>第二个，如果当前的应用依赖了web这样一个 jar 包，那么spring boot会自动内置Tomcat，他们看着容器来去运行web应用，我们不再需要去单独进行应用部署。</p>\n<p>第三，Spring boot的自动装配机制的实现中，通过扫描约定路径下的spring.factory文件去进行识别配置类，从而去实现类的自动装载</p>\n<p>第四，Spring boot？默认会加载resource目录下的application.property文件。总的来说啊，约定优于配置呢，是一个比较常见的软件设计思想，它的核心本质都是为了去更加高效，以及更加便捷的去实现软件系统的开发和维护。</p>\n<p><strong>自我总结：</strong></p>\n<p>​\t约定大于配置，不是说我们要设定啥，原来规定的是什么就不能改变，不是这个意思。他真正的意思是说当我们配置某个选项时，springboot会自动帮我们加载可能会与其相关的配置，就好比我们应用依赖了 web，那么spring boot会自动内置Tomcat，他们看着容器来去运行web应用，我们不再需要去单独进行应用部署。</p>\n<p>​\t总的来说啊，约定优于配置呢，是一个比较常见的软件设计思想，它的核心本质都是为了去更加高效，以及更加便捷的去实现软件系统的开发和维护。</p>\n\n<div id=\"gitalk-container\"></div>\n<script src=\"https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js\"></script><link rel=\"stylesheet\" href=\"https://unpkg.com/gitalk/dist/gitalk.css\"><script src=\"https://unpkg.com/gitalk/dist/gitalk.min.js\"></script>\n\n\t\t<script>\n\t\tvar gitalkConfig = {\"clientID\":\"eda74f740080fa01d0b5\",\"clientSecret\":\"c994dd2162a1dadaefbf078fcab49361438a7aca\",\"repo\":\"comments001\",\"owner\":\"onlymarryu\",\"admin\":[\"onlymarryu\"],\"distractionFreeMode\":true,\"proxy\":\"https://winter-rain-5b30.wudu-bk.workers.dev\"};\n\t    gitalkConfig.id = md5(location.pathname);\n\t\tvar gitalk = new Gitalk(gitalkConfig);\n\t    gitalk.render(\"gitalk-container\");\n\t    </script>",
            "tags": [
                "框架",
                "Spring",
                "SpringBoot"
            ]
        }
    ]
}