---
title: JVM突击版
date: 2023-1-12
categories: 
  - 面试
tags:
  - JVM
  - 面试
---

## 什么是JVM

JVM是java代码运行的平台，他帮助我们的代码一次编译到处运行

## 类加载过程

字节码 ——> ClassLoader 类加载 ——> Linking （ 格式检查、 静态成员变量附默认值、resolution[符号引用——> 直接引用]）——> init 初始化 ——>  UIsing 对象使用  ——>  GC 回收

## 双亲委派是什么？

我们在加载一个类对象的时候，要经过类加载器。

类加载器分为 4种 ，分别为：自定义类加载器（ConsumerClassLoader）、系统类加载器（APP）【classpath】、扩展类加载器（ex）【找的是 JAVA_HOME/jre/lib】、启动类加载器（bootstrap）【找的是 JAVA_HOME/lib】

我们加载的时候，一般都是从最下方的自定义加载器向上查找到启动类加载器，当然前提是有自定义类加载器，加载过程中会首先判断这个类加载器是否能存在这个类的缓存，存在就直接返回结果，不存在它就会向上委托，交由上层加载器加载，直至启动类加载器，如果这里也没有缓存，就要自己生成了，这时候启动类加载器就开始判断他是否可以生成，能生成就直接返回结果即可，不能生成就委托与下层加载器，直至生成，如果最后了都没找到可以生成这个类的类加载器就返回`Class Not Found Exception`

## 如何打破双亲委派？

JDK1.2之前，自定义ClassLoader都必须重写loadClass()

ThreadContextClassLoader可以实现基础类调用实现类代码，通过thread.setContextClassLoader指定

简单来说就是用自定义的ClassLoader即可，但是大多是情况不建议打破

## JVM的内存模型

1. PC 程序计数器：记录程序运行到哪里一步，只增不减

2. JVM栈：存储基本类型和引用地址

3. 本地方法栈（不关注）

4. 堆：存储所有的引用类型

5. 方法区：

    * 在 jdk  <=  1.7 ：永久区，永久代

        本质上，方法区和永久代并不等价，永久代的数据在FUllGC也会删除，他不会，所以会导致OOM。

        大小启动的时候指定，不能变

    * 在 jdk  》  1.8 ：元数据区，元空间

        元空间不再虚拟机设置的内存当中，而是使用本地内存。在FULLGC也会删除。

        不设定的话，最大就是物理内存

## JVM中那些是线程独享，那些是共享的？

1. JVM中 每个线程都有一个PC、JVM stack 、NMS
2. JVM中 所有线程共享 ：堆内存，方法区

## 永久区和元空间的区别

1. 字符串常量池——> 永久代有；元空间 没有，放在了堆内存中
2. GC——>永久代不会被FullGC  ; 会被FUGC
3. 内存：永久代启动时设定，且不能改；元空间时代不设定最大就是物理内存

## 如何确定一个垃圾

如果这个内存没有任何的引用，他就是一个垃圾

9. 确认垃圾的方式
    1. 根的可达性分析
    2. 引用计数法

解释：

* 根的可达性分析，可选择作为根的：

    (1). [虚拟机](https://so.csdn.net/so/search?q=虚拟机&spm=1001.2101.3001.7020)栈（栈帧中的局部变量区，也叫做局部变量表）中引用的对象。

    (2). 方法区中的类静态属性引用的对象。

    (3). 方法区中常量引用的对象。

    (4). 本地方法栈中JNI([Native](https://so.csdn.net/so/search?q=Native&spm=1001.2101.3001.7020)方法)引用的对象。

    **基本思路**：通过一系列名为”GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链(Reference Chain)，当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的

* 引用计数法

    其实就是去看这个对象是否被引用没有被引用那就是垃圾，最简单的

## 常见的垃圾回收算法

1. 标记清除
2. 标记复制算法
3. 标记整理

具体解释：

* 标记清除

    标记清除简单来看就是两步，标记和清除，是垃圾就标记，然后清理掉，简单粗暴，但是有个问题就是导致我们的空间碎片化，位置不连续。

* 标记复制算法

    同样两步，这个标记前将我们的空间分成两部分，将垃圾和非垃圾的标记出来，然后分别放入我们之前划分好的空间，这样就避免了空间碎片化的问题，但是有一个新问题，我们浪费了空间。

* 标记整理、标记压缩

    步骤同复制算法一致，但是后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。

    其实上述过程相对"复制算法"来讲，少了一个"保留区，但是要多出一个临时空间，要保证被使用的对象要存活。老年代一般不这样做。







## JVM内存分代模型

新生代（Eden + 2 survive ） 	； 老年代				；永久区/元空间

> 提示：在记忆的时候，我们可以联想诺亚方舟的故事，Eden(伊甸园)是最初的世界，GC是洪水，老年代是洪水过后的世界

解释：

* 新生代
    1. 一个Eden区，2个survive区{**8:1:1**}，存储的时候现在Eden区（**如果对象过大，直接去老年代**）
    2. 经过YGC后活着的对象进入第 1 个survive区
    3. 再次YGC后活着的对象进入第 2 个survive区
    4. 进入老年代
        1. **动态对象年龄判定**	如果Survivor区中相同年龄所有对象的大小总和大于Survivor区空间一半，年龄大于或者等于该年龄的对象在MinorGC时将复制到老年代
        2. **空间分配担保**，当YGC时，如果存活对象过多，无法完全放入Survivor区，就会向老年代借用内存存放对象，已完成YGC
        3. **长期存活的对象将进入到老年代**（***\*虚拟机设置值，默认阈值为15\****）

* 老年代

    在空间满了之后，会执行FGC

注意：要尽量减少FGC次数





## 常见的垃圾回收器

1. 串行回收器(Serial/SerialOld)

     它是一种单线程收集器，不仅仅意味着它只会使用一个CPU或者一条收集线程去完成垃圾收集工作，更重要的是其在进行垃圾收集的时候需要暂停其他线程

2. 并行回收器(Parallel/ParallelOld)

     **可以把这个收集器理解为Serial收集器的多线程版本。**

3. 并发回收器(PN/CMS)

    采取的是"标记-清除算法"，整个过程分为四步：

    (1)初始标记 CMS initial mark					标记GC Roots直接关联对象，不用Tracing，速度很快

    (2)并发标记 CMS concurrent mark		   进行GC Roots Tracing

    (3)重新标记CMS remark								修改并发标记因用户程序变动的内容

    (4)并发清除CMS concurrent sweep 			清除不可达对象回收空间，同时有新垃圾产生，留着下次清理称为

    ​																				 浮动垃圾

    整个过程中，并发标记和并发编程，收集器线程可以与用户线程一起工作，所以总体来说，CMS收集器的内存回收过程是与用户线程一起并发的执行。

4. G1

    算法：三色标记 + SATB

5. ZGC

    算法：ColoredPointers + LoadBarrier

6. Shenandoah

    算法：ColoredPointers + WriteBarrier

7. Eplison



## JVM内存分代模型是逻辑分代还是物理分代

除Epsilon 、ZGC 、Shenandoah之外的GC都是使用逻辑分代模型

G1是逻辑分代，物理不分代

除此之外不仅逻辑分代，而且物理分代



## 垃圾收集器跟内存大小的关系

1. Serial 几十兆
2. PS 上百兆 - 几个G
3. CMS - 20G
4. G1 - 上百G
5. ZGC - 4T - 16T（JDK13）

1.8默认的垃圾回收：PS + ParallelOld

