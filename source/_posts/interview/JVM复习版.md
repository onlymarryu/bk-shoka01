---
title: JVM复习版
date: 2023-1-2
categories: 
  - 面试
tags:
  - JVM
  - 面试
---


# JVM




![image-20220821204809060](新建文本文档/image-20220821204809060.png)

![image-20220907231623467](新建文本文档/image-20220907231623467.png)

1、方法区

线程共享，方法区是逻辑上堆的一部分，虚拟机有一个在所有Java虚拟机线程之间共享的方法区。

运行时常量池、字段和方法数据，以及方法和构造函数的代码，包括类和实例初始化和接口初始化中使用的特殊方法。

如果方法区域中的内存无法满足分配请求，Java 虚拟机将抛出一个OutOfMemoryError

2、堆（虚拟机中最大的一块）

线程共享

堆是为所有类实例和数组分配内存的运行时数据区域。

内存不足OutOfMemoryError

3、java虚拟机栈				执行java方法								线程私有		深度不够时，Stack OverflowError

4、本地方法栈					执行本地方法（C++）			

5、程序计数器					记录程序执行到的位置			线程私有		深度不够时，Stack OverflowError

![image-20220907232658406](新建文本文档/image-20220907232658406.png)

栈帧代表一个方法的运行，他的结构如图所示：

![image-20220907233019604](新建文本文档/image-20220907233019604.png)

==还少一个附加信息==

**附加信息：栈帧的高度  +  虚拟机版本信息**

**栈帧信息：附加信息  +  动态链接  + 方法的返回地址** 

**局部变量表：方法中定义的局部变量以及方法的参数都会存放在这张表中，单纯的存储单元**

**操作数栈：以压栈以及出栈的方式存储操作数**

int a = 1;

int b = 1;

int c = a + b;

将a，b从表中拿出来，然后将c返回到表中

**方法的返回地址：当你一个方法执行的时候，只有两种方法可以退出**

* 遇到方法的返回字节码指令
* 出现异常，有异常处理，则交给异常处理器，没有就抛出异常

**动态链接：动态链接将这些符号方法引用转换为具体的方法引用，简单来说，符号引用转变为直接引用**

```java
void a() {
    b();
}
void b() {
    c();
}
void c() {}
// 如果调用a()最终执行的是c()
```

**但是这里有个问题，符号引用转变为直接引用，我们在类加载的时候已经做过了，为什么又要来一次？**

> 这是因为我们java的多态，我们在刚开始的时候并不知道，具体的实现方法，要在我们运行的过程中，
> 才能知道，我们运用的是哪一个，所以我们这个时候会再来一次 “符号的引用转变为直接引用”



### 类加载机制

![image-20220907201636552](新建文本文档/image-20220907201636552.png)

类加载机制其实就是虚拟机把Class文件加载到内存并对数据进行校验，转换解析和初始化，形成可以虚拟机直接使用的Java类型，即java.lang.Class

1、装载

Class文件 ——> 二进制字节流 ——> 类加载器

1）通过一个类的全限定名获取这个类的二进制字节流

2）将这个字节流所代表的静态存储结构转换成为方法区的运行时数据结构

3）在Java堆中生成一个代表这个类的Java.lang.Class对象，作为我们方法区得数据访问入口

2、链接

1）验证，保证我们类加载的正确性

* 文件格式的验证（这一步其实在我们我们装载的时候进行）
* 元数据验证
* 字节码验证
* 符号引用验证

2）准备

为==类的静态变量分配内存==，并将其初始化为当前类型的==默认值==

3）解析

解析是从运行时常量池中的符号引用动态确定具体指的过程。

把类中的符号引用转换成直接引用

3、初始化

执行到Clinit方法，为静态变量赋值，初始化静态代码块，初始化当前类的父类。



### 类加载器

![image-20220907203357976](新建文本文档/image-20220907203357976.png)

启动类加载器、扩展类加载器、系统加载器、自定义加载器

### 双亲委派机制

原名叫：父类委托机制

![image-20220907182221718](新建文本文档/image-20220907182221718.png)





### 打破双亲委派机制

1.复写		重写classloader

2.SPI			Service Provider Interface      服务提供接口

可插拔设计，可以随时替换实现

3.OSGI 		热部署，热更新



### 对象的创建过程

1、对象类的加载——> ClassLoader

​	load

​	link(verification[检验是否符合标准],preparation[对对象附默认值],resolution[做解析])

​	initializing(类的初始化) -> 静态变量附默认值，并执行静态语句块

2、申请对象内存

3、成员变量附默认值

4、调用构造方法

​	成员变量顺序附初始值

​	执行构造方法语句

![img](新建文本文档/20210714084921294.png)

### 为什么要把堆和栈区分出来呢？栈中不是也可以存储数据吗？

**栈是运行时的单位，而堆是存储的单位。**

栈解决程序的运行问题，即程序如何执行，或者说如何处理数据；堆解决的是数据存储的问题，即数据怎么放、放在哪儿。

在Java中一个线程就会相应有一个线程栈与之对应，这点很容易理解，因为不同的线程执行逻辑有所不同，因此需要一个独立的线程栈。而堆则是所有线程共享的。栈因为是运行单位，因此里面存储的信息都是跟当前线程（或程序）相关信息的。包括局部变量、程序运行状态、方法返回值等等；而堆只负责存储对象信息。

 

1、从软件设计的角度看，栈代表了处理逻辑，而堆代表了数据。这样分开，使得处理逻辑更为清晰。分而治之的思想。这种隔离、模块化的思想在软件设计的方方面面都有体现。

2、 堆与栈的分离，使得堆中的内容可以被多个栈共享（也可以理解为多个线程访问同一个对象）。这种共享的收益是很多的。一方面这种共享提供了一种有效的数据交互方式(如：共享内存)，另一方面，堆中的共享常量和缓存可以被所有栈访问，节省了空间。

3、栈因为运行时的需要，比如保存系统运行的上下文，需要进行地址段的划分。由于栈只能向上增长，因此就会限制住栈存储内容的能力。而堆不同，堆中的对象是可以根据需要动态增长的，因此栈和堆的拆分，使得动态增长成为可能，相应栈中只需记录堆中的一个地址即可。

4、 面向对象就是堆和栈的完美结合。其实，面向对象方式的程序与以前结构化的程序在执行上没有任何区别。但是，面向对象的引入，使得对待问题的思考方式发生了改变，而更接近于自然方式的思考。当我们把对象拆开，你会发现，对象的属性其实就是数据，存放在堆中；而对象的行为（方法），就是运行逻辑，放在栈中。我们在编写对象的时候，其实即编写了数据结构，也编写的处理数据的逻辑。不得不承认，面向对象的设计，确实很美。

### 为什么不把基本类型放堆中呢？

因为其占用的空间一般是1~8个字节——需要空间比较少，而且因为是基本类型，所以不会出现动态增长的情况——长度固定，因此栈中存储就够了，如果把他存在堆中是没有什么意义的。可以这么说，基本类型和对象的引用都是存放在栈中，而且都是几个字节的一个数，因此在程序运行时，他们的处理方式是统一的。但是基本类型、对象引用和对象本身就有所区别了，因为一个是栈中的数据一个是堆中的数据。最常见的一个问题就是，Java中参数传递时的问题。

### 堆中存什么？栈中存什么？

堆中存的是对象。栈中存的是基本数据类型和堆中对象的引用。一个对象的大小是不可估计的，或者说是可以动态变化的，但是在栈中，一个对象只对应了一个4btye的引用（堆栈分离的好处：）。

 

### Java中的参数传递时传值呢？还是传引用？

参数是基本数据类型  -》按值传递  

参数是引用类型  —— 》 按引用传递 

注意String是个坑 ，他是值传递但是引用数据类型



### 为什么需要JVM

1、JVM可以帮助我们屏蔽底层的操作系统，一次编译，到处运行。

2、JVM可以运行Class文件

![image-20220907171924496](新建文本文档/image-20220907171924496.png)

![image-20220907171933089](新建文本文档/image-20220907171933089.png)



### JDK，JRE，JVM的关系

![image-20220907171654044](新建文本文档/image-20220907171654044.png)



### 我们的编译器到底干了什么

仅仅是将我们的 .java 文件转换成了 .class文件  ，实际上就是文件格式化的转换，对等信息转换

![image-20220907175840054](新建文本文档/image-20220907175840054.png)



### 对象被判定为不可达对象之后就死了吗？

<img src="../../../../../../面试/面试题/面试题_img/image-20220907183347727.png" alt="image-20220907183347727" style="zoom:150%;" />

finalize()只能调用一次

根：GC_Root



### Java堆进行分代处理

![image-20220907171502725](新建文本文档/image-20220907171502725.png)



### 为什么Eden：S0：S1是8:1:1

98%的对象都是朝生夕死，在一块业务用一下，就等着死亡，比如我们new Radom() 用完就结束了。

eden区越小越容易发送young区GC，消耗性能

### 老年代的担保机制

Eden区有一个域值，如果对象超过Eden区的域值，他就直接进入到了Old区，年轻代扛不住。



### 如何确定一个对象是垃圾

* 引用计数法

​    **对于某个对象而言，只要应用程序中持有该对象的引用，就说明该对象不是垃圾，如果一个对象没有任何指针对其引用，它就是垃圾。**

==弊端:如果AB相互持有引用，导致永远不能被回收。== （很少用了）

![image-20220907231345316](新建文本文档/image-20220907231345316.png)

循环使用，导致我们永远不能被回收。循环引用，内存泄漏，最终导致内存占用越来越多，导致内存溢出



* 可达性分析/跟搜索算法

通过GC_Root的对象(==活跃的引用，不是对象==)，开始向下搜找，看某个对象是否可达

![image-20220907200320553](新建文本文档/image-20220907200320553.png)

能够作为GC_Root：

​	类加载器、Thread、虚拟机栈的本地变量表、static成员、常量引用、本地方法栈的变量等。

> 虚拟机栈（栈帧中的本地变量表)中引用的对象。方法区中类静态属性引用的对象。
> 方法区中常量引用的对象。
> 本地方法核中NI（即一般说的Native方法）引用的对象



### 垃圾收集器分类

* 串行收集器->Serial和Serial Old

**只能有一个垃圾回收线程执行，用户线程暂停。**

> 适用于内存比较小的嵌入式设备。

* 并行收集器[吞吐量优先]->Parallel Scanvenge、Parallel Old

**多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。**

> 适用于科学计算、后台处理等若交互场景。

* 并发收集器[停顿时间优先]->CMS、G1

**用户线程和垃圾收集线程同时执行(但并不一定是并行的，可能是交替执行的)，垃圾收集线程在执行的时候不会停顿用户线程的运行。**

> 适用于相对时间有要求的场景，比知web。



### 吞吐量和停顿时间

* 停顿时间->垃圾收集器进行垃圾回收终端应用执行响应的时间

* 吞吐量->运行用户代码时间/(运行用户代码时间+垃圾收集时间)

> 停顿时间越短就越适合需要和用户交互的程序，良好的响应速度能提升用户体验;
>
> 高吞吐量则可以高效地利用cPu时间，尽快完成程序的运算任务，主要适洽在后台运算而不需要太多交互的任务。

小结:这两个指标也是评价垃圾回收器好处的标准。

### 垃圾收集算法

> 已经能够确定一个对象为垃圾之后，接下来要考虑的就是回收，怎么回收呢?得要有对应的算法，下面介绍常见的垃圾回收算法。

### 标记-清除(Mark-Sweep)

* 标记
    **找出内存中需要回收的对象，并且把它们标记出来**

    此时堆中所有的对象都会被扫描一遍，从而才能确定需要回收的对象，比较耗时

    ![image-20220907180008076](新建文本文档/image-20220907180008076.png)

* 清除

    清除掉被标记需要回收的对象，释放出对应的内存空间

    ![image-20220907180045044](新建文本文档/image-20220907180045044.png)

**缺点：**

> ​	标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。
>
> (1)标记和清除两个过程都比较耗时,效率不高
>
> (2)会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。



### 标记-复制算法(Mark-Copying)

将内存划分为两块相等的区域，每次只使用其中一块，如下图所示:

![image-20220907180404320](新建文本文档/image-20220907180404320.png)

当其中一块内存使用完了，就将还存活的对象复制到另外一块上面，然后把已经使用过的内存空间一次清除掉。

![image-20220907180425740](新建文本文档/image-20220907180425740.png)

**缺点：空间利用率低**



### 标记-整理(Mark-Compact)

> 复制收集算法在对象存活率较高时就要进行较多的复制操作，效率将会变低。更关键的是，如果不想浪费50%的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都有100%存活的极端情况，所以老年代一般不能直接选用这种算法。

**标记过程仍然与"标记-清除"算法一样，但是后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。**

其实上述过程相对"复制算法"来讲，少了一个"保留区

![image-20220907180607386](新建文本文档/image-20220907180607386.png)

让所有存活的对象都向一端移动，清除掉边界以外的内存

![image-20220907180726882](新建文本文档/image-20220907180726882.png)



### 分代收集算法

既然上面介绍了 3 种垃圾收集算法，那么在堆内存中到底用哪一个呢？

Young区：复制算法(对象在被分配之后，可能生命周期比较短，young区复制效率比较高)

Old	  区：标记清除或者标记整理(Old区对象存活时间比较长，复制来复制去没有必要，不如做个标记然后清除)





### ZGC

官网: https://docs.oracle.com/en/java/javase/11/gctuning/z-garbage-collector1.html#GUID-A5A42691-095E-47BA-B6DC-FB4E5FAA43DO

​	JDK11新引入的ZGC收集器，不管是物理上还是逻辑上，ZGC中已经不存在新老年代的概念了会分为一个个page，当进行GC操作时会对page进行压缩，因此没有碎片问题，只能在64位的linux上使用，目前用得还比较少。

**(1）可以达到10ms以内的停顿时间要求**
**(2)支持TB级别的内存**
**(3）堆内存变大后停顿时间还是在10ms以内**



### 垃圾收集器

![image-20220907200720387](新建文本文档/image-20220907200720387.png)

### Serial系列

​	**Serial收集器是最基本、发展历史最悠久的收集器，曾经（在JDK1.3.1之前)是虚拟机新生代收集的唯一选择。**

​	**它是一种单线程收集器，不仅仅意味着它只会使用一个CPU或者一条收集线程去完成垃圾收集工作，更重要的是其在进行垃圾收集的时候需要暂停其他线程。**

> 优点：简单高效,拥有很高的单线程收集效率缺点:收集过程需要暂停所有线程
>
> **算法：复制算法**
>
> 应用：client模式下的默认新生代收集器
>
> 适用范围：新生代

![image-20220907175127639](新建文本文档/image-20220907175127639.png)

* serial Old

    Serial Old收集器是Serial收集器的老年代版本，也是一个单线程收集器，不同的是采用**"标记-整理算法”**，运行过程和Serial收集器一样。

    ![image-20220907174807758](新建文本文档/image-20220907174807758.png)





### Parallel系列垃圾收集器

* ParNew
    **可以把这个收集器理解为Serial收集器的多线程版本。**

    > 重点：关注停顿时间
    >
    > 优点：在多CPU时,比Serial效率高。
    >
    > 缺点：收集过程暂停所有应用程序线程，单cPU时比Serial效率差。算法:复制算法
    >
    > 应用：运行在Server模式下的虚拟机中首选的新生代收集器
    >
    > 适用范围：新生代

    ![image-20220907174604135](新建文本文档/image-20220907174604135.png)

* Parallel Scavenge
    **Parallel Scavenge收集器是一个新生代收集器，它也是使用复制算法的收集器，又是并行的多线程收集器，看上去和ParNew一样，但是Parallel Scanvenge更关注系统的吞吐量。**

> 吞吐量 = 运行用户代码的时间/(运行用户代码的时间+垃圾收集时间)
>
> 比如虚拟机总共运行了100分钟，垃圾收集时间用了1分钟，吞吐量=(100-1)/100=99%。
>
> 若吞吐量越大，意味着垃圾收集的时间越短，则用户代码可以充分利用CPU资源，尽快完成程序的运算任务。

-XX:MaxGCPauseMillis			控制最大的垃圾收集停顿时间，
-XX:GCRatio								直接设置吞吐量的大小。

* Parallel Old

    **Parallel Old收集器是Parallel Scavenge收集器的老年代版本，使用多线程和标记-整理算法进行垃圾回收，也是更加关注系统的吞吐量**



### CMS垃圾收集器

采取的是"标记-清除算法"，整个过程分为四步：

(1)初始标记 CMS initial mark					标记GC Roots直接关联对象，不用Tracing，速度很快

(2)并发标记 CMS concurrent mark		   进行GC Roots Tracing

(3)重新标记CMS remark								修改并发标记因用户程序变动的内容

(4)并发清除CMS concurrent sweep 			清除不可达对象回收空间，同时有新垃圾产生，留着下次清理称为

​																				 浮动垃圾

整个过程中，并发标记和并发编程，收集器线程可以与用户线程一起工作，所以总体来说，CMS收集器的内存回收过程是与用户线程一起并发的执行。

![image-20220907164245323](新建文本文档/image-20220907164245323.png)

优点：并发收集、低停顿

缺点：产生大量的空间碎片并发阶段会降低吞吐量



### G1 调优策略

**(1）不要手动设置新生代和老年代的大小，只要设置整个堆的大小**
why: https://blogs.oracle.com/poonam/increased-heap-usage-with-g1-gc

> G1收集器在运行过程中，会自己调整新生代和老年代的大小
> 其实是通过adapt代的大小来调整对象晋升的速度和年龄，从而达到为收集器设置的暂停时间目标如果手动设置了大小就意味着放弃了G1的自动调优

**(2)不断调优暂停时间目标**

> 一般情况下这个值设置到100ms或者20oms都是可以的(不同情况下会不一样)，但如果设置成5oms就不太合理。暂停时间设置的太短，就会导致出现G1跟不上垃圾产生的速度。最终退化成Full GC。所以对这个参数的调优是一个持续的过程，逐步调整到最佳状态。暂停时间只是一个目标，并不能总是得到满足。

**(3)使用-XX:ConcGCThreads=n来增加标记线程的数量**

> IHOP如果阀值设置过高，可能会遇到转移失败的风险，比如对象进行转移时空间不足。如果阀值设置过低，就会使标记周期运行过于频繁,并且有可能混合收集期回收不到空间。
> IHOP值如果设置合理，但是在并发周期时间过长时，可以尝试增加并发线程数，调高ConcGCThreads。

**(4) MixedGC调优**

> -XX:InitiatingHeapOccupancyPercent
>
> -XX:G1MixedGCLiveThresholdPercent
>
> -XX:G1MixedGcCountTarger
>
> -XX:G10ldCSetRegionThresholdPercent

**(5)当增加堆内存大小**

**(6)不正常的Full GC**

> 有时候会发现系统刚刚启动的时候，就会发生一次Full GC，但是老年代空间比较充足，一般是由Metaspace区域引起的。可以通过MetaspaceSize适当增加其大家,比如256M。



### G1垃圾收集器

官网:
https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuningLg1_gc.html#garbage_first_garbage_collection

**使用G1收集器时，Java堆的内存布局与就与其他收集器有很大差别，它将整个Java堆划分为多个大小相等的独立区域 (Region)，虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分Region(不需要连续)的集合。**

每个Region大小都是一样的，可以是1M到32M之间的数值，但是必须保证是2的n次幂

如果对象太大，一个Region放不下[超过Region大小的50%]，那么就会直接放到Humongous中

设置Region大小: -XX:G1HeapRegionSize= <N> M

所谓Garbage-Frist，其实就是优先回收垃圾最多的Region区域

> (1)分代收集（仍然保留了分代的概念)
>
> (2）空间整合（整体上属于“标记-整理”算法，不会导致空间碎片)
>
> (3）可预测的停顿（比CNs更先进的地方在于能让使用者明确指定一个长度为w毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒)

![image-20220907165802632](新建文本文档/image-20220907165802632.png)

**工作过程可以分为如下几步**
初始标记0KIaitial Marking)									标记以下GC Roots能够关联的对象，并且修改TAS的值，需要

​																						 暂停用户线程

并发标记（Concurrent Marking)				 		 从GC Roots进行可达性分析，找出存活的对象，与用户线程并

​																						 发执行

最终标记Final Marking)											修正在并发标记阶段因为用户程序的并发执行导致变动的数

​																						  据，需暂停用户线程

筛选回收(Live Data Counting and Evacuation)   对各个Region的回收价值和成本进行排序，根据用户所期望

​																							的cc停顿时间制定回收计划

![image-20220907170046446](新建文本文档/image-20220907170046446.png)





### 生产环境中，如何选择合适的垃圾收集器

https://docs.oracle.com/ljavase/8/docs/technotes/guides/vm/gctuning/collectors.html#sthref28

* 优先调整堆的大小让服务器自己来选择
* 如果内存小于100M，使用串行收集器
* 如果是单核，并且没有停顿时间要求，使用串行或JVM自己选
* 如果允许停顿时间超过1秒，选择并行或JVM自己选
* 如果响应时间最重要，并且不能超过1秒，使用并发收集器



### 如何判断是否使用G1垃圾收集器

https://docs.oracle.com/javase/8/docs/technotes/guides/vm/G1.html#use_cases

**JDK 7开始使用，JDK 8非常成熟，JDK9默认的垃圾收集器，适用于新老生代。**

**是否使用G1收集器?**

(1)50%以上的堆被存活对象占用

(2)对象分配和晋升的速度变化非常大

(3)垃圾回收时间比较长



### 什么时候才会进行垃圾回收

> GC是由JVM自动完成的，根据JVM系统环境而定，所以时机是不确定的。
> 当然，我们可以手动进行垃圾回收，比如调用System.gc()方法通知JVM进行一次垃圾回收，但是具体什么时刻运行也无法控制。也就是说System.gc()只是通知要回收，什么时候回收由VM决定。**但是不建议手动调用该方法，因为GC消耗的资源比较大。**

(1)当Eden区或者s区不够用

(2)老年代空间不够用

(3)方法区空间不够用

(4)System.gc()				// 通知    			时机也不确定   	执行的Full GC




### JVM 常用命令

* jps

    **查看java进程**

    > The jps command lists the instrumented Java HotSpot VWls on the target system. The command is limited toreporting information on JVMs for which it has the access permissions.

* jinfo

    **(1)实时查看和调整JVM配置参数**

    > The jinfo command prints Java configuration information for a specified Java process or core file or aremote debug server. The configuration information includes Java system properties and Java VirtualMachine (VM)command-line flags.

    **(2)查看用法**

    ``` 
    jinfo  -flag  name  PID			查看某个java进程的name属性的值
    
    jinfo  -flag  MaxHeapSize  PID
    jinfo  -flag  UseG1GC  PID
    ```

    **(3)修改**

    参数只有被标记为manageable的flags可以被实时修改

    ``` 
    jinfo -flag [+-]PID
    jinfo -flag  <name>=<value> PID
    ```

    **(4）查看曾经赋过值的一些参数**

    ``` 
    jinfo -flags PID
    ```

* jstat
    **(1）查看虚拟机性能统计信息**

    > The jstat command displays performance statistics for an instrumented Java HotSpot VwW. The target wW isidentified by its virtual machine identifier, or vmid option.

    **(2)查看类装载信息**

    jstat   -class   PID  1000  10				查看某个java进程的类装载信息，每1000毫秒输出一次，共输出10次

    **(3)查看垃圾收集信息**

    jstat   -gc   PID   1000   10

* jstack
    **(1)查看线程堆栈信息**

    > The jstack command prints Java stack traces of ]ava threads for a specified Java process,core file,orremote debug server.

    **(2)用法**


    jstack   	PID

* jmap

    (1)生成堆转储快照

    > The jmap command prints shared object memory maps or heap memory details of a specified process,corefile, or remote debug server.

    (2)打印出堆内存相关信息

    jmap	 -heap	 PID

    jinfo 	-flag	 UsePSAdaptiveSurvivorSizePolicy	 35352

    -XX: SurvivorRatio=8





### JVM性能优化指南

![image-20220907173816272](新建文本文档/image-20220907173816272.png)





