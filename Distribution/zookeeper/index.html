<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="记录“美食”每刻" href="http://yoursite.com/rss.xml"><link rel="alternate" type="application/atom+xml" title="记录“美食”每刻" href="http://yoursite.com/atom.xml"><link rel="alternate" type="application/json" title="记录“美食”每刻" href="http://yoursite.com/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><link rel="canonical" href="http://yoursite.com/Distribution/zookeeper/"><title>zookeeper | 雾都博客 = 记录 “美食” 每刻</title><meta name="generator" content="Hexo 6.3.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">zookeeper</h1><div class="meta"><span class="item" title="创建时间：2022-10-28 20:37:30"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2022-10-28T20:37:30+08:00">2022-10-28</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>17k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>15 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">雾都博客</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://tva4.sinaimg.cn/large/6833939bly1gipeu1usa7j20zk0m8b29.jpg"></li><li class="item" data-background-image="https://tva4.sinaimg.cn/large/6833939bly1giclj9410cj20zk0m8h12.jpg"></li><li class="item" data-background-image="https://tva4.sinaimg.cn/large/6833939bly1gipev1x5e4j20zk0m8b29.jpg"></li><li class="item" data-background-image="https://tva4.sinaimg.cn/large/6833939bly1giclh0m9pdj20zk0m8hdt.jpg"></li><li class="item" data-background-image="https://tva4.sinaimg.cn/large/6833939bly1gipevo9j1jj20zk0m8e81.jpg"></li><li class="item" data-background-image="https://tva4.sinaimg.cn/large/6833939bly1gipeyonbf9j20zk0m8e81.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://yoursite.com/Distribution/zookeeper/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="雾都"><meta itemprop="description" content=", 记录 “美食” 每刻"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="记录 “美食” 每刻"></span><div class="body md" itemprop="articleBody"><h1 id="课程内容的介绍"><a href="#课程内容的介绍" class="headerlink" title="课程内容的介绍"></a>课程内容的介绍</h1><ol><li>Zookeeper的介绍和安装</li><li>Zookeeper客户端使用</li><li>ZookeeperJavaAPI使用</li></ol><h1 id="一、Zookeeper的介绍和安装"><a href="#一、Zookeeper的介绍和安装" class="headerlink" title="一、Zookeeper的介绍和安装"></a>一、Zookeeper的介绍和安装</h1><h2 id="1-为什么要使用Zookeeper"><a href="#1-为什么要使用Zookeeper" class="headerlink" title="1. 为什么要使用Zookeeper"></a>1. 为什么要使用Zookeeper</h2><p>​ 我们为了学习Dubbo，而在dubbo中需要一个注册中心，而Zookeeper是我们在使用Dubbo是官方推荐的注册中心，所以我们先来介绍Zookeeper</p><img data-src="/Distribution/zookeeper/image-20210226191457919.png" title="image-20210226191457919"> <img data-src="/Distribution/zookeeper/image-20210226191530528.png" title="image-20210226191530528"><h2 id="2-Zookeeper介绍"><a href="#2-Zookeeper介绍" class="headerlink" title="2. Zookeeper介绍"></a>2. Zookeeper介绍</h2><img data-src="/Distribution/zookeeper/image-20210226192111730.png" title="image-20210226192111730"><h3 id="2-1-Zookeeper概述"><a href="#2-1-Zookeeper概述" class="headerlink" title="2.1 Zookeeper概述"></a>2.1 Zookeeper概述</h3><p>ZooKeeper是一个分布式的，开放源码的分布式应用程序协调服务，是Google的Chubby一个开源的实现，是Hadoop和Hbase的重要组件。它是一个为分布式应用提供一致性服务的软件，提供的功能包括：配置维护、域名服务、分布式同步、组服务等。<br>Zookeeper是一个分布式协调服务；就是为用户的分布式应用程序提供协调服务</p><table><thead><tr><th>序号</th><th>功能</th></tr></thead><tbody><tr><td>1</td><td>为别的分布式程序服务的</td></tr><tr><td>2</td><td>本身就是一个分布式程序</td></tr><tr><td>3</td><td>主从协调 服务器节点动态上下线 统一配置管理 分布式共享锁 统一名称服务</td></tr><tr><td>4</td><td>管理(存储，读取)用户程序提交的数据 并为用户程序提供数据节点监听服务</td></tr></tbody></table><h3 id="2-2-Zookeeper的集群机制"><a href="#2-2-Zookeeper的集群机制" class="headerlink" title="2.2 Zookeeper的集群机制"></a>2.2 Zookeeper的集群机制</h3><p>Zookeeper是为其他分布式程序提供服务的，所以本身自己不能随便就挂了，所以zookeeper自身的集群机制就很重要。zookeeper的集群机制采用的是<strong>半数存活机制</strong>，也就是整个集群节点中有半数以上的节点存活，那么整个集群环境可用。这也就是说们的集群节点最好是奇数个节点。</p><p><strong>Zookeeper集群节点的角色</strong></p><p><strong>Leader</strong></p><p>Leader服务器是Zookeeper集群工作的核心，其主要工作如下</p><ol><li>事务请求的唯一调度和处理者，保证集群事务处理的顺序性。</li><li>集群内部各服务器的调度者</li></ol><p><strong>Follower</strong></p><p>Follower是Zookeeper集群的跟随者，其主要工作如下</p><ol><li>处理客户端非事务性请求（读取数据），转发事务请求给Leader服务器。</li><li>参与事务请求Proposal的投票。</li><li>参与Leader选举投票。</li></ol><p><strong>Observer</strong><br>Observer充当观察者角色，观察Zookeeper集群的最新状态变化并将这些状态同步过来，其对于非事务请求可以进行独立处理，对于事务请求，则会转发给Leader服务器进行处理。Observer不会参与任何形式的投票，包括事务请求Proposal的投票和Leader选举投票</p><h2 id="3-集群环境准备"><a href="#3-集群环境准备" class="headerlink" title="3. 集群环境准备"></a>3. 集群环境准备</h2><p>​ 通过上面的介绍我们了解到zookeeper的集群环境应该配置奇数个节点，所以我们在本文中搭建的zookeeper环境准备在3个节点上搭建。接下来我们介绍下需要准备的环境。</p><h3 id="3-1-准备3个节点"><a href="#3-1-准备3个节点" class="headerlink" title="3.1 准备3个节点"></a>3.1 准备3个节点</h3><p>​ 准备3个centos7.0的虚拟机节点，并且安装配置好JDK版本最好是8.不清楚的可参考此地址<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NTI2NTczL2FydGljbGUvZGV0YWlscy84Njc3NzE2Mw==">Linux之jdk安装</span>,并配置好相关的网络配置。</p><table><thead><tr><th>ip</th><th>主机名</th></tr></thead><tbody><tr><td>192.168.100.120</td><td>bobo01</td></tr><tr><td>192.168.100.121</td><td>bobo02</td></tr><tr><td>192.168.100.122</td><td>bobo03</td></tr></tbody></table><p>通过VMware的克隆或者直接复制文件夹的方式来创建另外两个新的节点</p><h3 id="3-2-网络配置"><a href="#3-2-网络配置" class="headerlink" title="3.2 网络配置"></a>3.2 网络配置</h3><p>修改ifcfg-ens33配置文件</p><img data-src="/Distribution/zookeeper/image-20210228125047032.png" title="image-20210228125047032"><p>重启网络服务</p><pre><code class="shell">service network restart
</code></pre><p>ping测试</p><img data-src="/Distribution/zookeeper/image-20210228125219258.png" title="image-20210228125219258"><p>三个节点的网络配置都ok的化我们就可以通过XShell来连接了</p><h3 id="3-3-节点的映射关系"><a href="#3-3-节点的映射关系" class="headerlink" title="3.3 节点的映射关系"></a>3.3 节点的映射关系</h3><p>每个节点设置相应的ip和主机名的映射关系，方便集群环境的部署</p><p>修改hosts配置文件中的信息</p><img data-src="/Distribution/zookeeper/image-20210228130055348.png" title="image-20210228130055348"><h3 id="3-4-配置免密登录"><a href="#3-4-配置免密登录" class="headerlink" title="3.4 配置免密登录"></a>3.4 配置免密登录</h3><p>生成公钥和私钥</p><pre><code class="shell">ssh-keygen
</code></pre><p>输入命令后根据提示，四次回车即可</p><img data-src="/Distribution/zookeeper/image-20210228130543258.png" title="image-20210228130543258"><p>发送公钥给需要免密登录的节点</p><pre><code class="shell">ssh-copy-id bobo01
ssh-copy-id bobo02
ssh-copy-id bobo03
</code></pre><img data-src="/Distribution/zookeeper/image-20210228130833067.png" title="image-20210228130833067"><p>节点和节点发送文件通过scp命令实现</p><pre><code class="shell">scp -r b.txt bobo01:/root/
</code></pre><img data-src="/Distribution/zookeeper/image-20210228131239060.png" title="image-20210228131239060"><h3 id="3-5-关闭防火墙"><a href="#3-5-关闭防火墙" class="headerlink" title="3.5 关闭防火墙"></a>3.5 关闭防火墙</h3><p>查看防火墙状态</p><pre><code class="shell">firewall-cmd --state
</code></pre><p>停止防火墙</p><pre><code class="shell">systemctl stop firewall.service
</code></pre><p>禁止开机启动</p><pre><code class="shell">systemctl disable firewall.service
</code></pre><h2 id="4-Zookeeper集群环境搭建"><a href="#4-Zookeeper集群环境搭建" class="headerlink" title="4. Zookeeper集群环境搭建"></a>4. Zookeeper集群环境搭建</h2><h3 id="4-1-获取安装文件"><a href="#4-1-获取安装文件" class="headerlink" title="4.1 获取安装文件"></a>4.1 获取安装文件</h3><p>下载地址:<span class="exturl" data-url="aHR0cHM6Ly9taXJyb3JzLmJmc3UuZWR1LmNuL2FwYWNoZS96b29rZWVwZXIv">https://mirrors.bfsu.edu.cn/apache/zookeeper/</span></p><p>通过wget命令将安装文件下载到opt目录下</p><p>注意：</p><p>apache-zookeeper-3.5.9-bin.tar.gz和apache-zookeeper-3.5.9.tar.gz的区别 -bin是编译后的文件 我们用这个</p><pre><code class="shell">wget https://mirrors.bfsu.edu.cn/apache/zookeeper/zookeeper-3.5.9/apache-zookeeper-3.5.9-bin.tar.gz
</code></pre><img data-src="/Distribution/zookeeper/image-20210228135143823.png" title="image-20210228135143823"><p>解压缩文件</p><img data-src="/Distribution/zookeeper/image-20210228135240561.png" title="image-20210228135240561"><p>进入Zookeeper目录</p><img data-src="/Distribution/zookeeper/image-20210228135417463.png" title="image-20210228135417463"><h3 id="4-2-修改配置"><a href="#4-2-修改配置" class="headerlink" title="4.2 修改配置"></a>4.2 修改配置</h3><p>修改zoo.cfg文件，系统默认的名称是 zoo_smple.cfg我们需要重命名为zoo.cfg</p><img data-src="/Distribution/zookeeper/image-20210228135552375.png" title="image-20210228135552375"><p>修改cfg的内容</p><p>修改了两块：</p><p>1是Zookeeper中存储数据的文件夹，还有就是Zookeeper集群环境节点信息</p><img data-src="/Distribution/zookeeper/image-20210228135948719.png" title="image-20210228135948719"><p>配置myid文件</p><p>​ 我们需要在Zookeeper的数据存储的目录中创建一个myid文件，文件中的内容只有一行信息，即表示我们集群几点的标识，范围是1-255，每个节点的myid的数字和我们在zoo.cfg中配置的server.数字是对应的</p><pre><code class="shell">1
</code></pre><h3 id="4-3-分发文件"><a href="#4-3-分发文件" class="headerlink" title="4.3 分发文件"></a>4.3 分发文件</h3><p>​ 当我们配置好了一个Zookeeper节点后，我们就可以将Zookeeper文件夹分发给其他几个节点了</p><pre><code class="shell">scp -r zookeeper bobo02:`pwd`
scp -r zookeeper bobo03:`pwd`
</code></pre><p>分发成功后我们需要修改各个节点中的myid的信息为配置文件中对应的数字</p><h3 id="4-4-启动测试"><a href="#4-4-启动测试" class="headerlink" title="4.4 启动测试"></a>4.4 启动测试</h3><p>整个集群环境都配置好了之后我们就可以测试启动了</p><p>启动命令</p><pre><code class="shell">./bin/zkServer.sh start
</code></pre><p>当我们仅仅启动一个节点的时候，因为半数存活机制，3个节点只启动一个节点是没有效果的，</p><img data-src="/Distribution/zookeeper/image-20210228151546411.png" title="image-20210228151546411"><p>当我们启动第二个节点后发现集群环境可以使用了</p><img data-src="/Distribution/zookeeper/image-20210228151658522.png" title="image-20210228151658522"><p>然后第一个节点的状态也改变了</p><img data-src="/Distribution/zookeeper/image-20210228151723421.png" title="image-20210228151723421"><p>然后再把第三个节点也启动起来</p><img data-src="/Distribution/zookeeper/image-20210228151751891.png" title="image-20210228151751891"><h2 id="5-Zookeeper的选举机制"><a href="#5-Zookeeper的选举机制" class="headerlink" title="5. Zookeeper的选举机制"></a>5. Zookeeper的选举机制</h2><p>为什么要进行Leader选举？<br>Leader 主要作用是保证分布式数据一致性，即每个节点的存储的数据同步。遇到以下两种情况需要进行Leader选举</p><ul><li>服务器初始化启动</li><li>服务器运行期间无法和Leader保持连接，Leader节点崩溃，逻辑时钟崩溃。</li></ul><h3 id="5-1-服务器初始化时Leader选举"><a href="#5-1-服务器初始化时Leader选举" class="headerlink" title="5.1 服务器初始化时Leader选举"></a>5.1 服务器初始化时Leader选举</h3><p>Zookeeper由于其自身的性质，一般建议选取奇数个节点进行搭建分布式服务器集群。以3个节点组成的服务器集群为例，说明服务器初始化时的选举过程。启动第一台安装Zookeeper的节点时，无法单独进行选举，启动第二台时，两节点之间进行通信，开始选举Leader。</p><ol><li><p>每个Server投出一票。他们两都选自己为Leader，投票的内容为（SID，ZXID）。<br>SID即Server的id，安装zookeeper时配置文件中所配置的myid；ZXID，事务id，<br>为节点的更新程度，ZXID越大，代表Server对Znode的操作越新。由于服务器初始化，<br>每个Sever上的Znode为0，所以Server1投的票为（1,0），Server2为（2,0）。<br>两Server将各自投票发给集群中其他机器。</p></li><li><p>每个Server接收来自其他Server的投票。集群中的每个Server先判断投票有效性，<br>如检查是不是本轮的投票，是不是来Looking状态的服务器投的票。</p></li><li><p>对投票结果进行处理。先了解下处理规则</p></li></ol><ul><li><p>首先对比ZXID。ZXID大的服务器优先作为Leader</p></li><li><p>若ZXID相同，比如初始化的时候，每个Server的ZXID都为0，</p></li><li><p>就会比较myid，myid大的选出来做Leader。</p><p>对于Server而言，他接受到的投票为（2,0），因为自身的票为（1,0），所以此时它会选举Server2为Leader，<br>将自己的更新为（2,0）。而Server2收到的投票为Server1的（1,0）由于比他自己小，<br>Server2的投票不变。Server1和Server2再次将票投出，投出的票都为（2,0）。</p></li></ul><ol start="4"><li><p>统计投票。每次投票之后，服务器都会统计投票信息，如果判定某个Server有过半的票数投它，<br>那么该Server将会作为Leader。对于Server1和Server2而言,统计出已经有两台机器接收了（2,0）的投票信息，<br>此时认为选出了Leader。</p></li><li><p>改变服务器状态。当确定了Leader之后，每个Server更新自己的状态，<br>Leader将状态更新为Leading，Follower将状态更新为Following。</p></li></ol><img data-src="/Distribution/zookeeper/image-20210301104123274.png" title="image-20210301104123274"><h3 id="5-2-服务器运行期间的Leader选举"><a href="#5-2-服务器运行期间的Leader选举" class="headerlink" title="5.2 服务器运行期间的Leader选举"></a>5.2 服务器运行期间的Leader选举</h3><p>Zookeeper运行期间，如果有新的Server加入，或者非Leader的Server宕机，那么Leader将会同步数据到新Server或者寻找其他备用Server替代宕机的Server。若Leader宕机，此时集群暂停对外服务，开始在内部选举新的Leader。假设当前集群中有Server1、Server2、Server3三台服务器，Server2为当前集群的Leader，由于意外情况，Server2宕机了，便开始进入选举状态。过程如下</p><ol><li><p>变更状态。其他的非Observer服务器将自己的状态改变为Looking，开始进入Leader选举。</p></li><li><p>每个Server发出一个投票（myid，ZXID），由于此集群已经运行过，所以每个Server上的ZXID可能不同。<br>假设Server1的ZXID为145，Server3的为122，第一轮投票中，Server1和Server3都投自己，<br>票分别为（1，145）、（3,122）,将自己的票发送给集群中所有机器。</p></li><li><p>每个Server接收接收来自其他Server的投票，接下来的步骤与初始化时相同。</p></li></ol><h1 id="二、Zookeeper客户端使用"><a href="#二、Zookeeper客户端使用" class="headerlink" title="二、Zookeeper客户端使用"></a>二、Zookeeper客户端使用</h1><h2 id="1-配置Zookeeper的环境变量"><a href="#1-配置Zookeeper的环境变量" class="headerlink" title="1. 配置Zookeeper的环境变量"></a>1. 配置Zookeeper的环境变量</h2><p>​ 为了简化我们每次操作Zookeeper而不用进入到Zookeeper的安装目录，我们可以将Zookeeper的安装信息配置到系统的环境变量中</p><pre><code class="shell">vim /etc/profile
</code></pre><p>添加的内容</p><pre><code class="shell">export ZOOKEPPER_HOME=/opt/zookeeper
export PATH=$PATH:$ZOOKEEPER_HOME/bin
</code></pre><p>执行source命令</p><pre><code class="shell">source /etc/profile
</code></pre><p>我们就可以在节点的任意位置操作Zookeeper了</p><p>通过scp命令将profile文件发送到其他几个节点上</p><pre><code class="shell">scp /etc/profile bobo02:/etc/
</code></pre><h2 id="2-客户端连接"><a href="#2-客户端连接" class="headerlink" title="2.客户端连接"></a>2.客户端连接</h2><p>通过bin目录下的zkCli.sh 命令连接即可</p><pre><code class="shell">zkCli.sh
</code></pre><img data-src="/Distribution/zookeeper/image-20210301110004402.png" title="image-20210301110004402"><p>zkCli.sh默认连接的是当前节点的Zookeeper节点，如果我们要连接其他节点执行如下命令即可</p><pre><code class="shell">zkCli.sh -timeout 5000 -server bobo02:2181
</code></pre><img data-src="/Distribution/zookeeper/image-20210301110253746.png" title="image-20210301110253746"><h2 id="3-数据操作"><a href="#3-数据操作" class="headerlink" title="3.数据操作"></a>3.数据操作</h2><h3 id="3-1-Zookeeper的数据结构"><a href="#3-1-Zookeeper的数据结构" class="headerlink" title="3.1 Zookeeper的数据结构"></a>3.1 Zookeeper的数据结构</h3><ol><li>层次化的目录结构，命名符合常规文件系统规范</li><li>每个节点在Zookeeper中叫做znode，并且有一个唯一的路径标识</li><li>节点znode可以包含数据和子节点（但是EPHEMERAL类型的节点不能有子节点）</li><li>客户端应用可以在节点上设置监听器</li></ol><img data-src="/Distribution/zookeeper/image-20210301113558950.png" title="image-20210301113558950"><h3 id="3-2-节点类型"><a href="#3-2-节点类型" class="headerlink" title="3.2 节点类型"></a>3.2 节点类型</h3><p><strong>1).znode有两种类型：</strong></p><p>短暂性（ephemeral）（断开连接自己删除）<br>持久性（persistent）（断开连接不删除）</p><p><strong>2).znode有四种形式的目录节点（默认是persistent）如下</strong></p><table><thead><tr><th>序号</th><th>节点类型</th><th>描述</th></tr></thead><tbody><tr><td>1</td><td>PERSISTENT</td><td>持久节点</td></tr><tr><td>2</td><td>PERSISTENT_SEQUENTIAL</td><td>持久有序节点</td></tr><tr><td>3</td><td>EPHEMERAL</td><td>短暂节点</td></tr><tr><td>4</td><td>EPHEMERAL_SEQUENTIAL</td><td>短暂有序节点</td></tr></tbody></table><p>​ 创建znode时设置顺序标识，znode名称后会附加一个值，顺序号是一个单调递增的计数器，有父节点维护<br>在分布式系统中，顺序号可以被用于为所有的事件进行全局排序，这样客户端可以通过顺序号推断事件的顺序</p><h3 id="3-3-常用命令"><a href="#3-3-常用命令" class="headerlink" title="3.3 常用命令"></a>3.3 常用命令</h3><p>​ Zookeeper作为Dubbo的注册中心用来保存我们各个服务的节点信息，显示Zookeeper是可以实现输出的存储操作的，我们来看下Zookeeper中存储操作的基本命令</p><img data-src="/Distribution/zookeeper/image-20210301115013270.png" title="image-20210301115013270"><p><strong>ls</strong></p><p>​ ls用来查看某个节点下的子节点信息</p><img data-src="/Distribution/zookeeper/image-20210301114751517.png" title="image-20210301114751517"><p>增强的命令，查看节点下的子节点及当前节点的属性信息 ls2或者 ls -s 命令</p><img data-src="/Distribution/zookeeper/image-20210301114914215.png" title="image-20210301114914215"><p><strong>create</strong></p><p>​ 创建节点信息</p><img data-src="/Distribution/zookeeper/image-20210301114945149.png" title="image-20210301114945149"><p><strong>get</strong></p><p>​ get命令用来查看节点的数据</p><img data-src="/Distribution/zookeeper/image-20210301115127622.png" title="image-20210301115127622"><p>如果要查看节点的属性信息那么我们可以通过get -s 来实现</p><img data-src="/Distribution/zookeeper/image-20210301115623726.png" title="image-20210301115623726"><p><strong>delete</strong></p><p>​ delete只能删除没有子节点的节点要删除非空节点可以通过 rmr 或者 deleteall 命令实现</p><img data-src="/Distribution/zookeeper/image-20210301115752831.png" title="image-20210301115752831"><p><strong>set</strong></p><p>​ set命令可以用来修改节点的内容。</p><img data-src="/Distribution/zookeeper/image-20210301115841724.png" title="image-20210301115841724"><h3 id="3-4-事件监听"><a href="#3-4-事件监听" class="headerlink" title="3.4 事件监听"></a>3.4 事件监听</h3><h4 id="3-4-1-数据改变的监听"><a href="#3-4-1-数据改变的监听" class="headerlink" title="3.4.1 数据改变的监听"></a>3.4.1 数据改变的监听</h4><p>​ 监听某个节点的数据内容变化，通过get命令 带 -w 参数即可，在3.4版本的Zookeeper中是通过<code>get path watch</code> 来说实现监控的</p><img data-src="/Distribution/zookeeper/image-20210301135116352.png" title="image-20210301135116352"><p>然后我们在其他节点上修改app1节点的数据，会触监听事件</p><img data-src="/Distribution/zookeeper/image-20210301135159833.png" title="image-20210301135159833"> <img data-src="/Distribution/zookeeper/image-20210301135216095.png" title="image-20210301135216095"><p>注意监听一次节点只会触发一次，如果要实现多次监听，那么可以在触发事件的处理函数中再次追加对节点的监听操作</p><h4 id="3-4-2-子节点的改变"><a href="#3-4-2-子节点的改变" class="headerlink" title="3.4.2 子节点的改变"></a>3.4.2 子节点的改变</h4><p>​ 监听节点下面的子节点的改变。</p><pre><code class="shell">[zk: localhost:2181(CONNECTED) 14] ls -w /app1
[]
</code></pre><p>触发</p><img data-src="/Distribution/zookeeper/image-20210301135538966.png" title="image-20210301135538966"> <img data-src="/Distribution/zookeeper/image-20210301135629103.png" title="image-20210301135629103"><h1 id="三、Zookeeper-Java-API使用"><a href="#三、Zookeeper-Java-API使用" class="headerlink" title="三、Zookeeper Java API使用"></a>三、Zookeeper Java API使用</h1><p>​ 介绍如何通过Java代码来操作Zookeeper中的数据</p><p>在Zookeeper的安装目录下是提供的有相关的Jar依赖的</p><img data-src="/Distribution/zookeeper/image-20210301141050300.png" title="image-20210301141050300"><p>但是我们对于Maven构建项目已经习惯而且是主流，那么我们可以通过maven坐标来管理</p><pre><code class="xml">&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt;
        &lt;artifactId&gt;zookeeper&lt;/artifactId&gt;
        &lt;version&gt;3.5.9&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;com.github.sgroschupf&lt;/groupId&gt;
        &lt;artifactId&gt;zkclient&lt;/artifactId&gt;
        &lt;version&gt;0.1&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;junit&lt;/groupId&gt;
        &lt;artifactId&gt;junit&lt;/artifactId&gt;
        &lt;version&gt;4.12&lt;/version&gt;
    &lt;/dependency&gt;

&lt;/dependencies&gt;
</code></pre><h2 id="1-连接ZK服务"><a href="#1-连接ZK服务" class="headerlink" title="1.连接ZK服务"></a>1.连接ZK服务</h2><pre><code class="java">import org.apache.zookeeper.WatchedEvent;
import org.apache.zookeeper.Watcher;
import org.apache.zookeeper.ZooKeeper;
import org.junit.Test;

import java.io.IOException;

public class Test1 &#123;

    private String connectString = &quot;192.168.100.121:2181,192.168.122:2181,192.168.100.122:2181&quot;;

    private int sessionTimeOut = 5000;

    /**
     * 连接Zookeeper服务端
     */
    @Test
    public void test1() throws IOException &#123;
        ZooKeeper zooKeeper = new ZooKeeper(connectString, sessionTimeOut, new Watcher() &#123;
            /**
             * 触发监听事件的回调方法
             * @param watchedEvent
             */
            @Override
            public void process(WatchedEvent watchedEvent) &#123;
                System.out.println(&quot;触发了.....&quot;);
            &#125;
        &#125;);
        System.out.println(&quot;---&gt;&quot; + zooKeeper);
    &#125;
&#125;
</code></pre><img data-src="/Distribution/zookeeper/image-20210301141935591.png" title="image-20210301141935591"><h2 id="2-基本操作"><a href="#2-基本操作" class="headerlink" title="2 基本操作"></a>2 基本操作</h2><pre><code class="java">package com.bobo.test;

import jdk.nashorn.internal.ir.CallNode;
import org.apache.zookeeper.*;
import org.apache.zookeeper.data.Stat;
import org.junit.Before;
import org.junit.Test;

import java.io.IOException;
import java.util.List;

public class Test1 &#123;

    private String connectString = &quot;192.168.100.121:2181,192.168.122:2181,192.168.100.122:2181&quot;;

    private int sessionTimeOut = 10000;

    ZooKeeper zooKeeper = null;

    /**
     * 连接Zookeeper服务端
     */
    @Before
    public void test1() throws IOException &#123;
        zooKeeper = new ZooKeeper(connectString, sessionTimeOut, new Watcher() &#123;
            /**
             * 触发监听事件的回调方法
             * @param watchedEvent
             */
            @Override
            public void process(WatchedEvent watchedEvent) &#123;
                System.out.println(&quot;触发了.....&quot;);
            &#125;
        &#125;);
        //System.out.println(&quot;---&gt;&quot; + zooKeeper);
    &#125;

    /**
     * 创建节点
     */
    @Test
    public void createNode() throws Exception&#123;
        String path = zooKeeper.create(&quot;/apptest&quot; // 节点路径
                ,&quot;HelloZookeeper&quot;.getBytes() // 节点的数据
                , ZooDefs.Ids.OPEN_ACL_UNSAFE // 权限
        , CreateMode.PERSISTENT // 节点类型
        );
        System.out.println(path);
    &#125;

    /**
     * 判断节点是否存在
     */
    @Test
    public void exist() throws  Exception&#123;
        // true表示的是使用Zookeeper中的watch
        Stat stat = zooKeeper.exists(&quot;/apptest&quot;, true);
        if(stat != null)&#123;
            System.out.println(&quot;节点存在&quot;+ stat.getNumChildren());
        &#125;else&#123;
            System.out.println(&quot;节点不存在 ....&quot;);
        &#125;
    &#125;

    /**
     * 获取某个节点下面的所有的子节点
     */
    @Test
    public void getChildrens() throws Exception&#123;
        List&lt;String&gt; childrens = zooKeeper.getChildren(&quot;/app1&quot;, true);
        for (String children : childrens) &#123;
            // System.out.println(children);
            // 获取子节点中的数据
            byte[] data = zooKeeper.getData(&quot;/app1/&quot; + children, false, null);
            System.out.println(children+&quot;:&quot; + new String(data));
        &#125;
    &#125;

    /**
     * 修改节点的内容
     */
    @Test
    public void setData() throws Exception&#123;
        // -1 不指定版本 自动维护
        Stat stat = zooKeeper.setData(&quot;/app1/a1&quot;, &quot;666666&quot;.getBytes(), -1);
        System.out.println(stat);
    &#125;


    /**
     * 删除节点
     */
    @Test
    public void deleteNode() throws Exception&#123;
        zooKeeper.delete(&quot;/app1&quot;,-1);
        
    &#125;


&#125;
</code></pre><h2 id="3-事件监听处理"><a href="#3-事件监听处理" class="headerlink" title="3 事件监听处理"></a>3 事件监听处理</h2><p>​ Java程序如何监听Zookeeper中的数据的变化？</p><pre><code class="java">    /**
     * 监听Node节点下的子节点的变化
     */
    @Test
    public void nodeChildrenChange() throws Exception&#123;
        List&lt;String&gt; list = zooKeeper.getChildren(&quot;/app1&quot;, new Watcher() &#123;

            /**
             *              None(-1),
             *             NodeCreated(1),
             *             NodeDeleted(2),
             *             NodeDataChanged(3),
             *             NodeChildrenChanged(4),
             *             DataWatchRemoved(5),
             *             ChildWatchRemoved(6);
             * @param watchedEvent
             */
            @Override
            public void process(WatchedEvent watchedEvent) &#123;
                System.out.println(&quot;---&gt;&quot;+ watchedEvent.getType());
            &#125;
        &#125;);
        for (String s : list) &#123;
            System.out.println(s);
        &#125;

        Thread.sleep(Integer.MAX_VALUE);
    &#125;

    /**
     * 监听节点内容变更
     */
    @Test
    public void nodeDataChanged() throws Exception&#123;
        byte[] data = zooKeeper.getData(&quot;/app1/a1&quot;, new Watcher() &#123;
            @Override
            public void process(WatchedEvent watchedEvent) &#123;
                System.out.println(&quot;---&gt;&quot; + watchedEvent.getType());
            &#125;
        &#125;, null);
        System.out.println(&quot;---&gt;&quot; + new String(data));
        Thread.sleep(Integer.MAX_VALUE);
    &#125;
</code></pre><h1 id="四、Zookeeper实现分布式锁"><a href="#四、Zookeeper实现分布式锁" class="headerlink" title="四、Zookeeper实现分布式锁"></a>四、Zookeeper实现分布式锁</h1><h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><p>排他锁、共享锁</p><h3 id="排他锁"><a href="#排他锁" class="headerlink" title="排他锁"></a>排他锁</h3><p>排他锁（Exclusive Locks），又被称为写锁或独占锁，如果事务T1对数据对象O1加上排他锁，那么整个加锁期间，只允许事务T1对O1进行读取和更新操作，其他任何事务都不能进行读或写。</p><p>实现方式在下面的<code>Zookeeper</code> 实现分布式锁中有具体讲解，<code>Zookeeper</code>实现分布式锁就是一个排它锁</p><h3 id="共享锁"><a href="#共享锁" class="headerlink" title="共享锁"></a>共享锁</h3><p>共享锁（Shared Locks），又称读锁。如果事务T1对数据对象O1加上了共享锁，那么当前事务只能对O1进行读取操作，其他事务也只能对这个数据对象加共享锁，直到该数据对象上的所有共享锁都释放。</p><p><strong>实现方式：</strong></p><p>1、客户端调用 create 方法创建类似定义锁方式的临时顺序节点。</p><img data-src="/Distribution/zookeeper/lock-01.png" title="img"><p>2、客户端调用 getChildren 接口来获取所有已创建的子节点列表。</p><p>3、判断是否获得锁</p><ul><li>对于读请求：如果所有比自己小的子节点都是读请求或者没有比自己序号小的子节点，表明已经成功获取共享锁，同时开始执行度逻辑。</li><li>对于写请求：如果自己不是序号最小的子节点，那么就进入等待。</li></ul><p>4、如果没有获取到共享锁，读请求向比自己序号小的最后一个写请求节点注册 watcher 监听，写请求向比自己序号小的最后一个节点注册watcher 监听。</p><h3 id="概念总结"><a href="#概念总结" class="headerlink" title="概念总结"></a>概念总结</h3><ul><li><p>对于排他锁而言</p><p>只监听自己前面的人，前面没人才能拿到锁资源</p></li><li><p>对于共享锁(读写锁)</p><ol><li><p>序号越大越可能是读锁</p></li><li><p>写锁的序号最小</p></li></ol></li></ul><h3 id="操作事例"><a href="#操作事例" class="headerlink" title="操作事例"></a>操作事例</h3><p><strong>实际开发过程中，可以 curator 工具包封装的API帮助我们实现分布式锁。</strong></p><p>curator 的几种锁方案 ：</p><ul><li>1、<strong>InterProcessMutex</strong>：分布式可重入排它锁</li><li>2、<strong>InterProcessSemaphoreMutex</strong>：分布式排它锁</li><li>3、<strong>InterProcessReadWriteLock</strong>：分布式读写锁</li></ul><p>引入依赖：</p><pre><code class="xml">        &lt;!-- curator-framework 自带Zookeeper --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.apache.curator&lt;/groupId&gt;
            &lt;artifactId&gt;curator-framework&lt;/artifactId&gt;
            &lt;version&gt;4.2.0&lt;/version&gt;
            &lt;exclusions&gt;
                &lt;exclusion&gt;
                    &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt;
                    &lt;artifactId&gt;zookeeper&lt;/artifactId&gt;
                &lt;/exclusion&gt;
            &lt;/exclusions&gt;
        &lt;/dependency&gt;
        &lt;!-- curator-recipes --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.apache.curator&lt;/groupId&gt;
            &lt;artifactId&gt;curator-recipes&lt;/artifactId&gt;
            &lt;version&gt;4.2.0&lt;/version&gt;
            &lt;exclusions&gt;
                &lt;exclusion&gt;
                    &lt;groupId&gt;org.apache.curator&lt;/groupId&gt;
                    &lt;artifactId&gt;curator-framework&lt;/artifactId&gt;
                &lt;/exclusion&gt;
            &lt;/exclusions&gt;
        &lt;/dependency&gt;
</code></pre><p>测试用例：</p><pre><code class="java">import org.apache.curator.framework.CuratorFramework;
import org.apache.curator.framework.CuratorFrameworkFactory;
import org.apache.curator.framework.recipes.locks.InterProcessMutex;
import org.apache.curator.framework.recipes.locks.InterProcessReadWriteLock;
import org.apache.curator.framework.recipes.locks.InterProcessSemaphoreMutex;
import org.apache.curator.retry.ExponentialBackoffRetry;

public class InterprocessLock &#123;
    public static void main(String[] args)  &#123;
        CuratorFramework zkClient = getZkClient();
        String lockPath = &quot;/lock&quot;;
        InterProcessMutex lock = new InterProcessMutex(zkClient, lockPath);
        InterProcessSemaphoreMutex lock1 = new InterProcessSemaphoreMutex(zkClient, lockPath);
        InterProcessMutex read  = new InterProcessReadWriteLock(zkClient,lockPath).readLock();
        InterProcessMutex write = new InterProcessReadWriteLock(zkClient,lockPath).writeLock();

        //模拟线程抢锁
        for (int i = 0; i &lt; 5; i++) &#123;
            //分布式可重入排它锁
            // new Thread(new TestThread(i, lock)).start();
            // 分布式排它锁
            new Thread(new TestInterProcessSemaphoreMutex(i + 1, lock1));
        &#125;

        // 模拟线程抢锁
        // 读书数量为 i ,写锁数量为 j
        for (int i = 0 ,j = 0; j&lt;3 || i &lt; 5 ;j++, i++) &#123;
            // if (j&lt;3) new Thread(new TestThreadSharedLockOnWriter(i + 1, write)).start();
           // new Thread( new TestThreadSharedLockOnRead(i + 1, read)).start();
        &#125;
        for (int i = 0; i &lt; 2; i++) &#123;
            // new Thread(new TestThreadSharedLockOnWriter(i + 1, write)).start();
        &#125;


    &#125;

    static class TestInterProcessMutex implements Runnable &#123;
        private Integer threadFlag;
        private InterProcessMutex lock;
        private InterProcessSemaphoreMutex lock1;

        @Override
        public void run() &#123;
            testInterProcessMutex();
        &#125;

        public TestInterProcessMutex() &#123;
        &#125;

        public TestInterProcessMutex(Integer threadFlag, InterProcessMutex lock) &#123;
            this.threadFlag = threadFlag;
            this.lock = lock;
        &#125;

        public TestInterProcessMutex(Integer threadFlag, InterProcessSemaphoreMutex lock1) &#123;
            this.threadFlag = threadFlag;
            this.lock1 = lock1;
        &#125;

        private void testInterProcessMutex()&#123;
            try &#123;
                lock.acquire();
                System.out.println(&quot;第&quot;+threadFlag+&quot;线程获取到了锁&quot;);
                //等到1秒后释放锁
                Thread.sleep(1000);
            &#125; catch (Exception e) &#123;
                e.printStackTrace();
            &#125;finally &#123;
                try &#123;
                    lock.release();
                &#125; catch (Exception e) &#123;
                    e.printStackTrace();
                &#125;
            &#125;
        &#125;

    &#125;
    static class TestInterProcessSemaphoreMutex implements Runnable &#123;
        private Integer threadFlag;
        private InterProcessSemaphoreMutex lock;

        @Override
        public void run() &#123;
            testInterProcessSemaphoreMutex();
        &#125;

        public TestInterProcessSemaphoreMutex() &#123;
        &#125;

        public TestInterProcessSemaphoreMutex(Integer threadFlag, InterProcessSemaphoreMutex lock) &#123;
            this.threadFlag = threadFlag;
            this.lock = lock;
        &#125;
        private void testInterProcessSemaphoreMutex()&#123;
            try &#123;
                lock.acquire();
                System.out.println(&quot;第&quot;+threadFlag+&quot;线程获取到了锁&quot;);
                //等到1秒后释放锁
                Thread.sleep(1000);
            &#125; catch (Exception e) &#123;
                e.printStackTrace();
            &#125;finally &#123;
                try &#123;
                    lock.release();
                &#125; catch (Exception e) &#123;
                    e.printStackTrace();
                &#125;
            &#125;
        &#125;


    &#125;
    static class TestThreadSharedLockOnRead implements Runnable&#123;
        private Integer threadFlag;
        private InterProcessMutex lock2;

        public TestThreadSharedLockOnRead() &#123;
        &#125;

        public TestThreadSharedLockOnRead(Integer threadFlag, InterProcessMutex lock2) &#123;
            this.threadFlag = threadFlag;
            this.lock2 = lock2;
        &#125;

        private void testInterProcessReadWriteLockOnRead()&#123;
            try &#123;
                lock2.acquire();
                System.out.println(&quot;读锁----第&quot;+threadFlag+&quot;线程获取到了锁&quot;);
                //等到1秒后释放锁
                Thread.sleep(5000);
            &#125; catch (Exception e) &#123;
                e.printStackTrace();
            &#125;finally &#123;
                try &#123;
                    lock2.release();
                &#125; catch (Exception e) &#123;
                    e.printStackTrace();
                &#125;
            &#125;
        &#125;

        @Override
        public void run() &#123;
            testInterProcessReadWriteLockOnRead();
        &#125;
    &#125;
    static class TestThreadSharedLockOnWriter implements Runnable&#123;
        private Integer threadFlag;
        private InterProcessMutex lock2;

        public TestThreadSharedLockOnWriter() &#123;
        &#125;

        public TestThreadSharedLockOnWriter(Integer threadFlag, InterProcessMutex lock2) &#123;
            this.threadFlag = threadFlag;
            this.lock2 = lock2;
        &#125;

        private void testInterProcessReadWriteLockOnWriter()&#123;
            try &#123;
                lock2.acquire();
                System.out.println(&quot;写锁----第&quot;+threadFlag+&quot;线程获取到了锁&quot;);
                //等到1秒后释放锁
                Thread.sleep(1000);
            &#125; catch (Exception e) &#123;
                e.printStackTrace();
            &#125;finally &#123;
                try &#123;
                    lock2.release();
                &#125; catch (Exception e) &#123;
                    e.printStackTrace();
                &#125;
            &#125;
        &#125;

        @Override
        public void run() &#123;
            testInterProcessReadWriteLockOnWriter();
        &#125;
    &#125;

    /**
     * 建立连接
     * @return
     */
    private static CuratorFramework getZkClient() &#123;
        String zkServerAddress = &quot;39.103.208.148:2181&quot;;
        ExponentialBackoffRetry retryPolicy = new ExponentialBackoffRetry(1000, 3, 5000);
        CuratorFramework zkClient = CuratorFrameworkFactory.builder()
                .connectString(zkServerAddress)
                .sessionTimeoutMs(5000)
                .connectionTimeoutMs(5000)
                .retryPolicy(retryPolicy)
                .build();
        zkClient.start();
        return zkClient;
    &#125;
&#125;
</code></pre><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>​ <code>[Zookeeper</code>能实现分布式锁，是因为它有一个特性，就是&#x3D;&#x3D;多个线程去 Zookeeper 里面去创建同一个节点的时候，只会有一个线程执行成功&#x3D;&#x3D;。（<strong>默认公平锁，也叫排它锁</strong>）</p><p><strong>锁可理解为 ZooKeeper 上的一个节点</strong></p><ul><li>当需要获取锁时，就在这个锁节点下创建一个临时顺序节点。当存在多个客户端同时来获取锁，就按顺序依次创建多个临时顺序节点，但只有排列序号是第一的那个节点能获取锁成功，其他节点则按顺序分别监听前一个节点的变化，当被监听者释放锁时，监听者就可以马上获得锁。</li><li>当释放锁时，只需要将会话关闭，临时节点就删除了，即释放了锁。如果万一客户端获取到锁之后突然挂掉（Session连接断开），那么这个临时节点也会自动删除掉。</li></ul><h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><p>实现有两种方案：</p><ul><li>基于临时节点实现，会产生羊群效应，<strong>不推荐</strong>。</li><li>基于临时顺序节点实现。<strong>推荐</strong></li></ul><p>一般我们认为，<font color="red">ZooKeeper 的分布式锁是基于临时顺序节点，然后通过监听机制来实现的</font>。即方案2。</p><p>基于临时节点实现:</p><p>1、实现思路</p><div style="align-items:Center;justify-content:center"><img data-src="zookeeper/4dafb20334a545b39c52b1fc64eb46e1.png"></div><p><strong>锁节点</strong>：即锁对象</p><p><strong>获取锁</strong>：锁请求者加锁，则创建锁节点。</p><ul><li>如果创建成功，那么加锁成功，</li><li>如果创建失败，那么加锁失败，则等待获取锁（等待获取锁成功的客户端释放锁）。注意：这里锁请求者监听的都是 锁节点的删除操作。</li></ul><p><strong>释放锁</strong>：只需要将会话关闭，临时节点就删除了，即释放了锁。</p><p><strong>羊群效应</strong>：如果所有的锁请求者都来监听锁持有者，当锁持有者的节点被删除以后，所有的锁请求者都会通知到，即都会同时去竞争锁，但是只有一个锁请求者能拿到锁。这就是羊群效应(<strong>非公平锁</strong>)。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>参考分布式锁中的代码实现</p><ul><li>Zookeeper中多用 <strong>InterProcessMutex</strong>（分布式可重入排它锁）</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>菜鸟教程：<span class="exturl" data-url="aHR0cHM6Ly93d3cucnVub29iLmNvbS93M2Nub3RlL3pvb2tlZXBlci1sb2Nrcy5odG1s">https://www.runoob.com/w3cnote/zookeeper-locks.html</span></p><p>Charge8：<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDAyODU0L2FydGljbGUvZGV0YWlscy8xMjQ5MzY4OTU=">https://blog.csdn.net/qq_42402854/article/details/124936895</span></p><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig={clientID:"6db178ba46c8af8f6a6f",clientSecret:"90f730e5956024596558df00975cd8eae28cae3d",repo:"bk-comment01",owner:"onlymarryu",admin:["onlymarryu"],distractionFreeMode:!1,language:"zh-CN",proxy:"https://gitalk-comments.netlify.app/github_access_token",perPage:15};gitalkConfig.id=md5(location.pathname);var gitalk=new Gitalk(gitalkConfig);gitalk.render("gitalk-container")</script></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2022-10-28 20:38:38" itemprop="dateModified" datetime="2022-10-28T20:38:38+08:00">2022-10-28</time></span></div><div class="reward"><button><i class="ic i-heartbeat"></i> 赞赏</button><p>请我喝[茶]~(￣▽￣)~*</p><div id="qr"><div><img data-src="/images/wechatpay.png" alt="雾都 微信支付"><p>微信支付</p></div><div><img data-src="/images/alipay.png" alt="雾都 支付宝"><p>支付宝</p></div><div><img data-src="/images/paypal.png" alt="雾都 贝宝"><p>贝宝</p></div></div></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>雾都 <i class="ic i-at"><em>@</em></i>记录 “美食” 每刻</li><li class="link"><strong>本文链接：</strong> <a href="http://yoursite.com/Distribution/zookeeper/" title="zookeeper">http://yoursite.com/Distribution/zookeeper/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/tools/tools-All/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;tva4.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1giclhpw3lwj20zk0m8gvw.jpg" title="所有工具安装合集"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> 工具软件安装</span><h3>所有工具安装合集</h3></a></div><div class="item right"></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AE%B9%E7%9A%84%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.</span> <span class="toc-text">课程内容的介绍</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81Zookeeper%E7%9A%84%E4%BB%8B%E7%BB%8D%E5%92%8C%E5%AE%89%E8%A3%85"><span class="toc-number">2.</span> <span class="toc-text">一、Zookeeper的介绍和安装</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8Zookeeper"><span class="toc-number">2.1.</span> <span class="toc-text">1. 为什么要使用Zookeeper</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Zookeeper%E4%BB%8B%E7%BB%8D"><span class="toc-number">2.2.</span> <span class="toc-text">2. Zookeeper介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-Zookeeper%E6%A6%82%E8%BF%B0"><span class="toc-number">2.2.1.</span> <span class="toc-text">2.1 Zookeeper概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-Zookeeper%E7%9A%84%E9%9B%86%E7%BE%A4%E6%9C%BA%E5%88%B6"><span class="toc-number">2.2.2.</span> <span class="toc-text">2.2 Zookeeper的集群机制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E9%9B%86%E7%BE%A4%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87"><span class="toc-number">2.3.</span> <span class="toc-text">3. 集群环境准备</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E5%87%86%E5%A4%873%E4%B8%AA%E8%8A%82%E7%82%B9"><span class="toc-number">2.3.1.</span> <span class="toc-text">3.1 准备3个节点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE"><span class="toc-number">2.3.2.</span> <span class="toc-text">3.2 网络配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E8%8A%82%E7%82%B9%E7%9A%84%E6%98%A0%E5%B0%84%E5%85%B3%E7%B3%BB"><span class="toc-number">2.3.3.</span> <span class="toc-text">3.3 节点的映射关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-%E9%85%8D%E7%BD%AE%E5%85%8D%E5%AF%86%E7%99%BB%E5%BD%95"><span class="toc-number">2.3.4.</span> <span class="toc-text">3.4 配置免密登录</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-%E5%85%B3%E9%97%AD%E9%98%B2%E7%81%AB%E5%A2%99"><span class="toc-number">2.3.5.</span> <span class="toc-text">3.5 关闭防火墙</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-Zookeeper%E9%9B%86%E7%BE%A4%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA"><span class="toc-number">2.4.</span> <span class="toc-text">4. Zookeeper集群环境搭建</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E8%8E%B7%E5%8F%96%E5%AE%89%E8%A3%85%E6%96%87%E4%BB%B6"><span class="toc-number">2.4.1.</span> <span class="toc-text">4.1 获取安装文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E4%BF%AE%E6%94%B9%E9%85%8D%E7%BD%AE"><span class="toc-number">2.4.2.</span> <span class="toc-text">4.2 修改配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-%E5%88%86%E5%8F%91%E6%96%87%E4%BB%B6"><span class="toc-number">2.4.3.</span> <span class="toc-text">4.3 分发文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-%E5%90%AF%E5%8A%A8%E6%B5%8B%E8%AF%95"><span class="toc-number">2.4.4.</span> <span class="toc-text">4.4 启动测试</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-Zookeeper%E7%9A%84%E9%80%89%E4%B8%BE%E6%9C%BA%E5%88%B6"><span class="toc-number">2.5.</span> <span class="toc-text">5. Zookeeper的选举机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%88%9D%E5%A7%8B%E5%8C%96%E6%97%B6Leader%E9%80%89%E4%B8%BE"><span class="toc-number">2.5.1.</span> <span class="toc-text">5.1 服务器初始化时Leader选举</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BF%90%E8%A1%8C%E6%9C%9F%E9%97%B4%E7%9A%84Leader%E9%80%89%E4%B8%BE"><span class="toc-number">2.5.2.</span> <span class="toc-text">5.2 服务器运行期间的Leader选举</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81Zookeeper%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BD%BF%E7%94%A8"><span class="toc-number">3.</span> <span class="toc-text">二、Zookeeper客户端使用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E9%85%8D%E7%BD%AEZookeeper%E7%9A%84%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F"><span class="toc-number">3.1.</span> <span class="toc-text">1. 配置Zookeeper的环境变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%BF%9E%E6%8E%A5"><span class="toc-number">3.2.</span> <span class="toc-text">2.客户端连接</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C"><span class="toc-number">3.3.</span> <span class="toc-text">3.数据操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-Zookeeper%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">3.3.1.</span> <span class="toc-text">3.1 Zookeeper的数据结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E8%8A%82%E7%82%B9%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.3.2.</span> <span class="toc-text">3.2 节点类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="toc-number">3.3.3.</span> <span class="toc-text">3.3 常用命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC"><span class="toc-number">3.3.4.</span> <span class="toc-text">3.4 事件监听</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-1-%E6%95%B0%E6%8D%AE%E6%94%B9%E5%8F%98%E7%9A%84%E7%9B%91%E5%90%AC"><span class="toc-number">3.3.4.1.</span> <span class="toc-text">3.4.1 数据改变的监听</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-2-%E5%AD%90%E8%8A%82%E7%82%B9%E7%9A%84%E6%94%B9%E5%8F%98"><span class="toc-number">3.3.4.2.</span> <span class="toc-text">3.4.2 子节点的改变</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E3%80%81Zookeeper-Java-API%E4%BD%BF%E7%94%A8"><span class="toc-number">4.</span> <span class="toc-text">三、Zookeeper Java API使用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E8%BF%9E%E6%8E%A5ZK%E6%9C%8D%E5%8A%A1"><span class="toc-number">4.1.</span> <span class="toc-text">1.连接ZK服务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-number">4.2.</span> <span class="toc-text">2 基本操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC%E5%A4%84%E7%90%86"><span class="toc-number">4.3.</span> <span class="toc-text">3 事件监听处理</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B%E3%80%81Zookeeper%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="toc-number">5.</span> <span class="toc-text">四、Zookeeper实现分布式锁</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="toc-number">5.1.</span> <span class="toc-text">分布式锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%92%E4%BB%96%E9%94%81"><span class="toc-number">5.1.1.</span> <span class="toc-text">排他锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E9%94%81"><span class="toc-number">5.1.2.</span> <span class="toc-text">共享锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93"><span class="toc-number">5.1.3.</span> <span class="toc-text">概念总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E4%BA%8B%E4%BE%8B"><span class="toc-number">5.1.4.</span> <span class="toc-text">操作事例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D"><span class="toc-number">5.2.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0"><span class="toc-number">5.3.</span> <span class="toc-text">具体实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-number">5.4.</span> <span class="toc-text">代码实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83"><span class="toc-number">5.5.</span> <span class="toc-text">参考</span></a></li></ol></li></ol></div><div class="related panel pjax" data-title="系列文章"></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="雾都" data-src="/images/avatar.jpg"><p class="name" itemprop="name">雾都</p><div class="description" itemprop="description">记录 “美食” 每刻</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">57</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">8</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">15</span> <span class="name">标签</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL29ubHltYXJyeXU=" title="https:&#x2F;&#x2F;github.com&#x2F;onlymarryu"><i class="ic i-github"></i></span> <span class="exturl item music" data-url="aHR0cHM6Ly9tdXNpYy4xNjMuY29tLyMvbXkvbS9tdXNpYy9wbGF5bGlzdD9pZD0zMTY2MDYwNzkw" title="https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;my&#x2F;m&#x2F;music&#x2F;playlist?id&#x3D;3166060790"><i class="ic i-cloud-music"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>时间轴</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li><li class="item"><a href="/friends/" rel="section"><i class="ic i-heart"></i>友链</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-calendar"></i>留言</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/%E5%B7%A5%E5%85%B7%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/" title="分类于 工具软件安装">工具软件安装</a></div><span><a href="/tools/MyCat-tool/" title="MyCat">MyCat</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/JavaSE/" title="分类于 JavaSE">JavaSE</a></div><span><a href="/Java/%E7%AC%AC10%E7%AB%A0_%E5%B8%B8%E7%94%A8%E7%B1%BB/" title="第10章_常用类">第10章_常用类</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Mybatis/" title="分类于 Mybatis">Mybatis</a></div><span><a href="/ORM/MybatisPlus/" title="MybatisPlus">MybatisPlus</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/" title="分类于 分布式">分布式</a></div><span><a href="/Distribution/Solr/" title="Solr">Solr</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E5%B7%A5%E5%85%B7%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/" title="分类于 工具软件安装">工具软件安装</a></div><span><a href="/tools/tools-All/" title="所有工具安装合集">所有工具安装合集</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E5%B7%A5%E5%85%B7%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/" title="分类于 工具软件安装">工具软件安装</a></div><span><a href="/tools/IDEA-tool/" title="IDEA-tool">IDEA-tool</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/JavaSE/" title="分类于 JavaSE">JavaSE</a></div><span><a href="/Java/%E7%AC%AC7%E7%AB%A0_IDEA%E7%9A%84%E4%BD%BF%E7%94%A8/" title="第7章_IDEA的使用">第7章_IDEA的使用</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/JavaSE/" title="分类于 JavaSE">JavaSE</a></div><span><a href="/Java/%E7%AC%AC8%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" title="第8章_面向对象">第8章_面向对象</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/JavaSE/" title="分类于 JavaSE">JavaSE</a></div><span><a href="/Java/%E7%AC%AC16%E7%AB%A0_%E5%8F%8D%E5%B0%84/" title="第16章_反射">第16章_反射</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E5%B7%A5%E5%85%B7%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/" title="分类于 工具软件安装">工具软件安装</a></div><span><a href="/tools/Nacos-tool/" title="Nacos">Nacos</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2010 – <span itemprop="copyrightYear">2022</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">雾都 @ 雾都博客</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="站点总字数">830k 字</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="站点阅读时长">12:34</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"Distribution/zookeeper/",favicon:{show:"（●´3｀●）やれやれだぜ",hide:"(´Д｀)大変だ！"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html>