<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="每天进步一点点，就是成功的开始" href="https://eth168.top/rss.xml"><link rel="alternate" type="application/atom+xml" title="每天进步一点点，就是成功的开始" href="https://eth168.top/atom.xml"><link rel="alternate" type="application/json" title="每天进步一点点，就是成功的开始" href="https://eth168.top/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="集合,面试"><link rel="canonical" href="https://eth168.top/interview/JavaSE%E2%80%94%E9%9B%86%E5%90%88/"><title>集合 - 面试 | 雾都博客 = 每天进步一点点，就是成功的开始</title><meta name="generator" content="Hexo 6.3.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">集合</h1><div class="meta"><span class="item" title="创建时间：2023-01-12 00:00:00"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2023-01-12T00:00:00+08:00">2023-01-12</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>31k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>29 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">雾都博客</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://api.yimian.xyz/img?466966"></li><li class="item" data-background-image="https://api.yimian.xyz/img?756434"></li><li class="item" data-background-image="https://api.yimian.xyz/img?437883"></li><li class="item" data-background-image="https://api.yimian.xyz/img?468727"></li><li class="item" data-background-image="https://api.yimian.xyz/img?198443"></li><li class="item" data-background-image="https://api.yimian.xyz/img?497715"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/%E9%9D%A2%E8%AF%95/" itemprop="item" rel="index" title="分类于 面试"><span itemprop="name">面试</span></a><meta itemprop="position" content="1"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://eth168.top/interview/JavaSE%E2%80%94%E9%9B%86%E5%90%88/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="雾都"><meta itemprop="description" content=", 花非花，雾非雾"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="每天进步一点点，就是成功的开始"></span><div class="body md" itemprop="articleBody"><p><strong>基础</strong></p><h3 id="arraylist集合的add过程"><a class="anchor" href="#arraylist集合的add过程">#</a> <strong>ArrayList 集合的 add 过程</strong></h3><p><strong>1.7 和 1.8 的区别</strong></p><p>在 1.7 的时候创建不传参直接初始化为 10,</p><p>在 1.8 的时候，只是空参构造初始化为 {}，元素个数为 0，什么时候为 10 呢？——》在第一次 add 时候</p><p>默认初始化一个数组长度 <strong>1.7：10</strong> ；<strong>1.8：0（在第一次 add 时候变为 10）</strong>，最大长度为 Integer.MAX_VALUE=2147483647=(2^31)-1 ;</p><p>当 <code>size</code> &gt;10 时，list 要变，也就是说数组要扩容，扩容为原来的 1.5 倍</p><pre><code>    /**
    * minCapacity =size+1
    */
    private void grow(int minCapacity) &#123;
        // overflow-conscious code
        int oldCapacity = elementData.length;
        //新的数组长度
        int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);
        // 扩容后还小于 size+1
        if (newCapacity - minCapacity &lt; 0)
            newCapacity = minCapacity;
        // 扩容后大于 Integer.MAX_VALUE - 8
        if (newCapacity - MAX_ARRAY_SIZE &gt; 0)
            newCapacity = hugeCapacity(minCapacity);
        // minCapacity is usually close to size, so this is a win:
        elementData = Arrays.copyOf(elementData, newCapacity);
    &#125;
</code></pre><p>当到达极端情况下此时 arr 为最大时 2^31-8</p><pre><code>        int a = Integer.MAX_VALUE;
        //MAX_ARRAY_SIZE(2^31-8)
        int b = a - 8;
        // newCapacity
        int c = b + b &gt;&gt; 1;

        //MAX_ARRAY_SIZE(2^31-8)
        System.out.println(&quot;MAX_ARRAY_SIZE:&quot;+b);
        // newCapacity
        System.out.println(&quot;newCapacity:&quot;+c);
        // newCapacity - minCapacity( size + 1 )
        System.out.println(&quot;newCapacity - minCapacity:&quot;+(c-(b+1)));
        // newCapacity - MAX_ARRAY_SIZE(2^31-8)
        System.out.println(&quot;newCapacity - MAX_ARRAY_SIZE:&quot;+(c - (a-8)));
</code></pre><p>结果：</p><pre><code>MAX_ARRAY_SIZE: 2147483639
newCapacity: -1073741838
ewCapacity - minCapacity: 1073741818
newCapacity - MAX_ARRAY_SIZE: 1073741819
</code></pre><h3 id="18为什么改变成17的头插法成尾插法"><a class="anchor" href="#18为什么改变成17的头插法成尾插法">#</a> <strong>1.8 为什么改变成 1.7 的头插法成尾插法？</strong></h3><p>剖析：</p><p>一个链表想要用<strong>尾插</strong>的形式插入数据，我们首先得知道他的<em> next</em> 是否为<em> null</em>,</p><pre><code>class node&lt;T&gt;&#123;
    T data;
    node next;
&#125;
</code></pre><p>一个链表想要用<strong>头插</strong>的形式插入数据，我们首先得知道他的<em> pre</em> 是否为<em> null</em>, 其次找到之后还要将新元素的<em> next</em> 指向原来的头结点</p><pre><code>class node&lt;T&gt; &#123;
    T data;
    node pre;
    node next;
&#125;
</code></pre><p>*<strong> 总结：*</strong></p><p>​	从创建开始他的头插的结构体 &gt; 尾插的结构体，其次最主要的是<strong>头插容易形成环形结构</strong>，造成 CPU 的损耗，尾插法可以避免</p><p>![image-20220709101908776](file://D:/_Myself/%E9%9D%A2%E8%AF%95/%E9%9D%A2%E8%AF%95%E9%A2%98/img/image-20220709101908776.png?lastModify=1673361991)</p><h3 id="victor-和-arraylist区别"><a class="anchor" href="#victor-和-arraylist区别">#</a> <strong>Victor 和 ArrayList 区别</strong></h3><p>【1】底层 Object 数组，int 类型属性表示数组中有效长度：</p><p>![image-20220629231051908](file://D:/_Myself/%E9%9D%A2%E8%AF%95/%E9%9D%A2%E8%AF%95%E9%A2%98/img/image-20220629231051908.png?lastModify=1673361991)</p><p>【2】Vector v=new Vector (); 调用构造器：</p><p>![image-20220629231123796](file://D:/_Myself/%E9%9D%A2%E8%AF%95/%E9%9D%A2%E8%AF%95%E9%A2%98/img/image-20220629231123796.png?lastModify=1673361991)</p><p>【3】add 方法：</p><p>![image-20220629231602106](file://D:/_Myself/%E9%9D%A2%E8%AF%95/%E9%9D%A2%E8%AF%95%E9%A2%98/img/image-20220629231602106.png?lastModify=1673361991)</p><p>![image-20220629231137216](file://D:/_Myself/%E9%9D%A2%E8%AF%95/%E9%9D%A2%E8%AF%95%E9%A2%98/img/image-20220629231137216.png?lastModify=1673361991)</p><p><strong>总结：</strong></p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">Vector</th><th style="text-align:center">ArrayList</th></tr></thead><tbody><tr><td style="text-align:center">底层</td><td style="text-align:center">数组</td><td style="text-align:center">数组</td></tr><tr><td style="text-align:center">初始化</td><td style="text-align:center">直接为长度为 10 的数组</td><td style="text-align:center">1.7：直接为长度为 10 的数组<br>1.8 只初始化为 {} 元素个数为 0 的数组，在第一次 add 的时候扩大到 10</td></tr><tr><td style="text-align:center">扩容</td><td style="text-align:center">2 倍</td><td style="text-align:center">1.5</td></tr><tr><td style="text-align:center">安全性</td><td style="text-align:center">安全<br>add 方法加了 synchronized</td><td style="text-align:center">不安全<br></td></tr><tr><td style="text-align:center">效率</td><td style="text-align:center">低</td><td style="text-align:center">高</td></tr></tbody></table><h3 id="iteratoriteratoriterable关系"><a class="anchor" href="#iteratoriteratoriterable关系">#</a> <strong>iterator (),Iterator,Iterable 关系</strong></h3><p>![image-20220629233802397](file://D:/_Myself/%E9%9D%A2%E8%AF%95/%E9%9D%A2%E8%AF%95%E9%A2%98/img/image-20220629233802397.png?lastModify=1673361991)</p><p><strong>增强 for 循环 底层也是通过迭代器实现的：</strong></p><p><strong>总结：</strong></p><p><code>iterator()</code> 是 <code>Iterable</code> 接口 中的一个抽象方法， <code>ArrayList</code> 内部类 <code>Itr</code> 实现了 <code>Iterator</code> 接口， <code>iterator()</code> 是 Arraylist 内部的一个方法</p><h3 id="listiterator迭代器"><a class="anchor" href="#listiterator迭代器">#</a> <strong>ListIterator 迭代器</strong></h3><p>迭代器不可以和 list 同时操作一个对象，可以用迭代器对象直接操作</p><p>不仅有 <code>正向迭代</code> 还有 <code>逆向迭代</code></p><pre><code> ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();
        list.add(&quot;aa&quot;);
        list.add(&quot;bb&quot;);
        list.add(&quot;cc&quot;);
        list.add(&quot;dd&quot;);
        list.add(&quot;ee&quot;);
        //在&quot;cc&quot;之后添加一个字符串&quot;kk&quot;
        ListIterator&lt;String&gt; it = list.listIterator();
while(it.hasNext())&#123;
            if(&quot;cc&quot;.equals(it.next()))&#123;
                it.add(&quot;kk&quot;);
            &#125;
        &#125;
</code></pre><h3 id="linkedlist底层"><a class="anchor" href="#linkedlist底层">#</a> <strong>LinkedList 底层</strong></h3><p>​	链表，双向链表</p><p>输入和输出结构顺序一致</p><h3 id="hashset底层是什么"><a class="anchor" href="#hashset底层是什么">#</a> <strong>HashSet 底层是什么</strong></h3><p><a href="#hashMap_base_code">HashMap</a>，所有的值都存在了 <strong>key</strong> 中</p><p>![image-20220630002635848](file://D:/_Myself/%E9%9D%A2%E8%AF%95/%E9%9D%A2%E8%AF%95%E9%A2%98/img/image-20220630002635848.png?lastModify=1673361991)</p><p><strong>基本原理：</strong></p><p>​	在存放数据时，首先要对数据进行 <code>hash</code> 计算然后根据 hash 值存放到对应的数组地址上，地址重复时，再在该位置上引申上一个链表，在每个值插入之前我们都先要对存储过的值进行比较，用的是 <code>equals</code> , 如果存在就不存了。</p><p>引申</p><p>1、要放入 HashSet 的元素 要具备 <code>Hash</code> 、 <code>equals</code> 两大方法且适合自己，即在自己的类要重写</p><p>2、哈希表 = 数组 + 链表</p><h3 id="linkedset底层"><a class="anchor" href="#linkedset底层">#</a> <strong>LinkedSet 底层</strong></h3><p>​	哈希表 + 链表</p><p>唯一，输出顺序和输入顺序一致</p><h3 id="treeset底层"><a class="anchor" href="#treeset底层">#</a> <strong>TreeSet 底层</strong></h3><p>TreeMap 底层数据结构为 二叉树，</p><p>他与输入结果 无序，输出结果，有序</p><p>一般情况下，随意输入，但是存储的时候，会经过比较器（内部比较强 / 外部比较器 [多用]），经过计算将结果放到合适的位置上，输出的时候，利用中序遍历输出得到一个升序的结果。</p><p>引申</p><p><strong>1、外部比较器</strong></p><p>要实现 <code>Comparator</code> 接口 ，重写 <code>camparr</code> 方法，自定义比较方式，<strong>多用</strong></p><p>![image-20220630115643791](file://D:/_Myself/%E9%9D%A2%E8%AF%95/%E9%9D%A2%E8%AF%95%E9%A2%98/img/image-20220630115643791.png?lastModify=1673361991)</p><p><strong>2、二叉树的遍历方式</strong></p><p>​	3 种：先序遍历、中序遍历、后序遍历</p><p><strong>先、中、后说的是根节点</strong>，例如</p><p>先：12 3 7 9</p><p>中：3 7 9 12 16</p><p>后：3 7 9 16 12</p><p>![image-20220630115853278](file://D:/_Myself/%E9%9D%A2%E8%AF%95/%E9%9D%A2%E8%AF%95%E9%A2%98/img/image-20220630115853278.png?lastModify=1673361991)</p><h3 id="hashmap底层"><a class="anchor" href="#hashmap底层">#</a> <strong>HashMap 底层</strong></h3><h4 id="17底层遵照-font-colorred-哈希表结构-font头插法"><a class="anchor" href="#17底层遵照-font-colorred-哈希表结构-font头插法">#</a> <strong>1.7 底层遵照</strong> <em><em><em>*<font color="red">*</font></em>*<em> 哈希表结构 *</em> *</em>*</em>**<strong>(头插法)</strong></h4><p>1.7 的源码</p><pre><code>    //哈希表默认的数组长度
    static final int DEFAULT_INITIAL_CAPACITY = 16;
    // 最大长度
    static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;
        //定义了一个float类型的变量，以后作为：默认的装填因子，加载因子是表示Hsah表中元素的填满的程度
        //太大容易引起哈西冲突，太小容易浪费  0.75是经过大量运算后得到的最好值
        //这个值其实可以自己改，但是不建议改，因为这个0.75是大量运算得到的
        static final float DEFAULT_LOAD_FACTOR = 0.75f;
        transient Entry&lt;K,V&gt;[] table;//主数组,每个元素为Entry类型，1.8改名为Node内部一样
        transient int size;
        int threshold;//数组扩容的界限值,门槛值   16*0.75=12 
        final float loadFactor;//用来接收装填因子的变量


        
        //【4】查看构造器：内部相当于：this(16,0.75f);调用了当前类中的带参构造器
        public HashMap() &#123;
        this(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR);
    &#125;
        //【5】本类中带参数构造器：--》作用给一些数值进行初始化的！
        public HashMap(int initialCapacity, float loadFactor) &#123;
        //【6】给capacity赋值，capacity的值一定是 大于你传进来的initialCapacity 的 最小的 2的倍数
        int capacity = 1;
        while (capacity &lt; initialCapacity)
            capacity &lt;&lt;= 1;
                //【7】给loadFactor赋值，将装填因子0.75赋值给loadFactor
        this.loadFactor = loadFactor;
                //【8】数组扩容的界限值,门槛值
        threshold = (int)Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + 1);
                
                //【9】给table数组赋值，初始化数组长度为16
        table = new Entry[capacity];
                   
    &#125;
        //【10】调用put方法：
        public V put(K key, V value) &#123;
                //【11】对空值的判断
            if (key == null)
                return putForNullKey(value);
                    //【12】调用hash方法，获取哈希码
            int hash = hash(key);
                    //【14】得到key对应在数组中的位置
            int i = indexFor(hash, table.length);
                    //【16】如果你放入的元素，在主数组那个位置上没有值，e==null  那么下面这个循环不走
                    //当在同一个位置上放入元素的时候
            for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123;
                Object k;
                            //哈希值一样  并且  equals相比一样   
                            //(k = e.key) == key  如果是一个对象就不用比较equals了
                if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;
                    V oldValue = e.value;
                    e.value = value;
                    e.recordAccess(this);
                    return oldValue;
                &#125;
            &#125;
            modCount++;
                    //【17】走addEntry添加这个节点的方法：
            addEntry(hash, key, value, i);
            return null;
          &#125;
        
        //【13】hash方法返回这个key对应的哈希值，内部进行二次散列，为了尽量保证不同的key得到不同的哈希码！
        final int hash(Object k) &#123;
        int h = 0;
        if (useAltHashing) &#123;
            if (k instanceof String) &#123;
                return sun.misc.Hashing.stringHash32((String) k);
            &#125;
            h = hashSeed;
        &#125;
                //k.hashCode()函数调用的是key键值类型自带的哈希函数，
                //由于不同的对象其hashCode()有可能相同，所以需对hashCode()再次哈希，以降低相同率。
        h ^= k.hashCode();
        // This function ensures that hashCodes that differ only by
        // constant multiples at each bit position have a bounded
        // number of collisions (approximately 8 at default load factor).
                /*
                接下来的一串与运算和异或运算，称之为“扰动函数”，
                扰动的核心思想在于使计算出来的值在保留原有相关特性的基础上，
                增加其值的不确定性，从而降低冲突的概率。
                不同的版本实现的方式不一样，但其根本思想是一致的。
                往右移动的目的，就是为了将h的高位利用起来，减少哈西冲突
                */
        h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12);
        return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);
    &#125;
        //【15】返回int类型数组的坐标
        static int indexFor(int h, int length) &#123;
                //其实这个算法就是取模运算：h%length，取模效率不如位运算
        return h &amp; (length-1);
    &#125;
        //【18】调用addEntry
        void addEntry(int hash, K key, V value, int bucketIndex) &#123;
                //【25】size的大小  大于 16*0.75=12的时候，比如你放入的是第13个，这第13个你打算放在没有元素的位置上的时候
        if ((size &gt;= threshold) &amp;&amp; (null != table[bucketIndex])) &#123;
                        //【26】主数组扩容为2倍
            resize(2 * table.length);
                        //【30】重新调整当前元素的hash码
            hash = (null != key) ? hash(key) : 0;
                        //【31】重新计算元素位置
            bucketIndex = indexFor(hash, table.length);
        &#125;
                //【19】将hash,key,value,bucketIndex位置  封装为一个Entry对象：
        createEntry(hash, key, value, bucketIndex);
    &#125;
        //【20】
        void createEntry(int hash, K key, V value, int bucketIndex) &#123;
                //【21】获取bucketIndex位置上的元素给e
        Entry&lt;K,V&gt; e = table[bucketIndex];
                //【22】然后将hash, key, value封装为一个对象，然后将下一个元素的指向为e （链表的头插法）
                //【23】将新的Entry放在table[bucketIndex]的位置上
        table[bucketIndex] = new Entry&lt;&gt;(hash, key, value, e);
                //【24】集合中加入一个元素 size+1
        size++;
    &#125;
    //【27】
        void resize(int newCapacity) &#123;
        Entry[] oldTable = table;
        int oldCapacity = oldTable.length;
        if (oldCapacity == MAXIMUM_CAPACITY) &#123;
            threshold = Integer.MAX_VALUE;
            return;
        &#125;
                //【28】创建长度为newCapacity的数组
        Entry[] newTable = new Entry[newCapacity];
        boolean oldAltHashing = useAltHashing;
        useAltHashing |= sun.misc.VM.isBooted() &amp;&amp;
                (newCapacity &gt;= Holder.ALTERNATIVE_HASHING_THRESHOLD);
        boolean rehash = oldAltHashing ^ useAltHashing;
                //【28.5】转让方法：将老数组中的东西都重新放入新数组中
        transfer(newTable, rehash);
                //【29】老数组替换为新数组
        table = newTable;
                //【29.5】重新计算
        threshold = (int)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + 1);
    &#125;
        //【28.6】
        void transfer(Entry[] newTable, boolean rehash) &#123;
        int newCapacity = newTable.length;
        for (Entry&lt;K,V&gt; e : table) &#123;
            while(null != e) &#123;
                Entry&lt;K,V&gt; next = e.next;
                if (rehash) &#123;
                    e.hash = null == e.key ? 0 : hash(e.key);
                &#125;
                                //【28.7】将哈希值，和新的数组容量传进去，重新计算key在新数组中的位置
                int i = indexFor(e.hash, newCapacity);
                                //【28.8】头插法
                e.next = newTable[i];//获取链表上元素给e.next
                newTable[i] = e;//然后将e放在i位置 
                e = next;//e再指向下一个节点继续遍历
            &#125;
        &#125;
    &#125;
</code></pre><p>1.7 的头插可能会产生什么问题，为什么？</p><p>问题： 可能会产生环链</p><p>解析：</p><p>通过他的扩容过程中，正常状态下会，他原位置不会变化，只是因为他的结点插入方式为头插法导致我们在每一次的扩容过程之后都会导致我们的链表顺序要翻转一次，这就有一个问题，在单线程的情况下，这么设计是没有问题的，但是在多线程且没有锁的情况下可能会导致产生环。</p><p><strong>扩容前</strong></p><p>![image-20220819102531781](file://D:/_Myself/%E9%9D%A2%E8%AF%95/%E9%9D%A2%E8%AF%95%E9%A2%98/img/image-20220819102531781.png?lastModify=1673361991)</p><p>正常 resize () 后</p><p>![image-20220819102607885](file://D:/_Myself/%E9%9D%A2%E8%AF%95/%E9%9D%A2%E8%AF%95%E9%A2%98/img/image-20220819102607885.png?lastModify=1673361991)</p><p>![image-20220819101051964](file://D:/_Myself/%E9%9D%A2%E8%AF%95/%E9%9D%A2%E8%AF%95%E9%A2%98/img/image-20220819101051964.png?lastModify=1673361991)</p><p>简单解释一下：</p><p>假设现在两个线程都已经进入到了 trasfer () 方法并且同时到达 rehash 的地方，线程 Thread 2 落后于 Thread 1</p><p>这时候 Thread 1 已经扩容结束，但是在线程 Thread 2 中的 oldTable 并不是我们修改后的还是原来的，这就有问题了</p><p>Thread1 结果</p><p>![image-20220819110029605](file://D:/_Myself/%E9%9D%A2%E8%AF%95/%E9%9D%A2%E8%AF%95%E9%A2%98/img/image-20220819110029605.png?lastModify=1673361991)</p><p>Thread2 结果</p><p>![image-20220819113951593](file://D:/_Myself/%E9%9D%A2%E8%AF%95/%E9%9D%A2%E8%AF%95%E9%A2%98/img/image-20220819113951593.png?lastModify=1673361991)</p><table><thead><tr><th style="text-align:center">Thread 1</th><th style="text-align:center">Thread 2</th></tr></thead><tbody><tr><td style="text-align:center">进入 transfer</td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center">进入 transfer</td></tr><tr><td style="text-align:center">e-&gt;3, next-&gt; 2</td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center">e-&gt;3, next-&gt; 2</td></tr><tr><td style="text-align:center">开始 rehash ()</td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center">开始 rehash ()</td></tr><tr><td style="text-align:center">扩容</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">扩容结束 (Thread1 结果)</td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center">扩容</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">扩容结束 (Thread2 结果)</td></tr></tbody></table><p>总结：因为两个线程同时记录的了原链表最初的 结点 e 地址和 next 地址，在一个线程修改完成后顺序由 321 变成了 123，另一个线程再去修改 ，由于头插的缘故 最开始 3-&gt;2 在修改完成后的 2-&gt;3 之间就回形成环路</p><h4 id="18底层遵照-font-colorred-哈希表结构-红黑树font尾插法"><a class="anchor" href="#18底层遵照-font-colorred-哈希表结构-红黑树font尾插法">#</a> <strong>1.8 底层遵照</strong> <em><em><em>*<font color="red">*</font></em>*<em> 哈希表结构 + 红黑树 *</em>*</em>*</em>**<strong>（尾插法）</strong></h4><pre><code>// HashMap&lt;String,Integer&gt; map = new HashMap&lt;&gt;(); --&gt;JDK 1.7开始类型推断，后面用钻石运算符即可。
public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt;      //【1】继承的AbstractMap中，已经实现了Map接口
    implements Map&lt;K,V&gt;, Cloneable, Serializable &#123; //【2】又实现了这个接口，多余，但是集合的设计者觉得没有必要删除，就这么地了

    //------------------属性部分：
    final float loadFactor;//【3-2】用来接收装填因子的变量
    /*
        【3-3】
        定义了一个float类型的变量，以后作为：默认的装填因子，加载因子是表示Hsah表中元素的填满的程度
        太大容易引起哈西冲突，太小容易浪费  0.75是经过大量运算后得到的最好值
        这个值其实可以自己改，但是不建议改，因为这个0.75是大量运算得到的
    */
    static final float DEFAULT_LOAD_FACTOR = 0.75f;
    int threshold;//【6-3】数组扩容的界限值,门槛值
    transient Node&lt;K,V&gt;[] table;//【7-5】底层主数组
    //------------------构造器：
    //【3】调用空构造器
    public HashMap() &#123;
        //【3-1】给装填因子loadFactor赋值
        this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted
    &#125;
    
    //【4】调用有参构造器：
    public HashMap(int initialCapacity) &#123;
        //【5】调用两个参数构造器
        this(initialCapacity, DEFAULT_LOAD_FACTOR);
    &#125;
    //【6】
    public HashMap(int initialCapacity, float loadFactor) &#123;
        //【6-1】健壮性考虑，传入的数据过小不行，过大不行
        if (initialCapacity &lt; 0)
            throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; +
                                               initialCapacity);
        if (initialCapacity &gt; MAXIMUM_CAPACITY)
            initialCapacity = MAXIMUM_CAPACITY;
        if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))
            throw new IllegalArgumentException(&quot;Illegal load factor: &quot; +
                                               loadFactor);
        //【6-2】给装填因子loadFactor赋值，赋值为0.75，这个值可以单独传入改变，但是不建议改变，一般都用默认的0.75
        this.loadFactor = loadFactor;
        //【6-3】给threshold赋值 
        this.threshold = tableSizeFor(initialCapacity);
    &#125;
    //【6-4】返回的是大于initialCapacity的最接近的2的整数倍  ，比如initialCapacity传入10，这个方法返回16
    static final int tableSizeFor(int cap) &#123;//（内部内容讲源码时候不用管，面试题中详讲）
        int n = cap - 1;
        n |= n &gt;&gt;&gt; 1;
        n |= n &gt;&gt;&gt; 2;
        n |= n &gt;&gt;&gt; 4;
        n |= n &gt;&gt;&gt; 8;
        n |= n &gt;&gt;&gt; 16;
        return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;
    &#125;
    
    //------------------方法：
    //【7】调用put方法
    public V put(K key, V value) &#123;
        //【7-1】首先调用hash方法计算哈希值：
        //【7-3】调用putVal方法传入五个参数：
        return putVal(hash(key), key, value, false, true);
    &#125;
    //【7-2】计算hash值
    static final int hash(Object key) &#123;
        int h;
        return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);
    &#125;
    //【7-4】调用
    final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
                   boolean evict) &#123;
        Node&lt;K,V&gt;[] tab;
        Node&lt;K,V&gt; p; 
        int n, i;
        //【7-6】将底层主数组table给tab，判断是否为null，第一次放数据一定是null
        if ((tab = table) == null || (n = tab.length) == 0)
            //【7-7】走入if分支：table是null，就对table进行扩容，走进resize方法
            n = (tab = resize()).length;//【7-21】table的length为16 ，n为16
        /*
        【7-22】
        i = (n - 1) &amp; hash 根据哈希值和n计算放入数组的位置
        取出这个位置上的元素，看是否为空，如果是第一个元素，一定是null
        */
        if ((p = tab[i = (n - 1) &amp; hash]) == null)
            //【7-23】在这个位置上将元素封装为Node对象，放入对应位置
            tab[i] = newNode(hash, key, value, null);//封装Node节点new Node&lt;&gt;(hash, key, value, null);
        else &#123;
            Node&lt;K,V&gt; e; K k;
            if (p.hash == hash &amp;&amp;
                ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))
                e = p;
            else if (p instanceof TreeNode)
                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);
            else &#123;
                for (int binCount = 0; ; ++binCount) &#123;
                    if ((e = p.next) == null) &#123;
                        p.next = newNode(hash, key, value, null);
                        if (binCount &gt;= TREEIFY_THRESHOLD - 1)  
                            treeifyBin(tab, hash);
                        break;
                    &#125;
                    if (e.hash == hash &amp;&amp;
                        ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))
                        break;
                    p = e;
                &#125;
            &#125;
            if (e != null) &#123;  
                V oldValue = e.value;
                if (!onlyIfAbsent || oldValue == null)
                    e.value = value;
                afterNodeAccess(e);
                return oldValue;
            &#125;
        &#125;
        ++modCount;
        //【7-25】size指的是放入集合的键值总数，size++操作，不大于threshold，resize方法不走
        if (++size &gt; threshold)
            resize();
        afterNodeInsertion(evict);
        return null;
    &#125;
    //【7-8】resize方法：---》假设最开始走的是HashMap的空构造器：
    final Node&lt;K,V&gt;[] resize() &#123;
        Node&lt;K,V&gt;[] oldTab = table;//【7-9】table 是null
        int oldCap = (oldTab == null) ? 0 : oldTab.length; //【7-10】oldCap:0
        int oldThr = threshold;//【7-11】threshold为16，oldThr：16
        int newCap, newThr = 0;
        if (oldCap &gt; 0) &#123;//【7-12】不走
            if (oldCap &gt;= MAXIMUM_CAPACITY) &#123;
                threshold = Integer.MAX_VALUE;
                return oldTab;
            &#125;
            else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;
                     oldCap &gt;= DEFAULT_INITIAL_CAPACITY)
                newThr = oldThr &lt;&lt; 1;
        &#125;
        else if (oldThr &gt; 0)  //【7-13】走
            newCap = oldThr;//newCap=16
        else &#123;               //【7-14】不走
             
            newCap = DEFAULT_INITIAL_CAPACITY;
             
            newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);
        &#125;
        if (newThr == 0) &#123;//【7-15】走
            float ft = (float)newCap * loadFactor;//【7-16】ft: 16*0.75=12
            newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?
                      (int)ft : Integer.MAX_VALUE); //【7-17】newThr = 12
        &#125;
        //【7-18】threshold赋值为newThr为12， ---》所以走空构造器这里threshold赋值为12，走有参构造器里面threshold赋值为12？？？？
        threshold = newThr;
        @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)
        //【7-19】创建Node数组，长度为newCap16
            Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];
        //【7-20】table赋值为newTab
        table = newTab;
        if (oldTab != null) &#123;
            for (int j = 0; j &lt; oldCap; ++j) &#123;
                Node&lt;K,V&gt; e;
                if ((e = oldTab[j]) != null) &#123;
                    oldTab[j] = null;
                    if (e.next == null)
                        newTab[e.hash &amp; (newCap - 1)] = e;
                    else if (e instanceof TreeNode)
                        ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);
                    else &#123; 
                        Node&lt;K,V&gt; loHead = null, loTail = null;
                        Node&lt;K,V&gt; hiHead = null, hiTail = null;
                        Node&lt;K,V&gt; next;
                        do &#123;
                            next = e.next;
                            if ((e.hash &amp; oldCap) == 0) &#123;
                                if (loTail == null)
                                    loHead = e;
                                else
                                    loTail.next = e;
                                loTail = e;
                            &#125;
                            else &#123;
                                if (hiTail == null)
                                    hiHead = e;
                                else
                                    hiTail.next = e;
                                hiTail = e;
                            &#125;
                        &#125; while ((e = next) != null);
                        if (loTail != null) &#123;
                            loTail.next = null;
                            newTab[j] = loHead;
                        &#125;
                        if (hiTail != null) &#123;
                            hiTail.next = null;
                            newTab[j + oldCap] = hiHead;
                        &#125;
                    &#125;
                &#125;
            &#125;
        &#125;
        return newTab;
    &#125;
&#125;
</code></pre><pre><code>public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; 
    implements Map&lt;K,V&gt;, Cloneable, Serializable &#123; 
    final float loadFactor;
    static final float DEFAULT_LOAD_FACTOR = 0.75f;
    int threshold;
    transient Node&lt;K,V&gt;[] table;
    public HashMap() &#123;
        this.loadFactor = DEFAULT_LOAD_FACTOR; 
    &#125;
    
    public HashMap(int initialCapacity) &#123;
        this(initialCapacity, DEFAULT_LOAD_FACTOR);
    &#125;
    public HashMap(int initialCapacity, float loadFactor) &#123;
        if (initialCapacity &lt; 0)
            throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; +
                                               initialCapacity);
        if (initialCapacity &gt; MAXIMUM_CAPACITY)
            initialCapacity = MAXIMUM_CAPACITY;
        if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))
            throw new IllegalArgumentException(&quot;Illegal load factor: &quot; +
                                               loadFactor);
        this.loadFactor = loadFactor;
        this.threshold = tableSizeFor(initialCapacity);
    &#125;
    static final int tableSizeFor(int cap) &#123;
        int n = cap - 1;
        n |= n &gt;&gt;&gt; 1;
        n |= n &gt;&gt;&gt; 2;
        n |= n &gt;&gt;&gt; 4;
        n |= n &gt;&gt;&gt; 8;
        n |= n &gt;&gt;&gt; 16;
        return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;
    &#125;
    
    //【8-1】put方法
    public V put(K key, V value) &#123;
        //计算hash值
        return putVal(hash(key), key, value, false, true);
    &#125;

    static final int hash(Object key) &#123;
        int h;
        return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);
    &#125;
    //【8-2】调用putVal方法
    final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
                   boolean evict) &#123;
        Node&lt;K,V&gt;[] tab;
        Node&lt;K,V&gt; p; 
        int n, i;
        
        //【8-3】table不空了，不走if        
        if ((tab = table) == null || (n = tab.length) == 0)
            n = (tab = resize()).length;
        //【8-4】tab[i]不null，不走if
        if ((p = tab[i = (n - 1) &amp; hash]) == null)
            tab[i] = newNode(hash, key, value, null);
        else &#123;
            Node&lt;K,V&gt; e; K k;
            /*
                【8-5】
                判断p.hash == hash哈希值是否相等，即使hash相等也要做&amp;&amp;后续的判断，因为两个对象哈希值相等是有可能的
                (k = p.key) == key   == 比较地址值，String的话一样，不是字符串地址也不一样，
                Animal a1 = new Animal(19);     和   Animal a2 = new Animal(19); 地址一定不同，就需要用后面的equals进行比较
            */
            if (p.hash == hash &amp;&amp;
                ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))   //----》哈希值相等，出现哈西碰撞
                //【8-6】将该数组位置的数据给e
                e = p;
            else if (p instanceof TreeNode)
                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);
            else &#123;
                for (int binCount = 0; ; ++binCount) &#123;
                    if ((e = p.next) == null) &#123;
                        p.next = newNode(hash, key, value, null);
                        if (binCount &gt;= TREEIFY_THRESHOLD - 1)  
                            treeifyBin(tab, hash);
                        break;
                    &#125;
                    if (e.hash == hash &amp;&amp;
                        ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))
                        break;
                    p = e;
                &#125;
            &#125;
            if (e != null) &#123;  
                V oldValue = e.value;
                if (!onlyIfAbsent || oldValue == null)
                    e.value = value;//【8-7】新value替换老value
                afterNodeAccess(e);
                return oldValue;//【8-8】返回老value
            &#125;
        &#125;
        ++modCount;

        if (++size &gt; threshold)
            resize();
        afterNodeInsertion(evict);
        return null;
    &#125;

    final Node&lt;K,V&gt;[] resize() &#123;
        Node&lt;K,V&gt;[] oldTab = table;
        int oldCap = (oldTab == null) ? 0 : oldTab.length; 
        int oldThr = threshold;
        int newCap, newThr = 0;
        if (oldCap &gt; 0) &#123;
            if (oldCap &gt;= MAXIMUM_CAPACITY) &#123;
                threshold = Integer.MAX_VALUE;
                return oldTab;
            &#125;
            else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;
                     oldCap &gt;= DEFAULT_INITIAL_CAPACITY)
                newThr = oldThr &lt;&lt; 1;
        &#125;
        else if (oldThr &gt; 0) 
            newCap = oldThr;
        else &#123;    
            newCap = DEFAULT_INITIAL_CAPACITY;
            newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);
        &#125;
        if (newThr == 0) &#123;
            float ft = (float)newCap * loadFactor;
            newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?
                      (int)ft : Integer.MAX_VALUE);
        &#125;
        threshold = newThr;
        @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)
            Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];
        table = newTab;
        if (oldTab != null) &#123;
            for (int j = 0; j &lt; oldCap; ++j) &#123;
                Node&lt;K,V&gt; e;
                if ((e = oldTab[j]) != null) &#123;
                    oldTab[j] = null;
                    if (e.next == null)
                        newTab[e.hash &amp; (newCap - 1)] = e;
                    else if (e instanceof TreeNode)
                        ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);
                    else &#123; 
                        Node&lt;K,V&gt; loHead = null, loTail = null;
                        Node&lt;K,V&gt; hiHead = null, hiTail = null;
                        Node&lt;K,V&gt; next;
                        do &#123;
                            next = e.next;
                            if ((e.hash &amp; oldCap) == 0) &#123;
                                if (loTail == null)
                                    loHead = e;
                                else
                                    loTail.next = e;
                                loTail = e;
                            &#125;
                            else &#123;
                                if (hiTail == null)
                                    hiHead = e;
                                else
                                    hiTail.next = e;
                                hiTail = e;
                            &#125;
                        &#125; while ((e = next) != null);
                        if (loTail != null) &#123;
                            loTail.next = null;
                            newTab[j] = loHead;
                        &#125;
                        if (hiTail != null) &#123;
                            hiTail.next = null;
                            newTab[j + oldCap] = hiHead;
                        &#125;
                    &#125;
                &#125;
            &#125;
        &#125;
        return newTab;
    &#125;
&#125;
</code></pre><pre><code>public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; 
    implements Map&lt;K,V&gt;, Cloneable, Serializable &#123; 
    final float loadFactor;
    static final float DEFAULT_LOAD_FACTOR = 0.75f;
    int threshold;
    transient Node&lt;K,V&gt;[] table;
    public HashMap() &#123;
        this.loadFactor = DEFAULT_LOAD_FACTOR; 
    &#125;
    
    public HashMap(int initialCapacity) &#123;
        this(initialCapacity, DEFAULT_LOAD_FACTOR);
    &#125;
    public HashMap(int initialCapacity, float loadFactor) &#123;
        if (initialCapacity &lt; 0)
            throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; +
                                               initialCapacity);
        if (initialCapacity &gt; MAXIMUM_CAPACITY)
            initialCapacity = MAXIMUM_CAPACITY;
        if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))
            throw new IllegalArgumentException(&quot;Illegal load factor: &quot; +
                                               loadFactor);
        this.loadFactor = loadFactor;
        this.threshold = tableSizeFor(initialCapacity);
    &#125;
    static final int tableSizeFor(int cap) &#123;
        int n = cap - 1;
        n |= n &gt;&gt;&gt; 1;
        n |= n &gt;&gt;&gt; 2;
        n |= n &gt;&gt;&gt; 4;
        n |= n &gt;&gt;&gt; 8;
        n |= n &gt;&gt;&gt; 16;
        return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;
    &#125;
    
    //【9-1】put方法
    public V put(K key, V value) &#123;
        //计算hash值
        return putVal(hash(key), key, value, false, true);
    &#125;

    static final int hash(Object key) &#123;
        int h;
        return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);
    &#125;
    //【9-2】调用putVal方法
    final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
                   boolean evict) &#123;
        Node&lt;K,V&gt;[] tab;
        Node&lt;K,V&gt; p; 
        int n, i;
        
        //【9-3】table不空了，不走if        
        if ((tab = table) == null || (n = tab.length) == 0)
            n = (tab = resize()).length;
        //【9-4】tab[i]不null，不走if
        if ((p = tab[i = (n - 1) &amp; hash]) == null)
            tab[i] = newNode(hash, key, value, null);
        else &#123;
            Node&lt;K,V&gt; e; K k;
            /*
                【9-5】
                判断p.hash == hash哈希值是否相等，即使hash相等也要做&amp;&amp;后续的判断，因为两个对象哈希值相等是有可能的
                此时“通话”和“重地”的哈希值一致，但是key不一致，if不走
            */
            if (p.hash == hash &amp;&amp;
                ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))
                e = p;
            else if (p instanceof TreeNode)//【9-6】p也不是红黑树，不走if
                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);
            else &#123;
                //【9-7】走到这里，证明数组的这个位置是个链表了
                for (int binCount = 0; ; ++binCount) &#123;//【9-8】无条件的死循环   binCount 链表上节点的个数
                    //随着循环  p.next就是一路找链上元素
                    //p.next要是没有元素，就要开始追加了呗
                    if ((e = p.next) == null) &#123;//【9-10】一路next比较都没有key相同的数据
                    
                        p.next = newNode(hash, key, value, null);//【9-11】追加在链表尾部 ---》 前七后八
                        //【9-12】如果节点个数大于8，进行树化：要从链表转为红黑树
                        if (binCount &gt;= TREEIFY_THRESHOLD - 1)  
                            treeifyBin(tab, hash);//【9-13】这里还涉及 剪枝 问题，树节点在6个以下，就又变成链表了
                        break;
                    &#125;
                    //【9-9】比较过程中：如果比较链表某个key相同，就break结束了，不用继续走了
                    if (e.hash == hash &amp;&amp;
                        ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))
                        break;
                    p = e;
                &#125;
            &#125;
            if (e != null) &#123;  
                V oldValue = e.value;
                if (!onlyIfAbsent || oldValue == null)
                    e.value = value;//【8-7】新value替换老value
                afterNodeAccess(e);
                return oldValue;//【8-8】返回老value
            &#125;
        &#125;
        ++modCount;

        if (++size &gt; threshold)
            resize();
        afterNodeInsertion(evict);
        return null;
    &#125;

    final Node&lt;K,V&gt;[] resize() &#123;
        Node&lt;K,V&gt;[] oldTab = table;
        int oldCap = (oldTab == null) ? 0 : oldTab.length; 
        int oldThr = threshold;
        int newCap, newThr = 0;
        if (oldCap &gt; 0) &#123;
            if (oldCap &gt;= MAXIMUM_CAPACITY) &#123;
                threshold = Integer.MAX_VALUE;
                return oldTab;
            &#125;
            else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;
                     oldCap &gt;= DEFAULT_INITIAL_CAPACITY)
                newThr = oldThr &lt;&lt; 1;
        &#125;
        else if (oldThr &gt; 0) 
            newCap = oldThr;
        else &#123;    
            newCap = DEFAULT_INITIAL_CAPACITY;
            newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);
        &#125;
        if (newThr == 0) &#123;
            float ft = (float)newCap * loadFactor;
            newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?
                      (int)ft : Integer.MAX_VALUE);
        &#125;
        threshold = newThr;
        @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)
            Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];
        table = newTab;
        if (oldTab != null) &#123;
            for (int j = 0; j &lt; oldCap; ++j) &#123;
                Node&lt;K,V&gt; e;
                if ((e = oldTab[j]) != null) &#123;
                    oldTab[j] = null;
                    if (e.next == null)
                        newTab[e.hash &amp; (newCap - 1)] = e;
                    else if (e instanceof TreeNode)
                        ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);
                    else &#123; 
                        Node&lt;K,V&gt; loHead = null, loTail = null;
                        Node&lt;K,V&gt; hiHead = null, hiTail = null;
                        Node&lt;K,V&gt; next;
                        do &#123;
                            next = e.next;
                            if ((e.hash &amp; oldCap) == 0) &#123;
                                if (loTail == null)
                                    loHead = e;
                                else
                                    loTail.next = e;
                                loTail = e;
                            &#125;
                            else &#123;
                                if (hiTail == null)
                                    hiHead = e;
                                else
                                    hiTail.next = e;
                                hiTail = e;
                            &#125;
                        &#125; while ((e = next) != null);
                        if (loTail != null) &#123;
                            loTail.next = null;
                            newTab[j] = loHead;
                        &#125;
                        if (hiTail != null) &#123;
                            hiTail.next = null;
                            newTab[j + oldCap] = hiHead;
                        &#125;
                    &#125;
                &#125;
            &#125;
        &#125;
        return newTab;
    &#125;
&#125;
</code></pre><p><strong>总结：</strong></p><p>默认（创建时只是初始化负载因子，数组长度是在第一次 put 的时候初始化的）<strong>数组长度为 16</strong>，<strong>最大程度</strong>，<strong> 负载因子为 0.75</strong>，扩容时<strong>扩大 2 倍</strong>，最大不超过 (一旦到达最开始的域值就变大)</p><p>1.8 相对于 1.7 只是改变了数据结构</p><h3 id="hashmap为什么要使用红黑树"><a class="anchor" href="#hashmap为什么要使用红黑树">#</a> <strong>Hashmap 为什么要使用红黑树？</strong></h3><p>​	在 jdk1.8 版本后，java 对 HashMap 做了改进，在<strong>链表长度大于 8</strong> 的时候，将后面的数据存在红黑树中，以加快检索速度</p><p>​	红黑树虽然本质上是一棵二叉查找树，但它在二叉查找树的基础上增加了着色和相关的性质使得红黑树相对平衡，从而保证了红黑树的查找、插入、删除的时间复杂度最坏为 O (log n)。加快检索速率。</p><p>引申</p><p>在<strong>链表长度小于 6</strong> 的时候，红黑树又会变回二叉树</p><h3 id="主数组的长度为什么是"><a class="anchor" href="#主数组的长度为什么是">#</a> <strong>主数组的长度为什么是</strong> ****\**\******<strong>？</strong></h3><p><strong>原因 1：</strong></p><p>因为这个 length 的长度，会影响 key 的位置：</p><p>![image-20220630132734570](file://D:/_Myself/%E9%9D%A2%E8%AF%95/%E9%9D%A2%E8%AF%95%E9%A2%98/img/image-20220630132734570.png?lastModify=1673361991)</p><p>实际上这个算法就是： h% length , 但是取模的话 效率太低，所以用位运算效率会很高。</p><p><strong>原因 2：</strong></p><p>如果不是 2 的整数倍，那么 哈西碰撞 哈西冲突的概率就高了很多</p><h3 id="装填因子075的原因"><a class="anchor" href="#装填因子075的原因">#</a> <strong>装填因子 0.75 的原因</strong></h3><p><strong>如果装填因子是 1， 那么数组满了再扩容，可以做到 最大的空间利用率</strong> 但是这是一个理想状态，元素不可能完全的均匀分布，很可能就哈西碰撞产生链表了。产生链表的话 查询时间就长了。</p><ul><li><strong>空间好，时间不好</strong></li></ul><p><strong>如果是 0.5 的话，就浪费空间，但是可以做到到 0.5 就扩容 ，然后哈西碰撞就少，不产生链表的话，那么查询效率很高</strong></p><ul><li><strong>时间好，空间不好</strong></li></ul><p><strong>总结：</strong></p><p>1 空间利用率高，但是容易造成<strong> hash 冲突</strong>，产生链表，降低查询效率；</p><p>0.5 不易造成 Hash 冲突，但是空间利用率低；</p><p>综上所述 JDK 官方折中处理取了一个中间值 0.75</p><h3 id="hashmap-的时间复杂度"><a class="anchor" href="#hashmap-的时间复杂度">#</a> <strong>HashMap 的时间复杂度</strong></h3><p>在数组中结点没有产生链表的情况下 O (1)</p><p>在产生链表但长度小于 8 的时候 O (n)</p><p>链表长度大于等于 8 的时候 O (logn)</p><h3 id="hashtable底层"><a class="anchor" href="#hashtable底层">#</a> <strong>HashTable 底层</strong></h3><p>底层遵照 哈希表结构</p><h3 id="linkedmap底层"><a class="anchor" href="#linkedmap底层">#</a> <strong>LinkedMap 底层</strong></h3><p>底层遵照 哈希表 + 链表</p><h3 id="hashmap和hashtable有什么区别"><a class="anchor" href="#hashmap和hashtable有什么区别">#</a> <strong>HashMap 和 Hashtable 有什么区别？</strong></h3><table><thead><tr><th style="text-align:left"></th><th style="text-align:center">HashMap</th><th style="text-align:center">Hashtable</th></tr></thead><tbody><tr><td style="text-align:left">存储</td><td style="text-align:center">允许 <code>Key</code> 为 null</td><td style="text-align:center">不允许 <code>Key</code> 为 null</td></tr><tr><td style="text-align:left">线程安全</td><td style="text-align:center">线程不安全</td><td style="text-align:center">线程安全</td></tr></tbody></table><p><strong>推荐使用</strong>：</p><p>​	在<strong> Hashtable</strong> 的类注释可以看到，<strong>Hashtable</strong> 是保留类<strong>不建议使用</strong>，推荐在<strong>单线程环境</strong>下使<strong>用 HashMap 替代</strong>，如果需要<strong>多线程</strong>使用则<strong>用 ConcurrentHashMap 替代</strong>。</p><h3 id="treemap底层"><a class="anchor" href="#treemap底层">#</a> <strong>TreeMap 底层</strong></h3><p>红黑树</p><pre><code>public class TreeMap&lt;K,V&gt;&#123;
        //重要属性：
        //外部比较器：
        private final Comparator&lt;? super K&gt; comparator;
        //树的根节点：
        private transient Entry&lt;K,V&gt; root = null;
        //集合中元素的数量：
        private transient int size = 0;
        //空构造器:
        public TreeMap() &#123;
        comparator = null;//如果使用空构造器，那么底层就不使用外部比较器
    &#125;
        //有参构造器：
        public TreeMap(Comparator&lt;? super K&gt; comparator) &#123;
        this.comparator = comparator;//如果使用有参构造器，那么就相当于指定了外部比较器
    &#125;
        
        public V put(K key, V value) &#123;//k,V的类型在创建对象的时候确定了
        //如果放入的是第一对元素，那么t的值为null
        Entry&lt;K,V&gt; t = root;//在放入第二个节点的时候，root已经是根节点了
                //如果放入的是第一个元素的话，走入这个if中：
        if (t == null) &#123;
                        //自己跟自己比
            compare(key, key); // type (and possibly null) check
                        //根节点确定为root
            root = new Entry&lt;&gt;(key, value, null);
                        //size值变为1
            size = 1;
            modCount++;
            return null;
        &#125;
                
        int cmp;
        Entry&lt;K,V&gt; parent;
        // split comparator and comparable paths
                //将外部比较器赋给cpr:
        Comparator&lt;? super K&gt; cpr = comparator;
                //cpr不等于null，意味着你刚才创建对象的时候调用了有参构造器，指定了外部比较器
        if (cpr != null) &#123;
            do &#123;
                parent = t;
                cmp = cpr.compare(key, t.key);//将元素的key值做比较
                                //cmp返回的值就是int类型的数据：
                                //要是这个值《0 =0  》0
                if (cmp &lt; 0)
                    t = t.left;
                else if (cmp &gt; 0)
                    t = t.right;
                else//cpm==0
                                //如果key的值一样，那么新的value替换老的value  但是key不变 因为key是唯一的
                    return t.setValue(value);
            &#125; while (t != null);
        &#125;
                //cpr等于null，意味着你刚才创建对象的时候调用了空构造器，没有指定外部比较器，使用内部比较器
        else &#123;
            if (key == null)
                throw new NullPointerException();
            Comparable&lt;? super K&gt; k = (Comparable&lt;? super K&gt;) key;
            do &#123;
                parent = t;
                cmp = k.compareTo(t.key);//将元素的key值做比较
                if (cmp &lt; 0)
                    t = t.left;
                else if (cmp &gt; 0)
                    t = t.right;
                else
                    return t.setValue(value);
            &#125; while (t != null);
        &#125;
        Entry&lt;K,V&gt; e = new Entry&lt;&gt;(key, value, parent);
        if (cmp &lt; 0)
            parent.left = e;
        else
            parent.right = e;
        fixAfterInsertion(e);
        size++;//size加1 操作
        modCount++;
        return null;
    &#125;
        
        
&#125;
 static final class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;
        K key;
        V value;
        Entry&lt;K,V&gt; left = null;
        Entry&lt;K,V&gt; right = null;
        Entry&lt;K,V&gt; parent;
        boolean color = BLACK;
 &#125;

</code></pre><h3 id="collection-和-collections-区别"><a class="anchor" href="#collection-和-collections-区别">#</a> <strong>Collection 和 Collections 区别</strong></h3><p>Collection，提供了对集合对象进行基本操作的通用<strong>接口方法</strong>，所有集合都是它的子类，比如 List、Set 等。</p><p>Collections，是一个<strong>工具类</strong>，它包含了很多静态方法，不能被实例化，比如排序方法： Collections. sort (list) 等。</p><h3 id="arraysaslist方法之后的集合可以调用什么方法"><a class="anchor" href="#arraysaslist方法之后的集合可以调用什么方法">#</a> <strong>Arrays.asList () 方法之后的集合可以调用什么方法</strong></h3><p>​ <code>size()</code> 只有 size 方法可用，通过查看源码我们知道，将传递过去的数组变成了一个 ArrayList 集合，但是不是 java.util.ArrayList 而是 java.util.Arrays.ArrayList , 也就是 Arrays 中的一个内部类，他的方法只定义了 <code>size</code> 、 <code>toArray</code> 、 <code>get</code> 、 <code>set</code> 和 <code>indexOf</code></p><p>![image-20220628202337546](file://D:/_Myself/%E9%9D%A2%E8%AF%95/%E9%9D%A2%E8%AF%95%E9%A2%98/img/image-20220628202337546.png?lastModify=1673361991)</p><p>![image-20220628202651719](file://D:/_Myself/%E9%9D%A2%E8%AF%95/%E9%9D%A2%E8%AF%95%E9%A2%98/img/image-20220628202651719.png?lastModify=1673361991)</p><h3 id="map-set-list的区别"><a class="anchor" href="#map-set-list的区别">#</a> <strong>Map、Set、List 的区别</strong></h3><p>![image-20220629181141368](file://D:/_Myself/%E9%9D%A2%E8%AF%95/%E9%9D%A2%E8%AF%95%E9%A2%98/img/image-20220629181141368.png?lastModify=1673361991)</p><p><strong>List</strong></p><blockquote><p>List 中存储的元素有序，指的是读出的顺序与存入的顺序是一致的。</p></blockquote><p>①可以允许重复的对象； ②可以插入多个 null 元素； ③是一个有序容器，保持了每个元素的插入顺序，输出的顺序就是插入的顺序； ④常用的实现类有 ArrayList、LinkedList 和 Vector；ArrayList 最为流行，它提供了使用索引的随意访问，而 LinkedList 则对于经常需要从 List 中添加或删除元素的场合更为合适。</p><p><strong>Set</strong></p><blockquote><p>Set 存储的元素是无序的，这里的无序指的是存入的顺序与输出的顺序可能是不一致的。</p></blockquote><p>①不允许重复对象； ②无序容器，你无法保证每个元素的存储顺序，TreeSet 通过 Comparator 或者 Comparable 维护了一个排序顺序； ③只允许一个 null 元素； ④Set 接口最流行的几个实现类是 HashSet、LinkedHashSet 以及 TreeSet； 最流行的是<strong>基于 HashMap</strong> 实现的 HashSet； TreeSet 还实现了 SortedSet 接口，因此 TreeSet 是一个根据其 compare () 和 compareTo () 的定义进行排序的有序容器。</p><p><strong>Map</strong></p><blockquote><p>Map 存储的元素是键值对（key-value），键和值都是无序的，即存入顺序与输出顺序可能都不一样。</p></blockquote><p>①Map 不是 Collection 的子接口或者实现类，Map 是一个接口； ②Map 的 每个 Entry 都持有两个对象，也就是一个键一个值，Map 可能会持有相同的值对象但键对象必须是唯一的； ③TreeMap 也通过 Comparator 或者 Comparable 维护了一个排序顺序； ④Map 里你可以拥有随意个 null 值，但最多只能有一个 null 键； ⑤Map 接口最流行的几个实现类是 HashMap、LinkedHashMap、Hashtable 和 TreeMap。（HashMap、TreeMap 最常用）</p><h3 id="hashset与treeset-区别httpswwwcnblogscomwilliamjiep9099038html"><a class="anchor" href="#hashset与treeset-区别httpswwwcnblogscomwilliamjiep9099038html">#</a> <em><em><em>*[*</em><a target="_blank" rel="noopener" href="https://www.cnblogs.com/williamjie/p/9099038.html">*<em>HashSet 与 TreeSet 区别 *</em></a>*</em>](*</em>*<em><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vd2lsbGlhbWppZS9wLzkwOTkwMzguaHRtbCo=">https://www.cnblogs.com/williamjie/p/9099038.html*</span></em>*<em>)*</em>**</h3><p><strong>HashSet</strong> HashSet 有以下特点</p><ul><li>不能保证元素的排列顺序，顺序有可能发生变化</li><li>不是同步的</li><li>集合元素可以是 null, 但只能放入一个 null</li></ul><p>​ 当向 HashSet 集合中存入一个元素时，HashSet 会调用该对象的 hashCode () 方法来得到该对象的 hashCode 值，然后根据 hashCode 值来决定该对象在 HashSet 中存储位置。 简单的说，HashSet 集合判断两个元素相等的标准是两个对象通过 equals 方法比较相等，并且两个对象的 hashCode () 方法返回值相等</p><p>​ 注意，如果要把一个对象放入 HashSet 中，重写该对象对应类的 equals 方法，也应该重写其 hashCode () 方法。其规则是如果两个对 象通过 equals 方法比较返回 true 时，其 hashCode 也应该相同。另外，对象中用作 equals 比较标准的属性，都应该用来计算 hashCode 的值。</p><p><strong>TreeSet 类</strong> TreeSet 是 SortedSet 接口的唯一实现类，TreeSet 可以确保集合元素处于排序状态。TreeSet 支持两种排序方式，自然排序 和定制排序，其中自然排序为默认的排序方式。向 TreeSet 中加入的应该是同一个类的对象。 TreeSet 判断两个对象不相等的方式是两个对象通过 equals 方法返回 false，或者通过 CompareTo 方法比较没有返回 0 <strong>自然排序</strong> 自然排序使用要排序元素的 CompareTo（Object obj）方法来比较元素之间大小关系，然后将元素按照升序排列。 Java 提供了一个 Comparable 接口，该接口里定义了一个 compareTo (Object obj) 方法，该方法返回一个整数值，实现了该接口的对象就可以比较大小。 obj1.compareTo (obj2) 方法如果返回 0，则说明被比较的两个对象相等，如果返回一个正数，则表明 obj1 大于 obj2，如果是 负数，则表明 obj1 小于 obj2。 如果我们将两个对象的 equals 方法总是返回 true，则这两个对象的 compareTo 方法返回应该返回 0 <strong>定制排序</strong> 自然排序是根据集合元素的大小，以升序排列，如果要定制排序，应该使用 Comparator 接口，实现 int compare (T o1,T o2) 方法。</p><p><strong>最重要：</strong></p><p>1、TreeSet 是二差树实现的，Treeset 中的数据是自动排好序的，不允许放入 null 值。</p><p>2、HashSet 是哈希表实现的，HashSet 中的数据是无序的，可以放入 null，但只能放入一个 null，两者中的值都不能重复，就如数据库中唯一约束。</p><p>3、HashSet 要求放入的对象必须实现 HashCode () 方法，放入的对象，是以 hashcode 码作为标识的，而具有相同内容的 String 对象，hashcode 是一样，所以放入的内容不能重复。但是同一个类的对象可以放入不同的实例 。</p><p><strong>HashSet 与 TreeSet 的使用场景</strong></p><p>HashSet：哈希表是通过使用称为散列法的机制来存储信息的，元素并没有以某种特定顺序来存放 TreeSet：提供一个使用树结构存储 Set 接口的实现 (红黑树算法)，对象以升序顺序存储，访问和遍历的时间很快。 使用场景：HashSet 是基于 Hash 算法实现的，其性能通常都优于 TreeSet。我们通常都应该使用 HashSet，在我们需要排序的功能时，我们才使用 TreeSet。</p><p><strong>HashSet 与 TreeSet 的底层运行方式:</strong> TreeSet 集合对象的加入过程： TreeSet 的底层是通过二叉树来完成存储的，无序的集合 当我们将一个对象加入 treeset 中，treeset 会将第一个对象作为根对象，然后调用对象的 compareTo 方法拿第二个对象和第一个比较，当返回至 = 0 时，说明 2 个对象内容相等，treeset 就不把第二个对象加入集合。返回 &gt; 1 时，说明第二个对象大于第一个对象，将第二个对象放在右边，返回 - 1 时，则将第二个对象放在左边，依次类推</p><p>HashSet 集合对象的加入过程： hashset 底层是 hash 值的地址，它里面存的对象是无序的。 第一个对象进入集合时，hashset 会调用 object 类的 hashcode 根据对象在堆内存里的地址调用对象重写的 hashcode 计算出一个 hash 值，然后第一个对象就进入 hashset 集合中的任意一个位置。 第二个对象开始进入集合，hashset 先根据第二个对象在堆内存的地址调用对象的计算出一个 hash 值，如果第二个对象和第一个对象在堆内存里的地址是相同的，那么得到的 hash 值也是相同的，直接返回 true，hash 得到 true 后就不把第二个元素加入集合（这段是 hash 源码程序中的操作）。如果第二个对象和第一个对象在堆内存里地址是不同的，这时 hashset 类会先调用自己的方法遍历集合中的元素，当遍历到某个元素时，调用对象的 equals 方法，如果相等，返回 true，则说明这两个对象的内容是相同的，hashset 得到 true 后不会把第二个对象加入集合。</p><h3 id="hashtabl-hashmap-treemap的区别"><a class="anchor" href="#hashtabl-hashmap-treemap的区别">#</a> <strong>hashtabl、hashMap treeMap 的区别</strong></h3><p><strong>实现方面</strong> HashMap 是继承自 AbstractMap 类，而 HashTable 是继承自 Dictionary 类。它们都同时实现了 map、Cloneable（可复制）、Serializable（可序列化）这三个接口。存储的内容是基于 key-value 的键值对映射，不能有重复的 key，而且一个 key 只能映射一个 value。HashSet 底层就是基于 HashMap 实现的。</p><p><strong>为空方面</strong> Hashtable 的 key、value 都不能为 null；HashMap 的 key、value 可以为 null，不过只能有一个 key 为 null，但可以有多个 null 的 value；TreeMap 键、值都不能为 null。</p><p><strong>排序方面</strong> Hashtable、HashMap 具有无序特性。TreeMap 是利用红黑树实现的（树中的每个节点的值都会大于或等于它的左子树中的所有节点的值，并且小于或等于它的右子树中的所有节点的值），实现了 SortMap 接口，能够对保存的记录根据键进行排序。所以一般需求排序的情况下首选 TreeMap，默认按键的升序排序（深度优先搜索），也可以自定义实现 Comparator 接口实现排序方式。</p><p><strong>注：<strong>HashTable 是一个线程安全的类，它使用</strong> synchronized</strong> 来锁住整张<span class="exturl" data-url="aHR0cHM6Ly9zby5jc2RuLm5ldC9zby9zZWFyY2g/cT1IYXNoJmFtcDtzcG09MTAwMS4yMTAxLjMwMDEuNzAyMA=="> Hash</span> 表来实现线程安全，即每次锁住整张表让线程独占，相当于所有线程进行读写时都去竞争一把锁，导致效率非常低下</p><p>Hashtable 现在很少出现了，大家更多的会使用 <code>ConcurrentHashMap</code> ，引导面试官提问<strong> ConcurrentHashMap</strong>。</p><h3 id="concurrenthashmap原理与实现"><a class="anchor" href="#concurrenthashmap原理与实现">#</a> <strong>ConcurrentHashMap 原理与实现</strong></h3><p>分析问题：原理与实现主要是锁的原理与实现！我们可以从 JDK1.7 开始聊起: JDK1.7 版本，ConcurrentHashMap 内部使用段 (Segment),ConcurrentLevel 有 16 个分段，这 16 个分段有独立的锁机制，每个独立的机制都是一张表，表的下面是链表，这样就可以支持并发的同时保证每张表的线程安全，大大的题高了效率。</p><p>​	JDK1.8 版本，ConcurrentHashMap 内部使用 sychronized + volatile + CAS 的实现降低锁的粒度，大家可以认为粒度就是 HashEntry (首节点)。</p><p>让我们看看具体是如何实现的:</p><ul><li>插入、删除、扩容的时候都对数组中相应位置的元素加锁了，加锁用的是 synchronized.</li><li>table 数组、Node 中的 val 和 next、以及一些控制字段都加了 volatile</li><li>在更新一些关键变量的时候用到了 sun.misc.Unsafe 中的一些方法</li></ul><p>![204fe5e5d4314bf99acbaa07df844ef5~tplv-k3u1fbpfcp-watermark](file://D:/_Myself/%E9%9D%A2%E8%AF%95/%E9%9D%A2%E8%AF%95%E9%A2%98/img/204fe5e5d4314bf99acbaa07df844ef5tplv-k3u1fbpfcp-watermark.jpg?lastModify=1673361991)</p><p><strong>反思 &amp; 扩展</strong> <strong>ConcurrentHashMap 有什么缺陷吗？</strong> ConcurrentHashMap 是设计为非阻塞的。在更新时会局部锁住某部分数据，但不会把整个表都锁住。同步读取操作则是完全非阻塞的。好处是在保证合理的同步前提下，效率很高。坏处是严格来说读取操作不能保证反映最近的更新。例如线程 A 调用 putAll 写入大量数据，期间线程 B 调用 get，则只能 get 到目前为止已经顺利插入的部分数据。</p><p><strong>ConcurrentHashMap 在 JDK7 和 8 之间的区别</strong> JDK1.8 的实现降低锁的粒度，JDK1.7 版本锁的粒度是基于 Segment 的，包含多个 HashEntry，而 JDK1.8 锁的粒度就是 HashEntry (首节 点) JDK1.8 版本的数据结构变得更加简单，使得操作也更加清晰流畅，因为已经使用 synchronized 来进行同步，所以不需要分段锁的概念，也就不需要 Segment 这种数据结构了，由于粒度的降低，实现的复杂度也增加了 JDK1.8 使用红黑树来优化链表，基于长度很长的链表的遍历是一个很漫长的过程，而红黑树的遍历效率是很快的，代替一定阈值的链表，这样形成一个最佳拍档</p><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig={clientID:"6db178ba46c8af8f6a6f",clientSecret:"90f730e5956024596558df00975cd8eae28cae3d",repo:"bk-comment01",owner:"onlymarryu",admin:["onlymarryu"],distractionFreeMode:!1,language:"zh-CN",proxy:"https://gitalk-comments.netlify.app/github_access_token",perPage:15};gitalkConfig.id=md5(location.pathname);var gitalk=new Gitalk(gitalkConfig);gitalk.render("gitalk-container")</script><div class="tags"><a href="/tags/%E9%9B%86%E5%90%88/" rel="tag"><i class="ic i-tag"></i> 集合</a> <a href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag"><i class="ic i-tag"></i> 面试</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2023-01-16 21:05:55" itemprop="dateModified" datetime="2023-01-16T21:05:55+08:00">2023-01-16</time></span></div><div class="reward"><button><i class="ic i-heartbeat"></i> 赞赏</button><p>请我喝[茶]~(￣▽￣)~*</p><div id="qr"><div><img data-src="/images/wechatpay.png" alt="雾都 微信支付"><p>微信支付</p></div><div><img data-src="/images/alipay.png" alt="雾都 支付宝"><p>支付宝</p></div><div><img data-src="/images/paypal.png" alt="雾都 贝宝"><p>贝宝</p></div></div></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>雾都 <i class="ic i-at"><em>@</em></i>每天进步一点点，就是成功的开始</li><li class="link"><strong>本文链接：</strong> <a href="https://eth168.top/interview/JavaSE%E2%80%94%E9%9B%86%E5%90%88/" title="集合">https://eth168.top/interview/JavaSE—集合/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/interview/%E9%9D%A2%E8%AF%95%E9%A2%98/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;api.yimian.xyz&#x2F;img?313178" title="面试题"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> 面试</span><h3>面试题</h3></a></div><div class="item right"><a href="/interview/JavaSE%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;api.yimian.xyz&#x2F;img?568425" title="常见问题"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i> 面试</span><h3>常见问题</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#arraylist%E9%9B%86%E5%90%88%E7%9A%84add%E8%BF%87%E7%A8%8B"><span class="toc-number">1.</span> <span class="toc-text">ArrayList 集合的 add 过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18%E4%B8%BA%E4%BB%80%E4%B9%88%E6%94%B9%E5%8F%98%E6%88%9017%E7%9A%84%E5%A4%B4%E6%8F%92%E6%B3%95%E6%88%90%E5%B0%BE%E6%8F%92%E6%B3%95"><span class="toc-number">2.</span> <span class="toc-text">1.8 为什么改变成 1.7 的头插法成尾插法？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#victor-%E5%92%8C-arraylist%E5%8C%BA%E5%88%AB"><span class="toc-number">3.</span> <span class="toc-text">Victor 和 ArrayList 区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#iteratoriteratoriterable%E5%85%B3%E7%B3%BB"><span class="toc-number">4.</span> <span class="toc-text">iterator (),Iterator,Iterable 关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#listiterator%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">5.</span> <span class="toc-text">ListIterator 迭代器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#linkedlist%E5%BA%95%E5%B1%82"><span class="toc-number">6.</span> <span class="toc-text">LinkedList 底层</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#hashset%E5%BA%95%E5%B1%82%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">7.</span> <span class="toc-text">HashSet 底层是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#linkedset%E5%BA%95%E5%B1%82"><span class="toc-number">8.</span> <span class="toc-text">LinkedSet 底层</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#treeset%E5%BA%95%E5%B1%82"><span class="toc-number">9.</span> <span class="toc-text">TreeSet 底层</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#hashmap%E5%BA%95%E5%B1%82"><span class="toc-number">10.</span> <span class="toc-text">HashMap 底层</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#17%E5%BA%95%E5%B1%82%E9%81%B5%E7%85%A7-font-colorred-%E5%93%88%E5%B8%8C%E8%A1%A8%E7%BB%93%E6%9E%84-font%E5%A4%B4%E6%8F%92%E6%B3%95"><span class="toc-number">10.1.</span> <span class="toc-text">1.7 底层遵照 *** 哈希表结构 * ****(头插法)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#18%E5%BA%95%E5%B1%82%E9%81%B5%E7%85%A7-font-colorred-%E5%93%88%E5%B8%8C%E8%A1%A8%E7%BB%93%E6%9E%84-%E7%BA%A2%E9%BB%91%E6%A0%91font%E5%B0%BE%E6%8F%92%E6%B3%95"><span class="toc-number">10.2.</span> <span class="toc-text">1.8 底层遵照 *** 哈希表结构 + 红黑树 *****（尾插法）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#hashmap%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E7%BA%A2%E9%BB%91%E6%A0%91"><span class="toc-number">11.</span> <span class="toc-text">Hashmap 为什么要使用红黑树？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E6%95%B0%E7%BB%84%E7%9A%84%E9%95%BF%E5%BA%A6%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF"><span class="toc-number">12.</span> <span class="toc-text">主数组的长度为什么是 ****\**\******？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A3%85%E5%A1%AB%E5%9B%A0%E5%AD%90075%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="toc-number">13.</span> <span class="toc-text">装填因子 0.75 的原因</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#hashmap-%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">14.</span> <span class="toc-text">HashMap 的时间复杂度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#hashtable%E5%BA%95%E5%B1%82"><span class="toc-number">15.</span> <span class="toc-text">HashTable 底层</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#linkedmap%E5%BA%95%E5%B1%82"><span class="toc-number">16.</span> <span class="toc-text">LinkedMap 底层</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#hashmap%E5%92%8Chashtable%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">17.</span> <span class="toc-text">HashMap 和 Hashtable 有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#treemap%E5%BA%95%E5%B1%82"><span class="toc-number">18.</span> <span class="toc-text">TreeMap 底层</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#collection-%E5%92%8C-collections-%E5%8C%BA%E5%88%AB"><span class="toc-number">19.</span> <span class="toc-text">Collection 和 Collections 区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#arraysaslist%E6%96%B9%E6%B3%95%E4%B9%8B%E5%90%8E%E7%9A%84%E9%9B%86%E5%90%88%E5%8F%AF%E4%BB%A5%E8%B0%83%E7%94%A8%E4%BB%80%E4%B9%88%E6%96%B9%E6%B3%95"><span class="toc-number">20.</span> <span class="toc-text">Arrays.asList () 方法之后的集合可以调用什么方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#map-set-list%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">21.</span> <span class="toc-text">Map、Set、List 的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#hashset%E4%B8%8Etreeset-%E5%8C%BA%E5%88%ABhttpswwwcnblogscomwilliamjiep9099038html"><span class="toc-number">22.</span> <span class="toc-text">*[**HashSet 与 TreeSet 区别 **](**https:&#x2F;&#x2F;www.cnblogs.com&#x2F;williamjie&#x2F;p&#x2F;9099038.html**)***</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#hashtabl-hashmap-treemap%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">23.</span> <span class="toc-text">hashtabl、hashMap treeMap 的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#concurrenthashmap%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0"><span class="toc-number">24.</span> <span class="toc-text">ConcurrentHashMap 原理与实现</span></a></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li><a href="/interview/JVM%E5%A4%8D%E4%B9%A0%E7%89%88/" rel="bookmark" title="JVM复习版">JVM复习版</a></li><li><a href="/interview/JavaSE%E2%80%94%E5%A4%9A%E7%BA%BF%E7%A8%8B/" rel="bookmark" title="多线程">多线程</a></li><li><a href="/interview/JVM%E5%BF%AB%E9%80%9F%E7%AA%81%E5%87%BB%E7%89%88/" rel="bookmark" title="JVM突击版">JVM突击版</a></li><li><a href="/interview/JavaSE%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/" rel="bookmark" title="常见问题">常见问题</a></li><li class="active"><a href="/interview/JavaSE%E2%80%94%E9%9B%86%E5%90%88/" rel="bookmark" title="集合">集合</a></li><li><a href="/interview/%E9%9D%A2%E8%AF%95%E9%A2%98/" rel="bookmark" title="面试题">面试题</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="雾都" data-src="/images/avatar.jpg"><p class="name" itemprop="name">雾都</p><div class="description" itemprop="description">花非花，雾非雾</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">70</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">13</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">22</span> <span class="name">标签</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL29ubHltYXJyeXU=" title="https:&#x2F;&#x2F;github.com&#x2F;onlymarryu"><i class="ic i-github"></i></span> <span class="exturl item zhihu" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS9ydXJpc216aw==" title="https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;rurismzk"><i class="ic i-zhihu"></i></span> <span class="exturl item music" data-url="aHR0cHM6Ly9tdXNpYy4xNjMuY29tLyMvbXkvbS9tdXNpYy9wbGF5bGlzdD9pZD0zMTY2MDYwNzkw" title="https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;my&#x2F;m&#x2F;music&#x2F;playlist?id&#x3D;3166060790"><i class="ic i-cloud-music"></i></span> <span class="exturl item weibo" data-url="aHR0cHM6Ly93ZWliby5jb20vYW1laGltZQ==" title="https:&#x2F;&#x2F;weibo.com&#x2F;amehime"><i class="ic i-weibo"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>时间轴</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li><li class="item"><a href="/toolPage/" rel="section"><i class="ic i-feather"></i>常用工具设置技巧</a></li><li class="item"><a href="/projectBuild/" rel="section"><i class="ic i-th"></i>SpringBoot常用配置</a></li></ul></li><li class="item"><a href="/mianshi/" rel="section"><i class="ic i-calendar"></i>面试</a></li><li class="item"><a href="/study/" rel="section"><i class="ic i-sakura"></i>小实验</a></li><li class="item"><a href="/friends/" rel="section"><i class="ic i-heart"></i>友链</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-calendar"></i>留言</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/interview/%E9%9D%A2%E8%AF%95%E9%A2%98/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/interview/JavaSE%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"></div><span><a href="/toolsPage/VsCode/" title="VsCode常用插件和配置方案">VsCode常用插件和配置方案</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/ORM/" title="分类于 ORM">ORM</a></div><span><a href="/ORM/Mybatis/" title="Mybatis">Mybatis</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/" title="分类于 小程序开发">小程序开发</a></div><span><a href="/Web-anteriore/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/4.%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E5%9F%BA%E7%A1%80%E5%8A%A0%E5%BC%BA/" title="4.基础加强">4.基础加强</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" title="分类于 数据库">数据库</a> <i class="ic i-angle-right"></i> <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/" title="分类于 MySQL">MySQL</a></div><span><a href="/DataBase/MySQL/MySQL_Basic/" title="MySQL基础">MySQL基础</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E5%B7%A5%E5%85%B7%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/" title="分类于 工具软件安装">工具软件安装</a></div><span><a href="/tools/Maven-tool/" title="Maven-tool">Maven-tool</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E9%9D%A2%E8%AF%95/" title="分类于 面试">面试</a></div><span><a href="/interview/JVM%E5%BF%AB%E9%80%9F%E7%AA%81%E5%87%BB%E7%89%88/" title="JVM突击版">JVM突击版</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/ORM/" title="分类于 ORM">ORM</a></div><span><a href="/ORM/MybatisPlus/" title="MybatisPlus">MybatisPlus</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/" title="分类于 分布式">分布式</a></div><span><a href="/Distribution/FastDFS/" title="FastDFS">FastDFS</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/JavaSE/" title="分类于 JavaSE">JavaSE</a></div><span><a href="/Java/%E7%AC%AC6%E7%AB%A0_%E6%95%B0%E7%BB%84/" title="第6章_数组">第6章_数组</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E5%B7%A5%E5%85%B7%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/" title="分类于 工具软件安装">工具软件安装</a></div><span><a href="/tools/Solr-tool/" title="Solr">Solr</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2010 – <span itemprop="copyrightYear">2023</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">雾都 @ 雾都博客</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="站点总字数">1.1m 字</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="站点阅读时长">16:21</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"interview/JavaSE—集合/",favicon:{show:"（●´3｀●）やれやれだぜ",hide:"(´Д｀)大変だ！"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html>