<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="每天进步一点点，就是成功的开始" href="https://eth168.top/rss.xml"><link rel="alternate" type="application/atom+xml" title="每天进步一点点，就是成功的开始" href="https://eth168.top/atom.xml"><link rel="alternate" type="application/json" title="每天进步一点点，就是成功的开始" href="https://eth168.top/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="突击版 复习版"><link rel="canonical" href="https://eth168.top/interview/MySQL/"><title>MySQL 复习题 - . 面试题 | 雾都博客 = 每天进步一点点，就是成功的开始</title><meta name="generator" content="Hexo 6.3.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">MySQL 复习题</h1><div class="meta"><span class="item" title="创建时间：2023-01-24 12:43:45"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2023-01-24T12:43:45+08:00">2023-01-24</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>19k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>17 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">雾都博客</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://api.yimian.xyz/img?994684"></li><li class="item" data-background-image="https://api.yimian.xyz/img?456014"></li><li class="item" data-background-image="https://api.yimian.xyz/img?59795"></li><li class="item" data-background-image="https://api.yimian.xyz/img?962590"></li><li class="item" data-background-image="https://api.yimian.xyz/img?540684"></li><li class="item" data-background-image="https://api.yimian.xyz/img?960895"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/" itemprop="item" rel="index" title="分类于 . 面试题"><span itemprop="name">. 面试题</span></a><meta itemprop="position" content="1"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://eth168.top/interview/MySQL/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="雾都"><meta itemprop="description" content=", 花非花，雾非雾"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="每天进步一点点，就是成功的开始"></span><div class="body md" itemprop="articleBody"><h1 id="数据库存储引擎有哪些"><a class="anchor" href="#数据库存储引擎有哪些">#</a> 数据库存储引擎有哪些</h1><p>Myisam、Innodb</p><h1 id="myisam和innodb有什么区别"><a class="anchor" href="#myisam和innodb有什么区别">#</a> Myisam 和 Innodb 有什么区别</h1><table><thead><tr><th style="text-align:center">区别</th><th style="text-align:center">MyISAM</th><th style="text-align:center">InnoDB</th></tr></thead><tbody><tr><td style="text-align:center">数据结构</td><td style="text-align:center">.frm 存储表定义<br>.MYD 存储数据文件<br>.MYI 存储索引文件</td><td style="text-align:center">.frm 存储表定义<br>.ibd 存储数据和索引</td></tr><tr><td style="text-align:center">存储空间</td><td style="text-align:center">MyISAM<strong> 可被压缩，存储空间较小</strong><br>支持三种存储：静态表 [默认]、动态表、压缩表</td><td style="text-align:center">InnoDB<strong> 需要更多的内存和存储，它会在主内存中建立其专用的缓冲池用于高速缓冲数据和索引</strong>。InnoDB 所在的表都保存在同一个数据文件中（也可能是多个文件，或者是独立的表空间）<br>InnoDB 表的大小只受限于操作系统文件的大小，一般为 2GB</td></tr><tr><td style="text-align:center">事务的支持</td><td style="text-align:center">MyISAM 强调的是性能，每次查询具有原子性，其执行速度比 Innodb 类型更快，<br>但是<strong>不提供事务支持</strong>。</td><td style="text-align:center">InnoDB 除了<em><strong>提供事务支持</strong></em>和外部键等高级数据库功能。还具有事务提交（commit）、回滚（rollback）和崩溃修复能力（crach recovery capabilities）等这些事务安全（transaction-safe ACID compliant）型表</td></tr><tr><td style="text-align:center">锁的支持</td><td style="text-align:center">如果只是执行大量的查询，MyISAM 是更好的选择。MyISAM 在<strong>增删</strong>的时候需要<strong>锁定整个表格</strong>，效率会低一些</td><td style="text-align:center">innoDB 支持行级锁，<em><strong>删除插入</strong></em>的时候只需要<em><strong>锁定操作行</strong></em>就行。如果有大量的插入、修改删除操作，使用 InnoDB 性能能会更高</td></tr><tr><td style="text-align:center">查询效率</td><td style="text-align:center"><strong>高</strong><br>支持全文索引</td><td style="text-align:center"><strong>低</strong><br>不支持全文索引</td></tr><tr><td style="text-align:center">外键的支持</td><td style="text-align:center">MyISAM<strong> 不支持外键</strong></td><td style="text-align:center">支持外键</td></tr></tbody></table><h1 id="如何选择数据库引擎"><a class="anchor" href="#如何选择数据库引擎">#</a> 如何选择数据库引擎？</h1><p>1、如果需要支持事务，选择 InnoDB，不需要事务则选择 MyISAM。</p><p>2、如果大部分表操作都是查询，选择 MyISAM，有写又有读选 InnoDB。</p><p>3、如果系统崩溃导致数据难以恢复，且成本高，不要选择 MyISAM。</p><h1 id="三范式是什么"><a class="anchor" href="#三范式是什么">#</a> 三范式是什么</h1><p>第一范式：列不可再分</p><p>第二范式：行可以唯一区分，主键约束</p><p>第三范式：表的非主属性不能依赖与其他表的非主属性 外键约束</p><p>简单来说，第一范式就是让属性原子化，不可再分；第二范式就是让数据具有主属性从而产生唯一标识（特别是为了标识有联合主键的情况）；第三范式就是表的非主属性不能依赖与其他表的非主属性，也可以说是表中的属性不能有依赖关系</p><img data-src="/interview/MySQL/image-20220714214608165.png" title="image-20220714214608165"><h1 id="什么是事务有哪些特点"><a class="anchor" href="#什么是事务有哪些特点">#</a> 什么是事务，有哪些特点</h1><p>事务是用来维护数据库完整性的，具体体现就是多条 sql 语句，要么全部成功，要么全部失败。</p><p>特点：<mark>ACID</mark></p><p>A:（原子性 Atomicity）、C: 一致性（Consistency）、I：隔离性（Isolation）、D：持久性（Durability）</p><p>1) 原子性<br>原子是自然界最小的颗粒，具有不可再分的特性</p><ol start="2"><li><p>一致性<br>一致性是指事务执行的结果必须使数据库从一个一致性状态，变到另一个一致性状态。</p></li><li><p>隔离性<br>隔离性是指各个事务的执行互不干扰</p></li></ol><p>4) 持久性<br>持久性指事务一旦提交，对数据所做的任何改变，都要记录到永久存储器中</p><h1 id="事务的隔离级别有哪些"><a class="anchor" href="#事务的隔离级别有哪些">#</a> 事务的隔离级别有哪些</h1><p>由低到高：</p><img data-src="/interview/MySQL/image-20220714221905692.png" title="image-20220714221905692"><p><strong>READ UNCOMMITTED（读未提交）</strong></p><p>​	在这个隔离级别，所有事务都可以看到未提交事务的执行结果。在这种隔离级别上，可能会产生很多问题。所以这种隔离级别很少用于实际应用，而且它的性能也没有比其他性能好很多，而别的级别还有其他的优点。读取未提交数据，也被称为 “脏读”。</p><p><strong>READ COMMITTED（读已提交）</strong></p><p>​	读已提交这种隔离级别是大多数数据库系统默认的隔离级别（但 mysql 默认的隔离级别却不是这种），满足了隔离的最早简单定义：一个事务开始时，只能看见已经提交事务所做的改变，一个事务从开始到提交前，所做的任何数据改变都是不可见的，除非已经提交。这种隔离级别也支持所谓的不可重复读。这意味着用户运行同一个语句两次，看到的结果是不同的。</p><p><strong>REPEATABLE READ（可重复读）</strong></p><p>​	mysql 数据库默认的隔离级别。该级别解决了 READ UNCOMMITTED 导致的问题。它保证了同一事务的多个实例在并发读取事务时，会看到同样的数据行。不过这会导致另外一个问题 “幻读”。InnoDB 和 Falcon 存储引擎通过多版本并发控制解决了幻读问题。</p><p><strong>SERIALIZABLE（可串行化）</strong></p><p>​	该隔离级别是最高的隔离级别。它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简而言之：SERIALIZABLE 是在每个读的数据行加锁，在这个级别上可能导致大量的超时和锁竞争现象，实际应用中很少使用这个级别，但如果用户的应用为了数据的稳定性，需要强制减少并发，也可以选择这种隔离级别。</p><h1 id="并发事务带来哪些问题"><a class="anchor" href="#并发事务带来哪些问题">#</a> 并发事务带来哪些问题？</h1><p><strong>脏读（Dirty read）</strong></p><p>​	当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是 “脏数据”，依据 “脏数据” 所做的操作可能是不正确的。</p><img data-src="/interview/MySQL/image-20220714222508260.png" title="image-20220714222508260"><p><strong>不可重复读（Unrepeatableread）</strong></p><p>​	指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。</p><img data-src="/interview/MySQL/image-20220714222512979.png" title="image-20220714222512979"><p><strong>幻读 （Phantom read）</strong></p><p>幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。</p><img data-src="/interview/MySQL/image-20220714222518876.png" title="image-20220714222518876"><h1 id="不可重复度和幻读区别"><a class="anchor" href="#不可重复度和幻读区别">#</a> 不可重复度和幻读区别？</h1><p>不可重复读的重点是修改，幻读的重点在于新增或者删除。</p><p>解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表</p><h1 id="sql优化手段有哪些"><a class="anchor" href="#sql优化手段有哪些">#</a> SQL 优化手段有哪些？</h1><p>1、查询语句中不要使用 select *</p><p>2、尽量减少子查询，使用关联查询（left join,right join,inner join）替代</p><p>3、减少使用 IN 或者 NOT IN , 使用 exists，not exists 或者关联查询语句替代</p><p>4、or 的查询尽量用 union 或者 union all 代替 (在确认没有重复数据或者不用剔除重复数据时，union all 会更好)</p><p>5、应尽量避免在 where 子句中使用！= 或 &lt;&gt; 操作符，否则将引擎放弃使用索引而进行全表扫描。</p><p>6、应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如： select id from t where num is null 可以在 num 上设置默认值 0，确保表中 num 列没有 null 值，然后这样查询： select id from t where num=0</p><h1 id="undo-log日志详解"><a class="anchor" href="#undo-log日志详解">#</a> undo log 日志详解</h1><ol><li><p>什么是 undo log？<br>撤销日志，在数据库事务开始之前，MYSQL 会去记录更新前的数据到 undo log 文件中。如果事务回滚或者数据库崩溃时，可以利用 undo log 日志中记录的日志信息进行回退。同时也可以提供多版本并发控制下的读 (MVCC)。（具体的 MVCC 实现机制详解看这篇博客）</p></li><li><p>undo log 生命周期<br>undo log 产生： 在事务开始之前生成<br>undo log 销毁： <strong>当事务提交之后，undo log 并不能立马被删除</strong>，而是放入待清理的链表，由 purge 线程判断是否由其他事务在使用 undo 段中表的上一个事务之前的版本信息，决定是否可以清理 undo log 的日志空间。<br><strong>注意： undo log 也会生产 redo log，undo log 也要实现持久性保护。</strong></p></li><li><p><strong>uodo log 日志的作用</strong><br>首先简单说一下<strong> undolog 和 redo log 的区别</strong><br><code>undo log</code> 是逻辑日志，实现事务的原子性<br>undo log 记录的是事务 [ <code>开始前</code> ] 的数据状态，记录的是更新之前的值<br>undo log 实现事务的 <code>原子性</code> (<strong>提供回滚</strong>)<br><code>redo log</code> 是物理日志，实现事务的持久性<br>redo log 记录的是事务 [ <code>完成后</code> ] 的数据状态，记录的是更新之后的值<br>redo log 实现事务的 <code>持久性</code> (<strong>保证数据的完整性</strong>)</p></li></ol><img data-src="/interview/MySQL/bbd9b47cd66648cd99c3ce54090ba69e.png" title="在这里插入图片描述"><ol start="4"><li><p>undo log 版本链是什么？<br>在 undo log 日志里，每条数据除了自有的那些字段 (表 id、日志类型、数据页号等等)，其实还会有两个隐藏字段，一个是 trx_id，另一个是 roll_pointer。这个 trx_id 就是最近一次更新的事务 id，roll_pointer 是指向你更新这个事务之前生成的 undo log 数据。</p><p>这里给大家举个例子：<br>假设有一个事务 A，插入了一个数据 A，此时的 undo log 数据结构如下：</p><img data-src="/interview/MySQL/719f98466ea94f278dd2a4315368c622.png" title="在这里插入图片描述"><p>因为事务 id 是 10，所以这条数据的 trx_id=10。因为是插入数据，所以没有下一个 undo log 数据，roll_pointer 是空的。接着，此时有一个事务 B 需要执行，事务 B 的 id=20，那么执行完之后就会新生成一条 undo log 日志数据，trx_id=20，roll_pointer 就会指向实际的回滚日志，也就是值 A 那条数据。结构如下图所示：</p><img data-src="/interview/MySQL/bdbb19325c504296bb8dc40d9ee4bbe9.png" title="在这里插入图片描述"><p>以此类推，在这个多个事务中，每个事务新生成的 undo log 日志数据的 roll_pointer 都会指向前一个 undo log 日志数据，一次行程 undo log 版本链。</p></li></ol><h1 id="mvcc详解"><a class="anchor" href="#mvcc详解">#</a> MVCC 详解</h1><h2 id="1mvcc是什么"><a class="anchor" href="#1mvcc是什么">#</a> 1.MVCC 是什么？</h2><p>MVCC，全称 Multi-Version Concurrency Control，即<strong>多版本并发控制</strong>。MVCC 是一种并发控制的方法，一般在数据库管理系统中，<strong>实现对数据库的并发访问，在编程语言中实现事务内存</strong>。</p><p>它主要是用来处理 mysql 在多线程操作缓存数据时出现的一系列并发问题。</p><h2 id="2前置知识点"><a class="anchor" href="#2前置知识点">#</a> 2. 前置知识点</h2><p>1）什么是脏写、脏读、不可重复读、幻读？</p><p>2）四种隔离级别</p><p>3）undo log 版本链</p><h2 id="3基于undo-log多版本链实现的readview机制"><a class="anchor" href="#3基于undo-log多版本链实现的readview机制">#</a> 3. 基于 undo log 多版本链实现的 ReadView 机制</h2><p>**ReadView (读视图)** 是 “ <code>快照读</code> ”SQL 执行时 MVCC 提取数据的快</p><p><code>照读</code> 就是最普通的 <code>Select</code> 查询 SQL 语句</p><p><code>当前读</code> 指代执行下列语句时进行数据读取的方式</p><ul><li>insert、Updata、Delete、SELECT ... for update 、Select ... lock in share mode</li></ul><p>数据结构：</p><figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 四个字段</span></pre></td></tr><tr><td data-num="2"></td><td><pre>m_ids<span class="token operator">:</span> 当前活跃的事务编号集合</pre></td></tr><tr><td data-num="3"></td><td><pre>min_trx_id<span class="token operator">:</span> 最小活跃事务编号</pre></td></tr><tr><td data-num="4"></td><td><pre>max_trx_id<span class="token operator">:</span> 预分配事务编号，当前最大事务编号 <span class="token operator">+</span> <span class="token number">1</span></pre></td></tr><tr><td data-num="5"></td><td><pre>creator_trx_id<span class="token operator">:</span> ReadView创建者的事务编号</pre></td></tr></table></figure><p>假设 mysql 里有个数据，很早之前就有事务插入了，事务 id 是 20，如下图所示：</p><img data-src="/interview/MySQL/4b547c37ce38459d9820df53a4498280.png" title="在这里插入图片描述"><p>此时，有两个事务并发过来执行，分别是事务 A — id=30，要读取这行数据。事务 B — id=35，要修改这行数据。此时事务 A 会做个判断，判断当前行的 trx_id 是否小于 ReadView 中的 min_trx_id。此时发现 30&gt;20, 所以可以得知在事务 A 开启之前，当前行的事务就已经提交了，因此 shiwuA 可以查到这条数据。如下图：</p><img data-src="/interview/MySQL/309c8791d98f4006983cf2b28ce46fe7.png" title="在这里插入图片描述"><p>接着事务 B 开始操作，他把初始值修改成了值 B，trx_id 设置为自己的事务 id，也就是 35，同事 roll_pointer 指向了之前生成的 undo log，然后事务 B 提交了。如下图：</p><img data-src="/interview/MySQL/154a65588ce143bfadccc19d1c6b6bb5.png" title="在这里插入图片描述"><p>这个时候，事务 A 再查询，就会发现一个问题，事务 A 就会发现 trx_id 变成了 35，那么 trx_id 大于 min_trx_id，同时小于 ReadView 里的 max_trx_id=36。说明这个事务可能是和自己差不多时间开始的，然后就会看下这个 trx_id 是否在 m_ids 中，在 m_ids 中发现了 35 的 id，那么就证明当前的数据是和自己同一时间并发启动的事务然后提交的，所以按道理这条数据不能让他看到，就把这条数据屏蔽掉，然后顺着 roll_pointer 找之前的 undo log 数据，然后就会找到 trx_id=20 的那条数据，小于 min_trx_id，说明这条数据是在事务 A 提交之前就完成的，符合查询条件，就把这条数据给暴露出去。</p><img data-src="/interview/MySQL/7ceac4c1b97f4390b50f156d709186c3.png" title="在这里插入图片描述"><p>通过 undo log 多版本链，加上 ReadView 进行判断的机制，就可以让你读取你应该读取哪个版本的值。</p><h2 id="4readview机制是如何实现读已提交隔离级别rc隔离级别的"><a class="anchor" href="#4readview机制是如何实现读已提交隔离级别rc隔离级别的">#</a> 4.ReadView 机制是如何实现读已提交隔离级别（RC 隔离级别）的？</h2><p>首先了解下 RC 隔离级别：是指你事务在运行期间，只要别的事务修改数据并且提交了，你就可以读取到修改之后的数据。（这种情况还是会发生不可重复读和幻读）</p><p>下面我就用画图的形式，来和大家一步一步的讲解实现过程：<br>首先假设有个数据，是事务 id=50 之前就插入进去的，现在活跃着两个事务，事务 A — id=60，事务 B — id=70。如下图：</p><img data-src="/interview/MySQL/6d4c34e71d1348dbba3ebc8e6a65d619.png" title="在这里插入图片描述"><p>现在事务 B 将初始值修改成了值 B，此时 trx_id=70，同时会生成一个 undo log 数据。如下图：</p><img data-src="/interview/MySQL/66075a6b707e4b96b041df56290b1168.png" title="在这里插入图片描述"><p>此时事务 A 发起查询操作，然后生成一个 ReadView，m_ids=60、70，min_trx_id=60，max_trx_id=71，creator_trx_id=60。如下图：</p><img data-src="/interview/MySQL/12cba3301e11446594396a6b906c14b9.png" title="在这里插入图片描述"><p>此时事务 A 发现 trx_id=70，大于 min_trx_id，并且小于 max_trx_id，说明当前事务是和事务 A 同时提交的，但是又因为 trx_id=70，在 m_ids 里，说明当前事务还没有提交。那么根据读已提交隔离级别要求，事务未提交之前是不能查看修改值的，所以这里事务 A 看不到事务 B 的值 B，只能根据 roll_pointer 指向找到上一条 undo log 数据，在做判断，发现 trx_id=50，小于事务 A，说明已经提交完成，所以事务 A 查到的数据是初始值。<br>接着，这里我们再将事务 B 提交，那么提交之后，事务 A 再进行查询，此时会发现 m_ids 已经变成了 m_ids=60，那么说明事务 B 已经不再活跃 m_ids 数据中了，说明事务 B 已经提交了，因此事务 A 可以查看到事务 B 的值 B。</p><p><em><strong>这里需要注意一点，读已提交隔离级别中，事务每次执行，都会重新生成一个 ReadView，因为只有这样才能获取到最新的事务 id 数据。</strong></em><br>以上就是基于 ReadView 实现的 RC 隔离级别的原理。</p><h2 id="5-readview机制是如何实现可重复读隔离级别rr隔离级别的"><a class="anchor" href="#5-readview机制是如何实现可重复读隔离级别rr隔离级别的">#</a> 5. ReadView 机制是如何实现可重复读隔离级别（RR 隔离级别）的？</h2><p>我们已经了解了基于 ReadView 机制实现 RC 隔离级别的实现原理了，那么应该对 RR 隔离级别的实现原理也有一个大概猜想了，下面我们还是通过画图方式，来了解实现 RR 隔离级别的原理。</p><p>这里注意：RR 隔离级别里，你这个事务 读取一条数据，无论读取多少次，都是一个值，ReadView 也一样，别的事务哪怕事务提交了，也不能看到修改后的值，这样就避免了不可重复读的问题。</p><p>首先假设有个数据，是事务 id=50 之前就插入进去的，现在活跃着两个事务，事务 A — id=60，事务 B — id=70。如下图：</p><img data-src="/interview/MySQL/6d4c34e71d1348dbba3ebc8e6a65d619.png" title="在这里插入图片描述"><p>这个时候，事务 A 发起查询操作，这时候会生成一个 ReadView，这是 creator_trx_id=60，m_ids=60、71，min_trx_id=60，max_trx_id=71。如下图：</p><img data-src="/interview/MySQL/7fdcbd3c3fd74b2a8b5f419a925b262b.png" title="在这里插入图片描述"><p>这个时候当前数据的 trx_id=50，小于事务 A 的 60，证明当前事务早在事务 A 之前提交了，所以事务 A 可以看到初始值。<br>接着就是事务 B 开始执行修改操作，此时 trx_id=70，初始值改为值 B，同时生成一个 undo log，并且事务 B 提交了，也就是说此时事务 B 已经结束了。如下图：</p><img data-src="/interview/MySQL/991752fc4da34cf08d9d430509a6e3cb.png" title="在这里插入图片描述"><p>那么此时事务 A 再次进行查询操作，大家说 m_ids 的值是多少呢？答案是 m_ids=60,70。因为在 RR 隔离级别中，ReadView 一旦生成，就不会改变，这个时候，虽然事务 B 已经提交了，但是事务 A 中的 ReadView 里，还是会有 60、70 两个活跃事务 id。那么此时，事务 A 会判断 trx_id 是否大于 60，很明显 70&gt;60，然后再看 m_ids 中是否有 trx_id=70，是有的，所以这时候事务 A 还是认为事务 B 此时还是处于未提交状态，因此不会被允许查看事务 B 的值，他会根据 roll_pointer 找到上一条 undo log 数据，再次判断，50&lt;60, 满足条件，因此事务 A 查到的数据还是初始值。</p><p>大家看到这里是不是就感觉到了一下子就避免了不可重复读的问题呢。<br>同理，当有个事务 C 插入一条数据，事务 id=80，然后提交，在事务 A 中查看到的 max_trx_id 还是 71，这里会判读 80&gt;71, 因此事务 A 会知道，当前事务 C 是在事务 A 发起之后才执行的，明显是不能查看他的数据的，因此这里也不会出现幻读的情况。这些都是依托 ReadView 机制实现的。</p><p>到此，如何基于 ReadView 机制实现隔离级别，避免脏读、不可重复读和幻读的情况，这里就全部解释完毕了。</p><h2 id="6总结"><a class="anchor" href="#6总结">#</a> 6. 总结</h2><p><strong>Mysql 实现 MVCC 机制，就是基于 <code>undo log多版本链表</code> + <code>ReadView机制</code> 来实现的。默认的 RR 隔离级别，也是基于这套机制来实现的，处理避免脏读、不可重复读的问题，还能解决幻读的问题，因此我们一般都默认为 RR 隔离级别就好了。</strong></p><h2 id="参考"><a class="anchor" href="#参考">#</a> 参考</h2><ul><li><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xUMTFoa2EvYXJ0aWNsZS9kZXRhaWxzLzEyMjI2MDAzND9zcG09MTAwMS4yMDE0LjMwMDEuNTUwMg==">https://blog.csdn.net/LT11hka/article/details/122260034?spm=1001.2014.3001.5502</span></p></li><li><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMWhMNDExNDc5VC8/c3BtX2lkX2Zyb209MzMzLjMzNy5zZWFyY2gtY2FyZC5hbGwuY2xpY2smYW1wO3ZkX3NvdXJjZT1mMTYyZDVjMjU3NTVlMGQ2YjljYzM1OGI0ZjNlOGU0Zg==">https://www.bilibili.com/video/BV1hL411479T/?spm_id_from=333.337.search-card.all.click&amp;vd_source=f162d5c25755e0d6b9cc358b4f3e8e4f</span></p></li></ul><h1 id="mysql常见的日志有哪些分别起到了什么作用"><a class="anchor" href="#mysql常见的日志有哪些分别起到了什么作用">#</a> MySQL 常见的日志有哪些，分别起到了什么作用</h1><ol><li>bin log ：数据恢复、主从复制</li></ol><p>MySQL Server 层也有一个日志文件叫做 Binlog ，它可以被所有的存储引擎使用。</p><p>bin log 以事件的形式记录了所有的 DDL 和 DML 语句（因为他记录的是操作而不是数据值），可以用做主从复制和数据恢复</p><ol start="2"><li><p>relay log ：中介日志</p></li><li><p>redo log</p><p>记录修改后的值，属于物理日志</p><p>redo log 的大小事固定的，前面的内容会被覆盖，所以不能用于数据回滚 / 数据恢复</p><p>redo log 是 InnoDB 存储引擎实现的，并不是所有引擎都有</p></li><li><p>undo log</p><p>撤销日志，在数据库事务开始之前，MYSQL 会去记录更新前的数据到 undo log 文件中。如果事务回滚或者数据库崩溃时，可以利用 undo log 日志中记录的日志信息进行回退。同时也可以提供多版本并发控制下的读 (MVCC)</p><p>具体查看：<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xUMTFoa2EvYXJ0aWNsZS9kZXRhaWxzLzEyNTg3MDk4MSVFNCVCQiU4MCVFNCVCOSU4OCVFNiU5OCVBRkJ1ZmZlcg==">https://blog.csdn.net/LT11hka/article/details/125870981 什么是 Buffer</span> Pool</p></li></ol><img data-src="/interview/MySQL/image-20220909103813728.png" title="image-20220909103813728"><h1 id="buffer-pool-内存淘汰策略"><a class="anchor" href="#buffer-pool-内存淘汰策略">#</a> Buffer pool 内存淘汰策略</h1><p>冷热分区的 LRU 策略</p><p>冷热分区比：5:3</p><p>数据一进来先进入到冷区的头部，默认在 1000ms 之后如果再次访问，就会将他放入到热区</p><h1 id="什么是hash索引"><a class="anchor" href="#什么是hash索引">#</a> 什么是 hash 索引</h1><img data-src="/interview/MySQL/image-20220909104250912.png" title="image-20220909104250912"><p>不适合做范围查找，innodb 不支持 hash 索引</p><h1 id="mysql为什么要用b数做索引"><a class="anchor" href="#mysql为什么要用b数做索引">#</a> MySQL 为什么要用 B + 数做索引</h1><ol><li>B + 树能显著的减少 IO 次数，提高效率</li><li>B + 树的查询效率更加稳定，因为所有的数据都放在了叶子上</li><li>B + 树能提高范围查询的效率，因为叶子结点指向下一个叶子结点</li></ol><h1 id="数据库优化什么是数据库索引有哪些类型"><a class="anchor" href="#数据库优化什么是数据库索引有哪些类型">#</a> 数据库优化，什么是数据库索引，有哪些类型</h1><p><strong>1、按表列属性分类</strong><br>单列索引 (主键索引，唯一索引，普通索引) 和多列索引（组合索引），全文索引</p><ul><li>主键索引</li><li>唯一索引：唯一索引是在一个或多个字段上创建的，但它强制保证每行记录的字段值唯一。</li><li>普通索引：普通索引是最常用的索引，它是在一个或多个字段上创建的，可以加快数据库查询的速度。</li><li>多列索引：组合索引是在多个字段上创建的，可以提高查询的效率。</li><li>全文索引：全文索引是用于文本搜索的特殊索引，它可以提高文本搜索的效率。</li></ul><p><strong>2、按数据结构分类</strong></p><ul><li>1） B+tree 索引<br>b+tree 基于平衡二叉树的一种多路平衡查找树，所有记录都按照顺序存放在叶子节点中，各个叶子节点直接通过链表相连。与 b 树不同的是：非叶子节点只存储键值信息。所有叶子节点之间都有一个链指针。数据记录都存放在叶子节点中。</li><li>2）hash 索引<br>基于 hash 表结构实现的索引，mysql 中只有 MEMORY/HEAP 和 NDB 存储引擎支持；InnoDB 引擎支持自适应 hash 索引，但是是数据库自身创建使用的，而不能进行人为定义。当二级索引被频繁的访问时，便会自动创建自适应哈希索引；通过 命令 SHOW ENGINE INNODB STATUS 可查看自适应 hash 索引的使用情况；通过 命令 SHOW VARIABLES LIKE ‘% ap% hash_index’ 查看是否打开自适应 hash 索引对比：<br>由于 hash 索引是比较其 hash 值，hash 索引只能进行等值查找而不能进行范围查找 hash 索引无法进行排序：原因同上不支持最左匹配原则，复合索引时合并一起计算 hash 值 hash 索引的检索效率很高可以一次定位，但是当发生大量 hash 碰撞的时候，链表变长，hash 索引效率上是不如 b+tree 的由于存在 hash 碰撞的问题，当需要获得总数时候，hash 索引在任何时候都不能避免表扫描</li><li>3）T-tree 索引</li><li>4）R-tree 索引</li></ul><p><strong>3、按存储结构分类</strong></p><ul><li><strong>1）聚簇索引 (聚集索引)</strong><br>InnoDB 的聚簇索引实际上是在同一个 BTree 结构中同时存储了<strong>索引和整行数据</strong>，通过该索引查询<strong>可以直接获取查询数据行</strong>。<br>聚簇索引不是一种单独的索引类型，而是一种数据的存储方式，聚簇索引的顺序，就是数据在硬盘上的物理顺序。<br>在<strong> mysql</strong> 通常聚簇索引是主键的同义词，<strong>每张表只包含一个聚簇索引</strong> (其他数据库不一定)。</li><li><strong>2）非聚集索引 (辅助索引，次级索引，二级索引)</strong><br>非聚集索引在 BTree 的叶子节点中保存了<strong>索引列和主键</strong>。如果查询列不在该索引内，只能查到其主键值，还<strong>需要回表操作查询聚簇索引进行查询</strong>。</li><li><strong>聚簇索引的优点：</strong><br><strong>可以把相关数据保存在一起</strong>，如：实现电子邮箱时，可以根据用户 ID 来聚集数据，这样只需要从磁盘读取少量的数据页就能获取某个用户全部邮件，如果没有使用聚集索引，则每封邮件都可能导致一次磁盘 IO。<br><strong>数据访问更快，聚集索引将索引和数据保存在同一个 btree 中</strong>，因此从聚集索引中获取数据通常比在非聚集索引中查找要快。<br>使用覆盖索引扫描的查询可以直接使用页节点中的主键值。</li><li><strong>聚簇索引的缺点：</strong><br>聚簇数据最大限度地提高了 IO 密集型应用的性能，但如果数据全部放在内存中，则访问的顺序就没有那么重要了，聚集索引也没有什么优势了<br>插入速度严重依赖于插入顺序，按照主键的顺序插入是加载数据到 innodb 表中速度最快的方式，但如果不是按照主键顺序加载数据，那么在加载完成后最好使用 optimize table 命令重新组织一下表<br>更新聚集索引列的代价很高，因为会强制 innodb 将每个被更新的行移动到新的位置。<br>基于聚集索引的表在插入新行，或者主键被更新导致需要移动行的时候，可能面临页分裂的问题，当行的主键值要求必须将这一行插入到某个已满的页中时，存储引擎会将该页分裂成两个页面来容纳该行，这就是一次页分裂操作，页分裂会导致表占用更多的磁盘空间。<br>聚集索引可能导致全表扫描变慢，尤其是行比较稀疏，或者由于页分裂导致数据存储不连续的时候。<br>二级索引可能比想象的更大，因为在二级索引的叶子节点包含了引用行的主键列。<br>二级索引访问需要两次索引查找，而不是一次。</li></ul><h1 id="索引的优缺点"><a class="anchor" href="#索引的优缺点">#</a> 索引的优缺点</h1><p>1、优点：创建索引可以大大提高系统的性能。<br>第一、通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。<br>第二、可以大大加快 数据的检索速度，这也是创建索引的最主要的原因。<br>第三、可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。<br>第四、在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。<br>第五、通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。<br>也许会有人要问：增加索引有如此多的优点，为什么不对表中的每一个列创建一个索引呢？这种想法固然有其合理性，然而也有其片面性。虽然，索引有许多优点， 但是，为表中的每一个列都增加索引，是非常不明智的。</p><p>2、缺点<br>第一、创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。<br>第二、索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间。如果要建立聚簇索引，那么需要的空间就会更大。<br>第三、当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。</p><h1 id="谈一下你对数据库btree的理解"><a class="anchor" href="#谈一下你对数据库btree的理解">#</a> 谈一下你对数据库 b+tree 的理解</h1><p>Mysql 索引使用的是 B + 树，因为索引是用来加快查询的，而 B + 树通过对数据进行排序所以是可以提高查询速度的，然后通过一个节点中可以存储多个元素，从而可以使得 B + 树的高度不会太高</p><p>在 Mysql 中一个 Innodb 页就是一个 B + 树节点，一个 Innodb 页默认 16kb，所以一般情况下一颗两层的 B + 树可以存 2000 万行左右的数据，然后通过利用 B + 树叶子节点存储了所有数据并且进行了排序，并且叶子节点之间有指针，可以很好的支持全表扫描，范围查找等 SQL 语句</p><p>我们建议不要让 B + 树的层数超过三层，所以当数据了超过 2000W 行的时候就要进行分库分表。</p><h1 id="聚集索引和非聚集索引的区别"><a class="anchor" href="#聚集索引和非聚集索引的区别">#</a> 聚集索引和非聚集索引的区别</h1><ol><li><p>聚集索引：聚集索引是指将索引键值作为表中数据物理存储的顺序，并且只能有一个聚集索引。</p></li><li><p>非聚集索引：非聚集索引不影响表中数据的物理存储顺序，可以有多个非聚集索引，每个索引都包含一个指向表中行的指针。</p></li></ol><h1 id="在日常工作中是如何进行数据库优化的"><a class="anchor" href="#在日常工作中是如何进行数据库优化的">#</a> 在日常工作中是如何进行数据库优化的</h1><ol><li><p>使用正确的索引：为数据库表添加正确的索引可以加快查询速度，提高性能。</p></li><li><p>合理分配内存：为数据库分配合理的内存可以减少磁盘 I/O 操作，提高系统性能。</p></li><li><p>分析查询语句：分析 SQL 查询语句，改写查询语句，可以减少查询时间，提高数据库性能。</p></li><li><p>合理分区：合理分区数据库表可以提高查询性能，减少 I/O 操作，提高系统性能。</p></li><li><p>数据库优化：使用数据库优化工具，如 MySQL 优化器，可以改善数据库性能。</p></li><li><p>合理使用存储过程：使用存储过程可以减少查询次数，提高数据库性能。</p></li></ol><h1 id="请列举几个索引失效的场景"><a class="anchor" href="#请列举几个索引失效的场景">#</a> 请列举几个索引失效的场景</h1><p>(1) like 以 % 开头，索引无效；当 like 前缀没有 %，后缀有 % 时，索引有效。</p><p>(2) or 语句前后没有同时使用索引。当 or 左右查询字段只有一个是索引，该索引失效，只有当 or 左右查询字段均为索引时，才会生效</p><p>(3) 组合索引，不是使用第一列索引，索引失效。</p><p>(4) 数据类型出现隐式转化。如 varchar 不加单引号的话可能会自动转换为 int 型 (用 select 查询时)，使索引无效，产生全表扫描。</p><p>(5) 在索引列上使用 IS NULL 或 IS NOT NULL 操作 (在 where 子句中对字段进行 null 值判断)</p><p>(6) 在索引字段上使用 not，&lt;&gt;，!=。不等于操作符是永远不会用到索引的，因此对它的处理只会产生全表扫描。 优化方法： key&lt;&gt;0 改为 key&gt;0 or key&lt;0。</p><p>(7) 对索引字段进行计算操作、字段上使用函数。</p><p>(8) 当全表扫描速度比索引速度快时，mysql 会使用全表扫描，此时索引失效。</p><p>索引失效分析工具：</p><p>可以使用 explain 命令加在要分析的 sql 语句前面，在执行结果中查看 key 这一列的值，如果为 NULL，说明没有使用索引。</p><h1 id="数据库锁的机制"><a class="anchor" href="#数据库锁的机制">#</a> 数据库锁的机制</h1><p>**InnoDB 支持行级锁 (row-level locking) 和表级锁，默认为行级锁（偏向于写）** 在 Mysql 中，行级锁并不是直接锁记录，而是锁索引。InnoDB 行锁是通过给索引项加锁实现的，而索引分为主键索引和非主键索引两种</p><p>（1）命中索引才锁行，未命中索引默认锁整个索引，即锁表<br>（2）命中主键索引，直接锁主键索引对应的整行<br>（3）命中辅助索引，先锁命中的辅助索引，在锁该辅助索引所对应的主键索引</p><p>在实际应用中，要特别注意 InnoDB 行锁的这一特性，不然的话，可能导致大量的锁冲突，从而影响并发性能。<br>1、在不通过索引条件查询的时候，InnoDB 的效果就相当于表锁<br>2、当表有多个索引的时候，不同的事务可以使用不同的索引锁定不同的行，另外，不论 是使用主键索引、唯一索引或普通索引，InnoDB 都会使用行锁来对数据加锁。<br>3、由于 MySQL 的行锁是针对索引加的锁，不是针对记录加的锁，所以即便你的 sql 语句访问的是不同的记录行，但如果命中的是相同的被锁住的索引键，也还是会出现锁冲突的。<br>4、即便在条件中使用了索引字段，但是否使用索引来检索数据是由 MySQL 通过判断不同 执行计划的代价来决定的，如果 MySQL 认为全表扫描效率更高，比如对一些很小的表，它 就不会使用索引，这种情况下 InnoDB 将锁住所有行，相当于表锁。因此，在分析锁冲突时，别忘了检查 SQL 的执行计划，以确认是否真正使用了索引</p><p>innodb 的三种行锁算法，三种都是排他锁：<br>1、record lock：单个行记录上的锁<br>2、gap lock：间隙锁，锁定一个范围，但不包括记录本身。GAP 锁的目的，是为了防止同一事务的两次当前读，出现幻读的情况。<br>3、Next-key lock：等于 Record Lock 结合 Gap Lock，也就说 Next-Key Lock 既锁定记录本身也锁定一个范围，特别需要注意的是，InnoDB 存储引擎还会对辅助索引下一个键值加上 gap lock。对于行查询，innodb 采用的都是 Next-Key Lock，主要目的是解决幻读的问题，以满足相关隔离级别以及恢复和复制的需要。</p><p>Innodb 自动使用间隙锁的条件：<br>（1）<strong>必须在 RR 级别下</strong><br>（2）<strong>检索条件必须有索引</strong>（没有索引的话，mysql 会全表扫描，那样会锁定整张表所有的记录，包括不存在的记录，此时其他事务不能修改不能删除不能添加）</p><p>死锁现象：<br>死锁就是两个或多个事务在未结束的情况下，用排他锁互相锁死的一种特殊情况，下面有两种死锁情况（仅供参考）</p><img data-src="/interview/MySQL/20210226170241867.png" title="在这里插入图片描述"> <img data-src="/interview/MySQL/20210226170250512.png" title="在这里插入图片描述"><p>2、死锁产生的本质原理<br>死锁的发生与否，并不在于事务中有多少条 SQL 语句，死锁的关键在于：两个 (或以上) 的 Session 加锁的顺序不一致。而使用本文上面提到的，分析 MySQL 每条 SQL 语句的加锁规则，分析出每条语句的加锁顺序，然后检查多个并发 SQL 间是否存在以相反的顺序加锁的情况，就可以分析出各种潜在的死锁情况，也可以分析出线上死锁发生的原因。</p><p><strong>行锁优化建议：</strong><br>通过检查 InnoDB_row_lock 状态变量来分析系统上的行锁的争夺情况，在着手根据状态量来分析改善；<br>show status like ‘innodb_row_lock%’;// 查看行锁的状态<br>尽可能让所有数据检索都通过索引来完成， 从而避免无索引行锁升级为表锁<br>合理设计索引，尽量缩小锁的范围<br>尽可能减少检索条件，避免间隙锁<br>尽量控制事务大小，减少锁定资源量和时间长度<br>尽可能低级别事务隔离</p><p>悲观锁<br>** 在关系数据库管理系统里，悲观并发控制（又名 “悲观锁”，Pessimistic Concurrency Control，缩写 “PCC”）是一种并发控制的方法。它可以阻止一个事务以影响其他用户的方式来修改数据。** 如果一个事务执行的操作都某行数据应用了锁，那只有当这个事务把锁释放，其他事务才能够执行与该锁冲突的操作。<br>悲观并发控制主要用于数据争用激烈的环境，以及发生并发冲突时使用锁保护数据的成本要低于回滚事务的成本的环境中。<br>优点：<br>悲观并发控制实际上是 “先取锁再访问” 的保守策略，为数据处理的安全提供了保证。</p><p>缺点：<br>（a）在效率方面，处理加锁的机制会让数据库产生额外的开销，还有增加产生死锁的机会；<br>（b） 在只读型事务处理中由于不会产生冲突，也没必要使用锁，这样做只能增加系统负载；还有会降低了并行性，一个事务如果锁定了某行数据，其他事务就必须等待该事务处理完才可以处理那行数</p><p>乐观锁<br>在关系数据库管理系统里，乐观并发控制（又名 “乐观锁”，Optimistic Concurrency Control，缩写 “OCC”）是一种并发控制的方法。它假设多用户并发的事务在处理时不会彼此互相影响，各事务能够在不产生锁的情况下处理各自影响的那部分数据。 相对于悲观锁，在对数据库进行处理的时候，乐观锁并不会使用数据库提供的锁机制。一般的实现乐观锁的方式就是记录数据版本。</p><p>在数据库中，乐观锁的实现有两种方式<br>1、使用版本号实现<br>每一行数据多一个字段 version，每次更新数据对应版本号 + 1，<br>原理：读出数据，将版本号一同读出，之后更新，版本号 + 1，提交数据版本号大于数据库当前版本号，则予以更新，否则认为是过期数据，重新读取数据</p><p>2、使用时间戳实现<br>每一行数据多一个字段 time<br>原理：读出数据，将时间戳一同读出，之后更新，提交数据时间戳等于数据库当前时间戳，则予以更新，否则认为是过期数据，重新读取数据</p><p>优点与不足<br>乐观并发控制相信事务之间的数据竞争 (data race) 的概率是比较小的，因此尽可能直接做下去，直到提交的时候才去锁定，所以不会产生任何锁和死锁。</p><p>如何选择<br>在乐观锁与悲观锁的选择上面，主要看下两者的区别以及适用场景就可以了：<br>1、乐观锁并未真正加锁，效率高。一旦锁的粒度掌握不好，更新失败的概率就会比较高，容易发生业务失败。<br>2、悲观锁依赖数据库锁，效率低。更新失败的概率比较低。随着互联网三高架构（高并发、高性能、高可用）的提出，悲观锁已经越来越少的被使用到生产环境中了，尤其是并发量比较大的业务场景。</p><h1 id="在遇到死锁情况如何处理"><a class="anchor" href="#在遇到死锁情况如何处理">#</a> 在遇到死锁情况如何处理</h1><p>死锁的发生与否，并不在于事务中有多少条 SQL 语句，死锁的关键在于：两个 (或以上) 的 Session 加锁的顺序不一致。分析 MySQL 每条 SQL 语句的加锁规则，分析出每条语句的加锁顺序，然后检查多个并发 SQL 间是否存在以相反的顺序加锁的情况，就可以分析出各种潜在的死锁情况，也可以分析出线上死锁发生的原因。</p><ol><li><p>使用数据库调试工具检查死锁，查看死锁发生的原因。</p></li><li><p>尝试重新调整数据库的索引结构，减少数据库的查询和更新操作，以减少死锁的发生。</p></li><li><p>将数据库的事务隔离级别调整为更低的级别，以减少死锁的发生。</p></li><li><p>将数据库的事务超时时间设置得更短，以便及时中断发生死锁的事务。</p></li><li><p>将死锁发生的数据表拆分成多个表，以减少数据表上的竞争。</p></li></ol><h1 id="mysql和oracle的区别"><a class="anchor" href="#mysql和oracle的区别">#</a> mysql 和 oracle 的区别</h1><h1 id="数据库的根本特点"><a class="anchor" href="#数据库的根本特点">#</a> 数据库的根本特点</h1><p>1、数据结构化 数据库系统实现了整体数据的结构化，这是数据库的最主要的特征之一</p><p>2、数据的共享性高，冗余度低，易扩充 因为数据是面向整体的，所以数据可以被多个用户、多个应用程序共享使用</p><p>3、数据独立性高 数据独立性包括数据的物理独立性和逻辑独立性。</p><p>4、数据由 DBMS 统一管理和控制 数据库的共享是并发的 (concurrency) 共享，即多个用户可以同时存取数据库中的数据，甚至可以同时存取数据库中的同一个数据；</p><h1 id="数据库中数据共享是指"><a class="anchor" href="#数据库中数据共享是指">#</a> 数据库中数据共享是指</h1><p>多个应用、多种语言、多个用户共享数据</p><h1 id="数据库中产生数据不一致"><a class="anchor" href="#数据库中产生数据不一致">#</a> 数据库中产生数据不一致</h1><p>1. 并发控制不当</p><p>2. 数据冗余</p><p>3. 各种故障，错误</p><p>第一种往往是由于重复存放的数据未能进行一致性更新造成的</p><p>第二种情况是由于多用户共享数据库，而更新操作未能保持同步进行引起的</p><p>第三种是由于某种原因（硬件故障或软件故障等）而造成数据丢失或数据损坏等</p><h1 id="运算"><a class="anchor" href="#运算">#</a> 运算</h1><img data-src="/interview/MySQL/c484ce59eba713b93d75a1381901dabe.png" title="img"> <img data-src="/interview/MySQL/9606dddddf13fb7dafa3119aa768e7a4.png" title="数据库之运算符详解_数据库_18"><h2 id="运算优先级"><a class="anchor" href="#运算优先级">#</a> 运算优先级</h2><img data-src="/interview/MySQL/2b23723e1f54716522beeb85047554c2.png" title="数据库之运算符详解_mysql_23"><h1 id="问题"><a class="anchor" href="#问题">#</a> 问题</h1><ol><li><p>MySQL 索引使用有哪些注意事项呢？</p></li><li><p>MysQL 遇到过死锁问题吗，你是如何解决的？</p></li><li><p>日常工作中你是怎么优化 SQL 的？</p></li><li><p>说说分库与分表的设计</p></li><li><p>InnoDB 与 MylSAM 的区别</p></li><li><p>数据库索引的原理，为什么要用 B + 树，为什么不用二叉树？</p></li><li><p>聚集索引与非聚集索引的区别</p></li><li><p>limit 1000000 加载很慢的话，你是怎么解决的呢？</p><p><strong>方案一</strong>：如果 id 是连续的，可以这样，返回上次查询的最大记录 (偏移量)，再往下 limit</p><p>select id，name from employee where id&gt;1000000 limit 10.</p><p><strong>方案二</strong>：在业务允许的情况下限制页数：</p><p>建议跟业务讨论，有没有必要查这么后的分页啦。因为绝大多数用户都不会往后翻太多页。</p><p><strong>方案三</strong>：order by + 索引（id 为索引）</p><p>select id，name from employee order by id limit 1000000，10</p><p><strong>方案四</strong>：利用延迟关联或者子查询优化超多分页场景。（先快速定位需要获取的 id 段，然后再关联）</p><p>SELECT a.* FROM employee a, (select id from employee where 条件 LIMIT 1000000,10) b where <span class="exturl" data-url="aHR0cDovL2EuaWQ9Yi5pZA==">a.id=b.id</span></p></li><li><p>如何选择合适的分布式主键方案呢？</p></li><li><p>事务的隔离级别有哪些？MySQL 的默认隔离级别是什么？</p></li><li><p>什么是幻读，脏读，不可重复读呢？</p></li><li><p>在高并发情况下，如何做到安全的修改同一行数据？</p></li><li><p>数据库的乐观锁和悲观锁。</p></li><li><p>select for update 有什么含义，会锁表还是锁行还是其他。</p><p>select 查询语句是不会加锁的，但是 select …for update<strong> 除了有查询的作用外，还会加锁呢，而且它是悲观锁，排他锁。</strong></p><p>那么它加的是行锁还是表锁，这就要看是不是用了索引 / 主键。</p><p><strong>没用索引 / 主键的话就是表锁，否则就是是行锁</strong>。</p></li><li><p>MySQL 事务得四大特性以及实现原理</p></li><li><p>如果某个表有近千万数据，CRUD 比较慢，如何优化</p></li><li><p>如何写 sql 能够有效的使用到复合索引。</p></li><li><p>mysql 中 in 和 exists 的区别。</p><ul><li>子查询使用 exists，会先进行主查询，将查询到的每行数据循环带入子查询校验是否存在，过滤出整体的返回数据；子查询使用 in，会先进行子查询获取结果集，然后主查询匹配子查询的结果集，返回数据</li><li>外表内表相对大小情况不一样时，查询效率不一样：两表大小相当，in 和 exists 差别不大；内表大，用 exists 效率较高；内表小，用 in 效率较高。</li><li>不管外表与内表的大小，not exists 的效率一般要高于 not in，跟子查询的索引访问类型有关。</li></ul><ol><li><p>IN 和 EXISTS 都可以用来检测一个值是否存在于一个子查询中，但它们之间有一些重要的区别：</p></li><li><p>IN 操作符比较的是值，而 EXISTS 操作符比较的是整个子查询的结果。</p></li><li><p>IN 操作符只能比较一列值，而 EXISTS 操作符可以比较多列值。</p></li><li><p>IN 操作符不能使用带有 “NOT” 的条件，而 EXISTS 操作符可以使用带有 “NOT” 的条件。</p></li><li><p>IN 操作符的效率比 EXISTS 操作符要低，因为它必须比较每一行，而 EXISTS 操作符只检查是否存在至少一行满足条件。</p></li></ol></li><li><p>数据库自增主键可能遇到什么问题。</p></li><li><p>MVCC 熟悉吗，它的底层原理？</p></li><li><p>数据库中间件了解过吗，sharding jdbc，mycat?</p></li><li><p>MYSQL 的主从延迟，你怎么解决？</p><p>配合 semi-sync 半同步复制；<br>一主多从，分摊从库压力；<br>强制走主库方案（强一致性）；<br>sleep 方案：主库更新后，读从库之前先 sleep 一下；<br>判断主备无延迟方案（例如判断 seconds_behind_master 参数是否已经等于 0、对比位点）；<br>并行复制 — 解决从库复制延迟的问题；<br>这里主要介绍我在项目中使用的几种方案，分别是半同步复制、实时性操作强制走主库、并行复制。</p><p>参考资料：</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81NTQ5NjcxOC9hcnRpY2xlL2RldGFpbHMvMTI2NzM5MTEx">https://blog.csdn.net/weixin_55496718/article/details/126739111</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NodWlnZTIwMTMvYXJ0aWNsZS9kZXRhaWxzLzEyODU1NzMyMA==">https://blog.csdn.net/chuige2013/article/details/128557320</span></li></ul></li><li><p>说一下大表查询的优化方案</p></li><li><p>什么是数据库连接池？为什么需要数据库连接池呢？</p><p>数据库连接池（Database Connection Pooling）在程序初始化时创建一定数量的数据库连接对象并将其保存在一块内存区中，它允许应用程序重复使用一个现有的数据库连接，而不是重新建立一个；释放空闲时间超过最大空闲时间的数据库连接以避免因为没有释放数据库连接而引起的数据库连接遗漏。</p><p>​ 即在程序初始化的时候创建一定数量的数据库连接，用完可以放回去，下一个在接着用，通过配置连接池的参数来控制连接池中的初始连接数、最小连接、最大连接、最大空闲时间这些参数保证访问数据库的数量在一定可控制的范围类，防止系统崩溃，使用户的体验好</p><p><strong>为什么使用数据库连接池？（形象的说就是用了可以放回去给别人用，大家共享）</strong></p><p>数据库连接是一种关键、有限且昂贵的资源，创建和释放数据库连接是一个很耗时的操作，频繁地进行这样的操作将占用大量的性能开销，进而导致网站的响应速度下降，严重的时候可能导致服务器崩溃；数据库连接池可以节省系统许多开销。</p></li><li><p>一条 SQL 语句在 MySQL 中如何执行的？</p><p>from、where、select、group by having 、order by 、limit</p><p>可以将 SQL 语句执行分为两种种情况<br><strong>1、查询语句</strong></p><blockquote><p>select * from student where ssex=' 男 ' and classid=1;</p></blockquote><ul><li>先去检查语句是否有权限，如果没有权限，就会返回错误信息，如果有权限，就会西安查缓存查询，如果这条 sql 语句为 key 在缓存中查询有结果，则返回。</li><li>通过分析器进行词法分析，提取 sql 语句的关键元素。比如上面的语句是 select，提取关键字，表名 student，条件 ssex = 男，classid=1.</li><li>然后去判断 sql 语句是否有语法错误，提取的关键字是否有错误。没有就执行下一步</li><li>优化器确定优化方案：查询是男的学生；查询班级编号为 1 的学生</li><li>优化器会根据自己的判断去选择一个自己认为最好的方案去执行</li><li>进行权限验证</li></ul><p><strong>2、增删改</strong></p><blockquote><p>update student set ssex=' 女 ' where classid=1</p></blockquote><ul><li>先去查询一般这个数据，如果有缓存的话也是会用到缓存</li><li>然后拿到查询的语句，把性别改为女，然后去调用引擎 api 接口，写入修改的数据，存储引擎 innodb 把数据保存在内存中，写入日志中，告诉执行器执行</li><li>执行器执行，提交事务</li></ul></li><li><p>innodb 引擎中的索引策略了解过吗</p><p>InnoDB 引擎中的索引策略是一种索引优化技术，它通过分析表中的数据和索引结构，来调整索引结构，以最大程度地提高查询效率。它可以帮助数据库管理员改善查询性能，提高查询速度，减少索引大小，从而节省空间。InnoDB 引擎中的索引策略主要有以下几种：</p><ol><li><p>选择最佳索引：这种索引策略会选择最佳的索引来满足查询的要求，以便最大限度地提高查询性能。</p></li><li><p>索引合并：这种索引策略会将多个索引合并成一个索引，以减少索引大小，提高查询性能。</p></li><li><p>索引重建：这种索引策略会定期重建表中的索引，以避免索引碎片，提高查询性能。</p></li><li><p>索引优化：这种索引策略会根据查询的频率和数据的变化情况，调整索引的结构，以提高查询性能。</p></li></ol></li><li><p>一条 SQL 执行时间过长如何优化</p></li><li><p>MYSQL 数据库服务器性能分析的方法命令有哪些？</p></li><li><p>Blob 和 text 有什么区别？</p><p>Blob 和 text 是两种不同的对象类型，用于表示二进制数据。</p><p>Blob 是一种<strong>不可变的原始数据类型</strong>，可以表示任意大小的二进制数据，但是不能直接操作。它可以用于存储图像，视频，文档等文件类型。</p><p>Text 是一种<strong>可变的原始数据类型</strong>，可以表示字符串，可以直接操作。它可以用于存储文本，网页，JSON 等文件类型。</p></li><li><p>mysql 里记录货币用什么字段类型比较好？</p><p>MySQL 中最常用的字段类型来记录货币是 DECIMAL（精度）或 NUMERIC（精度）类型。DECIMAL（精度）和 NUMERIC（精度）类型允许您指定小数点后的位数，以便更准确地表示货币值。</p></li><li><p>Mysql 中有哪几种锁，列举一下？</p></li><li><p>Hash 索引和 B + 树区别是什么？你在设计索引是怎么抉择的？</p></li><li><p>mysql 的内连接、左连接、右连接有什么区别？</p></li><li><p>说说 MySQL 的基础架构图</p></li><li><p>什么是内连接、外连接、交叉连接、笛卡尔积呢？</p></li><li><p>说一下数据库的三大范式</p></li><li><p>Mysql 的 binlog 有几种录入格式？分别有什么区别？</p><p>1、Row-based 格式：这种格式下，MySQL 会记录每一行的变更，比如更新前后的值，插入前后的值，删除前后的值等，可以详细描述每一次变更。</p><p>2、Statement-based 格式：这种格式下，MySQL 只会记录 SQL 语句本身，不会记录每一行的变更，只能描述变更的范围，比如更新了几行，插入了几行，删除了几行等。</p><p><strong>区别</strong>：</p><p>Row-based 格式比 Statement-based 格式更加详细，但是会占用更多的空间，Statement-based 格式比 Row-based 格式占用的空间少，但是不能描述每一行的变更。</p></li><li><p>InnoDB 引擎的 4 大特性，了解过吗</p><p>1. 事务安全：InnoDB 引擎支持 ACID 事务，保证了事务的原子性、一致性、隔离性和持久性。</p><p>2. 行级锁：InnoDB 引擎支持行级锁，可以实现多用户并发访问，提高系统的性能。</p><p>3. 外键约束：InnoDB 引擎支持外键约束，可以防止数据的一致性和完整性。</p><p>4. 崩溃恢复能力：InnoDB 引擎支持崩溃恢复能力，可以恢复在数据库崩溃时发生的数据损失。</p></li><li><p>索引有哪些优缺点？索引有哪几种类型？</p></li><li><p>创建索引有什么原则呢？</p></li><li><p>创建索引的三种方式</p></li><li><p>百万级别或以上的数据，你是如何删除的？</p></li><li><p>什么是最左前缀原则？什么是最左匹配原则？</p></li><li><p>B 树和 B + 树的区别，数据库为什么使用 B + 树而不是 B 树？</p></li><li><p>覆盖索引、回表等这些，了解过吗？</p></li><li><p>非聚簇索引一定会回表查询吗？</p></li><li><p>联合索引是什么？为什么需要注意联合索引中的顺序？</p></li><li><p>数据库隔离级别与锁的关系</p></li><li><p>聊聊 InnoDb 的锁，什么是死锁？怎么解决？</p></li><li><p>count (1)、count (*) 与 count (列名) 的区别？</p></li><li><p>什么是存储过程？有哪些优缺点？</p></li><li><p>SQL 约束有哪几种呢？</p></li><li><p>varchar (50) 中的 50 是啥意思，varchar 和 char 的区别</p></li><li><p>mysql 中 int (20)、char (20)、varchar (20) 的区别</p></li><li><p>drop、delete 与 truncate 的区别</p></li><li><p>UNION 与 UNION ALL 的区别？</p></li><li><p>SQL 的生命周期？</p></li><li><p>一条 Sql 的执行顺序？</p></li><li><p>关心过业务系统里面的 sql 耗时吗？统计过慢查询吗？对慢查询都怎么优化过？</p></li><li><p>主键使用自增 ID 还是 UUID，为什么？mysql 自增主键用完了怎么办？</p></li><li><p>MySQL 数据库 cpu 飙升的话，要怎么处理呢？</p></li><li><p>读写分离常见方案？</p></li><li><p>MySQL 的复制原理以及流程</p></li><li><p>Innodb 的事务实现原理？</p></li><li><p>谈谈 MySQL 的 Explain</p></li><li><p>Innodb 的事务与日志的实现方式</p></li><li><p>你们数据库是否支持 emoji 表情存储，如果不支持，如何操作？</p></li><li><p>一个 6 亿的表 a，一个 3 亿的表 b，通过外间 tid 关联，你如何最快的查询出满足条件的第 50000 到第 50200 中的这 200 条数据记录。</p></li><li><p>Mysql 一条 SOL 加锁分析</p></li><li><p>回表问题和覆盖索引</p></li><li><p>MySQL 索引</p></li><li><p>回表问题和覆盖索引</p></li><li><p>双写一致性</p></li><li><p>undo 、redo、binlog</p></li><li><p>Hash 索引和 B + 树的区别是什么？</p><ol><li>B + 树可以进行范围查询，Hash 索引不能。</li><li>B + 树支持联合索引的最左侧原则，Hash 索引不支持。B + 树支持 order by 排序，Hash 索引不支持。</li><li>Hash 索引在等值查询上比 B + 树效率更高。</li><li>B + 树使用 like 进行模糊查询的时候，like 后面（比如 % 开头) 的话可以起到优化的作用，Hash 索引根本无法进行模糊查询</li></ol><img data-src="MySQL/image-20230124130116883.png" alt="image-20230124130116883" style="zoom:150%"><p>Mysql 逻辑架构图主要分三层:</p><p>第一层负责连接处理，授权认证，安全等等</p><p>第二层负责编译并优化 SQL</p><p>第三层是存储引擎。</p></li></ol><img data-src="MySQL/image-20230124125910848.png" alt="image-20230124125910848" style="zoom:150%"><p>主从复制分了五个步骤进行</p><ol><li><p>主库的更新事件 (update、insert、 delete) 被写到 binlog</p></li><li><p>从库发起连接，连接到主库。</p></li><li><p>此时主库创建一个 binlog dump thread，把 binlog 的内容发送到从库。</p></li><li><p>从库启动之后，创建一个 I/O 线程，读取主库传过来的 binlog 内容并写入到 relay log</p></li><li><p>还会创建一个 SQL 线程，从 relay log 里面读取内容，从 Exec_Master_Log_Pos 位置开始执行读取到的更新事件，将更新内容写入到 slave 的 db</p></li><li></li><li></li></ol><h2 id="未完成"><a class="anchor" href="#未完成">#</a> 未完成</h2><h1 id="未完成-2"><a class="anchor" href="#未完成-2">#</a> —————————— 未完成</h1><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig={clientID:"6db178ba46c8af8f6a6f",clientSecret:"90f730e5956024596558df00975cd8eae28cae3d",repo:"bk-comment01",owner:"onlymarryu",admin:["onlymarryu"],distractionFreeMode:!1,language:"zh-CN",proxy:"https://gitalk-comments.netlify.app/github_access_token",perPage:15};gitalkConfig.id=md5(location.pathname);var gitalk=new Gitalk(gitalkConfig);gitalk.render("gitalk-container")</script><div class="tags"><a href="/tags/%E7%AA%81%E5%87%BB%E7%89%88-%E5%A4%8D%E4%B9%A0%E7%89%88/" rel="tag"><i class="ic i-tag"></i> 突击版 复习版</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2023-01-25 22:55:47" itemprop="dateModified" datetime="2023-01-25T22:55:47+08:00">2023-01-25</time></span></div><div class="reward"><button><i class="ic i-heartbeat"></i> 赞赏</button><p>请我喝[茶]~(￣▽￣)~*</p><div id="qr"><div><img data-src="/images/wechatpay.png" alt="雾都 微信支付"><p>微信支付</p></div><div><img data-src="/images/alipay.png" alt="雾都 支付宝"><p>支付宝</p></div><div><img data-src="/images/paypal.png" alt="雾都 贝宝"><p>贝宝</p></div></div></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>雾都 <i class="ic i-at"><em>@</em></i>每天进步一点点，就是成功的开始</li><li class="link"><strong>本文链接：</strong> <a href="https://eth168.top/interview/MySQL/" title="MySQL 复习题">https://eth168.top/interview/MySQL/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/interview/JVM%E5%BF%AB%E9%80%9F%E7%AA%81%E5%87%BB%E7%89%88/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;api.yimian.xyz&#x2F;img?955722" title="JVM突击版"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> 面试</span><h3>JVM突击版</h3></a></div><div class="item right"></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">1.</span> <span class="toc-text">数据库存储引擎有哪些</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#myisam%E5%92%8Cinnodb%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">2.</span> <span class="toc-text">Myisam 和 Innodb 有什么区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BC%95%E6%93%8E"><span class="toc-number">3.</span> <span class="toc-text">如何选择数据库引擎？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E8%8C%83%E5%BC%8F%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">4.</span> <span class="toc-text">三范式是什么</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%8B%E5%8A%A1%E6%9C%89%E5%93%AA%E4%BA%9B%E7%89%B9%E7%82%B9"><span class="toc-number">5.</span> <span class="toc-text">什么是事务，有哪些特点</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">6.</span> <span class="toc-text">事务的隔离级别有哪些</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E4%BA%8B%E5%8A%A1%E5%B8%A6%E6%9D%A5%E5%93%AA%E4%BA%9B%E9%97%AE%E9%A2%98"><span class="toc-number">7.</span> <span class="toc-text">并发事务带来哪些问题？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E5%BA%A6%E5%92%8C%E5%B9%BB%E8%AF%BB%E5%8C%BA%E5%88%AB"><span class="toc-number">8.</span> <span class="toc-text">不可重复度和幻读区别？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#sql%E4%BC%98%E5%8C%96%E6%89%8B%E6%AE%B5%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">9.</span> <span class="toc-text">SQL 优化手段有哪些？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#undo-log%E6%97%A5%E5%BF%97%E8%AF%A6%E8%A7%A3"><span class="toc-number">10.</span> <span class="toc-text">undo log 日志详解</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#mvcc%E8%AF%A6%E8%A7%A3"><span class="toc-number">11.</span> <span class="toc-text">MVCC 详解</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1mvcc%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">11.1.</span> <span class="toc-text">1.MVCC 是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86%E7%82%B9"><span class="toc-number">11.2.</span> <span class="toc-text">2. 前置知识点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E5%9F%BA%E4%BA%8Eundo-log%E5%A4%9A%E7%89%88%E6%9C%AC%E9%93%BE%E5%AE%9E%E7%8E%B0%E7%9A%84readview%E6%9C%BA%E5%88%B6"><span class="toc-number">11.3.</span> <span class="toc-text">3. 基于 undo log 多版本链实现的 ReadView 机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4readview%E6%9C%BA%E5%88%B6%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E8%AF%BB%E5%B7%B2%E6%8F%90%E4%BA%A4%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%ABrc%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E7%9A%84"><span class="toc-number">11.4.</span> <span class="toc-text">4.ReadView 机制是如何实现读已提交隔离级别（RC 隔离级别）的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-readview%E6%9C%BA%E5%88%B6%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%ABrr%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E7%9A%84"><span class="toc-number">11.5.</span> <span class="toc-text">5. ReadView 机制是如何实现可重复读隔离级别（RR 隔离级别）的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E6%80%BB%E7%BB%93"><span class="toc-number">11.6.</span> <span class="toc-text">6. 总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83"><span class="toc-number">11.7.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#mysql%E5%B8%B8%E8%A7%81%E7%9A%84%E6%97%A5%E5%BF%97%E6%9C%89%E5%93%AA%E4%BA%9B%E5%88%86%E5%88%AB%E8%B5%B7%E5%88%B0%E4%BA%86%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8"><span class="toc-number">12.</span> <span class="toc-text">MySQL 常见的日志有哪些，分别起到了什么作用</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#buffer-pool-%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5"><span class="toc-number">13.</span> <span class="toc-text">Buffer pool 内存淘汰策略</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFhash%E7%B4%A2%E5%BC%95"><span class="toc-number">14.</span> <span class="toc-text">什么是 hash 索引</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#mysql%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8b%E6%95%B0%E5%81%9A%E7%B4%A2%E5%BC%95"><span class="toc-number">15.</span> <span class="toc-text">MySQL 为什么要用 B + 数做索引</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96%E4%BB%80%E4%B9%88%E6%98%AF%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95%E6%9C%89%E5%93%AA%E4%BA%9B%E7%B1%BB%E5%9E%8B"><span class="toc-number">16.</span> <span class="toc-text">数据库优化，什么是数据库索引，有哪些类型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">17.</span> <span class="toc-text">索引的优缺点</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%B0%88%E4%B8%80%E4%B8%8B%E4%BD%A0%E5%AF%B9%E6%95%B0%E6%8D%AE%E5%BA%93btree%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">18.</span> <span class="toc-text">谈一下你对数据库 b+tree 的理解</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95%E5%92%8C%E9%9D%9E%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">19.</span> <span class="toc-text">聚集索引和非聚集索引的区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9C%A8%E6%97%A5%E5%B8%B8%E5%B7%A5%E4%BD%9C%E4%B8%AD%E6%98%AF%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96%E7%9A%84"><span class="toc-number">20.</span> <span class="toc-text">在日常工作中是如何进行数据库优化的</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AF%B7%E5%88%97%E4%B8%BE%E5%87%A0%E4%B8%AA%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%E7%9A%84%E5%9C%BA%E6%99%AF"><span class="toc-number">21.</span> <span class="toc-text">请列举几个索引失效的场景</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%81%E7%9A%84%E6%9C%BA%E5%88%B6"><span class="toc-number">22.</span> <span class="toc-text">数据库锁的机制</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9C%A8%E9%81%87%E5%88%B0%E6%AD%BB%E9%94%81%E6%83%85%E5%86%B5%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86"><span class="toc-number">23.</span> <span class="toc-text">在遇到死锁情况如何处理</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#mysql%E5%92%8Coracle%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">24.</span> <span class="toc-text">mysql 和 oracle 的区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E6%A0%B9%E6%9C%AC%E7%89%B9%E7%82%B9"><span class="toc-number">25.</span> <span class="toc-text">数据库的根本特点</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E6%95%B0%E6%8D%AE%E5%85%B1%E4%BA%AB%E6%98%AF%E6%8C%87"><span class="toc-number">26.</span> <span class="toc-text">数据库中数据共享是指</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E4%BA%A7%E7%94%9F%E6%95%B0%E6%8D%AE%E4%B8%8D%E4%B8%80%E8%87%B4"><span class="toc-number">27.</span> <span class="toc-text">数据库中产生数据不一致</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%90%E7%AE%97"><span class="toc-number">28.</span> <span class="toc-text">运算</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">28.1.</span> <span class="toc-text">运算优先级</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%97%AE%E9%A2%98"><span class="toc-number">29.</span> <span class="toc-text">问题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%AA%E5%AE%8C%E6%88%90"><span class="toc-number">29.1.</span> <span class="toc-text">未完成</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9C%AA%E5%AE%8C%E6%88%90-2"><span class="toc-number">30.</span> <span class="toc-text">—————————— 未完成</span></a></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li class="active"><a href="/interview/MySQL/" rel="bookmark" title="MySQL复习题">MySQL复习题</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="雾都" data-src="/images/avatar.jpg"><p class="name" itemprop="name">雾都</p><div class="description" itemprop="description">花非花，雾非雾</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">61</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">11</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">19</span> <span class="name">标签</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL29ubHltYXJyeXU=" title="https:&#x2F;&#x2F;github.com&#x2F;onlymarryu"><i class="ic i-github"></i></span> <span class="exturl item zhihu" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS9ydXJpc216aw==" title="https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;rurismzk"><i class="ic i-zhihu"></i></span> <span class="exturl item music" data-url="aHR0cHM6Ly9tdXNpYy4xNjMuY29tLyMvbXkvbS9tdXNpYy9wbGF5bGlzdD9pZD0zMTY2MDYwNzkw" title="https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;my&#x2F;m&#x2F;music&#x2F;playlist?id&#x3D;3166060790"><i class="ic i-cloud-music"></i></span> <span class="exturl item weibo" data-url="aHR0cHM6Ly93ZWliby5jb20vYW1laGltZQ==" title="https:&#x2F;&#x2F;weibo.com&#x2F;amehime"><i class="ic i-weibo"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>时间轴</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li><li class="item"><a href="/toolPage/" rel="section"><i class="ic i-feather"></i>MarkDown常用操作</a></li><li class="item"><a href="/projectBuild/" rel="section"><i class="ic i-th"></i>SpringBoot常用配置</a></li></ul></li><li class="item"><a href="/mianshi/" rel="section"><i class="ic i-calendar"></i>面试</a></li><li class="item"><a href="/friends/" rel="section"><i class="ic i-heart"></i>友链</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-calendar"></i>留言</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/%E5%B7%A5%E5%85%B7%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/" title="分类于 工具软件安装">工具软件安装</a></div><span><a href="/tools/Maven-tool/" title="Maven-tool">Maven-tool</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E9%9D%A2%E8%AF%95/" title="分类于 面试">面试</a></div><span><a href="/interview/JavaSE%E2%80%94%E5%A4%9A%E7%BA%BF%E7%A8%8B/" title="多线程">多线程</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E9%9D%A2%E8%AF%95/" title="分类于 面试">面试</a></div><span><a href="/interview/JVM%E5%A4%8D%E4%B9%A0%E7%89%88/" title="JVM复习版">JVM复习版</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E5%B7%A5%E5%85%B7%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/" title="分类于 工具软件安装">工具软件安装</a></div><span><a href="/tools/Kafka-tool/" title="Kafka">Kafka</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/JavaSE/" title="分类于 JavaSE">JavaSE</a></div><span><a href="/Java/%E7%AC%AC9%E7%AB%A0_%E5%BC%82%E5%B8%B8/" title="第9章_异常">第9章_异常</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E5%B7%A5%E5%85%B7%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/" title="分类于 工具软件安装">工具软件安装</a></div><span><a href="/tools/redis-tool/" title="redis">redis</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/JavaSE/" title="分类于 JavaSE">JavaSE</a></div><span><a href="/Java/%E7%AC%AC2%E7%AB%A0_%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/" title="第2章_数据类型">第2章_数据类型</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/JavaSE/" title="分类于 JavaSE">JavaSE</a></div><span><a href="/Java/%E7%AC%AC13%E7%AB%A0%E5%A4%9A%E7%BA%BF%E7%A8%8B/" title="第13章多线程">第13章多线程</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/JavaSE/" title="分类于 JavaSE">JavaSE</a></div><span><a href="/Java/%E7%AC%AC7%E7%AB%A0_IDEA%E7%9A%84%E4%BD%BF%E7%94%A8/" title="第7章_IDEA的使用">第7章_IDEA的使用</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E5%B7%A5%E5%85%B7%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/" title="分类于 工具软件安装">工具软件安装</a></div><span><a href="/tools/python-tool/" title="python">python</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2010 – <span itemprop="copyrightYear">2023</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">雾都 @ 雾都博客</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="站点总字数">932k 字</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="站点阅读时长">14:07</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"interview/MySQL/",favicon:{show:"（●´3｀●）やれやれだぜ",hide:"(´Д｀)大変だ！"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html>