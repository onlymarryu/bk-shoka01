<!-- build time:Tue Oct 18 2022 20:23:03 GMT+0800 (中国标准时间) --><!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="记录“美食”每刻" href="http://example.com/rss.xml"><link rel="alternate" type="application/atom+xml" title="记录“美食”每刻" href="http://example.com/atom.xml"><link rel="alternate" type="application/json" title="记录“美食”每刻" href="http://example.com/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="JavaSE"><link rel="canonical" href="http://example.com/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/"><title>第 11 章集合 - 集合 - JavaSE | 雾都博客 = 记录 “美食” 每刻</title><meta name="generator" content="Hexo 6.3.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">第 11 章集合</h1><div class="meta"><span class="item" title="创建时间：2022-10-07 00:00:00"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2022-10-07T00:00:00+08:00">2022-10-07</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>74k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>1:07</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">雾都博客</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1giph4fomxoj20zk0m8axp.jpg"></li><li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1gipeyhsblkj20zk0m81kx.jpg"></li><li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1gipewr8iypj20zk0m8b29.jpg"></li><li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1gicivghyooj20zk0m8dir.jpg"></li><li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1giclxxcb6rj20zk0m8b29.jpg"></li><li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1gicm0n457cj20zk0m8e81.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/JavaSE/" itemprop="item" rel="index" title="分类于 JavaSE"><span itemprop="name">JavaSE</span></a><meta itemprop="position" content="1"></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/JavaSE/%E9%9B%86%E5%90%88/" itemprop="item" rel="index" title="分类于 集合"><span itemprop="name">集合</span></a><meta itemprop="position" content="2"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://example.com/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="雾都"><meta itemprop="description" content=", 记录 “美食” 每刻"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="记录 “美食” 每刻"></span><div class="body md" itemprop="articleBody"><h1 id="11-集合"><a href="#11-集合" class="headerlink" title="11 集合"></a>11 集合</h1><img data-src="/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618180112196.png"> <img data-src="/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618170703735.png"><h1 id="Colletion接口"><a href="#Colletion接口" class="headerlink" title="Colletion接口"></a>Colletion接口</h1><h2 id="1-1-常用方法"><a href="#1-1-常用方法" class="headerlink" title="1.1 常用方法"></a>1.1 常用方法</h2><pre><code class="java">package com.msb.test01;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.List;
/**
 * @author : msb-zhaoss
 */
public class Test01 &#123;
    //这是main方法，程序的入口
    public static void main(String[] args) &#123;
        /*
        Collection接口的常用方法：
        增加：add(E e) addAll(Collection&lt;? extends E&gt; c)
        删除：clear() remove(Object o)
        修改：
        查看：iterator() size()
        判断：contains(Object o)  equals(Object o) isEmpty()
         */
        //创建对象：接口不能创建对象，利用实现类创建对象：
        Collection col = new ArrayList();
        //调用方法：
        //集合有一个特点：只能存放引用数据类型的数据，不能是基本数据类型
        //基本数据类型自动装箱，对应包装类。int---&gt;Integer
        col.add(18);
        col.add(12);
        col.add(11);
        col.add(17);
        System.out.println(col/*.toString()*/);
        List list = Arrays.asList(new Integer[]&#123;11, 15, 3, 7, 1&#125;);
        col.addAll(list);//将另一个集合添加入col中
        System.out.println(col);
        //col.clear();清空集合
        System.out.println(col);
        System.out.println(&quot;集合中元素的数量为：&quot;+col.size());
        System.out.println(&quot;集合是否为空：&quot;+col.isEmpty());
        boolean isRemove = col.remove(15);
        System.out.println(col);
        System.out.println(&quot;集合中数据是否被删除：&quot;+isRemove);
        Collection col2 = new ArrayList();
        col2.add(18);
        col2.add(12);
        col2.add(11);
        col2.add(17);
        Collection col3 = new ArrayList();
        col3.add(18);
        col3.add(12);
        col3.add(11);
        col3.add(17);
        System.out.println(col2.equals(col3));
        System.out.println(col2==col3);//地址一定不相等  false
        System.out.println(&quot;是否包含元素：&quot;+col3.contains(117));
    &#125;
&#125;
</code></pre><h2 id="1-2-Collection集合的遍历"><a href="#1-2-Collection集合的遍历" class="headerlink" title="1.2 Collection集合的遍历"></a>1.2 Collection集合的遍历</h2><pre><code class="java">迭代器简要原理图：



package com.msb.test01;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;
/**
 * @author : msb-zhaoss
 */
public class Test02 &#123;
    //这是main方法，程序的入口
    public static void main(String[] args) &#123;
        Collection col = new ArrayList();
        col.add(18);
        col.add(12);
        col.add(11);
        col.add(17);
        col.add(&quot;abc&quot;);
        col.add(9.8);
        //对集合遍历（对集合中元素进行查看）
        //方式1：普通for循环
        /*for(int i= 0;i&lt;col.size();i++)&#123;
            col.
        &#125;*/
        //方式2：增强for循环
        for(Object o:col)&#123;
            System.out.println(o);
        &#125;
        System.out.println(&quot;------------------------&quot;);
        //方式3：iterator()
        Iterator it = col.iterator();
        while(it.hasNext())&#123;
            System.out.println(it.next());
        &#125;
    &#125;
&#125;
</code></pre><h2 id="2-List接口"><a href="#2-List接口" class="headerlink" title="2 List接口"></a>2 List接口</h2><h3 id="2-1-常用方法和遍历方式"><a href="#2-1-常用方法和遍历方式" class="headerlink" title="2.1 常用方法和遍历方式"></a>2.1 常用方法和遍历方式</h3><pre><code class="java">package com.msb.test01;
import com.sun.org.apache.xerces.internal.dom.PSVIAttrNSImpl;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
/**
 * @author : msb-zhaoss
 */
public class Test03 &#123;
    //这是main方法，程序的入口
    public static void main(String[] args) &#123;
        /*
        List接口中常用方法：
        增加：add(int index, E element)
        删除：remove(int index)  remove(Object o)
        修改：set(int index, E element)
        查看：get(int index)
        判断：
         */
        List list = new ArrayList();
        list.add(13);
        list.add(17);
        list.add(6);
        list.add(-1);
        list.add(2);
        list.add(&quot;abc&quot;);
        System.out.println(list);
        list.add(3,66);
        System.out.println(list);
        list.set(3,77);
        System.out.println(list);
        list.remove(2);//在集合中存入的是Integer类型数据的时候，调用remove方法调用的是：remove(int index)
        System.out.println(list);
        list.remove(&quot;abc&quot;);
        System.out.println(list);
        Object o = list.get(0);
        System.out.println(o);
        //List集合 遍历：
        //方式1：普通for循环：
        System.out.println(&quot;---------------------&quot;);
        for(int i = 0;i&lt;list.size();i++)&#123;
            System.out.println(list.get(i));
        &#125;
        //方式2：增强for循环：
        System.out.println(&quot;---------------------&quot;);
        for(Object obj:list)&#123;
            System.out.println(obj);
        &#125;
        //方式3：迭代器：
        System.out.println(&quot;---------------------&quot;);
        Iterator it = list.iterator();
        while(it.hasNext())&#123;
            System.out.println(it.next());
        &#125;
    &#125;
&#125;
</code></pre><h3 id="2-2-ArrayList实现类（JDK1-7）"><a href="#2-2-ArrayList实现类（JDK1-7）" class="headerlink" title="2.2 ArrayList实现类（JDK1.7）"></a>2.2 ArrayList实现类（JDK1.7）</h3><p>底层重要属性：</p><img data-src="/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618172028655.png"><p>在JDK1.7中：在调用构造器的时候给底层数组elementData初始化，<font color="#FF0000">数组初始化长度为10</font>：</p><img data-src="/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618172107247.png"><p>对应内存：</p><img data-src="/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618172121579.png"><p>调用add方法：</p><pre><code class="java">         ArrayList al = new ArrayList();
        System.out.println(al.add(&quot;abc&quot;));
        System.out.println(al.add(&quot;def&quot;));
</code></pre><img data-src="/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618172152471.png"><p>当数组中的10个位置都满了的时候就开始进行数组的扩容，扩容长度为 <font color="#FF0000">原数组的1.5倍</font>：</p><img data-src="/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618172227199.png"> <img data-src="/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618172231517.png"> <img data-src="/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618172235705.png"><h3 id="2-3-ArrayList实现类（JDK1-8）"><a href="#2-3-ArrayList实现类（JDK1-8）" class="headerlink" title="2.3 ArrayList实现类（JDK1.8）"></a>2.3 ArrayList实现类（JDK1.8）</h3><p>【1】JDK1.8底层依旧是Object类型的数组，size:数组中有效长度：</p><img data-src="/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618172252320.png"><p>【2】ArrayList al &#x3D; new ArrayList();调用空构造器：</p><img data-src="/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618172303832.png"><p>【3】add方法：</p><img data-src="/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618172316929.png"> <img data-src="/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618172324585.png"> <img data-src="/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618172335841.png"> <img data-src="/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618172340839.png"><h3 id="2-4-Vector实现类"><a href="#2-4-Vector实现类" class="headerlink" title="2.4 Vector实现类"></a>2.4 Vector实现类</h3><p>【1】底层Object数组，int类型属性表示数组中有效长度：</p><img data-src="/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618172455343.png"><p>【2】Vector v&#x3D;new Vector();调用构造器：</p><p>【3】add方法：</p><img data-src="/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618172507015.png"><h3 id="2-5-泛型"><a href="#2-5-泛型" class="headerlink" title="2.5 泛型"></a>2.5 泛型</h3><p>【1】什么是泛型（Generic）：<br>泛型就相当于标签<br>形式：&lt;&gt;<br>集合容器类在设计阶段&#x2F;声明阶段不能确定这个容器到底实际存的是什么类型的对象，所以在JDK1.5之前只能把元素类型设计为Object，<br>JDK1.5之 后使用泛型来解决。因为这个时候除了元素的类型不确定，其他的部分是确定的，例如关于这个元素如何保存，如何管理等是确定的，因此此时把元素的类型设计成一个参数，这个类型参数叫做泛型。<br>Collection<e>, List<e>， ArrayList<e>这个<e>就是类型参数，即泛型。</e></e></e></e></p><p>【2】没有泛型的时候使用集合：</p><pre><code class="java">package com.msb.test01;
import java.util.ArrayList;
/**
 * @author : msb-zhaoss
 */
public class Test01 &#123;
    //这是main方法，程序的入口
    public static void main(String[] args) &#123;
        //创建一个ArrayList集合，向这个集合中存入学生的成绩：
        ArrayList al = new ArrayList();
        al.add(98);
        al.add(18);
        al.add(39);
        al.add(60);
        al.add(83);
        al.add(&quot;丽丽&quot;);
        //对集合遍历查看：
        for(Object obj:al)&#123;
            System.out.println(obj);
        &#125;
    &#125;
&#125;
</code></pre><p>如果不使用泛型的话，有缺点：<br>一般我们在使用的时候基本上往集合中存入的都是相同类型的数据–》便于管理，所以现在什么引用数据类型都可以存入集合，不方便！</p><p>【3】JDK1.5以后开始使用泛型，集合中使用泛型：</p><pre><code class="java">package com.msb.test01;
import java.util.ArrayList;
/**
 * @author : msb-zhaoss
 */
public class Test01 &#123;
    //这是main方法，程序的入口
    public static void main(String[] args) &#123;
        //创建一个ArrayList集合，向这个集合中存入学生的成绩：
        //加入泛型的优点：在编译时期就会对类型进行检查，不是泛型对应的类型就不可以添加入这个集合。
        ArrayList&lt;Integer&gt; al = new ArrayList&lt;Integer&gt;();
        al.add(98);
        al.add(18);
        al.add(39);
        al.add(60);
        al.add(83);
        /*al.add(&quot;丽丽&quot;);
        al.add(9.8);*/
        //对集合遍历查看：
        /*for(Object obj:al)&#123;
            System.out.println(obj);
        &#125;*/
        for(Integer i:al)&#123;
            System.out.println(i);
        &#125;
    &#125;
&#125;
</code></pre><p>【4】泛型总结：<br>（1）JDK1.5以后<br>（2）泛型实际就是 一个&lt;&gt;引起来的 参数类型，这个参数类型 具体在使用的时候才会确定具体的类型。</p><img data-src="/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618172646571.png"><p>（3）使用了泛型以后，可以确定集合中存放数据的类型，在编译时期就可以检查出来。<br>（4）使用泛型你可能觉得麻烦，实际使用了泛型才会简单，后续的遍历等操作简单。<br>（5）泛型的类型：都是引用数据类型，不能是基本数据类型。<br>（6）ArrayList<integer>al &#x3D; new ArrayList<integer>();在JDK1.7以后可以写为：<br>ArrayList<integer>al &#x3D; new ArrayList&lt;&gt;(); –&lt;&gt; —钻石运算符</integer></integer></integer></p><h4 id="2-5-1-自定义泛型结构"><a href="#2-5-1-自定义泛型结构" class="headerlink" title="2.5.1 自定义泛型结构"></a>2.5.1 自定义泛型结构</h4><p>泛型类，泛型接口</p><p>【1】泛型类的定义和实例化：</p><pre><code class="java">package com.msb.test02;
/**
 * @author : msb-zhaoss
 * GenericTes就是一个普通的类
 * GenericTest&lt;E&gt; 就是一个泛型类
 * &lt;&gt;里面就是一个参数类型，但是这个类型是什么呢？这个类型现在是不确定的，相当于一个占位
 * 但是现在确定的是这个类型一定是一个引用数据类型，而不是基本数据类型
 */
public class GenericTest&lt;E&gt; &#123;
    int age;
    String name;
    E sex;
    public void a(E n)&#123;
    &#125;
    public void b(E[] m)&#123;
    &#125;
&#125;
class Test&#123;
    //这是main方法，程序的入口
    public static void main(String[] args) &#123;
        //GenericTest进行实例化：
        //(1)实例化的时候不指定泛型：如果实例化的时候不明确的指定类的泛型，那么认为此泛型为Object类型
        GenericTest gt1 = new GenericTest();
        gt1.a(&quot;abc&quot;);
        gt1.a(17);
        gt1.a(9.8);
        gt1.b(new String[]&#123;&quot;a&quot;,&quot;b&quot;,&quot;c&quot;&#125;);
        //（2）实例化的时候指定泛型：---》推荐方式
        GenericTest&lt;String&gt; gt2 = new GenericTest&lt;&gt;();
        gt2.sex = &quot;男&quot;;
        gt2.a(&quot;abc&quot;);
        gt2.b(new String[]&#123;&quot;a&quot;,&quot;b&quot;,&quot;c&quot;&#125;);
        
    &#125;
&#125;
</code></pre><p>【2】继承情况：<br>（1）父类指定泛型：</p><pre><code class="java">class SubGenericTest extends GenericTest&lt;Integer&gt;&#123;
&#125;
class Demo&#123;
    //这是main方法，程序的入口
    public static void main(String[] args) &#123;
        //指定父类泛型，那么子类就不需要再指定泛型了，可以直接使用
        SubGenericTest sgt = new SubGenericTest();
        sgt.a(19);
    &#125;
&#125;
</code></pre><p>（2）父类不指定泛型：<br>如果父类不指定泛型，那么子类也会变成一个泛型类，那这个E的类型可以在创建子类对象的时候确定：</p><pre><code class="java">class SubGenericTest2&lt;E&gt; extends GenericTest&lt;E&gt;&#123;
&#125;

class Demo2&#123;
    //这是main方法，程序的入口
    public static void main(String[] args) &#123;
        SubGenericTest2&lt;String&gt; s = new  SubGenericTest2&lt;&gt;();
        s.a(&quot;abc&quot;);
        s.sex = &quot;女&quot;;
    &#125;
&#125;
</code></pre><p>【3】应用场合：</p><img data-src="/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618173037582.png"><p>【4】细节：<br>（1）泛型类可以定义多个参数类型</p><img data-src="/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618173045431.png"><p>（2）泛型类的构造器的写法：</p><img data-src="/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618173057556.png"><p>（3）不同的泛型的引用类型不可以相互赋值：</p><img data-src="/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618173104251.png"><p>（4）泛型如果不指定，那么就会被擦除，反应对应的类型为Object类型：</p><img data-src="/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618173116539.png"><p>（5）反省类中的静态方法不能使用类的泛型：</p><img data-src="/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618173123924.png"><p>（6）不能直接使用E[]的创建：</p><img data-src="/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618173130213.png"><h4 id="2-5-2-泛型方法"><a href="#2-5-2-泛型方法" class="headerlink" title="2.5.2 泛型方法"></a>2.5.2 泛型方法</h4><pre><code class="java">package com.msb.test04;
/**
 * @author : msb-zhaoss
 * 1.什么是泛型方法：
 * 不是带泛型的方法就是泛型方法
 * 泛型方法有要求：这个方法的泛型的参数类型要和当前的类的泛型无关
 * 换个角度：
 * 泛型方法对应的那个泛型参数类型 和  当前所在的这个类 是否是泛型类，泛型是啥  无关
 * 2.泛型方法定义的时候，前面要加上&lt;T&gt;
 *     原因：如果不加的话，会把T当做一种数据类型，然而代码中没有T类型那么就会报错
 * 3.T的类型是在调用方法的时候确定的
 * 4.泛型方法可否是静态方法？可以是静态方法
 */
public class TestGeneric&lt;E&gt; &#123;
    //不是泛型方法 （不能是静态方法）
    public static void a(E e)&#123;
    &#125;
    //是泛型方法
    public static &lt;T&gt;  void b(T t)&#123;
    &#125;
&#125;
class Demo&#123;
    //这是main方法，程序的入口
    public static void main(String[] args) &#123;
        TestGeneric&lt;String&gt; tg = new TestGeneric&lt;&gt;();
        tg.a(&quot;abc&quot;);
        tg.b(&quot;abc&quot;);
        tg.b(19);
        tg.b(true);
    &#125;
&#125;
</code></pre><h4 id="2-5-3-泛型参数存在继承关系的情况"><a href="#2-5-3-泛型参数存在继承关系的情况" class="headerlink" title="2.5.3 泛型参数存在继承关系的情况"></a>2.5.3 泛型参数存在继承关系的情况</h4><img data-src="/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618173213265.png"><h4 id="2-5-4-通配符"><a href="#2-5-4-通配符" class="headerlink" title="2.5.4 通配符"></a>2.5.4 通配符</h4><p>【1】在没有通配符的时候：<br>下面的a方法，相当于方法的重复定义，报错</p><pre><code class="java">public class Test &#123;
    /*public void a(List&lt;Object&gt; list)&#123;
    &#125;
    public void a(List&lt;String&gt; list)&#123;
    &#125;
    public void a(List&lt;Integer&gt; list)&#123;
    &#125;*/
&#125;
</code></pre><p>【2】引入通配符：</p><pre><code class="java">public class Demo &#123;
    //这是main方法，程序的入口
    public static void main(String[] args) &#123;
        List&lt;Object&gt; list1 = new ArrayList&lt;&gt;();
        List&lt;String&gt; list2 = new ArrayList&lt;&gt;();
        List&lt;Integer&gt; list3 = new ArrayList&lt;&gt;();
        List&lt;?&gt; list = null;
        list = list1;
        list = list2;
        list = list3;
    &#125;
&#125;
</code></pre><p>发现： A 和 B是子类父类的关系，G<a>和G<b>不存在子类父类关系，是并列的<br>加入通配符？后，G&lt;?&gt;就变成了 G<a>和G<b>的父类</b></a></b></a></p><p>【3】使用通配符：</p><pre><code class="java">package com.msb.test06;
import java.util.ArrayList;
import java.util.List;
/**
 * @author : msb-zhaoss
 */
public class Test &#123;
    /*public void a(List&lt;Object&gt; list)&#123;
    &#125;
    public void a(List&lt;String&gt; list)&#123;
    &#125;
    public void a(List&lt;Integer&gt; list)&#123;
    &#125;*/
    public void a(List&lt;?&gt; list)&#123;
        //内部遍历的时候用Object即可，不用？
        for(Object a:list)&#123;
            System.out.println(a);
        &#125;
    &#125;
&#125;
class T&#123;
    //这是main方法，程序的入口
    public static void main(String[] args) &#123;
        Test t = new Test();
        t.a(new ArrayList&lt;Integer&gt;());
        t.a(new ArrayList&lt;String&gt;());
        t.a(new ArrayList&lt;Object&gt;());
    &#125;
&#125;
</code></pre><p>【4】查看API中应用位置：</p><img data-src="/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618173333503.png"><h4 id="2-5-5-使用通配符后的细节"><a href="#2-5-5-使用通配符后的细节" class="headerlink" title="2.5.5 使用通配符后的细节"></a>2.5.5 使用通配符后的细节</h4><pre><code class="java">public class Test &#123;
    public void a(List&lt;?&gt; list)&#123;
        //1.遍历：
        for(Object a:list)&#123;
            System.out.println(a);
        &#125;
        //2.数据的写入操作 ：
        //list.add(&quot;abc&quot;);--&gt;出错，不能随意的添加数据
        list.add(null);
        //3.数据的读取操作：
        Object s = list.get(0);
    &#125;
&#125;
class T&#123;
    //这是main方法，程序的入口
    public static void main(String[] args) &#123;
        Test t = new Test();
        t.a(new ArrayList&lt;Integer&gt;());
        t.a(new ArrayList&lt;String&gt;());
        t.a(new ArrayList&lt;Object&gt;());
    &#125;
&#125;
</code></pre><h4 id="2-5-6-泛型受限"><a href="#2-5-6-泛型受限" class="headerlink" title="2.5.6 泛型受限"></a>2.5.6 泛型受限</h4><pre><code class="java">package com.msb.test07;
import java.util.ArrayList;
import java.util.List;

public class Test &#123;
    //这是main方法，程序的入口
    public static void main(String[] args) &#123;
        //a,b,c三个集合是并列的关系：
        List&lt;Object&gt; a = new ArrayList&lt;&gt;();
        List&lt;Person&gt; b = new ArrayList&lt;&gt;();
        List&lt;Student&gt; c = new ArrayList&lt;&gt;();
        /*开始使用泛型受限：泛型的上限
        List&lt;? extends Person&gt;:
        就相当于：
        List&lt;? extends Person&gt;是List&lt;Person&gt;的父类，是List&lt;Person的子类&gt;的父类
         */
        List&lt;? extends Person&gt; list1 = null;
        /*list1 = a;
        list1 = b;
        list1 = c;*/
        /*开始使用泛型受限：泛型的下限
        List&lt;? super Person&gt;
        就相当于：
        List&lt;? super Person&gt;是List&lt;Person&gt;的父类，是List&lt;Person的父类&gt;的父类
         */
        List&lt;? super Person&gt; list2 = null;
        list2 = a;
        list2 = b;
        list3 = c;
    &#125;
&#125;
</code></pre><h3 id="2-6-LinkedList实现类"><a href="#2-6-LinkedList实现类" class="headerlink" title="2.6 LinkedList实现类"></a>2.6 LinkedList实现类</h3><h4 id="2-6-1-基本方法使用"><a href="#2-6-1-基本方法使用" class="headerlink" title="2.6.1 基本方法使用"></a>2.6.1 基本方法使用</h4><pre><code class="java">package com.msb.test04;
import java.util.Iterator;
import java.util.LinkedList;
/**
 * @author : msb-zhaoss
 */
public class Test &#123;
    //这是main方法，程序的入口
    public static void main(String[] args) &#123;
        /*
        LinkedList常用方法：
        增加 addFirst(E e) addLast(E e)
             offer(E e) offerFirst(E e) offerLast(E e)
        删除 poll()
            pollFirst() pollLast()  ---》JDK1.6以后新出的方法，提高了代码的健壮性
            removeFirst() removeLast()
        修改
        查看 element()
             getFirst()  getLast()
             indexOf(Object o)   lastIndexOf(Object o)
             peek()
             peekFirst() peekLast()
        判断
         */
        //创建一个LinkedList集合对象：
        LinkedList&lt;String&gt; list = new LinkedList&lt;&gt;();
        list.add(&quot;aaaaa&quot;);
        list.add(&quot;bbbbb&quot;);
        list.add(&quot;ccccc&quot;);
        list.add(&quot;ddddd&quot;);
        list.add(&quot;eeeee&quot;);
        list.add(&quot;bbbbb&quot;);
        list.add(&quot;fffff&quot;);
        list.addFirst(&quot;jj&quot;);
        list.addLast(&quot;hh&quot;);
        list.offer(&quot;kk&quot;);//添加元素在尾端
        list.offerFirst(&quot;pp&quot;);
        list.offerLast(&quot;rr&quot;);
        System.out.println(list);//LinkedList可以添加重复数据
        System.out.println(list.poll());//删除头上的元素并且将元素输出
        System.out.println(list.pollFirst());
        System.out.println(list.pollLast());
        System.out.println(list.removeFirst());
        System.out.println(list.removeLast());
        System.out.println(list);//LinkedList可以添加重复数据
        /*list.clear();//清空集合
        System.out.println(list);*/
        /*System.out.println(list.pollFirst());*/
        /*System.out.println(list.removeFirst());报错：Exception in thread &quot;main&quot; java.util.NoSuchElementException*/
        //集合的遍历：
        System.out.println(&quot;---------------------&quot;);
        //普通for循环：
        for(int i = 0;i&lt;list.size();i++)&#123;
            System.out.println(list.get(i));
        &#125;
        System.out.println(&quot;---------------------&quot;);
        //增强for：
        for(String s:list)&#123;
            System.out.println(s);
        &#125;
        System.out.println(&quot;---------------------&quot;);
        //迭代器：
        /*Iterator&lt;String&gt; it = list.iterator();
        while(it.hasNext())&#123;
            System.out.println(it.next());
        &#125;*/
        //下面这种方式好，节省内存
        for(Iterator&lt;String&gt; it = list.iterator();it.hasNext();)&#123;
            System.out.println(it.next());
        &#125;
    &#125;
&#125;
</code></pre><h4 id="2-6-2-简要底层原理图"><a href="#2-6-2-简要底层原理图" class="headerlink" title="2.6.2 简要底层原理图"></a>2.6.2 简要底层原理图</h4><img data-src="/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618173515599.png"><h4 id="2-6-3-模拟LinkedList源码"><a href="#2-6-3-模拟LinkedList源码" class="headerlink" title="2.6.3 模拟LinkedList源码"></a>2.6.3 模拟LinkedList源码</h4><pre><code class="java">package com.msb.test05;
/**
 * @author : msb-zhaoss
 */
public class MyLinkedList &#123;
    //链中一定有一个首节点：
    Node first;
    //链中一定有一个尾节点：
    Node last;
    //计数器：
    int count = 0;
    //提供一个构造器：
    public MyLinkedList()&#123;
    &#125;
    //添加元素方法：
    public void add(Object o)&#123;
        if(first == null)&#123;//证明你添加的元素是第一个节点：
            //将添加的元素封装为一个Node对象：
            Node n = new Node();
            n.setPre(null);
            n.setObj(o);
            n.setNext(null);
            //当前链中第一个节点变为n
            first = n;
            //当前链中最后一个节点变为n
            last = n;
        &#125;else&#123;//证明已经不是链中第一个节点了
            //将添加的元素封装为一个Node对象：
            Node n = new Node();
            n.setPre(last);//n的上一个节点一定是当前链中的最后一个节点last
            n.setObj(o);
            n.setNext(null);
            //当前链中的最后一个节点的下一个元素 要指向n
            last.setNext(n);
            //将最后一个节点变为n
            last = n;
        &#125;
        //链中元素数量加1
        count++;
    &#125;
    //得到集合中元素的数量：
    public int getSize()&#123;
        return count;
    &#125;
    //通过下标得到元素：
    public Object get(int index)&#123;
        //获取链表的头元素：
        Node n = first;
        //一路next得到想要的元素
        for(int i=0;i&lt;index;i++)&#123;
            n = n.getNext();
        &#125;
        return n.getObj();
    &#125;
&#125;
class Test&#123;
    //这是main方法，程序的入口
    public static void main(String[] args) &#123;
        //创建一个MyLinkedList集合对象：
        MyLinkedList ml = new MyLinkedList();
        ml.add(&quot;aa&quot;);
        ml.add(&quot;bb&quot;);
        ml.add(&quot;cc&quot;);
        System.out.println(ml.getSize());
        System.out.println(ml.get(0));
    &#125;
&#125;
</code></pre><h4 id="2-6-4-LinkedList源码解析"><a href="#2-6-4-LinkedList源码解析" class="headerlink" title="2.6.4 LinkedList源码解析"></a>2.6.4 LinkedList源码解析</h4><p>【1】JDK1.7和JDK1.8的LinkedList的源码是一致的<br>【2】源码：</p><pre><code class="java">public class LinkedList&lt;E&gt;&#123;//E是一个泛型，具体的类型要在实例化的时候才会最终确定
        transient int size = 0;//集合中元素的数量
        //Node的内部类
        private static class Node&lt;E&gt; &#123;
        E item;//当前元素
        Node&lt;E&gt; next;//指向下一个元素地址
        Node&lt;E&gt; prev;//上一个元素地址
        Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;
            this.item = element;
            this.next = next;
            this.prev = prev;
        &#125;
    &#125;
        transient Node&lt;E&gt; first;//链表的首节点
        transient Node&lt;E&gt; last;//链表的尾节点
        //空构造器：
        public LinkedList() &#123;
    &#125;
        //添加元素操作：
        public boolean add(E e) &#123;
        linkLast(e);
        return true;
    &#125;
        void linkLast(E e) &#123;//添加的元素e
        final Node&lt;E&gt; l = last;//将链表中的last节点给l 如果是第一个元素的话 l为null
                //将元素封装为一个Node具体的对象：
        final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null);
                //将链表的last节点指向新的创建的对象：
        last = newNode;
                
        if (l == null)//如果添加的是第一个节点
            first = newNode;//将链表的first节点指向为新节点
        else//如果添加的不是第一个节点 
            l.next = newNode;//将l的下一个指向为新的节点
        size++;//集合中元素数量加1操作
        modCount++;
    &#125;
        //获取集合中元素数量
        public int size() &#123;
        return size;
    &#125;
        //通过索引得到元素：
        public E get(int index) &#123;
        checkElementIndex(index);//健壮性考虑
        return node(index).item;
    &#125;
        
    Node&lt;E&gt; node(int index) &#123;
        //如果index在链表的前半段，那么从前往后找
        if (index &lt; (size &gt;&gt; 1)) &#123;
            Node&lt;E&gt; x = first;
            for (int i = 0; i &lt; index; i++)
                x = x.next;
            return x;
        &#125; else &#123;//如果index在链表的后半段，那么从后往前找
            Node&lt;E&gt; x = last;
            for (int i = size - 1; i &gt; index; i--)
                x = x.prev;
            return x;
        &#125;
    &#125;
&#125;
</code></pre><h3 id="面试题："><a href="#面试题：" class="headerlink" title="面试题："></a>面试题：</h3><blockquote><p>iterator(),Iterator,Iterable关系</p></blockquote><p>【1】面试题：对应的关系：</p><img data-src="/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618173707713.png"><p>【2】hasNext(),next()的具体实现：</p><img data-src="/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618173654976.png"><p>ListIterator迭代器</p><p>【1】加入字符串：</p><pre><code class="java">package com.msb.test06;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
/**
 * @author : msb-zhaoss
 */
public class Test2 &#123;
    //这是main方法，程序的入口
    public static void main(String[] args) &#123;
        ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();
        list.add(&quot;aa&quot;);
        list.add(&quot;bb&quot;);
        list.add(&quot;cc&quot;);
        list.add(&quot;dd&quot;);
        list.add(&quot;ee&quot;);
        //在&quot;cc&quot;之后添加一个字符串&quot;kk&quot;
        Iterator&lt;String&gt; it = list.iterator();
        while(it.hasNext())&#123;
            if(&quot;cc&quot;.equals(it.next()))&#123;
                list.add(&quot;kk&quot;);
            &#125;
        &#125;
    &#125;
&#125;
</code></pre><p>发现报错：</p><img data-src="/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618173818117.png"><p>出错原因：就是迭代器和list同时对集合进行操作：</p><img data-src="/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618173826503.png"><p>解决办法：事情让一个“人”做 –》引入新的迭代器：ListIterator<br>迭代和添加操作都是靠ListIterator来完成的：</p><pre><code class="java">package com.msb.test06;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.ListIterator;
/**
 * @author : msb-zhaoss
 */
public class Test2 &#123;
    //这是main方法，程序的入口
    public static void main(String[] args) &#123;
        ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();
        list.add(&quot;aa&quot;);
        list.add(&quot;bb&quot;);
        list.add(&quot;cc&quot;);
        list.add(&quot;dd&quot;);
        list.add(&quot;ee&quot;);
        //在&quot;cc&quot;之后添加一个字符串&quot;kk&quot;
        ListIterator&lt;String&gt; it = list.listIterator();
        while(it.hasNext())&#123;
            if(&quot;cc&quot;.equals(it.next()))&#123;
                it.add(&quot;kk&quot;);
            &#125;
        &#125;
        System.out.println(it.hasNext());
        System.out.println(it.hasPrevious());
        //逆向遍历：
        while(it.hasPrevious())&#123;
            System.out.println(it.previous());
        &#125;
        System.out.println(it.hasNext());
        System.out.println(it.hasPrevious());
        System.out.println(list);
    &#125;
&#125;
</code></pre><h2 id="3-Set接口"><a href="#3-Set接口" class="headerlink" title="3 Set接口"></a>3 Set接口</h2><h3 id="3-1-HashSet实现类的使用"><a href="#3-1-HashSet实现类的使用" class="headerlink" title="3.1 HashSet实现类的使用"></a>3.1 HashSet实现类的使用</h3><p>【1】放入Integer类型数据：</p><pre><code class="java">package com.msb.test07;
import java.util.HashSet;
/**
 * @author : msb-zhaoss
 */
public class TestInteger &#123;
    //这是main方法，程序的入口
    public static void main(String[] args) &#123;
        //创建一个HashSet集合：
        HashSet&lt;Integer&gt; hs = new HashSet&lt;&gt;();
        System.out.println(hs.add(19));//true
        hs.add(5);
        hs.add(20);
        System.out.println(hs.add(19));//false 这个19没有放入到集合中
        hs.add(41);
        hs.add(0);
        System.out.println(hs.size());//唯一，无序
        System.out.println(hs);
    &#125;
&#125;
</code></pre><p>【2】放入String类型数据：</p><pre><code class="java">package com.msb.test07;
import java.util.HashSet;
/**
 * @author : msb-zhaoss
 */
public class TestString &#123;
    //这是main方法，程序的入口
    public static void main(String[] args) &#123;
        //创建一个HashSet集合：
        HashSet&lt;String&gt; hs = new HashSet&lt;&gt;();
        hs.add(&quot;hello&quot;);
        hs.add(&quot;apple&quot;);
        hs.add(&quot;banana&quot;);
        hs.add(&quot;html&quot;);
        hs.add(&quot;apple&quot;);
        hs.add(&quot;css&quot;);
        System.out.println(hs.size());
        System.out.println(hs);
    &#125;
&#125;
</code></pre><p>【3】放入自定义的引用数据类型的数据：</p><pre><code class="java">package com.msb.test07;
import java.util.HashSet;
/**
 * @author : msb-zhaoss
 */
public class TestStudent &#123;
    //这是main方法，程序的入口
    public static void main(String[] args) &#123;
        //创建一个HashSet集合：
        HashSet&lt;Student&gt; hs = new HashSet&lt;&gt;();
        hs.add(new Student(19,&quot;lili&quot;));
        hs.add(new Student(20,&quot;lulu&quot;));
        hs.add(new Student(18,&quot;feifei&quot;));
        hs.add(new Student(19,&quot;lili&quot;));
        hs.add(new Student(10,&quot;nana&quot;));
        System.out.println(hs.size());
        System.out.println(hs);
    &#125;
&#125;
</code></pre><p>上面自定义的类型不满足 唯一，无序的特点。为什么呢？</p><p>【4】HashSet原理图：（简要原理图）</p><img data-src="/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618173954231.png"><p>【5】疑问：<br>1.数组的长度是多少。<br>2.数组的类型是什么？<br>3.hashCode，equals方法真的调用了吗？验证<br>4.底层表达式是什么？<br>5.同一个位置的数据 向前放 还是 向后放？<br>6.放入数组中的数据，是直接放的吗？是否封装为对象了？</p><h3 id="3-2LinkedHashSet使用"><a href="#3-2LinkedHashSet使用" class="headerlink" title="3.2LinkedHashSet使用"></a>3.2LinkedHashSet使用</h3><p>其实就是在HashSet的基础上，多了一个总的链表，这个总链表将放入的元素串在一起，方便有序的遍历：<br>（可以看到LinkedHashMap.Entry 继承自HashMap.Node 除了Node 本身有的几个属性外，额外增加了before after 用于指向前一个Entry 后一个Entry。也就是说，元素之间维持着一条总的链表数据结构。）</p><img data-src="/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618174059591.png"><pre><code class="java">package com.msb.test07;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
/**
 * @author : msb-zhaoss
 */
public class TestInteger &#123;
    //这是main方法，程序的入口
    public static void main(String[] args) &#123;
        //创建一个HashSet集合：
        LinkedHashSet&lt;Integer&gt; hs = new LinkedHashSet&lt;&gt;();
        System.out.println(hs.add(19));//true
        hs.add(5);
        hs.add(20);
        System.out.println(hs.add(19));//false 这个19没有放入到集合中
        hs.add(41);
        hs.add(0);
        System.out.println(hs.size());//唯一，无序
        System.out.println(hs);
    &#125;
&#125;
</code></pre><h3 id="3-3-比较器的使用"><a href="#3-3-比较器的使用" class="headerlink" title="3.3 比较器的使用"></a>3.3 比较器的使用</h3><p>【1】以int类型为案例：<br>比较的思路：将比较的数据做差，然后返回一个int类型的数据，将这个int类型的数值 按照 &#x3D;0 &gt;0 &lt;0</p><pre><code class="java">          int a = 10;
        int b = 20;
        System.out.println(a-b); // =0  &gt;0  &lt;0
</code></pre><p>【2】比较String类型数据：<br>String类实现了Comparable接口，这个接口中有一个抽象方法compareTo，String类中重写这个方法即可</p><pre><code class="java">          String a = &quot;A&quot;;
        String b = &quot;B&quot;;
        System.out.println(a.compareTo(b));
</code></pre><p>【3】比较double类型数据：</p><pre><code class="java">         double a = 9.6;
        double b = 9.3;
       /* System.out.println((int)(a-b));*/
        System.out.println(((Double) a).compareTo((Double) b));
</code></pre><p>【4】比较自定义的数据类型：<br>（1）内部比较器：</p><pre><code class="java">public class Student implements Comparable&lt;Student&gt;&#123;
    private int age;
    private double height;
    private String name;
    public int getAge() &#123;
        return age;
    &#125;
    public void setAge(int age) &#123;
        this.age = age;
    &#125;
    public double getHeight() &#123;
        return height;
    &#125;
    public void setHeight(double height) &#123;
        this.height = height;
    &#125;
    public String getName() &#123;
        return name;
    &#125;
    public void setName(String name) &#123;
        this.name = name;
    &#125;
    public Student(int age, double height, String name) &#123;
        this.age = age;
        this.height = height;
        this.name = name;
    &#125;
    @Override
    public String toString() &#123;
        return &quot;Student&#123;&quot; +
                &quot;age=&quot; + age +
                &quot;, height=&quot; + height +
                &quot;, name=&#39;&quot; + name + &#39;\&#39;&#39; +
                &#39;&#125;&#39;;
    &#125;
    @Override
    public int compareTo(Student o) &#123;
        //按照年龄进行比较：
        /*return this.getAge() - o.getAge();*/
        //按照身高比较
        /*return ((Double)(this.getHeight())).compareTo((Double)(o.getHeight()));*/
        //按照名字比较：
        return this.getName().compareTo(o.getName());
    &#125;
&#125;
</code></pre><pre><code class="java">public class Test02 &#123;
    //这是main方法，程序的入口
    public static void main(String[] args) &#123;
        //比较两个学生：
        Student s1 = new Student(14,160.5,&quot;alili&quot;);
        Student s2 = new Student(14,170.5,&quot;bnana&quot;);
        System.out.println(s1.compareTo(s2));
    &#125;
&#125;
</code></pre><p>（2）外部比较器：</p><pre><code class="java">public class Student&#123;
    private int age;
    private double height;
    private String name;
    public int getAge() &#123;
        return age;
    &#125;
    public void setAge(int age) &#123;
        this.age = age;
    &#125;
    public double getHeight() &#123;
        return height;
    &#125;
    public void setHeight(double height) &#123;
        this.height = height;
    &#125;
    public String getName() &#123;
        return name;
    &#125;
    public void setName(String name) &#123;
        this.name = name;
    &#125;
    public Student(int age, double height, String name) &#123;
        this.age = age;
        this.height = height;
        this.name = name;
    &#125;
    @Override
    public String toString() &#123;
        return &quot;Student&#123;&quot; +
                &quot;age=&quot; + age +
                &quot;, height=&quot; + height +
                &quot;, name=&#39;&quot; + name + &#39;\&#39;&#39; +
                &#39;&#125;&#39;;
    &#125;
&#125;
class BiJiao01 implements Comparator&lt;Student&gt; &#123;
    @Override
    public int compare(Student o1, Student o2) &#123;
        //比较年龄：
        return o1.getAge()-o2.getAge();
    &#125;
&#125;
class BiJiao02 implements Comparator&lt;Student&gt; &#123;
    @Override
    public int compare(Student o1, Student o2) &#123;
        //比较姓名：
        return o1.getName().compareTo(o2.getName());
    &#125;
&#125;
</code></pre><pre><code class="java">class BiJiao03 implements Comparator&lt;Student&gt; &#123;
    @Override
    public int compare(Student o1, Student o2) &#123;
        //在年龄相同的情况下 比较身高  年龄不同比较年龄
        if((o1.getAge()-o2.getAge())==0)&#123;
            return ((Double)(o1.getHeight())).compareTo((Double)(o2.getHeight()));
        &#125;else&#123;//年龄不一样
            return o1.getAge()-o2.getAge();
        &#125;
    &#125;
&#125;
</code></pre><pre><code class="java">public class Test02 &#123;
    //这是main方法，程序的入口
    public static void main(String[] args) &#123;
        //比较两个学生：
        Student s1 = new Student(9,160.5,&quot;alili&quot;);
        Student s2 = new Student(14,170.5,&quot;bnana&quot;);
        //获取外部比较器：
        Comparator bj1 = new BiJiao03();
        System.out.println(bj1.compare(s1, s2));
    &#125;
&#125;
</code></pre><p>【5】外部比较器和内部比较器 谁好呀？<br>答案：外部比较器，多态，扩展性好</p><h3 id="3-4-TreeSet实现类的使用"><a href="#3-4-TreeSet实现类的使用" class="headerlink" title="3.4 TreeSet实现类的使用"></a>3.4 TreeSet实现类的使用</h3><p>【1】存入Integer类型数据：（底层利用的是内部比较器）</p><pre><code class="java">package com.msb.test10;
import java.util.TreeSet;
/**
 * @author : msb-zhaoss
 */
public class Test01 &#123;
    //这是main方法，程序的入口
    public static void main(String[] args) &#123;
        //创建一个TreeSet:
        TreeSet&lt;Integer&gt; ts = new TreeSet&lt;&gt;();
        ts.add(12);
        ts.add(3);
        ts.add(7);
        ts.add(9);
        ts.add(3);
        ts.add(16);
        System.out.println(ts.size());
        System.out.println(ts);
    &#125;
&#125;
</code></pre><p>特点：唯一，无序（没有按照输入顺序进行输出）， 有序（按照升序进行遍历）</p><p>【2】原理：底层：二叉树（数据结构中的一个逻辑结构）</p><img data-src="/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618174503614.png"><p>【3】放入String类型数据：（底层实现类内部比较器）</p><pre><code class="java">public class Test02 &#123;
    //这是main方法，程序的入口
    public static void main(String[] args) &#123;
        //创建一个TreeSet:
        TreeSet&lt;String&gt; ts = new TreeSet&lt;&gt;();
        ts.add(&quot;elili&quot;);
        ts.add(&quot;blili&quot;);
        ts.add(&quot;alili&quot;);
        ts.add(&quot;elili&quot;);
        ts.add(&quot;clili&quot;);
        ts.add(&quot;flili&quot;);
        ts.add(&quot;glili&quot;);
        System.out.println(ts.size());
        System.out.println(ts);
    &#125;
&#125;
</code></pre><p>【4】想放入自定义的Student类型的数据：<br>（1）利用内部比较器：</p><pre><code class="java">public class Student implements Comparable&lt;Student&gt; &#123;
    private int age;
    private String name;
    public int getAge() &#123;
        return age;
    &#125;
    public void setAge(int age) &#123;
        this.age = age;
    &#125;
    public String getName() &#123;
        return name;
    &#125;
    public void setName(String name) &#123;
        this.name = name;
    &#125;
    public Student(int age, String name) &#123;
        this.age = age;
        this.name = name;
    &#125;
    @Override
    public String toString() &#123;
        return &quot;Student&#123;&quot; +
                &quot;age=&quot; + age +
                &quot;, name=&#39;&quot; + name + &#39;\&#39;&#39; +
                &#39;&#125;&#39;;
    &#125;
    @Override
    public int compareTo(Student o) &#123;
        return this.getAge()-o.getAge();
    &#125;
&#125;
</code></pre><pre><code class="java">public class Test03 &#123;
    //这是main方法，程序的入口
    public static void main(String[] args) &#123;
        //创建一个TreeSet:
        TreeSet&lt;Student&gt; ts = new TreeSet&lt;&gt;();
        ts.add(new Student(10,&quot;elili&quot;));
        ts.add(new Student(8,&quot;blili&quot;));
        ts.add(new Student(4,&quot;alili&quot;));
        ts.add(new Student(9,&quot;elili&quot;));
        ts.add(new Student(10,&quot;flili&quot;));
        ts.add(new Student(1,&quot;dlili&quot;));
        System.out.println(ts.size());
        System.out.println(ts);
    &#125;
&#125;
</code></pre><p>（2）通过外部比较器：</p><pre><code class="java">public class Student  &#123;
    private int age;
    private String name;
    public int getAge() &#123;
        return age;
    &#125;
    public void setAge(int age) &#123;
        this.age = age;
    &#125;
    public String getName() &#123;
        return name;
    &#125;
    public void setName(String name) &#123;
        this.name = name;
    &#125;
    public Student(int age, String name) &#123;
        this.age = age;
        this.name = name;
    &#125;
    @Override
    public String toString() &#123;
        return &quot;Student&#123;&quot; +
                &quot;age=&quot; + age +
                &quot;, name=&#39;&quot; + name + &#39;\&#39;&#39; +
                &#39;&#125;&#39;;
    &#125;
&#125;
class BiJiao implements Comparator&lt;Student&gt;&#123;
    @Override
    public int compare(Student o1, Student o2) &#123;
        return o1.getName().compareTo(o2.getName());
    &#125;
&#125;
</code></pre><pre><code class="java">public class Test03 &#123;
    //这是main方法，程序的入口
    public static void main(String[] args) &#123;
        //创建一个TreeSet:
        //利用外部比较器，必须自己制定：
        Comparator&lt;Student&gt; com = new BiJiao();
        TreeSet&lt;Student&gt; ts = new TreeSet&lt;&gt;(com);//一旦指定外部比较器，那么就会按照外部比较器来比较
        ts.add(new Student(10,&quot;elili&quot;));
        ts.add(new Student(8,&quot;blili&quot;));
        ts.add(new Student(4,&quot;alili&quot;));
        ts.add(new Student(9,&quot;elili&quot;));
        ts.add(new Student(10,&quot;flili&quot;));
        ts.add(new Student(1,&quot;dlili&quot;));
        System.out.println(ts.size());
        System.out.println(ts);
    &#125;
&#125;
</code></pre><p>实际开发中利用外部比较器多，因为扩展性好（多态）</p><p>换一种写法：</p><pre><code class="java">public class Test03 &#123;
    //这是main方法，程序的入口
    public static void main(String[] args) &#123;
        //创建一个TreeSet:
        //利用外部比较器，必须自己制定：
        /*Comparator&lt;Student&gt; com = new Comparator&lt;Student&gt;() &#123;
            @Override
            public int compare(Student o1, Student o2) &#123;
                return o1.getName().compareTo(o2.getName());
            &#125;
        &#125;;*/
        TreeSet&lt;Student&gt; ts = new TreeSet&lt;&gt;(new Comparator&lt;Student&gt;() &#123;
            @Override
            public int compare(Student o1, Student o2) &#123;
                return o1.getName().compareTo(o2.getName());
            &#125;
        &#125;);//一旦指定外部比较器，那么就会按照外部比较器来比较
        ts.add(new Student(10,&quot;elili&quot;));
        ts.add(new Student(8,&quot;blili&quot;));
        ts.add(new Student(4,&quot;alili&quot;));
        ts.add(new Student(9,&quot;elili&quot;));
        ts.add(new Student(10,&quot;flili&quot;));
        ts.add(new Student(1,&quot;dlili&quot;));
        System.out.println(ts.size());
        System.out.println(ts);
    &#125;
&#125;
</code></pre><p>【5】TreeSet底层的二叉树的遍历是按照升序的结果出现的，这个升序是靠中序遍历得到的：</p><img data-src="/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618174642838.png"><h3 id="3-5-Collection部分整体结构图"><a href="#3-5-Collection部分整体结构图" class="headerlink" title="3.5 Collection部分整体结构图"></a>3.5 Collection部分整体结构图</h3><img data-src="/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618174657969.png"><h1 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a>Map接口</h1><h2 id="1-常用方法"><a href="#1-常用方法" class="headerlink" title="1 常用方法"></a>1 常用方法</h2><pre><code class="java">package com.msb.test11;
import java.util.Collection;
import java.util.HashMap;
import java.util.Map;
import java.util.Set;
/**
 * @author : msb-zhaoss
 */
public class Test01 &#123;
    //这是main方法，程序的入口
    public static void main(String[] args) &#123;
        /*
        增加：put(K key, V value)
        删除：clear() remove(Object key)
        修改：
        查看：entrySet() get(Object key) keySet() size() values()
        判断：containsKey(Object key) containsValue(Object value)
            equals(Object o) isEmpty()
         */
        //创建一个Map集合：无序，唯一
        Map&lt;String,Integer&gt; map = new HashMap&lt;&gt;();
        System.out.println(map.put(&quot;lili&quot;, 10101010));
        map.put(&quot;nana&quot;,12345234);
        map.put(&quot;feifei&quot;,34563465);
        System.out.println(map.put(&quot;lili&quot;, 34565677));
        map.put(&quot;mingming&quot;,12323);
        /*map.clear();清空*/
        /*map.remove(&quot;feifei&quot;);移除*/
        System.out.println(map.size());
        System.out.println(map);
        System.out.println(map.containsKey(&quot;lili&quot;));
        System.out.println(map.containsValue(12323));
        Map&lt;String,Integer&gt; map2 = new HashMap&lt;&gt;();
        System.out.println(map2.put(&quot;lili&quot;, 10101010));
        map2.put(&quot;nana&quot;,12345234);
        map2.put(&quot;feifei&quot;,34563465);
        System.out.println(map2.put(&quot;lili&quot;, 34565677));
        map2.put(&quot;mingming2&quot;,12323);
        System.out.println(map==map2);
        System.out.println(map.equals(map2));//equals进行了重写，比较的是集合中的值是否一致
        System.out.println(&quot;判断是否为空：&quot;+map.isEmpty());
        System.out.println(map.get(&quot;nana&quot;));
        System.out.println(&quot;-----------------------------------&quot;);
        //keySet()对集合中的key进行遍历查看：
        Set&lt;String&gt; set = map.keySet();
        for(String s:set)&#123;
            System.out.println(s);
        &#125;
        System.out.println(&quot;-----------------------------------&quot;);
        //values()对集合中的value进行遍历查看：
        Collection&lt;Integer&gt; values = map.values();
        for(Integer i:values)&#123;
            System.out.println(i);
        &#125;
        System.out.println(&quot;-----------------------------------&quot;);
        //get(Object key) keySet()
        Set&lt;String&gt; set2 = map.keySet();
        for(String s:set2)&#123;
            System.out.println(map.get(s));
        &#125;
        System.out.println(&quot;-----------------------------------&quot;);
        //entrySet()
        Set&lt;Map.Entry&lt;String, Integer&gt;&gt; entries = map.entrySet();
        for(Map.Entry&lt;String, Integer&gt; e:entries)&#123;
            System.out.println(e.getKey()+&quot;----&quot;+e.getValue());
        &#125;
    &#125;
&#125;
</code></pre><h2 id="2-TreeMap"><a href="#2-TreeMap" class="headerlink" title="2 TreeMap"></a>2 TreeMap</h2><p>【1】key的类型为String类型：</p><pre><code class="java">public class Test02 &#123;
    //这是main方法，程序的入口
    public static void main(String[] args) &#123;
        Map&lt;String,Integer&gt; map = new TreeMap&lt;&gt;();
        map.put(&quot;blili&quot;,1234);
        map.put(&quot;alili&quot;,2345);
        map.put(&quot;blili&quot;,5467);
        map.put(&quot;clili&quot;,5678);
        map.put(&quot;dlili&quot;,2345);
        System.out.println(map.size());
        System.out.println(map);
    &#125;
&#125;
</code></pre><p>【2】key的类型是一个自定义的引用数据类型：<br>（1）内部比较器：</p><pre><code class="java">public class Test03 &#123;
    //这是main方法，程序的入口
    public static void main(String[] args) &#123;
        Map&lt;Student,Integer&gt; map = new TreeMap&lt;&gt;();
        map.put(new Student(19,&quot;blili&quot;,170.5),1001);
        map.put(new Student(18,&quot;blili&quot;,150.5),1003);
        map.put(new Student(19,&quot;alili&quot;,180.5),1023);
        map.put(new Student(17,&quot;clili&quot;,140.5),1671);
        map.put(new Student(10,&quot;dlili&quot;,160.5),1891);
        System.out.println(map);
        System.out.println(map.size());
    &#125;
&#125;
</code></pre><pre><code class="java">public class Student implements Comparable&lt;Student&gt;&#123;
    private int age;
    private String name;
    private double height;
    public int getAge() &#123;
        return age;
    &#125;
    public void setAge(int age) &#123;
        this.age = age;
    &#125;
    public String getName() &#123;
        return name;
    &#125;
    public void setName(String name) &#123;
        this.name = name;
    &#125;
    public double getHeight() &#123;
        return height;
    &#125;
    public void setHeight(double height) &#123;
        this.height = height;
    &#125;
    public Student(int age, String name, double height) &#123;
        this.age = age;
        this.name = name;
        this.height = height;
    &#125;
    @Override
    public String toString() &#123;
        return &quot;Student&#123;&quot; +
                &quot;age=&quot; + age +
                &quot;, name=&#39;&quot; + name + &#39;\&#39;&#39; +
                &quot;, height=&quot; + height +
                &#39;&#125;&#39;;
    &#125;
    @Override
    public int compareTo(Student o) &#123;
       /* return this.getAge()-o.getAge();*/
        return this.getName().compareTo(o.getName());
    &#125;
&#125;
</code></pre><p>（2）外部比较器：</p><pre><code class="java">public class Test03 &#123;
    //这是main方法，程序的入口
    public static void main(String[] args) &#123;
        Map&lt;Student,Integer&gt; map = new TreeMap&lt;&gt;(new Comparator&lt;Student&gt;() &#123;
            @Override
            public int compare(Student o1, Student o2) &#123;
                return ((Double)(o1.getHeight())).compareTo((Double)(o2.getHeight()));
            &#125;
        &#125;);
        map.put(new Student(19,&quot;blili&quot;,170.5),1001);
        map.put(new Student(18,&quot;blili&quot;,150.5),1003);
        map.put(new Student(19,&quot;alili&quot;,180.5),1023);
        map.put(new Student(17,&quot;clili&quot;,140.5),1671);
        map.put(new Student(10,&quot;dlili&quot;,160.5),1891);
        System.out.println(map);
        System.out.println(map.size());
    &#125;
&#125;
</code></pre><h2 id="3-Map部分整体结构图"><a href="#3-Map部分整体结构图" class="headerlink" title="3 Map部分整体结构图"></a>3 Map部分整体结构图</h2><img data-src="/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618174919194.png"><h2 id="4-源码部分"><a href="#4-源码部分" class="headerlink" title="4 源码部分"></a>4 源码部分</h2><h3 id="4-1-HashMap"><a href="#4-1-HashMap" class="headerlink" title="4.1 HashMap"></a>4.1 HashMap</h3><h4 id="4-1-1-代码展示特性"><a href="#4-1-1-代码展示特性" class="headerlink" title="4.1.1 代码展示特性"></a>4.1.1 代码展示特性</h4><pre><code class="java">public class Test &#123;
    //这是main方法，程序的入口
    public static void main(String[] args) &#123;
        //JDK1.7以后支持后面的&lt;&gt;中内容可以不写
        HashMap&lt;Integer,String&gt; hm = new HashMap&lt;&gt;();
        System.out.println(hm.put(12,&quot;丽丽&quot;));
        System.out.println(hm.put(7,&quot;菲菲&quot;));
        System.out.println(hm.put(19,&quot;露露&quot;));
        System.out.println(hm.put(12,&quot;明明&quot;));
        System.out.println(hm.put(6,&quot;莹莹&quot;));
        System.out.println(&quot;集合的长度：&quot;+hm.size());
        System.out.println(&quot;集合中内容查看：&quot;+hm);
    &#125;
&#125;
</code></pre><p>结果展示：</p><img data-src="/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618175455959.png"><h4 id="4-1-2-先演示原理"><a href="#4-1-2-先演示原理" class="headerlink" title="4.1.2 先演示原理"></a>4.1.2 先演示原理</h4><p>先演示原理图，再看源码，直接看的话，有的人接不上就蒙了：<br>相当于先看原理，然后从源码中验证这个原理是否正确：把图搞懂了，就是事倍功半的效果<br>原理如下：(JDK1.7)</p><img data-src="/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618175512371.png"><h4 id="4-1-3-源码（JDK1-7版本）"><a href="#4-1-3-源码（JDK1-7版本）" class="headerlink" title="4.1.3 源码（JDK1.7版本）"></a>4.1.3 源码（JDK1.7版本）</h4><pre><code class="java">public class HashMap&lt;K,V&gt;
    extends AbstractMap&lt;K,V&gt; //【1】继承的AbstractMap中，已经实现了Map接口
        //【2】又实现了这个接口，多余，但是设计者觉得没有必要删除，就这么地了
    implements Map&lt;K,V&gt;, Cloneable, Serializable&#123;
                
                
        //【3】后续会用到的重要属性：先粘贴过来：
    static final int DEFAULT_INITIAL_CAPACITY = 16;//哈希表主数组的默认长度
        //定义了一个float类型的变量，以后作为：默认的装填因子，加载因子是表示Hsah表中元素的填满的程度
        //太大容易引起哈西冲突，太小容易浪费  0.75是经过大量运算后得到的最好值
        //这个值其实可以自己改，但是不建议改，因为这个0.75是大量运算得到的
        static final float DEFAULT_LOAD_FACTOR = 0.75f;
        transient Entry&lt;K,V&gt;[] table;//主数组,每个元素为Entry类型
        transient int size;
        int threshold;//数组扩容的界限值,门槛值   16*0.75=12 
        final float loadFactor;//用来接收装填因子的变量
        
        //【4】查看构造器：内部相当于：this(16,0.75f);调用了当前类中的带参构造器
        public HashMap() &#123;
        this(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR);
    &#125;
        //【5】本类中带参数构造器：--》作用给一些数值进行初始化的！
        public HashMap(int initialCapacity, float loadFactor) &#123;
        //【6】给capacity赋值，capacity的值一定是 大于你传进来的initialCapacity 的 最小的 2的倍数
        int capacity = 1;
        while (capacity &lt; initialCapacity)
            capacity &lt;&lt;= 1;
                //【7】给loadFactor赋值，将装填因子0.75赋值给loadFactor
        this.loadFactor = loadFactor;
                //【8】数组扩容的界限值,门槛值
        threshold = (int)Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + 1);
                
                //【9】给table数组赋值，初始化数组长度为16
        table = new Entry[capacity];
                   
    &#125;
        //【10】调用put方法：
        public V put(K key, V value) &#123;
                //【11】对空值的判断
        if (key == null)
            return putForNullKey(value);
                //【12】调用hash方法，获取哈希码
        int hash = hash(key);
                //【14】得到key对应在数组中的位置
        int i = indexFor(hash, table.length);
                //【16】如果你放入的元素，在主数组那个位置上没有值，e==null  那么下面这个循环不走
                //当在同一个位置上放入元素的时候
        for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123;
            Object k;
                        //哈希值一样  并且  equals相比一样   
                        //(k = e.key) == key  如果是一个对象就不用比较equals了
            if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;
                V oldValue = e.value;
                e.value = value;
                e.recordAccess(this);
                return oldValue;
            &#125;
        &#125;
        modCount++;
                //【17】走addEntry添加这个节点的方法：
        addEntry(hash, key, value, i);
        return null;
    &#125;
        
        //【13】hash方法返回这个key对应的哈希值，内部进行二次散列，为了尽量保证不同的key得到不同的哈希码！
        final int hash(Object k) &#123;
        int h = 0;
        if (useAltHashing) &#123;
            if (k instanceof String) &#123;
                return sun.misc.Hashing.stringHash32((String) k);
            &#125;
            h = hashSeed;
        &#125;
                //k.hashCode()函数调用的是key键值类型自带的哈希函数，
                //由于不同的对象其hashCode()有可能相同，所以需对hashCode()再次哈希，以降低相同率。
        h ^= k.hashCode();
        // This function ensures that hashCodes that differ only by
        // constant multiples at each bit position have a bounded
        // number of collisions (approximately 8 at default load factor).
                /*
                接下来的一串与运算和异或运算，称之为“扰动函数”，
                扰动的核心思想在于使计算出来的值在保留原有相关特性的基础上，
                增加其值的不确定性，从而降低冲突的概率。
                不同的版本实现的方式不一样，但其根本思想是一致的。
                往右移动的目的，就是为了将h的高位利用起来，减少哈西冲突
                */
        h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12);
        return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);
    &#125;
        //【15】返回int类型数组的坐标
        static int indexFor(int h, int length) &#123;
                //其实这个算法就是取模运算：h%length，取模效率不如位运算
        return h &amp; (length-1);
    &#125;
        //【18】调用addEntry
        void addEntry(int hash, K key, V value, int bucketIndex) &#123;
                //【25】size的大小  大于 16*0.75=12的时候，比如你放入的是第13个，这第13个你打算放在没有元素的位置上的时候
        if ((size &gt;= threshold) &amp;&amp; (null != table[bucketIndex])) &#123;
                        //【26】主数组扩容为2倍
            resize(2 * table.length);
                        //【30】重新调整当前元素的hash码
            hash = (null != key) ? hash(key) : 0;
                        //【31】重新计算元素位置
            bucketIndex = indexFor(hash, table.length);
        &#125;
                //【19】将hash,key,value,bucketIndex位置  封装为一个Entry对象：
        createEntry(hash, key, value, bucketIndex);
    &#125;
        //【20】
        void createEntry(int hash, K key, V value, int bucketIndex) &#123;
                //【21】获取bucketIndex位置上的元素给e
        Entry&lt;K,V&gt; e = table[bucketIndex];
                //【22】然后将hash, key, value封装为一个对象，然后将下一个元素的指向为e （链表的头插法）
                //【23】将新的Entry放在table[bucketIndex]的位置上
        table[bucketIndex] = new Entry&lt;&gt;(hash, key, value, e);
                //【24】集合中加入一个元素 size+1
        size++;
    &#125;
    //【27】
        void resize(int newCapacity) &#123;
        Entry[] oldTable = table;
        int oldCapacity = oldTable.length;
        if (oldCapacity == MAXIMUM_CAPACITY) &#123;
            threshold = Integer.MAX_VALUE;
            return;
        &#125;
                //【28】创建长度为newCapacity的数组
        Entry[] newTable = new Entry[newCapacity];
        boolean oldAltHashing = useAltHashing;
        useAltHashing |= sun.misc.VM.isBooted() &amp;&amp;
                (newCapacity &gt;= Holder.ALTERNATIVE_HASHING_THRESHOLD);
        boolean rehash = oldAltHashing ^ useAltHashing;
                //【28.5】转让方法：将老数组中的东西都重新放入新数组中
        transfer(newTable, rehash);
                //【29】老数组替换为新数组
        table = newTable;
                //【29.5】重新计算
        threshold = (int)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + 1);
    &#125;
        //【28.6】
        void transfer(Entry[] newTable, boolean rehash) &#123;
        int newCapacity = newTable.length;
        for (Entry&lt;K,V&gt; e : table) &#123;
            while(null != e) &#123;
                Entry&lt;K,V&gt; next = e.next;
                if (rehash) &#123;
                    e.hash = null == e.key ? 0 : hash(e.key);
                &#125;
                                //【28.7】将哈希值，和新的数组容量传进去，重新计算key在新数组中的位置
                int i = indexFor(e.hash, newCapacity);
                                //【28.8】头插法
                e.next = newTable[i];//获取链表上元素给e.next
                newTable[i] = e;//然后将e放在i位置 
                e = next;//e再指向下一个节点继续遍历
            &#125;
        &#125;
    &#125;
&#125;
</code></pre><h4 id="4-1-4-细节讲解：主数组的长度为2的倍数"><a href="#4-1-4-细节讲解：主数组的长度为2的倍数" class="headerlink" title="4.1.4  细节讲解：主数组的长度为2的倍数"></a>4.1.4 细节讲解：主数组的长度为2的倍数</h4><p>【1】主数组的长度为2的倍数，</p><img data-src="/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618175628889.png"><p>因为这个length的长度，会影响 key的位置：<br>key的位置的计算：</p><img data-src="/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618175638657.png"><p>实际上这个算法就是： h%length ,但是取模的话 效率太低，所以用位运算效率会很高。</p><p><strong>原因1：</strong><br><img data-src="/img/image-20220618175703663.png" alt="image-20220618175703663">和<img data-src="/img/image-20220618175712379.png" alt="image-20220618175712379">等效的前提就是 length必须是2的整数倍<br><strong>原因2：</strong></p><p>如果不是2的整数倍，那么 哈西碰撞 哈西冲突的概率就高了很多</p><p>位运算 就 涉及 到 length是不是2的整数倍：<br>比如是2的整数倍：</p><img data-src="/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618175753914.png"> <img data-src="/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618175800521.png"><p>并且这个得到的索引值，一定在 0-15之间（数组是16的时候）：</p><img data-src="/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618175840905.png"><p>当然如果你扩容后数组长度为 32，那么这个索引就在0-31之间</p><p>比如如果不是2的整数倍：</p><img data-src="/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618175850530.png"><p>发现：如果不是2的整数倍，那么 哈西碰撞 哈西冲突的概率就高了很多</p><h4 id="4-1-5-细节讲解：装填因子0-75的原因"><a href="#4-1-5-细节讲解：装填因子0-75的原因" class="headerlink" title="4.1.5 细节讲解：装填因子0.75的原因"></a>4.1.5 细节讲解：装填因子0.75的原因</h4><p>如果装填因子是1， 那么数组满了再扩容，可以做到 最大的空间利用率<br>但是这是一个理想状态，元素不可能完全的均匀分布，很可能就哈西碰撞产生链表了。产生链表的话 查询时间就长了。<br>—》空间好，时间不好</p><p>那么有人说 ，把装填因子搞小一点，0.5， 如果是0.5的话，就浪费空间，但是可以做到 到0.5就扩容 ，然后哈西碰撞就少，<br>不产生链表的话，那么查询效率很高<br>—》时间好，空间不好</p><p>所以在空间和时间中，<br>取中间值，平衡这个因素 就取值为 0.75</p><img data-src="/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618175921895.png"><p><strong>1.8版本</strong></p><h2 id="1-8底层遵照-哈希表结构-红黑树"><a href="#1-8底层遵照-哈希表结构-红黑树" class="headerlink" title="1.8底层遵照 哈希表结构 + 红黑树"></a>1.8底层遵照 <font color="red">哈希表结构 + 红黑树</font></h2><pre><code class="java">// HashMap&lt;String,Integer&gt; map = new HashMap&lt;&gt;(); --&gt;JDK 1.7开始类型推断，后面用钻石运算符即可。
public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; 		//【1】继承的AbstractMap中，已经实现了Map接口
    implements Map&lt;K,V&gt;, Cloneable, Serializable &#123; //【2】又实现了这个接口，多余，但是集合的设计者觉得没有必要删除，就这么地了

    //------------------属性部分：
    final float loadFactor;//【3-2】用来接收装填因子的变量
    /*
        【3-3】
        定义了一个float类型的变量，以后作为：默认的装填因子，加载因子是表示Hsah表中元素的填满的程度
        太大容易引起哈西冲突，太小容易浪费  0.75是经过大量运算后得到的最好值
        这个值其实可以自己改，但是不建议改，因为这个0.75是大量运算得到的
    */
    static final float DEFAULT_LOAD_FACTOR = 0.75f;
    int threshold;//【6-3】数组扩容的界限值,门槛值
    transient Node&lt;K,V&gt;[] table;//【7-5】底层主数组
    //------------------构造器：
    //【3】调用空构造器
    public HashMap() &#123;
        //【3-1】给装填因子loadFactor赋值
        this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted
    &#125;
    
    //【4】调用有参构造器：
    public HashMap(int initialCapacity) &#123;
        //【5】调用两个参数构造器
        this(initialCapacity, DEFAULT_LOAD_FACTOR);
    &#125;
    //【6】
    public HashMap(int initialCapacity, float loadFactor) &#123;
        //【6-1】健壮性考虑，传入的数据过小不行，过大不行
        if (initialCapacity &lt; 0)
            throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; +
                                               initialCapacity);
        if (initialCapacity &gt; MAXIMUM_CAPACITY)
            initialCapacity = MAXIMUM_CAPACITY;
        if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))
            throw new IllegalArgumentException(&quot;Illegal load factor: &quot; +
                                               loadFactor);
        //【6-2】给装填因子loadFactor赋值，赋值为0.75，这个值可以单独传入改变，但是不建议改变，一般都用默认的0.75
        this.loadFactor = loadFactor;
        //【6-3】给threshold赋值 
        this.threshold = tableSizeFor(initialCapacity);
    &#125;
    //【6-4】返回的是大于initialCapacity的最接近的2的整数倍  ，比如initialCapacity传入10，这个方法返回16
    static final int tableSizeFor(int cap) &#123;//（内部内容讲源码时候不用管，面试题中详讲）
        int n = cap - 1;
        n |= n &gt;&gt;&gt; 1;
        n |= n &gt;&gt;&gt; 2;
        n |= n &gt;&gt;&gt; 4;
        n |= n &gt;&gt;&gt; 8;
        n |= n &gt;&gt;&gt; 16;
        return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;
    &#125;
    
    //------------------方法：
    //【7】调用put方法
    public V put(K key, V value) &#123;
        //【7-1】首先调用hash方法计算哈希值：
        //【7-3】调用putVal方法传入五个参数：
        return putVal(hash(key), key, value, false, true);
    &#125;
    //【7-2】计算hash值
    static final int hash(Object key) &#123;
        int h;
        return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);
    &#125;
    //【7-4】调用
    final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
                   boolean evict) &#123;
        Node&lt;K,V&gt;[] tab;
        Node&lt;K,V&gt; p; 
        int n, i;
        //【7-6】将底层主数组table给tab，判断是否为null，第一次放数据一定是null
        if ((tab = table) == null || (n = tab.length) == 0)
            //【7-7】走入if分支：table是null，就对table进行扩容，走进resize方法
            n = (tab = resize()).length;//【7-21】table的length为16 ，n为16
        /*
        【7-22】
        i = (n - 1) &amp; hash 根据哈希值和n计算放入数组的位置
        取出这个位置上的元素，看是否为空，如果是第一个元素，一定是null
        */
        if ((p = tab[i = (n - 1) &amp; hash]) == null)
            //【7-23】在这个位置上将元素封装为Node对象，放入对应位置
            tab[i] = newNode(hash, key, value, null);//封装Node节点new Node&lt;&gt;(hash, key, value, null);
        else &#123;
            Node&lt;K,V&gt; e; K k;
            if (p.hash == hash &amp;&amp;
                ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))
                e = p;
            else if (p instanceof TreeNode)
                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);
            else &#123;
                for (int binCount = 0; ; ++binCount) &#123;
                    if ((e = p.next) == null) &#123;
                        p.next = newNode(hash, key, value, null);
                        if (binCount &gt;= TREEIFY_THRESHOLD - 1)  
                            treeifyBin(tab, hash);
                        break;
                    &#125;
                    if (e.hash == hash &amp;&amp;
                        ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))
                        break;
                    p = e;
                &#125;
            &#125;
            if (e != null) &#123;  
                V oldValue = e.value;
                if (!onlyIfAbsent || oldValue == null)
                    e.value = value;
                afterNodeAccess(e);
                return oldValue;
            &#125;
        &#125;
        ++modCount;
        //【7-25】size指的是放入集合的键值总数，size++操作，不大于threshold，resize方法不走
        if (++size &gt; threshold)
            resize();
        afterNodeInsertion(evict);
        return null;
    &#125;
    //【7-8】resize方法：---》假设最开始走的是HashMap的空构造器：
    final Node&lt;K,V&gt;[] resize() &#123;
        Node&lt;K,V&gt;[] oldTab = table;//【7-9】table 是null
        int oldCap = (oldTab == null) ? 0 : oldTab.length; //【7-10】oldCap:0
        int oldThr = threshold;//【7-11】threshold为16，oldThr：16
        int newCap, newThr = 0;
        if (oldCap &gt; 0) &#123;//【7-12】不走
            if (oldCap &gt;= MAXIMUM_CAPACITY) &#123;
                threshold = Integer.MAX_VALUE;
                return oldTab;
            &#125;
            else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;
                     oldCap &gt;= DEFAULT_INITIAL_CAPACITY)
                newThr = oldThr &lt;&lt; 1;
        &#125;
        else if (oldThr &gt; 0)  //【7-13】走
            newCap = oldThr;//newCap=16
        else &#123;               //【7-14】不走
             
            newCap = DEFAULT_INITIAL_CAPACITY;
             
            newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);
        &#125;
        if (newThr == 0) &#123;//【7-15】走
            float ft = (float)newCap * loadFactor;//【7-16】ft: 16*0.75=12
            newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?
                      (int)ft : Integer.MAX_VALUE); //【7-17】newThr = 12
        &#125;
        //【7-18】threshold赋值为newThr为12， ---》所以走空构造器这里threshold赋值为12，走有参构造器里面threshold赋值为12？？？？
        threshold = newThr;
        @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)
        //【7-19】创建Node数组，长度为newCap16
            Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];
        //【7-20】table赋值为newTab
        table = newTab;
        if (oldTab != null) &#123;
            for (int j = 0; j &lt; oldCap; ++j) &#123;
                Node&lt;K,V&gt; e;
                if ((e = oldTab[j]) != null) &#123;
                    oldTab[j] = null;
                    if (e.next == null)
                        newTab[e.hash &amp; (newCap - 1)] = e;
                    else if (e instanceof TreeNode)
                        ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);
                    else &#123; 
                        Node&lt;K,V&gt; loHead = null, loTail = null;
                        Node&lt;K,V&gt; hiHead = null, hiTail = null;
                        Node&lt;K,V&gt; next;
                        do &#123;
                            next = e.next;
                            if ((e.hash &amp; oldCap) == 0) &#123;
                                if (loTail == null)
                                    loHead = e;
                                else
                                    loTail.next = e;
                                loTail = e;
                            &#125;
                            else &#123;
                                if (hiTail == null)
                                    hiHead = e;
                                else
                                    hiTail.next = e;
                                hiTail = e;
                            &#125;
                        &#125; while ((e = next) != null);
                        if (loTail != null) &#123;
                            loTail.next = null;
                            newTab[j] = loHead;
                        &#125;
                        if (hiTail != null) &#123;
                            hiTail.next = null;
                            newTab[j + oldCap] = hiHead;
                        &#125;
                    &#125;
                &#125;
            &#125;
        &#125;
        return newTab;
    &#125;
&#125;
</code></pre><pre><code class="java">public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; 
    implements Map&lt;K,V&gt;, Cloneable, Serializable &#123; 
    final float loadFactor;
    static final float DEFAULT_LOAD_FACTOR = 0.75f;
    int threshold;
    transient Node&lt;K,V&gt;[] table;
    public HashMap() &#123;
        this.loadFactor = DEFAULT_LOAD_FACTOR; 
    &#125;
    
    public HashMap(int initialCapacity) &#123;
        this(initialCapacity, DEFAULT_LOAD_FACTOR);
    &#125;
    public HashMap(int initialCapacity, float loadFactor) &#123;
        if (initialCapacity &lt; 0)
            throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; +
                                               initialCapacity);
        if (initialCapacity &gt; MAXIMUM_CAPACITY)
            initialCapacity = MAXIMUM_CAPACITY;
        if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))
            throw new IllegalArgumentException(&quot;Illegal load factor: &quot; +
                                               loadFactor);
        this.loadFactor = loadFactor;
        this.threshold = tableSizeFor(initialCapacity);
    &#125;
    static final int tableSizeFor(int cap) &#123;
        int n = cap - 1;
        n |= n &gt;&gt;&gt; 1;
        n |= n &gt;&gt;&gt; 2;
        n |= n &gt;&gt;&gt; 4;
        n |= n &gt;&gt;&gt; 8;
        n |= n &gt;&gt;&gt; 16;
        return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;
    &#125;
    
    //【8-1】put方法
    public V put(K key, V value) &#123;
        //计算hash值
        return putVal(hash(key), key, value, false, true);
    &#125;

    static final int hash(Object key) &#123;
        int h;
        return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);
    &#125;
    //【8-2】调用putVal方法
    final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
                   boolean evict) &#123;
        Node&lt;K,V&gt;[] tab;
        Node&lt;K,V&gt; p; 
        int n, i;
        
        //【8-3】table不空了，不走if		
        if ((tab = table) == null || (n = tab.length) == 0)
            n = (tab = resize()).length;
        //【8-4】tab[i]不null，不走if
        if ((p = tab[i = (n - 1) &amp; hash]) == null)
            tab[i] = newNode(hash, key, value, null);
        else &#123;
            Node&lt;K,V&gt; e; K k;
            /*
                【8-5】
                判断p.hash == hash哈希值是否相等，即使hash相等也要做&amp;&amp;后续的判断，因为两个对象哈希值相等是有可能的
                (k = p.key) == key   == 比较地址值，String的话一样，不是字符串地址也不一样，
                Animal a1 = new Animal(19);		和 	Animal a2 = new Animal(19);	地址一定不同，就需要用后面的equals进行比较
            */
            if (p.hash == hash &amp;&amp;
                ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))   //----》哈希值相等，出现哈西碰撞
                //【8-6】将该数组位置的数据给e
                e = p;
            else if (p instanceof TreeNode)
                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);
            else &#123;
                for (int binCount = 0; ; ++binCount) &#123;
                    if ((e = p.next) == null) &#123;
                        p.next = newNode(hash, key, value, null);
                        if (binCount &gt;= TREEIFY_THRESHOLD - 1)  
                            treeifyBin(tab, hash);
                        break;
                    &#125;
                    if (e.hash == hash &amp;&amp;
                        ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))
                        break;
                    p = e;
                &#125;
            &#125;
            if (e != null) &#123;  
                V oldValue = e.value;
                if (!onlyIfAbsent || oldValue == null)
                    e.value = value;//【8-7】新value替换老value
                afterNodeAccess(e);
                return oldValue;//【8-8】返回老value
            &#125;
        &#125;
        ++modCount;

        if (++size &gt; threshold)
            resize();
        afterNodeInsertion(evict);
        return null;
    &#125;

    final Node&lt;K,V&gt;[] resize() &#123;
        Node&lt;K,V&gt;[] oldTab = table;
        int oldCap = (oldTab == null) ? 0 : oldTab.length; 
        int oldThr = threshold;
        int newCap, newThr = 0;
        if (oldCap &gt; 0) &#123;
            if (oldCap &gt;= MAXIMUM_CAPACITY) &#123;
                threshold = Integer.MAX_VALUE;
                return oldTab;
            &#125;
            else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;
                     oldCap &gt;= DEFAULT_INITIAL_CAPACITY)
                newThr = oldThr &lt;&lt; 1;
        &#125;
        else if (oldThr &gt; 0) 
            newCap = oldThr;
        else &#123;    
            newCap = DEFAULT_INITIAL_CAPACITY;
            newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);
        &#125;
        if (newThr == 0) &#123;
            float ft = (float)newCap * loadFactor;
            newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?
                      (int)ft : Integer.MAX_VALUE);
        &#125;
        threshold = newThr;
        @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)
            Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];
        table = newTab;
        if (oldTab != null) &#123;
            for (int j = 0; j &lt; oldCap; ++j) &#123;
                Node&lt;K,V&gt; e;
                if ((e = oldTab[j]) != null) &#123;
                    oldTab[j] = null;
                    if (e.next == null)
                        newTab[e.hash &amp; (newCap - 1)] = e;
                    else if (e instanceof TreeNode)
                        ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);
                    else &#123; 
                        Node&lt;K,V&gt; loHead = null, loTail = null;
                        Node&lt;K,V&gt; hiHead = null, hiTail = null;
                        Node&lt;K,V&gt; next;
                        do &#123;
                            next = e.next;
                            if ((e.hash &amp; oldCap) == 0) &#123;
                                if (loTail == null)
                                    loHead = e;
                                else
                                    loTail.next = e;
                                loTail = e;
                            &#125;
                            else &#123;
                                if (hiTail == null)
                                    hiHead = e;
                                else
                                    hiTail.next = e;
                                hiTail = e;
                            &#125;
                        &#125; while ((e = next) != null);
                        if (loTail != null) &#123;
                            loTail.next = null;
                            newTab[j] = loHead;
                        &#125;
                        if (hiTail != null) &#123;
                            hiTail.next = null;
                            newTab[j + oldCap] = hiHead;
                        &#125;
                    &#125;
                &#125;
            &#125;
        &#125;
        return newTab;
    &#125;
&#125;
</code></pre><pre><code class="java">public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; 
    implements Map&lt;K,V&gt;, Cloneable, Serializable &#123; 
    final float loadFactor;
    static final float DEFAULT_LOAD_FACTOR = 0.75f;
    int threshold;
    transient Node&lt;K,V&gt;[] table;
    public HashMap() &#123;
        this.loadFactor = DEFAULT_LOAD_FACTOR; 
    &#125;
    
    public HashMap(int initialCapacity) &#123;
        this(initialCapacity, DEFAULT_LOAD_FACTOR);
    &#125;
    public HashMap(int initialCapacity, float loadFactor) &#123;
        if (initialCapacity &lt; 0)
            throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; +
                                               initialCapacity);
        if (initialCapacity &gt; MAXIMUM_CAPACITY)
            initialCapacity = MAXIMUM_CAPACITY;
        if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))
            throw new IllegalArgumentException(&quot;Illegal load factor: &quot; +
                                               loadFactor);
        this.loadFactor = loadFactor;
        this.threshold = tableSizeFor(initialCapacity);
    &#125;
    static final int tableSizeFor(int cap) &#123;
        int n = cap - 1;
        n |= n &gt;&gt;&gt; 1;
        n |= n &gt;&gt;&gt; 2;
        n |= n &gt;&gt;&gt; 4;
        n |= n &gt;&gt;&gt; 8;
        n |= n &gt;&gt;&gt; 16;
        return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;
    &#125;
    
    //【9-1】put方法
    public V put(K key, V value) &#123;
        //计算hash值
        return putVal(hash(key), key, value, false, true);
    &#125;

    static final int hash(Object key) &#123;
        int h;
        return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);
    &#125;
    //【9-2】调用putVal方法
    final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
                   boolean evict) &#123;
        Node&lt;K,V&gt;[] tab;
        Node&lt;K,V&gt; p; 
        int n, i;
        
        //【9-3】table不空了，不走if		
        if ((tab = table) == null || (n = tab.length) == 0)
            n = (tab = resize()).length;
        //【9-4】tab[i]不null，不走if
        if ((p = tab[i = (n - 1) &amp; hash]) == null)
            tab[i] = newNode(hash, key, value, null);
        else &#123;
            Node&lt;K,V&gt; e; K k;
            /*
                【9-5】
                判断p.hash == hash哈希值是否相等，即使hash相等也要做&amp;&amp;后续的判断，因为两个对象哈希值相等是有可能的
                此时“通话”和“重地”的哈希值一致，但是key不一致，if不走
            */
            if (p.hash == hash &amp;&amp;
                ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))
                e = p;
            else if (p instanceof TreeNode)//【9-6】p也不是红黑树，不走if
                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);
            else &#123;
                //【9-7】走到这里，证明数组的这个位置是个链表了
                for (int binCount = 0; ; ++binCount) &#123;//【9-8】无条件的死循环   binCount 链表上节点的个数
                    //随着循环  p.next就是一路找链上元素
                    //p.next要是没有元素，就要开始追加了呗
                    if ((e = p.next) == null) &#123;//【9-10】一路next比较都没有key相同的数据
                    
                        p.next = newNode(hash, key, value, null);//【9-11】追加在链表尾部 ---》 前七后八
                        //【9-12】如果节点个数大于8，进行树化：要从链表转为红黑树
                        if (binCount &gt;= TREEIFY_THRESHOLD - 1)  
                            treeifyBin(tab, hash);//【9-13】这里还涉及 剪枝 问题，树节点在6个以下，就又变成链表了
                        break;
                    &#125;
                    //【9-9】比较过程中：如果比较链表某个key相同，就break结束了，不用继续走了
                    if (e.hash == hash &amp;&amp;
                        ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))
                        break;
                    p = e;
                &#125;
            &#125;
            if (e != null) &#123;  
                V oldValue = e.value;
                if (!onlyIfAbsent || oldValue == null)
                    e.value = value;//【8-7】新value替换老value
                afterNodeAccess(e);
                return oldValue;//【8-8】返回老value
            &#125;
        &#125;
        ++modCount;

        if (++size &gt; threshold)
            resize();
        afterNodeInsertion(evict);
        return null;
    &#125;

    final Node&lt;K,V&gt;[] resize() &#123;
        Node&lt;K,V&gt;[] oldTab = table;
        int oldCap = (oldTab == null) ? 0 : oldTab.length; 
        int oldThr = threshold;
        int newCap, newThr = 0;
        if (oldCap &gt; 0) &#123;
            if (oldCap &gt;= MAXIMUM_CAPACITY) &#123;
                threshold = Integer.MAX_VALUE;
                return oldTab;
            &#125;
            else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;
                     oldCap &gt;= DEFAULT_INITIAL_CAPACITY)
                newThr = oldThr &lt;&lt; 1;
        &#125;
        else if (oldThr &gt; 0) 
            newCap = oldThr;
        else &#123;    
            newCap = DEFAULT_INITIAL_CAPACITY;
            newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);
        &#125;
        if (newThr == 0) &#123;
            float ft = (float)newCap * loadFactor;
            newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?
                      (int)ft : Integer.MAX_VALUE);
        &#125;
        threshold = newThr;
        @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)
            Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];
        table = newTab;
        if (oldTab != null) &#123;
            for (int j = 0; j &lt; oldCap; ++j) &#123;
                Node&lt;K,V&gt; e;
                if ((e = oldTab[j]) != null) &#123;
                    oldTab[j] = null;
                    if (e.next == null)
                        newTab[e.hash &amp; (newCap - 1)] = e;
                    else if (e instanceof TreeNode)
                        ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);
                    else &#123; 
                        Node&lt;K,V&gt; loHead = null, loTail = null;
                        Node&lt;K,V&gt; hiHead = null, hiTail = null;
                        Node&lt;K,V&gt; next;
                        do &#123;
                            next = e.next;
                            if ((e.hash &amp; oldCap) == 0) &#123;
                                if (loTail == null)
                                    loHead = e;
                                else
                                    loTail.next = e;
                                loTail = e;
                            &#125;
                            else &#123;
                                if (hiTail == null)
                                    hiHead = e;
                                else
                                    hiTail.next = e;
                                hiTail = e;
                            &#125;
                        &#125; while ((e = next) != null);
                        if (loTail != null) &#123;
                            loTail.next = null;
                            newTab[j] = loHead;
                        &#125;
                        if (hiTail != null) &#123;
                            hiTail.next = null;
                            newTab[j + oldCap] = hiHead;
                        &#125;
                    &#125;
                &#125;
            &#125;
        &#125;
        return newTab;
    &#125;
&#125;
</code></pre><p><strong>总结：</strong></p><p>默认<strong>数组长度为16</strong>，<strong>最大程度${2^{30}}$</strong>,<strong>负载因子为0.75</strong>，扩容时<strong>扩大2倍</strong>，</p><p>1.8比1.7改变了底层数据结构而已</p><h4 id="4-1-6-HashSet底层原理"><a href="#4-1-6-HashSet底层原理" class="headerlink" title="4.1.6 HashSet底层原理"></a>4.1.6 HashSet底层原理</h4><pre><code class="java">public class HashSet&lt;E&gt;&#123;
    //重要属性：
    private transient HashMap&lt;E,Object&gt; map;
    private static final Object PRESENT = new Object();
    //构造器：
    public HashSet() &#123;
        map = new HashMap&lt;&gt;();//HashSet底层就是利用HashMap来完成的
    &#125;
        
    public boolean add(E e) &#123;
        return map.put(e, PRESENT)==null;
    &#125;      
&#125;
</code></pre><h3 id="4-2TreeMap"><a href="#4-2TreeMap" class="headerlink" title="4.2TreeMap"></a>4.2TreeMap</h3><p>【1】原理大致介绍：</p><img data-src="/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618175955956.png"><p>【2】源码：</p><pre><code class="java">public class TreeMap&lt;K,V&gt;&#123;
        //重要属性：
        //外部比较器：
        private final Comparator&lt;? super K&gt; comparator;
        //树的根节点：
        private transient Entry&lt;K,V&gt; root = null;
        //集合中元素的数量：
        private transient int size = 0;
        //空构造器:
        public TreeMap() &#123;
        comparator = null;//如果使用空构造器，那么底层就不使用外部比较器
    &#125;
        //有参构造器：
        public TreeMap(Comparator&lt;? super K&gt; comparator) &#123;
        this.comparator = comparator;//如果使用有参构造器，那么就相当于指定了外部比较器
    &#125;
        
        public V put(K key, V value) &#123;//k,V的类型在创建对象的时候确定了
        //如果放入的是第一对元素，那么t的值为null
        Entry&lt;K,V&gt; t = root;//在放入第二个节点的时候，root已经是根节点了
                //如果放入的是第一个元素的话，走入这个if中：
        if (t == null) &#123;
                        //自己跟自己比
            compare(key, key); // type (and possibly null) check
                        //根节点确定为root
            root = new Entry&lt;&gt;(key, value, null);
                        //size值变为1
            size = 1;
            modCount++;
            return null;
        &#125;
                
        int cmp;
        Entry&lt;K,V&gt; parent;
        // split comparator and comparable paths
                //将外部比较器赋给cpr:
        Comparator&lt;? super K&gt; cpr = comparator;
                //cpr不等于null，意味着你刚才创建对象的时候调用了有参构造器，指定了外部比较器
        if (cpr != null) &#123;
            do &#123;
                parent = t;
                cmp = cpr.compare(key, t.key);//将元素的key值做比较
                                //cmp返回的值就是int类型的数据：
                                //要是这个值《0 =0  》0
                if (cmp &lt; 0)
                    t = t.left;
                else if (cmp &gt; 0)
                    t = t.right;
                else//cpm==0
                                //如果key的值一样，那么新的value替换老的value  但是key不变 因为key是唯一的
                    return t.setValue(value);
            &#125; while (t != null);
        &#125;
                //cpr等于null，意味着你刚才创建对象的时候调用了空构造器，没有指定外部比较器，使用内部比较器
        else &#123;
            if (key == null)
                throw new NullPointerException();
            Comparable&lt;? super K&gt; k = (Comparable&lt;? super K&gt;) key;
            do &#123;
                parent = t;
                cmp = k.compareTo(t.key);//将元素的key值做比较
                if (cmp &lt; 0)
                    t = t.left;
                else if (cmp &gt; 0)
                    t = t.right;
                else
                    return t.setValue(value);
            &#125; while (t != null);
        &#125;
        Entry&lt;K,V&gt; e = new Entry&lt;&gt;(key, value, parent);
        if (cmp &lt; 0)
            parent.left = e;
        else
            parent.right = e;
        fixAfterInsertion(e);
        size++;//size加1 操作
        modCount++;
        return null;
    &#125;
        
        
&#125;
 static final class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;
        K key;
        V value;
        Entry&lt;K,V&gt; left = null;
        Entry&lt;K,V&gt; right = null;
        Entry&lt;K,V&gt; parent;
        boolean color = BLACK;
 &#125;
</code></pre><h4 id="TreeSet源码"><a href="#TreeSet源码" class="headerlink" title="TreeSet源码"></a>TreeSet源码</h4><pre><code class="java">public class TreeSet&lt;E&gt; extends AbstractSet&lt;E&gt;
    implements NavigableSet&lt;E&gt;, Cloneable, java.io.Serializable&#123;
                //重要属性：
                private transient NavigableMap&lt;E,Object&gt; m;
                private static final Object PRESENT = new Object();
                
                //在调用空构造器的时候，底层创建了一个TreeMap
                public TreeSet() &#123;
                        this(new TreeMap&lt;E,Object&gt;());
                &#125;
                
                TreeSet(NavigableMap&lt;E,Object&gt; m) &#123;
                        this.m = m;
                &#125;
                
                public boolean add(E e) &#123;
        return m.put(e, PRESENT)==null;
    &#125;
                
                
        &#125;
</code></pre><h1 id="Collections工具类"><a href="#Collections工具类" class="headerlink" title="Collections工具类"></a>Collections工具类</h1><pre><code class="java">public class Test01 &#123;
    //这是main方法，程序的入口
    public static void main(String[] args) &#123;
        //Collections不支持创建对象，因为构造器私有化了
        /*Collections cols = new Collections();*/
        //里面的属性和方法都是被static修饰，我们可以直接用类名.去调用即可：
        //常用方法：
        //addAll：
        ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();
        list.add(&quot;cc&quot;);
        list.add(&quot;bb&quot;);
        list.add(&quot;aa&quot;);
        Collections.addAll(list,&quot;ee&quot;,&quot;dd&quot;,&quot;ff&quot;);
        Collections.addAll(list,new String[]&#123;&quot;gg&quot;,&quot;oo&quot;,&quot;pp&quot;&#125;);
        System.out.println(list);
        //binarySearch必须在有序的集合中查找：--》排序：
        Collections.sort(list);//sort提供的是升序排列
        System.out.println(list);
        //binarySearch
        System.out.println(Collections.binarySearch(list, &quot;cc&quot;));
        //copy:替换方法
        ArrayList&lt;String&gt; list2 = new ArrayList&lt;&gt;();
        Collections.addAll(list2,&quot;tt&quot;,&quot;ss&quot;);
        Collections.copy(list,list2);//将list2的内容替换到list上去
        System.out.println(list);
        System.out.println(list2);
        //fill 填充
        Collections.fill(list2,&quot;yyy&quot;);
        System.out.println(list2);
    &#125;
&#125;
</code></pre><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><pre><code class="java">public class Test &#123;
    //这是main方法，程序的入口
    public static void main(String[] args) &#123;
        /*
        Stack是Vector的子类，Vector里面两个重要的属性：
        Object[] elementData;底层依然是一个数组
        int elementCount;数组中的容量
         */
        Stack s = new Stack();
        s.add(&quot;A&quot;);
        s.add(&quot;B&quot;);
        s.add(&quot;C&quot;);
        s.add(&quot;D&quot;);
        System.out.println(s);//[A, B, C, D]
        System.out.println(&quot;栈是否为空：&quot; + s.empty());
        System.out.println(&quot;查看栈顶的数据，但是不移除：&quot; + s.peek());
        System.out.println(s);
        System.out.println(&quot;查看栈顶的数据，并且不移除：&quot; + s.pop());
        System.out.println(s);
        s.push(&quot;D&quot;);//和add方法执行的功能一样，就是返回值不同
        System.out.println(s);
    &#125;
&#125;
</code></pre><h2 id="同步类容器"><a href="#同步类容器" class="headerlink" title="同步类容器"></a>同步类容器</h2><p>比如ArrayList，HashMap，线程不安全，现在想把线程不安全的集合转换为线程安全的集合：</p><pre><code class="java">public class Test01 &#123;
    //这是main方法，程序的入口
    public static void main(String[] args) &#123;
        //ArrayList为案例：从线程不安全  转为线程安全：
        List list = Collections.synchronizedList(new ArrayList());
    &#125;
&#125;
</code></pre><p>试试ArrayList的线程不安全：</p><pre><code class="java">public class Demo &#123;
    //这是main方法，程序的入口
    public static void main(String[] args) &#123;
        //创建一个ArrayList集合：
        ArrayList list = new ArrayList();
        //创建一个线程池：线程池定长100
        ExecutorService es = Executors.newFixedThreadPool(100);
        //并发向集合中添加10000个数据：
        for (int i = 0; i &lt; 10000; i++) &#123;
            //每个线程处理任务：run方法中的内容就是线程单元，任务，实际线程执行的部分
            es.execute(new Runnable() &#123;
                @Override
                public void run() &#123;
                    list.add(&quot;aaa&quot;);
                &#125;
            &#125;);
        &#125;
        //关闭线程池：
        es.shutdown();
        //监控线程是否执行完毕：
        while(true)&#123;
            //线程都执行完以后返回true
            if(es.isTerminated())&#123;
                System.out.println(&quot;所有的子线程都执行完毕了！&quot;);
                //执行完毕以后看一下集合中元素的数量：
                System.out.println(list.size());
                if(list.size() == 10000)&#123;
                    System.out.println(&quot;线程安全！&quot;);
                &#125;else&#123;
                    System.out.println(&quot;线程不安全！&quot;);
                &#125;
                //线程执行完以后，while循环可以停止：
                break;
            &#125;
        &#125;
    &#125;
&#125;
</code></pre><p>结果：</p><img data-src="/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618180549466.png"><p>利用同步类容器解决：</p><pre><code class="java">public class Demo &#123;
    //这是main方法，程序的入口
    public static void main(String[] args) &#123;
        //创建一个ArrayList集合：
        ArrayList oldlist = new ArrayList();
        List list = Collections.synchronizedList(oldlist);
        //创建一个线程池：线程池定长100
        ExecutorService es = Executors.newFixedThreadPool(100);
        //并发向集合中添加10000个数据：
        for (int i = 0; i &lt; 10000; i++) &#123;
            //每个线程处理任务：run方法中的内容就是线程单元，任务，实际线程执行的部分
            es.execute(new Runnable() &#123;
                @Override
                public void run() &#123;
                    list.add(&quot;aaa&quot;);
                &#125;
            &#125;);
        &#125;
        //关闭线程池：
        es.shutdown();
        //监控线程是否执行完毕：
        while(true)&#123;
            //线程都执行完以后返回true
            if(es.isTerminated())&#123;
                System.out.println(&quot;所有的子线程都执行完毕了！&quot;);
                //执行完毕以后看一下集合中元素的数量：
                System.out.println(list.size());
                if(list.size() == 10000)&#123;
                    System.out.println(&quot;线程安全！&quot;);
                &#125;else&#123;
                    System.out.println(&quot;线程不安全！&quot;);
                &#125;
                //线程执行完以后，while循环可以停止：
                break;
            &#125;
        &#125;
    &#125;
&#125;
</code></pre><p>结果：</p><img data-src="/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618180623443.png"><p>源码解析：</p><img data-src="/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618180635090.png"><h2 id="ConcurrentMap并发容器"><a href="#ConcurrentMap并发容器" class="headerlink" title="ConcurrentMap并发容器"></a>ConcurrentMap并发容器</h2><p>JDK5.0之后提供了多种并发类容器可以替代同步类容器，提升性能、吞吐量<br>ConcurrentHashMap替代HashMap、HashTable<br>ConcurrentSkipListMap替代TreeMap</p><p>简单原理：</p><img data-src="/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618180711631.png"><p>并发情况下，验证提高性能：</p><p>ConcunrrentHashMap :</p><pre><code class="java">public class Test &#123;
    //这是main方法，程序的入口
    public static void main(String[] args) &#123;
        //选择一个容器：
        ConcurrentHashMap&lt;String,Integer&gt; map = new ConcurrentHashMap&lt;&gt;();
        
        //创建10个线程：
        for (int i = 0; i &lt; 10; i++) &#123;
            new Thread(new Runnable() &#123;
                @Override
                public void run() &#123;
                    long startTime = System.currentTimeMillis();
                    for (int j = 0; j &lt; 1000000; j++) &#123;
                        map.put(&quot;test&quot; + j , j);
                    &#125;
                    long endTime = System.currentTimeMillis();
                    System.out.println(&quot;一共需要的时间：&quot; + (endTime - startTime));
                &#125;
            &#125;).start();
        &#125;
    &#125;
&#125;
</code></pre><p>结果：</p><img data-src="/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618180735265.png"><p>Hashtable：</p><pre><code class="java">public class Test &#123;
    //这是main方法，程序的入口
    public static void main(String[] args) &#123;
        //选择一个容器：
        //ConcurrentHashMap&lt;String,Integer&gt; map = new ConcurrentHashMap&lt;&gt;();
        Hashtable map = new Hashtable();
        //创建10个线程：
        for (int i = 0; i &lt; 10; i++) &#123;
            new Thread(new Runnable() &#123;
                @Override
                public void run() &#123;
                    long startTime = System.currentTimeMillis();
                    for (int j = 0; j &lt; 1000000; j++) &#123;
                        map.put(&quot;test&quot; + j , j);
                    &#125;
                    long endTime = System.currentTimeMillis();
                    System.out.println(&quot;一共需要的时间：&quot; + (endTime - startTime));
                &#125;
            &#125;).start();
        &#125;
    &#125;
&#125;
</code></pre><img data-src="/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618180757516.png"><p>HashMap：</p><pre><code class="java">public class Test &#123;
    //这是main方法，程序的入口
    public static void main(String[] args) &#123;
        //选择一个容器：
        //ConcurrentHashMap&lt;String,Integer&gt; map = new ConcurrentHashMap&lt;&gt;();
        //Hashtable map = new Hashtable();
        HashMap map = new HashMap();
        //创建10个线程：
        for (int i = 0; i &lt; 10; i++) &#123;
            new Thread(new Runnable() &#123;
                @Override
                public void run() &#123;
                    long startTime = System.currentTimeMillis();
                    for (int j = 0; j &lt; 1000000; j++) &#123;
                        map.put(&quot;test&quot; + j , j);
                    &#125;
                    long endTime = System.currentTimeMillis();
                    System.out.println(&quot;一共需要的时间：&quot; + (endTime - startTime));
                &#125;
            &#125;).start();
        &#125;
    &#125;
&#125;
</code></pre><img data-src="/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618180824896.png"><p>线程安全的HashMap：</p><pre><code class="java">public class Test &#123;
    //这是main方法，程序的入口
    public static void main(String[] args) &#123;
        //选择一个容器：
        //ConcurrentHashMap&lt;String,Integer&gt; map = new ConcurrentHashMap&lt;&gt;();
        //Hashtable map = new Hashtable();
        HashMap oldmap = new HashMap();
        Map map = Collections.synchronizedMap(oldmap);
        //创建10个线程：
        for (int i = 0; i &lt; 10; i++) &#123;
            new Thread(new Runnable() &#123;
                @Override
                public void run() &#123;
                    long startTime = System.currentTimeMillis();
                    for (int j = 0; j &lt; 1000000; j++) &#123;
                        map.put(&quot;test&quot; + j , j);
                    &#125;
                    long endTime = System.currentTimeMillis();
                    System.out.println(&quot;一共需要的时间：&quot; + (endTime - startTime));
                &#125;
            &#125;).start();
        &#125;
    &#125;
&#125;
</code></pre><img data-src="/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618180846459.png"><p>总结：</p><table><thead><tr><th align="center">ConcurrentHashMap</th><th align="center">性能高，线程安全</th></tr></thead><tbody><tr><td align="center">Hashtable: 线程安全</td><td align="center">性能低</td></tr><tr><td align="center">HashMap:线程不安全</td><td align="center">性能高</td></tr></tbody></table><p>线程安全的HashMap：线程安全，性能低</p><h2 id="COW并发容器"><a href="#COW并发容器" class="headerlink" title="COW并发容器"></a>COW并发容器</h2><p>【1】COW类并发容器，全称：Copy On Write容器，写时复制容器。（读写分离容器）</p><p>【2】原理：<br>向容器中添加元素时，先将容器进行Copy复制出一个新容器，然后将元素添加到新容器中，再将原容器的引用指向新容器。<br>并发读的时候不需要锁定容器，因为原容器没有变化，所以可以读取原容器中的值，使用的是一种读写分离的思想。</p><img data-src="/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618181056593.png"><p>【3】这种设计的好处是什么呢？<br>注意上面的操作arr数组本身是无锁的，没有锁，在添加数据的时候，做了额外的复制，<br>此时如果有线程来读数据，那么读取的是老arr的数据，此时arr的地址还没有改呢，在我添加元素的过程中，<br>无论有多少个线程来读数据，都是读的原来的arr，不是新的arr<br>所以性能很高，读写分离。提高了并发的性能。如果再读再复制…</p><p>【4】注意：<br>CopyOnWrite容器只能保证数据的最终一致性，不能保证数据实时一致性。<br>所以如果你希望写入的的数据，马上能读到，请不要使用CopyOnWrite容器。</p><p>【5】适合特定场合：<br>这个应用场景显而易见，适合读多写少的情况。如果一万个线程都添加操作，都在集合中添加数据，那数组不断复制，长度不断+1，<br>那JVM肯定一直往上飙升，你用的时候肯定要评估使用场景的。<br>由于每次更新都会复制新容器，所以如果数据量较大并且更新操作频繁则对内存消耗很高，建议在高并发读的场景下使用。</p><p>【6】主要讲解：<br>COW容器有两种一种是CopyonWriteArrayList，一种是CopyOnWriteArraySet<br>一个是替代ArrayList，一个是代替Set</p><h3 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h3><pre><code class="java">public class Test &#123;
    //这是main方法，程序的入口
    public static void main(String[] args) &#123;
        CopyOnWriteArrayList&lt;Integer&gt; list = new CopyOnWriteArrayList&lt;&gt;();
        //添加方法：
        list.add(1);
        list.add(2);
        list.add(3);
        list.add(4);
        System.out.println(list);//[1, 2, 3, 4]
        list.add(3);//add方法无论元素是否存在，都可以添加进去--》添加重复的元素
        System.out.println(list);//[1, 2, 3, 4, 3]
        //adj. 缺席的；缺少的；心不在焉的；茫然的
        list.addIfAbsent(33);//添加不存在的元素--》不可以添加重复的数据
        System.out.println(list);//[1, 2, 3, 4, 3, 33]
    &#125;
&#125;
</code></pre><p>源码分析：</p><pre><code class="java">public class CopyOnWriteArrayList&lt;E&gt;&#123;
        //底层基于数组实现的
        private transient volatile Object[] array;
        
        public CopyOnWriteArrayList() &#123;
        setArray(new Object[0]);
    &#125;
        
        final void setArray(Object[] a) &#123;
        array = a; // array = new Object[0]
    &#125;
        //add方法：
        public boolean add(E e) &#123;
        final ReentrantLock lock = this.lock;
        lock.lock();
        try &#123;
                        //返回底层array数组,给了elements
            Object[] elements = getArray();
                        //获取elements的长度---》获取老数组的长度
            int len = elements.length;
                        //完成数组的复制，将老数组中的元素复制到新数组中，并且新数组的长度加1操作
            Object[] newElements = Arrays.copyOf(elements, len + 1);
                        //将e元素放入新数组最后位置
            newElements[len] = e;
                        //array数组的指向从老数组变为新数组
            setArray(newElements);
            return true;
        &#125; finally &#123;
            lock.unlock();
        &#125;
    &#125;
        
        
        final Object[] getArray() &#123;
        return array;//返回底层数组
    &#125;
        
        
        private boolean addIfAbsent(E e, Object[] snapshot) &#123;
        final ReentrantLock lock = this.lock;
        lock.lock();
        try &#123;
                        //取出array数组给current
            Object[] current = getArray();
            int len = current.length;
            if (snapshot != current) &#123;
                // Optimize for lost race to another addXXX operation
                int common = Math.min(snapshot.length, len);
                                //遍历老数组：
                for (int i = 0; i &lt; common; i++)
                                        //eq(e, current[i])将放入的元素和老数组的每一个元素进行比较，如果有重复的元素，就返回false，不添加了
                    if (current[i] != snapshot[i] &amp;&amp; eq(e, current[i]))
                        return false;
                if (indexOf(e, current, common, len) &gt;= 0)
                        return false;
            &#125;
                        //完成数组的复制，将老数组中的元素复制到新数组中，并且新数组的长度加1操作
            Object[] newElements = Arrays.copyOf(current, len + 1);
                        //将e元素放入新数组最后位置
            newElements[len] = e;
                        //array数组的指向从老数组变为新数组
            setArray(newElements);
            return true;
        &#125; finally &#123;
            lock.unlock();
        &#125;
    &#125;             
&#125;
</code></pre><h3 id="CopyOnWriteArraySet"><a href="#CopyOnWriteArraySet" class="headerlink" title="CopyOnWriteArraySet"></a>CopyOnWriteArraySet</h3><pre><code class="java">public class Test02 &#123;
    //这是main方法，程序的入口
    public static void main(String[] args) &#123;
        //创建一个集合：
        CopyOnWriteArraySet&lt;Integer&gt; set = new CopyOnWriteArraySet&lt;&gt;();
        //在这里也体现出Set和List的本质区别，就在于是否重复
        //所以add方法直接不可以添加重复数据进去
        set.add(1);
        set.add(2);
        set.add(2);
        set.add(7);
        System.out.println(set);//[1, 2, 7]
        
    &#125;
&#125;
</code></pre><p>源码：</p><pre><code class="java">public class CopyOnWriteArraySet&lt;E&gt;&#123;
        //CopyOnWriteArraySet底层基于CopyOnWriteArrayList
        private final CopyOnWriteArrayList&lt;E&gt; al;
        
        public CopyOnWriteArraySet() &#123;
        al = new CopyOnWriteArrayList&lt;E&gt;();
    &#125;
        
        //添加方法：
        public boolean add(E e) &#123;
        return al.addIfAbsent(e);//底层调用的还是CopyOnWriteArrayList的addIfAbsent
    &#125;
&#125;
</code></pre><p>总结：</p><p>由上面的源码看出，每次调用CopyOnWriteArraySet的add方法时候，其实底层是基于CopyOnWriteArrayList的addIfAbsent，<br>每次在addIfAbsent方法中每次都要对数组进行遍历，所以CopyOnWriteArraySet的性能低于CopyOnWriteArrayList</p><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>数据结构分为：<br>（1）逻辑结构 ：–》思想上的结构–》卧室，厨房，卫生间 —》线性表（数组，链表），图，树，栈，队列<br>（2）物理结构 ：–》真实结构–》钢筋混凝土+牛顿力学——》紧密结构（顺序结构），跳转结构（链式结构）</p><p>队列：特点：先进先出 （FIFO）（first in first out）</p><img data-src="/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618181454201.png"> <img data-src="/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618181504415.png"><p>他有两端，一端是让新元素进去，一端是让老元素出去</p><p>在需要公平且经济地对各种自然或社会资源做管理或分配的场合，无论是调度银行和医院的服务窗口，还是管理轮耕的田地和轮伐的森林，队列都可大显身手。</p><p>甚至计算机及其网络自身内部的各种计算资源，无论是多进程共享的 CPU 时间，还是多用户共享的打印机，也都需要借助队列结构实现合理和优化的分配。</p><p>双端队列：两端都可以进行进队，出队的队列：</p><p>（1）前端，后端都可以进出：</p><img data-src="/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618181511902.png"><p>（2）进行限制：</p><img data-src="/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618181516928.png"><p>（3）特殊情况，双端队列实现栈操作:</p><img data-src="/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618181522040.png"><p>栈和队列的物理结构实现 可以用线性表的数组，链表都可以</p><h2 id="队列Queue"><a href="#队列Queue" class="headerlink" title="队列Queue"></a>队列Queue</h2><h3 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h3><h4 id="BlockingQueue介绍"><a href="#BlockingQueue介绍" class="headerlink" title="BlockingQueue介绍"></a>BlockingQueue介绍</h4><img data-src="/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618181740905.png"><p>总结：BlockingQueue继承Queue，Queue继承自Collection<br>所以Collection最基础的增删改查操作是有的，在这个基础上，多了Queue的特点，在这个基础上又多了阻塞的特点，最终形成了BlockingQueue</p><p>什么叫阻塞？</p><img data-src="/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618181750078.png"> <img data-src="/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618181756012.png"><p>常用的API：<br>添加：</p><img data-src="/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618181825630.png"> <img data-src="/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618181805698.png"> <img data-src="/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618181833424.png"><p>put是阻塞的</p><p>查询：</p><img data-src="/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618181839103.png"> <img data-src="/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618181845214.png"><p>take是阻塞的</p><p>删除：</p><img data-src="/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618181852391.png"><h4 id="常见子类"><a href="#常见子类" class="headerlink" title="常见子类"></a>常见子类</h4><p><a href="#queue_impl1">ArrayBlockingQueue</a></p><p><a href="#queue_impl2">LinkedBlockingQueue</a></p><p><a href="#queue_impl3">SynchronousQueue</a></p><p><a href="#queue_impl4">PriorityBlockingQueue</a></p><p><a href="#queue_impl5">DelayQueue</a></p><div name="queue_impl1"><blockquote><p>ArrayBlockingQueue</p></blockquote><p>源码中的注释的解释说明：</p><img data-src="/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618181949074.png"><p>【1】添加元素：</p><pre><code class="java">public class Test01 &#123;
    //这是main方法，程序的入口
    public static void main(String[] args) throws InterruptedException &#123;
        //创建一个队列，队列可以指定容量指定长度3：
        ArrayBlockingQueue aq = new ArrayBlockingQueue(3);
        //添加元素：
        //【1】添加null元素：不可以添加null元素，会报空指针异常：NullPointerException
        //aq.add(null);
        //aq.offer(null);
        //aq.put(null);
        //【2】正常添加元素：
        aq.add(&quot;aaa&quot;);
        aq.offer(&quot;bbb&quot;);
        aq.put(&quot;ccc&quot;);
        System.out.println(aq);//[aaa, bbb, ccc]
        //【3】在队列满的情况下，再添加元素：
        //aq.add(&quot;ddd&quot;);//在队列满的情况下，添加元素 出现异常：Queue full
        //System.out.println(aq.offer(&quot;ddd&quot;));//没有添加成功，返回false
        //设置最大阻塞时间，如果时间到了，队列还是满的，就不再阻塞了
        //aq.offer(&quot;ddd&quot;,2, TimeUnit.SECONDS);
        //真正阻塞的方法： put ,如果队列满，就永远阻塞 
        aq.put(&quot;ddd&quot;);
        System.out.println(aq);
    &#125;
&#125;
</code></pre><p>【2】获取元素：</p><pre><code class="java">public class Test02 &#123;
    //这是main方法，程序的入口
    public static void main(String[] args) throws InterruptedException &#123;
        //创建一个队列，队列可以指定容量指定长度3：
        ArrayBlockingQueue aq = new ArrayBlockingQueue(3);
        aq.add(&quot;aaa&quot;);
        aq.add(&quot;bbb&quot;);
        aq.add(&quot;ccc&quot;);
        //得到头元素但是不移除
        System.out.println(aq.peek());
        System.out.println(aq);
        //得到头元素并且移除
        System.out.println(aq.poll());
        System.out.println(aq);
        //得到头元素并且移除
        System.out.println(aq.take());
        System.out.println(aq);
        //清空元素：
        aq.clear();
        System.out.println(aq);
        System.out.println(aq.peek());//null
        System.out.println(aq.poll());//null
        //设置阻塞事件，如果队列为空，返回null，时间到了以后就不阻塞了
        //System.out.println(aq.poll(2, TimeUnit.SECONDS));
        //真正阻塞：队列为空，永远阻塞
        System.out.println(aq.take());
    &#125;
&#125;
</code></pre><p>【3】源码：</p><pre><code class="java">public class ArrayBlockingQueue&lt;E&gt; &#123;
        //底层就是一个数组：
        final Object[] items;
        //取元素用到的索引，初始结果为0
        int takeIndex;
        //放元素用到的索引，初始结果为0
        int putIndex;
        //数组中元素的个数：
        int count;
        
        //一把锁：这个锁肯定很多方法中用到了，所以定义为属性，初始化以后可以随时使用
    final ReentrantLock lock;
    //锁伴随的一个等待吃：notEmpty
    private final Condition notEmpty;
    //锁伴随的一个等待吃：notFull
    private final Condition notFull;
        
        //构造器：
        public ArrayBlockingQueue(int capacity) &#123;//传入队列指定的容量
        this(capacity, false);
    &#125;
        
        public ArrayBlockingQueue(int capacity, boolean fair) &#123;//传入队列指定的容量
                //健壮性考虑
        if (capacity &lt;= 0)
            throw new IllegalArgumentException();
                //初始化底层数组
        this.items = new Object[capacity];
                //初始化锁 和  等待队列
        lock = new ReentrantLock(fair);
        notEmpty = lock.newCondition();
        notFull =  lock.newCondition();
    &#125;
        
        //两个基本方法：一个是入队，一个是出队  ，是其他方法的基础：
        //入队：
        private void enqueue(E x) &#123;
        // assert lock.getHoldCount() == 1;
        // assert items[putIndex] == null;
        final Object[] items = this.items;//底层数组赋给items
                //在对应的下标位置放入元素
        items[putIndex] = x;
        if (++putIndex == items.length) //++putIndex putIndex 索引 加1 
            putIndex = 0;
                //每放入一个元素，count加1操作
        count++;
        notEmpty.signal();
    &#125;
        
        
        //出队：
        private E dequeue() &#123;
        // assert lock.getHoldCount() == 1;
        // assert items[takeIndex] != null;
        final Object[] items = this.items;//底层数组赋给items
        @SuppressWarnings(&quot;unchecked&quot;)
        E x = (E) items[takeIndex];//在对应的位置取出元素
        items[takeIndex] = null;//对应位置元素取出后就置为null
        if (++takeIndex == items.length)//++takeIndex 加1操作
            takeIndex = 0;
        count--;//每取出一个元素，count减1操作
        if (itrs != null)
            itrs.elementDequeued();
        notFull.signal();
        return x;//将取出的元素作为方法的返回值
    &#125;       
&#125;
</code></pre><p>takeIndex和putIndex置为0的原因：</p><img data-src="/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618182045354.png"><p>【4】其他的添加或者获取的方法都是依托与这个入队和出队的基础方法</p><img data-src="/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618182053419.png"><p>【5】感受一下put和take的阻塞：</p><img data-src="/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618182101129.png"><p>上面的while不可以换为if，因为如果notFull中的线程被激活的瞬间，有其他线程放入元素，那么队列就又满了<br>那么沿着await后面继续执行就不可以，所以一定要反复确定队列是否满的，才能放入元素</p><div name="queue_impl2"><blockquote><p>LinkedBlockingQueue</p></blockquote><p>一个可选择的有边界的队列：意思就是队列的长度可以指定，也可以不指定</p><img data-src="/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618182251224.png"><p>【1】添加元素：</p><pre><code class="java">public class Test01 &#123;
    //这是main方法，程序的入口
    public static void main(String[] args) throws InterruptedException &#123;
        //创建一个队列，队列可以指定容量指定长度3：
        LinkedBlockingQueue aq = new LinkedBlockingQueue(3);
        //添加元素：
        //【1】添加null元素：不可以添加null元素，会报空指针异常：NullPointerException
        //aq.add(null);
        //aq.offer(null);
        aq.put(null);
        //【2】正常添加元素：
        aq.add(&quot;aaa&quot;);
        aq.offer(&quot;bbb&quot;);
        aq.put(&quot;ccc&quot;);
        System.out.println(aq);//[aaa, bbb, ccc]
        //【3】在队列满的情况下，再添加元素：
        //aq.add(&quot;ddd&quot;);//在队列满的情况下，添加元素 出现异常：Queue full
        //System.out.println(aq.offer(&quot;ddd&quot;));//没有添加成功，返回false
        //设置最大阻塞时间，如果时间到了，队列还是满的，就不再阻塞了
        //aq.offer(&quot;ddd&quot;,2, TimeUnit.SECONDS);
        //真正阻塞的方法： put ,如果队列满，就永远阻塞
        aq.put(&quot;ddd&quot;);
        System.out.println(aq);
    &#125;
&#125;
</code></pre><p>【2】取出元素：</p><pre><code class="java">public class Test02 &#123;
    //这是main方法，程序的入口
    public static void main(String[] args) throws InterruptedException &#123;
        //创建一个队列，队列可以指定容量指定长度3：
        LinkedBlockingQueue aq = new LinkedBlockingQueue();
        aq.add(&quot;aaa&quot;);
        aq.add(&quot;bbb&quot;);
        aq.add(&quot;ccc&quot;);
        //得到头元素但是不移除
        System.out.println(aq.peek());
        System.out.println(aq);
        //得到头元素并且移除
        System.out.println(aq.poll());
        System.out.println(aq);
        //得到头元素并且移除
        System.out.println(aq.take());
        System.out.println(aq);
        //清空元素：
        aq.clear();
        System.out.println(aq);
        System.out.println(aq.peek());//null
        System.out.println(aq.poll());//null
        //设置阻塞事件，如果队列为空，返回null，时间到了以后就不阻塞了
        //System.out.println(aq.poll(2, TimeUnit.SECONDS));
        //真正阻塞：队列为空，永远阻塞
        System.out.println(aq.take());
    &#125;
&#125;
</code></pre><p>【3】特点：<br>ArrayBlockingQueue ： 不支持读写同时操作，底层基于数组的。<br>LinkedBlockingQueue：支持读写同时操作，并发情况下，效率高。底层基于链表。</p><p>【4】源码：<br>入队操作：</p><img data-src="/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618182330212.png"><p>出队操作：</p><img data-src="/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618182341368.png"><pre><code class="java">public class LinkedBlockingQueue&lt;E&gt;&#123;
        //内部类Node就是链表的节点的对象对应的类：
        static class Node&lt;E&gt; &#123;
        E item;//封装你要装的那个元素
        
        Node&lt;E&gt; next;//下一个Node节点的地址
        Node(E x) &#123; item = x; &#125;//构造器
    &#125;
        //链表的长度
        private final int capacity;
        //计数器：
        private final AtomicInteger count = new AtomicInteger();
        //链表的头结点
        transient Node&lt;E&gt; head;
        //链表的尾结点
        private transient Node&lt;E&gt; last;
        //取元素用的锁
        private final ReentrantLock takeLock = new ReentrantLock();
        //等待池
    private final Condition notEmpty = takeLock.newCondition();
    //放元素用的锁
    private final ReentrantLock putLock = new ReentrantLock();
    //等待池
    private final Condition notFull = putLock.newCondition();
        
        public LinkedBlockingQueue() &#123;
        this(Integer.MAX_VALUE);//调用类本类的空构造器，传入正21亿
    &#125;
        
        public LinkedBlockingQueue(int capacity) &#123;
                //健壮性考虑
        if (capacity &lt;= 0) throw new IllegalArgumentException();
                //给队列指定长度  
        this.capacity = capacity;
                //last，head指向一个新的节点，新的节点中 元素为null 
        last = head = new Node&lt;E&gt;(null);
    &#125;
        
        
        //入队：
        private void enqueue(Node&lt;E&gt; node) &#123;
        last = last.next = node;
    &#125;
        
        //出队：
        private E dequeue() &#123;
        Node&lt;E&gt; h = head;//h指向了head
        Node&lt;E&gt; first = h.next;//first 指向head的next
        h.next = h; // help GC   h.next指向自己，更容易被GC发现 被GC
        head = first;//head的指向指为first
        E x = first.item;//取出链中第一个元素，给了x
        first.item = null;
        return x;//把x作为方法的返回值
    &#125;
&#125;
</code></pre><p>【5】put的阻塞：</p><p>阻塞的前提是 队列是固定长度的</p><img data-src="/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618182407325.png"><div name="queue_impl3"><blockquote><p>SynchronousQueue</p></blockquote><img data-src="/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618182455703.png"><p>这个特殊的队列设计的意义：</p><img data-src="/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618182515070.png"><p>测试1：先添加元素：</p><pre><code class="java">public class Test01 &#123;
    //这是main方法，程序的入口
    public static void main(String[] args) &#123;
        SynchronousQueue sq = new SynchronousQueue();
        sq.add(&quot;aaa&quot;);
    &#125;
&#125;
</code></pre><p>直接报错：说队列满了，因为队列没有容量，理解为满也是正常的：</p><img data-src="/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618182535474.png"><p>测试2：put方法 阻塞：队列是空的，可以理解为队列满了，满的话放入元素 put 一定会阻塞：</p><pre><code class="java">public class Test01 &#123;
    //这是main方法，程序的入口
    public static void main(String[] args) throws InterruptedException &#123;
        SynchronousQueue sq = new SynchronousQueue();
        sq.put(&quot;aaa&quot;);
    &#125;
&#125;
</code></pre><img data-src="/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618182600030.png"><p>测试3：先取 再放：</p><pre><code class="java">public class Test02 &#123;
    //这是main方法，程序的入口
    public static void main(String[] args) &#123;
        SynchronousQueue sq = new SynchronousQueue();
        //创建一个线程，取数据：
        new Thread(new Runnable() &#123;
            @Override
            public void run() &#123;
                while(true)&#123;
                    try &#123;
                        System.out.println(sq.take());
                    &#125; catch (InterruptedException e) &#123;
                        e.printStackTrace();
                    &#125;
                &#125;
            &#125;
        &#125;).start();
        //搞一个线程，往里面放数据：
        new Thread(new Runnable() &#123;
            @Override
            public void run() &#123;
                try &#123;
                    sq.put(&quot;aaa&quot;);
                    sq.put(&quot;bbb&quot;);
                    sq.put(&quot;ccc&quot;);
                    sq.put(&quot;ddd&quot;);
                &#125; catch (InterruptedException e) &#123;
                    e.printStackTrace();
                &#125;
            &#125;
        &#125;).start();
    &#125;
&#125;
</code></pre><img data-src="/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618182625271.png"><p>测试4：poll方法：</p><pre><code class="java">public class Test02 &#123;
    //这是main方法，程序的入口
    public static void main(String[] args) &#123;
        SynchronousQueue sq = new SynchronousQueue();
        //创建一个线程，取数据：
        new Thread(new Runnable() &#123;
            @Override
            public void run() &#123;
                while(true)&#123;
                    try &#123;
                        //设置一个阻塞事件：超出事件就不阻塞了
                        Object result = sq.poll(5, TimeUnit.SECONDS);
                        System.out.println(result);
                        if(result == null)&#123;
                            break;
                        &#125;
                    &#125; catch (InterruptedException e) &#123;
                        e.printStackTrace();
                    &#125;
                &#125;
            &#125;
        &#125;).start();
        //搞一个线程，往里面放数据：
        new Thread(new Runnable() &#123;
            @Override
            public void run() &#123;
                try &#123;
                    sq.put(&quot;aaa&quot;);
                    sq.put(&quot;bbb&quot;);
                    sq.put(&quot;ccc&quot;);
                    sq.put(&quot;ddd&quot;);
                &#125; catch (InterruptedException e) &#123;
                    e.printStackTrace();
                &#125;
            &#125;
        &#125;).start();
    &#125;
&#125;
</code></pre><img data-src="/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618182647289.png"><p>注意：取出元素 不能用peek，因为peek不会将元素从队列中拿走，只是查看的效果；</p><div name="queue_impl4"><blockquote><p>PriorityBlockingQueue</p></blockquote><p>带有优先级的阻塞队列。<br>优先级队列，意味着队列有先后顺序的，数据有不同的权重。</p><p>无界的队列，没有长度限制，但是在你不指定长度的时候，默认初始长度为11，也可以手动指定，<br>当然随着数据不断的加入，底层（底层是数组Object[]）会自动扩容，直到内存全部消耗殆尽了，导致 OutOfMemoryError内存溢出 程序才会结束。</p><img data-src="/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618183001941.png"><p>不可以放入null元素的，不允许放入不可比较的对象（导致抛出ClassCastException），对象必须实现内部比较器或者外部比较器。</p><p>测试1：添加null数据：</p><pre><code class="java">public class Test &#123;
    //这是main方法，程序的入口
    public static void main(String[] args) &#123;
        PriorityBlockingQueue pq = new PriorityBlockingQueue();
        pq.put(null);
    &#125;
&#125;
</code></pre><img data-src="/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618183016134.png"><p>测试2：添加四个数据：</p><pre><code class="java">public class Student implements Comparable&lt;Student&gt; &#123;
    String name;
    int age;
    public Student() &#123;
    &#125;
    public Student(String name, int age) &#123;
        this.name = name;
        this.age = age;
    &#125;
    @Override
    public String toString() &#123;
        return &quot;Student&#123;&quot; +
                &quot;name=&#39;&quot; + name + &#39;\&#39;&#39; +
                &quot;, age=&quot; + age +
                &#39;&#125;&#39;;
    &#125;
    @Override
    public int compareTo(Student o) &#123;
        return this.age - o.age;
    &#125;
&#125;
</code></pre><pre><code class="java">public class Test02 &#123;
    //这是main方法，程序的入口
    public static void main(String[] args) &#123;
        PriorityBlockingQueue&lt;Student&gt; pq = new PriorityBlockingQueue&lt;&gt;();
        pq.put(new Student(&quot;nana&quot;,18));
        pq.put(new Student(&quot;lulu&quot;,11));
        pq.put(new Student(&quot;feifei&quot;,6));
        pq.put(new Student(&quot;mingming&quot;,21));
        System.out.println(pq);
    &#125;
&#125;
</code></pre><p>结果</p><img data-src="/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618183048547.png"><p>发现结果并没有按照优先级顺序排列</p><p>测试3：取出数据：</p><pre><code class="java">public class Test02 &#123;
    //这是main方法，程序的入口
    public static void main(String[] args) throws InterruptedException &#123;
        PriorityBlockingQueue&lt;Student&gt; pq = new PriorityBlockingQueue&lt;&gt;();
        pq.put(new Student(&quot;nana&quot;,18));
        pq.put(new Student(&quot;lulu&quot;,11));
        pq.put(new Student(&quot;feifei&quot;,6));
        pq.put(new Student(&quot;mingming&quot;,21));
        System.out.println(&quot;------------------------------------------&quot;);
        System.out.println(pq.take());
        System.out.println(pq.take());
        System.out.println(pq.take());
        System.out.println(pq.take());
    &#125;
&#125;
</code></pre><img data-src="/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618183114429.png"><p>从结果证明，这个优先级队列，并不是在put数据的时候计算谁在前谁在后<br>而是取数据的时候，才真正判断谁在前 谁在后</p><p>优先级 –》取数据的优先级</p><div name="queue_impl5"><blockquote><p>DelayQueue</p></blockquote><p>一、DelayQueue是什么<br>DelayQueue是一个无界的BlockingQueue，用于放置实现了Delayed接口的对象，其中的对象只能在其到期时才能从队列中取走。</p><img data-src="/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618183216715.png"><p>​ 当生产者线程调用put之类的方法加入元素时，会触发Delayed接口中的compareTo方法进行排序，也就是说队列中元素的顺序是按到期时间排序的，而非它们进入队列的顺序。排在队列头部的元素是最早到期的，越往后到期时间赿晚。</p><p>消费者线程查看队列头部的元素，注意是查看不是取出。然后调用元素的getDelay方法，如果此方法返回的值小０或者等于０，则消费者线程会从队列中取出此元素，并进行处理。如果getDelay方法返回的值大于0，则消费者线程wait返回的时间值后，再从队列头部取出元素，此时元素应该已经到期。</p><p>​	注意：不能将null元素放置到这种队列中。</p><p>二、DelayQueue能做什么</p><ol><li><p>淘宝订单业务:下单之后如果三十分钟之内没有付款就自动取消订单。</p></li><li><p>饿了吗订餐通知:下单成功后60s之后给用户发送短信通知。</p></li><li><p>关闭空闲连接。服务器中，有很多客户端的连接，空闲一段时间之后需要关闭之。</p></li><li><p>缓存。缓存中的对象，超过了空闲时间，需要从缓存中移出。</p></li><li><p>任务超时处理。在网络协议滑动窗口请求应答式交互时，处理超时未响应的请求等。</p></li></ol><p>案例：</p><pre><code class="java">public class User implements Delayed &#123;
    private int id;//用户id
    private String name;//用户名字
    private long endTime;//结束时间
    public int getId() &#123;
        return id;
    &#125;
    public void setId(int id) &#123;
        this.id = id;
    &#125;
    public String getName() &#123;
        return name;
    &#125;
    public void setName(String name) &#123;
        this.name = name;
    &#125;
    public long getEndTime() &#123;
        return endTime;
    &#125;
    public void setEndTime(long endTime) &#123;
        this.endTime = endTime;
    &#125;
    public User(int id, String name, long endTime) &#123;
        this.id = id;
        this.name = name;
        this.endTime = endTime;
    &#125;
    //只包装用户名字就可以
    @Override
    public String toString() &#123;
        return &quot;User&#123;&quot; +
                &quot;name=&#39;&quot; + name + &#39;\&#39;&#39; +
                &#39;&#125;&#39;;
    &#125;
    @Override
    public long getDelay(TimeUnit unit) &#123;
        //计算剩余时间 剩余时间小于0 &lt;=0  证明已经到期
        return this.getEndTime() - System.currentTimeMillis();
    &#125;
    @Override
    public int compareTo(Delayed o) &#123;
        //队列中数据 到期时间的比较
        User other = (User)o;
        return ((Long)(this.getEndTime())).compareTo((Long)(other.getEndTime()));
    &#125;
&#125;
</code></pre><p>compareTo：看谁先被移除<br>getDelay ：看剩余时间</p><pre><code class="java">public class TestDelayQueue &#123;
    //创建一个队列：
    DelayQueue&lt;User&gt; dq = new DelayQueue&lt;&gt;();
    //登录游戏：
    public void login(User user)&#123;
        dq.add(user);
        System.out.println(&quot;用户：[&quot; + user.getId() +&quot;],[&quot; + user.getName() + &quot;]已经登录，预计下机时间为：&quot; + user.getEndTime() );
    &#125;
    //时间到，退出游戏，队列中移除：
    public void logout()&#123;
        //打印队列中剩余的人：
        System.out.println(dq);
        try &#123;
            User user = dq.take();
            System.out.println(&quot;用户：[&quot; + user.getId() +&quot;],[&quot; + user.getName() + &quot;]上机时间到，自动退出游戏&quot;);
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
    //获取在线人数：
    public int onlineSize()&#123;
        return dq.size();
    &#125;
    //这是main方法，程序的入口
    public static void main(String[] args) &#123;
        //创建测试类对象：
        TestDelayQueue test = new TestDelayQueue();
        //添加登录的用户：
        test.login(new User(1,&quot;张三&quot;,System.currentTimeMillis()+5000));
        test.login(new User(2,&quot;李四&quot;,System.currentTimeMillis()+2000));
        test.login(new User(3,&quot;王五&quot;,System.currentTimeMillis()+10000));
        //一直监控
        while(true)&#123;
            //到期的话，就自动下线：
            test.logout();
            //队列中元素都被移除了的话，那么停止监控，停止程序即可
            if(test.onlineSize() == 0)&#123;
                break;
            &#125;
        &#125;
    &#125;
&#125;
</code></pre><img data-src="/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618183342855.png"><h3 id="双端队列Deque"><a href="#双端队列Deque" class="headerlink" title="双端队列Deque"></a>双端队列Deque</h3><pre><code class="java">public class Test03 &#123;
    //这是main方法，程序的入口
    public static void main(String[] args) &#123;
        /*
        双端队列：
        Deque&lt;E&gt; extends Queue
        Queue一端放 一端取的基本方法  Deque是具备的
        在此基础上 又扩展了 一些 头尾操作（添加，删除，获取）的方法
         */
        Deque&lt;String&gt; d = new LinkedList&lt;&gt;() ;
        d.offer(&quot;A&quot;);
        d.offer(&quot;B&quot;);
        d.offer(&quot;C&quot;);
        System.out.println(d);//[A, B, C]
        d.offerFirst(&quot;D&quot;);
        d.offerLast(&quot;E&quot;);
        System.out.println(d);//[D, A, B, C, E]
        System.out.println(d.poll());
        System.out.println(d);//[A, B, C, E]
        System.out.println(d.pollFirst());
        System.out.println(d.pollLast());
        System.out.println(d);
    &#125;
&#125;
</code></pre><div class="tags"><a href="/tags/JavaSE/" rel="tag"><i class="ic i-tag"></i> JavaSE</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2022-10-08 00:09:13" itemprop="dateModified" datetime="2022-10-08T00:09:13+08:00">2022-10-08</time></span></div><div class="reward"><button><i class="ic i-heartbeat"></i> 赞赏</button><p>请我喝[茶]~(￣▽￣)~*</p><div id="qr"><div><img data-src="/images/wechatpay.png" alt="雾都 微信支付"><p>微信支付</p></div><div><img data-src="/images/alipay.png" alt="雾都 支付宝"><p>支付宝</p></div><div><img data-src="/images/paypal.png" alt="雾都 贝宝"><p>贝宝</p></div></div></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>雾都 <i class="ic i-at"><em>@</em></i>记录 “美食” 每刻</li><li class="link"><strong>本文链接：</strong> <a href="http://example.com/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/" title="第 11 章集合">http://example.com/2022/10/07/Java/第11章集合/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></div></div></div></div></div></article></div><div class="post-nav"><div class="item left"><a href="/2022/10/07/Java/%E7%AC%AC12%E7%AB%A0IO/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;tva3.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1gicm07ih54j20zk0m84qp.jpg" title="第12章IO"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> IO</span><h3>第12章IO</h3></a></div><div class="item right"><a href="/2022/10/07/Java/%E7%AC%AC10%E7%AB%A0_%E5%B8%B8%E7%94%A8%E7%B1%BB/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;tva3.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1giclxxcb6rj20zk0m8b29.jpg" title="第10章_常用类"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i> 常用类</span><h3>第10章_常用类</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#11-%E9%9B%86%E5%90%88"><span class="toc-number">1.</span> <span class="toc-text">11 集合</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Colletion%E6%8E%A5%E5%8F%A3"><span class="toc-number">2.</span> <span class="toc-text">Colletion接口</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">2.1.</span> <span class="toc-text">1.1 常用方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-Collection%E9%9B%86%E5%90%88%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-number">2.2.</span> <span class="toc-text">1.2 Collection集合的遍历</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-List%E6%8E%A5%E5%8F%A3"><span class="toc-number">2.3.</span> <span class="toc-text">2 List接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E5%92%8C%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F"><span class="toc-number">2.3.1.</span> <span class="toc-text">2.1 常用方法和遍历方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-ArrayList%E5%AE%9E%E7%8E%B0%E7%B1%BB%EF%BC%88JDK1-7%EF%BC%89"><span class="toc-number">2.3.2.</span> <span class="toc-text">2.2 ArrayList实现类（JDK1.7）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-ArrayList%E5%AE%9E%E7%8E%B0%E7%B1%BB%EF%BC%88JDK1-8%EF%BC%89"><span class="toc-number">2.3.3.</span> <span class="toc-text">2.3 ArrayList实现类（JDK1.8）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-Vector%E5%AE%9E%E7%8E%B0%E7%B1%BB"><span class="toc-number">2.3.4.</span> <span class="toc-text">2.4 Vector实现类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-%E6%B3%9B%E5%9E%8B"><span class="toc-number">2.3.5.</span> <span class="toc-text">2.5 泛型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-1-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%9B%E5%9E%8B%E7%BB%93%E6%9E%84"><span class="toc-number">2.3.5.1.</span> <span class="toc-text">2.5.1 自定义泛型结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-2-%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95"><span class="toc-number">2.3.5.2.</span> <span class="toc-text">2.5.2 泛型方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-3-%E6%B3%9B%E5%9E%8B%E5%8F%82%E6%95%B0%E5%AD%98%E5%9C%A8%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB%E7%9A%84%E6%83%85%E5%86%B5"><span class="toc-number">2.3.5.3.</span> <span class="toc-text">2.5.3 泛型参数存在继承关系的情况</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-4-%E9%80%9A%E9%85%8D%E7%AC%A6"><span class="toc-number">2.3.5.4.</span> <span class="toc-text">2.5.4 通配符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-5-%E4%BD%BF%E7%94%A8%E9%80%9A%E9%85%8D%E7%AC%A6%E5%90%8E%E7%9A%84%E7%BB%86%E8%8A%82"><span class="toc-number">2.3.5.5.</span> <span class="toc-text">2.5.5 使用通配符后的细节</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-6-%E6%B3%9B%E5%9E%8B%E5%8F%97%E9%99%90"><span class="toc-number">2.3.5.6.</span> <span class="toc-text">2.5.6 泛型受限</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-LinkedList%E5%AE%9E%E7%8E%B0%E7%B1%BB"><span class="toc-number">2.3.6.</span> <span class="toc-text">2.6 LinkedList实现类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-6-1-%E5%9F%BA%E6%9C%AC%E6%96%B9%E6%B3%95%E4%BD%BF%E7%94%A8"><span class="toc-number">2.3.6.1.</span> <span class="toc-text">2.6.1 基本方法使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-6-2-%E7%AE%80%E8%A6%81%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E5%9B%BE"><span class="toc-number">2.3.6.2.</span> <span class="toc-text">2.6.2 简要底层原理图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-6-3-%E6%A8%A1%E6%8B%9FLinkedList%E6%BA%90%E7%A0%81"><span class="toc-number">2.3.6.3.</span> <span class="toc-text">2.6.3 模拟LinkedList源码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-6-4-LinkedList%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90"><span class="toc-number">2.3.6.4.</span> <span class="toc-text">2.6.4 LinkedList源码解析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A"><span class="toc-number">2.3.7.</span> <span class="toc-text">面试题：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-Set%E6%8E%A5%E5%8F%A3"><span class="toc-number">2.4.</span> <span class="toc-text">3 Set接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-HashSet%E5%AE%9E%E7%8E%B0%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">2.4.1.</span> <span class="toc-text">3.1 HashSet实现类的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2LinkedHashSet%E4%BD%BF%E7%94%A8"><span class="toc-number">2.4.2.</span> <span class="toc-text">3.2LinkedHashSet使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E6%AF%94%E8%BE%83%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">2.4.3.</span> <span class="toc-text">3.3 比较器的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-TreeSet%E5%AE%9E%E7%8E%B0%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">2.4.4.</span> <span class="toc-text">3.4 TreeSet实现类的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-Collection%E9%83%A8%E5%88%86%E6%95%B4%E4%BD%93%E7%BB%93%E6%9E%84%E5%9B%BE"><span class="toc-number">2.4.5.</span> <span class="toc-text">3.5 Collection部分整体结构图</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Map%E6%8E%A5%E5%8F%A3"><span class="toc-number">3.</span> <span class="toc-text">Map接口</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">3.1.</span> <span class="toc-text">1 常用方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-TreeMap"><span class="toc-number">3.2.</span> <span class="toc-text">2 TreeMap</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-Map%E9%83%A8%E5%88%86%E6%95%B4%E4%BD%93%E7%BB%93%E6%9E%84%E5%9B%BE"><span class="toc-number">3.3.</span> <span class="toc-text">3 Map部分整体结构图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E6%BA%90%E7%A0%81%E9%83%A8%E5%88%86"><span class="toc-number">3.4.</span> <span class="toc-text">4 源码部分</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-HashMap"><span class="toc-number">3.4.1.</span> <span class="toc-text">4.1 HashMap</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-1-%E4%BB%A3%E7%A0%81%E5%B1%95%E7%A4%BA%E7%89%B9%E6%80%A7"><span class="toc-number">3.4.1.1.</span> <span class="toc-text">4.1.1 代码展示特性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-2-%E5%85%88%E6%BC%94%E7%A4%BA%E5%8E%9F%E7%90%86"><span class="toc-number">3.4.1.2.</span> <span class="toc-text">4.1.2 先演示原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-3-%E6%BA%90%E7%A0%81%EF%BC%88JDK1-7%E7%89%88%E6%9C%AC%EF%BC%89"><span class="toc-number">3.4.1.3.</span> <span class="toc-text">4.1.3 源码（JDK1.7版本）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-4-%E7%BB%86%E8%8A%82%E8%AE%B2%E8%A7%A3%EF%BC%9A%E4%B8%BB%E6%95%B0%E7%BB%84%E7%9A%84%E9%95%BF%E5%BA%A6%E4%B8%BA2%E7%9A%84%E5%80%8D%E6%95%B0"><span class="toc-number">3.4.1.4.</span> <span class="toc-text">4.1.4 细节讲解：主数组的长度为2的倍数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-5-%E7%BB%86%E8%8A%82%E8%AE%B2%E8%A7%A3%EF%BC%9A%E8%A3%85%E5%A1%AB%E5%9B%A0%E5%AD%900-75%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="toc-number">3.4.1.5.</span> <span class="toc-text">4.1.5 细节讲解：装填因子0.75的原因</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-8%E5%BA%95%E5%B1%82%E9%81%B5%E7%85%A7-%E5%93%88%E5%B8%8C%E8%A1%A8%E7%BB%93%E6%9E%84-%E7%BA%A2%E9%BB%91%E6%A0%91"><span class="toc-number">3.5.</span> <span class="toc-text">1.8底层遵照 哈希表结构 + 红黑树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-6-HashSet%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86"><span class="toc-number">3.5.0.1.</span> <span class="toc-text">4.1.6 HashSet底层原理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2TreeMap"><span class="toc-number">3.5.1.</span> <span class="toc-text">4.2TreeMap</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#TreeSet%E6%BA%90%E7%A0%81"><span class="toc-number">3.5.1.1.</span> <span class="toc-text">TreeSet源码</span></a></li></ol></li></ol></li></ol><li class="toc-item toc-level-1"><a class="toc-link" href="#Collections%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="toc-number">4.</span> <span class="toc-text">Collections工具类</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">5.</span> <span class="toc-text">数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%88"><span class="toc-number">5.1.</span> <span class="toc-text">栈</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E7%B1%BB%E5%AE%B9%E5%99%A8"><span class="toc-number">5.2.</span> <span class="toc-text">同步类容器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ConcurrentMap%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8"><span class="toc-number">5.3.</span> <span class="toc-text">ConcurrentMap并发容器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#COW%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8"><span class="toc-number">5.4.</span> <span class="toc-text">COW并发容器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CopyOnWriteArrayList"><span class="toc-number">5.4.1.</span> <span class="toc-text">CopyOnWriteArrayList</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CopyOnWriteArraySet"><span class="toc-number">5.4.2.</span> <span class="toc-text">CopyOnWriteArraySet</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%9F%E5%88%97"><span class="toc-number">5.5.</span> <span class="toc-text">队列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%9F%E5%88%97Queue"><span class="toc-number">5.6.</span> <span class="toc-text">队列Queue</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97"><span class="toc-number">5.6.1.</span> <span class="toc-text">阻塞队列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#BlockingQueue%E4%BB%8B%E7%BB%8D"><span class="toc-number">5.6.1.1.</span> <span class="toc-text">BlockingQueue介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E5%AD%90%E7%B1%BB"><span class="toc-number">5.6.1.2.</span> <span class="toc-text">常见子类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97Deque"><span class="toc-number">5.6.2.</span> <span class="toc-text">双端队列Deque</span></a></li></ol></li></ol></li></div><div class="related panel pjax" data-title="系列文章"><ul><li class="active"><a href="/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/" rel="bookmark" title="第11章集合">第11章集合</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="雾都" data-src="/images/avatar.jpg"><p class="name" itemprop="name">雾都</p><div class="description" itemprop="description">记录 “美食” 每刻</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">56</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">38</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">20</span> <span class="name">标签</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL29ubHltYXJyeXU=" title="https:&#x2F;&#x2F;github.com&#x2F;onlymarryu"><i class="ic i-github"></i></span> <span class="exturl item CSDN" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JraG9sZT9zcG09MTAwMC4yMTE1LjMwMDEuNTM0Mw==" title="https:&#x2F;&#x2F;blog.csdn.net&#x2F;Bkhole?spm&#x3D;1000.2115.3001.5343"><i class="ic i-CSDN"></i></span> <span class="exturl item fengye" data-url="aHR0cHM6Ly9jbG91ZC5meW5vdGUuY29tL2VkaXQ/bmlkPTExMzc5NiZpZD0xNTY3NTI4MDE2MzQ1NTYzMTM2JnQ9MTY2NTgxNjM0NTU4Nw==" title="https:&#x2F;&#x2F;cloud.fynote.com&#x2F;edit?nid&#x3D;113796&amp;id&#x3D;1567528016345563136&amp;t&#x3D;1665816345587"><i class="ic i-fengye"></i></span> <span class="exturl item yuque" data-url="aHR0cHM6Ly93d3cueXVxdWUuY29tL2Rhc2hib2FyZC9yZWNlbnQ=" title="https:&#x2F;&#x2F;www.yuque.com&#x2F;dashboard&#x2F;recent"><i class="ic i-yuque"></i></span> <span class="exturl item music" data-url="aHR0cHM6Ly9tdXNpYy4xNjMuY29tLyMvbXkvbS9tdXNpYy9wbGF5bGlzdD9pZD0zMTY2MDYwNzkw" title="https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;my&#x2F;m&#x2F;music&#x2F;playlist?id&#x3D;3166060790"><i class="ic i-cloud-music"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li><li class="item"><a href="/friends/" rel="section"><i class="ic i-heart"></i>friends</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/2022/10/07/Java/%E7%AC%AC12%E7%AB%A0IO/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/2022/10/07/Java/%E7%AC%AC10%E7%AB%A0_%E5%B8%B8%E7%94%A8%E7%B1%BB/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/%E5%B7%A5%E5%85%B7%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/" title="分类于 工具软件安装">工具软件安装</a></div><span><a href="/2022/10/15/tools/RabbitMQ-tool/" title="RabbitMQ">RabbitMQ</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/" title="分类于 分布式">分布式</a> <i class="ic i-angle-right"></i> <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/Dubbo/" title="分类于 Dubbo">Dubbo</a></div><span><a href="/2022/10/07/Distribution/Dubbo/" title="Dubbo">Dubbo</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/" title="分类于 分布式">分布式</a> <i class="ic i-angle-right"></i> <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/FastDFS/" title="分类于 FastDFS">FastDFS</a></div><span><a href="/2022/10/07/Distribution/FastDFS/" title="FastDFS">FastDFS</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/" title="分类于 分布式">分布式</a> <i class="ic i-angle-right"></i> <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/RabbitMQ/" title="分类于 RabbitMQ">RabbitMQ</a></div><span><a href="/2022/10/07/Distribution/RabbitMQ/" title="RabbitMQ">RabbitMQ</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E5%B7%A5%E5%85%B7%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/" title="分类于 工具软件安装">工具软件安装</a></div><span><a href="/2022/10/15/tools/Maven-tool/" title="Maven-tool">Maven-tool</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E5%B7%A5%E5%85%B7%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/" title="分类于 工具软件安装">工具软件安装</a></div><span><a href="/2022/10/15/tools/Erlang-tool/" title="Erlang">Erlang</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E5%B7%A5%E5%85%B7%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/" title="分类于 工具软件安装">工具软件安装</a></div><span><a href="/2022/10/15/tools/Zookeeper-tool/" title="Zookeeper">Zookeeper</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/JavaSE/" title="分类于 JavaSE">JavaSE</a> <i class="ic i-angle-right"></i> <a href="/categories/JavaSE/%E9%9B%86%E5%90%88/" title="分类于 集合">集合</a></div><span><a href="/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/" title="第11章集合">第11章集合</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/JavaSE/" title="分类于 JavaSE">JavaSE</a> <i class="ic i-angle-right"></i> <a href="/categories/JavaSE/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/" title="分类于 数据类型">数据类型</a></div><span><a href="/2022/10/07/Java/%E7%AC%AC2%E7%AB%A0_%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/" title="第2章_数据类型">第2章_数据类型</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E5%B7%A5%E5%85%B7%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/" title="分类于 工具软件安装">工具软件安装</a></div><span><a href="/2022/10/15/tools/docker-tool/" title="docker安装">docker安装</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2010 – <span itemprop="copyrightYear">2022</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">雾都 @ 雾都博客</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="站点总字数">774k 字</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="站点阅读时长">11:44</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"2022/10/07/Java/第11章集合/",favicon:{show:"（●´3｀●）やれやれだぜ",hide:"(´Д｀)大変だ！"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,audio:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html><!-- rebuild by hrmmi -->