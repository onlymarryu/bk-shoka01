<!-- build time:Tue Oct 18 2022 20:23:03 GMT+0800 (中国标准时间) --><!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="记录“美食”每刻" href="http://example.com/rss.xml"><link rel="alternate" type="application/atom+xml" title="记录“美食”每刻" href="http://example.com/atom.xml"><link rel="alternate" type="application/json" title="记录“美食”每刻" href="http://example.com/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="框架,ORM"><link rel="canonical" href="http://example.com/2022/10/07/ORM/Mybatis/"><title>Mybatis - Mybatis | 雾都博客 = 记录 “美食” 每刻</title><meta name="generator" content="Hexo 6.3.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">Mybatis</h1><div class="meta"><span class="item" title="创建时间：2022-10-07 00:00:00"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2022-10-07T00:00:00+08:00">2022-10-07</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>66k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>1:01</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">雾都博客</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1gipetfk5zwj20zk0m8e81.jpg"></li><li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1giclj9410cj20zk0m8h12.jpg"></li><li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1giclhnx9glj20zk0m8npd.jpg"></li><li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1giclh0m9pdj20zk0m8hdt.jpg"></li><li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1gipeybxm1pj20zk0m8niv.jpg"></li><li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1gicitcxhpij20zk0m8hdt.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/Mybatis/" itemprop="item" rel="index" title="分类于 Mybatis"><span itemprop="name">Mybatis</span></a><meta itemprop="position" content="1"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://example.com/2022/10/07/ORM/Mybatis/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="雾都"><meta itemprop="description" content=", 记录 “美食” 每刻"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="记录 “美食” 每刻"></span><div class="body md" itemprop="articleBody"><h1 id="1-Mybatis入门"><a href="#1-Mybatis入门" class="headerlink" title="1 Mybatis入门"></a>1 Mybatis入门</h1><p>原生JDBC实现CURD的问题</p><blockquote><p>1 编码繁琐<br>2 需要我们自己将结果集映射成对象<br>3 性能不太好 连接池 缓存<br>4 SQL语句和java代码的耦合度特别高<br>5 … …</p></blockquote><p>MyBatis 本是Apache的一个开源项目iBatis, 2010年这个项目由Apache Software Foundation 迁移到了Google Code，且改名为MyBatis 。2013年11月迁移到GitHub。iBATIS一词来源于“internet”和“abatis”的组合，是一个基于Java的持久层框架。<br>MyBatis 是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 POJOs(Plain Ordinary Java Object,普通的 Java对象)映射成数据库中的记录。</p><img data-src="/2022/10/07/ORM/Mybatis/image-20220617191731748.png" title="image-20220617191731748"><h2 id="1-认识框架"><a href="#1-认识框架" class="headerlink" title="1 认识框架"></a>1 认识框架</h2><p>框架（Framework）是一个框子——指其约束性，也是一个架子——指其支撑性。是一个基本概念上的结构，用于去解决或者处理复杂的问题。框架这个广泛的定义使用的十分流行，尤其在软件概念。<br>框架( Framework )对于java来说,就是一系列为了解决特定问题而定义的一系列接口和实现类,在组织框架代码时,使用了一系列优秀的设计模式,使代码无论在性能上还是API操作上得到很大提升.框架可以看做是项目开发的半成品,基本的底层操作已经封装完毕,通过框架,程序员可以从底层代码中解脱出来,专注于业务逻辑的完成和性能的优化。框架规定了你的应用的体系结构。它定义了整体结构，类和对象的分割，各部分的主要责任，类和对象怎么协作，以及控制流程。框架预定义了这些设计参数，以便于应用设计者或实现者能集中精力于应用本身的特定细节。</p><p>如果将开发完成的软件比作是一套已经装修完毕的新房，那框架就好比是一套已经修建好的毛坯房。用户直接购买毛坯房，建筑质量和户型合理有保证，还省去了自己建造房屋的时间，一举多得。<br>在开发过程是使用框架，同样可以保证减少开发时间、降低开发难度，并且还保证设计质量。好比和世界上最优秀的软件工程师是一个项目的，并且他们完成的还是基础、全局的工作。想想是不是很嗨的一件事情。</p><img data-src="/2022/10/07/ORM/Mybatis/image-20220617191818381.png" title="image-20220617191818381"><p>框架还有一个作用是约束。莎士比亚说,”一千个观众眼中有一千个哈姆雷特” 即仁者见仁,智者见智.说每个人都会对作品有不同的理解，每个人对待任何事物都有自己的看法，一千个人就有可能有一千种不同的看法1000人心中有1000个哈姆雷特。同样的技术解决同样的问题会产生不同流程和风格的解决方案，而采用一种框架其实就是限制用户必须使用其规定的方案来实现，<strong>可以降低程序员之间沟通以及日后维护的成本。</strong></p><p>常用的基于JavaEE的三大开源框架，已经从SSH、SSH2过渡到了SSM：SpringMVC、Spring、MyBatis &gt;&gt;&gt; springBoot</p><p><font face="微软雅黑" size="6" color="#FF0000">总之，框架是一个半成品，已经对基础的代码进行了封装并提供相应的API，开发者在使用框架是直接调用封装好的API可以省去很多代码编写，从而提高工作效率和开发速度。</font></p><h2 id="2-认识ORM"><a href="#2-认识ORM" class="headerlink" title="2 认识ORM"></a>2 认识ORM</h2><p>DBC的缺点：</p><p>需要手动的完成面向对象的Java语言、面向关系的数据库之间数据的转换，代码繁琐无技术含量，影响了开发效率。</p><p>如图所示，查询是需要手动的将结果集的列数据转换为Java对象的属性；而添加操作时需要手动将Java对象的属性转换为数据库表的列字段。</p><p>关于面向对象的Java语言、面向关系的数据库之间数据的转换必须要做，问题在于这个转换是否可以不由开发者来做。可以的。ORM框架就是专门来做这个问题的，相当于在面向对象语言和关系数据库之间搭建一个桥梁。</p><p>&#x3D;&#x3D;ORM，Object-Relationl Mapping，对象关系映射，它的作用是在关系型数据库和对象之间作一个映射，这样我们在具体的操作数据库的时候，只要像平时操作对象一样操作它就可以了，ORM框架会根据映射完成对数据库的操作，就不需要再去和复杂的SQL语句打交道了&#x3D;&#x3D;。</p><img data-src="/2022/10/07/ORM/Mybatis/image-20220617192304044.png" title="image-20220617192304044"><p>另外学习ORM必须知道两个概念：持久化、持久层</p><p><strong>什么是“持久化”</strong></p><p>持久（Persistence），<font color="#FF0000">即把数据（如内存中的对象）保存到可永久保存的存储设备中（如磁盘）</font>。持久化的主要应用是将内存中的数据存储在关系型的数据库中，当然也可以存储在磁盘文件中、XML数据文件中等等。</p><p><strong>什么是 “持久层”</strong></p><p>持久层（Persistence Layer），即专注于实现数据持久化应用领域的某个特定系统的一个逻辑层面，将数据使用者和数据实体相关联。之前使用JDBC访问数据库的DAO层，后面采用MyBatis访问数据库的mapper层，就是持久层。</p><p><strong>Mybatis是一持久层的款半自动的ORM映射框架</strong></p><h2 id="3-认识MyBatis"><a href="#3-认识MyBatis" class="headerlink" title="3 认识MyBatis"></a>3 认识MyBatis</h2><blockquote><p>MyBatis 本是Apache的一个开源项目iBatis, 2010年这个项目由Apache Software Foundation 迁移到了Google Code，且改名为MyBatis 。2013年11月迁移到GitHub。iBATIS一词来源于“internet”和“abatis”的组合，是一个基于Java的持久层框架。</p></blockquote><p>MyBatis 是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 POJOs(Plain Ordinary Java Object,普通的 Java对象)映射成数据库中的记录。</p><img data-src="/2022/10/07/ORM/Mybatis/image-20220617192446302.png" title="image-20220617192446302"><p>精简解释：MyBatis是一个半自动ORM框架，其本质是对JDBC的封装。使用MyBatis重点需要程序员编写SQL命令，不需要写一行JDBC代码</p><h1 id="2-MyBatis初次使用"><a href="#2-MyBatis初次使用" class="headerlink" title="2 MyBatis初次使用"></a>2 MyBatis初次使用</h1><h2 id="1-创建maven项目导入相关依赖"><a href="#1-创建maven项目导入相关依赖" class="headerlink" title="1 创建maven项目导入相关依赖"></a>1 创建maven项目导入相关依赖</h2><p>但凡是框架,使用都是分三步走</p><p>1导入jar文件,maven</p><p>2处理配置文件</p><p>3开发业务代码</p><p>先创建一个空项目,用于存放后面Mybatis相关项目模块</p><img data-src="/2022/10/07/ORM/Mybatis/image-20220617192550409.png" title="image-20220617192550409"><p>项目名为mybatisAll即可</p><img data-src="/2022/10/07/ORM/Mybatis/image-20220617192555641.png" title="image-20220617192555641"><p>这里不显示项目名 没关系,如果想看到项目名,可以close项目后,再次open即可</p><img data-src="/2022/10/07/ORM/Mybatis/image-20220617192604832.png" title="image-20220617192604832"><p>关闭项目</p><img data-src="/2022/10/07/ORM/Mybatis/image-20220617192611548.png" title="image-20220617192611548"><p>再次open</p><img data-src="/2022/10/07/ORM/Mybatis/image-20220617192630884.png" title="image-20220617192630884"><p>项目名就显示了</p><img data-src="/2022/10/07/ORM/Mybatis/image-20220617192636190.png" title="image-20220617192636190"><p>接下来设置maven为我们自己安装的,不用idea自带的(当然用自带的也行)</p><img data-src="/2022/10/07/ORM/Mybatis/image-20220617192641520.png" title="image-20220617192641520"> <img data-src="/2022/10/07/ORM/Mybatis/image-20220617192647200.png" title="image-20220617192647200"><p>在当前项目中创建模块</p><img data-src="/2022/10/07/ORM/Mybatis/image-20220617192652567.png" title="image-20220617192652567"><p>选择maven项目 next</p><img data-src="/2022/10/07/ORM/Mybatis/image-20220617192703265.png" title="image-20220617192703265"><p>输入groupid和aitifactid 然后finish</p><img data-src="/2022/10/07/ORM/Mybatis/image-20220617192713221.png" title="image-20220617192713221"><p>检查项目目前在磁盘上的存放路径 然后next</p><img data-src="/2022/10/07/ORM/Mybatis/image-20220617192719403.png" title="image-20220617192719403"><p>检查项目目录结构是否有缺失</p><img data-src="/2022/10/07/ORM/Mybatis/image-20220617192723928.png" title="image-20220617192723928"><p>MyBatis官网说明文档 <span class="exturl" data-url="aHR0cHM6Ly9teWJhdGlzLm9yZy9teWJhdGlzLTMvemgvaW5kZXguaHRtbA==">https://mybatis.org/mybatis-3/zh/index.html</span></p><p>在pom.xml中导入MyBatis相关依赖jar文件</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
    &lt;groupId&gt;com.msb&lt;/groupId&gt;
    &lt;artifactId&gt;mybatisTest01&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;packaging&gt;jar&lt;/packaging&gt;
    &lt;dependencies&gt;
        &lt;!--mysqlConnector--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;mysql&lt;/groupId&gt;
            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
            &lt;version&gt;8.0.16&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!--mybatis 核心jar包--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
            &lt;artifactId&gt;mybatis&lt;/artifactId&gt;
            &lt;version&gt;3.5.3&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!--junit--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;junit&lt;/groupId&gt;
            &lt;artifactId&gt;junit&lt;/artifactId&gt;
            &lt;version&gt;4.13.1&lt;/version&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;
        &lt;!--lombok --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
            &lt;artifactId&gt;lombok&lt;/artifactId&gt;
            &lt;version&gt;1.18.12&lt;/version&gt;
            &lt;scope&gt;provided&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/project&gt;
</code></pre><p>安装lombok插件后,重启idea</p><img data-src="/2022/10/07/ORM/Mybatis/image-20220617192808470.png" title="image-20220617192808470"><p>导入lombok依赖后,单独设置启用注解处理</p><img data-src="/2022/10/07/ORM/Mybatis/image-20220617192814365.png" title="image-20220617192814365"><h2 id="2-准备数据库-包结构和实体类"><a href="#2-准备数据库-包结构和实体类" class="headerlink" title="2  准备数据库_包结构和实体类"></a>2 准备数据库_包结构和实体类</h2><p>数据库</p><p><img data-src="/../spring/img/image-20220617192857161.png" alt="image-20220617192857161"></p><p>项目结构</p><img data-src="/2022/10/07/ORM/Mybatis/image-20220617192901785.png" title="image-20220617192901785"><p>实体类Dept</p><pre><code class="java"> package com.msb.pojo;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import java.io.Serializable;
/**

 * @Author: Ma HaiYang
 * @Description: MircoMessage:Mark_7001
    */
    @Data
    @AllArgsConstructor
    @NoArgsConstructor
    public class Dept implements Serializable &#123;
    private Integer deptno;
    private String dname;
    private String loc;
    &#125;
</code></pre><h2 id="3-准备Mapper映射文件和核心配置文件"><a href="#3-准备Mapper映射文件和核心配置文件" class="headerlink" title="3 准备Mapper映射文件和核心配置文件"></a>3 准备Mapper映射文件和核心配置文件</h2><p>resources目录下 创建 com&#x2F;msb&#x2F;mapper目录,然后添加DeptMapper.xml映射文件</p><img data-src="/2022/10/07/ORM/Mybatis/image-20220617193030929.png" title="image-20220617193030929"><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper
        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;aaa&quot;&gt;
    &lt;!--public List&lt;Dept&gt; findAll()&#123;    &#125;--&gt;
    &lt;select id=&quot;findAll&quot; resultType=&quot;com.msb.pojo.Dept&quot; &gt;
        select * from dept
    &lt;/select&gt;
&lt;/mapper&gt;
</code></pre><p>resources目录下准备sqlMapConfig.xml 核心配置文件</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE configuration
        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;
&lt;configuration&gt;
    &lt;environments default=&quot;development&quot;&gt;
        &lt;environment id=&quot;development&quot;&gt;
            &lt;transactionManager type=&quot;JDBC&quot;/&gt;
            &lt;dataSource type=&quot;POOLED&quot;&gt;
                &lt;property name=&quot;driver&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt;
                &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://127.0.0.1:3306/mydb?useSSL=false&amp;amp;useUnicode=true&amp;amp;characterEncoding=UTF-8&amp;amp;serverTimezone=Asia/Shanghai&quot;/&gt;
                &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;
                &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt;
            &lt;/dataSource&gt;
        &lt;/environment&gt;
    &lt;/environments&gt;
    &lt;!--加载mapper映射文件--&gt;
    &lt;mappers&gt;
        &lt;mapper resource=&quot;com/msb/mapper/DeptMapper.xml&quot;/&gt;
    &lt;/mappers&gt;
&lt;/configuration&gt;
</code></pre><h2 id="4-运行测试"><a href="#4-运行测试" class="headerlink" title="4 运行测试"></a>4 运行测试</h2><img data-src="/2022/10/07/ORM/Mybatis/image-20220617193244713.png" title="image-20220617193244713"><p>在test目录下开发测试代码并运行</p><p><img data-src="/../spring/img/image-20220617193259351.png" alt="image-20220617193259351"></p><pre><code class="java"> package com.msb.test;
import com.msb.pojo.Dept;
import org.apache.ibatis.io.Resources;
import org.apache.ibatis.session.SqlSession;
import org.apache.ibatis.session.SqlSessionFactory;
import org.apache.ibatis.session.SqlSessionFactoryBuilder;
import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import java.io.IOException;
import java.io.InputStream;
import java.util.List;
/**

 * @Author: Ma HaiYang
 * @Description: MircoMessage:Mark_7001
    */
    public class Test1 &#123;
    private SqlSession sqlSession;
    @Before
    public void init()&#123;
        SqlSessionFactoryBuilder ssfb =new SqlSessionFactoryBuilder();
        InputStream resourceAsStream = null;
        try &#123;
            resourceAsStream = Resources.getResourceAsStream(&quot;sqlMapConfig.xml&quot;);
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125;
        SqlSessionFactory factory=ssfb.build(resourceAsStream) ;
        sqlSession=factory.openSession();
    &#125;
    @Test
    public void testFindAll()&#123;
        // 调用SQL语句
        List&lt;Dept&gt; list = sqlSession.selectList(&quot;findAll&quot;);
        for (Dept dept : list) &#123;
            System.out.println(dept);
        &#125;
    &#125;
    @After
    public void release()&#123;
        // 关闭SQLSession
        sqlSession.close();
    &#125;
    &#125;
</code></pre><h1 id="3-MyBatis配置详解"><a href="#3-MyBatis配置详解" class="headerlink" title="3 MyBatis配置详解"></a>3 MyBatis配置详解</h1><h3 id="1-log4j1和log4j2的简单配置"><a href="#1-log4j1和log4j2的简单配置" class="headerlink" title="1_log4j1和log4j2的简单配置"></a>1_log4j1和log4j2的简单配置</h3><p>项目中添加依赖</p><pre><code class="xml">&lt;!-- log4j2 --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;
    &lt;artifactId&gt;log4j-core&lt;/artifactId&gt;
    &lt;version&gt;2.12.1&lt;/version&gt;
&lt;/dependency&gt;
&lt;!-- log4j1 --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;log4j&lt;/groupId&gt;
    &lt;artifactId&gt;log4j&lt;/artifactId&gt;
    &lt;version&gt;1.2.17&lt;/version&gt;
&lt;/dependency&gt;
</code></pre><pre><code>在mybatis.cfg.xml中配置MyBatis所使用的具体日志实现。如果不指定将自动搜索。可能会搜到log4j，但是如果优先搜到了其他的日志实现呢，所以还是设置为好。这一来log4j就跑不了了。
</code></pre><p>log4j 1</p><pre><code>将log4j.properties文件负责到src下。另外在其中可以将全局的日志级别调高，避免大量debug信息的干扰。同时将对映射文件的操作调低，可以用来显示SQL语句的调试信息。开发阶段，建议启动控制的日志。
</code></pre><p>#定义全局日志级别调试阶段推荐debug</p><pre><code class="properties">log4j.rootLogger=debug,stdout 
log4j.appender.stdout=org.apache.log4j.ConsoleAppender
log4j.appender.stdout.Target=System.err
log4j.appender.stdout.layout=org.apache.log4j.SimpleLayout
log4j.appender.logfile=org.apache.log4j.FileAppender
log4j.appender.logfile.File=d:/msb.log
log4j.appender.logfile.layout=org.apache.log4j.PatternLayout
log4j.appender.logfile.layout.ConversionPattern=%d&#123;yyyy-MM-dd HH:mm:ss&#125; %l %F %p %m%n
</code></pre><p>在核心配置文件中可以选择的其他日志处理方式</p><p>log4j 2</p><p>将log4j2.xml文件负责到resources下。</p><pre><code class="xml"> &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;Configuration status=&quot;DEBUG&quot;&gt;
    &lt;Appenders&gt;
        &lt;Console name=&quot;Console&quot; target=&quot;SYSTEM_ERR&quot;&gt;
            &lt;PatternLayout pattern=&quot;%d&#123;YYYY-MM-dd HH:mm:ss&#125; [%t] %-5p %c&#123;1&#125;:%L - %msg%n&quot; /&gt;
        &lt;/Console&gt;
        &lt;RollingFile name=&quot;RollingFile&quot; filename=&quot;log/test.log&quot;
                     filepattern=&quot;$&#123;logPath&#125;/%d&#123;YYYYMMddHHmmss&#125;-fargo.log&quot;&gt;
            &lt;PatternLayout pattern=&quot;%d&#123;YYYY-MM-dd HH:mm:ss&#125; [%t] %-5p %c&#123;1&#125;:%L - %msg%n&quot; /&gt;
            &lt;Policies&gt;
                &lt;SizeBasedTriggeringPolicy size=&quot;10 MB&quot; /&gt;
            &lt;/Policies&gt;
            &lt;DefaultRolloverStrategy max=&quot;20&quot; /&gt;
        &lt;/RollingFile&gt;
    &lt;/Appenders&gt;
    &lt;Loggers&gt;
        &lt;Root level=&quot;INFO&quot;&gt;
            &lt;AppenderRef ref=&quot;Console&quot; /&gt;
        &lt;/Root&gt;
    &lt;/Loggers&gt;
&lt;/Configuration&gt;
</code></pre><p>核心配置文件中可以指定日志打印方式</p><img data-src="/2022/10/07/ORM/Mybatis/image-20220617193736735.png" title="image-20220617193736735"><h2 id="2-关于事务配置"><a href="#2-关于事务配置" class="headerlink" title="2_关于事务配置"></a>2_关于事务配置</h2><img data-src="/2022/10/07/ORM/Mybatis/image-20220617193831478.png" title="image-20220617193831478"><p>在mybatis核心配置文件中 envirment中 通过transactionManager配置事务的处理策略</p><p><font color="#FF000">JDBC</font> – 这个配置直接简单使用了 JDBC 的提交和回滚设置。它依赖于从数据源得到的连接来管理事务范围。</p><p><font color="#FF000">MANAGED </font>– 这个配置几乎没做什么。它从来不提交或回滚一个连接。而它会让容器来管理事务的整个生命周期(比如 Spring 或 JEE 应用服务器的上下文) 默认情况下它会关闭连接。然而一些容器并不希望这样, 因此如果你需要从连接中停止它,将closeConnection 属性设置为 false. mybatis本身并不做事务的处理,交给其他框架去处理事务,如spring</p><h2 id="3-关于映射文件的加载方式"><a href="#3-关于映射文件的加载方式" class="headerlink" title="3_关于映射文件的加载方式"></a>3_关于映射文件的加载方式</h2><p>1.mapper映射文件的文件路径导入 使用的mapper标签的resource属性</p><p>2.网络资源路径 使用的mapper标签的url属性</p><p>3.接口的全限定名导入 使用的是mapper标签的class属性 (基于接口的代理模式开发)</p><p>4.包扫描形式加载所有的mapper映射文件 使用的是 package标签</p><img data-src="/2022/10/07/ORM/Mybatis/image-20220617193946594.png" title="image-20220617193946594"><h2 id="4-关于实体类别名处理"><a href="#4-关于实体类别名处理" class="headerlink" title="4_关于实体类别名处理"></a>4_关于实体类别名处理</h2><p>在mybatis核心配置文件中使用别名处理</p><pre><code class="xml"> &lt;!--设置实体类别名--&gt;
&lt;typeAliases&gt;
    &lt;!--
    通过包扫描给所有的实体类起别名
    给指定报名下的所有类起别名
    默认每个实体类的别名是首字母小写的类名
    Dept   dept
    Emp    emp
    --&gt;
    &lt;package name=&quot;com.msb.pojo&quot;/&gt;
&lt;/typeAliases&gt;
</code></pre><p>在映射文件的resultType 返回值类型 和paramterType 上就可以使用别名了</p><pre><code class="xml">&lt;select id=&quot;selectByEmpno&quot;  resultType=&quot;emp&quot;&gt;
    select * from emp where empno = 7566
&lt;/select&gt;
</code></pre><h2 id="5-关于外部属性配置文件存储数据库连接信息"><a href="#5-关于外部属性配置文件存储数据库连接信息" class="headerlink" title="5_关于外部属性配置文件存储数据库连接信息"></a>5_关于外部属性配置文件存储数据库连接信息</h2><p>在resources下准备jdbc.properties属性配置文件</p><img data-src="/2022/10/07/ORM/Mybatis/image-20220617194131042.png" title="image-20220617194131042"><p>配置文件中的内容</p><pre><code class="properties">jdbc_driver=com.mysql.cj.jdbc.Driver
jdbc_url=jdbc:mysql://127.0.0.1:3306/mydb?useSSL=false&amp;useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=Asia/Shanghai
jdbc_username=root
jdbc_password=root
</code></pre><p>在核心配置文件中引入db.properties属性文件</p><pre><code class="xml"> &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!-- xml文档约束 约束xml文档中可以有哪些标签,哪些属性,以及标签的包含关系和顺序....
dtd 约束
schema 约束
--&gt;

&lt;!DOCTYPE configuration
        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;
&lt;configuration&gt;
    &lt;properties resource=&quot;jdbc.properties&quot;&gt;&lt;/properties&gt;
    &lt;settings&gt;
        &lt;!--设置日志处理方式--&gt;
        &lt;setting name=&quot;logImpl&quot; value=&quot;LOG4J&quot;/&gt;
    &lt;/settings&gt;
    &lt;!--设置实体类别名--&gt;
    &lt;typeAliases&gt;
        &lt;!--
        通过包扫描给所有的实体类起别名
        给指定报名下的所有类起别名
        默认每个实体类的别名是首字母小写的类名
        Dept   dept
        Emp    emp
        --&gt;
        &lt;package name=&quot;com.msb.pojo&quot;/&gt;
    &lt;/typeAliases&gt;
    &lt;!--配置数据库链接信息--&gt;
    &lt;environments default=&quot;mysql&quot;&gt;
        &lt;!--数据源1--&gt;
        &lt;environment id=&quot;mysql&quot;&gt;
            &lt;transactionManager type=&quot;JDBC&quot;/&gt;
            &lt;!--一个数据源--&gt;
            &lt;dataSource type=&quot;POOLED&quot;&gt;
                &lt;property name=&quot;driver&quot; value=&quot;$&#123;jdbc_driver&#125;&quot;/&gt;
                &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc_url&#125;&quot;/&gt;
                &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc_username&#125;&quot;/&gt;
                &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc_password&#125;&quot;/&gt;
            &lt;/dataSource&gt;
        &lt;/environment&gt;
    &lt;/environments&gt;
    &lt;!--加载映射文件的--&gt;
    &lt;mappers&gt;
        &lt;mapper resource=&quot;com/msb/mapper/DeptMapper.xml&quot;/&gt;
    &lt;/mappers&gt;
&lt;/configuration&gt;
</code></pre><h1 id="4-MyBatis传统DAO模式开发"><a href="#4-MyBatis传统DAO模式开发" class="headerlink" title="4 MyBatis传统DAO模式开发"></a>4 MyBatis传统DAO模式开发</h1><blockquote><pre><code>普通模式,也称为传统DAO模式,就是在传统DAO模式下,定义接口和实现类,如 interface EmpDao  class EmpDaoImpl implements EmpDao.  在实现类中,用SQLSession对象调用select insert delete update 等方法实现.目前极为少见.在传统模式下,我们需要知道SqlSession对象 实现CURD和 参数传递的处理
</code></pre></blockquote><h2 id="1-sqlSession查询的三种方式"><a href="#1-sqlSession查询的三种方式" class="headerlink" title="1_sqlSession查询的三种方式"></a>1_sqlSession查询的三种方式</h2><p>SqlSession对象本身的API中就有三个查询方法,分别能够实现如下查询方式</p><p>1返回单个对象 selectOne</p><p>2返回对象List集合 selectList</p><p>3返回对象Map集合 selectMap</p><p>接下来我们就对这三个方法进行一个快速的学习</p><img data-src="/2022/10/07/ORM/Mybatis/image-20220617194257643.png" title="image-20220617194257643"><p>创建Emp实体类</p><pre><code class="java">@AllArgsConstructor
@NoArgsConstructor
@Data
public class Emp implements Serializable &#123;
    private Integer empno;
    private String ename;
    private String job;
    private Integer mgr;
    private Date hiredate;
    private Double sal;
    private Double comm;
    private Integer deptno;
&#125;
</code></pre><p>准备Mapper映射文件</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper
        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;EmpMapper&quot;&gt;
    &lt;!--
    返回单个对象
    public Emp findOne();
    id 相当于方法名
    resultType 相当于返回值类型
        sql语句的查询结果用哪个类来进行封装 如果返回值类型是集合,这里写的也是集合中的元素对应的类,不是集合本身作为类型
    paramaterType 参数类型
    SQL语句就是具体的方法体的实现
    --&gt;
    &lt;select id=&quot;findOne&quot; resultType=&quot;emp&quot; &gt;
        select * from emp where empno = 7499
    &lt;/select&gt;
    &lt;!--
    返回多个对象List集合
    查询全部的员工信息
    public List&lt;Emp&gt; findAll()
    --&gt;
    &lt;select id=&quot;findAll&quot; resultType=&quot;emp&quot;&gt;
        select * from emp
    &lt;/select&gt;
    &lt;!--返回多个对象的Map集合
    把查询出来的数据中的某一列作为键,整条数据封装的对象作为值
    public Map&lt;key,Emp&gt; findEmpMap()
    &lt;empno,Emp&gt;
    &lt;key,Emp&gt;
    --&gt;
    &lt;select id=&quot;findEmpMap&quot; resultType=&quot;map&quot;&gt;
        select * from emp
    &lt;/select&gt;
&lt;/mapper&gt;
</code></pre><p>sqlMapConfig中导入EmpMapper映射文件</p><pre><code class="xml">&lt;!--加载mapper映射文件--&gt;
&lt;mappers&gt;
    &lt;mapper resource=&quot;com/msb/mapper/DeptMapper.xml&quot;/&gt;
    &lt;mapper resource=&quot;com/msb/mapper/EmpMapper.xml&quot;/&gt;
&lt;/mappers&gt;
</code></pre><p>测试代码</p><pre><code class="java">package com.msb.test;
import com.msb.pojo.Dept;
import com.msb.pojo.Emp;
import org.apache.ibatis.io.Resources;
import org.apache.ibatis.session.SqlSession;
import org.apache.ibatis.session.SqlSessionFactory;
import org.apache.ibatis.session.SqlSessionFactoryBuilder;
import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import java.io.IOException;
import java.io.InputStream;
import java.util.List;
import java.util.Map;
import java.util.Set;
/**

 * @Author: Ma HaiYang
 * @Description: MircoMessage:Mark_7001
    */
    public class Test2 &#123;
    private SqlSession sqlSession;
    @Before
    public void init()&#123;
        SqlSessionFactoryBuilder ssfb =new SqlSessionFactoryBuilder();
        InputStream resourceAsStream = null;
        try &#123;
            resourceAsStream = Resources.getResourceAsStream(&quot;sqlMapConfig.xml&quot;);
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125;
        SqlSessionFactory factory=ssfb.build(resourceAsStream) ;
        sqlSession=factory.openSession();
    &#125;
    @Test
    public void testSelectOne()&#123;
        // 查询单个对象
        System.out.println(&quot;sqlSession查询单个对象&quot;);
        Emp emp = sqlSession.selectOne(&quot;findOne&quot;);
        System.out.println(emp);
    &#125;
    @Test
    public void testSelectList()&#123;
        // 查询多个对象的List集合
        System.out.println(&quot;sqlSession查询对象List集合&quot;);
        List&lt;Emp&gt; emps = sqlSession.selectList(&quot;EmpMapper.findAll&quot;);
        emps.forEach(System.out::println);
    &#125;
    @Test
    public void testSelectMap()&#123;
        // 查询多个对象的Map集合
        System.out.println(&quot;sqlSession查询对象Map集合&quot;);
        Map&lt;Integer, Emp&gt; empMap = sqlSession.selectMap(&quot;findEmpMap&quot;, &quot;EMPNO&quot;);
        Set&lt;Integer&gt; empnos = empMap.keySet();
        for (Integer empno : empnos) &#123;
            System.out.println(empno+&quot; :&quot; +empMap.get(empno));
        &#125;
    &#125;
    @After
    public void release()&#123;
        // 关闭SQLSession
        sqlSession.close();
    &#125;
&#125;
</code></pre><h2 id="2-sqlSession传递参数的三种方式"><a href="#2-sqlSession传递参数的三种方式" class="headerlink" title="2_sqlSession传递参数的三种方式"></a>2_sqlSession传递参数的三种方式</h2><p>1 单个基础数据类型作为参数</p><p>2 多个基础数据类型的map 集合作为参数</p><p>3 引用类型作为参数</p><p>Mapper映射文件</p><pre><code class="xml"> &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper
        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;EmpMapper2&quot;&gt;
    &lt;!--
    参数为一个基本数据类型
    根据员工工号查询员工的全部信息,返回单个员工对象
    public Emp findByEmpno(int empno);
    parameterType 在有参数情况下也是可以省略不写  mybatis 可以根据实际情况自动判断
    如果要写parameterType 那么就要写对
    在SQL语句上可以使用$&#123;&#125;  #&#123;&#125; 代表参数的占位
    如果参数是单个基本数据类型,&#123;&#125;中名字可以随便写,见名知意
    $&#123;&#125; 代表mybatis底层使用Statment语句对象,参数是以字符串拼接的形式设置
    #&#123;&#125; 代表mybatis底层使用的preparedStatment语句对象,参数使用?作为占位符处理
    #&#123;&#125; 以后常用
    --&gt;
    &lt;select id=&quot;findByEmpno&quot; resultType=&quot;emp&quot; parameterType=&quot;int&quot;&gt;
        select  * from emp where empno = #&#123;empno&#125;
    &lt;/select&gt;
    &lt;!--
    参数为map集合
    查询指定部门号和指定最低薪资的员工信息
    20 号部门 且工资在1500以上的员工信息
    public List&lt;Emp&gt; findEmpByDeptnoAndSal(int deptno,double sal);
    &lt;  &gt;  最好要进行转译处理,参照HTML转译  w3school在线文档中有转译符号对应规则
     Map&lt;String,Object&gt; args=new HashMap&lt;&gt;();
        args.put(&quot;deptno&quot;, 20);
        args.put(&quot;sal&quot;, 1500.0);
    #&#123;&#125;中写的是map集合中,参数的键
    --&gt;
    &lt;select id=&quot;findEmpByDeptnoAndSal&quot; resultType=&quot;emp&quot; parameterType=&quot;map&quot;&gt;
    &lt;/select&gt;
    &lt;!--
   参数为对象
   emp &gt;&gt;&gt;  deptno   sal
   参数是我们自定义的类型,那么 #&#123;&#125;中写的是参数的属性名
   --&gt;
    &lt;select id=&quot;findEmpByDeptnoAndSal2&quot; resultType=&quot;emp&quot; parameterType=&quot;emp&quot;&gt;
    &lt;/select&gt;
&lt;/mapper&gt;
</code></pre><p>测试代码</p><pre><code class="java"> package com.msb.test;
import com.msb.pojo.Emp;
import org.apache.ibatis.io.Resources;
import org.apache.ibatis.session.SqlSession;
import org.apache.ibatis.session.SqlSessionFactory;
import org.apache.ibatis.session.SqlSessionFactoryBuilder;
import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import java.io.IOException;
import java.io.InputStream;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
/**

 * @Author: Ma HaiYang
 * @Description: MircoMessage:Mark_7001
    */
    public class Test3 &#123;
    private SqlSession sqlSession;
    @Before
    public void init()&#123;
        SqlSessionFactoryBuilder ssfb =new SqlSessionFactoryBuilder();
        InputStream resourceAsStream = null;
        try &#123;
            resourceAsStream = Resources.getResourceAsStream(&quot;sqlMapConfig.xml&quot;);
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125;
        SqlSessionFactory factory=ssfb.build(resourceAsStream) ;
        sqlSession=factory.openSession();
    &#125;
    @Test
    public void testSingleArg()&#123;
        // 测试单个基本数据类型作为参数
        Emp emp = sqlSession.selectOne(&quot;findByEmpno&quot;, 7499);
        System.out.println(emp);
    &#125;
    @Test
    public void testMapArg()&#123;
        // 测试Map集合作为参数
        Map&lt;String,Object&gt; args=new HashMap&lt;&gt;();
        args.put(&quot;deptno&quot;, 20);
        args.put(&quot;sal&quot;, 3000.0);
        List&lt;Emp&gt; emps = sqlSession.selectList(&quot;findEmpByDeptnoAndSal&quot;, args);
        emps.forEach(System.out::println);
    &#125;
    @Test
    public void testEmpArg()&#123;
        // 测试Map集合作为参数
        Emp arg =new Emp();
        arg.setDeptno(10);
        arg.setSal(2000.0);
        List&lt;Emp&gt; emps = sqlSession.selectList(&quot;findEmpByDeptnoAndSal2&quot;, arg);
        emps.forEach(System.out::println);
    &#125;
    @After
    public void release()&#123;
        // 关闭SQLSession
        sqlSession.close();
    &#125;
&#125;
</code></pre><h2 id="3-sqlSession完成DML所有操作"><a href="#3-sqlSession完成DML所有操作" class="headerlink" title="3_sqlSession完成DML所有操作"></a>3_sqlSession完成DML所有操作</h2><p>Mapper映射文件</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper
        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;EmpMapper3&quot;&gt;
    &lt;!--
    增删方法的返回值类型都是int
    resultType就无需指定了
    insert update delete 标签中没有resultType
    但是仍然可以有paramaterType
    --&gt;
    &lt;!-- 增加方法
    public int addEmp(Emp emp);
    --&gt;
    &lt;insert id=&quot;addEmp&quot; parameterType=&quot;emp&quot;&gt;
    &lt;/insert&gt;
    &lt;!--修改
    根据工号修改员工姓名
    public int updateEmp(Emp emp);
    --&gt;
    &lt;update id=&quot;updateEmp&quot; parameterType=&quot;emp&quot;&gt;
    &lt;/update&gt;
    &lt;!-- 删除
    删除大于给定工号的员工信息
    public int deleteEmp(int empno)
    --&gt;
    &lt;delete id=&quot;deleteEmp&quot; parameterType=&quot;int&quot;&gt;
        delete from emp where empno &gt;= #&#123;empno&#125;
    &lt;/delete&gt;
&lt;/mapper&gt;
</code></pre><p>测试代码</p><pre><code class="java">package com.msb.test;
import com.msb.pojo.Emp;
import org.apache.ibatis.io.Resources;
import org.apache.ibatis.session.SqlSession;
import org.apache.ibatis.session.SqlSessionFactory;
import org.apache.ibatis.session.SqlSessionFactoryBuilder;
import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import java.io.IOException;
import java.io.InputStream;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
/**
 * @Author: Ma HaiYang
 * @Description: MircoMessage:Mark_7001
 */
public class Test4 &#123;
    private SqlSession sqlSession;
    @Before
    public void init()&#123;
        SqlSessionFactoryBuilder ssfb =new SqlSessionFactoryBuilder();
        InputStream resourceAsStream = null;
        try &#123;
            resourceAsStream = Resources.getResourceAsStream(&quot;sqlMapConfig.xml&quot;);
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125;
        SqlSessionFactory factory=ssfb.build(resourceAsStream) ;
        sqlSession=factory.openSession(true);
    &#125;
    @Test
    public void testInsert()&#123;
        Emp emp =new Emp(null,&quot;按住啦Baby&quot;,&quot;SALESMAN&quot;,7839,new Date(),3100.0, 200.0,10 );
        int rows = sqlSession.insert(&quot;addEmp&quot;, emp);
        System.out.println(rows);
        // 手动提交事务
        //sqlSession.commit();
        /*增删改 要提交事务
        * sqlSession.commit();手动提交事务
        * sqlSession=factory.openSession(true); 设置事务自动提交
        * */
    &#125;
    @Test
    public void testUpdate()&#123;
        Emp emp =new Emp( );
        emp.setEname(&quot;晓明&quot;);
        emp.setEmpno(7937);
        int rows = sqlSession.update(&quot;updateEmp&quot;, emp);
        System.out.println(rows);
    &#125;
    @Test
    public void testDelete()&#123;
        int rows = sqlSession.delete(&quot;deleteEmp&quot;, 7936);
        System.out.println(rows);
    &#125;
    @After
    public void release()&#123;
        // 关闭SQLSession
        sqlSession.close();
    &#125;
&#125;
</code></pre><h1 id="5-MyBatis代理模式开发"><a href="#5-MyBatis代理模式开发" class="headerlink" title="5 MyBatis代理模式开发"></a>5 MyBatis代理模式开发</h1><p>前面已经使用MyBatis完成了对Emp表的CRUD操作，都是由SqlSession调用自身方法发送SQL命令并得到结果的，实现了MyBatis的入门。</p><p>但是却存在如下缺点：</p><ol><li><p>不管是selectList()、selectOne()、selectMap()，都是通过SQLSession对象的API完成增删改查,都只能提供一个查询参数。如果要多个参数，需要封装到JavaBean或者Map中，并不一定永远是一个好办法。</p></li><li><p>返回值类型较固定。</p></li><li><p>只提供了映射文件，没有提供数据库操作的接口，不利于后期的维护扩展。</p></li></ol><p>在MyBatis中提供了另外一种成为<strong>Mapper代理（或称为接口绑定）</strong>的操作方式。在实际开发中也使用该方式。下面我们就是要Mapper代理的方式来实现对Emp表的CRUD操作吧，还有完成多个参数传递、模糊查询、自增主键回填等更多的技能实现。搭建好的项目框架如图所示，相比而言，增加了接口EmployeeMapper。但是却会引起映射文件和测试类的变化。</p><p>优点:</p><p>1有接口 模块之间有规范了</p><p>2参数的处理多样了,接口中的方法参数列表由我们自己决定</p><p>3通过代理模式由mybatis提供接口的实现类对象 我们不用写实现类了</p><p>项目结构:注意文件路径和文件位置!!!</p><img data-src="/2022/10/07/ORM/Mybatis/image-20220617195010768.png" title="image-20220617195010768"><p>准备接口和mapper映射文件</p><p>EmpMapper接口</p><pre><code class="java">package com.msb.mapper;
import com.msb.pojo.Emp;
import java.util.List;
/**

 * @Author: Ma HaiYang
 * @Description: MircoMessage:Mark_7001
    */
public interface EmpMapper &#123;
    /**
     * 该方法用于查询全部的员工信息
     * @return 全部员工信息封装的Emp对象的List集合
        */
    List&lt;Emp&gt; findAll();
 &#125;
</code></pre><p>EmpMapper.xml映射文件</p><pre><code class="xml"> &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper
        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;com.msb.mapper.EmpMapper&quot;&gt;
    &lt;!--
    1 接口的名字和Mapper映射为文件名字必须保持一致(不包含拓展名)
    2 Mapper映射文件的namespace必须是接口的全路径名
    3 sql语句的id必须是对应方法的名
    4 DeptMapper映射文件应该和接口编译之后放在同一个目录下
    --&gt;
    &lt;!--List&lt;Emp&gt; findAll();--&gt;
    &lt;select id=&quot;findAll&quot; resultType=&quot;emp&quot; &gt;
        select * from emp
    &lt;/select&gt;
&lt;/mapper&gt;
</code></pre><p>在sqlMapConfig.xml核心配置文件中使用包扫描形式加载所有的映射文件</p><pre><code class="xml"> &lt;!--加载mapper映射文件--&gt;
&lt;mappers&gt;
    &lt;!--通过类的全路径去找mapper映射文件--&gt;
    &lt;mapper class=&quot;com.msb.mapper.EmpMapper&quot;/&gt;
&lt;/mappers&gt;
</code></pre><p>测试代码</p><pre><code class="java">package com.msb.test;
import com.msb.mapper.EmpMapper;
import com.msb.pojo.Dept;
import com.msb.pojo.Emp;
import org.apache.ibatis.io.Resources;
import org.apache.ibatis.session.SqlSession;
import org.apache.ibatis.session.SqlSessionFactory;
import org.apache.ibatis.session.SqlSessionFactoryBuilder;
import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import java.io.IOException;
import java.io.InputStream;
import java.util.List;
/**

 * @Author: Ma HaiYang
 * @Description: MircoMessage:Mark_7001
    */
    public class Test1 &#123;
    private SqlSession sqlSession;
    @Before
    public void init()&#123;
        SqlSessionFactoryBuilder ssfb =new SqlSessionFactoryBuilder();
        InputStream resourceAsStream = null;
        try &#123;
            resourceAsStream = Resources.getResourceAsStream(&quot;sqlMapConfig.xml&quot;);
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125;
        SqlSessionFactory factory=ssfb.build(resourceAsStream) ;
        sqlSession=factory.openSession();
    &#125;
    @Test
    public void testFindAll()&#123;
        EmpMapper empMapper=sqlSession.getMapper(EmpMapper.class);
        List&lt;Emp&gt; emps = empMapper.findAll();
        emps.forEach(System.out::println);
    &#125;
    @After
    public void release()&#123;
        // 关闭SQLSession
        sqlSession.close();
    &#125;
&#125;
</code></pre><p><strong>代理模式浅析</strong></p><p>mybatis是如何通过代理模式实现查询的</p><p>这条语句的底层使用了动态代理模式，动态创建一个EmployeeMapper的一个代理对象并赋给接口引用。所以在MyBatis中不需要显式提供Mapper接口的实现类，这也是简单的地方。</p><h1 id="6-代理模式下开发各种功能"><a href="#6-代理模式下开发各种功能" class="headerlink" title="6 代理模式下开发各种功能"></a>6 代理模式下开发各种功能</h1><h2 id="1-多种参数传递问题"><a href="#1-多种参数传递问题" class="headerlink" title="1_多种参数传递问题"></a>1_多种参数传递问题</h2><blockquote><p>1单个基本数据类型</p><p>2多个基本数据类型</p><p>3单个引用数据类型</p><p>4map集合数据类型</p><p>5多个引用数据类型</p></blockquote><p>接口</p><pre><code class="java">package com.msb.mapper;
import com.msb.pojo.Emp;
import org.apache.ibatis.annotations.Param;
import java.util.List;
import java.util.Map;
/**
 * @Author: Ma HaiYang
 * @Description: MircoMessage:Mark_7001
 */
public interface EmpMapper &#123;
    /**
     * 该方法用于查询全部的员工信息
     * @return 全部员工信息封装的Emp对象的List集合
     */
    List&lt;Emp&gt; findAll();
    /**
     * 根据员工编号查询单个员工信息的方法
     * @param empno 员工编号
     * @return 如果找到了返回Emp对象,找不到返回null
     */
    Emp findByEmpno(int empno);
    /**
     * 根据员工编号和薪资下限去查询员工信息
     * @param empno 员工编号
     * @param sal 薪资下限
     * @return 多个Emp对象的List集合
     */
    List&lt;Emp&gt; findByDeptnoAndSal(@Param(&quot;deptno&quot;) int deptno,@Param(&quot;sal&quot;) double sal);
    List&lt;Emp&gt; findByDeptnoAndSal2(Map&lt;String,Object&gt; map);
    List&lt;Emp&gt; findByDeptnoAndSal3(Emp emp);
    List&lt;Emp&gt; findByDeptnoAndSal4(@Param(&quot;empa&quot;) Emp empa,@Param(&quot;empb&quot;) Emp empb);
&#125;
</code></pre><p>mapper映射文件</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper
        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;com.msb.mapper.EmpMapper&quot;&gt;
    &lt;!--
    1 接口的名字和Mapper映射为文件名字必须保持一致(不包含拓展名)
    2 Mapper映射文件的namespace必须是接口的全路径名
    3 sql语句的id必须是对应方法的名
    4 DeptMapper映射文件应该和接口编译之后放在同一个目录下
    --&gt;
    &lt;!--List&lt;Emp&gt; findAll();--&gt;
    &lt;select id=&quot;findAll&quot; resultType=&quot;emp&quot; &gt;
        select * from emp
    &lt;/select&gt;
    &lt;!--
    单个基本数据类型作为方法参数
    #&#123;&#125;中可以随便写,遵循见名知意
    Emp findByEmpno(int empno);
    --&gt;
    &lt;select id=&quot;findByEmpno&quot; resultType=&quot;emp&quot; &gt;
        select * from emp where empno =#&#123;empno&#125;
    &lt;/select&gt;
    &lt;!--
     多个基本数据类型作为方法参数
     List&lt;Emp&gt; findByDeptnoAndSal(@Param(&quot;detpno&quot;) int deptno,@Param(&quot;sal&quot;) double sal);
     方式1 arg*     arg0 arg1 arg2 数字是索引,从0开始
     方式2 param*   param1 param2 param3 数字是编号,从1开始
     使用别名
     List&lt;Emp&gt; findByDeptnoAndSal(@Param(&quot;detpno&quot;) int deptno,@Param(&quot;sal&quot;) double sal);
     通过@Param注解使用别名之后,就不能再使用arg* 但是可以继续使用param*
    --&gt;
    &lt;select id=&quot;findByDeptnoAndSal&quot; resultType=&quot;emp&quot;&gt;
    &lt;/select&gt;
    &lt;!--
    参数是map,&#123;&#125;写键的名字
    --&gt;
    &lt;select id=&quot;findByDeptnoAndSal2&quot; resultType=&quot;emp&quot; parameterType=&quot;map&quot; &gt;
    &lt;/select&gt;
    &lt;!--单个引用类型,&#123;&#125;中写的使用对象的属性名--&gt;
    &lt;select id=&quot;findByDeptnoAndSal3&quot; resultType=&quot;emp&quot; parameterType=&quot;emp&quot; &gt;
    &lt;/select&gt;
    &lt;!--
    多个引用类型作为方法参数
     List&lt;Emp&gt; findByDeptnoAndSal4(@Param(&quot;empa&quot;) Emp empa,@Param(&quot;empb&quot;) Emp empb);
     如果用@Param定义了别名,那么就不能使用arg*.属性名,但是可以使用param*.属性名和别名.属性名
    --&gt;
    &lt;select id=&quot;findByDeptnoAndSal4&quot; resultType=&quot;emp&quot;  &gt;
    &lt;/select&gt;
&lt;/mapper&gt;
</code></pre><p>测试 代码</p><pre><code class="java">package com.msb.testDemo;
import com.msb.mapper.EmpMapper;
import com.msb.pojo.Emp;
import com.msb.util.SqlSessionUtil;
import org.apache.ibatis.session.SqlSession;
import java.util.List;
public class Test1 &#123;
    public static void main(String[] args) &#123;
        SqlSession sqlSession = SqlSessionUtil.getSqlSession(true);
        /*
        * 帮助我们生成一个接口下的实现类对象的
        *
        * */
        EmpMapper mapper = sqlSession.getMapper(EmpMapper.class);
        List&lt;Emp&gt; emps = mapper.getAllEmp();
        for(Emp emp:emps) &#123;
            System.out.println(emp);
        &#125;
        // 1单个基本数据类型作为方法参数
        Emp emp = mapper.getByEmpno(7902);
        System.out.println(emp);
        // 2多个基本数据类型作为方法参数
        List&lt;Emp&gt; emps2 = mapper.getByDeptnoAndSal(10, 1500);
        for(Emp em:emps2) &#123;
            System.out.println(em);
        &#125;
        // 3单个引用类型作为方法参数
        Emp condition=new Emp();
        condition.setDeptno(10);
        condition.setSal(1500.0);
        List&lt;Emp&gt; emps3 = mapper.getByDeptnoAndSal2(condition);
        for(Emp em:emps3) &#123;
            System.out.println(em);
        &#125;
        // 4多个引用类型作为方法参数
        Emp condition1=new Emp();
        condition1.setDeptno(10);
        Emp condition2=new Emp();
        condition2.setSal(1500.0);
        List&lt;Emp&gt; emps4 = mapper.getByDeptnoAndSal3(condition1,condition2);
        for(Emp em:emps4) &#123;
            System.out.println(em);
        &#125;
        sqlSession.close();
    &#125;
&#125;
</code></pre><h2 id="2-模糊查询功能"><a href="#2-模糊查询功能" class="headerlink" title="2 模糊查询功能"></a>2 模糊查询功能</h2><pre><code>在进行模糊查询时，在映射文件中可以使用concat()函数来连接参数和通配符。另外注意对于特殊字符，比如&lt;，不能直接书写，应该使用字符实体替换。
</code></pre><p>接口</p><pre><code class="java">/**
 * 根据名字做模糊查询
 * @param name 模糊查询的文字
 * @return  Emp对象List集合
 */
List&lt;Emp&gt; findByEname( String name);
</code></pre><p>mapper映射文件</p><pre><code class="xml">&lt;!--List&lt;Emp&gt; getByName(String name);--&gt;
&lt;select id=&quot;findByEname&quot;  resultType=&quot;emp&quot; &gt;
    select * from emp where ename like concat(&#39;%&#39;,#&#123;name&#125;,&#39;%&#39;)
&lt;/select&gt;
</code></pre><h2 id="3-主键自增回填"><a href="#3-主键自增回填" class="headerlink" title="3_主键自增回填"></a>3_主键自增回填</h2><pre><code>MySQL支持主键自增。有时候完成添加后需要立刻获取刚刚自增的主键，由下一个操作来使用。比如结算构造车后，主订单的主键确定后，需要作为后续订单明细项的外键存在。如何拿到主键呢，MyBatis提供了支持，可以非常简单的获取。
</code></pre><p>接口</p><pre><code class="java">public interface DeptMapper &#123;
    int addDept(Dept dept);
    int addDept2(Dept dept);
&#125;
</code></pre><p>mapper映射文件</p><pre><code class="xml">&lt;mapper namespace=&quot;com.msb.mapper.DeptMapper&quot;&gt;
   &lt;!-- int addDept(Dept dept);
   useGeneratedKeys=&quot;true&quot; 返回数据库帮我们生成的主键
   keyProperty=&quot;deptno&quot; 生成的主键值用我们dept对象那个属性存储
   --&gt;
    &lt;insert id=&quot;addDept&quot; parameterType=&quot;dept&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;deptno&quot;&gt;
    &lt;/insert&gt;
    &lt;insert id=&quot;addDept2&quot; parameterType=&quot;dept&quot;&gt;
        &lt;selectKey order=&quot;AFTER&quot; keyProperty=&quot;deptno&quot;  resultType=&quot;int&quot;&gt;
            select @@identity
        &lt;/selectKey&gt;
    &lt;/insert&gt;
&lt;/mapper&gt;
</code></pre><p>测试代码</p><pre><code class="java">SqlSession sqlSession = SqlSessionUtil.getSqlSession(true);
DeptMapper mapper = sqlSession.getMapper(DeptMapper.class);
Dept dept =new Dept(null,&quot;AI学院&quot;,&quot;北京&quot;);
int i = mapper.addDept2(dept);
System.out.println(i);
System.out.println(dept.getDeptno());
sqlSession.close();
</code></pre><p>方式1</p><p>useGeneratedKeys：表示要使用自增的主键</p><p>keyProperty：表示把自增的主键赋给JavaBean的哪个成员变量。</p><p>以添加Dept对象为例，添加前Dept对象的deptno是空的，添加完毕后可以通过getDeptno() 获取自增的主键。</p><p>方式2</p><p>order：取值AFTER|BEFORE，表示在新增之后|之前执行<selectkey>中的SQL命令</selectkey></p><p>keyProperty：执行select @@identity后结果填充到哪个属性中</p><p>resultType：结果类型。</p><p><strong>技术扩展</strong><br>在很多应用场景中需要新增数据后获取到新增数据的主键值，针对这样的需求一般由三种解决方式：</p><ul><li>主键自定义，用户通过UUID或时间戳等方式生成唯一主键，把这个值当做主键值。在分布式场景中应用较多。</li><li>查询后通过select max(主键) from 表获取主键最大值。这种方式在多线程访问情况下可能出现问题。</li><li>查询后通过select @@identity获取最新生成主键。要求这条SQL必须在insert操作之后，且数据库连接没有关闭。</li></ul><h2 id="4-实现DML操作"><a href="#4-实现DML操作" class="headerlink" title="4_实现DML操作"></a>4_实现DML操作</h2><p>EmpMapper接口</p><pre><code class="java">/**
 * 增加员工信息
 * @param emp 存储新增员工信息的Emp对象
 * @return 对数据库数据产生影响的行数
 */
int addEmp(Emp emp);
/**
 * 根据员工编号修改员工姓名的方法
 * @param empno 要修改的员工编号
 * @param ename 修改之后的新的员工名字
 * @return 对数据库数据产生影响的行数
 */
int updateEnameByEmpno(@Param(&quot;empno&quot;) int empno,@Param(&quot;ename&quot;) String ename);
/**
 * 根据员工编号删除员工信息
 * @param empno 要删除的员工编号
 * @return 对数据库数据产生影响的行数
 */
int deleteByEmpno(int empno);
</code></pre><p>EmpMapper映射 文件</p><pre><code class="xml">&lt;!--int addEmp(Emp emp);--&gt;
&lt;insert id=&quot;addEmp&quot; &gt;
&lt;/insert&gt;
&lt;!--int updateEnameByEmpno(@Param(&quot;empno&quot;) int empno,@Param(&quot;ename&quot;) String ename);--&gt;
&lt;update id=&quot;updateEnameByEmpno&quot; &gt;
&lt;/update&gt;
&lt;!--int deleteByEmpno(int empno);--&gt;
&lt;update id=&quot;deleteByEmpno&quot; &gt;
    delete from emp where empno =#&#123;empno&#125;
&lt;/update&gt;
</code></pre><p>测试代码</p><pre><code class="java">package com.msb.test;
import com.msb.mapper.DeptMapper;
import com.msb.mapper.EmpMapper;
import com.msb.pojo.Dept;
import com.msb.pojo.Emp;
import org.apache.ibatis.io.Resources;
import org.apache.ibatis.session.SqlSession;
import org.apache.ibatis.session.SqlSessionFactory;
import org.apache.ibatis.session.SqlSessionFactoryBuilder;
import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import java.io.IOException;
import java.io.InputStream;
import java.util.Date;
/**
 * @Author: Ma HaiYang
 * @Description: MircoMessage:Mark_7001
 */
public class Test3 &#123;
    private SqlSession sqlSession;
    @Before
    public void init()&#123;
        SqlSessionFactoryBuilder ssfb =new SqlSessionFactoryBuilder();
        InputStream resourceAsStream = null;
        try &#123;
            resourceAsStream = Resources.getResourceAsStream(&quot;sqlMapConfig.xml&quot;);
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125;
        SqlSessionFactory factory=ssfb.build(resourceAsStream) ;
        sqlSession=factory.openSession();
    &#125;
    @Test
    public void testAddEmp()&#123;
        EmpMapper mapper = sqlSession.getMapper(EmpMapper.class);
        mapper.addEmp(new Emp(null, &quot;TOM&quot;, &quot;SALESMAN&quot;, 7521, new Date(), 2314.0, 100.0, 10));
        sqlSession.commit();
    &#125;
    @Test
    public void testUpdateEnameByEmpno()&#123;
        EmpMapper mapper = sqlSession.getMapper(EmpMapper.class);
        mapper.updateEnameByEmpno(7938, &quot;TOM&quot;);
        sqlSession.commit();
    &#125;
    @Test
    public void testDeletByEmpno()&#123;
        EmpMapper mapper = sqlSession.getMapper(EmpMapper.class);
        mapper.deleteByEmpno(7938);
        sqlSession.commit();
    &#125;
    @After
    public void release()&#123;
        // 关闭SQLSession
        sqlSession.close();
    &#125;
&#125;
</code></pre><h1 id="7-动态SQL"><a href="#7-动态SQL" class="headerlink" title="7 动态SQL"></a>7 动态SQL</h1><pre><code>经常遇到很多按照很多查询条件进行查询的情况，比如京东根据不同的条件筛选商品。其中经常出现很多条件不取值的情况，在后台应该如何完成最终的SQL语句呢？









如果采用JDBC进行处理，需要根据条件是否取值进行SQL语句的拼接，一般情况下是使用StringBuilder类及其append方法实现，还是有些繁琐的。如果你有使用 JDBC 或其它类似框架的经验，你就能体会到根据不同条件拼接 SQL语句的痛苦。例如拼接时要确保不能忘记添加必要的空格，还要注意去掉列表最后一个列名的逗号。利用动态 SQL 这一特性可以彻底摆脱这种痛苦。

MyBatis在简化操作方法提出了动态SQL功能，将使用Java代码拼接SQL语句，改变为在XML映射文件中截止标签拼接SQL语句。相比而言，大大减少了代码量，更灵活、高度可配置、利于后期维护。

MyBatis中动态SQL是编写在mapper.xml中的，其语法和JSTL类似，但是却是基于强大的OGNL表达式实现的。

MyBatis也可以在注解中配置SQL，但是由于注解功能受限，尤其是对于复杂的SQL语句，可读性很差，所以较少使用。
</code></pre><h2 id="1-if标签"><a href="#1-if标签" class="headerlink" title="1_if标签"></a>1_if标签</h2><p>接口</p><pre><code class="java">public interface EmpMapper2 &#123;
  List&lt;Emp&gt; findByCondition(Emp emp);
&#125;
</code></pre><p>映射文件</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper
        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;com.msb.mapper.EmpMapper2&quot;&gt;
&lt;!--List&lt;Emp&gt; findByCondition(Emp emp);--&gt;
    &lt;select id=&quot;findByCondition&quot; resultType=&quot;emp&quot;&gt;
        select * from emp where 1=1
        &lt;if test=&quot;empno != null&quot;&gt;
            and empno =#&#123;empno&#125;
        &lt;/if&gt;
        &lt;if test=&quot;ename != null and ename != &#39;&#39;&quot;&gt;
            and ename like concat(&#39;%&#39;,#&#123;ename&#125;,&#39;%&#39;)
        &lt;/if&gt;
        &lt;if test=&quot;job != null and job != &#39;&#39;&quot;&gt;
            and job =#&#123;job&#125;
        &lt;/if&gt;
        &lt;if test=&quot;mgr != null&quot;&gt;
            and mgr =#&#123;mgr&#125;
        &lt;/if&gt;
        &lt;if test=&quot;hiredate != null&quot;&gt;
            and hiredate =#&#123;hiredate&#125;
        &lt;/if&gt;
        &lt;if test=&quot;sal != null&quot;&gt;
            and sal =#&#123;sal&#125;
        &lt;/if&gt;
        &lt;if test=&quot;comm != null&quot;&gt;
            and comm =#&#123;comm&#125;
        &lt;/if&gt;
        &lt;if test=&quot;deptno != null&quot;&gt;
            and deptno =#&#123;deptno&#125;
        &lt;/if&gt;
    &lt;/select&gt;
&lt;/mapper&gt;
</code></pre><p>测试代码</p><pre><code class="java">public static void main(String[] args) &#123;
    SqlSession sqlSession = MyBatisUtil.getSqlSession(false);
    EmpMapper2 mapper = sqlSession.getMapper(EmpMapper2.class);
    Emp condition =new Emp();
   /* condition.setDeptno(20);*/
   /* condition.setSal(3000.0);*/
   /*condition.setHiredate(new java.sql.Date(81,1,22));*/
   condition.setComm(0.0);
   condition.setDeptno(20);
    List&lt;Emp&gt; emps = mapper.findEmpByCondition(condition);
    for (Emp e:emps
         ) &#123;
        System.out.println(e);
    &#125;
&#125;
</code></pre><h2 id="2-where标签"><a href="#2-where标签" class="headerlink" title="2_where标签"></a>2_where标签</h2><blockquote><p>用于处理where关键字和and</p><p>默认删除第一个and逻辑连接符</p></blockquote><pre><code class="xml">&lt;select id=&quot;findEmpByCondition&quot; resultType=&quot;emp&quot;&gt;
    select * from emp
    &lt;where&gt;
        &lt;if test=&quot;empno != null&quot;&gt;
            and empno= #&#123;empno&#125;
        &lt;/if&gt;
        &lt;if test=&quot;ename != null and ename != &#39;&#39;&quot;&gt;
            and ename= #&#123;ename&#125;
        &lt;/if&gt;
        &lt;if test=&quot;job != null and job != &#39;&#39;&quot;&gt;
            and job= #&#123;job&#125;
        &lt;/if&gt;
        &lt;if test=&quot;mgr != null &quot;&gt;
            and mgr= #&#123;mgr&#125;
        &lt;/if&gt;
        &lt;if test=&quot;hiredate != null &quot;&gt;
            and hiredate= #&#123;hiredate&#125;
        &lt;/if&gt;
        &lt;if test=&quot;sal != null&quot;&gt;
            and sal= #&#123;sal&#125;
        &lt;/if&gt;
        &lt;if test=&quot;comm != null &quot;&gt;
             and comm =#&#123;comm&#125;
        &lt;/if&gt;
        &lt;if test=&quot;deptno != null &quot;&gt;
            and deptno= #&#123;deptno&#125;
        &lt;/if&gt;
    &lt;/where&gt;
&lt;/select&gt;
</code></pre><h2 id="3-choose标签"><a href="#3-choose标签" class="headerlink" title="3_choose标签"></a>3_choose标签</h2><p>前面的when条件成立 后面的 when就不再判断了</p><pre><code class="xml"> &lt;select id=&quot;findEmpByCondition2&quot; resultType=&quot;emp&quot;&gt;
    select * from emp
    &lt;where&gt;
        &lt;choose&gt;
            &lt;when test=&quot;empno != null&quot;&gt;
                and empno= #&#123;empno&#125;
            &lt;/when&gt;
            &lt;when test=&quot;ename != null and ename != &#39;&#39;&quot;&gt;
                and ename= #&#123;ename&#125;
            &lt;/when&gt;
            &lt;when test=&quot;job != null and job != &#39;&#39;&quot;&gt;
                and job= #&#123;job&#125;
            &lt;/when&gt;
            &lt;when test=&quot;mgr != null &quot;&gt;
                and mgr= #&#123;mgr&#125;
            &lt;/when&gt;
            &lt;when test=&quot;hiredate != null &quot;&gt;
                and hiredate= #&#123;hiredate&#125;
            &lt;/when&gt;
            &lt;when test=&quot;sal != null&quot;&gt;
                and sal= #&#123;sal&#125;
            &lt;/when&gt;
            &lt;when test=&quot;comm != null &quot;&gt;
                and comm =#&#123;comm&#125;
            &lt;/when&gt;
            &lt;when test=&quot;deptno != null &quot;&gt;
                and deptno= #&#123;deptno&#125;
            &lt;/when&gt;
        &lt;/choose&gt;
    &lt;/where&gt;
&lt;/select&gt;
</code></pre><h2 id="4-set标签"><a href="#4-set标签" class="headerlink" title="4_set标签"></a>4_set标签</h2><p>接口</p><pre><code class="java"> int updateEmpByCondtion(Emp emp);
</code></pre><p>映射文件</p><pre><code class="xml"> &lt;!--int updateEmpByCondtion(Emp emp);--&gt;
&lt;update id=&quot;updateEmpByCondtion&quot; &gt;
    update emp
    &lt;set&gt;
        &lt;if test=&quot;ename != null and ename != &#39;&#39; &quot;&gt;
            , ename =#&#123;ename&#125;
        &lt;/if&gt;
        &lt;if test=&quot;job != null and ename != &#39;&#39; &quot;&gt;
            , job =#&#123;job&#125;
        &lt;/if&gt;
        &lt;if test=&quot;mgr != null &quot;&gt;
            , mgr =#&#123;mgr&#125;
        &lt;/if&gt;
        &lt;if test=&quot;hiredate != null &quot;&gt;
            , hiredate =#&#123;hiredate&#125;
        &lt;/if&gt;
        &lt;if test=&quot;sal != null &quot;&gt;
            , sal =#&#123;sal&#125;
        &lt;/if&gt;
        &lt;if test=&quot;comm != null &quot;&gt;
            , comm =#&#123;comm&#125;
        &lt;/if&gt;
        &lt;if test=&quot;deptno != null &quot;&gt;
            , deptno =#&#123;deptno&#125;
        &lt;/if&gt;
    &lt;/set&gt;
    where empno =#&#123;empno&#125;
&lt;/update&gt;
</code></pre><h2 id="5-trim标签"><a href="#5-trim标签" class="headerlink" title="5_trim标签"></a>5_trim标签</h2><blockquote><p>Trim 标签处理 set ，可以为他包裹起来的SQL语句前后 增加&#x2F;删除 关键词&#x2F;固定字符</p></blockquote><pre><code class="xml">&lt;update id=&quot;updateEmpByCondition2&quot; &gt;
    update emp
    &lt;!--prefix 要增加什么前缀
    prefixOverrides 要去除什么前缀
    suffix 要增加什么后缀
    suffixOverrides 要去除什么后缀
    set 是trim的一种特殊情况
    --&gt;
    &lt;trim prefix=&quot;set&quot;  suffixOverrides=&quot;,&quot; &gt;
        &lt;if test=&quot;ename != null and ename != &#39;&#39;&quot;&gt;
            ename= #&#123;ename&#125;,
        &lt;/if&gt;
        &lt;if test=&quot;job != null and job != &#39;&#39;&quot;&gt;
            job= #&#123;job&#125;,
        &lt;/if&gt;
        &lt;if test=&quot;mgr != null &quot;&gt;
            mgr= #&#123;mgr&#125;,
        &lt;/if&gt;
        &lt;if test=&quot;hiredate != null &quot;&gt;
            hiredate= #&#123;hiredate&#125;,
        &lt;/if&gt;
        &lt;if test=&quot;sal != null&quot;&gt;
            sal= #&#123;sal&#125;,
        &lt;/if&gt;
        &lt;if test=&quot;comm != null &quot;&gt;
            comm =#&#123;comm&#125;,
        &lt;/if&gt;
        &lt;if test=&quot;deptno != null &quot;&gt;
            deptno= #&#123;deptno&#125;,
        &lt;/if&gt;
    &lt;/trim&gt;
    where  empno = #&#123;empno&#125;
&lt;/update&gt;
</code></pre><p>Trim标签 处理where</p><pre><code class="xml">    &lt;select id=&quot;findByCondition&quot; resultMap=&quot;EmpMap&quot;&gt;
        select * from emp 
        &lt;trim prefix=&quot;where&quot; prefixOverrides=&quot;and&quot;&gt;
            &lt;if test=&quot;empno != null&quot;&gt;
                and empno =#&#123;empno&#125;
            &lt;/if&gt;
            &lt;if test=&quot;ename != null and ename != &#39;&#39;&quot;&gt;
                &lt;bind name=&quot;likePattern&quot; value=&quot;&#39;%&#39;+ename+&#39;%&#39;&quot;/&gt;
                and ename like #&#123;likePattern&#125;
            &lt;/if&gt;
            &lt;if test=&quot;job != null and job != &#39;&#39;&quot;&gt;
                and job =#&#123;job&#125;
            &lt;/if&gt;
            &lt;if test=&quot;mgr != null&quot;&gt;
                and mgr =#&#123;mgr&#125;
            &lt;/if&gt;
            &lt;if test=&quot;hiredate != null&quot;&gt;
                and hiredate =#&#123;hiredate&#125;
            &lt;/if&gt;
            &lt;if test=&quot;sal != null&quot;&gt;
                and sal =#&#123;sal&#125;
            &lt;/if&gt;
            &lt;if test=&quot;comm != null&quot;&gt;
                and comm =#&#123;comm&#125;
            &lt;/if&gt;
            &lt;if test=&quot;deptno != null&quot;&gt;
                and deptno =#&#123;deptno&#125;
            &lt;/if&gt;
        &lt;/trim&gt;
    &lt;/select&gt;
</code></pre><h2 id="6-bind标签"><a href="#6-bind标签" class="headerlink" title="6_bind标签"></a>6_bind标签</h2><p>一般用于处理模糊查询的模板</p><p>接口</p><img data-src="/2022/10/07/ORM/Mybatis/image-20220617200421440.png" title="image-20220617200421440"><p>SQL语句</p><pre><code class="xml">&lt;!-- bind 写一个局部SQL模板，模糊 like 常用--&gt;
    &lt;select id=&quot;findEmpByEname&quot; resultMap=&quot;EmpMap&quot;&gt;
        &lt;bind name=&quot;likePatten&quot; value=&quot;&#39;%&#39;+param1+&#39;%&#39;&quot;/&gt;
        select * from emp where ename like #&#123;likePatten&#125;;
    &lt;/select&gt;
</code></pre><h2 id="7-nclude"><a href="#7-nclude" class="headerlink" title="7_nclude"></a>7_nclude</h2><p>引用提前写好的 SQL 标签的SQL语句</p><pre><code class="xml">    &lt;sql id=&quot;empColumn&quot;&gt;empno,ename,job,mgr,hiredate,sal,comm,deptno&lt;/sql&gt;
    &lt;sql id=&quot;baseSelect&quot;&gt;
        select &lt;include refid=&quot;empColumn&quot;&gt;&lt;/include&gt; from emp
    &lt;/sql&gt;
</code></pre><h2 id="8-sql标签"><a href="#8-sql标签" class="headerlink" title="8_sql标签"></a>8_sql标签</h2><pre><code class="xml"> &lt;sql id=&quot;empColumn&quot;&gt;empno,ename,job,mgr,hiredate,sal,comm,deptno&lt;/sql&gt;
&lt;sql id=&quot;baseSelect&quot;&gt;select &lt;include refid=&quot;empColumn&quot;&gt;&lt;/include&gt; from emp&lt;/sql&gt;
&lt;!--List&lt;Emp&gt; findByCondition(Emp emp);--&gt;
&lt;select id=&quot;findByCondition&quot; resultType=&quot;emp&quot;&gt;
    &lt;include refid=&quot;baseSelect&quot;&gt;&lt;/include&gt;
    &lt;trim prefix=&quot;where&quot; prefixOverrides=&quot;and&quot;&gt;
        &lt;if test=&quot;empno != null&quot;&gt;
            and empno =#&#123;empno&#125;
        &lt;/if&gt;
        &lt;if test=&quot;ename != null and ename != &#39;&#39;&quot;&gt;
            &lt;bind name=&quot;likePattern&quot; value=&quot;&#39;%&#39;+ename+&#39;%&#39;&quot;/&gt;
            and ename like #&#123;likePattern&#125;
        &lt;/if&gt;
        &lt;if test=&quot;job != null and job != &#39;&#39;&quot;&gt;
            and job =#&#123;job&#125;
        &lt;/if&gt;
        &lt;if test=&quot;mgr != null&quot;&gt;
            and mgr =#&#123;mgr&#125;
        &lt;/if&gt;
        &lt;if test=&quot;hiredate != null&quot;&gt;
            and hiredate =#&#123;hiredate&#125;
        &lt;/if&gt;
        &lt;if test=&quot;sal != null&quot;&gt;
            and sal =#&#123;sal&#125;
        &lt;/if&gt;
        &lt;if test=&quot;comm != null&quot;&gt;
            and comm =#&#123;comm&#125;
        &lt;/if&gt;
        &lt;if test=&quot;deptno != null&quot;&gt;
            and deptno =#&#123;deptno&#125;
        &lt;/if&gt;
    &lt;/trim&gt;
&lt;/select&gt;
</code></pre><h2 id="9-foreach标签"><a href="#9-foreach标签" class="headerlink" title="9_foreach标签"></a>9_foreach标签</h2><pre><code class="xml"> &lt;!--List&lt;Emp&gt; findByEmpnos1(int[] empnos);
 collection=&quot;&quot;  遍历的集合或者是数组
                 参数是数组,collection中名字指定为array
                 参数是List集合,collection中名字指定为list
 separator=&quot;&quot;   多个元素取出的时候 用什么文字分隔
 open=&quot;&quot;        以什么开头
 close=&quot;&quot;       以什么结尾
 item=&quot;&quot;        中间变量名
 for(Person per:PersonList)
 --&gt;
 &lt;select id=&quot;findByEmpnos1&quot; resultType=&quot;emp&quot;&gt;
     select * from emp  where empno in
     &lt;foreach collection=&quot;array&quot; separator=&quot;,&quot; open=&quot;(&quot; close=&quot;)&quot; item=&quot;deptno&quot;&gt;
         #&#123;deptno&#125;
     &lt;/foreach&gt;
 &lt;/select&gt;
&lt;!-- List&lt;Emp&gt; findByEmpnos2(List&lt;Integer&gt; empnos);--&gt;
 &lt;select id=&quot;findByEmpnos2&quot; resultType=&quot;emp&quot;&gt;
     select * from emp  where empno in
     &lt;foreach collection=&quot;list&quot; separator=&quot;,&quot; open=&quot;(&quot; close=&quot;)&quot; item=&quot;deptno&quot;&gt;
         #&#123;deptno&#125;
     &lt;/foreach&gt;
 &lt;/select&gt;
</code></pre><h1 id="8-MyBatis实现多表查询"><a href="#8-MyBatis实现多表查询" class="headerlink" title="8 MyBatis实现多表查询"></a>8 MyBatis实现多表查询</h1><p>前面已经使用MyBatis完成了对Emp表的CRUD操作，不管是使用SqlSession直接操作，还是使用Mapper代理方式，都只是完成了对单个数据库表的操作。这肯定是远远不够的。</p><p>在实际开发中，经常会将来自多张表的数据在一个位置显示。比如查询并显示的员工信息中会有来自部门表、岗位表的数据，而后台一般是定义一个方法</p><h2 id="1-关联查询"><a href="#1-关联查询" class="headerlink" title="1 关联查询"></a>1 关联查询</h2><h3 id="1-手动处理映射关系"><a href="#1-手动处理映射关系" class="headerlink" title="1 手动处理映射关系"></a>1 手动处理映射关系</h3><p>实体类</p><pre><code class="java">public class Emp  implements Serializable &#123;
    private Integer empno;
    private String name;
    private String job;
    private Integer mgr;
    private Date hiredate;
    private Double sal;
    private Double comm;
    private Integer deptno;
&#125;
</code></pre><p>映射文件</p><pre><code class="xml">&lt;mapper namespace=&quot;com.msb.mapper.EmpMapper&quot;&gt;
    &lt;!--手动处理数据库查询字段和封装实体类属性之间的映射关系
    1 主键一般使用id属性
    2 当属性名和查询出的数据表字段名相同 可以不写映射关系
    --&gt;
    &lt;resultMap id=&quot;empMap&quot; type=&quot;emp&quot;&gt;
        &lt;!--&lt;id property=&quot;empno&quot; column=&quot;empno&quot;&gt;&lt;/id&gt;--&gt;
        &lt;result property=&quot;name&quot; column=&quot;ename&quot;&gt;&lt;/result&gt;
        &lt;!--&lt;result property=&quot;job&quot; column=&quot;job&quot;&gt;&lt;/result&gt;
        &lt;result property=&quot;sal&quot; column=&quot;sal&quot;&gt;&lt;/result&gt;
        &lt;result property=&quot;hiredate&quot; column=&quot;hiredate&quot;&gt;&lt;/result&gt;
        &lt;result property=&quot;mgr&quot; column=&quot;mgr&quot;&gt;&lt;/result&gt;
        &lt;result property=&quot;comm&quot; column=&quot;comm&quot;&gt;&lt;/result&gt;
        &lt;result property=&quot;deptno&quot; column=&quot;deptno&quot;&gt;&lt;/result&gt;--&gt;
    &lt;/resultMap&gt;
    &lt;select id=&quot;findByEmpno&quot; resultMap=&quot;empMap&quot; &gt;
        select * from emp where empno =#&#123;empno&#125;
    &lt;/select&gt;
&lt;/mapper&gt;
</code></pre><h3 id="2-一对一关联查询"><a href="#2-一对一关联查询" class="headerlink" title="2 一对一关联查询"></a>2 一对一关联查询</h3><p>数据准备: 创建项目表和项目记录表</p><img data-src="/2022/10/07/ORM/Mybatis/image-20220617200808312.png" title="image-20220617200808312"><pre><code class="sql">CREATE TABLE `projects`  (
  `pid` int(2) NOT NULL AUTO_INCREMENT,
  `pname` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL,
  `money` int(11) NULL DEFAULT NULL,
  PRIMARY KEY (`pid`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = Dynamic;
INSERT INTO `projects` VALUES (1, &#39; ***大学OA&#39;, 500000);
INSERT INTO `projects` VALUES (2, &#39;学生选课系统&#39;, 100000);
INSERT INTO `projects` VALUES (3, &#39;讲师测评系统&#39;, 20000);
INSERT INTO `projects` VALUES (4, &#39;线上问答系统 &#39;, 20000);
CREATE TABLE `projectrecord`  (
  `empno` int(4) NOT NULL,
  `pid` int(2) NOT NULL,
  PRIMARY KEY (`empno`, `pid`) USING BTREE,
  INDEX `fk_project_pro`(`pid`) USING BTREE,
  CONSTRAINT `fk_emp_pro` FOREIGN KEY (`empno`) REFERENCES `emp` (`EMPNO`) ON DELETE CASCADE ON UPDATE CASCADE,
  CONSTRAINT `fk_project_pro` FOREIGN KEY (`pid`) REFERENCES `projects` (`pid`) ON DELETE CASCADE ON UPDATE CASCADE
) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = Dynamic;
INSERT INTO `projectrecord` VALUES (7369, 1);
INSERT INTO `projectrecord` VALUES (7521, 1);
INSERT INTO `projectrecord` VALUES (7369, 2);
INSERT INTO `projectrecord` VALUES (7499, 2);
INSERT INTO `projectrecord` VALUES (7521, 2);
INSERT INTO `projectrecord` VALUES (7369, 3);
INSERT INTO `projectrecord` VALUES (7499, 3);
INSERT INTO `projectrecord` VALUES (7521, 3);
INSERT INTO `projectrecord` VALUES (7369, 4);
INSERT INTO `projectrecord` VALUES (7499, 4);
</code></pre><p>需求:根据编号查询员工信息及所在的部门信息</p><p>实体类添加一个部门作为属性</p><p>实体类</p><pre><code class="java">@AllArgsConstructor
@NoArgsConstructor
@Data
public class Emp implements Serializable &#123;
    private Integer empno;
    private String ename;
    private String job;
    private Integer mgr;
    private Date hiredate;
    private Double sal;
    private Double comm;
    private Integer deptno;
    // 组合一个Dept对象作为自己的属性
    private Dept dept;
&#125;
</code></pre><p>接口</p><pre><code class="java">public interface EmpMapper &#123;
    /**
     * 根据员工编号查询员工的所有信息并携带所在的部门信息
     * @param empno 要查询的员工编号
     * @return Emp对象,组合了Dept对象作为属性,对部门信息进行存储
     */
    Emp findEmpJoinDeptByEmpno(int empno);
&#125;
</code></pre><p>映射文件</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper
        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;com.msb.mapper.EmpMapper&quot;&gt;
    &lt;!--Emp findEmpJoinDeptByEmpno(int empno);--&gt;
    &lt;resultMap id=&quot;empJoinDept&quot; type=&quot;emp&quot;&gt;
        &lt;!--设置emp本身的八个属性的映射关系--&gt;
        &lt;id property=&quot;empno&quot; column=&quot;empno&quot;&gt;&lt;/id&gt;
        &lt;result property=&quot;ename&quot; column=&quot;ename&quot;&gt;&lt;/result&gt;
        &lt;result property=&quot;job&quot; column=&quot;job&quot;&gt;&lt;/result&gt;
        &lt;result property=&quot;sal&quot; column=&quot;sal&quot;&gt;&lt;/result&gt;
        &lt;result property=&quot;hiredate&quot; column=&quot;hiredate&quot;&gt;&lt;/result&gt;
        &lt;result property=&quot;mgr&quot; column=&quot;mgr&quot;&gt;&lt;/result&gt;
        &lt;result property=&quot;comm&quot; column=&quot;comm&quot;&gt;&lt;/result&gt;
        &lt;result property=&quot;deptno&quot; column=&quot;deptno&quot;&gt;&lt;/result&gt;
        &lt;!--
        association 处理一对一
        封装一对一信息关系的标签
        property  emp类的属性名
        javaType  用哪个类的对象给属性赋值
        --&gt;
        &lt;association property=&quot;dept&quot; javaType=&quot;dept&quot;&gt;
            &lt;id column=&quot;deptno&quot; property=&quot;deptno&quot;&gt;&lt;/id&gt;
            &lt;result column=&quot;dname&quot; property=&quot;dname&quot;&gt;&lt;/result&gt;
            &lt;result column=&quot;loc&quot; property=&quot;loc&quot;&gt;&lt;/result&gt;
        &lt;/association&gt;
    &lt;/resultMap&gt;
    &lt;select id=&quot;findEmpJoinDeptByEmpno&quot; resultMap=&quot;empJoinDept&quot; &gt;
        select * from
        emp e
        left join dept  d
        on e.deptno =d.deptno
        where empno = #&#123;empno&#125;
    &lt;/select&gt;
&lt;/mapper&gt;
</code></pre><p>测试代码</p><pre><code class="java">@Test
public void testOneToOne() throws ParseException &#123;
    EmpMapper mapper = sqlSession.getMapper(EmpMapper.class);
    Emp emp = mapper.findEmpJoinDeptByEmpno(7499);
    System.out.println(emp);
&#125;
</code></pre><p>3 一对多关联查询</p><p>根据部门号查询部门信息及该部门的所有员工信息</p><p>实体类</p><pre><code class="java">@Data
@AllArgsConstructor
@NoArgsConstructor
public class Dept implements Serializable &#123;
    private Integer deptno;
    private String dname;
    private String loc;
    // 组合一个Emp的List集合作为属性
    private List&lt;Emp&gt; empList;
&#125;
</code></pre><p>接口</p><pre><code class="java">package com.msb.mapper;
import com.msb.pojo.Dept;
/**
 * @Author: Ma HaiYang
 * @Description: MircoMessage:Mark_7001
 */
public interface DeptMapper &#123;
    /**
     * 根据部门编号查询部门信息及该部分的所有员工信息
     * @param deptno 要查询的部门编号
     * @return Dept对象,内部组合了一个Emp的List属性用于封装部门的所有员工信息
     */
    Dept findDeptJoinEmpsByDeptno(int deptno);
&#125;
</code></pre><p>映射文件</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper
        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;com.msb.mapper.DeptMapper&quot;&gt;
    &lt;!--Dept findDeptJoinEmpsByDeptno(int deptno);--&gt;
    &lt;resultMap id=&quot;deptJoinEmps&quot; type=&quot;dept&quot;&gt;
        &lt;id column=&quot;deptno&quot; property=&quot;deptno&quot;&gt;&lt;/id&gt;
        &lt;result column=&quot;dname&quot; property=&quot;dname&quot;&gt;&lt;/result&gt;
        &lt;result column=&quot;loc&quot; property=&quot;loc&quot;&gt;&lt;/result&gt;
        &lt;!--处理一对多关系的标签--&gt;
        &lt;collection property=&quot;empList&quot; ofType=&quot;emp&quot; &gt;
            &lt;!--设置emp本身的八个属性的映射关系--&gt;
            &lt;id property=&quot;empno&quot; column=&quot;empno&quot;&gt;&lt;/id&gt;
            &lt;result property=&quot;ename&quot; column=&quot;ename&quot;&gt;&lt;/result&gt;
            &lt;result property=&quot;job&quot; column=&quot;job&quot;&gt;&lt;/result&gt;
            &lt;result property=&quot;sal&quot; column=&quot;sal&quot;&gt;&lt;/result&gt;
            &lt;result property=&quot;hiredate&quot; column=&quot;hiredate&quot;&gt;&lt;/result&gt;
            &lt;result property=&quot;mgr&quot; column=&quot;mgr&quot;&gt;&lt;/result&gt;
            &lt;result property=&quot;comm&quot; column=&quot;comm&quot;&gt;&lt;/result&gt;
            &lt;result property=&quot;deptno&quot; column=&quot;deptno&quot;&gt;&lt;/result&gt;
        &lt;/collection&gt;
    &lt;/resultMap&gt;
    &lt;select id=&quot;findDeptJoinEmpsByDeptno&quot; resultMap=&quot;deptJoinEmps&quot;&gt;
        select * from dept d left join emp e on d.deptno =e.deptno where d.deptno =#&#123;deptno&#125;
    &lt;/select&gt;
&lt;/mapper&gt;
</code></pre><p>测试代码</p><pre><code class="java">@Test
public void testOneToMany() throws ParseException &#123;
    DeptMapper mapper = sqlSession.getMapper(DeptMapper.class);
    Dept dept = mapper.findDeptJoinEmpsByDeptno(20);
    System.out.println(dept);
    System.out.println(&quot;---------&quot;);
    List&lt;Emp&gt; empList = dept.getEmpList();
    empList.forEach(System.out::println);
&#125;
</code></pre><p>4 多对多关联查询</p><p>根据项目编号查询项目信息,以及参与到该项目之中的所有的员工信息</p><p>实体类</p><pre><code class="java">@NoArgsConstructor
@AllArgsConstructor
@Data
public class Project  implements Serializable &#123;
    private Integer pid;
    private String pname;
    private Integer money;
    // 组合一个ProjectRecord对象集合作为属性
    private List&lt;ProjectRecord&gt; projectRecords;
&#125;
@Data
@AllArgsConstructor
@NoArgsConstructor
public class ProjectRecord implements Serializable &#123;
    private Integer empno;
    private Integer pid;
    // 组合一个Emp对象作为属性
    private Emp emp;
&#125;
</code></pre><p>接口</p><pre><code class="java">package com.msb.mapper;
import com.msb.pojo.Emp;
import com.msb.pojo.Project;
/**
 * @Author: Ma HaiYang
 * @Description: MircoMessage:Mark_7001
 */
public interface ProjectMapper &#123;
    /**
     * 根据项目编号查询一个项目信息及参与该项目的所有员工信息
     * @param pid 项目编号
     * @return 所有信息封装的Project对象
     */
    Project findProjectJoinEmpsByPid(int pid);
&#125;
</code></pre><p>映射文件</p><pre><code class="xml">&lt;!DOCTYPE mapper
        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;com.msb.mapper.ProjectMapper&quot;&gt;
    &lt;!--Project findProjectJoinEmpsByPid(int pid);--&gt;
    &lt;resultMap id=&quot;projectJoinEmps&quot; type=&quot;project&quot;&gt;
        &lt;id column=&quot;pid&quot; property=&quot;pid&quot;&gt;&lt;/id&gt;
        &lt;result column=&quot;pname&quot; property=&quot;pname&quot;&gt;&lt;/result&gt;
        &lt;result column=&quot;money&quot; property=&quot;money&quot;&gt;&lt;/result&gt;
        &lt;!--一对多 集合属性 collection--&gt;
        &lt;collection property=&quot;projectRecords&quot; ofType=&quot;projectRecord&quot;&gt;
            &lt;id column=&quot;empno&quot; property=&quot;empno&quot;&gt;&lt;/id&gt;
            &lt;id column=&quot;pid&quot; property=&quot;pid&quot;&gt;&lt;/id&gt;
            &lt;!--一对一 --&gt;
            &lt;association property=&quot;emp&quot; javaType=&quot;emp&quot;&gt;
                &lt;id property=&quot;empno&quot; column=&quot;empno&quot;&gt;&lt;/id&gt;
                &lt;result property=&quot;ename&quot; column=&quot;ename&quot;&gt;&lt;/result&gt;
                &lt;result property=&quot;job&quot; column=&quot;job&quot;&gt;&lt;/result&gt;
                &lt;result property=&quot;sal&quot; column=&quot;sal&quot;&gt;&lt;/result&gt;
                &lt;result property=&quot;hiredate&quot; column=&quot;hiredate&quot;&gt;&lt;/result&gt;
                &lt;result property=&quot;mgr&quot; column=&quot;mgr&quot;&gt;&lt;/result&gt;
                &lt;result property=&quot;comm&quot; column=&quot;comm&quot;&gt;&lt;/result&gt;
                &lt;result property=&quot;deptno&quot; column=&quot;deptno&quot;&gt;&lt;/result&gt;
            &lt;/association&gt;
        &lt;/collection&gt;
    &lt;/resultMap&gt;
    &lt;select id=&quot;findProjectJoinEmpsByPid&quot;  resultMap=&quot;projectJoinEmps&quot;&gt;
        select * from
        project p
        left join projectrecord pr
        on p.pid = pr.pid
        left join emp e
        on e.empno = pr.empno
        where p.pid= #&#123;pid&#125;
    &lt;/select&gt;
&lt;/mapper&gt;
</code></pre><p>测试代码</p><pre><code class="java">@Test
public void testManyToMany() throws ParseException &#123;
    ProjectMapper mapper = sqlSession.getMapper(ProjectMapper.class);
    Project project = mapper.findProjectJoinEmpsByPid(2);
    System.out.println(project.getPid());
    System.out.println(project.getPname());
    System.out.println(project.getMoney());
    List&lt;ProjectRecord&gt; projectRecords = project.getProjectRecords();
    for (ProjectRecord projectRecord : projectRecords) &#123;
        Emp emp = projectRecord.getEmp();
        System.out.println(emp);
    &#125;
&#125;
</code></pre><h2 id="2-级联查询"><a href="#2-级联查询" class="headerlink" title="2 级联查询"></a>2 级联查询</h2><p>级联查询，顾名思义，就是利于数据库表间的外键关联关系进行自动的级联查询操作。使用MyBatis实现级联查询，除了实体类增加关联属性外，还需要在映射文件中进行配置。</p><h3 id="1-立即加载"><a href="#1-立即加载" class="headerlink" title="1 立即加载"></a>1 立即加载</h3><h3 id="2-延迟加载"><a href="#2-延迟加载" class="headerlink" title="2 延迟加载"></a>2 延迟加载</h3><p><strong>延迟加载，又称按需加载</strong>。延迟加载的内容等到真正使用时才去进行加载（查询）。多用在关联对象或集合中。</p><p>延迟加载的好处：先从单表查询、需要时再从关联表去关联查询，大大降低数据库在单位时间内的查询工作量,将工作在时间上的分配更加均匀，而且单表要比关联查询多张表速度要快。</p><p>延迟加载的设置</p><p>第一步：全局开关：在sqlMapConfig.xml中打开延迟加载的开关。配置完成后所有的association和collection元素都生效</p><pre><code class="xml">  &lt;settings&gt;
      &lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot;/&gt;
      &lt;setting name=&quot;aggressiveLazyLoading&quot; value=&quot;true&quot;/&gt;
  &lt;/settings&gt;
</code></pre><p><font color="#008000">lazyLoadingEnabled</font>:是否开启延迟加载。是Mybatis是否启用懒加载的全局开关。当开启时，所有关联对象都会延迟加载。特定关联关系中可通过设置fetchType属性来覆盖该项的开关状态</p><p><font color="#008000">aggressiveLazyLoading</font>：当开启时，任何方法的调用都会懒加载对象的所有属性。否则，每个属性会按需加载,</p><p>第二步：分开关：指定的association和collection元素中配置<font color="#0000FF">fetchType</font>属性。eager：表示立刻加载；lazy：表示延迟加载。<strong>将覆盖全局延迟设置。</strong></p><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3 总结"></a>3 总结</h2><h4 id="resultMap中的常见属性"><a href="#resultMap中的常见属性" class="headerlink" title="resultMap中的常见属性"></a>resultMap中的常见属性</h4><table style="text-align:center" cellpadding="30"><tr style="background-color:#E2EFD9"><td>property</td><td>需要映射到JavaBean 的属性名称</td></tr><tr><td>javaType</td><td>property的类型，一个完整的类名，或者是一个类型别名。如果你匹配的是一个JavaBean，那MyBatis 通常会自行检测到</td></tr><tr style="background-color:#E2EFD9"><td>column</td><td>数据表的列名或者列别名</td></tr><tr><td>jdbcType</td><td>column在数据库表中的类型。这个属性只在insert,update 或delete 的时候针对允许空的列有用。JDBC 需要这项，但MyBatis 不需要</td></tr><tr style="background-color:#E2EFD9"><td>typeHandler</td><td>使用这个属性可以覆写类型处理器，实现javaType、jdbcType之间的相互转换。一般可以省略，会探测到使用的什么类型的typeHandler进行处理</td></tr><tr><td>fetchType</td><td>自动延迟加载</td></tr><tr style="background-color:#E2EFD9"><td>select</td><td>association、collection的属性，使用哪个查询查询属性的值，要求指定namespace+id的全名称</td></tr><tr><td>ofType</td><td>collection的属性，指明集合中元素的类型（即泛型类型）</td></tr></table><h4 id="级联查询和多表查询的比较及其选择"><a href="#级联查询和多表查询的比较及其选择" class="headerlink" title="级联查询和多表查询的比较及其选择"></a>级联查询和多表查询的比较及其选择</h4><table style="text-align:center" cellpadding="30"><tr style="background-color:#E2EFD9"><td>SQL语句数量</td><td>多条</td><td>一条</td></tr><tr><td>性能</td><td>性能低</td><td>性能高</td></tr><tr style="background-color:#E2EFD9"><td>延迟加载</td><td>立即加载、延迟加载</td><td>只有立即加载</td></tr><tr><td>灵活性</td><td>更灵活</td><td>不灵活</td></tr><tr style="background-color:#E2EFD9"><td>SQL难易度</td><td>简单</td><td>复杂</td></tr><tr><td>选择依据</td><td>简单、灵活</td><td>高性能</td></tr></table><p><strong>ResultType和ResultMap使用场景</strong></p><ol><li><pre><code>如果你做的是单表的查询并且封装的实体和数据库的字段一一对应   resultType
</code></pre></li><li><pre><code>如果实体封装的属性和数据库的字段不一致  resultMap
</code></pre></li><li><pre><code> 使用N+1级联查询的时候  resultMap
</code></pre></li><li><pre><code>使用的是多表的连接查询  resultMap
</code></pre></li></ol><p><strong>一对一关联映射的实现</strong></p><ol><li><pre><code>实例：学生和学生证、雇员和工牌
</code></pre></li><li><pre><code>数据库层次：主键关联或者外键关联（参看之前内容）
</code></pre></li><li><pre><code> MyBatis层次：在映射文件的设置双方均使用association即可，用法相同
</code></pre></li></ol><p><strong>多对多映射的实现</strong></p><ol><li><pre><code>实例：学生和课程、用户和角色
</code></pre></li><li><pre><code> 数据库层次：引入一个中间表将一个多对多转为两个一对多
</code></pre></li><li><pre><code> MyBatis层次
</code></pre></li></ol><p>方法1：在映射文件的设置双方均使用collection即可，不用引入中间类</p><p>方法2：引入中间类和中间类的映射文件，按照两个一对多处理</p><p><strong>自关联映射</strong></p><ol><li><pre><code>实例：Emp表中的员工和上级。一般是一对多关联
</code></pre></li><li><pre><code>数据库层次：外键参考当前表的主键（比如mgr参考empno）
</code></pre></li><li><p>MyBatis层次：按照一对多处理，但是增加的属性都写到一个实体类中，增加的映射也都写到一个映射文件中</p></li></ol><h1 id="9-MyBatis注解开发"><a href="#9-MyBatis注解开发" class="headerlink" title="9 MyBatis注解开发"></a>9 MyBatis注解开发</h1><pre><code class="java">public interface DeptMapper &#123;
    Dept findDeptByDeptno(int deptno);
    @Select(&quot;select * from dept where deptno =#&#123;deptno&#125;&quot;)
    Dept findByDeptno(int deptno);
    int updateDept(Dept dept);
    int addDept(Dept dept);
    @Delete(&quot;delete from dept where deptno =#&#123;deptno&#125;&quot;)
    int removeDept(int deptno);
&#125;
</code></pre><p>1.使用注解没有实现Java代码和SQL语句的解耦</p><p>2.无法实现SQL语句的动态拼接</p><p>3.进行多表的查询时定制ResultMap比较麻烦</p><p><strong>注解和XML的优缺点</strong></p><table style="text-align:center" cellpadding="30"><tr style="background-color:#E2EFD9"><td>优点</td><td>类和类之间的解耦</td><td>简化配置</td></tr><tr><td></td><td>利于修改。直接修改XML文件，无需到源代码中修改。</td><td>使用起来直观且容易，提升开发效率</td></tr><tr style="background-color:#E2EFD9"><td></td><td>配置集中在XML中，对象间关系一目了然，利于快速了解项目和维护</td><td>类型安全，编译器进行校验，不用等到运行期才会发现错误</td></tr><tr><td></td><td>容易和其他系统进行数据交交换</td><td>注解的解析可以不依赖于第三方库，可以直接使用Java自带的反射</td></tr></table><h1 id="10-缓存"><a href="#10-缓存" class="headerlink" title="10 缓存"></a>10 缓存</h1><img data-src="/2022/10/07/ORM/Mybatis/image-20220617211853352.png" title="image-20220617211853352"><blockquote><p>​	是一种临时存储少量数据至内存或者是磁盘的一种技术.减少数据的加载次数,可以降低工作量,提高程序响应速度</p><p>​	缓存的重要性是不言而喻的。mybatis的缓存将相同查询条件的SQL语句执行一遍后所得到的结果存在内存或者某种缓存介质当中，当下次遇到一模一样的查询SQL时候不在执行SQL与数据库交互，而是直接从缓存中获取结果，减少服务器的压力；尤其是在查询越多、缓存命中率越高的情况下，使用缓存对性能的提高更明显。</p><p>​	MyBatis允许使用缓存，缓存一般放置在高速读&#x2F;写的存储器上，比如服务器的内存，能够有效的提供系统性能。MyBatis分为<font color="#FF0000">一级缓存和二级缓存</font>，同时也可配置关于缓存设置。</p><p>​	一级存储是SqlSession上的缓存，二级缓存是在SqlSessionFactory(namespace)上的缓存。默认情况下，MyBatis开启一级缓存，没有开启二级缓存。当数据量大的时候可以借助一些第三方缓存框架或Redis缓存来协助保存Mybatis的二级缓存数据。</p></blockquote><img data-src="/2022/10/07/ORM/Mybatis/image-20220617211938471.png" title="image-20220617211938471"><h2 id="1-一级缓存"><a href="#1-一级缓存" class="headerlink" title="1 一级缓存"></a>1 一级缓存</h2><p>一级存储是SqlSession上的缓存，默认开启，是一种内存型缓存,不要求实体类对象实现Serializable接口。</p><p>缓存中的数据使用键值对形式存储数据</p><p>&#x3D;&#x3D;namespace + sqlid + args + offset &gt;&gt;&gt; hash 值作为键,查询出的结果作为值&#x3D;&#x3D;</p><img data-src="/2022/10/07/ORM/Mybatis/image-20220617212008075.png" title="image-20220617212008075"><p>测试 代码</p><pre><code class="java">@Test
public void testFindDeptByDetpno()   &#123;
    EmpMapper mapper = sqlSession.getMapper(EmpMapper.class);
    Emp emp = mapper.findByEmpno(7521);
    System.out.println(emp);
    // 中间发生了增删改或者是调用了SqlSession调用了commit,会自动清空缓存
    sqlSession.commit();// 增删改的时候调用
    EmpMapper mapper2 = sqlSession.getMapper(EmpMapper.class);
    Emp emp2 = mapper2.findByEmpno(7521);
    System.out.println(emp2); 
    
    System.out.println(emp==emp2);// 没有commit之前为True
    System.out.println(mapper==mapper2);// false 表示确实产生了两个代理对象
&#125;
</code></pre><h2 id="2-二级缓存"><a href="#2-二级缓存" class="headerlink" title="2 二级缓存"></a>2 二级缓存</h2><p>二级缓存是以namespace为标记的缓存，可以是由一个SqlSessionFactory创建的SqlSession之间共享缓存数据。默认并不开启。下面的代码中创建了两个SqlSession，执行相同的SQL语句，尝试让第二个SqlSession使用第一个SqlSession查询后缓存的数据。要求实体类必须实现序列化接口</p><img data-src="/2022/10/07/ORM/Mybatis/image-20220617212052512.png" title="image-20220617212052512"><p>接口</p><pre><code class="java">public interface EmpMapper &#123;
    Emp findByEmpno(int empno);
&#125;
</code></pre><p>映射文件</p><pre><code class="xml">&lt;mapper namespace=&quot;com.msb.mapper.EmpMapper&quot;&gt;
    &lt;cache/&gt;
    &lt;select id=&quot;findByEmpno&quot; resultType=&quot;emp&quot; useCache=&quot;true&quot; flushCache=&quot;false&quot;&gt;
        select * from emp where empno =#&#123;empno&#125;
    &lt;/select&gt;
&lt;/mapper&gt;
</code></pre><p>测试 代码</p><pre><code class="java">package com.msb.test;
import com.msb.mapper.EmpMapper;
import com.msb.pojo.Emp;
import org.apache.ibatis.io.Resources;
import org.apache.ibatis.session.SqlSession;
import org.apache.ibatis.session.SqlSessionFactory;
import org.apache.ibatis.session.SqlSessionFactoryBuilder;
import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import java.io.IOException;
import java.io.InputStream;
/**
 * @Author: Ma HaiYang
 * @Description: MircoMessage:Mark_7001
 */
public class Test3 &#123;
    private SqlSession sqlSession;
    private SqlSession sqlSession2;
    @Before
    public void init()&#123;
        SqlSessionFactoryBuilder ssfb =new SqlSessionFactoryBuilder();
        InputStream resourceAsStream = null;
        try &#123;
            resourceAsStream = Resources.getResourceAsStream(&quot;sqlMapConfig.xml&quot;);
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125;
        SqlSessionFactory factory=ssfb.build(resourceAsStream) ;
        sqlSession=factory.openSession();
        sqlSession2=factory.openSession();
    &#125;
    @Test
    public void testFindDeptByDetpno()   &#123;
        EmpMapper mapper = sqlSession.getMapper(EmpMapper.class);
        Emp emp = mapper.findByEmpno(7521);
        System.out.println(emp);
        // SqlSession提交之后,才会将查询的结果放入二级缓存
        sqlSession.commit();
        EmpMapper mapper2 = sqlSession2.getMapper(EmpMapper.class);
        Emp emp2 = mapper2.findByEmpno(7521);
        System.out.println(emp2);
    &#125;
    @After
    public void release()&#123;
        // 关闭SQLSession
        sqlSession.close();
        sqlSession2.close();
    &#125;
&#125;
</code></pre><p><strong>注意：</strong></p><p>​	其中的commit()，执行该命令后才会将该SqlSession的查询结果从一级缓存中放入二级缓存，供其他SqlSession使用。另外执行SqlSession的close()也会将该SqlSession的查询结果从一级缓存中放入二级缓存。两种方式区别在当前SqlSession是否关闭了。</p><p>执行结果显示进行了两次对数据库的SQL查询，说明二级缓存并没有开启。需要进行如下步骤完成开启。</p><ol><li>全局开关：在sqlMapConfig.xml文件中的<font color="blue"><settings></settings></font>标签配置开启二级缓存</li></ol><pre><code class="xml">&lt;settings&gt;
    &lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt;
&lt;/settings&gt;
</code></pre><p>cacheEnabled的默认值就是true，所以这步的设置可以省略。</p><ol start="2"><li>分开关：在要开启二级缓存的mapper文件中开启缓存：</li></ol><pre><code class="xml">&lt;mapper namespace=&quot;com.msb.mapper.EmployeeMapper&quot;&gt;
    &lt;cache/&gt;
&lt;/mapper&gt;
</code></pre><ol start="3"><li>二级缓存未必完全使用内存,有可能占用硬盘存储,缓存中存储的JavaBean对象必须实现序列化接口,</li></ol><pre><code class="java">public class Emp implements  Serializable &#123;  &#125;
</code></pre><p>经过设置后，查询结果如图所示。发现第一个SqlSession会首先去二级缓存中查找，如果不存在，就查询数据库，<font color="#FF0000">在commit()或者close()的时候将数据放入到二级缓存</font>。第二个SqlSession执行相同SQL语句查询时就直接从二级缓存中获取了。</p><p><strong>注意：</strong></p><p>​	1) MyBatis的二级缓存的缓存介质有多种多样，而并不一定是在内存中，所以需要对JavaBean对象实现序列化接口。</p><ol start="2"><li>二级缓存是以 namespace 为单位的，不同 namespace 下的操作互不影响</li></ol><p>​	3) 加入Cache元素后，会对相应命名空间所有的select元素查询结果进行缓存，而其中的insert、update、delete在操作是会清空整个namespace的缓存。</p><p>​	4) cache 有一些可选的属性 type, eviction, flushInterval, size, readOnly, blocking。</p><pre><code class="xml">&lt;cache type=&quot;&quot; readOnly=&quot;&quot; eviction=&quot;&quot;flushInterval=&quot;&quot;size=&quot;&quot;blocking=&quot;&quot;/&gt;
</code></pre><p>&lt;cache type&#x3D;”” readOnly&#x3D;”” eviction&#x3D;””flushInterval&#x3D;””size&#x3D;””blocking&#x3D;””&#x2F;&gt;</p><table style="text-align:center" cellpadding="30"><style>td{text-align:center}p{text-align:center}</style><tr style="background-color:#E2EFD9"><td>type</td><td><p>自定义缓存类，要求实现org.apache.ibatis.cache.Cache接口</p></td><td>null</td></tr><tr><td>readOnly</td><td><p>是否只读</p><p>true:给所有调用者返回缓存对象的相同实例。因此这些对象不能被修改。</p><span>这提供了很重要的性能优势。</span><p>false:会返回缓存对象的拷贝(通过序列化)。</p><p>这会慢一些,但是安全</p></td><td>false</td></tr><tr style="background-color:#E2EFD9"><td>eviction</td><td><p>缓存策略<br>LRU（默认） – 最近最少使用：移除最长时间不被使用的对象。</p><p>FIFO – 先进先出：按对象进入缓存的顺序来移除它们。</p><p>SOFT – 软引用：基于垃圾回收器状态和软引用规则移除对象。</p><p>WEAK – 弱引用：更积极地基于垃圾收集器状态和弱引用规则移除对象。</p></td><td>LRU</td></tr><tr><td>flushInterval</td><td><p>刷新间隔，毫秒为单位。默认为null，也就是没有刷新间隔，</p><p>只有执行update、insert、delete语句才会刷新</p></td><td>null</td></tr><tr style="background-color:#E2EFD9"><td>size</td><td><p>缓存对象个数</p><p></p></td><td>1024</td></tr><tr><td>blocking</td><td><p>是否使用阻塞性缓存BlockingCache</p><p>true：在查询缓存时锁住对应的Key，如果缓存命中了则会释放对应的锁，</p><span>否则会在查询数据库以后再释放锁，</span><p>保证只有一个线程到数据库中查找指定key对应的数据</p><p>false：不使用阻塞性缓存，性能更好</p></td><td>false</td></tr></table><ol start="5"><li>如果在加入Cache元素的前提下让个别select 元素不使用缓存，可以使用useCache属性，设置为false。useCache控制当前sql语句是否启用缓存 flushCache控制当前sql执行一次后是否刷新缓存</li></ol><pre><code class="xml">&lt;select id=&quot;findByEmpno&quot; resultType=&quot;emp&quot; useCache=&quot;true&quot; flushCache=&quot;false&quot;&gt;
</code></pre><h2 id="3-三方缓存"><a href="#3-三方缓存" class="headerlink" title="3 三方缓存"></a>3 三方缓存</h2><blockquote><p>分布式缓存框架：我们系统为了提高系统并发和性能，一般对系统进行分布式部署（集群部署方式）不适用分布缓存， 缓存的数据在各个服务单独存储，不方便系统开发。所以要使用分布式缓存对缓存数据进行集中管理.ehcache,redis ,memcache缓存框架。</p></blockquote><p>Ehcache：是一种广泛使用的开源java分布式缓存。主要面向通用缓存，javaEE 和 轻量级容器。它具有内存和磁盘存储功能。被用于大型复杂分布式web application的</p><p>这里的三方缓存是作为二级缓存使用的</p><p>导入依赖的jar文件</p><pre><code class="xml"> &lt;dependency&gt;
    &lt;groupId&gt;org.mybatis.caches&lt;/groupId&gt;
    &lt;artifactId&gt;mybatis-ehcache&lt;/artifactId&gt;
    &lt;version&gt;1.0.2&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;net.sf.ehcache&lt;/groupId&gt;
    &lt;artifactId&gt;ehcache&lt;/artifactId&gt;
    &lt;version&gt;2.10.1&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
    &lt;artifactId&gt;slf4j-nop&lt;/artifactId&gt;
    &lt;version&gt;1.7.2&lt;/version&gt;
&lt;/dependency&gt;
</code></pre><p>去各自的sql映射文件里,开启二级缓存,并把缓存类型指定为EhcacheCache</p><pre><code class="xml"> &lt;cache type=&quot;org.mybatis.caches.ehcache.EhcacheCache&quot;/&gt;
</code></pre><p>在资源目录下放置一个缓存配置文件,文件名为: ehcache.xml 内容如下</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;ehcache xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:noNamespaceSchemaLocation=&quot;ehcache.xsd&quot;
         updateCheck=&quot;true&quot; monitoring=&quot;autodetect&quot;
         dynamicConfig=&quot;true&quot;&gt;
    &lt;diskStore path=&quot;D:\msb\ehcache&quot; /&gt;
    &lt;defaultCache
            maxElementsInMemory=&quot;1000&quot;
            maxElementsOnDisk=&quot;10000000&quot;
            eternal=&quot;false&quot;
            overflowToDisk=&quot;true&quot;
            timeToIdleSeconds=&quot;120&quot;
            timeToLiveSeconds=&quot;120&quot;
            diskExpiryThreadIntervalSeconds=&quot;120&quot;
            memoryStoreEvictionPolicy=&quot;LRU&quot;&gt;
    &lt;/defaultCache&gt;
&lt;/ehcache&gt;
        &lt;!--  Cache配置
        ·           name：Cache的唯一标识
        ·           maxElementsInMemory：内存中最大缓存对象数。
        ·           maxElementsOnDisk：磁盘中最大缓存对象数，若是0表示无穷大。
        ·           eternal：Element是否永久有效，一但设置了，timeout将不起作用。
        ·           overflowToDisk：配置此属性，当内存中Element数量达到maxElementsInMemory时，Ehcache将会Element写到磁盘中。
        ·           timeToIdleSeconds：设置Element在失效前的允许闲置时间。仅当element不是永久有效时使用，可选属性，默认值是0，也就是可闲置时间无穷大。
        ·           timeToLiveSeconds：设置Element在失效前允许存活时间。最大时间介于创建时间和失效时间之间。仅当element不是永久有效时使用，默认是0.，也就是element存活时间无穷大。
        ·           diskExpiryThreadIntervalSeconds：磁盘失效线程运行时间间隔，默认是120秒。
        ·           diskSpoolBufferSizeMB：这个参数设置DiskStore（磁盘缓存）的缓存区大小。默认是30MB。每个Cache都应该有自己的一个缓冲区。
        ·           memoryStoreEvictionPolicy：当达到maxElementsInMemory限制时，Ehcache将会根据指定的策略去清理内存。默认策略是LRU（最近最少使用）。你可以设置为FIFO（先进先出）或是LFU（较少使用）。     --&gt;
</code></pre><h1 id="11-逆向工程"><a href="#11-逆向工程" class="headerlink" title="11 逆向工程"></a>11 逆向工程</h1><blockquote><p>MyBatisPlus 内容，简略分析，可以参考后面具体内容</p></blockquote><p>MyBatis的一个主要的特点就是需要程序员自己编写SQL，那么如果表太多的话，难免会很麻烦，所以MyBatis官方提供了一个逆向工程，可以针对单表自动生成MyBatis执行所需要的代码（包括mapper.xml，mapper.java，pojo）。一般在开发中，常用的逆向工程方式是通过数据库的表生成代码。</p><p>创建maven项目导入逆向工程依赖</p><img data-src="/2022/10/07/ORM/Mybatis/image-20220617221042957.png" title="image-20220617221042957"><pre><code class="xml">&lt;dependencies&gt;
  
    &lt;!-- mysql驱动包 --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;mysql&lt;/groupId&gt;
        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
        &lt;version&gt;8.0.16&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;!-- 日志包，方便查看执行信息--&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
        &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;
        &lt;version&gt;1.6.1&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;!-- 代码生成工具jar --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt;
        &lt;artifactId&gt;mybatis-generator-core&lt;/artifactId&gt;
        &lt;version&gt;1.3.2&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre><p>配置逆向工程配置文件 在resources目录下放置一个名为generatorConfig.xml的配置文件,文件内容如下</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE generatorConfiguration
  PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;
  &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt;
&lt;generatorConfiguration&gt;
   &lt;context id=&quot;testTables&quot; targetRuntime=&quot;MyBatis3&quot;&gt;
      &lt;commentGenerator&gt;
         &lt;!-- 是否去除自动生成的注释 true：是 ： false:否 --&gt;
         &lt;property name=&quot;suppressAllComments&quot; value=&quot;true&quot; /&gt;
      &lt;/commentGenerator&gt;
      &lt;!--数据库连接的信息：驱动类、连接地址、用户名、密码 --&gt;
      &lt;!-- &lt;jdbcConnection driverClass=&quot;com.mysql.jdbc.Driver&quot;
         connectionURL=&quot;jdbc:mysql://localhost:3306/mybatis&quot; userId=&quot;root&quot;
         password=&quot;123&quot;&gt;
      &lt;/jdbcConnection&gt; --&gt;
       &lt;jdbcConnection driverClass=&quot;com.mysql.cj.jdbc.Driver&quot;
         connectionURL=&quot;jdbc:mysql://127.0.0.1:3306/mydb?useSSL=false&amp;amp;useUnicode=true&amp;amp;characterEncoding=UTF-8&amp;amp;serverTimezone=Asia/Shanghai&amp;amp;allowPublicKeyRetrieval=true&quot;
         userId=&quot;root&quot;
         password=&quot;root&quot;&gt;
      &lt;/jdbcConnection&gt; 
      &lt;!-- 默认false，把JDBC DECIMAL 和 NUMERIC 类型解析为 Integer，为 true时把JDBC DECIMAL 和 
         NUMERIC 类型解析为java.math.BigDecimal --&gt;
      &lt;javaTypeResolver&gt;
         &lt;property name=&quot;forceBigDecimals&quot; value=&quot;false&quot; /&gt;
      &lt;/javaTypeResolver&gt;
      &lt;!-- targetProject:生成PO类的位置 --&gt;
      &lt;javaModelGenerator targetPackage=&quot;com.msb.pojo&quot;
         targetProject=&quot;.\src&quot;&gt;
         &lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt;
         &lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot; /&gt;
         &lt;!-- 从数据库返回的值被清理前后的空格 --&gt;
         &lt;property name=&quot;trimStrings&quot; value=&quot;true&quot; /&gt;
      &lt;/javaModelGenerator&gt;
        &lt;!-- targetProject:mapper映射文件生成的位置 --&gt;
      &lt;sqlMapGenerator targetPackage=&quot;com.msb.mapper&quot;
         targetProject=&quot;.\src&quot;&gt;
         &lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt;
         &lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot; /&gt;
      &lt;/sqlMapGenerator&gt;
      &lt;!-- targetPackage：mapper接口生成的位置 --&gt;
      &lt;javaClientGenerator type=&quot;XMLMAPPER&quot;
         targetPackage=&quot;com.msb.mapper&quot;
         targetProject=&quot;.\src&quot;&gt;
         &lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt;
         &lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot; /&gt;
      &lt;/javaClientGenerator&gt;
      &lt;!-- 指定数据库表 --&gt;
      
      &lt;table tableName=&quot;dept&quot; domainObjectName=&quot;Dept&quot;
       enableCountByExample=&quot;false&quot; enableUpdateByExample=&quot;false&quot; enableDeleteByExample=&quot;false&quot;    
               enableSelectByExample=&quot;false&quot; selectByExampleQueryId=&quot;false&quot; &gt;
               &lt;columnOverride column=&quot;id&quot; javaType=&quot;Integer&quot; /&gt;
         &lt;/table&gt;
      
   &lt;/context&gt;
&lt;/generatorConfiguration&gt;
</code></pre><p>在resources目录下放置一个名为log4j.properties的配置文件,文件内容如下</p><pre><code class="properties">log4j.rootLogger=debug,stdout
log4j.appender.stdout=org.apache.log4j.ConsoleAppender
log4j.appender.stdout.Target=System.err
log4j.appender.stdout.layout=org.apache.log4j.SimpleLayout
log4j.appender.logfile=org.apache.log4j.FileAppender
log4j.appender.logfile.File=d:/msb.log
log4j.appender.logfile.layout=org.apache.log4j.PatternLayout
log4j.appender.logfile.layout.ConversionPattern=%d&#123;yyyy-MM-dd HH:mm:ss&#125; %l %F %p %m%n
</code></pre><p>运行逆向工程代码</p><pre><code class="java">package com.msb.gennerator;
import org.mybatis.generator.api.MyBatisGenerator;
import org.mybatis.generator.config.Configuration;
import org.mybatis.generator.config.xml.ConfigurationParser;
import org.mybatis.generator.internal.DefaultShellCallback;
import java.io.File;
import java.util.ArrayList;
import java.util.List;
/**
 *
 */
public class GeneratorSqlmap &#123;
    public void generator() throws Exception&#123;
        List&lt;String&gt; warnings = new ArrayList&lt;String&gt;();
        boolean overwrite = true;
        File configFile = new File(&quot;D:\\ideaProjects\\reverse\\target\\classes\\generatorConfig.xml&quot;);
        ConfigurationParser cp = new ConfigurationParser(warnings);
        Configuration config = cp.parseConfiguration(configFile);
        DefaultShellCallback callback = new DefaultShellCallback(overwrite);
        MyBatisGenerator myBatisGenerator = new MyBatisGenerator(config,
                callback, warnings);
        myBatisGenerator.generate(null);
    &#125;
    public static void main(String[] args) throws Exception &#123;
        try &#123;
            GeneratorSqlmap generatorSqlmap = new GeneratorSqlmap();
            generatorSqlmap.generator();
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;
</code></pre><p>生成的实体类和Mapper接口和Mapper映射文件,包含了基本的CURD功能,哪里需要文件就放哪里</p><img data-src="/2022/10/07/ORM/Mybatis/image-20220617221208040-1665157666426.png" title="image-20220617221208040"><h1 id="12-main目录下配置文件打包问题"><a href="#12-main目录下配置文件打包问题" class="headerlink" title="12 main目录下配置文件打包问题"></a>12 main目录下配置文件打包问题</h1><pre><code class="xml">&lt;build&gt;
    &lt;!--告诉maven将项目源码中的xml文件也进行编译，并放到编译目录中--&gt;
    &lt;resources&gt;
        &lt;resource&gt;
            &lt;directory&gt;src/main/java&lt;/directory&gt;
            &lt;includes&gt;
                &lt;include&gt;**/*.xml&lt;/include&gt;
            &lt;/includes&gt;
            &lt;filtering&gt;true&lt;/filtering&gt;
        &lt;/resource&gt;
        &lt;resource&gt;
            &lt;directory&gt;src/main/resources&lt;/directory&gt;
            &lt;filtering&gt;true&lt;/filtering&gt;
        &lt;/resource&gt;
    &lt;/resources&gt;
&lt;/build&gt;
</code></pre><div class="tags"><a href="/tags/%E6%A1%86%E6%9E%B6/" rel="tag"><i class="ic i-tag"></i> 框架</a> <a href="/tags/ORM/" rel="tag"><i class="ic i-tag"></i> ORM</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2022-10-07 23:48:11" itemprop="dateModified" datetime="2022-10-07T23:48:11+08:00">2022-10-07</time></span></div><div class="reward"><button><i class="ic i-heartbeat"></i> 赞赏</button><p>请我喝[茶]~(￣▽￣)~*</p><div id="qr"><div><img data-src="/images/wechatpay.png" alt="雾都 微信支付"><p>微信支付</p></div><div><img data-src="/images/alipay.png" alt="雾都 支付宝"><p>支付宝</p></div><div><img data-src="/images/paypal.png" alt="雾都 贝宝"><p>贝宝</p></div></div></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>雾都 <i class="ic i-at"><em>@</em></i>记录 “美食” 每刻</li><li class="link"><strong>本文链接：</strong> <a href="http://example.com/2022/10/07/ORM/Mybatis/" title="Mybatis">http://example.com/2022/10/07/ORM/Mybatis/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/2022/10/07/Spring_Family/Spring/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;tva3.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1gipewf5l51j20zk0m8b29.jpg" title="Spring"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> Spring</span><h3>Spring</h3></a></div><div class="item right"><a href="/2022/10/07/ORM/MybatisPlus/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;tva3.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1gicis081o9j20zk0m8dmr.jpg" title="MybatisPlus"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i> MybatisPlus</span><h3>MybatisPlus</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-Mybatis%E5%85%A5%E9%97%A8"><span class="toc-number">1.</span> <span class="toc-text">1 Mybatis入门</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E8%AE%A4%E8%AF%86%E6%A1%86%E6%9E%B6"><span class="toc-number">1.1.</span> <span class="toc-text">1 认识框架</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E8%AE%A4%E8%AF%86ORM"><span class="toc-number">1.2.</span> <span class="toc-text">2 认识ORM</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E8%AE%A4%E8%AF%86MyBatis"><span class="toc-number">1.3.</span> <span class="toc-text">3 认识MyBatis</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-MyBatis%E5%88%9D%E6%AC%A1%E4%BD%BF%E7%94%A8"><span class="toc-number">2.</span> <span class="toc-text">2 MyBatis初次使用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%88%9B%E5%BB%BAmaven%E9%A1%B9%E7%9B%AE%E5%AF%BC%E5%85%A5%E7%9B%B8%E5%85%B3%E4%BE%9D%E8%B5%96"><span class="toc-number">2.1.</span> <span class="toc-text">1 创建maven项目导入相关依赖</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%87%86%E5%A4%87%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%8C%85%E7%BB%93%E6%9E%84%E5%92%8C%E5%AE%9E%E4%BD%93%E7%B1%BB"><span class="toc-number">2.2.</span> <span class="toc-text">2 准备数据库_包结构和实体类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%87%86%E5%A4%87Mapper%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6%E5%92%8C%E6%A0%B8%E5%BF%83%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-number">2.3.</span> <span class="toc-text">3 准备Mapper映射文件和核心配置文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E8%BF%90%E8%A1%8C%E6%B5%8B%E8%AF%95"><span class="toc-number">2.4.</span> <span class="toc-text">4 运行测试</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-MyBatis%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3"><span class="toc-number">3.</span> <span class="toc-text">3 MyBatis配置详解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-log4j1%E5%92%8Clog4j2%E7%9A%84%E7%AE%80%E5%8D%95%E9%85%8D%E7%BD%AE"><span class="toc-number">3.0.1.</span> <span class="toc-text">1_log4j1和log4j2的简单配置</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%85%B3%E4%BA%8E%E4%BA%8B%E5%8A%A1%E9%85%8D%E7%BD%AE"><span class="toc-number">3.1.</span> <span class="toc-text">2_关于事务配置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%85%B3%E4%BA%8E%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%96%B9%E5%BC%8F"><span class="toc-number">3.2.</span> <span class="toc-text">3_关于映射文件的加载方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%85%B3%E4%BA%8E%E5%AE%9E%E4%BD%93%E7%B1%BB%E5%88%AB%E5%90%8D%E5%A4%84%E7%90%86"><span class="toc-number">3.3.</span> <span class="toc-text">4_关于实体类别名处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E5%85%B3%E4%BA%8E%E5%A4%96%E9%83%A8%E5%B1%9E%E6%80%A7%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E4%BF%A1%E6%81%AF"><span class="toc-number">3.4.</span> <span class="toc-text">5_关于外部属性配置文件存储数据库连接信息</span></a></li></ol><li class="toc-item toc-level-1"><a class="toc-link" href="#4-MyBatis%E4%BC%A0%E7%BB%9FDAO%E6%A8%A1%E5%BC%8F%E5%BC%80%E5%8F%91"><span class="toc-number">4.</span> <span class="toc-text">4 MyBatis传统DAO模式开发</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-sqlSession%E6%9F%A5%E8%AF%A2%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">4.1.</span> <span class="toc-text">1_sqlSession查询的三种方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-sqlSession%E4%BC%A0%E9%80%92%E5%8F%82%E6%95%B0%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">4.2.</span> <span class="toc-text">2_sqlSession传递参数的三种方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-sqlSession%E5%AE%8C%E6%88%90DML%E6%89%80%E6%9C%89%E6%93%8D%E4%BD%9C"><span class="toc-number">4.3.</span> <span class="toc-text">3_sqlSession完成DML所有操作</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-MyBatis%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E5%BC%80%E5%8F%91"><span class="toc-number">5.</span> <span class="toc-text">5 MyBatis代理模式开发</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E4%B8%8B%E5%BC%80%E5%8F%91%E5%90%84%E7%A7%8D%E5%8A%9F%E8%83%BD"><span class="toc-number">6.</span> <span class="toc-text">6 代理模式下开发各种功能</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%A4%9A%E7%A7%8D%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E9%97%AE%E9%A2%98"><span class="toc-number">6.1.</span> <span class="toc-text">1_多种参数传递问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E6%A8%A1%E7%B3%8A%E6%9F%A5%E8%AF%A2%E5%8A%9F%E8%83%BD"><span class="toc-number">6.2.</span> <span class="toc-text">2 模糊查询功能</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E4%B8%BB%E9%94%AE%E8%87%AA%E5%A2%9E%E5%9B%9E%E5%A1%AB"><span class="toc-number">6.3.</span> <span class="toc-text">3_主键自增回填</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%AE%9E%E7%8E%B0DML%E6%93%8D%E4%BD%9C"><span class="toc-number">6.4.</span> <span class="toc-text">4_实现DML操作</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-%E5%8A%A8%E6%80%81SQL"><span class="toc-number">7.</span> <span class="toc-text">7 动态SQL</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-if%E6%A0%87%E7%AD%BE"><span class="toc-number">7.1.</span> <span class="toc-text">1_if标签</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-where%E6%A0%87%E7%AD%BE"><span class="toc-number">7.2.</span> <span class="toc-text">2_where标签</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-choose%E6%A0%87%E7%AD%BE"><span class="toc-number">7.3.</span> <span class="toc-text">3_choose标签</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-set%E6%A0%87%E7%AD%BE"><span class="toc-number">7.4.</span> <span class="toc-text">4_set标签</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-trim%E6%A0%87%E7%AD%BE"><span class="toc-number">7.5.</span> <span class="toc-text">5_trim标签</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-bind%E6%A0%87%E7%AD%BE"><span class="toc-number">7.6.</span> <span class="toc-text">6_bind标签</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-nclude"><span class="toc-number">7.7.</span> <span class="toc-text">7_nclude</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-sql%E6%A0%87%E7%AD%BE"><span class="toc-number">7.8.</span> <span class="toc-text">8_sql标签</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-foreach%E6%A0%87%E7%AD%BE"><span class="toc-number">7.9.</span> <span class="toc-text">9_foreach标签</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8-MyBatis%E5%AE%9E%E7%8E%B0%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2"><span class="toc-number">8.</span> <span class="toc-text">8 MyBatis实现多表查询</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%85%B3%E8%81%94%E6%9F%A5%E8%AF%A2"><span class="toc-number">8.1.</span> <span class="toc-text">1 关联查询</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%89%8B%E5%8A%A8%E5%A4%84%E7%90%86%E6%98%A0%E5%B0%84%E5%85%B3%E7%B3%BB"><span class="toc-number">8.1.1.</span> <span class="toc-text">1 手动处理映射关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%B8%80%E5%AF%B9%E4%B8%80%E5%85%B3%E8%81%94%E6%9F%A5%E8%AF%A2"><span class="toc-number">8.1.2.</span> <span class="toc-text">2 一对一关联查询</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E7%BA%A7%E8%81%94%E6%9F%A5%E8%AF%A2"><span class="toc-number">8.2.</span> <span class="toc-text">2 级联查询</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%AB%8B%E5%8D%B3%E5%8A%A0%E8%BD%BD"><span class="toc-number">8.2.1.</span> <span class="toc-text">1 立即加载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD"><span class="toc-number">8.2.2.</span> <span class="toc-text">2 延迟加载</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%80%BB%E7%BB%93"><span class="toc-number">8.3.</span> <span class="toc-text">3 总结</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#resultMap%E4%B8%AD%E7%9A%84%E5%B8%B8%E8%A7%81%E5%B1%9E%E6%80%A7"><span class="toc-number">8.3.0.1.</span> <span class="toc-text">resultMap中的常见属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%A7%E8%81%94%E6%9F%A5%E8%AF%A2%E5%92%8C%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2%E7%9A%84%E6%AF%94%E8%BE%83%E5%8F%8A%E5%85%B6%E9%80%89%E6%8B%A9"><span class="toc-number">8.3.0.2.</span> <span class="toc-text">级联查询和多表查询的比较及其选择</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9-MyBatis%E6%B3%A8%E8%A7%A3%E5%BC%80%E5%8F%91"><span class="toc-number">9.</span> <span class="toc-text">9 MyBatis注解开发</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#10-%E7%BC%93%E5%AD%98"><span class="toc-number">10.</span> <span class="toc-text">10 缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E4%B8%80%E7%BA%A7%E7%BC%93%E5%AD%98"><span class="toc-number">10.1.</span> <span class="toc-text">1 一级缓存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98"><span class="toc-number">10.2.</span> <span class="toc-text">2 二级缓存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E4%B8%89%E6%96%B9%E7%BC%93%E5%AD%98"><span class="toc-number">10.3.</span> <span class="toc-text">3 三方缓存</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#11-%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B"><span class="toc-number">11.</span> <span class="toc-text">11 逆向工程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#12-main%E7%9B%AE%E5%BD%95%E4%B8%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E6%89%93%E5%8C%85%E9%97%AE%E9%A2%98"><span class="toc-number">12.</span> <span class="toc-text">12 main目录下配置文件打包问题</span></a></li></div><div class="related panel pjax" data-title="系列文章"><ul><li class="active"><a href="/2022/10/07/ORM/Mybatis/" rel="bookmark" title="Mybatis">Mybatis</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="雾都" data-src="/images/avatar.jpg"><p class="name" itemprop="name">雾都</p><div class="description" itemprop="description">记录 “美食” 每刻</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">56</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">38</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">20</span> <span class="name">标签</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL29ubHltYXJyeXU=" title="https:&#x2F;&#x2F;github.com&#x2F;onlymarryu"><i class="ic i-github"></i></span> <span class="exturl item CSDN" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JraG9sZT9zcG09MTAwMC4yMTE1LjMwMDEuNTM0Mw==" title="https:&#x2F;&#x2F;blog.csdn.net&#x2F;Bkhole?spm&#x3D;1000.2115.3001.5343"><i class="ic i-CSDN"></i></span> <span class="exturl item fengye" data-url="aHR0cHM6Ly9jbG91ZC5meW5vdGUuY29tL2VkaXQ/bmlkPTExMzc5NiZpZD0xNTY3NTI4MDE2MzQ1NTYzMTM2JnQ9MTY2NTgxNjM0NTU4Nw==" title="https:&#x2F;&#x2F;cloud.fynote.com&#x2F;edit?nid&#x3D;113796&amp;id&#x3D;1567528016345563136&amp;t&#x3D;1665816345587"><i class="ic i-fengye"></i></span> <span class="exturl item yuque" data-url="aHR0cHM6Ly93d3cueXVxdWUuY29tL2Rhc2hib2FyZC9yZWNlbnQ=" title="https:&#x2F;&#x2F;www.yuque.com&#x2F;dashboard&#x2F;recent"><i class="ic i-yuque"></i></span> <span class="exturl item music" data-url="aHR0cHM6Ly9tdXNpYy4xNjMuY29tLyMvbXkvbS9tdXNpYy9wbGF5bGlzdD9pZD0zMTY2MDYwNzkw" title="https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;my&#x2F;m&#x2F;music&#x2F;playlist?id&#x3D;3166060790"><i class="ic i-cloud-music"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li><li class="item"><a href="/friends/" rel="section"><i class="ic i-heart"></i>friends</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/2022/10/07/Spring_Family/Spring/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/2022/10/07/ORM/MybatisPlus/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/%E5%B7%A5%E5%85%B7%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/" title="分类于 工具软件安装">工具软件安装</a></div><span><a href="/2022/10/15/tools/Nacos-tool/" title="Nacos">Nacos</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/JavaSE/" title="分类于 JavaSE">JavaSE</a> <i class="ic i-angle-right"></i> <a href="/categories/JavaSE/%E5%8F%8D%E5%B0%84/" title="分类于 反射">反射</a></div><span><a href="/2022/10/07/Java/%E7%AC%AC16%E7%AB%A0_%E5%8F%8D%E5%B0%84/" title="第16章_反射">第16章_反射</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/" title="分类于 分布式">分布式</a> <i class="ic i-angle-right"></i> <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/FastDFS/" title="分类于 FastDFS">FastDFS</a></div><span><a href="/2022/10/07/Distribution/FastDFS/" title="FastDFS">FastDFS</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" title="分类于 数据库">数据库</a> <i class="ic i-angle-right"></i> <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/" title="分类于 Redis">Redis</a></div><span><a href="/2022/10/07/DataBase/Redis/Redis/" title="Redis基础">Redis基础</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E5%B7%A5%E5%85%B7%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/" title="分类于 工具软件安装">工具软件安装</a></div><span><a href="/2022/10/15/tools/RabbitMQ-tool/" title="RabbitMQ">RabbitMQ</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Spring/" title="分类于 Spring">Spring</a> <i class="ic i-angle-right"></i> <a href="/categories/Spring/SpringMVC/" title="分类于 SpringMVC">SpringMVC</a></div><span><a href="/2022/10/07/Spring_Family/SpringMVC/" title="SpringMVC">SpringMVC</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/MybatisPlus/" title="分类于 MybatisPlus">MybatisPlus</a></div><span><a href="/2022/10/07/ORM/MybatisPlus/" title="MybatisPlus">MybatisPlus</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E5%B7%A5%E5%85%B7%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/" title="分类于 工具软件安装">工具软件安装</a></div><span><a href="/2022/10/15/tools/Maven-tool/" title="Maven-tool">Maven-tool</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E5%B7%A5%E5%85%B7%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/" title="分类于 工具软件安装">工具软件安装</a></div><span><a href="/2022/10/15/tools/Erlang-tool/" title="Erlang">Erlang</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/JavaSE/" title="分类于 JavaSE">JavaSE</a> <i class="ic i-angle-right"></i> <a href="/categories/JavaSE/JAVA%E7%AE%80%E4%BB%8B/" title="分类于 JAVA 简介">JAVA 简介</a></div><span><a href="/2022/10/07/Java/%E7%AC%AC1%E7%AB%A0%E5%88%9D%E8%AF%86JAVA/" title="第1章初识JAVA">第1章初识JAVA</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2010 – <span itemprop="copyrightYear">2022</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">雾都 @ 雾都博客</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="站点总字数">774k 字</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="站点阅读时长">11:44</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"2022/10/07/ORM/Mybatis/",favicon:{show:"（●´3｀●）やれやれだぜ",hide:"(´Д｀)大変だ！"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,audio:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html><!-- rebuild by hrmmi -->