<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Dubbo</title>
    <url>/2022/10/07/Distribution/Dubbo/</url>
    <content><![CDATA[<h1 id="Dubbo"><a href="#Dubbo" class="headerlink" title="Dubbo"></a>Dubbo</h1><h3 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h3><ol>
<li>Dubbo简介</li>
<li>Dubbo架构讲解</li>
<li>Dubbo支持的协议</li>
<li>Dubbo支持的注册中心</li>
<li>第一个Dubbo的Provider</li>
<li>Admin管理界面搭建</li>
<li>成Dubbo的Consumer</li>
<li>负载均衡</li>
<li>完整Dubbo项目演示</li>
</ol>
<h3 id="学习目标"><a href="#学习目标" class="headerlink" title="学习目标"></a>学习目标</h3><table>
<thead>
<tr>
<th>知识点</th>
<th>要求</th>
</tr>
</thead>
<tbody><tr>
<td>Dubbo简介</td>
<td>掌握</td>
</tr>
<tr>
<td>Dubbo架构讲解</td>
<td>精通</td>
</tr>
<tr>
<td>Dubbo支持的协议</td>
<td>掌握</td>
</tr>
<tr>
<td>Dubbo支持的注册中心</td>
<td>掌握</td>
</tr>
<tr>
<td>第一个Dubbo的Provider</td>
<td>掌握</td>
</tr>
<tr>
<td>Admin管理界面搭建</td>
<td>掌握</td>
</tr>
<tr>
<td>完成Dubbo的Consumer</td>
<td>掌握</td>
</tr>
<tr>
<td>负载均衡</td>
<td>掌握</td>
</tr>
<tr>
<td>完整Dubbo项目演示</td>
<td>掌握</td>
</tr>
</tbody></table>
<h3 id="一、Dubbo简介"><a href="#一、Dubbo简介" class="headerlink" title="一、Dubbo简介"></a>一、Dubbo简介</h3><h4 id="1-官方说明"><a href="#1-官方说明" class="headerlink" title="1,官方说明"></a>1,官方说明</h4><img data-src="/2022/10/07/Distribution/Dubbo/Dubbo-1.png" class="">


<p>​	Apache Dubbo 是一个高可用的，基于Java的开源RPC框架。</p>
<p>​	Dubbo框架不仅仅是具备RPC访问功能，还包含服务治理功能。</p>
<h4 id="2-发展历史"><a href="#2-发展历史" class="headerlink" title="2.发展历史"></a>2.发展历史</h4><p>​	Dubbo是最开始是阿里巴巴内部使用的RPC框架。</p>
<p>​	2011年对外提供。</p>
<p>​	2012年停止更新。</p>
<p>​	2017年开始继续更新。</p>
<p>​	2019年捐献给Apache，由Apache维护2.7以上版本。</p>
<h4 id="3-Dubbo架构讲解"><a href="#3-Dubbo架构讲解" class="headerlink" title="3.Dubbo架构讲解"></a>3.Dubbo架构讲解</h4><h5 id="3-1架构图"><a href="#3-1架构图" class="headerlink" title="3.1架构图"></a>3.1架构图</h5><img data-src="/2022/10/07/Distribution/Dubbo/Dubbo-2.png" class="">


<h4 id="3-2架构说明"><a href="#3-2架构说明" class="headerlink" title="3.2架构说明"></a>3.2架构说明</h4><h5 id="3-2-1虚线"><a href="#3-2-1虚线" class="headerlink" title="3.2.1虚线"></a>3.2.1虚线</h5><p>​	虚线表示异步，实线表示同步。异步不阻塞线程性能高，同步阻塞线程必须等待响应结果才能继续执行，相对性能低。</p>
<h5 id="3-2-2Provider"><a href="#3-2-2Provider" class="headerlink" title="3.2.2Provider"></a>3.2.2Provider</h5><p>​	提供者。编写持久层和事务代码。</p>
<h5 id="3-2-3Container"><a href="#3-2-3Container" class="headerlink" title="3.2.3Container"></a>3.2.3Container</h5><p>​	容器（Spring容器），Dubbo完全基于Spring实现的。</p>
<h5 id="3-2-4Registry"><a href="#3-2-4Registry" class="headerlink" title="3.2.4Registry"></a>3.2.4Registry</h5><p>​	注册中心。放置所有Provider对外提供的信息。包含Provider的IP，访问端口，访问遵守的协议，对外提供的接口，接口中有哪些方法等相关信息。</p>
<h5 id="3-2-5Consumer"><a href="#3-2-5Consumer" class="headerlink" title="3.2.5Consumer"></a>3.2.5Consumer</h5><p>​	消费者（RPC调用者，SOA调用服务的项目）开发中也是一个项目，编写service和controller（还可以报页面等）。调用XXXXServiceImpl中的方法。</p>
<h5 id="3-2-6Monitor"><a href="#3-2-6Monitor" class="headerlink" title="3.2.6Monitor"></a>3.2.6Monitor</h5><p>​	监控中心。监控Provider的压力情况等。每隔2分钟Consumer和Provider会把调用次数发送给Monitor，由Monitor进行统计。</p>
<h4 id="4-执行流程"><a href="#4-执行流程" class="headerlink" title="4.执行流程"></a>4.执行流程</h4><ol start="0">
<li>start：启动Spring容器时会把Provider启动。 </li>
<li>register：把Provider相关信息注册到Registry里</li>
<li>subscribe：Consumer从Registry中订阅Provider的信息</li>
<li>notify：通知给Consumer</li>
<li>invoke：Consumer根据Registry通知的信息进行调用Provider中方法。</li>
<li>count:Consumer和Provider把调用次数信息异步发送给Monitor进行统计。</li>
</ol>
<h3 id="二、Dubbo支持的协议"><a href="#二、Dubbo支持的协议" class="headerlink" title="二、Dubbo支持的协议"></a>二、Dubbo支持的协议</h3><h4 id="1-Dubbo协议-官方推荐协议"><a href="#1-Dubbo协议-官方推荐协议" class="headerlink" title="1.Dubbo协议(官方推荐协议)"></a>1.Dubbo协议(官方推荐协议)</h4><p>​	优点：</p>
<p>​		采用NIO复用单一长连接，并使用线程池并发处理请求，减少握手和加大并发效率，性能较好（推荐使用）</p>
<p>​	缺点：</p>
<p>​		大文件上传时,可能出现问题(不使用Dubbo文件上传)</p>
<h4 id="2-RMI-Remote-Method-Invocation-协议"><a href="#2-RMI-Remote-Method-Invocation-协议" class="headerlink" title="2.RMI(Remote Method Invocation)协议"></a>2.RMI(Remote Method Invocation)协议</h4><p>​	优点:</p>
<p>​		JDK自带的能力。</p>
<p>​	缺点:</p>
<p>​		偶尔连接失败.</p>
<h4 id="3-Hessian协议"><a href="#3-Hessian协议" class="headerlink" title="3.Hessian协议"></a>3.Hessian协议</h4><p>​	优点:</p>
<p>​		可与原生Hessian互操作，基于HTTP协议</p>
<p>​	缺点:</p>
<p>​		需hessian.jar支持，http短连接的开销大</p>
<h3 id="三、Dubbo支持的注册中心"><a href="#三、Dubbo支持的注册中心" class="headerlink" title="三、Dubbo支持的注册中心"></a>三、Dubbo支持的注册中心</h3><h4 id="1-Zookeeper-官方推荐"><a href="#1-Zookeeper-官方推荐" class="headerlink" title="1.Zookeeper(官方推荐)"></a>1.Zookeeper(官方推荐)</h4><p>​	1) 优点:</p>
<p>​		支持分布式.很多周边产品.</p>
<p>​	2) 缺点: </p>
<p>​		受限于Zookeeper软件的稳定性.Zookeeper专门分布式辅助软件,稳定较优</p>
<h4 id="2-Multicast"><a href="#2-Multicast" class="headerlink" title="2.Multicast"></a>2.Multicast</h4><p>​	1) 优点:</p>
<p>​		去中心化,不需要单独安装软件.</p>
<p>​	2) 缺点:</p>
<p>​		2.2.1 Provider和Consumer和Registry不能跨机房(路由)</p>
<h4 id="3-Redis"><a href="#3-Redis" class="headerlink" title="3.Redis"></a>3.Redis</h4><p>​	1) 优点:</p>
<p>​		支持集群,性能高</p>
<p>​	2) 缺点:</p>
<p>​		要求服务器时间同步.否则可能出现集群失败问题.</p>
<h4 id="4-Simple"><a href="#4-Simple" class="headerlink" title="4.Simple"></a>4.Simple</h4><p>​	1) 优点: </p>
<p>​		标准RPC服务.没有兼容问题</p>
<p>​	2) 缺点: </p>
<p>​		不支持集群.</p>
<h3 id="四、第一个Dubbo的Provider"><a href="#四、第一个Dubbo的Provider" class="headerlink" title="四、第一个Dubbo的Provider"></a>四、第一个Dubbo的Provider</h3><p>​	新建父项目Parent1。最终结构如下：</p>
<img data-src="/2022/10/07/Distribution/Dubbo/Dubbo-3.png" class="">


<p>​	编写pom.xml继承SpringBoot父项目。</p>
<pre><code>&lt;parent&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
    &lt;version&gt;2.1.10.RELEASE&lt;/version&gt;
&lt;/parent&gt; 
</code></pre>
<h4 id="1-新建api项目"><a href="#1-新建api项目" class="headerlink" title="1.新建api项目"></a>1.新建api项目</h4><h5 id="1-1创建接口"><a href="#1-1创建接口" class="headerlink" title="1.1创建接口"></a>1.1创建接口</h5><p>​	创建com.msb.<strong>dubbo</strong>.service.Demo<strong>Dubbo</strong>Service接口</p>
<pre><code>public interface DemoDubboService &#123;
    String demo();
&#125;
</code></pre>
<h4 id="2-新建provider项目"><a href="#2-新建provider项目" class="headerlink" title="2.新建provider项目"></a>2.新建provider项目</h4><h5 id="2-1编写pom-xml"><a href="#2-1编写pom-xml" class="headerlink" title="2.1编写pom.xml"></a>2.1编写pom.xml</h5><p>​	注意：不需要依赖web，如果依赖spring-boot-start-web还需要考虑端口问题。</p>
<pre><code>&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;artifactId&gt;api&lt;/artifactId&gt;
        &lt;groupId&gt;com.msb&lt;/groupId&gt;
        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;
        &lt;version&gt;2.1.10.RELEASE&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt;
        &lt;artifactId&gt;dubbo-spring-boot-starter&lt;/artifactId&gt;
        &lt;version&gt;2.7.3&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.apache.curator&lt;/groupId&gt;
        &lt;artifactId&gt;curator-recipes&lt;/artifactId&gt;
        &lt;version&gt;4.2.0&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.apache.curator&lt;/groupId&gt;
        &lt;artifactId&gt;curator-framework&lt;/artifactId&gt;
        &lt;version&gt;4.2.0&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;   
</code></pre>
<h5 id="2-2编写配置文件"><a href="#2-2编写配置文件" class="headerlink" title="2.2编写配置文件"></a>2.2编写配置文件</h5><p>​	新建application.yml</p>
<pre><code>dubbo:
  application:
    name: dubbo-provider
  registry:
    address: zookeeper://192.168.32.128:2181
</code></pre>
<h5 id="2-3新建实现类"><a href="#2-3新建实现类" class="headerlink" title="2.3新建实现类"></a>2.3新建实现类</h5><p>​	新建com.msb.dubbo.service.impl.DemoDubboServiceImpl</p>
<p>​	注意：注解是apache的注解。</p>
<pre><code>import com.msb.dubbo.service.DemoDubboService;
import org.apache.dubbo.config.annotation.Service;

@Service
public class DemoDubboServiceImpl implements DemoDubboService &#123;
    @Override
    public String demo() &#123;
        System.out.println(&quot;demo方法&quot;);
        return &quot;123&quot;;
    &#125;
&#125;
</code></pre>
<h5 id="2-4新建启动类"><a href="#2-4新建启动类" class="headerlink" title="2.4新建启动类"></a>2.4新建启动类</h5><p>​	新建com.msb.ProviderApplication。</p>
<p>​	必须要有@EnableDubbo注解，否则Dubbo不生效。</p>
<pre><code>@SpringBootApplication
@EnableDubbo
public class ProviderApplication &#123;
    public static void main(String[] args) &#123;
        SpringApplication.run(ProviderApplication.class,args);
    &#125;
&#125;
</code></pre>
<h3 id="五、完成Dubbo的Consumer"><a href="#五、完成Dubbo的Consumer" class="headerlink" title="五、完成Dubbo的Consumer"></a>五、完成Dubbo的Consumer</h3><p>​	创建consumer项目</p>
<h4 id="1-编写pom-xml"><a href="#1-编写pom-xml" class="headerlink" title="1.编写pom.xml"></a>1.编写pom.xml</h4><pre><code>&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;artifactId&gt;api&lt;/artifactId&gt;
        &lt;groupId&gt;com.msb&lt;/groupId&gt;
        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;version&gt;2.1.10.RELEASE&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt;
        &lt;artifactId&gt;dubbo-spring-boot-starter&lt;/artifactId&gt;
        &lt;version&gt;2.7.3&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.apache.curator&lt;/groupId&gt;
        &lt;artifactId&gt;curator-recipes&lt;/artifactId&gt;
        &lt;version&gt;4.2.0&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.apache.curator&lt;/groupId&gt;
        &lt;artifactId&gt;curator-framework&lt;/artifactId&gt;
        &lt;version&gt;4.2.0&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;   
</code></pre>
<h4 id="2-新建配置文件"><a href="#2-新建配置文件" class="headerlink" title="2.新建配置文件"></a>2.新建配置文件</h4><p>​	新建application.yml</p>
<pre><code>dubbo:
  application:
    name: dubbo-consumer
  registry:
    address: zookeeper://192.168.32.128:2181
</code></pre>
<h4 id="3-新建service及实现类"><a href="#3-新建service及实现类" class="headerlink" title="3.新建service及实现类"></a>3.新建service及实现类</h4><p>​	新建com.msb.service.DemoService</p>
<p>​	新建com.msb.service.impl.DemoServiceImpl</p>
<p>​	调用服务使用@Reference注解，不要倒错包了，有两个。</p>
<pre><code>public interface DemoService &#123;
    String consumerDemo();
&#125;
</code></pre>
<pre><code>import com.msb.dubbo.service.DemoDubboService;
import com.msb.service.DemoService;
import org.apache.dubbo.config.annotation.Reference;
import org.springframework.stereotype.Service;

@Service
public class DemoServiceImpl implements DemoService &#123;

    @Reference
    private DemoDubboService demoDubboService;

    @Override
    public String consumerDemo() &#123;
        return demoDubboService.demo();
    &#125;
&#125;
</code></pre>
<h4 id="4-新建控制器"><a href="#4-新建控制器" class="headerlink" title="4.新建控制器"></a>4.新建控制器</h4><p>​	新建控制器com.msb.controller.DemoController</p>
<pre><code>@Controller
public class DemoController &#123;
    @Autowired
    private DemoService demoService;

    @RequestMapping(&quot;/demo&quot;)
    @ResponseBody
    public String demo()&#123;
        return demoService.consumerDemo();
    &#125;
&#125;
</code></pre>
<h4 id="5-新建启动器"><a href="#5-新建启动器" class="headerlink" title="5.新建启动器"></a>5.新建启动器</h4><p>​	新建com.msb.ConsumerApplication</p>
<pre><code>@SpringBootApplication
@EnableDubbo
public class ConsumerApplication &#123;
    public static void main(String[] args) &#123;
        SpringApplication.run(ConsumerApplication.class,args);
    &#125;
&#125;
</code></pre>
<h3 id="六、Admin管理界面搭建"><a href="#六、Admin管理界面搭建" class="headerlink" title="六、Admin管理界面搭建"></a>六、Admin管理界面搭建</h3><p>​	资料中把dubbo-admin-0.2.0.jar\BOOT-INF\classes 中application.properties里面注册中心的ip设置正确</p>
<p>​	使用java -jar dubbo-admin-0.2.0.jar运行即可。</p>
<p>​	注意：占用8080端口，不要冲突了。</p>
<h3 id="七、负载均衡"><a href="#七、负载均衡" class="headerlink" title="七、负载均衡"></a>七、负载均衡</h3><p>​	集群：一个内容，部署多次，形成的整体称为集群。集群中每个个体应该部署到不同的服务器上。</p>
<p>​	伪集群：集群中内容部署到同一台服务器上，通过不同端口区分不同个体。</p>
<p>​	负载均衡是在集群前提下，当访问整个集群时，集群中每个节点被访问次数或频率的规则。</p>
<p>​	Dubbo 内置了四个负载均衡策略。默认为Random</p>
<h4 id="1-内置策略"><a href="#1-内置策略" class="headerlink" title="1.内置策略"></a>1.内置策略</h4><h5 id="1-1Random"><a href="#1-1Random" class="headerlink" title="1.1Random"></a>1.1Random</h5><p>​	随机。随机访问集群中节点。访问概率和权重有关。</p>
<h5 id="1-2RoundRobin"><a href="#1-2RoundRobin" class="headerlink" title="1.2RoundRobin"></a>1.2RoundRobin</h5><p>​	轮询。访问频率和权重有关。</p>
<p>​	权重（weight）：占有比例。集群中每个项目部署的服务器的性能可能是不同，性能好的服务器权重应该高一些。</p>
<h5 id="1-3LeastActive"><a href="#1-3LeastActive" class="headerlink" title="1.3LeastActive"></a>1.3LeastActive</h5><p>​	活跃数相同的随机，不同的活跃数高的放前面。</p>
<h5 id="1-4ConsistentHash"><a href="#1-4ConsistentHash" class="headerlink" title="1.4ConsistentHash"></a>1.4ConsistentHash</h5><p>​	一致性Hash。相同参数请求总是发到一个提供者。</p>
<h4 id="2-Provider集群"><a href="#2-Provider集群" class="headerlink" title="2.Provider集群"></a>2.Provider集群</h4><p>​	新建四个启动类。</p>
<p>​	每次启动启动类修改配置文件dubbo.protocal.port</p>
<h4 id="3-设置负载均衡"><a href="#3-设置负载均衡" class="headerlink" title="3.设置负载均衡"></a>3.设置负载均衡</h4><h5 id="3-1-Reference"><a href="#3-1-Reference" class="headerlink" title="3.1@Reference"></a>3.1@Reference</h5><p>​	调用的服务采用的负载均衡</p>
<pre><code>@Reference(loadbalance = &quot;roundrobin&quot;)
private DemoDubboService demoDubboService;
</code></pre>
<h5 id="3-2-Service"><a href="#3-2-Service" class="headerlink" title="3.2 @Service"></a>3.2 @Service</h5><p>​	当前服务采用的负载均衡算法</p>
<pre><code>@Service(loadbalance = &quot;random&quot;)
public class DemoDubboServiceImpl implements DemoDubboService &#123;
</code></pre>
<p>​	设置权重</p>
<pre><code>@Service(weight = 4)
</code></pre>
<h5 id="3-3配置文件"><a href="#3-3配置文件" class="headerlink" title="3.3配置文件"></a>3.3配置文件</h5><p>​			全局设置所有provider和consumer的负载均衡效果。</p>
<pre><code>dubbo:
  application:
    name: dubbo-provider
  registry:
    address: zookeeper://192.168.32.128:2181
  protocol:
    port: 20884
  provider:
    loadbalance: random
  consumer:
    loadbalance: random
</code></pre>
<h3 id="八、完整Dubbo项目演示"><a href="#八、完整Dubbo项目演示" class="headerlink" title="八、完整Dubbo项目演示"></a>八、完整Dubbo项目演示</h3><h4 id="1-原型"><a href="#1-原型" class="headerlink" title="1.原型"></a>1.原型</h4><h5 id="1-1部门显示"><a href="#1-1部门显示" class="headerlink" title="1.1部门显示"></a>1.1部门显示</h5><p>​	显示全部部门信息</p>
<img data-src="/2022/10/07/Distribution/Dubbo/Dubbo-4.png" class="">




<h5 id="1-2员工新增"><a href="#1-2员工新增" class="headerlink" title="1.2员工新增"></a>1.2员工新增</h5><img data-src="/2022/10/07/Distribution/Dubbo/Dubbo-5.png" class="">


<h5 id="1-3查看部门员工"><a href="#1-3查看部门员工" class="headerlink" title="1.3查看部门员工"></a>1.3查看部门员工</h5><img data-src="/2022/10/07/Distribution/Dubbo/Dubbo-6.png" class="">


<h4 id="2-按照分布式架构进行设计项目"><a href="#2-按照分布式架构进行设计项目" class="headerlink" title="2.按照分布式架构进行设计项目"></a>2.按照分布式架构进行设计项目</h4><p>​		设定员工管理和部门管理不在同一个模块中，需要有一个员工管理项目和一个部门管理项目。</p>
<p>​	为了方便，不去每个项目使用一个窗口，而是使用聚合项目。      </p>
<img data-src="/2022/10/07/Distribution/Dubbo/Dubbo-7.png" class="">








<h4 id="3-创建数据库表"><a href="#3-创建数据库表" class="headerlink" title="3.创建数据库表"></a>3.创建数据库表</h4><pre><code>create table dept(
id int(11) primary key auto_increment,
name varchar(20)
);

insert into dept values(default,&#39;开发部&#39;);
insert into dept values(default,&#39;产品部&#39;);

create table emp(
id int(11) primary key auto_increment,
name varchar(20),
photo varchar(200),
did int(11),
CONSTRAINT fk_emp_dept FOREIGN key (did) REFERENCES dept(id)
);
</code></pre>
<h4 id="4-创建父项目"><a href="#4-创建父项目" class="headerlink" title="4.创建父项目"></a>4.创建父项目</h4><p>​	创建项目parent。</p>
<img data-src="/2022/10/07/Distribution/Dubbo/Dubbo-8.png" class="">




<p>编写pom.xml</p>
<pre><code>&lt;parent&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
    &lt;version&gt;2.1.10.RELEASE&lt;/version&gt;
&lt;/parent&gt;
&lt;dependencyManagement&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;
            &lt;version&gt;2.1.10.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
            &lt;version&gt;2.1.10.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;
            &lt;version&gt;2.1.10.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt;
            &lt;artifactId&gt;dubbo-spring-boot-starter&lt;/artifactId&gt;
            &lt;version&gt;2.7.3&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.apache.curator&lt;/groupId&gt;
            &lt;artifactId&gt;curator-recipes&lt;/artifactId&gt;
            &lt;version&gt;4.2.0&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.apache.curator&lt;/groupId&gt;
            &lt;artifactId&gt;curator-framework&lt;/artifactId&gt;
            &lt;version&gt;4.2.0&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;
            &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;
            &lt;version&gt;2.1.1&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;mysql&lt;/groupId&gt;
            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
            &lt;version&gt;5.1.6&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;commons-io&lt;/groupId&gt;
            &lt;artifactId&gt;commons-io&lt;/artifactId&gt;
            &lt;version&gt;2.6&lt;/version&gt;
        &lt;/dependency&gt;
         &lt;dependency&gt;
             &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
             &lt;artifactId&gt;lombok&lt;/artifactId&gt;
             &lt;version&gt;1.18.12&lt;/version&gt;
             &lt;scope&gt;provided&lt;/scope&gt;
         &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/dependencyManagement&gt;
</code></pre>
<h4 id="5-创建pojo项目"><a href="#5-创建pojo项目" class="headerlink" title="5.创建pojo项目"></a>5.创建pojo项目</h4><h4 id="6-创建mapper项目"><a href="#6-创建mapper项目" class="headerlink" title="6.创建mapper项目"></a>6.创建mapper项目</h4><h5 id="6-1编写pom-xml"><a href="#6-1编写pom-xml" class="headerlink" title="6.1编写pom.xml"></a>6.1编写pom.xml</h5><pre><code>&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;artifactId&gt;pojo&lt;/artifactId&gt;
        &lt;groupId&gt;com.msb&lt;/groupId&gt;
        &lt;version&gt;1.0.0&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;
        &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;mysql&lt;/groupId&gt;
        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;    
</code></pre>
<h5 id="6-2新建配置文件"><a href="#6-2新建配置文件" class="headerlink" title="6.2新建配置文件"></a>6.2新建配置文件</h5><p>​	新建application-mybatis.yml</p>
<pre><code>spring:
  datasource:
    driver-class-name: com.mysql.jdbc.Driver
    url: jdbc:mysql://localhost:3306/maven
    username: root
    password: root

mybatis:
  mapper-locations: classpath:mybatis/*.xml
  type-aliases-package: com.msb.pojo
</code></pre>
<h4 id="7-新建api项目"><a href="#7-新建api项目" class="headerlink" title="7.新建api项目"></a>7.新建api项目</h4><h5 id="7-1编写pom-xml"><a href="#7-1编写pom-xml" class="headerlink" title="7.1编写pom.xml"></a>7.1编写pom.xml</h5><pre><code>&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;artifactId&gt;pojo&lt;/artifactId&gt;
        &lt;groupId&gt;com.bjsxt&lt;/groupId&gt;
        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;    
</code></pre>
<h4 id="8-新建provider"><a href="#8-新建provider" class="headerlink" title="8.新建provider"></a>8.新建provider</h4><h5 id="8-1编写pom-xml"><a href="#8-1编写pom-xml" class="headerlink" title="8.1编写pom.xml"></a>8.1编写pom.xml</h5><pre><code>&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;artifactId&gt;mapper&lt;/artifactId&gt;
        &lt;groupId&gt;com.msb&lt;/groupId&gt;
        &lt;version&gt;1.0.0&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;artifactId&gt;api&lt;/artifactId&gt;
        &lt;groupId&gt;com.msb&lt;/groupId&gt;
        &lt;version&gt;1.0.0&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt;
        &lt;artifactId&gt;dubbo-spring-boot-starter&lt;/artifactId&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.apache.curator&lt;/groupId&gt;
        &lt;artifactId&gt;curator-recipes&lt;/artifactId&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.apache.curator&lt;/groupId&gt;
        &lt;artifactId&gt;curator-framework&lt;/artifactId&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
<h5 id="8-2新建配置文件"><a href="#8-2新建配置文件" class="headerlink" title="8.2新建配置文件"></a>8.2新建配置文件</h5><p>​	新建application.yml</p>
<pre><code>dubbo:
  application:
    name: dubbo-provider
  registry:
    address: zookeeper://192.168.52.128:2181

# 加载其他配置文件,加载其他application-*.yml文件，多个名称之间使用逗号分隔
spring:
  profiles:
    active: mybatis
</code></pre>
<h5 id="8-3新建启动类"><a href="#8-3新建启动类" class="headerlink" title="8.3新建启动类"></a>8.3新建启动类</h5><p>​	新建com.msb.ProviderApplication</p>
<pre><code>@SpringBootApplication
@EnableDubbo
@MapperScan(&quot;com.msb.mapper&quot;)
public class ProviderApplication &#123;
    public static void main(String[] args) &#123;
        SpringApplication.run(ProviderApplication.class,args);
    &#125;
&#125;
</code></pre>
<h4 id="9-完成Dept查询功能"><a href="#9-完成Dept查询功能" class="headerlink" title="9.完成Dept查询功能"></a>9.完成Dept查询功能</h4><h5 id="9-1在api中新建接口"><a href="#9-1在api中新建接口" class="headerlink" title="9.1在api中新建接口"></a>9.1在api中新建接口</h5><p>​	com.msb.dubbo.service.DeptDubboService</p>
<pre><code>public interface DeptDubboService &#123;
    List&lt;Dept&gt; selectAll();
&#125;
</code></pre>
<h5 id="9-2在provider中新建实现类"><a href="#9-2在provider中新建实现类" class="headerlink" title="9.2在provider中新建实现类"></a>9.2在provider中新建实现类</h5><p>​	com.msb.dubbo.service.impl.DeptDubboServiceImpl</p>
<pre><code>@Service
public class DeptDubboServiceImpl implements DeptDubboService &#123;
    @Autowired
    private DeptMapper deptMapper;
    @Override
    public List&lt;Dept&gt; selectAll() &#123;
        return deptMapper.selectByExample(null);
    &#125;
&#125;
</code></pre>
<h5 id="9-3新建项目dept"><a href="#9-3新建项目dept" class="headerlink" title="9.3新建项目dept"></a>9.3新建项目dept</h5><h6 id="9-3-1添加依赖"><a href="#9-3-1添加依赖" class="headerlink" title="9.3.1添加依赖"></a>9.3.1添加依赖</h6><pre><code>&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;artifactId&gt;api&lt;/artifactId&gt;
        &lt;groupId&gt;com.msb&lt;/groupId&gt;
        &lt;version&gt;1.0.0&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt;
        &lt;artifactId&gt;dubbo-spring-boot-starter&lt;/artifactId&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.apache.curator&lt;/groupId&gt;
        &lt;artifactId&gt;curator-recipes&lt;/artifactId&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.apache.curator&lt;/groupId&gt;
        &lt;artifactId&gt;curator-framework&lt;/artifactId&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;   
</code></pre>
<h6 id="9-3-2编写配置文件"><a href="#9-3-2编写配置文件" class="headerlink" title="9.3.2编写配置文件"></a>9.3.2编写配置文件</h6><p>​	新建application.yml</p>
<pre><code>dubbo:
  application:
    name: dubbo-dept-consumer
  registry:
    address: zookeeper://192.168.52.128:2181
</code></pre>
<h6 id="9-3-3新建启动类"><a href="#9-3-3新建启动类" class="headerlink" title="9.3.3新建启动类"></a>9.3.3新建启动类</h6><p>​	com.msb.DeptApplication</p>
<pre><code>@SpringBootApplication
@EnableDubbo
public class DeptApplication &#123;
    public static void main(String[] args) &#123;
        SpringApplication.run(DeptApplication.class,args);
    &#125;
&#125;
</code></pre>
<h6 id="9-3-4新建接口及实现类"><a href="#9-3-4新建接口及实现类" class="headerlink" title="9.3.4新建接口及实现类"></a>9.3.4新建接口及实现类</h6><p>​	接口：com.msb.service.DeptService</p>
<p>​	实现类：com.msb.service.impl.DeptServiceImpl</p>
<pre><code>public interface DeptService &#123;
    List&lt;Dept&gt; showAll();
&#125;
</code></pre>
<pre><code>@Service
public class DeptServiceImpl implements DeptService &#123;
    @Reference
    private DeptDubboService deptDubboService;
    @Override
    public List&lt;Dept&gt; showAll() &#123;
        return deptDubboService.selectAll();
    &#125;
&#125;
</code></pre>
<h6 id="9-3-5新建控制器"><a href="#9-3-5新建控制器" class="headerlink" title="9.3.5新建控制器"></a>9.3.5新建控制器</h6><p>​	com.msb.controller.DeptController</p>
<pre><code>@Controller
public class DeptController &#123;

    @Autowired
    private DeptService deptService;

    @GetMapping(&quot;/dept&quot;)
    public String shwoDept(Model model)&#123;
        model.addAttribute(&quot;list&quot;,deptService.showAll());
        return &quot;dept&quot;;
    &#125;
&#125;
</code></pre>
<h5 id="9-3-6-新建页面"><a href="#9-3-6-新建页面" class="headerlink" title="9.3.6  新建页面"></a>9.3.6  新建页面</h5><p>​	在resources &#x2F;templates新建dept.html</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;table border=&quot;1&quot; width=&quot;500&quot;&gt;
        &lt;tr&gt;
            &lt;th&gt;编号&lt;/th&gt;
            &lt;th&gt;部门名称&lt;/th&gt;
            &lt;th&gt;查看&lt;/th&gt;
        &lt;/tr&gt;
        &lt;tr th:each=&quot;dept : $&#123;list&#125;&quot;&gt;
            &lt;td th:text=&quot;$&#123;dept.id&#125;&quot;&gt;&lt;/td&gt;
            &lt;td th:text=&quot;$&#123;dept.name&#125;&quot;&gt;&lt;/td&gt;
            &lt;td&gt; &lt;a th:href=&quot;@&#123;/showEmp(did=$&#123;dept.id&#125;)&#125;&quot;&gt;查看&lt;/a&gt; &lt;/td&gt;
        &lt;/tr&gt;
    &lt;/table&gt;
&lt;/body&gt;
&lt;/html&gt;             
</code></pre>
]]></content>
      <categories>
        <category>分布式</category>
        <category>Dubbo</category>
      </categories>
      <tags>
        <tag>分布式</tag>
        <tag>Dubbo</tag>
      </tags>
  </entry>
  <entry>
    <title>FastDFS</title>
    <url>/2022/10/07/Distribution/FastDFS/</url>
    <content><![CDATA[<h1 id="分布式文件存储系统FastDFS"><a href="#分布式文件存储系统FastDFS" class="headerlink" title="分布式文件存储系统FastDFS"></a>分布式文件存储系统FastDFS</h1><h1 id="一、分布式文件存储"><a href="#一、分布式文件存储" class="headerlink" title="一、分布式文件存储"></a>一、分布式文件存储</h1><h2 id="1-分布式文件存储的由来"><a href="#1-分布式文件存储的由来" class="headerlink" title="1.分布式文件存储的由来"></a>1.分布式文件存储的由来</h2><p>&amp;emsp;&amp;emsp;在我们的项目中有很多需要存储的内容出现，比如图片，视频，文件等等，在早期的时候用户量不大，产生的文件也不是很多，这时我们可以把文件和服务程序放在一个服务器中。</p>
<img data-src="/2022/10/07/Distribution/FastDFS/66d2beee9a4e47c08aa9552530a9c996.png" class="">


<p>&amp;emsp;&amp;emsp;后面随着文件越来越多，服务器的资源会被文件资源大量占据，从而影响到服务器的稳定，这时我们可以单独的把文件服务器拆出来。</p>
<img data-src="/2022/10/07/Distribution/FastDFS/8097b0f16465452b9f9b460e2149aa0d.png" class="">


<p>&amp;emsp;&amp;emsp;拆解出来后，文件服务的使用不会影响到我们的系统服务的稳定，但是当用户量越来越大，存储的文件就会越来越多，这时如果还是单台的文件服务，比如100T的文件，这时是存储不下去的，这时就产生了我们将的分布式文件存储，</p>
<img data-src="/2022/10/07/Distribution/FastDFS/fff16a09675d40ac926d42be9385d461.png" class="">


<p>&amp;emsp;&amp;emsp;也就是我们解决如何将这100T的文件分散的存储到各个节点上，然后当我们需要读取文件的时候又能非常快的帮我们把文件找到。这个就是分布式文件系统帮我们解决的问题了。</p>
<h2 id="2-常见的分布式存储框架"><a href="#2-常见的分布式存储框架" class="headerlink" title="2.常见的分布式存储框架"></a>2.常见的分布式存储框架</h2><p>&amp;emsp;&amp;emsp;接下来我们看看在国内常用的分布式存储的框架选择有哪些</p>
<table>
<thead>
<tr>
<th>分布式框架</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>FastDFS</td>
<td>我们介绍的主角，国产</td>
</tr>
<tr>
<td>HDFS</td>
<td>Hadoop组件中分布式存储框架</td>
</tr>
<tr>
<td>MinIO</td>
<td>MinIO是在Apache下的产品，最适合存储非结构化的数据，<br />比如照片，视频，日志文件，备份和容器等。</td>
</tr>
<tr>
<td>阿里云对象存储</td>
<td>当然我们还可以花费一点费用来使用其他厂商提供的对象存储服务</td>
</tr>
</tbody></table>
<p>&amp;emsp;&amp;emsp;好了就介绍这么几个，其他的我们也用不到了。</p>
<h1 id="二、FastDFS介绍"><a href="#二、FastDFS介绍" class="headerlink" title="二、FastDFS介绍"></a>二、FastDFS介绍</h1><p>&amp;emsp;&amp;emsp;FastDFS是余庆国人开发的一个开源的轻量级分布式文件系统，它对文件进行管理，功能包括：文件存储、文件同步、文件访问（文件上传、文件下载）等，解决了大容量存储和负载均衡的问题。特别适合以文件为载体的在线服务，如相册网站、视频网站等等。</p>
<p>&amp;emsp;&amp;emsp;FastDFS为互联网量身定制，充分考虑了冗余备份、负载均衡、线性扩容等机制，并注重高可用、高性能等指标，使用FastDFS很容易搭建一套高性能的文件服务器集群提供文件上传、下载等服务。</p>
<p>FastDFS的特点：</p>
<ul>
<li>FastDFS是一个轻量级的开源分布式文件系统</li>
<li>FastDFS主要解决了大容量的文件存储和高并发访问的问题，文件存取时实现了负载均衡</li>
<li>FastDFS实现了软件方式的RAID，可以使用廉价的IDE硬盘进行存储</li>
<li>支持存储服务器在线扩容</li>
<li>支持相同内容的文件只保存一份，节约磁盘空间</li>
<li>FastDFS只能通过Client API访问，不支持POSIX访问方式</li>
<li>FastDFS特别适合大中型网站使用，用来存储资源文件（如：图片、文档、音频、视频等等）</li>
</ul>
<p>架构图：</p>
<img data-src="/2022/10/07/Distribution/FastDFS/92362218a5024b7c9e9141b754756b79.png" class="">


<p>相关术语讲解：</p>
<table>
<thead>
<tr>
<th>名词</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Tracker Server</td>
<td>跟踪服务器，主要做调度工作，在访问上起负载均衡的作用。<br />记录storage server的状态，是连接Client和Storage server的枢纽</td>
</tr>
<tr>
<td>Storage Server</td>
<td>存储服务器，文件和meta data都保存到存储服务器上</td>
</tr>
<tr>
<td>group</td>
<td>组，也可称为卷。同组内服务器上的文件是完全相同的</td>
</tr>
<tr>
<td>文件标识</td>
<td>包括两部分：组名和文件名（包含路径）</td>
</tr>
<tr>
<td>meta-data</td>
<td>文件相关属性，键值对（Key Value Pair）方式，如：width&#x3D;1024,heigth&#x3D;768</td>
</tr>
</tbody></table>
<p>架构解读：</p>
<ul>
<li>只有两个角色，tracker server和storage server，不需要存储文件索引信息。</li>
<li>所有服务器都是对等的，不存在Master-Slave关系。</li>
<li>存储服务器采用分组方式，同组内存储服务器上的文件完全相同（RAID 1）。</li>
<li>不同组的storage server之间不会相互通信。</li>
<li>由storage server主动向tracker server报告状态信息，tracker server之间不会相互通信。</li>
</ul>
<h1 id="三、FastDFS安装"><a href="#三、FastDFS安装" class="headerlink" title="三、FastDFS安装"></a>三、FastDFS安装</h1><img data-src="/2022/10/07/Distribution/FastDFS/b60ca697c06d4425b7cd228b98dc3d19.png" class="">


<p>&amp;emsp;&amp;emsp;FastDFS的安装我们还是通过Docker来安装实现吧，直接在Linux上还装还是比较繁琐的，但就学习而言Docker安装还是非常高效的。Docker环境请自行安装哦，不清楚的可以看看我的Docker专题的内容。<a href="Docker%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99" title="Docker学习资料">https://blog.csdn.net/qq_38526573&#x2F;category_9619681.html</a></p>
<h2 id="1-拉取镜像文件"><a href="#1-拉取镜像文件" class="headerlink" title="1.拉取镜像文件"></a>1.拉取镜像文件</h2><p>&amp;emsp;&amp;emsp;首先我们可以通过 <code>docker search fastdfs</code> 来查询下有哪些镜像文件。</p>
<img data-src="/2022/10/07/Distribution/FastDFS/5a06a59eb24d4f9e847a4badeef871ac.png" class="">


<p>&amp;emsp;&amp;emsp;我们看到搜索到的镜像还是蛮多的，这里我们使用 <code>delron/fastdfs</code> 你也可以尝试使用其他的镜像来安装，你也可以制作自己的镜像来给别人使用哦，只是不同的镜像在使用的时候配置会有一些不一样，有些镜像没有提供Nginx的相关配置，使用的时候会繁琐一点。接下来通过 <code>docker pull delron/fastdfs</code>命令把镜像拉取下来。</p>
<pre><code class="shell">docker pull delron/fastdfs
</code></pre>
<img data-src="/2022/10/07/Distribution/FastDFS/5e5b85b3dc9a432abf615b27868fc7bf.png" class="">


<h2 id="2-构建Tracker服务"><a href="#2-构建Tracker服务" class="headerlink" title="2.构建Tracker服务"></a>2.构建Tracker服务</h2><p>&amp;emsp;&amp;emsp;首先我们需要通过Docker命令来创建Tracker服务。命令为</p>
<pre><code class="shell">docker run -d --name tracker --network=host -v /mydata/fastdfs/tracker:/var/fdfs delron/fastdfs tracker
</code></pre>
<p>&amp;emsp;&amp;emsp;tracker服务默认的端口为22122，-v 实现了容器和本地目录的挂载操作。</p>
<img data-src="/2022/10/07/Distribution/FastDFS/694d42632bf6410a806df9aa43e836c0.png" class="">


<h2 id="3-构建Storage服务"><a href="#3-构建Storage服务" class="headerlink" title="3.构建Storage服务"></a>3.构建Storage服务</h2><p>&amp;emsp;&amp;emsp;接下来创建Storage服务，具体的执行命令如下</p>
<pre><code class="shell">docker run -d --name storage --network=host  -e TRACKER_SERVER=192.168.1.195:22122 -v /mydata/fastdfs/storage:/var/fdfs -e GROUP_NAME=group1 delron/fastdfs storage
</code></pre>
<p>&amp;emsp;&amp;emsp;在执行上面命令的时候要注意对应的修改下，其中TRACKER_SERVER中的ip要修改为你的Tracker服务所在的服务IP地址。</p>
<img data-src="/2022/10/07/Distribution/FastDFS/dc2bdf85d0f24fe18a32efbe4caa2d27.png" class="">


<p>&amp;emsp;&amp;emsp;默认情况下在Storage服务中是帮我们安装了Nginx服务的，相关的端口为</p>
<table>
<thead>
<tr>
<th>服务</th>
<th>默认端口</th>
</tr>
</thead>
<tbody><tr>
<td>tracker</td>
<td>22122</td>
</tr>
<tr>
<td>storage</td>
<td>23000</td>
</tr>
<tr>
<td>Nginx</td>
<td>8888</td>
</tr>
</tbody></table>
<p>&amp;emsp;&amp;emsp;当然如果你发现这些相关的端口被占用了，或者想要对应的修改端口信息也可以的。要修改你可以先进入容器中查看下相关的配置文件信息。</p>
<img data-src="/2022/10/07/Distribution/FastDFS/da5cc21445e840baa85580ba420db94d.png" class="">


<p>&amp;emsp;&amp;emsp;然后查看storage.conf文件</p>
<img data-src="/2022/10/07/Distribution/FastDFS/63862499980b408195291de047048566.png" class="">


<p>&amp;emsp;&amp;emsp;这个是storage监听的Nginx的端口8888，如果要修改那么我们还需要修改Nginx中的服务配置，这块的配置在 <code>/usr/local/nginx/conf</code>目录下</p>
<img data-src="/2022/10/07/Distribution/FastDFS/f866c08177be4fd48bfd9a582ec78779.png" class="">


<p>&amp;emsp;&amp;emsp;查看下文件</p>
<img data-src="/2022/10/07/Distribution/FastDFS/dc7c5888363a400b9308f3ba64cca9ac.png" class="">


<p>所以要修改端口号的话，这两个位置都得修改了。当然本文我们就使用默认的端口号来使用了。</p>
<h2 id="4-测试图片上传"><a href="#4-测试图片上传" class="headerlink" title="4.测试图片上传"></a>4.测试图片上传</h2><p>&amp;emsp;&amp;emsp;好了，安装我们已经完成了，那么到底是否可以使用呢？我们来测试下。首先在虚拟机的&#x2F;mydata&#x2F;fastdfs&#x2F;storage下保存一张图片。</p>
<img data-src="/2022/10/07/Distribution/FastDFS/ff2ea2626bb34acd810fbb8d9438129a.png" class="">


<p>&amp;emsp;&amp;emsp;然后我们再进入到storage容器中。并且进入到 <code>/var/fdfs</code>目录下,可以看到我们挂载的文件了</p>
<img data-src="/2022/10/07/Distribution/FastDFS/cb8a96fb9bb644328880ca70378a7fc2.png" class="">


<p>&amp;emsp;&amp;emsp;然后执行如下命令即可完成图片的上传操作</p>
<pre><code class="shell">/usr/bin/fdfs_upload_file /etc/fdfs/client.conf 1.jpg
</code></pre>
<img data-src="/2022/10/07/Distribution/FastDFS/0fd0e82898bb45178eca4eef9a412745.png" class="">


<p>&amp;emsp;&amp;emsp;通过上面的提示我们看到文件上传成功了，而且返回了文件在storage中存储的信息。这时我们就可以通过这个信息来拼接访问的地址在浏览器中访问了：<span class="exturl" data-url="aHR0cDovLzE5Mi4xNjguNTYuMTAwOjg4ODgvZ3JvdXAxL00wMC8wMC8wMC93S2c0WkdIY0tMU0FYaWJhQUFlek11VXJsUzgyMzUuanBn">http://192.168.56.100:8888/group1/M00/00/00/wKg4ZGHcKLSAXibaAAezMuUrlS8235.jpg</span></p>
<img data-src="/2022/10/07/Distribution/FastDFS/b34e823e956f410297bfd1218ebc0231.png" class="">


<p>&amp;emsp;&amp;emsp;好了到这儿FastDFS的服务安装成功了。</p>
<h1 id="四、客户端操作"><a href="#四、客户端操作" class="headerlink" title="四、客户端操作"></a>四、客户端操作</h1><h2 id="1-Fastdfs-java-client"><a href="#1-Fastdfs-java-client" class="headerlink" title="1.Fastdfs-java-client"></a>1.Fastdfs-java-client</h2><p>&amp;emsp;&amp;emsp;首先我们来看下如何实现FastDFS中提供的JavaAPI来直接实现对应的文件上传和下载操作。</p>
<h3 id="1-1-文件上传"><a href="#1-1-文件上传" class="headerlink" title="1.1 文件上传"></a>1.1 文件上传</h3><p>&amp;emsp;&amp;emsp;先来看下文件上传的流程</p>
<img data-src="/2022/10/07/Distribution/FastDFS/c1da19dbbe994f55b20371ba0806d694.png" class="">


<p>&amp;emsp;&amp;emsp;上传流程的文字梳理为：</p>
<ol>
<li>客户端访问Tracker</li>
<li>Tracker 返回Storage的ip和端口</li>
<li>客户端直接访问Storage，把文件内容和元数据发送过去。</li>
<li>Storage返回文件存储id。包含了组名和文件名</li>
</ol>
<p>&amp;emsp;&amp;emsp;首先创建一个普通的maven项目，然后引入对应的依赖</p>
<pre><code class="xml">&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;cn.bestwu&lt;/groupId&gt;
        &lt;artifactId&gt;fastdfs-client-java&lt;/artifactId&gt;
        &lt;version&gt;1.27&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;
        &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt;
        &lt;version&gt;3.4&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
<p>&amp;emsp;&amp;emsp;然后编写FastDFS的配置文件，内容如下：注意ip修改为你自己对应的ip即可</p>
<pre><code class="xml">connect_timeout = 10
network_timeout = 30
charset = UTF-8
http.tracker_http_port = 8080
tracker_server = 192.168.56.100:22122
</code></pre>
<img data-src="/2022/10/07/Distribution/FastDFS/3c54c7b41f2a4ac2b420b65beafd10d2.png" class="">


<p>&amp;emsp;&amp;emsp;然后导入对应的工具类，在工具类中完成了StorageClient的实例化，并提供了相关的上传和下载的方法。</p>
<pre><code class="java">package com.bobo.fastdfs.config;

import org.apache.commons.lang3.StringUtils;
import org.csource.common.NameValuePair;
import org.csource.fastdfs.*;

import java.io.*;

public class FastDFSClient &#123;
    private static final String CONF_FILENAME = Thread.currentThread().getContextClassLoader().getResource(&quot;&quot;).getPath() + &quot;fdfs_client.conf&quot;;

    private static StorageClient storageClient = null;

    /**
     * 只加载一次.
     */
    static &#123;
        try &#123;
            ClientGlobal.init(CONF_FILENAME);
            TrackerClient trackerClient = new TrackerClient(ClientGlobal.g_tracker_group);
            TrackerServer trackerServer = trackerClient.getConnection();
            StorageServer storageServer = trackerClient.getStoreStorage(trackerServer);
            storageClient = new StorageClient(trackerServer, storageServer);
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
        &#125;
    &#125;

    /**
     *
     * @param inputStream
     *    上传的文件输入流
     * @param fileName
     *    上传的文件原始名
     * @return
     */
    public static String[] uploadFile(InputStream inputStream, String fileName) &#123;
        try &#123;
            // 文件的元数据
            NameValuePair[] meta_list = new NameValuePair[2];
            // 第一组元数据，文件的原始名称
            meta_list[0] = new NameValuePair(&quot;file name&quot;, fileName);
            // 第二组元数据
            meta_list[1] = new NameValuePair(&quot;file length&quot;, inputStream.available()+&quot;&quot;);
            // 准备字节数组
            byte[] file_buff = null;
            if (inputStream != null) &#123;
                // 查看文件的长度
                int len = inputStream.available();
                // 创建对应长度的字节数组
                file_buff = new byte[len];
                // 将输入流中的字节内容，读到字节数组中。
                inputStream.read(file_buff);
            &#125;
            // 上传文件。参数含义：要上传的文件的内容（使用字节数组传递），上传的文件的类型（扩展名），元数据
            String[] fileids = storageClient.upload_file(file_buff, getFileExt(fileName), meta_list);
            return fileids;
        &#125; catch (Exception ex) &#123;
            ex.printStackTrace();
            return null;
        &#125;
    &#125;

    /**
     *
     * @param file
     *            文件
     * @param fileName
     *            文件名
     * @return 返回Null则为失败
     */
    public static String[] uploadFile(File file, String fileName) &#123;
        FileInputStream fis = null;
        try &#123;
            NameValuePair[] meta_list = null; // new NameValuePair[0];
            fis = new FileInputStream(file);
            byte[] file_buff = null;
            if (fis != null) &#123;
                int len = fis.available();
                file_buff = new byte[len];
                fis.read(file_buff);
            &#125;

            String[] fileids = storageClient.upload_file(file_buff, getFileExt(fileName), meta_list);
            return fileids;
        &#125; catch (Exception ex) &#123;
            return null;
        &#125;finally&#123;
            if (fis != null)&#123;
                try &#123;
                    fis.close();
                &#125; catch (IOException e) &#123;
                    e.printStackTrace();
                &#125;
            &#125;
        &#125;
    &#125;

    /**
     * 根据组名和远程文件名来删除一个文件
     *
     * @param groupName
     *            例如 &quot;group1&quot; 如果不指定该值，默认为group1
     * @param remoteFileName
     *            例如&quot;M00/00/00/wKgxgk5HbLvfP86RAAAAChd9X1Y736.jpg&quot;
     * @return 0为成功，非0为失败，具体为错误代码
     */
    public static int deleteFile(String groupName, String remoteFileName) &#123;
        try &#123;
            int result = storageClient.delete_file(groupName == null ? &quot;group1&quot; : groupName, remoteFileName);
            return result;
        &#125; catch (Exception ex) &#123;
            return 0;
        &#125;
    &#125;

    /**
     * 修改一个已经存在的文件
     *
     * @param oldGroupName
     *            旧的组名
     * @param oldFileName
     *            旧的文件名
     * @param file
     *            新文件
     * @param fileName
     *            新文件名
     * @return 返回空则为失败
     */
    public static String[] modifyFile(String oldGroupName, String oldFileName, File file, String fileName) &#123;
        String[] fileids = null;
        try &#123;
            // 先上传
            fileids = uploadFile(file, fileName);
            if (fileids == null) &#123;
                return null;
            &#125;
            // 再删除
            int delResult = deleteFile(oldGroupName, oldFileName);
            if (delResult != 0) &#123;
                return null;
            &#125;
        &#125; catch (Exception ex) &#123;
            return null;
        &#125;
        return fileids;
    &#125;

    /**
     * 文件下载
     *
     * @param groupName 卷名
     * @param remoteFileName 文件名
     * @return 返回一个流
     */
    public static InputStream downloadFile(String groupName, String remoteFileName) &#123;
        try &#123;
            byte[] bytes = storageClient.download_file(groupName, remoteFileName);
            InputStream inputStream = new ByteArrayInputStream(bytes);
            return inputStream;
        &#125; catch (Exception ex) &#123;
            return null;
        &#125;
    &#125;

    public static NameValuePair[] getMetaDate(String groupName, String remoteFileName)&#123;
        try&#123;
            NameValuePair[] nvp = storageClient.get_metadata(groupName, remoteFileName);
            return nvp;
        &#125;catch(Exception ex)&#123;
            ex.printStackTrace();
            return null;
        &#125;
    &#125;

    /**
     * 获取文件后缀名（不带点）.
     *
     * @return 如：&quot;jpg&quot; or &quot;&quot;.
     */
    private static String getFileExt(String fileName) &#123;
        if (StringUtils.isBlank(fileName) || !fileName.contains(&quot;.&quot;)) &#123;
            return &quot;&quot;;
        &#125; else &#123;
            return fileName.substring(fileName.lastIndexOf(&quot;.&quot;) + 1); // 不带最后的点
        &#125;
    &#125;

&#125;
</code></pre>
<p>&amp;emsp;&amp;emsp;然后我们就可以来测试上传的操作了。</p>
<pre><code class="java">    public static void main(String[] args) &#123;
        try &#123;
            File file = new File(&quot;D:/2.jpg&quot;);
            InputStream is = new FileInputStream(file);
            String fileName = UUID.randomUUID().toString()+&quot;.jpg&quot;;
            String[] result = FastDFSClient.uploadFile(is, fileName);
            System.out.println(Arrays.toString(result));
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
</code></pre>
<img data-src="/2022/10/07/Distribution/FastDFS/6d7d9ff0b42e4e1daae06e47dab3793f.png" class="">


<p>访问即可：<span class="exturl" data-url="aHR0cDovLzE5Mi4xNjguNTYuMTAwOjg4ODgvZ3JvdXAxL00wMC8wMC8wMC93S2c0WkdIY1VFNkFaQTJVQUFXOGRJWDVwNTAzNzQuanBn">http://192.168.56.100:8888/group1/M00/00/00/wKg4ZGHcUE6AZA2UAAW8dIX5p50374.jpg</span></p>
<p>&amp;emsp;&amp;emsp;返回后的字符串的结构说明</p>
<img data-src="/2022/10/07/Distribution/FastDFS/5cec7e1344324b8dbd8050715d40b32f.png" class="">


<h3 id="1-2-文件下载"><a href="#1-2-文件下载" class="headerlink" title="1.2 文件下载"></a>1.2 文件下载</h3><p>&amp;emsp;&amp;emsp;文件下载的流程，如下</p>
<img data-src="/2022/10/07/Distribution/FastDFS/04cba11544044479996f178ed8e41768.png" class="">


<p>&amp;emsp;&amp;emsp;文件下载的流程为：</p>
<ol>
<li>client询问tracker需要下载的文件的storage，参数为文件的标识(group加文件名)。</li>
<li>tracker根据客户端的参数返回一台可用的storage。</li>
<li>client根据返回的storage直接完成对应的文件的下载。</li>
</ol>
<p>&amp;emsp;&amp;emsp;有了上面的基础，文件下载就非常简单了，我们只需要根据前面上传的文件的group和文件的存储路径就可以通过StorageClient中提供的downloadFile方法把对应的文件下载下来了，具体的代码如下</p>
<pre><code class="java">    /**
     * 文件下载
     */
    public static void downloadFile()&#123;
        try &#123;
            InputStream is = FastDFSClient
                    .downloadFile(&quot;group1&quot;, &quot;M00/00/00/wKg4ZGHcUE6AZA2UAAW8dIX5p50374.jpg&quot;);
            OutputStream os = new FileOutputStream(new File(&quot;D:/12.jpg&quot;));
            int index = 0 ;
            while((index = is.read())!=-1)&#123;
                os.write(index);
            &#125;
            os.flush();
            os.close();
            is.close();
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
</code></pre>
<p>注意：StorageClient是线程不安全的。那么我们的解决方案</p>
<ol>
<li>对文件的操作的每个方法我们做同步处理</li>
<li>每次操作文件的时候我们都获取一个新的StorageClient对象</li>
</ol>
<p>第一种方式效率肯定是最低的，第二种方式每次都要建立新的连接效率同样的会受到影响，这时最好的方式其实是把StorageClient交给我们自定义的连接池来管理</p>
<h2 id="2-SpringBoot整合"><a href="#2-SpringBoot整合" class="headerlink" title="2.SpringBoot整合"></a>2.SpringBoot整合</h2><p>&amp;emsp;&amp;emsp;我们在实际工作中基本都是和SpringBoot整合在一起来使用的，那么我们就来看看FastDFS是如何在SpringBoot项目中来使用的。首先创建一个普通的SpringBoot项目，然后导入fastdfs-spring-boot-starter这个依赖。</p>
<pre><code class="xml">    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;com.luhuiguo&lt;/groupId&gt;
            &lt;artifactId&gt;fastdfs-spring-boot-starter&lt;/artifactId&gt;
            &lt;version&gt;0.2.0&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
</code></pre>
<p>&amp;emsp;&amp;emsp;既然是一个starter，那么必然会在spring.factories文件中提供对应的自动配置类。</p>
<img data-src="/2022/10/07/Distribution/FastDFS/807e18ab743d4dcea0128bfc9f967a22.png" class="">


<p>&amp;emsp;&amp;emsp;可以看到给我们提供的配置类为FdfsAutoConfiguration进入后可以看到帮我们注入了很多的核心对象。</p>
<img data-src="/2022/10/07/Distribution/FastDFS/74a13becccb94ff8841c542cf0b9ce98.png" class="">


<p>&amp;emsp;&amp;emsp;然后可以看到系统提供的配置信息，前缀为 <code>fdfs</code></p>
<img data-src="/2022/10/07/Distribution/FastDFS/ef9e211d1145444c8b8348d2e73a6a76.png" class="">


<p>&amp;emsp;&amp;emsp;然后我们就可以在application.properties中配置FastDFS的配置信息了。</p>
<img data-src="/2022/10/07/Distribution/FastDFS/aa2dde964afc4909a7214239a269b65b.png" class="">


<p>&amp;emsp;&amp;emsp;配置完成后我们就可以测试文件的上传下载操作了</p>
<pre><code class="java">@SpringBootTest
class FastDfsSpringBootApplicationTests &#123;

    @Autowired
    public FastFileStorageClient storageClient;


    @Test
    void contextLoads() throws Exception&#123;
        File file = new File(&quot;d:\\2.jpg&quot;);
        StorePath path = storageClient.uploadFile(null,new FileInputStream(file),file.length(),file.getName());
        System.out.println(path.getFullPath());
    &#125;

&#125;
</code></pre>
<p>文件操作成功</p>
<img data-src="/2022/10/07/Distribution/FastDFS/781603ff01b4486c8775ee45639420f4.png" class="">

]]></content>
      <categories>
        <category>分布式</category>
        <category>FastDFS</category>
      </categories>
      <tags>
        <tag>分布式</tag>
        <tag>FastDFS</tag>
      </tags>
  </entry>
  <entry>
    <title>RPC</title>
    <url>/2022/10/07/Distribution/RPC/</url>
    <content><![CDATA[<h1 id="【RPC】"><a href="#【RPC】" class="headerlink" title="【RPC】"></a>【RPC】</h1><h2 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h2><ol>
<li><p>项目结构变化</p>
</li>
<li><p>RPC简介</p>
</li>
<li><p>RMI实现RPC</p>
</li>
<li><p>HttpClient实现RPC</p>
</li>
<li><p>Zookeeper安装</p>
</li>
<li><p>Zookeeper客户端常用命令</p>
</li>
<li><p>向Zookeeper中注册内容</p>
</li>
<li><p>从Zookeeper中发现内容</p>
</li>
<li><p>手写RPC框架</p>
</li>
</ol>
<h2 id="学习目标"><a href="#学习目标" class="headerlink" title="学习目标"></a>学习目标</h2><table>
<thead>
<tr>
<th>知识点</th>
<th>要求</th>
</tr>
</thead>
<tbody><tr>
<td>项目架构变化</td>
<td>掌握</td>
</tr>
<tr>
<td>RPC简介</td>
<td>掌握</td>
</tr>
<tr>
<td>RMI实现RPC</td>
<td>掌握</td>
</tr>
<tr>
<td>HttpClient实现RPC</td>
<td>了解</td>
</tr>
<tr>
<td>Zookeeper安装</td>
<td>掌握</td>
</tr>
<tr>
<td>Zookeeper客户端常用命令</td>
<td>掌握</td>
</tr>
<tr>
<td>向Zookeeper中注册内容</td>
<td>掌握</td>
</tr>
<tr>
<td>从zookeeper中发现内容</td>
<td>掌握</td>
</tr>
<tr>
<td>手写RPC框架</td>
<td>掌握</td>
</tr>
</tbody></table>
<h3 id="一、今天学什么？为什么讲？"><a href="#一、今天学什么？为什么讲？" class="headerlink" title="一、今天学什么？为什么讲？"></a>一、今天学什么？为什么讲？</h3><p>​	 现在学习RPC。后期学习的Dubbo是一个RPC框架，学习好现在的内容，学习Dubbo将会变得容易一些。</p>
<h3 id="二、项目架构变化"><a href="#二、项目架构变化" class="headerlink" title="二、项目架构变化"></a>二、项目架构变化</h3><h4 id="1-单体架构"><a href="#1-单体架构" class="headerlink" title="1     单体架构"></a>1     单体架构</h4><h5 id="1-1-架构图"><a href="#1-1-架构图" class="headerlink" title="1.1   架构图"></a>1.1   架构图</h5><p>​	单体架构就是一个项目里面包含这个项目中全部代码。一个应用搞定全部功能。</p>
<p>​	DNS 服务器可以是单映射，也可以配置多个映射。</p>
<img data-src="/2022/10/07/Distribution/RPC/rpc-01.png" class="">


<h5 id="1-2-软件代码结构"><a href="#1-2-软件代码结构" class="headerlink" title="1.2   软件代码结构"></a>1.2   软件代码结构</h5><p>​	在单体架构项目中，团队都是通过包(package)进行区分每个模块。</p>
<p>​	总体包结构：com.msb.*.分层包。</p>
<pre><code>项目名：
  -- com
    --msb
      -- common
        -- utils
      --user
        -- controller
        -- service
        -- mapper
      -- sys
        -- controller
        -- service
        -- mapper
</code></pre>
<h4 id="1-3-优缺点"><a href="#1-3-优缺点" class="headerlink" title="1.3   优缺点"></a>1.3   优缺点</h4><h5 id="1-3-1-优点"><a href="#1-3-1-优点" class="headerlink" title="1.3.1    优点"></a>1.3.1    优点</h5><p>​	部署简单</p>
<p>​	维护方便</p>
<p>​	成本低</p>
<h5 id="1-3-2-缺点"><a href="#1-3-2-缺点" class="headerlink" title="1.3.2    缺点"></a>1.3.2    缺点</h5><p>​	当项目规模大、用户访问频率高、并发量大、数据量大时，会大大降低程序执行效率，甚至出现服务器宕机等情况。</p>
<h4 id="1-4-适用项目"><a href="#1-4-适用项目" class="headerlink" title="1.4   适用项目"></a>1.4   适用项目</h4><p>传统管理项目，小型互联网项目。</p>
<h4 id="2-分布式架构"><a href="#2-分布式架构" class="headerlink" title="2     分布式架构"></a>2     分布式架构</h4><h5 id="2-1-架构图（简易版）"><a href="#2-1-架构图（简易版）" class="headerlink" title="2.1   架构图（简易版）"></a>2.1   架构图（简易版）</h5><p>​	分布式架构会把一个项目按照特定要求（多按照模块或功能）拆分成多个项目，每个项目分别部署到不同的服务器上。</p>
<img data-src="/2022/10/07/Distribution/RPC/rpc-02.png" class="">


<h5 id="2-2-软件代码结构"><a href="#2-2-软件代码结构" class="headerlink" title="2.2   软件代码结构"></a>2.2   软件代码结构</h5><pre><code>项目1：
  --com.msb.xxx
    -- controller
    -- service
    -- mapper
项目2
  --com.msb.mmm
    -- controller
    -- service
    -- mapper
</code></pre>
<h4 id="2-3-优缺点"><a href="#2-3-优缺点" class="headerlink" title="2.3   优缺点"></a>2.3   优缺点</h4><h5 id="2-3-1-优点"><a href="#2-3-1-优点" class="headerlink" title="2.3.1    优点"></a>2.3.1    优点</h5><p>​	增大了系统可用性。减少单点故障，导致整个应用不可用。</p>
<p>​	增加重用性。因为模块化，所以重用性更高。</p>
<p>​	增加可扩展性。有新的模块增加新的项目即可。</p>
<p>​	增加每个模块的负载能力。因为每个模块都是一个项目，所以每个模块的负载能力更强。</p>
<h5 id="2-3-2-缺点"><a href="#2-3-2-缺点" class="headerlink" title="2.3.2    缺点"></a>2.3.2    缺点</h5><p>​	成本更高。</p>
<p>​	架构更加复杂。</p>
<p>​	整体响应之间变长，一些业务需要多项目通信后给出结果。</p>
<p>​	吞吐量更大。吞吐量&#x3D; 请求数&#x2F;秒。</p>
<h4 id="2-4-待解决问题"><a href="#2-4-待解决问题" class="headerlink" title="2.4   待解决问题"></a>2.4   待解决问题</h4><p>​	分布式架构中各个模块如何进行通信？</p>
<p>​	可以使用Http协议，也可以使用RPC协议通信，也可以使用其他的通信方式。我们本阶段使用的是RPC协议，因为它比HTTP更适合项目内部通信。</p>
<h3 id="三、RPC简介"><a href="#三、RPC简介" class="headerlink" title="三、RPC简介"></a>三、RPC简介</h3><h4 id="1-RFC"><a href="#1-RFC" class="headerlink" title="1     RFC"></a>1     RFC</h4><p>​	RFC(Request For Comments) 是由互联网工程任务组(IETF)发布的文件集。文件集中每个文件都有自己唯一编号，例如：rfc1831。目前RFC文件由互联网协会(Internet Society，ISOC)赞助发型。</p>
<p>​	RPC就收集到了rfc 1831中。可以通过下面网址查看：</p>
<p>​	<span class="exturl" data-url="aHR0cHM6Ly9kYXRhdHJhY2tlci5pZXRmLm9yZy9kb2MvcmZjMTgzMS8=">https://datatracker.ietf.org/doc/rfc1831/</span></p>
<h4 id="2-RPC"><a href="#2-RPC" class="headerlink" title="2     RPC"></a>2     RPC</h4><p>​	RPC在rfc 1831中收录 ，RPC（Remote Procedure Call） 远程过程调用协议</p>
<p>​	RPC协议规定允许互联网中一台主机程序调用另一台主机程序，而程序员无需对这个交互过程进行编程。在RPC协议中强调当A程序调用B程序中功能或方法时，A是不知道B中方法具体实现的。</p>
<p>​	RPC是上层协议，底层可以基于TCP协议，也可以基于HTTP协议。一般我们说RPC都是基于RPC的具体实现，如：Dubbo框架。从广义上讲只要是满足网络中进行通讯调用都统称为RPC，甚至HTTP协议都可以说是RPC的具体实现，但是具体分析看来RPC协议要比HTTP协议更加高效，基于RPC的框架功能更多。</p>
<p>​	RPC协议是基于分布式架构而出现的，所以RPC在分布式项目中有着得天独厚的优势。</p>
<h4 id="3-RPC和HTTP对比"><a href="#3-RPC和HTTP对比" class="headerlink" title="3     RPC和HTTP对比"></a>3     RPC和HTTP对比</h4><h5 id="3-1-具体实现"><a href="#3-1-具体实现" class="headerlink" title="3.1   具体实现"></a>3.1   具体实现</h5><p>​	RPC：可以基于TCP协议，也可以基于HTTP协议。</p>
<p>​	HTTP：基于HTTP协议</p>
<h5 id="3-2-效率"><a href="#3-2-效率" class="headerlink" title="3.2   效率"></a>3.2   效率</h5><p>​	RPC：自定义具体实现可以减少很多无用的报文内容，使得报文体积更小。</p>
<p>​	HTTP：如果是HTTP 1.1 报文中很多内容都是无用的。如果是HTTP2.0以后和RPC相差不大，比RPC少的可能就是一些服务治理等功能。</p>
<h5 id="3-3-连接方式"><a href="#3-3-连接方式" class="headerlink" title="3.3   连接方式"></a>3.3   连接方式</h5><p>​	RPC：长连接支持。</p>
<p>​	HTTP：每次连接都是<span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vbmV2ZXJtb3Jld2FuZy9wLzg5MDY4MzMuaHRtbA==">三次握手四次挥手</span>。</p>
<h5 id="3-4-性能"><a href="#3-4-性能" class="headerlink" title="3.4   性能"></a>3.4   性能</h5><p>​	RPC可以基于很多序列化方式。如：thrift</p>
<p>​	HTTP 主要是通过JSON，序列化和反序列效率更低。</p>
<h5 id="3-5-注册中心"><a href="#3-5-注册中心" class="headerlink" title="3.5   注册中心"></a>3.5   注册中心</h5><p>​	RPC ：一般RPC框架都带有注册中心。</p>
<p>​	HTTP：都是直连。</p>
<h5 id="3-6-负载均衡"><a href="#3-6-负载均衡" class="headerlink" title="3.6   负载均衡"></a>3.6   负载均衡</h5><p>​	RPC：绝大多数RPC框架都带有负载均衡测量。</p>
<p>​	HTTP：一般都需要借助第三方工具。如：nginx</p>
<h5 id="3-7-综合结论"><a href="#3-7-综合结论" class="headerlink" title="3.7   综合结论"></a>3.7   综合结论</h5><p>​	RPC框架一般都带有丰富的服务治理等功能，更适合企业内部接口调用。而HTTP更适合多平台之间相互调用。</p>
<h3 id="四、HttpClient实现RPC"><a href="#四、HttpClient实现RPC" class="headerlink" title="四、HttpClient实现RPC"></a>四、HttpClient实现RPC</h3><h4 id="1-HttpClient简介"><a href="#1-HttpClient简介" class="headerlink" title="1     HttpClient简介"></a>1     HttpClient简介</h4><p>​	在JDK中java.net包下提供了用户HTTP访问的基本功能，但是它缺少灵活性或许多应用所需要的功能。</p>
<p>​	HttpClient起初是Apache Jakarta Common 的子项目。用来提供高效的、最新的、功能丰富的支持 HTTP 协议的客户端编程工具包，并且它支持 HTTP 协议最新的版本。2007年成为顶级项目。</p>
<p>​	通俗解释：HttpClient可以实现使用Java代码完成标准HTTP请求及响应。</p>
<h4 id="2-代码实现"><a href="#2-代码实现" class="headerlink" title="2     代码实现"></a>2     代码实现</h4><h5 id="2-1-服务端"><a href="#2-1-服务端" class="headerlink" title="2.1   服务端"></a>2.1   服务端</h5><p>​	新建项目HttpClientServer</p>
<h5 id="2-1-1-新建控制器"><a href="#2-1-1-新建控制器" class="headerlink" title="2.1.1    新建控制器"></a>2.1.1    新建控制器</h5><p>com.msb.controller.DemoController</p>
<pre><code class="java">@Controller
public class DemoController &#123;
    @RequestMapping(&quot;/demo&quot;)
    @ResponseBody
    public String demo(String param)&#123;
        return &quot;demo&quot;+param;
    &#125;
&#125;
</code></pre>
<h5 id="2-1-2-新建启动器"><a href="#2-1-2-新建启动器" class="headerlink" title="2.1.2    新建启动器"></a>2.1.2    新建启动器</h5><p>​	新建启动器</p>
<p>com.msb.HttpClientServerApplication</p>
<pre><code class="java">@SpringBootApplication
public class HttpClientServerApplication &#123;
    public static void main(String[] args) &#123;
    SpringApplication.run(HttpClientServerApplication.class,args);
    &#125;
&#125;
</code></pre>
<h4 id="2-2-客户端"><a href="#2-2-客户端" class="headerlink" title="2.2   客户端"></a>2.2   客户端</h4><p>​	新建HttpClientDemo项目</p>
<h5 id="2-2-1-添加依赖"><a href="#2-2-1-添加依赖" class="headerlink" title="2.2.1    添加依赖"></a>2.2.1    添加依赖</h5><pre><code class="xml"> &lt;dependency&gt;
        &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt;
        &lt;artifactId&gt;httpclient&lt;/artifactId&gt;
        &lt;version&gt;4.5.10&lt;/version&gt;
 &lt;/dependency&gt;
</code></pre>
<h5 id="2-2-2-新建类"><a href="#2-2-2-新建类" class="headerlink" title="2.2.2    新建类"></a>2.2.2    新建类</h5><p>​	新建com.msb.HttpClientDemo，编写主方法。</p>
<h6 id="2-2-2-1-使用GET方法访问"><a href="#2-2-2-1-使用GET方法访问" class="headerlink" title="2.2.2.1 使用GET方法访问"></a>2.2.2.1 使用GET方法访问</h6><pre><code class="java">public static void main(String[] args) &#123;
    try &#123;
        //创建http工具（理解成:浏览器） 发起请求，解析响应
        CloseableHttpClient httpClient = HttpClients.createDefault();
        //请求路径
        URIBuilder uriBuilder = new URIBuilder(&quot;http://localhost:8080/demo&quot;);
        uriBuilder.addParameter(&quot;param&quot;, &quot;get123&quot;);
        //创建HttpGet请求对象
        HttpGet get = new HttpGet(uriBuilder.build());
        //创建响应对象
        CloseableHttpResponse response = httpClient.execute(get);
        //由于响应体是字符串，因此把HttpEntity类型转换为字符串类型，并设置字符编码
        String result = EntityUtils.toString(response.getEntity(), &quot;utf-8&quot;);
        //输出结果
        System.out.println(result);
        //释放资源
        response.close();
        httpClient.close();
    &#125; catch (URISyntaxException e) &#123;
        e.printStackTrace();
    &#125; catch (IOException e) &#123;
        e.printStackTrace();
    &#125;
&#125;
</code></pre>
<h6 id="2-2-2-2-使用POST方式访问"><a href="#2-2-2-2-使用POST方式访问" class="headerlink" title="2.2.2.2 使用POST方式访问"></a>2.2.2.2 使用POST方式访问</h6><pre><code class="java">public class HttpClientDemo &#123;
    public static void main(String[] args) &#123;
        try &#123;
            //创建http工具（理解成:浏览器） 发起请求，解析响应
            CloseableHttpClient httpClient = HttpClients.createDefault();
            //创建HttpPOST请求对象
            HttpPost post = new HttpPost(&quot;http://localhost:8080/demo&quot;);
            //所有请求参数
            List&lt;NameValuePair&gt; params = new ArrayList&lt;&gt;();
            params.add(new BasicNameValuePair(&quot;param&quot;,&quot;123&quot;));
            //创建HttpEntity接口的文本实现类的对象，放入参数并设置编码
            HttpEntity httpEntity = new UrlEncodedFormEntity(params,&quot;utf-8&quot;);
            //放入到HttpPost对象中
            post.setEntity(httpEntity);            
            //创建响应对象
            CloseableHttpResponse response = httpClient.execute(post);
            //由于响应体是字符串，因此把HttpEntity类型转换为字符串类型
            String result = EntityUtils.toString(response.getEntity());
            //输出结果
            System.out.println(result);
            //释放资源
            response.close();
            httpClient.close();
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;
</code></pre>
<h4 id="3-Jackson用法"><a href="#3-Jackson用法" class="headerlink" title="3. Jackson用法"></a>3. Jackson用法</h4><h5 id="3-1-把对象转换为json字符串"><a href="#3-1-把对象转换为json字符串" class="headerlink" title="3.1   把对象转换为json字符串"></a>3.1   把对象转换为json字符串</h5><pre><code class="java">ObjectMapper objectMapper = new ObjectMapper();
People peo = new People();
objectMapper.writeValueAsString(peo);
</code></pre>
<h5 id="3-2-把json字符串转换为对象"><a href="#3-2-把json字符串转换为对象" class="headerlink" title="3.2   把json字符串转换为对象"></a>3.2   把json字符串转换为对象</h5><pre><code class="java">ObjectMapper objectMapper = new ObjectMapper();
People peo = objectMapper.readValue(content, People.class);
</code></pre>
<h5 id="3-3-把json字符串转换为List集合"><a href="#3-3-把json字符串转换为List集合" class="headerlink" title="3.3   把json字符串转换为List集合"></a>3.3   把json字符串转换为List集合</h5><pre><code class="java">ObjectMapper objectMapper = new ObjectMapper();
JavaType javaType = objectMapper.getTypeFactory().constructParametricType(List.class, People.class);
List&lt;People&gt; list = objectMapper.readValue(content, javaType);
</code></pre>
<h4 id="4-HttpClient请求包含JSON"><a href="#4-HttpClient请求包含JSON" class="headerlink" title="4     HttpClient请求包含JSON"></a>4     HttpClient请求包含JSON</h4><h5 id="4-1-java代码实现"><a href="#4-1-java代码实现" class="headerlink" title="4.1   java代码实现"></a>4.1   java代码实现</h5><pre><code class="java">public class HttpClientDemo &#123;
    public static void main(String[] args) &#123;
        try &#123;
            CloseableHttpClient httpClient = HttpClients.createDefault();
            HttpPost post = new HttpPost(&quot;http://localhost:8080/demo&quot;);
            HttpEntity httpEntity= null;
            String json = &quot;&#123;&#125;&quot;;
            StringEntity entity = new StringEntity(json, ContentType.APPLICATION_JSON);
            post.setEntity(entity);
            CloseableHttpResponse response = httpClient.execute(post);
            String result = EntityUtils.toString(response.getEntity());
            System.out.println(result);
            response.close();
            httpClient.close();
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;

 @Test
    public void testInputSteam()&#123;
        try &#123;

            CloseableHttpClient httpClient = HttpClients.createDefault();

            URIBuilder uriBuilder = new URIBuilder(&quot;http://localhost:8080/demo4&quot;);

            HttpPost httpPost = new HttpPost(uriBuilder.build());
            //创建集合
            List&lt;User&gt; users = new ArrayList&lt;&gt;();
            users.add(new User(2,&quot;李四&quot;));
            users.add(new User(1,&quot;张三&quot;));
            //将集合对象转化成JSON字符串
            ObjectMapper objectMapper = new ObjectMapper();
            String UserJson = objectMapper.writeValueAsString(users);
            System.out.println(UserJson);
            StringEntity stringEntity = new StringEntity(UserJson, 		  ContentType.APPLICATION_JSON);
            //设置请求体
            httpPost.setEntity(stringEntity);
            CloseableHttpResponse response= httpClient.execute(httpPost);
            String result = EntityUtils.toString(response.getEntity());
            System.out.println(result);

            response.close();
            httpClient.close();
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
</code></pre>
<h4 id="5-控制器接口参数"><a href="#5-控制器接口参数" class="headerlink" title="5     控制器接口参数"></a>5     控制器接口参数</h4><p>​	@RequestBody把请求体中流数据转换为指定的对象。多用在请求参数是json数据且请求的Content-Type&#x3D;”application&#x2F;json”</p>
<pre><code class="java">@RequestMapping(&quot;/demo4&quot;)
@ResponseBody
public String demo4(@RequestBody List&lt;People&gt; list) &#123;
    System.out.println(list);
    return list.toString();
&#125;
</code></pre>
<h4 id="6-Ajax发送json参数写法"><a href="#6-Ajax发送json参数写法" class="headerlink" title="6   Ajax发送json参数写法"></a>6   Ajax发送json参数写法</h4><pre><code class="html">var json = &#39;[&#123;&quot;id&quot;:123,&quot;name&quot;:&quot;msb&quot;&#125;,&#123;&quot;id&quot;:123,&quot;name&quot;:&quot;mashibing&quot;&#125;]&#39;;
 $.ajax(&#123;
     url:&#39;/demo5&#39;,
     type:&#39;post&#39;,
     success:function(data)&#123;
         alert(data);
         for(var i = 0 ;i&lt;data.length;i++)&#123;

             alert(data[i].id +&quot;  &quot;+data[i].name);
         &#125;
     &#125;,
     contentType:&#39;application/json&#39;,//请求体中内容类型
     dataType:&#39;json&#39;,//响应内容类型。
     data:json
 &#125;);
</code></pre>
<h4 id="7-跨域"><a href="#7-跨域" class="headerlink" title="7     跨域"></a>7     跨域</h4><p>​	跨域：协议、ip、端口中只要有一个不同就是跨域请求。</p>
<p>​	同源策略：浏览器默认只允许ajax访问同源(协议、ip、端口都相同)内容。</p>
<p>​	解决同源策略：</p>
<p>​	在控制器接口上添加@CrossOrigin。表示允许跨域。本质在响应头中添加Access-Control-Allow-Origin: *</p>
<pre><code class="html">var json = &#39;[&#123;&quot;id&quot;:123,&quot;name&quot;:&quot;msb&quot;&#125;,&#123;&quot;id&quot;:456,&quot;name&quot;:&quot;mashibing&quot;&#125;]&#39;;
 $.ajax(&#123;
     url:&#39;/demo5&#39;,
     type:&#39;post&#39;,
     success:function(data)&#123;
         alert(data);
         for(var i = 0 ;i&lt;data.length;i++)&#123;

             alert(data[i].id +&quot;  &quot;+data[i].name);
         &#125;
     &#125;,
     contentType:&#39;application/json&#39;,//请求体中内容类型
     dataType:&#39;json&#39;,//响应内容类型。
     data:json
 &#125;);
</code></pre>
<h3 id="五、RMI实现RPC"><a href="#五、RMI实现RPC" class="headerlink" title="五、RMI实现RPC"></a>五、RMI实现RPC</h3><h4 id="1-RMI简-介"><a href="#1-RMI简-介" class="headerlink" title="1     RMI简 介"></a>1     RMI简 介</h4><p>​	RMI(Remote Method Invocation) 远程方法调用。</p>
<p>​	RMI是从JDK1.2推出的功能，它可以实现在一个Java应用中可以像调用本地方法一样调用另一个服务器中Java应用（JVM）中的内容。</p>
<p>​	RMI 是Java语言的远程调用，无法实现跨语言。</p>
<h4 id="2-执行流程"><a href="#2-执行流程" class="headerlink" title="2     执行流程"></a>2     执行流程</h4><img data-src="/2022/10/07/Distribution/RPC/rpc-03.png" class="">


<p>​	Registry(注册表)是放置所有服务器对象的命名空间。 每次服务端创建一个对象时，它都会使用bind()或rebind()方法注册该对象。 这些是使用称为绑定名称的唯一名称注册的。 </p>
<p>​	要调用远程对象，客户端需要该对象的引用。即通过服务端绑定的名称从注册表中获取对象(lookup()方法)。</p>
<h4 id="3-API介绍"><a href="#3-API介绍" class="headerlink" title="3     API介绍"></a>3     API介绍</h4><h5 id="3-1-Remote"><a href="#3-1-Remote" class="headerlink" title="3.1   Remote"></a>3.1   Remote</h5><p>​	java.rmi.Remote 定义了此接口为远程调用接口。如果接口被外部调用，需要继承此接口。</p>
<pre><code class="java">public interface Remote&#123;&#125;
</code></pre>
<h4 id="3-2-RemoteException"><a href="#3-2-RemoteException" class="headerlink" title="3.2   RemoteException"></a>3.2   RemoteException</h4><p>​	java.rmi.RemoteException</p>
<p>​	继承了Remote接口的接口中，如果方法是允许被远程调用的，需要抛出此异常。</p>
<h4 id="3-3-UnicastRemoteObject"><a href="#3-3-UnicastRemoteObject" class="headerlink" title="3.3   UnicastRemoteObject"></a>3.3   UnicastRemoteObject</h4><p>​	java.rmi.server.UnicastRemoteObject</p>
<p>​	此类实现了Remote接口和Serializable接口。</p>
<p>​	自定义接口实现类除了实现自定义接口还需要继承此类。</p>
<h4 id="3-4-LocateRegistry"><a href="#3-4-LocateRegistry" class="headerlink" title="3.4   LocateRegistry"></a>3.4   LocateRegistry</h4><p>​	java.rmi.registry.LocateRegistry</p>
<p>​	可以通过LocateRegistry在本机上创建Registry，通过特定的端口就可以访问这个Registry。</p>
<h4 id="3-5-Naming"><a href="#3-5-Naming" class="headerlink" title="3.5   Naming"></a>3.5   Naming</h4><p>​	java.rmi.Naming</p>
<p>​	Naming定义了发布内容可访问RMI名称。也是通过Naming获取到指定的远程方法。</p>
<h4 id="4-代码实现"><a href="#4-代码实现" class="headerlink" title="4     代码实现"></a>4     代码实现</h4><h5 id="4-1-服务端创建"><a href="#4-1-服务端创建" class="headerlink" title="4.1   服务端创建"></a>4.1   服务端创建</h5><p>​	创建RmiServer项目</p>
<h5 id="4-1-1-编写接口"><a href="#4-1-1-编写接口" class="headerlink" title="4.1.1    编写接口"></a>4.1.1    编写接口</h5><p>​	com.msb.service.DemoService 编写</p>
<pre><code class="java">public interface DemoService extends Remote &#123;
    String demo(String demo) throws RemoteException;
&#125;
</code></pre>
<h5 id="4-1-2-编写实现类"><a href="#4-1-2-编写实现类" class="headerlink" title="4.1.2    编写实现类"></a>4.1.2    编写实现类</h5><p>​	com.msb.service.impl.DemoServiceImpl 编写。</p>
<p>​	注意：构造方法是public的。默认生成protected</p>
<pre><code class="java">public class DemoServiceImpl extends UnicastRemoteObject implements DemoService &#123;
    public DemoServiceImpl() throws RemoteException &#123;
    &#125;
    @Override
    public String demo(String demo) throws RemoteException &#123;
        return demo+&quot;123&quot;;
    &#125;
&#125;
</code></pre>
<h5 id="4-1-3-编写主方法"><a href="#4-1-3-编写主方法" class="headerlink" title="4.1.3    编写主方法"></a>4.1.3    编写主方法</h5><p>​	编写com.msb.DemoServer类，生成主方法</p>
<pre><code class="java">public class DemoServiceImpl extends UnicastRemoteObject implements DemoService &#123;
    public DemoServiceImpl() throws RemoteException &#123;
    &#125;
    @Override
    public String demo(String demo) throws RemoteException &#123;
        return demo+&quot;123&quot;;
    &#125;
&#125;
</code></pre>
<pre><code class="java">public class DemoStart &#123;
    public static void main(String[] args) &#123;
        try &#123;
            //1创建接口实现类
            RmiDemo rmiDemo = new RmiDemoImpl();
            //2创建注册表
            LocateRegistry.createRegistry(8099);
            //3绑定服务
            Naming.bind(&quot;rmi://localhost:8099/rmiDemo&quot;,rmiDemo);

            System.out.println(&quot;服务器启动！&quot;);
        &#125; catch (RemoteException e) &#123;
            e.printStackTrace();
        &#125; catch (AlreadyBoundException e) &#123;
            e.printStackTrace();
        &#125; catch (MalformedURLException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;
</code></pre>
<h5 id="4-1-4-运行项目"><a href="#4-1-4-运行项目" class="headerlink" title="4.1.4    运行项目"></a>4.1.4    运行项目</h5><p>​	运行后项目，项目一直处于启动状态，表示可以远程访问此项目中的远程方法。</p>
<h4 id="4-2-创建客户端代码"><a href="#4-2-创建客户端代码" class="headerlink" title="4.2   创建客户端代码"></a>4.2   创建客户端代码</h4><p>​	创建项目RmiClient</p>
<h5 id="4-2-1-复制服务端接口"><a href="#4-2-1-复制服务端接口" class="headerlink" title="4.2.1    复制服务端接口"></a>4.2.1    复制服务端接口</h5><p>​	把服务端com.msb.service.DemoService粘贴到项目中</p>
<h5 id="4-2-2-创建主方法类"><a href="#4-2-2-创建主方法类" class="headerlink" title="4.2.2    创建主方法类"></a>4.2.2    创建主方法类</h5><p>​	新建com.msb.DemoClient</p>
<pre><code class="java">public class DemoServiceImpl extends UnicastRemoteObject implements DemoService &#123;
    public DemoServiceImpl() throws RemoteException &#123;
    &#125;
    @Override
    public String demo(String demo) throws RemoteException &#123;
        return demo+&quot;123&quot;;
    &#125;
&#125;
</code></pre>
<h3 id="六、Zookeeper安装"><a href="#六、Zookeeper安装" class="headerlink" title="六、Zookeeper安装"></a>六、Zookeeper安装</h3><h4 id="1-Zookeeper简介"><a href="#1-Zookeeper简介" class="headerlink" title="1     Zookeeper简介"></a>1     Zookeeper简介</h4><p>​	zookeeper分布式管理软件。常用它做注册中心（依赖zookeeper的发布&#x2F;订阅功能）、配置文件中心、分布式锁配置、集群管理等。</p>
<p>​	zookeeper一共就有两个版本。主要使用的是java语言写的。</p>
<h4 id="2-安装"><a href="#2-安装" class="headerlink" title="2     安装"></a>2     安装</h4><h5 id="2-1-上传压缩文件"><a href="#2-1-上传压缩文件" class="headerlink" title="2.1   上传压缩文件"></a>2.1   上传压缩文件</h5><p>​	上传到 &#x2F;usr&#x2F;local&#x2F;tmp中</p>
<h4 id="2-2-解压"><a href="#2-2-解压" class="headerlink" title="2.2   解压"></a>2.2   解压</h4><pre><code class="sh">tar zxf apache-zookeeper-3.5.5-bin.tar.gz
cp -r apache-zookeeper-3.5.5-bin ../zookeeper
</code></pre>
<h4 id="2-3-新建data目录"><a href="#2-3-新建data目录" class="headerlink" title="2.3   新建data目录"></a>2.3   新建data目录</h4><p>进入到zookeeper中</p>
<pre><code class="sh">cd /usr/local/zookeeper
mkdir data
</code></pre>
<h4 id="2-4-修改配置文件"><a href="#2-4-修改配置文件" class="headerlink" title="2.4   修改配置文件"></a>2.4   修改配置文件</h4><p>进入conf中</p>
<pre><code class="sh">cd conf
cp zoo_sample.cfg zoo.cfg
vim zoo.cfg
</code></pre>
<p>修改dataDir为data文件夹路径</p>
<pre><code class="sh">dataDir=/usr/local/zookeeper/data
</code></pre>
<h4 id="2-5-启动zookeeper"><a href="#2-5-启动zookeeper" class="headerlink" title="2.5   启动zookeeper"></a>2.5   启动zookeeper</h4><p>进入bin文件夹</p>
<pre><code class="sh">cd /usr/local/zookeeper/bin
./zkServer.sh start
</code></pre>
<p>通过status查看启动状态。稍微有个等待时间</p>
<p># .&#x2F;zkServer.sh status</p>
<h3 id="六、Zookeeper安装-Docker"><a href="#六、Zookeeper安装-Docker" class="headerlink" title="六、Zookeeper安装(Docker)"></a>六、Zookeeper安装(Docker)</h3><p><strong>资料：</strong></p>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20va2luZ2tvby9wLzg3MzI0NDguaHRtbA==">https://www.cnblogs.com/kingkoo/p/8732448.html</span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL2F2ODA4NzQ2NjY/ZnJvbT1zZWFyY2gmYW1wO3NlaWQ9MTYyOTE0NTAyNTIxMTk5OTEwNCZhbXA7c3BtX2lkX2Zyb209MzMzLjMzNy4wLjA=">https://www.bilibili.com/video/av80874666?from=search&amp;seid=1629145025211999104&amp;spm_id_from=333.337.0.0</span></p>
<h4 id="1-Zookeeper简介-1"><a href="#1-Zookeeper简介-1" class="headerlink" title="1     Zookeeper简介"></a>1     Zookeeper简介</h4><p>​	zookeeper分布式管理软件。常用它做注册中心（依赖zookeeper的发布&#x2F;订阅功能）、配置文件中心、分布式锁配置、集群管理等。</p>
<p>​	zookeeper一共就有两个版本。主要使用的是java语言写的。</p>
<h4 id="2-安装-1"><a href="#2-安装-1" class="headerlink" title="2     安装"></a>2     安装</h4><h5 id="2-1-拉取镜像"><a href="#2-1-拉取镜像" class="headerlink" title="2.1   拉取镜像"></a>2.1   拉取镜像</h5><ul>
<li><p>自定义zookeeper目录</p>
<pre><code class="shell">mkdir /root/zookeeper

mkdir /root/zookeeper/data #原因参照上面 -在docker中data其实也不用在宿主机行自己生成(目前如此)

#仓库官网查看版本或者用命令直接查
docker search zookeeper

#拉取特定版本（3.5）
docker pull zookeeper:3.5
</code></pre>
</li>
</ul>
<h4 id="2-2-创建并启动容器"><a href="#2-2-创建并启动容器" class="headerlink" title="2.2 创建并启动容器"></a>2.2 创建并启动容器</h4><p>​	<strong>注：就目前而且 好像直接在docker中使用 zookeeper 不需要过多的配置，直接用命令创建吧，下面的解释先不看，具体原因后面补充</strong></p>
<p>命令：</p>
<pre><code class="shell">docker run -d --name zookeeper -v /root/zookeeper/data:/data -p 2181:2181 --restart always zookeeper:3.5
</code></pre>
<ul>
<li><code>--restart always</code>：始终重启</li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vYWdlb3ZiL3AvMTUzMjg3OTYuaHRtbA==">https://www.cnblogs.com/ageovb/p/15328796.html</span></li>
</ul>
<p><strong>解释</strong></p>
<ul>
<li><p>1、这里为啥只挂载了 data 目录–》因为当我们 没有直接的安装压缩包时，我们的就没有配置文件，所以我们直接生成，容器中就回自动生成conf文件，其中就有我们需要的 一系列配置文件，我们第一次创建的时候就可以如此，我们在进<strong>行配置文件的修改完成</strong>后，要将所有配置文件放到我们  bash 目录中的 conf 文件中去。</p>
</li>
<li><p>2、第一次进入容器</p>
<ul>
<li><p>在bash目录下进入bin 目录然后输入开启客户端命令</p>
<pre><code class="shell">./zkCli.sh
</code></pre>
</li>
</ul>
</li>
<li><p>3、第二次进入容器</p>
<pre><code class="shell">docker exec -it zookeeper /bin/bash  -p    端口号
或
docker exec -it zookeeper zkCli.sh
</code></pre>
</li>
</ul>
<p><strong>只看到这就可*，容器创建成功就可以直接用了，还没有出现问题。有待补充</strong></p>
<h4 id="2-3-修改配置文件"><a href="#2-3-修改配置文件" class="headerlink" title="2.3   修改配置文件"></a>2.3   修改配置文件</h4><ul>
<li>配置文件来源<ul>
<li>1、可以去我们的资料中直接解压出<strong>conf</strong>目录粘贴到我们的 zookeeper 目录中去</li>
<li>2、可以直接进行第 3 步，完事之后直接会在容器中生成。找到conf文件，修改其中的 zoo.cfg文件，</li>
</ul>
</li>
</ul>
<p>进入容器后，找到conf中的 **zoo.cfg文件，接下来就是修改 <strong>dataDir</strong> 路径为容器中的 data文件目录。</p>
<p>前提是要下载 vim ，因为容器中没有，命令是：</p>
<pre><code class="sh">apt-get update

apt-get install -y vim

cd conf
# 没有zoo.cfg 就先拷贝 zoo_sample.cfg 两个其实是一个文件，内容相同
#cp zoo_sample.cfg zoo.cfg
vim zoo.cfg
</code></pre>
<p>修改dataDir为data文件夹路径</p>
<pre><code class="sh">dataDir=/usr/local/zookeeper/data
</code></pre>
<h3 id="注：docker集群搭建在solr笔记中"><a href="#注：docker集群搭建在solr笔记中" class="headerlink" title="注：docker集群搭建在solr笔记中"></a>注：docker集群搭建在solr笔记中</h3><h3 id="七、Zookeeper客户端常用命令"><a href="#七、Zookeeper客户端常用命令" class="headerlink" title="七、Zookeeper客户端常用命令"></a>七、Zookeeper客户端常用命令</h3><p>​	进入到.&#x2F;zkCli.sh命令行工具后，可以使用下面常用命令</p>
<h4 id="1-ls"><a href="#1-ls" class="headerlink" title="1    ls"></a>1    ls</h4><p>​	ls [-s][-R] &#x2F;path</p>
<p>​	-s 详细信息，替代老版的ls2</p>
<p>​	-R 当前目录和子目录中内容都罗列出来</p>
<p>​	例如：ls -R &#x2F; 显示根目录下所有内容</p>
<h4 id="2-create"><a href="#2-create" class="headerlink" title="2     create"></a>2     create</h4><p>​	create &#x2F;path [data]</p>
<p>​	[data] 包含内容</p>
<p>​	创建指定路径信息</p>
<p>​	例如：create &#x2F;demo 创建&#x2F;demo</p>
<h4 id="3-get"><a href="#3-get" class="headerlink" title="3     get"></a>3     get</h4><p>​	get [-s] &#x2F;path</p>
<p>​	[-s] 详细信息</p>
<p>​	查看指定路径下内容。</p>
<p>​	例如： get -s &#x2F;demo</p>
<img data-src="/2022/10/07/Distribution/RPC/rpc-04.png" class="">


<p>​	null:存放的数据</p>
<p>​	cZxid:创建时zxid(znode每次改变时递增的事务id)</p>
<p>​	ctime:创建时间戳</p>
<p>​	mZxid:最近一次更新的zxid</p>
<p>​	mtime:最近一次更新的时间戳</p>
<p>​	pZxid:子节点的zxid</p>
<p>​	cversion:子节点更新次数</p>
<p>​	dataversion:节点数据更新次数</p>
<p>​	aclVersion:节点ACL(授权信息)的更新次数</p>
<p>​	ephemeralOwner:如果该节点为ephemeral节点(临时，生命周期与session一样), ephemeralOwner值表示与该节点绑定的session id. 如果该节点不是ephemeral节点, ephemeralOwner值为0.</p>
<p>​	dataLength:节点数据字节数</p>
<p>​	numChildren:子节点数量</p>
<h4 id="4-set"><a href="#4-set" class="headerlink" title="4     set"></a>4     set</h4><p>​	set &#x2F;path data</p>
<p>​	设置节点内容</p>
<h4 id="5-delete"><a href="#5-delete" class="headerlink" title="5     delete"></a>5     delete</h4><p>​	delete &#x2F;path</p>
<p>​	删除节点</p>
<h3 id="八、向Zookeeper中注册内容"><a href="#八、向Zookeeper中注册内容" class="headerlink" title="八、向Zookeeper中注册内容"></a>八、向Zookeeper中注册内容</h3><p>​	新建项目ZookeeperClient</p>
<h4 id="1-创建-x2F-demo"><a href="#1-创建-x2F-demo" class="headerlink" title="1     创建&#x2F;demo"></a>1     创建&#x2F;demo</h4><p>​	使用zookeeper的客户端命令工具创建&#x2F;demo</p>
<pre><code class="sh">./zkCli.sh
create /demos
</code></pre>
<h4 id="2-添加依赖"><a href="#2-添加依赖" class="headerlink" title="2     添加依赖"></a>2     添加依赖</h4><pre><code class="xml">    &lt;dependency&gt;
        &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt;
        &lt;artifactId&gt;zookeeper&lt;/artifactId&gt;
        &lt;version&gt;3.5.5&lt;/version&gt;
    &lt;/dependency&gt;
</code></pre>
<h4 id="3-编写代码"><a href="#3-编写代码" class="headerlink" title="3     编写代码"></a>3     编写代码</h4><p>​	创建类com.msb.MyApp。</p>
<p>​	ZooDefs.Ids.OPEN_ACL_UNSAFE 表示权限。</p>
<p>​	CreateMode.PERSISTENT_SEQUENTIAL 永久存储，文件内容编号递增。</p>
<pre><code class="java">public class SendContent &#123;
    public static void main(String[] args) &#123;
        try &#123;
            /**
             * 创建ZooKeeper对象
             * param1: zookeeper_IP+端口号
             * param2: 访问超时设置---时间设置长一点
             * param3: 通过观察者模式发出访问回复，当连接成功后，编写成功信息
             */
            ZooKeeper zooKeeper = new ZooKeeper(
                    &quot;192.168.88.128:2181&quot;,
                    1000000,
                    new Watcher() &#123;
                        @Override
                        public void process(WatchedEvent watchedEvent) &#123;
                            System.out.println(&quot;获取链接&quot;);
                        &#125;
                    &#125;
            );

            /**
             * 发送内容  向zookeeper服务器中
             * param1: 发送的文件
             * param2: 发送的内容(要转变成Bytes[])
             * param3: 权限
             * param4: 内容的模式
             */
            String result = zooKeeper.create(
                    &quot;/demos/rmi_address&quot;,
                    &quot;rmi:localhost:8080/demoService&quot;.getBytes(),
                    ZooDefs.Ids.OPEN_ACL_UNSAFE,
                    CreateMode.PERSISTENT_SEQUENTIAL
            );

            System.out.println(&quot;result  -&gt; &quot;+result);
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125; catch (KeeperException e) &#123;
            e.printStackTrace();
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;

    &#125;
&#125;
</code></pre>
<h4 id="4-查看上传数据"><a href="#4-查看上传数据" class="headerlink" title="4     查看上传数据"></a>4     查看上传数据</h4><p>​	ls -R &#x2F;            :查看列表</p>
<p>​	get  &#x2F;demo&#x2F;nn0000000002     :查看内容</p>
<h3 id="九、-从zookeeper中发现内容"><a href="#九、-从zookeeper中发现内容" class="headerlink" title="九、    从zookeeper中发现内容"></a>九、    从zookeeper中发现内容</h3><p>​	在原有项目中新建一个类，类中编写主方法。</p>
<pre><code class="java">public static void main(String[] args) &#123;
    try &#123;
        ZooKeeper zookeeper = new ZooKeeper(&quot;192.168.32.128:2181&quot;, 10000, new Watcher() &#123;
            @Override
            public void process(WatchedEvent watchedEvent) &#123;
                System.out.println(&quot;获取连接&quot;);
            &#125;
        &#125;);
        //获取列表
        List&lt;String&gt; list = zookeeper.getChildren(&quot;/demo&quot;, false);
        for (String child : list) &#123;
            byte[] result = zookeeper.getData(&quot;/demo/&quot; + child, false, null);
            System.out.println(new String(result));
        &#125;
    &#125; catch (IOException e) &#123;
        e.printStackTrace();
    &#125; catch (KeeperException e) &#123;
        e.printStackTrace();
    &#125; catch (InterruptedException e) &#123;
        e.printStackTrace();
    &#125;
&#125;
</code></pre>
<h3 id="十、手写RPC框架"><a href="#十、手写RPC框架" class="headerlink" title="十、手写RPC框架"></a>十、手写RPC框架</h3><p>​	使用Zookeeper作为注册中心，RMI作为连接技术，手写RPC框架。</p>
<h4 id="1-创建项目ParentDemo"><a href="#1-创建项目ParentDemo" class="headerlink" title="1     创建项目ParentDemo"></a>1     创建项目ParentDemo</h4><p>​	创建父项目ParentDemo。</p>
<p>​	包含3个聚合子项目。</p>
<p>​	pojo: service中需要的实体类</p>
<p>​	service：包含被serviceimpl和consumer依赖的接口。</p>
<p>​	serviceimpl:provider提供的服务内容</p>
<p>​	consumer：消费者，调用服务内容。</p>
<h4 id="2-在父项目中添加依赖"><a href="#2-在父项目中添加依赖" class="headerlink" title="2     在父项目中添加依赖"></a>2     在父项目中添加依赖</h4><pre><code class="java">public static void main(String[] args) &#123;
    try &#123;
        ZooKeeper zookeeper = new ZooKeeper(&quot;192.168.32.128:2181&quot;, 10000, new Watcher() &#123;
            @Override
            public void process(WatchedEvent watchedEvent) &#123;
                System.out.println(&quot;获取连接&quot;);
            &#125;
        &#125;);
        //获取列表
        List&lt;String&gt; list = zookeeper.getChildren(&quot;/demo&quot;, false);
        for (String child : list) &#123;
            byte[] result = zookeeper.getData(&quot;/demo/&quot; + child, false, null);
            System.out.println(new String(result));
        &#125;
    &#125; catch (IOException e) &#123;
        e.printStackTrace();
    &#125; catch (KeeperException e) &#123;
        e.printStackTrace();
    &#125; catch (InterruptedException e) &#123;
        e.printStackTrace();
    &#125;
&#125;
</code></pre>
<h4 id="3-创建service项目"><a href="#3-创建service项目" class="headerlink" title="3     创建service项目"></a>3     创建service项目</h4><h4 id="4-创建DemoService接口"><a href="#4-创建DemoService接口" class="headerlink" title="4     创建DemoService接口"></a>4     创建DemoService接口</h4><p>​	创建com.msb.DemoService</p>
<pre><code class="java">public interface DemoService extends Remote &#123;
    String demo(String param) throws RemoteException;
&#125;
</code></pre>
<h4 id="5-创建serviceimpl项目"><a href="#5-创建serviceimpl项目" class="headerlink" title="5     创建serviceimpl项目"></a>5     创建serviceimpl项目</h4><p>​	此项目编写接口具体实现，RMI服务发布和把信息发送到Zookeeper中。</p>
<p>​	项目结构如下：</p>
<p>​	在pom.xml中添加对service项目的依赖</p>
<pre><code class="xml">&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;artifactId&gt;service&lt;/artifactId&gt;
        &lt;groupId&gt;com.msb&lt;/groupId&gt;
        &lt;version&gt;1.0.0&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
<h4 id="6-创建DemoServiceImpl"><a href="#6-创建DemoServiceImpl" class="headerlink" title="6     创建DemoServiceImpl"></a>6     创建DemoServiceImpl</h4><p>​	创建com.bjsxt.service.impl.DemoServiceImpl</p>
<pre><code class="java">public class DemoServiceImpl extends UnicastRemoteObject implements DemoService &#123;
    public DemoServiceImpl() throws RemoteException &#123;
    &#125;

    @Override
    public String demo(String param) throws RemoteException&#123;
        return param+&quot;123&quot;;
    &#125;
&#125;
</code></pre>
<h4 id="7-创建RmiRun"><a href="#7-创建RmiRun" class="headerlink" title="7     创建RmiRun"></a>7     创建RmiRun</h4><p>​	创建com.msb.RmiRun。实现RMI服务的发布和Zookeeper消息的发布。</p>
<pre><code class="java">public class RmiRun &#123;
    public static void main(String[] args) &#123;
        try &#123;
            DemoService demoService = new DemoServiceImpl();
            LocateRegistry.createRegistry(8888);
            String url = &quot;rmi://localhost:8888/demoService&quot;;
            Naming.bind(url,demoService);
            ZooKeeper zookeeper = new ZooKeeper(&quot;192.168.32.128:2181&quot;, 10000, new Watcher() &#123;
                @Override
                public void process(WatchedEvent watchedEvent) &#123;
                    System.out.println(&quot;获取连接&quot;);
                &#125;
            &#125;);
            String content = zookeeper.create(&quot;/demo/demoService&quot;,url.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);
            System.out.println(&quot;服务发布成功。。。。&quot;);
        &#125; catch (AlreadyBoundException e) &#123;
            e.printStackTrace();
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125; catch (KeeperException e) &#123;
            e.printStackTrace();
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;
</code></pre>
<h4 id="8-创建Consumer项目"><a href="#8-创建Consumer项目" class="headerlink" title="8     创建Consumer项目"></a>8     创建Consumer项目</h4><p>​	新建consumer项目，此项目需要从zookeeper中获取rmi信息，并调用rmi服务</p>
<p>​	在pom.xml中添加对service项目的依赖</p>
<pre><code class="xml">&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;artifactId&gt;service&lt;/artifactId&gt;
        &lt;groupId&gt;com.msb&lt;/groupId&gt;
        &lt;version&gt;1.0.0&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
<h4 id="9-创建接口和实现类"><a href="#9-创建接口和实现类" class="headerlink" title="9     创建接口和实现类"></a>9     创建接口和实现类</h4><p>​	创建com.msb.service.ConsumerService接口</p>
<p>​	创建com.msb.service.impl.ConsumerServiceImpl实现类 </p>
<pre><code class="java">public interface ConsumerService &#123;
    String consumerService(String param);
&#125;
</code></pre>
<pre><code class="java">@Service
public class ConsumerServiceImpl implements ConsumerService &#123;
    @Override
    public String consumerService(String param) &#123;
        try &#123;
            ZooKeeper zookeeper = new ZooKeeper(&quot;192.168.32.128:2181&quot;, 10000, new Watcher() &#123;
                @Override
                public void process(WatchedEvent watchedEvent) &#123;
                    System.out.println(&quot;获取连接&quot;);
                &#125;
            &#125;);
            byte[] urlByte = zookeeper.getData(&quot;/demo/demoService&quot;, false, null);
            DemoService demoService =(DemoService) Naming.lookup(new String(urlByte));
            String result = demoService.demo(param);
            System.out.println(result);
            return result;
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125; catch (KeeperException e) &#123;
            e.printStackTrace();
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125; catch (NotBoundException e) &#123;
            e.printStackTrace();
        &#125;
        return null;
    &#125;
&#125;
</code></pre>
<h4 id="10-创建控制器"><a href="#10-创建控制器" class="headerlink" title="10  创建控制器"></a>10  创建控制器</h4><p>​	创建com.msb.controller.DemoController控制器</p>
<pre><code class="java">@Controller
public class DemoController &#123;

    @Autowired
    private ConsumerService consumerService;

    @RequestMapping(&quot;/demo&quot;)
    @ResponseBody
    public String demo(String param)&#123;
        return consumerService.consumerService(param);
    &#125;
&#125;
</code></pre>
<h4 id="11-创建启动器"><a href="#11-创建启动器" class="headerlink" title="11  创建启动器"></a>11  创建启动器</h4><p>​	创建com.msb.ConsumerApplication</p>
<pre><code class="java">@SpringBootApplication
public class ConsumerApplication &#123;
    public static void main(String[] args) &#123;
        SpringApplication.run(ConsumerApplication.class,args);
    &#125;
&#125;
</code></pre>
<h4 id="12-测试"><a href="#12-测试" class="headerlink" title="12  测试"></a>12  测试</h4><p>​	在浏览器输入：<span class="exturl" data-url="aHR0cDovL2xvY2FsaG9zdDo4MDgwL2RlbW8/cGFyYW09ZGVtbw==">http://localhost:8080/demo?param=demo</span></p>
<p>​	观察结果是否是：demo123</p>
]]></content>
      <categories>
        <category>分布式</category>
        <category>RPC</category>
      </categories>
      <tags>
        <tag>分布式</tag>
        <tag>RPC</tag>
      </tags>
  </entry>
  <entry>
    <title>RabbitMQ</title>
    <url>/2022/10/07/Distribution/RabbitMQ/</url>
    <content><![CDATA[<h2 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a><strong>主要内容</strong></h2><ol>
<li><p>AMQP简介</p>
</li>
<li><p>RabbitMQ简介</p>
</li>
<li><p>RabbitMQ原理</p>
</li>
<li><p>Erlang安装</p>
</li>
<li><p>安装RabbitMQ</p>
</li>
<li><p>RabbitMQ账户管理</p>
</li>
<li><p>交换器</p>
</li>
</ol>
<h2 id="学习目标"><a href="#学习目标" class="headerlink" title="学习目标"></a><strong>学习目标</strong></h2><table>
<thead>
<tr>
<th>知识点</th>
<th>要求</th>
</tr>
</thead>
<tbody><tr>
<td>AMQP简介</td>
<td>掌握</td>
</tr>
<tr>
<td>RabbmitMQ简介</td>
<td>掌握</td>
</tr>
<tr>
<td>RabbitMQ原理</td>
<td>掌握</td>
</tr>
<tr>
<td>Erlang安装</td>
<td>掌握</td>
</tr>
<tr>
<td>安装RabbitMQ</td>
<td>掌握</td>
</tr>
<tr>
<td>RabbitMQ账户管理</td>
<td>掌握</td>
</tr>
<tr>
<td>交换器</td>
<td>掌握</td>
</tr>
</tbody></table>
<h3 id="一、-AMQP简介"><a href="#一、-AMQP简介" class="headerlink" title="一、 AMQP简介"></a>一、 <strong>AMQP简介</strong></h3><h4 id="1-AMQP是什么"><a href="#1-AMQP是什么" class="headerlink" title="1 AMQP是什么?"></a>1 <strong>AMQP是什么?</strong></h4><p>​	AMQP(Advanced Message Queuing Protocol,高级消息队列协议)是进程之间传递异步消息的网络协议。</p>
<h3 id="2-AMQP工作过程"><a href="#2-AMQP工作过程" class="headerlink" title="2 AMQP工作过程"></a>2 <strong>AMQP工作过程</strong></h3><p>​	发布者(Publisher)发布消息(Message),经过交换机(Exchange)，交换机根据路由规则将收到消息分发给交换机绑定的队列(Queue)，最后AMQP代理会将消息投递给订阅了此队列的消费者，或者消费者按照需求自行获取。</p>
<img data-src="/2022/10/07/Distribution/RabbitMQ/RabbitMQ-01.jpg" class="">


<h3 id="3-队列"><a href="#3-队列" class="headerlink" title="3 队列"></a>3 <strong>队列</strong></h3><p>​	队列是数据结构中概念。数据存储在一个队列中，数据是有顺序的，先进的先出，后进后出。其中一侧负责进数据，另一侧负责出数据。</p>
<p>MQ（消息队列）很多功能都是基于此队列结构实现的!</p>
<h3 id="二、-RabbitMQ简介"><a href="#二、-RabbitMQ简介" class="headerlink" title="二、 RabbitMQ简介"></a>二、 <strong>RabbitMQ简介</strong></h3><h4 id="1-RabbitMQ介绍"><a href="#1-RabbitMQ介绍" class="headerlink" title="1 RabbitMQ介绍"></a>1 <strong>RabbitMQ介绍</strong></h4><p>​	RabbitMQ是由Erlang语言编写的基于AMQP的消息中间件。而消息中间件作为分布式系统重要组件之一，可以解决应用耦合，异步消息，流量削峰等问题。</p>
<h5 id="1-1-解决应用耦合"><a href="#1-1-解决应用耦合" class="headerlink" title="1.1 解决应用耦合"></a>1.1 <strong>解决应用耦合</strong></h5><h6 id="1-1-1-不使用MQ时"><a href="#1-1-1-不使用MQ时" class="headerlink" title="1.1.1 不使用MQ时"></a>1.1.1 <strong>不使用MQ时</strong></h6><img data-src="/2022/10/07/Distribution/RabbitMQ/RabbitMQ-03.jpg" class="">


<h6 id="1-1-2-使用MQ解决耦合"><a href="#1-1-2-使用MQ解决耦合" class="headerlink" title="1.1.2 使用MQ解决耦合"></a>1.1.2 <strong>使用MQ解决耦合</strong></h6><img data-src="/2022/10/07/Distribution/RabbitMQ/RabbitMQ-04.jpg" class="">


<h4 id="2-RabbitMQ适用场景"><a href="#2-RabbitMQ适用场景" class="headerlink" title="2 RabbitMQ适用场景"></a>2 <strong>RabbitMQ适用场景</strong></h4><p>​	排队算法 : 使用消息队列特性</p>
<p>​	秒杀活动 : 使用消息队列特性</p>
<p>​	消息分发 : 使用消息异步特性</p>
<p>​	异步处理 : 使用消息异步特性</p>
<p>​	数据同步 : 使用消息异步特性</p>
<p>​	处理耗时任务 : 使用消息异步特性</p>
<p>​	流量销峰</p>
<h3 id="三、-RabbitMQ原理"><a href="#三、-RabbitMQ原理" class="headerlink" title="三、 RabbitMQ原理"></a>三、 <strong>RabbitMQ原理</strong></h3><img data-src="/2022/10/07/Distribution/RabbitMQ/RabbitMQ-05.jpg" class="">


<table>
<thead>
<tr>
<th>1.Message</th>
</tr>
</thead>
<tbody><tr>
<td>消息。消息是不具名的，它由消息头消息体组成。消息体是不透明的，而消息头则由一系列可选属性组成，这些属性包括：routing-key(路由键)、priority(相对于其他消息的优先权)、delivery-mode(指出消息可能持久性存储)等。</td>
</tr>
<tr>
<td><strong>2</strong>.<strong>Publisher</strong></td>
</tr>
<tr>
<td>消息的生产者。也是一个向交换器发布消息的客户端应用程序。</td>
</tr>
<tr>
<td><strong>3</strong>.<strong>Consumer</strong></td>
</tr>
<tr>
<td>消息的消费者。表示一个从消息队列中取得消息的客户端应用程序。</td>
</tr>
<tr>
<td><strong>4.Exchange</strong></td>
</tr>
<tr>
<td>交换器。用来接收生产者发送的消息并将这些消息路由给服务器中的队列。三种常用的交换器类型1. direct(发布与订阅 完全匹配)2. fanout(广播)3. topic(主题，规则匹配)</td>
</tr>
<tr>
<td><strong>5.Binding</strong></td>
</tr>
<tr>
<td>绑定。用于消息队列和交换器之间的关联。一个绑定就是基于路由键将交换器和消息队列连接起来的路由规则，所以可以将交换器理解成一个由绑定构成的路由表。</td>
</tr>
<tr>
<td><strong>6.Queue</strong></td>
</tr>
<tr>
<td>消息队列。用来保存消息直到发送给消费者。它是消息的容器，也是消息的终点。一个消息可投入一个或多个队列。消息一直在队列里面，等待消费者链接到这个队列将其取走。</td>
</tr>
<tr>
<td><strong>7.Routing-key</strong></td>
</tr>
<tr>
<td>路由键。RabbitMQ决定消息该投递到哪个队列的规则。（也可以理解为队列的名称，路由键是key，队列是value）队列通过路由键绑定到交换器。消息发送到MQ服务器时，消息将拥有一个路由键，即便是空的，RabbitMQ也会将其和绑定使用的路由键进行匹配。如果相匹配，消息将会投递到该队列。如果不匹配，消息将会进入黑洞。</td>
</tr>
<tr>
<td><strong>8.Connection</strong></td>
</tr>
<tr>
<td>链接。指rabbit服务器和服务建立的TCP链接。</td>
</tr>
<tr>
<td><strong>9.Channel</strong></td>
</tr>
<tr>
<td>信道。1，Channel中文叫做信道，是TCP里面的虚拟链接。例如：电缆相当于TCP，信道是一个独立光纤束，一条TCP连接上创建多条信道是没有问题的。2，TCP一旦打开，就会创建AMQP信道。3，无论是发布消息、接收消息、订阅队列，这些动作都是通过信道完成的。</td>
</tr>
<tr>
<td><strong>10.Virtual Host</strong></td>
</tr>
<tr>
<td>虚拟主机。表示一批交换器，消息队列和相关对象。虚拟主机是共享相同的身份认证和加密环境的独立服务器域。每个vhost本质上就是一个mini版的RabbitMQ服务器，拥有自己的队列、交换器、绑定和权限机制。vhost是AMQP概念的基础，必须在链接时指定，RabbitMQ默认的vhost是**&#x2F;**</td>
</tr>
<tr>
<td><strong>11.Borker</strong></td>
</tr>
<tr>
<td>表示消息队列服务器实体。</td>
</tr>
<tr>
<td><strong>12.交换器和队列的关系</strong></td>
</tr>
<tr>
<td>交换器是通过路由键和队列绑定在一起的，如果消息拥有的路由键跟队列和交换器的路由键匹配，那么消息就会被路由到该绑定的队列中。     也就是说，消息到队列的过程中，消息首先会经过交换器，接下来交换器在通过路由键匹配分发消息到具体的队列中。     路由键可以理解为匹配的规则。</td>
</tr>
<tr>
<td><strong>13.RabbitMQ为什么需要信道？为什么不是TCP直接通信？</strong></td>
</tr>
<tr>
<td>1. TCP的创建和销毁开销特别大。创建需要3次握手，销毁需要4次分手。2. 如果不用信道，那应用程序就会以TCP链接Rabbit，高峰时每秒成千上万条链接会造成资源巨大的浪费，而且操作系统每秒处理TCP链接数也是有限制的，必定造成性能瓶颈。3. 信道的原理是一条线程一条通道，多条线程多条通道同用一条TCP链接。一条TCP链接可以容纳无限的信道，即使每秒成千上万的请求也不会成为性能的瓶颈。</td>
</tr>
</tbody></table>
<h3 id="四、-Erlang安装"><a href="#四、-Erlang安装" class="headerlink" title="四、 Erlang安装"></a>四、 <strong>Erlang安装</strong></h3><p>​	RabbitMQ是使用Erlang语言编写的，所以需要先配置Erlang</p>
<h4 id="1-修改主机名"><a href="#1-修改主机名" class="headerlink" title="1 修改主机名"></a>1 <strong>修改主机名</strong></h4><p>​	RabbitMQ是通过主机名进行访问的，必须指定能访问的主机名。</p>
<pre><code>  vim /etc/sysconfig/network
</code></pre>
<img data-src="/2022/10/07/Distribution/RabbitMQ/RabbitMQ-06.jpg" class="">


<pre><code>  vim /etc/hosts
</code></pre>
<p>​	新添加了一行，前面为服务器ip，空格后面添加计算机主机名</p>
<img data-src="/2022/10/07/Distribution/RabbitMQ/RabbitMQ-07.jpg" class="">


<h4 id="2-安装依赖"><a href="#2-安装依赖" class="headerlink" title="2 安装依赖"></a>2 <strong>安装依赖</strong></h4><pre><code>  yum -y install make gcc gcc-c++ kernel-devel m4 ncurses-devel openssl-devel unixODBC unixODBC-devel
</code></pre>
<h4 id="3-上传并解压"><a href="#3-上传并解压" class="headerlink" title="3 上传并解压"></a>3 <strong>上传并解压</strong></h4><p>​	上传otp_src_22.0.tar.gz到&#x2F;usr&#x2F;local&#x2F;tmp目录中，进入目录并解压。</p>
<pre><code> 解压时注意，此压缩包不具有gzip属性，解压参数没有z，只有xf
</code></pre>
<pre><code>  cd /usr/local/tmp
  tar xf otp_src_22.0.tar.gz -C /usr/local/tmp
</code></pre>
<h4 id="4-配置参数"><a href="#4-配置参数" class="headerlink" title="4 配置参数"></a>4 <strong>配置参数</strong></h4><p>​	先新建&#x2F;usr&#x2F;local&#x2F;erlang文件夹，作为安装文件夹</p>
<pre><code>  mkdir -p /usr/local/erlang
</code></pre>
<p>​	 进入文件夹</p>
<pre><code>  cd otp_src_22.0
</code></pre>
<p>​	 配置参数</p>
<pre><code>  ./configure --prefix=/usr/local/erlang --with-ssl --enable-threads --enable-smp-support --enable-kernel-poll --enable-hipe --without-javac
</code></pre>
<h4 id="5-编译并安装"><a href="#5-编译并安装" class="headerlink" title="5 编译并安装"></a>5 <strong>编译并安装</strong></h4><p>​	编译 </p>
<pre><code>  make
</code></pre>
<p>​	 安装</p>
<pre><code>  make install
</code></pre>
<h4 id="6-修改环境变量"><a href="#6-修改环境变量" class="headerlink" title="6 修改环境变量"></a>6 <strong>修改环境变量</strong></h4><p>​	修改&#x2F;etc&#x2F;profile文件</p>
<pre><code> vim /etc/profile
</code></pre>
<p>​	 在文件中添加下面代码 </p>
<pre><code>export PATH=$PATH:/usr/local/erlang/bin
</code></pre>
<p>​	运行文件，让修改内容生效</p>
<pre><code>  source /etc/profile
</code></pre>
<h4 id="7-查看配置是否成功"><a href="#7-查看配置是否成功" class="headerlink" title="7 查看配置是否成功"></a>7 <strong>查看配置是否成功</strong></h4><pre><code>  erl -version
</code></pre>
<img data-src="/2022/10/07/Distribution/RabbitMQ/RabbitMQ-08.jpg" class="">


<h3 id="五、-安装RabbitMQ"><a href="#五、-安装RabbitMQ" class="headerlink" title="五、 安装RabbitMQ"></a>五、 <strong>安装RabbitMQ</strong></h3><h4 id="1-上传并解压"><a href="#1-上传并解压" class="headerlink" title="1 上传并解压"></a>1 <strong>上传并解压</strong></h4><p>​	上传rabbitmq-server-generic-unix-3.7.18.tar.xz到&#x2F;usr&#x2F;loca&#x2F;tmp中</p>
<pre><code>  cd /usr/local/tmp
  tar xf rabbitmq-server-generic-unix-3.7.18.tar.xz
</code></pre>
<h4 id="2-复制到local下"><a href="#2-复制到local下" class="headerlink" title="2 复制到local下"></a>2 <strong>复制到local下</strong></h4><p>​	复制解压文件到&#x2F;usr&#x2F;local下，命名为rabbitmq</p>
<pre><code>  cp -r rabbitmq_server-3.7.18 /usr/local/rabbitmq
</code></pre>
<h4 id="3-配置环境变量"><a href="#3-配置环境变量" class="headerlink" title="3 配置环境变量"></a>3 <strong>配置环境变量</strong></h4><pre><code>  vim /etc/profile
</code></pre>
<p>​	在文件中添加 </p>
<pre><code>export PATH=$PATH:/usr/local/rabbitmq/sbin
</code></pre>
<p>​	解析文件</p>
<pre><code># source /etc/profile
</code></pre>
<h4 id="4-开启web管理插件"><a href="#4-开启web管理插件" class="headerlink" title="4 开启web管理插件"></a>4 <strong>开启web管理插件</strong></h4><p>​	进入rabbitmq&#x2F;sbin目录</p>
<pre><code># cd /usr/local/rabbitmq/sbin
</code></pre>
<pre><code> 查看插件列表
</code></pre>
<pre><code># ./rabbitmq-plugins list
</code></pre>
<pre><code> 生效管理插件
</code></pre>
<pre><code># ./rabbitmq-plugins enable rabbitmq_management
</code></pre>
<h4 id="5-后台运行"><a href="#5-后台运行" class="headerlink" title="5 后台运行"></a>5 <strong>后台运行</strong></h4><p>​	启动rabbitmq。</p>
<pre><code># ./rabbitmq-server -detached
</code></pre>
<p>​	停止命令，如果无法停止，使用kill -9 进程号进行关闭</p>
<pre><code># ./rabbitmqctl stop_app
</code></pre>
<h4 id="6-查看web管理界面"><a href="#6-查看web管理界面" class="headerlink" title="6 查看web管理界面"></a>6 <strong>查看web管理界面</strong></h4><p>​	默认可以在安装rabbitmq的电脑上通过用户名：guest密码guest进行访问web管理界面</p>
<p>​	端口号：15672（放行端口，或关闭防火墙）</p>
<p>​	在虚拟机浏览器中输入：</p>
<p>​	<span class="exturl" data-url="aHR0cDovL2xvY2FsaG9zdDoxNTY3Mi8=">http://localhost:15672</span></p>
<h3 id="六、-RabbitMq账户管理"><a href="#六、-RabbitMq账户管理" class="headerlink" title="六、 RabbitMq账户管理"></a>六、 <strong>RabbitMq账户管理</strong></h3><h4 id="1-创建账户"><a href="#1-创建账户" class="headerlink" title="1 创建账户"></a>1 <strong>创建账户</strong></h4><p>​	语法：.&#x2F;rabbitmqctl add_user username password</p>
<pre><code># cd /usr/local/rabbitmq/sbin
# ./rabbitmqctl add_user mashibing mashibing
</code></pre>
<h4 id="2-给用户授予管理员角色"><a href="#2-给用户授予管理员角色" class="headerlink" title="2 给用户授予管理员角色"></a>2 <strong>给用户授予管理员角色</strong></h4><p>​	其中smallming为新建用户的用户名</p>
<pre><code># ./rabbitmqctl set_user_tags mashibing administrator
</code></pre>
<h4 id="3-给用户授权"><a href="#3-给用户授权" class="headerlink" title="3 给用户授权"></a>3 <strong>给用户授权</strong></h4><p>​	“&#x2F;” 表示虚拟机</p>
<p>​	mashibing 表示用户名</p>
<p>​	“.<em>“ “.</em>“ “.*” 表示完整权限</p>
<pre><code># ./rabbitmqctl set_permissions -p &quot;/&quot; mashibing &quot;.*&quot; &quot;.*&quot; &quot;.*&quot;
</code></pre>
<h4 id="4-登录"><a href="#4-登录" class="headerlink" title="4 登录"></a>4 <strong>登录</strong></h4><p>​	使用新建账户和密码在windows中访问rabbitmq并登录 </p>
<p>​	在浏览器地址栏输入：</p>
<p>​	<span class="exturl" data-url="aHR0cDovL2lwOjE1NjcyLw==">http://ip:15672/</span></p>
<pre><code> 用户名：mashibing
</code></pre>
<p>​	密码：mashibing</p>
<h3 id="七、-交换器（交换机）"><a href="#七、-交换器（交换机）" class="headerlink" title="七、 交换器（交换机）"></a>七、 <strong>交换器（交换机）</strong></h3><p>​	交换器负责接收客户端传递过来的消息，并转发到对应的队列中。在RabbitMQ中支持四种交换器</p>
<p>​	1.Direct Exchange：直连交换器（默认）</p>
<p>​	2.Fanout Exchange：扇形交换器</p>
<p>​	3.Topic Exchange：主题交换器</p>
<p>​	4.Header Exchange：首部交换器。</p>
<p>​	在RabbitMq的Web管理界面中Exchanges选项卡就可以看见这四个交换器。</p>
<img data-src="/2022/10/07/Distribution/RabbitMQ/RabbitMQ-09.jpg" class="">


<h4 id="1-direct交换器"><a href="#1-direct交换器" class="headerlink" title="1 direct交换器"></a>1 <strong>direct交换器</strong></h4><p>​	direct交换器是RabbitMQ默认交换器。默认会进行公平调度。所有接受者依次从消息队列中获取值。Publisher给哪个队列发消息，就一定是给哪个队列发送消息。对交换器绑定的其他队列没有任何影响。</p>
<p>​	（代码演示）一个队列需要绑定多个消费者</p>
<p>​	需要使用注解&#x2F;API：</p>
<p>​	org.springframework.amqp.core.Queue:队列</p>
<p>​	AmqpTemplate：操作RabbitMQ的接口。负责发送或接收消息</p>
<p>​	@RabbitListener(queues &#x3D; “”) 注解某个方法为接收消息方法</p>
<h4 id="1-1-代码实现"><a href="#1-1-代码实现" class="headerlink" title="1.1 代码实现"></a>1.1 <strong>代码实现</strong></h4><h5 id="1-1-1-新建项目Publisher"><a href="#1-1-1-新建项目Publisher" class="headerlink" title="1.1.1 新建项目Publisher"></a>1.1.1 <strong>新建项目Publisher</strong></h5><h6 id="1-1-1-1-添加依赖"><a href="#1-1-1-1-添加依赖" class="headerlink" title="1.1.1.1 添加依赖"></a>1.1.1.1 <strong>添加依赖</strong></h6><pre><code>&lt;parent&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
    &lt;version&gt;2.2.2.RELEASE&lt;/version&gt;
&lt;/parent&gt;

&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
<h6 id="1-1-1-2-编写配置文件"><a href="#1-1-1-2-编写配置文件" class="headerlink" title="1.1.1.2 编写配置文件"></a>1.1.1.2 <strong>编写配置文件</strong></h6><p>​	新建application.yml.</p>
<p>​	host:默认值localhost</p>
<p>​	username默认值：guest</p>
<p>​	password默认值：guest	</p>
<pre><code>spring:
  rabbitmq:
    host: 192.168.1.195
    username: mashibing
    password: mashibing
</code></pre>
<h6 id="1-1-1-3-编写配置类"><a href="#1-1-1-3-编写配置类" class="headerlink" title="1.1.1.3 编写配置类"></a>1.1.1.3 <strong>编写配置类</strong></h6><p>新建com.config.RabbitmqConfig</p>
<p>​	队列的创建只有没有这个队列的时候需要编写。以后没有这个queue()方法也可以。</p>
<pre><code>@Configuration
public class RabbitmqConfig &#123;
    @Bean
    protected Queue queue()&#123;
        Queue queue = new Queue(&quot;myqueue&quot;);
        return queue;
    &#125;
&#125;
</code></pre>
<h6 id="1-1-1-4-编写启动类"><a href="#1-1-1-4-编写启动类" class="headerlink" title="1.1.1.4 编写启动类"></a>1.1.1.4 <strong>编写启动类</strong></h6><p>略</p>
<h6 id="1-1-1-5-编写测试类"><a href="#1-1-1-5-编写测试类" class="headerlink" title="1.1.1.5 编写测试类"></a>1.1.1.5 <strong>编写测试类</strong></h6><p>SpringBoot整合Spring-AMQP后包含内置对象AmqpTemplate</p>
<pre><code>@SpringBootTest(classes = PublisherApplication.class)
@RunWith(SpringJUnit4ClassRunner.class)
public class MyTest &#123;
    @Autowired
    private AmqpTemplate amqpTemplate;

    @Test
    public void test()&#123;
        amqpTemplate.convertAndSend(&quot;myqueue&quot;,&quot;这是内容1&quot;);
        System.out.println(&quot;发送成功&quot;);
    &#125;
&#125;
</code></pre>
<h5 id="1-1-2-创建Consumer"><a href="#1-1-2-创建Consumer" class="headerlink" title="1.1.2 创建Consumer"></a>1.1.2 <strong>创建Consumer</strong></h5><p>​	新建项目consumer</p>
<h6 id="1-1-2-1-添加依赖"><a href="#1-1-2-1-添加依赖" class="headerlink" title="1.1.2.1 添加依赖"></a>1.1.2.1 <strong>添加依赖</strong></h6><p>​	和Publisher一样</p>
<h6 id="1-1-2-2-编写配置文件"><a href="#1-1-2-2-编写配置文件" class="headerlink" title="1.1.2.2 编写配置文件"></a>1.1.2.2 <strong>编写配置文件</strong></h6><p>​	和Publisher一样</p>
<h6 id="1-1-2-3-编写监听器方法"><a href="#1-1-2-3-编写监听器方法" class="headerlink" title="1.1.2.3 编写监听器方法"></a>1.1.2.3 <strong>编写监听器方法</strong></h6><p>​	注意：</p>
<p>​	类上要有@Componet，项目启动时此类生效。</p>
<p>​	@RabbitListener 监听指定队列。</p>
<pre><code>@Component
public class DemoReceive &#123;

    @RabbitListener(queues = &quot;myqueue&quot;)
    public void demo(String msg)&#123;
        System.out.println(&quot;获取到的消息1111：&quot;+msg);
    &#125;

    @RabbitListener(queues = &quot;myqueue&quot;)
    public void demo2(String msg)&#123;
        System.out.println(&quot;获取到的消息2222：&quot;+msg);
    &#125;
&#125;
</code></pre>
<h6 id="1-1-2-4-新建启动类"><a href="#1-1-2-4-新建启动类" class="headerlink" title="1.1.2.4 新建启动类"></a>1.1.2.4 <strong>新建启动类</strong></h6><p>​	略。启动后此项目一直处于运行状态。属于长连接。</p>
<h4 id="2-fanout交换器"><a href="#2-fanout交换器" class="headerlink" title="2 fanout交换器"></a>2 <strong>fanout交换器</strong></h4><p>​	扇形交换器，实际上做的事情就是广播，fanout会把消息发送给所有的绑定在当前交换器上的队列。且每个队列消息中第一个Consumer能收到消息。</p>
<p>​	（代码演示）一个交换器需要绑定多个队列</p>
<p>​	需要使用注解&#x2F;API：</p>
<p>​	FanoutExchange：fanout交换器</p>
<p>​	Binding：绑定交换器和队列</p>
<p>​	BindingBuilder：Binding的构建器</p>
<p>​	amq.fanout:内置fanout交换器名称</p>
<h4 id="2-1-代码"><a href="#2-1-代码" class="headerlink" title="2.1 代码"></a>2.1 <strong>代码</strong></h4><h5 id="2-1-1-Publisher"><a href="#2-1-1-Publisher" class="headerlink" title="2.1.1 Publisher"></a>2.1.1 <strong>Publisher</strong></h5><h6 id="2-1-1-1-修改配置类"><a href="#2-1-1-1-修改配置类" class="headerlink" title="2.1.1.1 修改配置类"></a>2.1.1.1 <strong>修改配置类</strong></h6><pre><code>@Bean
protected Queue fanoutQuque1()&#123;
    return new Queue(&quot;fanout1&quot;);
&#125;

@Bean
protected Queue fanoutQuque2()&#123;
    return new Queue(&quot;fanout2&quot;);
&#125;

@Bean
protected FanoutExchange fanoutExchange()&#123;
    return new FanoutExchange(&quot;amq.fanout&quot;);
&#125;

@Bean
protected Binding fanoutBinding(Queue fanoutQuque1,FanoutExchange fanoutExchange)&#123;
    return BindingBuilder.bind(fanoutQuque1).to(fanoutExchange);
&#125;

@Bean
protected Binding fanoutBinding2(Queue fanoutQuque2,FanoutExchange fanoutExchange)&#123;
    return BindingBuilder.bind(fanoutQuque2).to(fanoutExchange);
&#125;
</code></pre>
<h5 id="2-1-2-编写发送方法"><a href="#2-1-2-编写发送方法" class="headerlink" title="2.1.2 编写发送方法****"></a>2.1.2 <strong>编写发送方法</strong>****</h5><p>​	第二个参数routingKey对于fanout没有意义的</p>
<pre><code>@Test
public void test2()&#123;
    amqpTemplate.convertAndSend(&quot;amq.fanout&quot;,&quot;asdfadsf&quot;,&quot;fanout msg&quot;);
    System.out.println(&quot;发送成功&quot;);
&#125;
</code></pre>
<h5 id="2-1-3-Consumer"><a href="#2-1-3-Consumer" class="headerlink" title="2.1.3 Consumer"></a>2.1.3 <strong>Consumer</strong></h5><p>​	Consumer代码和Direct完全相同。一个队列给一个监听方法即可。</p>
<h4 id="3-topic交换器"><a href="#3-topic交换器" class="headerlink" title="3 topic交换器"></a>3 <strong>topic交换器</strong></h4><p>​	允许在路由键（RoutingKey）中出现匹配规则。</p>
<p>​	路由键的写法和包写法相同。com.msb.xxxx.xxx格式。</p>
<p>​	在绑定时可以带有下面特殊符号，中间可以出现:</p>
<p>​	* : 代表一个单词（两个.之间内容）</p>
<p>​	# : 0个或多个字符</p>
<p>​	接收方依然是公平调度，同一个队列中内容轮换获取值。</p>
<p>​	需要使用注解&#x2F;API：</p>
<p>​	TopicExchange：Topic交换器</p>
<p>​	amq.topic:内置topic交换器名称</p>
<h4 id="3-1-代码"><a href="#3-1-代码" class="headerlink" title="3.1 代码"></a>3.1 <strong>代码</strong></h4><h5 id="3-1-1-Publisher"><a href="#3-1-1-Publisher" class="headerlink" title="3.1.1 Publisher"></a>3.1.1 <strong>Publisher</strong></h5><h6 id="3-1-1-1-配置类。"><a href="#3-1-1-1-配置类。" class="headerlink" title="3.1.1.1 配置类。"></a>3.1.1.1 <strong>配置类。</strong></h6><p>​	之所以建立两个队列目的是为了演示使用Topic完成Fanout效果。</p>
<pre><code>@Bean
protected Queue topicQueue() &#123;
    return new Queue(&quot;topic1&quot;);
&#125;

@Bean
protected Queue topicQueue2() &#123;
    return new Queue(&quot;topic2&quot;);
&#125;

@Bean
protected TopicExchange topicExchange() &#123;
    return new TopicExchange(&quot;amq.topic&quot;);
&#125;

@Bean
protected Binding topicBinding(Queue topicQueue, TopicExchange topicExchange) &#123;
    return BindingBuilder.bind(topicQueue).to(topicExchange).with(&quot;com.a&quot;);
&#125;

@Bean
protected Binding topicBinding2(Queue topicQueue2, TopicExchange topicExchange) &#123;
    return BindingBuilder.bind(topicQueue2).to(topicExchange).with(&quot;com.#&quot;);
&#125;
</code></pre>
<h6 id="3-1-1-2-发送消息"><a href="#3-1-1-2-发送消息" class="headerlink" title="3.1.1.2 发送消息"></a>3.1.1.2 <strong>发送消息</strong></h6><p>​	第二个参数为路由键，匹配配置类中绑定时的路由规则。</p>
<pre><code>@Test
public void test3()&#123;
    amqpTemplate.convertAndSend(&quot;amq.topic&quot;,&quot;com.bjsxt.a.b&quot;,&quot;topic msg&quot;);
    System.out.println(&quot;发送成功&quot;);
&#125;
</code></pre>
<p> 3.1.2 <strong>Consumer</strong></p>
<p>​	Consumer代码与以前一样，注意队列名称topic1,topic2不要写路由键名称。( queues取值)</p>
<pre><code>@RabbitListener(queues = &quot;topic2&quot;)
public void demo10(String msg)&#123;
    System.out.println(&quot;topic2-2:&quot;+msg);
&#125;
</code></pre>
<h3 id="八、-传递对象类型参数"><a href="#八、-传递对象类型参数" class="headerlink" title="八、 传递对象类型参数"></a>八、 <strong>传递对象类型参数</strong></h3><p>​	如果消息是对象类型，此对象的类型必须进行序列化，且需要给定序列化值</p>
<pre><code>public class People implements Serializable 
&#123;
    public static final long serialVersionUID=1L;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>分布式</category>
        <category>RabbitMQ</category>
      </categories>
      <tags>
        <tag>分布式</tag>
        <tag>中间件</tag>
        <tag>RabbitMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>Solr</title>
    <url>/2022/10/07/Distribution/Solr/</url>
    <content><![CDATA[<h1 id="Solr"><a href="#Solr" class="headerlink" title="Solr"></a>Solr</h1><h3 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h3><ol>
<li><p>Solr简介</p>
</li>
<li><p>Solr搜索原理</p>
</li>
<li><p>Solr单机版安装</p>
</li>
<li><p>可视化管理界面</p>
</li>
<li><p>新建核心</p>
</li>
<li><p>分词</p>
</li>
<li><p>Dataimport</p>
</li>
<li><p>使用SolrJ操作Solr</p>
</li>
<li><p>Spring Data for Apache Solr</p>
<ol start="10">
<li>SolrCloud</li>
</ol>
</li>
</ol>
<h3 id="学习目标"><a href="#学习目标" class="headerlink" title="学习目标"></a>学习目标</h3><table>
<thead>
<tr>
<th>知识点</th>
<th>要求</th>
</tr>
</thead>
<tbody><tr>
<td>Solr简介</td>
<td>掌握</td>
</tr>
<tr>
<td>Solr搜索原理</td>
<td>掌握</td>
</tr>
<tr>
<td>Solr单机版安装</td>
<td>掌握</td>
</tr>
<tr>
<td>可视化管理界面</td>
<td>掌握</td>
</tr>
<tr>
<td>新建核心</td>
<td>掌握</td>
</tr>
<tr>
<td>分词</td>
<td>掌握</td>
</tr>
<tr>
<td>Dataimport</td>
<td>掌握</td>
</tr>
<tr>
<td>使用SolrJ操作Solr</td>
<td>掌握</td>
</tr>
<tr>
<td>SolrCloud</td>
<td>掌握</td>
</tr>
<tr>
<td>Spring Data for Apache Solr</td>
<td>掌握</td>
</tr>
</tbody></table>
<h3 id="一、Solr简介"><a href="#一、Solr简介" class="headerlink" title="一、Solr简介"></a>一、Solr简介</h3><h4 id="1-为什么使用Solr"><a href="#1-为什么使用Solr" class="headerlink" title="1.为什么使用Solr"></a>1.为什么使用Solr</h4><p>​	在海量数据下，对MySQL或Oracle进行模糊查询或条件查询的效率是很低的。而搜索功能在绝大多数项目中都是必须的，如何提升搜索效率是很多互联网项目必须要考虑的问题。</p>
<p>​	既然使用关系型数据库进行搜索效率比较低，最直接的解决方案就是使用专用搜索工具进行搜索，从而提升搜索效率。</p>
<h4 id="2-常见搜索解决方案"><a href="#2-常见搜索解决方案" class="headerlink" title="2.常见搜索解决方案"></a>2.常见搜索解决方案</h4><p>​	基于Apache Lucene（全文检索工具库）实现搜索。但是Lucene的使用对于绝大多数的程序员都是“噩梦级”的。</p>
<p>​	基于谷歌API实现搜索。</p>
<p>​	基于百度API实现搜索。</p>
<h4 id="3-Solr简介"><a href="#3-Solr简介" class="headerlink" title="3.Solr简介"></a>3.Solr简介</h4><p>​	Solr是基于Apache Lucene构建的用于搜索和分析的开源解决方案。可提供可扩展索引、搜索功能、高亮显示和文字解析功能。</p>
<p>​	Solr本质就是一个Java web 项目，且内嵌了Jetty服务器，所以安装起来非常方便。客户端操作Solr的过程和平时我们所写项目一样，就是请求Solr中控制器，处理完数据后把结果响应给客户端。</p>
<h4 id="4-正向索引和反向索引"><a href="#4-正向索引和反向索引" class="headerlink" title="4.正向索引和反向索引"></a>4.正向索引和反向索引</h4><p>​	只要讨论搜索就不得不提的两个概念：正向索引（forward index）和反向索引(inverted index)。</p>
<p>​	正向索引：从文档内容到词组的过程。每次搜索的实收需要搜索所有文档，每个文档比较搜索条件和词组。</p>
<table>
<thead>
<tr>
<th>文档</th>
<th>词组</th>
</tr>
</thead>
<tbody><tr>
<td>I am a chinese</td>
<td>I,am,a,chinese</td>
</tr>
</tbody></table>
<p>​	反向索引：是正向索引的逆向。建立词组和文档的映射关系。通过找到词组就能找到文档内容。（和新华字典找字很像）</p>
<table>
<thead>
<tr>
<th>词组</th>
<th>文档</th>
</tr>
</thead>
<tbody><tr>
<td>I,am,a,chinese</td>
<td>I am a chinese</td>
</tr>
</tbody></table>
<h3 id="二、Solr搜索原理"><a href="#二、Solr搜索原理" class="headerlink" title="二、Solr搜索原理"></a>二、Solr搜索原理</h3><h4 id="1-搜索原理"><a href="#1-搜索原理" class="headerlink" title="1.搜索原理"></a>1.搜索原理</h4><p>​	Solr能够提升检索效率的主要原因就是分词和索引（反向索引，通过）。</p>
<p>​	分词：会对搜索条件&#x2F;存储内容进行分词，分成日常所使用的词语。</p>
<p>​	索引：存储在Solr中内容会按照程序员的要求来是否建立索引。如果要求建立索引会把存储内容中关键字（分词）建立索引。</p>
<img data-src="/2022/10/07/Distribution/Solr/solr-01.JPG" class="">

<h4 id="2-Solr中数据存储说明"><a href="#2-Solr中数据存储说明" class="headerlink" title="2.Solr中数据存储说明"></a>2.Solr中数据存储说明</h4><p>​	Solr为了给内容建立索引，所以Solr就必须具备数据存储能力。所有需要被搜索的内容都需要存储在Solr中，在开发中需要把数据库中数据添加到Solr中进行初始化，每次修改数据库中数据还需要同步Solr中的数据。</p>
<p>​	Solr中数据存储是存储在Document对象中，对象中可以包含的属性和属性类型都定义在scheme.xml中。如果需要自定义属性或自定义属性类型都需要修改scheme.xml配置文件。从Solr5开始schema.xml更改名称为managed-scheme(没有扩展名)</p>
<h3 id="三、Solr单机版安装"><a href="#三、Solr单机版安装" class="headerlink" title="三、Solr单机版安装"></a>三、Solr单机版安装</h3><p>​	Solr是使用Java编写，所以必选先安装JDK。</p>
<h4 id="1-上传并解压"><a href="#1-上传并解压" class="headerlink" title="1.上传并解压"></a>1.上传并解压</h4><p>​	上传压缩包solr-7.7.2.tgz到&#x2F;usr&#x2F;local&#x2F;tmp中。</p>
<p>解压</p>
<pre><code># cd /usr/local/tmp
# tar zxf solr-7.7.2.tgz
</code></pre>
<h4 id="2-复制到-x2F-usr-x2F-local中"><a href="#2-复制到-x2F-usr-x2F-local中" class="headerlink" title="2.复制到&#x2F;usr&#x2F;local中"></a>2.复制到&#x2F;usr&#x2F;local中</h4><pre><code># cp -r solr-7.7.2 ../solr
</code></pre>
<h4 id="3-修改启动参数"><a href="#3-修改启动参数" class="headerlink" title="3.修改启动参数"></a>3.修改启动参数</h4><p>​	修改启动参数，否则启动时报警告。提示设置SOLR_ULIMIT_CHECKS&#x3D;false</p>
<pre><code># cd /usr/local/solr/bin
# vim solr.in.sh
</code></pre>
<img data-src="/2022/10/07/Distribution/Solr/solr-02.jpg" class="">

<h4 id="4-启动Solr"><a href="#4-启动Solr" class="headerlink" title="4.启动Solr"></a>4.启动Solr</h4><p>​	Solr内嵌Jetty，直接启动即可。监听8983端口。</p>
<p>​	solr默认不推荐root账户启动，如果是root账户启动需要添加-force参数。</p>
<pre><code># ./solr start -force
</code></pre>
<h3 id="四、可视化管理界面"><a href="#四、可视化管理界面" class="headerlink" title="四、可视化管理界面"></a>四、可视化管理界面</h3><p>​	在关闭防火墙的前提下，可以在windows的浏览器中访问Solr。</p>
<p>​	输入: <span class="exturl" data-url="aHR0cDovLzE5Mi4xNjguOTMuMTA6ODk4My8=">http://192.168.93.10:8983</span> 就可以访问Solr的可视化管理界面。</p>
<p>​	左侧有5个菜单。分别是：</p>
<p>​	（1）Dashboard：面板显示Solr的总体信息。</p>
<p>​	（2）Logging：日志</p>
<p>​	（3）Core Admin：Solr的核心。类似于数据的Database</p>
<p>​	（4）Java Perperties：所有Java相关属性。</p>
<p>​	（5）Thread Dump：线程相关信息。</p>
<p>​	（6）如果有Core，将显示在此处。</p>
<img data-src="/2022/10/07/Distribution/Solr/solr-03.JPG" class="">

<h3 id="五、新建核心"><a href="#五、新建核心" class="headerlink" title="五、新建核心"></a>五、新建核心</h3><p>​	Solr安装完成后默认是没有核心的。需要手动配置。</p>
<p>​	需要在solr&#x2F;server&#x2F;solr下新建文件夹，并给定配置文件，否则无法建立。</p>
<img data-src="/2022/10/07/Distribution/Solr/solr-04.JPG" class="">

<h4 id="1-新建目录"><a href="#1-新建目录" class="headerlink" title="1.新建目录"></a>1.新建目录</h4><p>​	在&#x2F;usr&#x2F;local&#x2F;solr&#x2F;server&#x2F;solr中新建自定义名称目录。此处示例名称为testcore。</p>
<pre><code># cd /usr/local/solr/server/solr
# mkdir testcore
</code></pre>
<h4 id="2-复制配置文件"><a href="#2-复制配置文件" class="headerlink" title="2.复制配置文件"></a>2.复制配置文件</h4><p>​	在configsets里面包含了_default和sample_techproducts_configs。里面都是配置文件示例。_default属于默认配置，较纯净。sample_techproducts_configs是带有了一些配置示例。</p>
<pre><code># cp -r configsets/_default/conf/ testcore/
</code></pre>
<h4 id="3-填写Core信息"><a href="#3-填写Core信息" class="headerlink" title="3.填写Core信息"></a>3.填写Core信息</h4><p>​	在可视化管理界面中Core Admin中编写信息后点击Add Core后，短暂延迟后testcore就会创建成功。schema处不用更改。</p>
<img data-src="/2022/10/07/Distribution/Solr/solr-05.JPG" class="">

<h4 id="4-出现testcore"><a href="#4-出现testcore" class="headerlink" title="4.出现testcore"></a>4.出现testcore</h4><p>​	在客户端管理界面中，选择新建的Core后，就可以按照自己项目的需求进行操作了。</p>
<img data-src="/2022/10/07/Distribution/Solr/solr-06.jpg" class="">

<h3 id="六、分词Analysis"><a href="#六、分词Analysis" class="headerlink" title="六、分词Analysis"></a>六、分词Analysis</h3><p>​	在Solr可视化管理界面中，Core的管理菜单项中都会有Analysis。表示根据Scheme.xml(managed-schema)中配置要求进行解析。</p>
<p>​	对英文解析就比较简单了，只要按照空格把英文语句拆分成英文单词即可。</p>
<img data-src="/2022/10/07/Distribution/Solr/solr-07.jpg" class="">

<p>​	但是如果条件是中文时，把一句话按照字进行拆分就不是很合理了。正确的方式是按照合理的词组进行拆分。<img data-src="/2022/10/07/Distribution/Solr/solr-08.jpg" class=""></p>
<h4 id="1-配置步骤"><a href="#1-配置步骤" class="headerlink" title="1.配置步骤"></a>1.配置步骤</h4><p>​	上传ik-analyzer.jar到webapps中。</p>
<p>​	去<span class="exturl" data-url="aHR0cHM6Ly9zZWFyY2gubWF2ZW4ub3JnL3NlYXJjaD9xPWNvbS5naXRodWIubWFnZXNlJUU0JUI4JThCJUU4JUJEJUJEJUU1JUFGJUI5JUU1JUJBJTk0JUU3JTg5JTg4JUU2JTlDJUFDJUU3JTlBJTg0aWstYW5hbHl6ZXIlRTMlODAlODIlRTUlOEYlQUYlRTQlQkIlQTUlRTUlOUMlQTglRTglQjUlODQlRTYlOTYlOTklRTQlQjglQUQlRTclOUIlQjQlRTYlOEUlQTUlRTglOEUlQjclRTUlOEYlOTYlRTMlODAlODI=">https://search.maven.org/search?q=com.github.magese下载对应版本的ik-analyzer。可以在资料中直接获取。</span></p>
<h5 id="1-1上传jar到指定目录"><a href="#1-1上传jar到指定目录" class="headerlink" title="1.1上传jar到指定目录"></a>1.1上传jar到指定目录</h5><p>​	上传ik-analyzer-7.7.0.jar到</p>
<p>​	&#x2F;usr&#x2F;local&#x2F;solr&#x2F;server&#x2F;solr-webapp&#x2F;webapp&#x2F;WEB-INF&#x2F;lib目录中</p>
<h5 id="1-2修改配置文件"><a href="#1-2修改配置文件" class="headerlink" title="1.2修改配置文件"></a>1.2修改配置文件</h5><p>​	修改&#x2F;usr&#x2F;local&#x2F;solr&#x2F;server&#x2F;solr&#x2F;testcore&#x2F;conf&#x2F;managed-schema</p>
<pre><code class="sh">vim /usr/local/solr/server/solr/testcore/conf/managed-schema
</code></pre>
<p>​	添加下面内容。</p>
<p>​	排版：Esc 退出编辑状态下：gg&#x3D;G</p>
<pre><code>&lt;field name=&quot;myfield&quot; type=&quot;text_ik&quot; indexed=&quot;true&quot; stored=&quot;true&quot; /&gt;
    &lt;fieldType name=&quot;text_ik&quot; class=&quot;solr.TextField&quot;&gt;
            &lt;analyzer type=&quot;index&quot;&gt;
                    &lt;tokenizer class=&quot;org.wltea.analyzer.lucene.IKTokenizerFactory&quot; useSmart=&quot;false&quot; conf=&quot;ik.conf&quot;/&gt;
                    &lt;filter class=&quot;solr.LowerCaseFilterFactory&quot;/&gt;
            &lt;/analyzer&gt;
            &lt;analyzer type=&quot;query&quot;&gt;
                    &lt;tokenizer class=&quot;org.wltea.analyzer.lucene.IKTokenizerFactory&quot; useSmart=&quot;true&quot; conf=&quot;ik.conf&quot;/&gt;
                    &lt;filter class=&quot;solr.LowerCaseFilterFactory&quot;/&gt;
            &lt;/analyzer&gt;
    &lt;/fieldType&gt;
</code></pre>
<h5 id="1-3重启"><a href="#1-3重启" class="headerlink" title="1.3重启"></a>1.3重启</h5><pre><code># cd /usr/local/solr/bin
# ./solr stop -all
# ./solr start -force
</code></pre>
<h5 id="1-4验证"><a href="#1-4验证" class="headerlink" title="1.4验证"></a>1.4验证</h5><p>​	可以在可视化管理界面中找到myfield属性进行验证。</p>
<img data-src="/2022/10/07/Distribution/Solr/solr-09.jpg" class="">

<h4 id="2-managed-schema配置说明"><a href="#2-managed-schema配置说明" class="headerlink" title="2.managed-schema配置说明"></a>2.managed-schema配置说明</h4><h5 id="2-1-lt-fieldType-x2F-gt"><a href="#2-1-lt-fieldType-x2F-gt" class="headerlink" title="2.1&lt; fieldType&#x2F;&gt;"></a>2.1&lt; fieldType&#x2F;&gt;</h5><p>​	表示定义一个属性类型。在Solr中属性类型都是自定义的。在上面配置中name&#x3D;”text_ik”为自定义类型。当某个属性取值为text_ik时IK Analyzer才能生效。</p>
<h5 id="2-2-lt-field-x2F-gt"><a href="#2-2-lt-field-x2F-gt" class="headerlink" title="2.2&lt; field&#x2F;&gt;"></a>2.2&lt; field&#x2F;&gt;</h5><p>​	表示向Document中添加一个属性。</p>
<p>​	常用属性：</p>
<p>​		name: 属性名</p>
<p>​		type:属性类型。所有类型都是solr使用<fieldType>配置的</p>
<p>​		indexed: 是否建立索引</p>
<p>​		stored: solr是否把该属性值响应给搜索用户。</p>
<p>​		required：该属性是否是必须的。默认id是必须的。</p>
<p>​		multiValued：如果为true，表示该属性为复合属性，此属性中包含了多个其他的属性。常用在多个列作为搜索条件时，把这些列定义定义成一个新的复合属性，通过搜索一个复合属性就可以实现搜索多个列。当设置为true时与&lt; copyField source&#x3D;”” dest&#x3D;””&#x2F;&gt;结合使用</p>
<h5 id="2-3-lt-uniqueKey-gt"><a href="#2-3-lt-uniqueKey-gt" class="headerlink" title="2.3&lt; uniqueKey&gt;"></a>2.3&lt; uniqueKey&gt;</h5><p>​	唯一主键，Solr中默认定义id属性为唯一主键。ID的值是不允许重复的。</p>
<h5 id="2-4-lt-dynamicField-gt"><a href="#2-4-lt-dynamicField-gt" class="headerlink" title="2.4&lt; dynamicField&gt;"></a>2.4&lt; dynamicField&gt;</h5><p>​	名称中允许*进行通配。代表满足特定名称要求的一组属性。</p>
<pre><code> msb_java    
</code></pre>
<p>​	msb_bigdata</p>
<p>​	msb_UI</p>
<p>​        msb_*</p>
<h3 id="七、Dataimport"><a href="#七、Dataimport" class="headerlink" title="七、Dataimport"></a>七、Dataimport</h3><p>​	可以使用Solr自带的Dataimport功能把数据库中数据快速导入到solr中.</p>
<p>​	<strong>必须保证managed-schema和数据库中表的列对应。，添加配置</strong></p>
<h4 id="1-修改配置文件"><a href="#1-修改配置文件" class="headerlink" title="1.修改配置文件"></a>1.修改配置文件</h4><p>​	修改solrconfig.xml，添加下面内容</p>
<pre><code> &lt;!-- 配置数据导入的处理器 --&gt;
  &lt;requestHandler name=&quot;/dataimport&quot; class=&quot;org.apache.solr.handler.dataimport.DataImportHandler&quot;&gt;
    &lt;lst name=&quot;defaults&quot;&gt;
      &lt;!--  加载data-config.xml  --&gt;
      &lt;str name=&quot;config&quot;&gt;data-config.xml&lt;/str&gt;
     &lt;/lst&gt;
  &lt;/requestHandler&gt;
</code></pre>
<h4 id="2-新建data-config-xml"><a href="#2-新建data-config-xml" class="headerlink" title="2.新建data-config.xml"></a>2.新建data-config.xml</h4><p>​	和solrconfig.xml同一目录下新建data-config.xml</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;dataConfig&gt;
        &lt;dataSource type=&quot;JdbcDataSource&quot;   
                driver=&quot;com.mysql.jdbc.Driver&quot;   
                url=&quot;jdbc:mysql://192.168.1.135:3306/mytest&quot;   
                user=&quot;root&quot;   
                password=&quot;root&quot;/&gt;
        &lt;document&gt;
            &lt;entity name=&quot;product&quot; query=&quot;SELECT id,name,price from t_product&quot;&gt;
                &lt;!-- 
                 实现数据库的列和索引库的字段的映射
                 column 指定数据库的列表
                 name  指定索引库的字段名字，必须和schema.xml中定义的一样
                 --&gt;
                 &lt;field column=&quot;id&quot; name=&quot;id&quot;/&gt;
                 &lt;field column=&quot;name&quot; name=&quot;name&quot;/&gt;
                 &lt;field column=&quot;price&quot; name=&quot;price&quot;/&gt;
            &lt;/entity&gt;
         &lt;/document&gt;
&lt;/dataConfig&gt;
</code></pre>
<h4 id="3-添加jar"><a href="#3-添加jar" class="headerlink" title="3.添加jar"></a>3.添加jar</h4><p>​	向solr-webapp中添加三个jar。在dist中两个还有一个数据库驱动。</p>
<img data-src="/2022/10/07/Distribution/Solr/solr-10.jpg" class="">

<h4 id="4-操作"><a href="#4-操作" class="headerlink" title="4.操作"></a>4.操作</h4><p>​	重启solr后，在可视化管理页面中进行数据导入。</p>
<p>​	注意：</p>
<p>​	点击导入按钮后，要记得点击刷新按钮。</p>
<h3 id="八、菜单项目Documents使用办法"><a href="#八、菜单项目Documents使用办法" class="headerlink" title="八、菜单项目Documents使用办法"></a>八、菜单项目Documents使用办法</h3><p>​	以XML格式举例</p>
<h4 id="1-新增-x2F-修改"><a href="#1-新增-x2F-修改" class="headerlink" title="1.新增&#x2F;修改"></a>1.新增&#x2F;修改</h4><p>​	当id不存在时新增，当id存在修改。</p>
<pre><code>&lt;doc&gt;
&lt;field name=&quot;id&quot;&gt;8&lt;/field&gt;
&lt;field name=&quot;name&quot;&gt;明天更大卖&lt;/field&gt;
&lt;field name=&quot;price&quot;&gt;98&lt;/field&gt;
&lt;/doc&gt;
</code></pre>
<h4 id="2-删除"><a href="#2-删除" class="headerlink" title="2.删除"></a>2.删除</h4><h5 id="2-1根据主键删除"><a href="#2-1根据主键删除" class="headerlink" title="2.1根据主键删除"></a>2.1根据主键删除</h5><pre><code>&lt;delete&gt;
    &lt;id&gt;8&lt;/id&gt;
&lt;/delete&gt;
&lt;commit/&gt;
</code></pre>
<h5 id="2-2根据条件删除"><a href="#2-2根据条件删除" class="headerlink" title="2.2根据条件删除"></a>2.2根据条件删除</h5><pre><code>&lt;delete&gt;
    &lt;query&gt;*:*&lt;/query&gt;
&lt;/delete&gt;
</code></pre>
<h4 id="3-solr可视化界面使用（QUERY）"><a href="#3-solr可视化界面使用（QUERY）" class="headerlink" title="3.solr可视化界面使用（QUERY）"></a>3.solr可视化界面使用（QUERY）</h4><p><img data-src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\1645693120964.png" alt="1645693120964"></p>
<p>参数：</p>
<p>​	<strong>q：</strong>query，等于。格式  ——&gt; parameter&#x2F;columns : value	<strong>具有分词时，相当于模糊查询–like</strong></p>
<p>​	<strong>fq：</strong>【在 q 的情况下再加条件】（要有分词功能）注意这里的keyword是用来检索的字段，他包含name、address、gender、expert_skill，这几个属性，所以我搜索“海”能够查询出来有海字的记录。</p>
<p>​	<strong>sort：</strong>排序 。 parameter&#x2F;columns    desc逆序&#x2F;asc</p>
<p>​	<strong>start,rows：</strong>从查询结果的start开始，显示到rows结束【下标】</p>
<p>​	<strong>fl：</strong>想显示的属性。</p>
<p>​	<strong>df：</strong>不想显示的属性。</p>
<p>​	<strong>wt：</strong>返回值类型</p>
<p>​	<strong>hl：</strong>高亮</p>
<pre><code>    *  hl.fl						 value
    *  hl.simple.pre        &lt;font color=&#39;red&#39;&gt;
    *  hl.simple.post     &lt;/font&gt;
</code></pre>
<p>​	</p>
<h3 id="九、使用SolrJ操作Solr"><a href="#九、使用SolrJ操作Solr" class="headerlink" title="九、使用SolrJ操作Solr"></a>九、使用SolrJ操作Solr</h3><p>​	SolrJ是Solr提供的Java客户端API。通过SolrJ可以实现Java程序对Solr中数据的操作。</p>
<p>​	大前提：添加SolrJ依赖。依赖版本和Solr版本严格对应</p>
<pre><code>&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.apache.solr&lt;/groupId&gt;
            &lt;artifactId&gt;solr-solrj&lt;/artifactId&gt;
        &lt;version&gt;7.7.2&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
<h4 id="1-新增-x2F-修改实现"><a href="#1-新增-x2F-修改实现" class="headerlink" title="1.新增&#x2F;修改实现"></a>1.新增&#x2F;修改实现</h4><pre><code>String url = &quot;http://192.168.93.10:8983/solr/testcore&quot;;
HttpSolrClient solrClient =  new HttpSolrClient.Builder(url).build();
SolrInputDocument inputDocument = new SolrInputDocument();
inputDocument.addField(&quot;id&quot;,&quot;3&quot;);
inputDocument.addField(&quot;myfield&quot;,&quot;myfield3&quot;);
solrClient.add(inputDocument);
solrClient.commit();
</code></pre>
<ul>
<li>使用solrj进行索引的添加<ul>
<li><ul>
<li><strong>每个索引的添加必须要ID</strong><ul>
<li><strong>添加key值要和schema.xml文件内的field域保持一致</strong></li>
<li><strong>添加数据后一定要提交数据，不然是不存在数据的</strong></li>
<li><strong>连接Solr的对象需要连接到项目名</strong></li>
<li><strong>每个document是一组Json数据对象</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="2-删除实现"><a href="#2-删除实现" class="headerlink" title="2.删除实现"></a>2.删除实现</h4><pre><code>String url = &quot;http://192.168.93.10:8983/solr/testcore&quot;;
HttpSolrClient solrClient =  new HttpSolrClient.Builder(url).build();
solrClient.deleteById(&quot;3&quot;);
solrClient.commit();
</code></pre>
<ul>
<li><strong>删除</strong></li>
<li>删除支持两种删除方式<ul>
<li><ul>
<li><strong>1.根据ID</strong><ul>
<li>2.执行查询删除<ul>
<li><ul>
<li><strong>查询删除的格式：查询的域:值</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="3-查询实现"><a href="#3-查询实现" class="headerlink" title="3.查询实现"></a>3.查询实现</h4><pre><code>public void testQuery()&#123;
    try &#123;
        String url = &quot;http://192.168.93.10:8983/solr/testcore&quot;;
        HttpSolrClient solrClient = new HttpSolrClient.Builder(url).build();

        //封装了所有查询条件
        SolrQuery params = new SolrQuery();
        params.setQuery(&quot;name:丰富的&quot;);
        //排序
        params.setSort(&quot;price&quot;, SolrQuery.ORDER.desc);
        //分页
        params.setStart(0);
 params.setRows(1);
        //高亮
        params.setHighlight(true);
        params.addHighlightField(&quot;name&quot;);
        params.setHighlightSimplePre(&quot;&lt;span&gt;&quot;);
        params.setHighlightSimplePost(&quot;&lt;/span&gt;&quot;);

        QueryResponse response = solrClient.query(params);
        SolrDocumentList list = response.getResults();
        System.out.println(&quot;总条数：&quot;+list.getNumFound());

        //高亮数据
        Map&lt;String, Map&lt;String, List&lt;String&gt;&gt;&gt; highlighting = response.getHighlighting();

        for(SolrDocument doc :list)&#123;
            System.out.println(doc.get(&quot;id&quot;));
            Map&lt;String, List&lt;String&gt;&gt; map = highlighting.get(doc.get(&quot;id&quot;));
            List&lt;String&gt; HLList = map.get(&quot;name&quot;);
            if(HLList!=null&amp;&amp;HLList.size()&gt;0)&#123;//显示高亮数据
                System.out.println(HLList.get(0));
            &#125;else&#123;
                System.out.println(doc.get(&quot;name&quot;));
            &#125;
            System.out.println(doc.get(&quot;price&quot;));
            System.out.println(&quot;===================&quot;);
        &#125;
        solrClient.close();
    &#125; catch (SolrServerException e) &#123;
        e.printStackTrace();
    &#125; catch (IOException e) &#123;
        e.printStackTrace();
    &#125;
&#125;
</code></pre>
<p><strong>使用到的对象</strong></p>
<ul>
<li>1.SolrQuery查询对象<ul>
<li>1.setQuery()：设置查询的关键字<br>  2.set（）:设置查询的域<br>  3.setStart():设置开始<br>  4.setRows（）：设置结束</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><p>2.QueryResponse：响应结果集</p>
<ul>
<li>1.getNumFound():返回查询到的数量<br>  2.getResults（）；返回封装的list集合</li>
</ul>
</li>
<li><p>3.SolrDocumentList：结果集合</p>
<ul>
<li>1.get():获取指定域的值</li>
</ul>
</li>
</ul>
<h3 id="十、Spring-Data-for-Apache-Solr"><a href="#十、Spring-Data-for-Apache-Solr" class="headerlink" title="十、Spring Data for Apache Solr"></a>十、Spring Data for Apache Solr</h3><h4 id="1-Spring-Data简介"><a href="#1-Spring-Data简介" class="headerlink" title="1.Spring Data简介"></a>1.Spring Data简介</h4><p>​	Spring Data 是Spring的顶级项目。里面包含了N多个二级子项目，每个子项目对应一种技术或工具。其目的为了让数据访问更加简单，更加方便的和Spring进行整合。</p>
<p>​	Spring Data 项目如果单独使用是还需要配置XML配置文件的，当和Spring Boot整合后使用起来非常方便。spring-boot-starter-data-xx就是对应的启动器。</p>
<h4 id="2-实现步骤"><a href="#2-实现步骤" class="headerlink" title="2.实现步骤"></a>2.实现步骤</h4><h5 id="2-1添加依赖"><a href="#2-1添加依赖" class="headerlink" title="2.1添加依赖"></a>2.1添加依赖</h5><pre><code> &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-data-solr&lt;/artifactId&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
</code></pre>
<h5 id="2-2编写配置文件"><a href="#2-2编写配置文件" class="headerlink" title="2.2编写配置文件"></a>2.2编写配置文件</h5><pre><code>spring:
  data:
    solr:
      host: http://192.168.9.132:8080/solr
      # zk-host: 192.168.9.132:2181,192.168.9.132:2182,192.168.9.132:2183
</code></pre>
<h5 id="2-3编写测试类"><a href="#2-3编写测试类" class="headerlink" title="2.3编写测试类"></a>2.3编写测试类</h5><pre><code>@RunWith(SpringJUnit4ClassRunner.class)
@SpringBootTest(classes = MyApplication.class)
public class MyTest &#123;
    @Autowired
    private SolrTemplate solrTemplate;

    public void testInsert()&#123;
        SolrInputDocument doc = new SolrInputDocument();
        doc.setField(&quot;id&quot;,&quot;002&quot;);
        doc.setField(&quot;item_title&quot;,&quot;这是一个手机3&quot;);
        UpdateResponse ur = solrTemplate.saveBean(&quot;collection1&quot;, doc);
        if(ur.getStatus()==0)&#123;
            System.out.println(&quot;成功&quot;);
        &#125;else&#123;
            System.out.println(&quot;失败&quot;);
        &#125;
        solrTemplate.commit(&quot;collection1&quot;);
    &#125;

    public void testDelete()&#123;
        UpdateResponse ur = solrTemplate.deleteByIds(&quot;collection1&quot;, &quot;change.me&quot;);
        if(ur.getStatus()==0)&#123;
            System.out.println(&quot;成功&quot;);
        &#125;else&#123;
            System.out.println(&quot;失败&quot;);
        &#125;
        solrTemplate.commit(&quot;collection1&quot;);
    &#125;


    public void query()&#123;
        SimpleQuery query = new SimpleQuery();
        Criteria c = new Criteria(&quot;item_keywords&quot;);
        c.is(&quot;手机&quot;);
        query.addCriteria(c);
        query.setOffset(1L);
        query.setRows(1);
        ScoredPage&lt;DemoPojo&gt; sp = solrTemplate.queryForPage(&quot;collection1&quot;, query, DemoPojo.class);
        System.out.println(sp.getContent());
    &#125;

    @Test
    public void queryHL()&#123;

        List&lt;DemoPojo&gt; listResult = new ArrayList&lt;&gt;();
        SimpleHighlightQuery query = new SimpleHighlightQuery();
        //设置查询条件
        Criteria c = new Criteria(&quot;item_keywords&quot;);
        c.is(&quot;手机&quot;);
        query.addCriteria(c);
        //分页
        query.setOffset(0L);
        query.setRows(10);
        //排序
        Sort sort = new Sort(Sort.Direction.DESC,&quot;id&quot;);
        query.addSort(sort);
        //高亮设置
        HighlightOptions hlo = new HighlightOptions();
        hlo.addField(&quot;item_title item_sell_point&quot;);
        hlo.setSimplePrefix(&quot;&lt;span style=&#39;color:red;&#39;&gt;&quot;);
        hlo.setSimplePostfix(&quot;&lt;/span&gt;&quot;);
        query.setHighlightOptions(hlo);
        HighlightPage&lt;DemoPojo&gt; hl = solrTemplate.queryForHighlightPage(&quot;collection1&quot;, query, DemoPojo.class);
//        System.out.println(hl.getContent());
        List&lt;HighlightEntry&lt;DemoPojo&gt;&gt; highlighted = hl.getHighlighted();
        for(HighlightEntry&lt;DemoPojo&gt; hle : highlighted)&#123;
            List&lt;HighlightEntry.Highlight&gt; list = hle.getHighlights();
            DemoPojo dp = hle.getEntity();
            for (HighlightEntry.Highlight h : list)&#123;//一个对象里面可能多个属性是高亮属性
                if(h.getField().getName().equals(&quot;item_title&quot;))&#123;
                    dp.setItem_title( h.getSnipplets().get(0));
                &#125;
            &#125;
            listResult.add(dp);
        &#125;
        System.out.println(listResult);
    &#125;
&#125;
</code></pre>
<h3 id="十一-使用zookeepr管理solr集群"><a href="#十一-使用zookeepr管理solr集群" class="headerlink" title="十一. 使用zookeepr管理solr集群"></a>十一. 使用zookeepr管理solr集群</h3><p>1.上传压缩包到&#x2F;usr&#x2F;local&#x2F;tmp 下 并解压。</p>
<p>2.在 &#x2F;usr&#x2F;local下新建文件夹 zookeeper</p>
<pre><code># mkdir /usr/local/zookeeper
</code></pre>
<p>3.把解压的所有文件复制到zookeeper下， 并命名为zk1</p>
<pre><code># cp -r /usr/local/temp/zookeeper-3.4.8 /usr/local/zookeeper/zk1
</code></pre>
<p>4.在zk1下新建文件夹 data</p>
<p>5.在data下新建文件 myid, 里面写上 1</p>
<pre><code># vim myid
</code></pre>
<p>6.进入到zk1&#x2F;conf 下 把 zoo_sample.cfg 复制一份叫做 zoo.cfg</p>
<p>7.编辑 zoo.cfg 内容，设置 dataDIR为 data文件夹， 并在文件最下面添加下面内容</p>
<pre><code>server.1=192.168.93.10:2688:3888
server.2=192.168.93.10:2689:3889
server.3=192.168.93.10:2690:3890
</code></pre>
<p> 7.1 server.1中的1是myid的内容</p>
<p> 7.2 2688 2689 2690 是 zookeeper内部端口</p>
<p> 7.3 3888 3889 3890 是 leader端口</p>
<p>8.把zk1复制两份，分部叫做 zk2  zk3  并修改 myid 的值为 2，3 修改zoo.cfg中 dataDIR和clientPort</p>
<p>9.启动三个zookeeper</p>
<pre><code># ./zkServer.sh start
</code></pre>
<p>10.查看状态</p>
<pre><code># ./zkServer.sh status
</code></pre>
<h3 id="十一-使用zookeepr管理solr集群-Dokcer"><a href="#十一-使用zookeepr管理solr集群-Dokcer" class="headerlink" title="十一. 使用zookeepr管理solr集群(Dokcer )"></a>十一. 使用zookeepr管理solr集群(Dokcer )</h3><h4 id="1、准备docker-compose-yml文件"><a href="#1、准备docker-compose-yml文件" class="headerlink" title="1、准备docker-compose.yml文件"></a><strong>1、准备</strong>docker-compose.yml<strong>文件</strong></h4><pre><code class="shell">version: &#39;2&#39;
services:
  zoo1:
    image: zookeeper:3.5
    restart: always
    container_name: zoo1
    ports:
      - &quot;2181:2181&quot;
    environment:
      ZOO_MY_ID: 1
      ZOO_SERVERS: server.1=0.0.0.0:2688:3888 server.2=zoo2:2689:3888 server.3=zoo3:2690:3888

  zoo2:
    image: zookeeper:3.5
    restart: always
    container_name: zoo2
    ports:
      - &quot;2182:2181&quot;
    environment:
      ZOO_MY_ID: 2
      ZOO_SERVERS: server.1=zoo1:2688:3888 server.2=0.0.0.0:2689:3888 server.3=zoo3:2690:3888

  zoo3:
    image: zookeeper:3.5
    restart: always
    container_name: zoo3
    ports:
      - &quot;2183:2181&quot;
    environment:
      ZOO_MY_ID: 3
      ZOO_SERVERS: server.1=zoo1:2688:3888 server.2=zoo2:2689:3888 server.3=0.0.0.0:2690:3888

</code></pre>
<h4 id="2、创建镜像"><a href="#2、创建镜像" class="headerlink" title="2、创建镜像"></a><strong>2、创建镜像</strong></h4><ul>
<li>要在创建的docker-compose.yml文件中使用命令</li>
</ul>
<pre><code class="shell">docker-compose up -d
</code></pre>
<h4 id="3、进入容器"><a href="#3、进入容器" class="headerlink" title="3、进入容器"></a><strong>3、进入容器</strong></h4><pre><code class="shell">docker exec -it zoo1 /bin/bash

#查看zoo1 的状态
cd bin
./zkServer.sh status
</code></pre>
<ul>
<li>如果出现，以下情况：</li>
</ul>
<pre><code>ZooKeeper JMX enabled by default
Using config: /conf/zoo.cfg
Client port not found in static config file. Looking in dynamic config file.
grep: : No such file or directory
Client port not found in the server configs
Client port not found. Looking for secureClientPort in the static config.
Unable to find either secure or unsecure client port in any configs. Terminating.
</code></pre>
<p>​	通过阅读我们知道他在conf中的zoo.cfg文件中缺少 **clientPort **我们只需要自行添加即可</p>
<pre><code class="shell">#修改之前我们先装一下 vim
apt-get update

apt-get install -y vim 

#修改zoo.fcg文件
vim /conf/zoo.fcg

clientPort=2181
</code></pre>
<ul>
<li><p>完事之后<strong>重启</strong>zoo1</p>
<p>  <img data-src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\1645780920291.png" alt="1645780920291"></p>
<p>  成功！！</p>
</li>
</ul>
<h4 id="4、查看所有zookeeper的状态"><a href="#4、查看所有zookeeper的状态" class="headerlink" title="4、查看所有zookeeper的状态"></a>4、查看所有zookeeper的状态</h4><pre><code class="shell">docker exec -it zoo3 bash ./bin/zkServer.sh status
</code></pre>
<h4 id="5、进去客户端"><a href="#5、进去客户端" class="headerlink" title="5、进去客户端"></a>5、进去客户端</h4><pre><code class="shell">docker exec -it zoo3 zkCli.sh
</code></pre>
<h3 id="十二、SolrCloud"><a href="#十二、SolrCloud" class="headerlink" title="十二、SolrCloud"></a>十二、SolrCloud</h3><p>​	Solr可以搭建具备容错能力和高可用的Solr集群。集群中集群配置、自动负载均衡和查询故障转移、			Zookeeper集群实现集群协调管理，这些全部功能统称为SolrCloud。</p>
<p>​	SolrCloud是基于Zookeeper进行管理的。在Solr中已经内置了Zookeeper相关内容，当执行集群创建命令会自动创建Zookeeper相关内容。这个使用的是Zookeeper的集群管理功能实现的。</p>
<h4 id="1-搭建"><a href="#1-搭建" class="headerlink" title="1.搭建"></a>1.搭建</h4><h5 id="1-1创建"><a href="#1-1创建" class="headerlink" title="1.1创建"></a>1.1创建</h5><p>​	SolrCloud已经包含在了Solr中，可以直接启动Solr集群。</p>
<pre><code> ./solr -e cloud -noprompt -force
</code></pre>
<p>​	此命令等同于# .&#x2F;solr -e cloud -force全部参数为默认值。</p>
<p>​	运行成功后会在example文件夹多出cloud文件夹。</p>
<h5 id="1-2停止"><a href="#1-2停止" class="headerlink" title="1.2停止"></a>1.2停止</h5><pre><code> ./solr stop -all
</code></pre>
<h5 id="1-3重新运行"><a href="#1-3重新运行" class="headerlink" title="1.3重新运行"></a>1.3重新运行</h5><pre><code> ./solr start -c -p 8983 -s ../example/cloud/node1/solr/ -force
 ./solr start -c -p 7574 -z localhost:9983 -s ../example/cloud/node2/solr/ -force
</code></pre>
]]></content>
      <categories>
        <category>分布式</category>
        <category>Solr</category>
      </categories>
      <tags>
        <tag>分布式</tag>
        <tag>中间件</tag>
        <tag>Solr</tag>
        <tag>快速搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>第10章_常用类</title>
    <url>/2022/10/07/Java/%E7%AC%AC10%E7%AB%A0_%E5%B8%B8%E7%94%A8%E7%B1%BB/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>JavaSE</category>
        <category>常用类</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title>第11章集合</title>
    <url>/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<h1 id="11-集合"><a href="#11-集合" class="headerlink" title="11 集合"></a>11 集合</h1><img data-src="/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618180112196.png" class="">




<img data-src="/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618170703735.png" class="">




<h1 id="Colletion接口"><a href="#Colletion接口" class="headerlink" title="Colletion接口"></a>Colletion接口</h1><h2 id="1-1-常用方法"><a href="#1-1-常用方法" class="headerlink" title="1.1 常用方法"></a>1.1 常用方法</h2><pre><code class="java">package com.msb.test01;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.List;
/**
 * @author : msb-zhaoss
 */
public class Test01 &#123;
    //这是main方法，程序的入口
    public static void main(String[] args) &#123;
        /*
        Collection接口的常用方法：
        增加：add(E e) addAll(Collection&lt;? extends E&gt; c)
        删除：clear() remove(Object o)
        修改：
        查看：iterator() size()
        判断：contains(Object o)  equals(Object o) isEmpty()
         */
        //创建对象：接口不能创建对象，利用实现类创建对象：
        Collection col = new ArrayList();
        //调用方法：
        //集合有一个特点：只能存放引用数据类型的数据，不能是基本数据类型
        //基本数据类型自动装箱，对应包装类。int---&gt;Integer
        col.add(18);
        col.add(12);
        col.add(11);
        col.add(17);
        System.out.println(col/*.toString()*/);
        List list = Arrays.asList(new Integer[]&#123;11, 15, 3, 7, 1&#125;);
        col.addAll(list);//将另一个集合添加入col中
        System.out.println(col);
        //col.clear();清空集合
        System.out.println(col);
        System.out.println(&quot;集合中元素的数量为：&quot;+col.size());
        System.out.println(&quot;集合是否为空：&quot;+col.isEmpty());
        boolean isRemove = col.remove(15);
        System.out.println(col);
        System.out.println(&quot;集合中数据是否被删除：&quot;+isRemove);
        Collection col2 = new ArrayList();
        col2.add(18);
        col2.add(12);
        col2.add(11);
        col2.add(17);
        Collection col3 = new ArrayList();
        col3.add(18);
        col3.add(12);
        col3.add(11);
        col3.add(17);
        System.out.println(col2.equals(col3));
        System.out.println(col2==col3);//地址一定不相等  false
        System.out.println(&quot;是否包含元素：&quot;+col3.contains(117));
    &#125;
&#125;
</code></pre>
<h2 id="1-2-Collection集合的遍历"><a href="#1-2-Collection集合的遍历" class="headerlink" title="1.2 Collection集合的遍历"></a>1.2 Collection集合的遍历</h2><pre><code class="java">迭代器简要原理图：



package com.msb.test01;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;
/**
 * @author : msb-zhaoss
 */
public class Test02 &#123;
    //这是main方法，程序的入口
    public static void main(String[] args) &#123;
        Collection col = new ArrayList();
        col.add(18);
        col.add(12);
        col.add(11);
        col.add(17);
        col.add(&quot;abc&quot;);
        col.add(9.8);
        //对集合遍历（对集合中元素进行查看）
        //方式1：普通for循环
        /*for(int i= 0;i&lt;col.size();i++)&#123;
            col.
        &#125;*/
        //方式2：增强for循环
        for(Object o:col)&#123;
            System.out.println(o);
        &#125;
        System.out.println(&quot;------------------------&quot;);
        //方式3：iterator()
        Iterator it = col.iterator();
        while(it.hasNext())&#123;
            System.out.println(it.next());
        &#125;
    &#125;
&#125;
</code></pre>
<h2 id="2-List接口"><a href="#2-List接口" class="headerlink" title="2 List接口"></a>2 List接口</h2><h3 id="2-1-常用方法和遍历方式"><a href="#2-1-常用方法和遍历方式" class="headerlink" title="2.1 常用方法和遍历方式"></a>2.1 常用方法和遍历方式</h3><pre><code class="java">package com.msb.test01;
import com.sun.org.apache.xerces.internal.dom.PSVIAttrNSImpl;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
/**
 * @author : msb-zhaoss
 */
public class Test03 &#123;
    //这是main方法，程序的入口
    public static void main(String[] args) &#123;
        /*
        List接口中常用方法：
        增加：add(int index, E element)
        删除：remove(int index)  remove(Object o)
        修改：set(int index, E element)
        查看：get(int index)
        判断：
         */
        List list = new ArrayList();
        list.add(13);
        list.add(17);
        list.add(6);
        list.add(-1);
        list.add(2);
        list.add(&quot;abc&quot;);
        System.out.println(list);
        list.add(3,66);
        System.out.println(list);
        list.set(3,77);
        System.out.println(list);
        list.remove(2);//在集合中存入的是Integer类型数据的时候，调用remove方法调用的是：remove(int index)
        System.out.println(list);
        list.remove(&quot;abc&quot;);
        System.out.println(list);
        Object o = list.get(0);
        System.out.println(o);
        //List集合 遍历：
        //方式1：普通for循环：
        System.out.println(&quot;---------------------&quot;);
        for(int i = 0;i&lt;list.size();i++)&#123;
            System.out.println(list.get(i));
        &#125;
        //方式2：增强for循环：
        System.out.println(&quot;---------------------&quot;);
        for(Object obj:list)&#123;
            System.out.println(obj);
        &#125;
        //方式3：迭代器：
        System.out.println(&quot;---------------------&quot;);
        Iterator it = list.iterator();
        while(it.hasNext())&#123;
            System.out.println(it.next());
        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="2-2-ArrayList实现类（JDK1-7）"><a href="#2-2-ArrayList实现类（JDK1-7）" class="headerlink" title="2.2 ArrayList实现类（JDK1.7）"></a>2.2 ArrayList实现类（JDK1.7）</h3><p>底层重要属性：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618172028655.png" class="">


<p>在JDK1.7中：在调用构造器的时候给底层数组elementData初始化，<font color=#FF0000>数组初始化长度为10</font>：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618172107247.png" class="">


<p>对应内存：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618172121579.png" class="">


<p>调用add方法：</p>
<pre><code class="java">         ArrayList al = new ArrayList();
        System.out.println(al.add(&quot;abc&quot;));
        System.out.println(al.add(&quot;def&quot;));
</code></pre>
<img data-src="/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618172152471.png" class="">


<p>当数组中的10个位置都满了的时候就开始进行数组的扩容，扩容长度为 <font color=#FF0000>原数组的1.5倍</font>：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618172227199.png" class="">


<img data-src="/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618172231517.png" class="">


<img data-src="/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618172235705.png" class="">








<h3 id="2-3-ArrayList实现类（JDK1-8）"><a href="#2-3-ArrayList实现类（JDK1-8）" class="headerlink" title="2.3 ArrayList实现类（JDK1.8）"></a>2.3 ArrayList实现类（JDK1.8）</h3><p>【1】JDK1.8底层依旧是Object类型的数组，size:数组中有效长度：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618172252320.png" class="">


<p>【2】ArrayList al &#x3D; new ArrayList();调用空构造器：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618172303832.png" class="">


<p>【3】add方法：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618172316929.png" class="">


<img data-src="/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618172324585.png" class="">


<img data-src="/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618172335841.png" class="">


<img data-src="/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618172340839.png" class="">




<h3 id="2-4-Vector实现类"><a href="#2-4-Vector实现类" class="headerlink" title="2.4 Vector实现类"></a>2.4 Vector实现类</h3><p>【1】底层Object数组，int类型属性表示数组中有效长度：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618172455343.png" class="">



<p>【2】Vector v&#x3D;new Vector();调用构造器：</p>
<p>【3】add方法：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618172507015.png" class="">




<h3 id="2-5-泛型"><a href="#2-5-泛型" class="headerlink" title="2.5 泛型"></a>2.5 泛型</h3><p>【1】什么是泛型（Generic）：<br>泛型就相当于标签<br>形式：&lt;&gt;<br>集合容器类在设计阶段&#x2F;声明阶段不能确定这个容器到底实际存的是什么类型的对象，所以在JDK1.5之前只能把元素类型设计为Object，<br>JDK1.5之 后使用泛型来解决。因为这个时候除了元素的类型不确定，其他的部分是确定的，例如关于这个元素如何保存，如何管理等是确定的，因此此时把元素的类型设计成一个参数，这个类型参数叫做泛型。<br>Collection<E>, List<E>， ArrayList<E> 这个<E>就是类型参数，即泛型。</p>
<p>【2】没有泛型的时候使用集合：</p>
<pre><code class="java">package com.msb.test01;
import java.util.ArrayList;
/**
 * @author : msb-zhaoss
 */
public class Test01 &#123;
    //这是main方法，程序的入口
    public static void main(String[] args) &#123;
        //创建一个ArrayList集合，向这个集合中存入学生的成绩：
        ArrayList al = new ArrayList();
        al.add(98);
        al.add(18);
        al.add(39);
        al.add(60);
        al.add(83);
        al.add(&quot;丽丽&quot;);
        //对集合遍历查看：
        for(Object obj:al)&#123;
            System.out.println(obj);
        &#125;
    &#125;
&#125;
</code></pre>
<p>如果不使用泛型的话，有缺点：<br>一般我们在使用的时候基本上往集合中存入的都是相同类型的数据–》便于管理，所以现在什么引用数据类型都可以存入集合，不方便！</p>
<p>【3】JDK1.5以后开始使用泛型，集合中使用泛型：</p>
<pre><code class="java">package com.msb.test01;
import java.util.ArrayList;
/**
 * @author : msb-zhaoss
 */
public class Test01 &#123;
    //这是main方法，程序的入口
    public static void main(String[] args) &#123;
        //创建一个ArrayList集合，向这个集合中存入学生的成绩：
        //加入泛型的优点：在编译时期就会对类型进行检查，不是泛型对应的类型就不可以添加入这个集合。
        ArrayList&lt;Integer&gt; al = new ArrayList&lt;Integer&gt;();
        al.add(98);
        al.add(18);
        al.add(39);
        al.add(60);
        al.add(83);
        /*al.add(&quot;丽丽&quot;);
        al.add(9.8);*/
        //对集合遍历查看：
        /*for(Object obj:al)&#123;
            System.out.println(obj);
        &#125;*/
        for(Integer i:al)&#123;
            System.out.println(i);
        &#125;
    &#125;
&#125;
</code></pre>
<p>【4】泛型总结：<br>（1）JDK1.5以后<br>（2）泛型实际就是 一个&lt;&gt;引起来的 参数类型，这个参数类型  具体在使用的时候才会确定具体的类型。</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618172646571.png" class="">


<p>（3）使用了泛型以后，可以确定集合中存放数据的类型，在编译时期就可以检查出来。<br>（4）使用泛型你可能觉得麻烦，实际使用了泛型才会简单，后续的遍历等操作简单。<br>（5）泛型的类型：都是引用数据类型，不能是基本数据类型。<br>（6）ArrayList<Integer> al &#x3D; new ArrayList<Integer>();在JDK1.7以后可以写为：<br>ArrayList<Integer> al &#x3D; new ArrayList&lt;&gt;();  –&lt;&gt;  —钻石运算符</p>
<h4 id="2-5-1-自定义泛型结构"><a href="#2-5-1-自定义泛型结构" class="headerlink" title="2.5.1 自定义泛型结构"></a>2.5.1 自定义泛型结构</h4><p>泛型类，泛型接口</p>
<p>【1】泛型类的定义和实例化：</p>
<pre><code class="java">package com.msb.test02;
/**
 * @author : msb-zhaoss
 * GenericTes就是一个普通的类
 * GenericTest&lt;E&gt; 就是一个泛型类
 * &lt;&gt;里面就是一个参数类型，但是这个类型是什么呢？这个类型现在是不确定的，相当于一个占位
 * 但是现在确定的是这个类型一定是一个引用数据类型，而不是基本数据类型
 */
public class GenericTest&lt;E&gt; &#123;
    int age;
    String name;
    E sex;
    public void a(E n)&#123;
    &#125;
    public void b(E[] m)&#123;
    &#125;
&#125;
class Test&#123;
    //这是main方法，程序的入口
    public static void main(String[] args) &#123;
        //GenericTest进行实例化：
        //(1)实例化的时候不指定泛型：如果实例化的时候不明确的指定类的泛型，那么认为此泛型为Object类型
        GenericTest gt1 = new GenericTest();
        gt1.a(&quot;abc&quot;);
        gt1.a(17);
        gt1.a(9.8);
        gt1.b(new String[]&#123;&quot;a&quot;,&quot;b&quot;,&quot;c&quot;&#125;);
        //（2）实例化的时候指定泛型：---》推荐方式
        GenericTest&lt;String&gt; gt2 = new GenericTest&lt;&gt;();
        gt2.sex = &quot;男&quot;;
        gt2.a(&quot;abc&quot;);
        gt2.b(new String[]&#123;&quot;a&quot;,&quot;b&quot;,&quot;c&quot;&#125;);
        
    &#125;
&#125;
</code></pre>
<p>【2】继承情况：<br>（1）父类指定泛型：</p>
<pre><code class="java">class SubGenericTest extends GenericTest&lt;Integer&gt;&#123;
&#125;
class Demo&#123;
    //这是main方法，程序的入口
    public static void main(String[] args) &#123;
        //指定父类泛型，那么子类就不需要再指定泛型了，可以直接使用
        SubGenericTest sgt = new SubGenericTest();
        sgt.a(19);
    &#125;
&#125;
</code></pre>
<p>（2）父类不指定泛型：<br>如果父类不指定泛型，那么子类也会变成一个泛型类，那这个E的类型可以在创建子类对象的时候确定：</p>
<pre><code class="java">class SubGenericTest2&lt;E&gt; extends GenericTest&lt;E&gt;&#123;
&#125;

class Demo2&#123;
    //这是main方法，程序的入口
    public static void main(String[] args) &#123;
        SubGenericTest2&lt;String&gt; s = new  SubGenericTest2&lt;&gt;();
        s.a(&quot;abc&quot;);
        s.sex = &quot;女&quot;;
    &#125;
&#125;
</code></pre>
<p>【3】应用场合：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618173037582.png" class="">


<p>【4】细节：<br>（1）泛型类可以定义多个参数类型</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618173045431.png" class="">


<p>（2）泛型类的构造器的写法：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618173057556.png" class="">


<p>（3）不同的泛型的引用类型不可以相互赋值：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618173104251.png" class="">


<p>（4）泛型如果不指定，那么就会被擦除，反应对应的类型为Object类型：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618173116539.png" class="">


<p>（5）反省类中的静态方法不能使用类的泛型：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618173123924.png" class="">


<p>（6）不能直接使用E[]的创建：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618173130213.png" class="">


<h4 id="2-5-2-泛型方法"><a href="#2-5-2-泛型方法" class="headerlink" title="2.5.2 泛型方法"></a>2.5.2 泛型方法</h4><pre><code class="java">package com.msb.test04;
/**
 * @author : msb-zhaoss
 * 1.什么是泛型方法：
 * 不是带泛型的方法就是泛型方法
 * 泛型方法有要求：这个方法的泛型的参数类型要和当前的类的泛型无关
 * 换个角度：
 * 泛型方法对应的那个泛型参数类型 和  当前所在的这个类 是否是泛型类，泛型是啥  无关
 * 2.泛型方法定义的时候，前面要加上&lt;T&gt;
 *     原因：如果不加的话，会把T当做一种数据类型，然而代码中没有T类型那么就会报错
 * 3.T的类型是在调用方法的时候确定的
 * 4.泛型方法可否是静态方法？可以是静态方法
 */
public class TestGeneric&lt;E&gt; &#123;
    //不是泛型方法 （不能是静态方法）
    public static void a(E e)&#123;
    &#125;
    //是泛型方法
    public static &lt;T&gt;  void b(T t)&#123;
    &#125;
&#125;
class Demo&#123;
    //这是main方法，程序的入口
    public static void main(String[] args) &#123;
        TestGeneric&lt;String&gt; tg = new TestGeneric&lt;&gt;();
        tg.a(&quot;abc&quot;);
        tg.b(&quot;abc&quot;);
        tg.b(19);
        tg.b(true);
    &#125;
&#125;
</code></pre>
<h4 id="2-5-3-泛型参数存在继承关系的情况"><a href="#2-5-3-泛型参数存在继承关系的情况" class="headerlink" title="2.5.3 泛型参数存在继承关系的情况"></a>2.5.3 泛型参数存在继承关系的情况</h4><img data-src="/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618173213265.png" class="">


<h4 id="2-5-4-通配符"><a href="#2-5-4-通配符" class="headerlink" title="2.5.4 通配符"></a>2.5.4 通配符</h4><p>【1】在没有通配符的时候：<br>下面的a方法，相当于方法的重复定义，报错</p>
<pre><code class="java">public class Test &#123;
    /*public void a(List&lt;Object&gt; list)&#123;
    &#125;
    public void a(List&lt;String&gt; list)&#123;
    &#125;
    public void a(List&lt;Integer&gt; list)&#123;
    &#125;*/
&#125;
</code></pre>
<p>【2】引入通配符：</p>
<pre><code class="java">public class Demo &#123;
    //这是main方法，程序的入口
    public static void main(String[] args) &#123;
        List&lt;Object&gt; list1 = new ArrayList&lt;&gt;();
        List&lt;String&gt; list2 = new ArrayList&lt;&gt;();
        List&lt;Integer&gt; list3 = new ArrayList&lt;&gt;();
        List&lt;?&gt; list = null;
        list = list1;
        list = list2;
        list = list3;
    &#125;
&#125;
</code></pre>
<p>发现： A 和 B是子类父类的关系，G<A>和G<B>不存在子类父类关系，是并列的<br>加入通配符？后，G&lt;?&gt;就变成了 G<A>和G<B>的父类</p>
<p>【3】使用通配符：</p>
<pre><code class="java">package com.msb.test06;
import java.util.ArrayList;
import java.util.List;
/**
 * @author : msb-zhaoss
 */
public class Test &#123;
    /*public void a(List&lt;Object&gt; list)&#123;
    &#125;
    public void a(List&lt;String&gt; list)&#123;
    &#125;
    public void a(List&lt;Integer&gt; list)&#123;
    &#125;*/
    public void a(List&lt;?&gt; list)&#123;
        //内部遍历的时候用Object即可，不用？
        for(Object a:list)&#123;
            System.out.println(a);
        &#125;
    &#125;
&#125;
class T&#123;
    //这是main方法，程序的入口
    public static void main(String[] args) &#123;
        Test t = new Test();
        t.a(new ArrayList&lt;Integer&gt;());
        t.a(new ArrayList&lt;String&gt;());
        t.a(new ArrayList&lt;Object&gt;());
    &#125;
&#125;
</code></pre>
<p>【4】查看API中应用位置：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618173333503.png" class="">


<h4 id="2-5-5-使用通配符后的细节"><a href="#2-5-5-使用通配符后的细节" class="headerlink" title="2.5.5 使用通配符后的细节"></a>2.5.5 使用通配符后的细节</h4><pre><code class="java">public class Test &#123;
    public void a(List&lt;?&gt; list)&#123;
        //1.遍历：
        for(Object a:list)&#123;
            System.out.println(a);
        &#125;
        //2.数据的写入操作 ：
        //list.add(&quot;abc&quot;);--&gt;出错，不能随意的添加数据
        list.add(null);
        //3.数据的读取操作：
        Object s = list.get(0);
    &#125;
&#125;
class T&#123;
    //这是main方法，程序的入口
    public static void main(String[] args) &#123;
        Test t = new Test();
        t.a(new ArrayList&lt;Integer&gt;());
        t.a(new ArrayList&lt;String&gt;());
        t.a(new ArrayList&lt;Object&gt;());
    &#125;
&#125;
</code></pre>
<h4 id="2-5-6-泛型受限"><a href="#2-5-6-泛型受限" class="headerlink" title="2.5.6 泛型受限"></a>2.5.6 泛型受限</h4><pre><code class="java">package com.msb.test07;
import java.util.ArrayList;
import java.util.List;

public class Test &#123;
    //这是main方法，程序的入口
    public static void main(String[] args) &#123;
        //a,b,c三个集合是并列的关系：
        List&lt;Object&gt; a = new ArrayList&lt;&gt;();
        List&lt;Person&gt; b = new ArrayList&lt;&gt;();
        List&lt;Student&gt; c = new ArrayList&lt;&gt;();
        /*开始使用泛型受限：泛型的上限
        List&lt;? extends Person&gt;:
        就相当于：
        List&lt;? extends Person&gt;是List&lt;Person&gt;的父类，是List&lt;Person的子类&gt;的父类
         */
        List&lt;? extends Person&gt; list1 = null;
        /*list1 = a;
        list1 = b;
        list1 = c;*/
        /*开始使用泛型受限：泛型的下限
        List&lt;? super Person&gt;
        就相当于：
        List&lt;? super Person&gt;是List&lt;Person&gt;的父类，是List&lt;Person的父类&gt;的父类
         */
        List&lt;? super Person&gt; list2 = null;
        list2 = a;
        list2 = b;
        list3 = c;
    &#125;
&#125;
</code></pre>
<h3 id="2-6-LinkedList实现类"><a href="#2-6-LinkedList实现类" class="headerlink" title="2.6 LinkedList实现类"></a>2.6 LinkedList实现类</h3><h4 id="2-6-1-基本方法使用"><a href="#2-6-1-基本方法使用" class="headerlink" title="2.6.1 基本方法使用"></a>2.6.1 基本方法使用</h4><pre><code class="java">package com.msb.test04;
import java.util.Iterator;
import java.util.LinkedList;
/**
 * @author : msb-zhaoss
 */
public class Test &#123;
    //这是main方法，程序的入口
    public static void main(String[] args) &#123;
        /*
        LinkedList常用方法：
        增加 addFirst(E e) addLast(E e)
             offer(E e) offerFirst(E e) offerLast(E e)
        删除 poll()
            pollFirst() pollLast()  ---》JDK1.6以后新出的方法，提高了代码的健壮性
            removeFirst() removeLast()
        修改
        查看 element()
             getFirst()  getLast()
             indexOf(Object o)   lastIndexOf(Object o)
             peek()
             peekFirst() peekLast()
        判断
         */
        //创建一个LinkedList集合对象：
        LinkedList&lt;String&gt; list = new LinkedList&lt;&gt;();
        list.add(&quot;aaaaa&quot;);
        list.add(&quot;bbbbb&quot;);
        list.add(&quot;ccccc&quot;);
        list.add(&quot;ddddd&quot;);
        list.add(&quot;eeeee&quot;);
        list.add(&quot;bbbbb&quot;);
        list.add(&quot;fffff&quot;);
        list.addFirst(&quot;jj&quot;);
        list.addLast(&quot;hh&quot;);
        list.offer(&quot;kk&quot;);//添加元素在尾端
        list.offerFirst(&quot;pp&quot;);
        list.offerLast(&quot;rr&quot;);
        System.out.println(list);//LinkedList可以添加重复数据
        System.out.println(list.poll());//删除头上的元素并且将元素输出
        System.out.println(list.pollFirst());
        System.out.println(list.pollLast());
        System.out.println(list.removeFirst());
        System.out.println(list.removeLast());
        System.out.println(list);//LinkedList可以添加重复数据
        /*list.clear();//清空集合
        System.out.println(list);*/
        /*System.out.println(list.pollFirst());*/
        /*System.out.println(list.removeFirst());报错：Exception in thread &quot;main&quot; java.util.NoSuchElementException*/
        //集合的遍历：
        System.out.println(&quot;---------------------&quot;);
        //普通for循环：
        for(int i = 0;i&lt;list.size();i++)&#123;
            System.out.println(list.get(i));
        &#125;
        System.out.println(&quot;---------------------&quot;);
        //增强for：
        for(String s:list)&#123;
            System.out.println(s);
        &#125;
        System.out.println(&quot;---------------------&quot;);
        //迭代器：
        /*Iterator&lt;String&gt; it = list.iterator();
        while(it.hasNext())&#123;
            System.out.println(it.next());
        &#125;*/
        //下面这种方式好，节省内存
        for(Iterator&lt;String&gt; it = list.iterator();it.hasNext();)&#123;
            System.out.println(it.next());
        &#125;
    &#125;
&#125;
</code></pre>
<h4 id="2-6-2-简要底层原理图"><a href="#2-6-2-简要底层原理图" class="headerlink" title="2.6.2 简要底层原理图"></a>2.6.2 简要底层原理图</h4><img data-src="/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618173515599.png" class="">


<h4 id="2-6-3-模拟LinkedList源码"><a href="#2-6-3-模拟LinkedList源码" class="headerlink" title="2.6.3 模拟LinkedList源码"></a>2.6.3 模拟LinkedList源码</h4><pre><code class="java">package com.msb.test05;
/**
 * @author : msb-zhaoss
 */
public class MyLinkedList &#123;
    //链中一定有一个首节点：
    Node first;
    //链中一定有一个尾节点：
    Node last;
    //计数器：
    int count = 0;
    //提供一个构造器：
    public MyLinkedList()&#123;
    &#125;
    //添加元素方法：
    public void add(Object o)&#123;
        if(first == null)&#123;//证明你添加的元素是第一个节点：
            //将添加的元素封装为一个Node对象：
            Node n = new Node();
            n.setPre(null);
            n.setObj(o);
            n.setNext(null);
            //当前链中第一个节点变为n
            first = n;
            //当前链中最后一个节点变为n
            last = n;
        &#125;else&#123;//证明已经不是链中第一个节点了
            //将添加的元素封装为一个Node对象：
            Node n = new Node();
            n.setPre(last);//n的上一个节点一定是当前链中的最后一个节点last
            n.setObj(o);
            n.setNext(null);
            //当前链中的最后一个节点的下一个元素 要指向n
            last.setNext(n);
            //将最后一个节点变为n
            last = n;
        &#125;
        //链中元素数量加1
        count++;
    &#125;
    //得到集合中元素的数量：
    public int getSize()&#123;
        return count;
    &#125;
    //通过下标得到元素：
    public Object get(int index)&#123;
        //获取链表的头元素：
        Node n = first;
        //一路next得到想要的元素
        for(int i=0;i&lt;index;i++)&#123;
            n = n.getNext();
        &#125;
        return n.getObj();
    &#125;
&#125;
class Test&#123;
    //这是main方法，程序的入口
    public static void main(String[] args) &#123;
        //创建一个MyLinkedList集合对象：
        MyLinkedList ml = new MyLinkedList();
        ml.add(&quot;aa&quot;);
        ml.add(&quot;bb&quot;);
        ml.add(&quot;cc&quot;);
        System.out.println(ml.getSize());
        System.out.println(ml.get(0));
    &#125;
&#125;
</code></pre>
<h4 id="2-6-4-LinkedList源码解析"><a href="#2-6-4-LinkedList源码解析" class="headerlink" title="2.6.4 LinkedList源码解析"></a>2.6.4 LinkedList源码解析</h4><p>【1】JDK1.7和JDK1.8的LinkedList的源码是一致的<br>【2】源码：</p>
<pre><code class="java">public class LinkedList&lt;E&gt;&#123;//E是一个泛型，具体的类型要在实例化的时候才会最终确定
        transient int size = 0;//集合中元素的数量
        //Node的内部类
        private static class Node&lt;E&gt; &#123;
        E item;//当前元素
        Node&lt;E&gt; next;//指向下一个元素地址
        Node&lt;E&gt; prev;//上一个元素地址
        Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;
            this.item = element;
            this.next = next;
            this.prev = prev;
        &#125;
    &#125;
        transient Node&lt;E&gt; first;//链表的首节点
        transient Node&lt;E&gt; last;//链表的尾节点
        //空构造器：
        public LinkedList() &#123;
    &#125;
        //添加元素操作：
        public boolean add(E e) &#123;
        linkLast(e);
        return true;
    &#125;
        void linkLast(E e) &#123;//添加的元素e
        final Node&lt;E&gt; l = last;//将链表中的last节点给l 如果是第一个元素的话 l为null
                //将元素封装为一个Node具体的对象：
        final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null);
                //将链表的last节点指向新的创建的对象：
        last = newNode;
                
        if (l == null)//如果添加的是第一个节点
            first = newNode;//将链表的first节点指向为新节点
        else//如果添加的不是第一个节点 
            l.next = newNode;//将l的下一个指向为新的节点
        size++;//集合中元素数量加1操作
        modCount++;
    &#125;
        //获取集合中元素数量
        public int size() &#123;
        return size;
    &#125;
        //通过索引得到元素：
        public E get(int index) &#123;
        checkElementIndex(index);//健壮性考虑
        return node(index).item;
    &#125;
        
    Node&lt;E&gt; node(int index) &#123;
        //如果index在链表的前半段，那么从前往后找
        if (index &lt; (size &gt;&gt; 1)) &#123;
            Node&lt;E&gt; x = first;
            for (int i = 0; i &lt; index; i++)
                x = x.next;
            return x;
        &#125; else &#123;//如果index在链表的后半段，那么从后往前找
            Node&lt;E&gt; x = last;
            for (int i = size - 1; i &gt; index; i--)
                x = x.prev;
            return x;
        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="面试题："><a href="#面试题：" class="headerlink" title="面试题："></a>面试题：</h3><blockquote>
<p>iterator(),Iterator,Iterable关系</p>
</blockquote>
<p>【1】面试题：对应的关系：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618173707713.png" class="">


<p>【2】hasNext(),next()的具体实现：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618173654976.png" class="">


<p>ListIterator迭代器</p>
<p>【1】加入字符串：</p>
<pre><code class="java">package com.msb.test06;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
/**
 * @author : msb-zhaoss
 */
public class Test2 &#123;
    //这是main方法，程序的入口
    public static void main(String[] args) &#123;
        ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();
        list.add(&quot;aa&quot;);
        list.add(&quot;bb&quot;);
        list.add(&quot;cc&quot;);
        list.add(&quot;dd&quot;);
        list.add(&quot;ee&quot;);
        //在&quot;cc&quot;之后添加一个字符串&quot;kk&quot;
        Iterator&lt;String&gt; it = list.iterator();
        while(it.hasNext())&#123;
            if(&quot;cc&quot;.equals(it.next()))&#123;
                list.add(&quot;kk&quot;);
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<p>发现报错：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618173818117.png" class="">


<p>出错原因：就是迭代器和list同时对集合进行操作：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618173826503.png" class="">


<p>解决办法：事情让一个“人”做 –》引入新的迭代器：ListIterator<br>迭代和添加操作都是靠ListIterator来完成的：</p>
<pre><code class="java">package com.msb.test06;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.ListIterator;
/**
 * @author : msb-zhaoss
 */
public class Test2 &#123;
    //这是main方法，程序的入口
    public static void main(String[] args) &#123;
        ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();
        list.add(&quot;aa&quot;);
        list.add(&quot;bb&quot;);
        list.add(&quot;cc&quot;);
        list.add(&quot;dd&quot;);
        list.add(&quot;ee&quot;);
        //在&quot;cc&quot;之后添加一个字符串&quot;kk&quot;
        ListIterator&lt;String&gt; it = list.listIterator();
        while(it.hasNext())&#123;
            if(&quot;cc&quot;.equals(it.next()))&#123;
                it.add(&quot;kk&quot;);
            &#125;
        &#125;
        System.out.println(it.hasNext());
        System.out.println(it.hasPrevious());
        //逆向遍历：
        while(it.hasPrevious())&#123;
            System.out.println(it.previous());
        &#125;
        System.out.println(it.hasNext());
        System.out.println(it.hasPrevious());
        System.out.println(list);
    &#125;
&#125;
</code></pre>
<h2 id="3-Set接口"><a href="#3-Set接口" class="headerlink" title="3 Set接口"></a>3 Set接口</h2><h3 id="3-1-HashSet实现类的使用"><a href="#3-1-HashSet实现类的使用" class="headerlink" title="3.1 HashSet实现类的使用"></a>3.1 HashSet实现类的使用</h3><p>【1】放入Integer类型数据：</p>
<pre><code class="java">package com.msb.test07;
import java.util.HashSet;
/**
 * @author : msb-zhaoss
 */
public class TestInteger &#123;
    //这是main方法，程序的入口
    public static void main(String[] args) &#123;
        //创建一个HashSet集合：
        HashSet&lt;Integer&gt; hs = new HashSet&lt;&gt;();
        System.out.println(hs.add(19));//true
        hs.add(5);
        hs.add(20);
        System.out.println(hs.add(19));//false 这个19没有放入到集合中
        hs.add(41);
        hs.add(0);
        System.out.println(hs.size());//唯一，无序
        System.out.println(hs);
    &#125;
&#125;
</code></pre>
<p>【2】放入String类型数据：</p>
<pre><code class="java">package com.msb.test07;
import java.util.HashSet;
/**
 * @author : msb-zhaoss
 */
public class TestString &#123;
    //这是main方法，程序的入口
    public static void main(String[] args) &#123;
        //创建一个HashSet集合：
        HashSet&lt;String&gt; hs = new HashSet&lt;&gt;();
        hs.add(&quot;hello&quot;);
        hs.add(&quot;apple&quot;);
        hs.add(&quot;banana&quot;);
        hs.add(&quot;html&quot;);
        hs.add(&quot;apple&quot;);
        hs.add(&quot;css&quot;);
        System.out.println(hs.size());
        System.out.println(hs);
    &#125;
&#125;
</code></pre>
<p>【3】放入自定义的引用数据类型的数据：</p>
<pre><code class="java">package com.msb.test07;
import java.util.HashSet;
/**
 * @author : msb-zhaoss
 */
public class TestStudent &#123;
    //这是main方法，程序的入口
    public static void main(String[] args) &#123;
        //创建一个HashSet集合：
        HashSet&lt;Student&gt; hs = new HashSet&lt;&gt;();
        hs.add(new Student(19,&quot;lili&quot;));
        hs.add(new Student(20,&quot;lulu&quot;));
        hs.add(new Student(18,&quot;feifei&quot;));
        hs.add(new Student(19,&quot;lili&quot;));
        hs.add(new Student(10,&quot;nana&quot;));
        System.out.println(hs.size());
        System.out.println(hs);
    &#125;
&#125;
</code></pre>
<p>上面自定义的类型不满足 唯一，无序的特点。为什么呢？</p>
<p>【4】HashSet原理图：（简要原理图）</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618173954231.png" class="">


<p>【5】疑问：<br>1.数组的长度是多少。<br>2.数组的类型是什么？<br>3.hashCode，equals方法真的调用了吗？验证<br>4.底层表达式是什么？<br>5.同一个位置的数据 向前放  还是 向后放？<br>6.放入数组中的数据，是直接放的吗？是否封装为对象了？</p>
<h3 id="3-2LinkedHashSet使用"><a href="#3-2LinkedHashSet使用" class="headerlink" title="3.2LinkedHashSet使用"></a>3.2LinkedHashSet使用</h3><p>其实就是在HashSet的基础上，多了一个总的链表，这个总链表将放入的元素串在一起，方便有序的遍历：<br>（可以看到LinkedHashMap.Entry 继承自HashMap.Node 除了Node 本身有的几个属性外，额外增加了before after 用于指向前一个Entry 后一个Entry。也就是说，元素之间维持着一条总的链表数据结构。）</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618174059591.png" class="">


<pre><code class="java">package com.msb.test07;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
/**
 * @author : msb-zhaoss
 */
public class TestInteger &#123;
    //这是main方法，程序的入口
    public static void main(String[] args) &#123;
        //创建一个HashSet集合：
        LinkedHashSet&lt;Integer&gt; hs = new LinkedHashSet&lt;&gt;();
        System.out.println(hs.add(19));//true
        hs.add(5);
        hs.add(20);
        System.out.println(hs.add(19));//false 这个19没有放入到集合中
        hs.add(41);
        hs.add(0);
        System.out.println(hs.size());//唯一，无序
        System.out.println(hs);
    &#125;
&#125;
</code></pre>
<h3 id="3-3-比较器的使用"><a href="#3-3-比较器的使用" class="headerlink" title="3.3 比较器的使用"></a>3.3 比较器的使用</h3><p>【1】以int类型为案例：<br>比较的思路：将比较的数据做差，然后返回一个int类型的数据，将这个int类型的数值  按照 &#x3D;0  &gt;0  &lt;0</p>
<pre><code class="java">          int a = 10;
        int b = 20;
        System.out.println(a-b); // =0  &gt;0  &lt;0
</code></pre>
<p>【2】比较String类型数据：<br>String类实现了Comparable接口，这个接口中有一个抽象方法compareTo，String类中重写这个方法即可</p>
<pre><code class="java">          String a = &quot;A&quot;;
        String b = &quot;B&quot;;
        System.out.println(a.compareTo(b));
</code></pre>
<p>【3】比较double类型数据：</p>
<pre><code class="java">         double a = 9.6;
        double b = 9.3;
       /* System.out.println((int)(a-b));*/
        System.out.println(((Double) a).compareTo((Double) b));
</code></pre>
<p>【4】比较自定义的数据类型：<br>（1）内部比较器：</p>
<pre><code class="java">public class Student implements Comparable&lt;Student&gt;&#123;
    private int age;
    private double height;
    private String name;
    public int getAge() &#123;
        return age;
    &#125;
    public void setAge(int age) &#123;
        this.age = age;
    &#125;
    public double getHeight() &#123;
        return height;
    &#125;
    public void setHeight(double height) &#123;
        this.height = height;
    &#125;
    public String getName() &#123;
        return name;
    &#125;
    public void setName(String name) &#123;
        this.name = name;
    &#125;
    public Student(int age, double height, String name) &#123;
        this.age = age;
        this.height = height;
        this.name = name;
    &#125;
    @Override
    public String toString() &#123;
        return &quot;Student&#123;&quot; +
                &quot;age=&quot; + age +
                &quot;, height=&quot; + height +
                &quot;, name=&#39;&quot; + name + &#39;\&#39;&#39; +
                &#39;&#125;&#39;;
    &#125;
    @Override
    public int compareTo(Student o) &#123;
        //按照年龄进行比较：
        /*return this.getAge() - o.getAge();*/
        //按照身高比较
        /*return ((Double)(this.getHeight())).compareTo((Double)(o.getHeight()));*/
        //按照名字比较：
        return this.getName().compareTo(o.getName());
    &#125;
&#125;
</code></pre>
<pre><code class="java">public class Test02 &#123;
    //这是main方法，程序的入口
    public static void main(String[] args) &#123;
        //比较两个学生：
        Student s1 = new Student(14,160.5,&quot;alili&quot;);
        Student s2 = new Student(14,170.5,&quot;bnana&quot;);
        System.out.println(s1.compareTo(s2));
    &#125;
&#125;
</code></pre>
<p>（2）外部比较器：</p>
<pre><code class="java">public class Student&#123;
    private int age;
    private double height;
    private String name;
    public int getAge() &#123;
        return age;
    &#125;
    public void setAge(int age) &#123;
        this.age = age;
    &#125;
    public double getHeight() &#123;
        return height;
    &#125;
    public void setHeight(double height) &#123;
        this.height = height;
    &#125;
    public String getName() &#123;
        return name;
    &#125;
    public void setName(String name) &#123;
        this.name = name;
    &#125;
    public Student(int age, double height, String name) &#123;
        this.age = age;
        this.height = height;
        this.name = name;
    &#125;
    @Override
    public String toString() &#123;
        return &quot;Student&#123;&quot; +
                &quot;age=&quot; + age +
                &quot;, height=&quot; + height +
                &quot;, name=&#39;&quot; + name + &#39;\&#39;&#39; +
                &#39;&#125;&#39;;
    &#125;
&#125;
class BiJiao01 implements Comparator&lt;Student&gt; &#123;
    @Override
    public int compare(Student o1, Student o2) &#123;
        //比较年龄：
        return o1.getAge()-o2.getAge();
    &#125;
&#125;
class BiJiao02 implements Comparator&lt;Student&gt; &#123;
    @Override
    public int compare(Student o1, Student o2) &#123;
        //比较姓名：
        return o1.getName().compareTo(o2.getName());
    &#125;
&#125;
</code></pre>
<pre><code class="java">class BiJiao03 implements Comparator&lt;Student&gt; &#123;
    @Override
    public int compare(Student o1, Student o2) &#123;
        //在年龄相同的情况下 比较身高  年龄不同比较年龄
        if((o1.getAge()-o2.getAge())==0)&#123;
            return ((Double)(o1.getHeight())).compareTo((Double)(o2.getHeight()));
        &#125;else&#123;//年龄不一样
            return o1.getAge()-o2.getAge();
        &#125;
    &#125;
&#125;
</code></pre>
<pre><code class="java">public class Test02 &#123;
    //这是main方法，程序的入口
    public static void main(String[] args) &#123;
        //比较两个学生：
        Student s1 = new Student(9,160.5,&quot;alili&quot;);
        Student s2 = new Student(14,170.5,&quot;bnana&quot;);
        //获取外部比较器：
        Comparator bj1 = new BiJiao03();
        System.out.println(bj1.compare(s1, s2));
    &#125;
&#125;
</code></pre>
<p>【5】外部比较器和内部比较器 谁好呀？<br>答案：外部比较器，多态，扩展性好</p>
<h3 id="3-4-TreeSet实现类的使用"><a href="#3-4-TreeSet实现类的使用" class="headerlink" title="3.4 TreeSet实现类的使用"></a>3.4 TreeSet实现类的使用</h3><p>【1】存入Integer类型数据：（底层利用的是内部比较器）</p>
<pre><code class="java">package com.msb.test10;
import java.util.TreeSet;
/**
 * @author : msb-zhaoss
 */
public class Test01 &#123;
    //这是main方法，程序的入口
    public static void main(String[] args) &#123;
        //创建一个TreeSet:
        TreeSet&lt;Integer&gt; ts = new TreeSet&lt;&gt;();
        ts.add(12);
        ts.add(3);
        ts.add(7);
        ts.add(9);
        ts.add(3);
        ts.add(16);
        System.out.println(ts.size());
        System.out.println(ts);
    &#125;
&#125;
</code></pre>
<p>特点：唯一，无序（没有按照输入顺序进行输出）， 有序（按照升序进行遍历）</p>
<p>【2】原理：底层：二叉树（数据结构中的一个逻辑结构）</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618174503614.png" class="">


<p>【3】放入String类型数据：（底层实现类内部比较器）</p>
<pre><code class="java">public class Test02 &#123;
    //这是main方法，程序的入口
    public static void main(String[] args) &#123;
        //创建一个TreeSet:
        TreeSet&lt;String&gt; ts = new TreeSet&lt;&gt;();
        ts.add(&quot;elili&quot;);
        ts.add(&quot;blili&quot;);
        ts.add(&quot;alili&quot;);
        ts.add(&quot;elili&quot;);
        ts.add(&quot;clili&quot;);
        ts.add(&quot;flili&quot;);
        ts.add(&quot;glili&quot;);
        System.out.println(ts.size());
        System.out.println(ts);
    &#125;
&#125;
</code></pre>
<p>【4】想放入自定义的Student类型的数据：<br>（1）利用内部比较器：</p>
<pre><code class="java">public class Student implements Comparable&lt;Student&gt; &#123;
    private int age;
    private String name;
    public int getAge() &#123;
        return age;
    &#125;
    public void setAge(int age) &#123;
        this.age = age;
    &#125;
    public String getName() &#123;
        return name;
    &#125;
    public void setName(String name) &#123;
        this.name = name;
    &#125;
    public Student(int age, String name) &#123;
        this.age = age;
        this.name = name;
    &#125;
    @Override
    public String toString() &#123;
        return &quot;Student&#123;&quot; +
                &quot;age=&quot; + age +
                &quot;, name=&#39;&quot; + name + &#39;\&#39;&#39; +
                &#39;&#125;&#39;;
    &#125;
    @Override
    public int compareTo(Student o) &#123;
        return this.getAge()-o.getAge();
    &#125;
&#125;
</code></pre>
<pre><code class="java">public class Test03 &#123;
    //这是main方法，程序的入口
    public static void main(String[] args) &#123;
        //创建一个TreeSet:
        TreeSet&lt;Student&gt; ts = new TreeSet&lt;&gt;();
        ts.add(new Student(10,&quot;elili&quot;));
        ts.add(new Student(8,&quot;blili&quot;));
        ts.add(new Student(4,&quot;alili&quot;));
        ts.add(new Student(9,&quot;elili&quot;));
        ts.add(new Student(10,&quot;flili&quot;));
        ts.add(new Student(1,&quot;dlili&quot;));
        System.out.println(ts.size());
        System.out.println(ts);
    &#125;
&#125;
</code></pre>
<p>（2）通过外部比较器：</p>
<pre><code class="java">public class Student  &#123;
    private int age;
    private String name;
    public int getAge() &#123;
        return age;
    &#125;
    public void setAge(int age) &#123;
        this.age = age;
    &#125;
    public String getName() &#123;
        return name;
    &#125;
    public void setName(String name) &#123;
        this.name = name;
    &#125;
    public Student(int age, String name) &#123;
        this.age = age;
        this.name = name;
    &#125;
    @Override
    public String toString() &#123;
        return &quot;Student&#123;&quot; +
                &quot;age=&quot; + age +
                &quot;, name=&#39;&quot; + name + &#39;\&#39;&#39; +
                &#39;&#125;&#39;;
    &#125;
&#125;
class BiJiao implements Comparator&lt;Student&gt;&#123;
    @Override
    public int compare(Student o1, Student o2) &#123;
        return o1.getName().compareTo(o2.getName());
    &#125;
&#125;
</code></pre>
<pre><code class="java">public class Test03 &#123;
    //这是main方法，程序的入口
    public static void main(String[] args) &#123;
        //创建一个TreeSet:
        //利用外部比较器，必须自己制定：
        Comparator&lt;Student&gt; com = new BiJiao();
        TreeSet&lt;Student&gt; ts = new TreeSet&lt;&gt;(com);//一旦指定外部比较器，那么就会按照外部比较器来比较
        ts.add(new Student(10,&quot;elili&quot;));
        ts.add(new Student(8,&quot;blili&quot;));
        ts.add(new Student(4,&quot;alili&quot;));
        ts.add(new Student(9,&quot;elili&quot;));
        ts.add(new Student(10,&quot;flili&quot;));
        ts.add(new Student(1,&quot;dlili&quot;));
        System.out.println(ts.size());
        System.out.println(ts);
    &#125;
&#125;
</code></pre>
<p>实际开发中利用外部比较器多，因为扩展性好（多态）</p>
<p>换一种写法：</p>
<pre><code class="java">public class Test03 &#123;
    //这是main方法，程序的入口
    public static void main(String[] args) &#123;
        //创建一个TreeSet:
        //利用外部比较器，必须自己制定：
        /*Comparator&lt;Student&gt; com = new Comparator&lt;Student&gt;() &#123;
            @Override
            public int compare(Student o1, Student o2) &#123;
                return o1.getName().compareTo(o2.getName());
            &#125;
        &#125;;*/
        TreeSet&lt;Student&gt; ts = new TreeSet&lt;&gt;(new Comparator&lt;Student&gt;() &#123;
            @Override
            public int compare(Student o1, Student o2) &#123;
                return o1.getName().compareTo(o2.getName());
            &#125;
        &#125;);//一旦指定外部比较器，那么就会按照外部比较器来比较
        ts.add(new Student(10,&quot;elili&quot;));
        ts.add(new Student(8,&quot;blili&quot;));
        ts.add(new Student(4,&quot;alili&quot;));
        ts.add(new Student(9,&quot;elili&quot;));
        ts.add(new Student(10,&quot;flili&quot;));
        ts.add(new Student(1,&quot;dlili&quot;));
        System.out.println(ts.size());
        System.out.println(ts);
    &#125;
&#125;
</code></pre>
<p>【5】TreeSet底层的二叉树的遍历是按照升序的结果出现的，这个升序是靠中序遍历得到的：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618174642838.png" class="">






<h3 id="3-5-Collection部分整体结构图"><a href="#3-5-Collection部分整体结构图" class="headerlink" title="3.5 Collection部分整体结构图"></a>3.5 Collection部分整体结构图</h3><img data-src="/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618174657969.png" class="">






<h1 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a>Map接口</h1><h2 id="1-常用方法"><a href="#1-常用方法" class="headerlink" title="1 常用方法"></a>1 常用方法</h2><pre><code class="java">package com.msb.test11;
import java.util.Collection;
import java.util.HashMap;
import java.util.Map;
import java.util.Set;
/**
 * @author : msb-zhaoss
 */
public class Test01 &#123;
    //这是main方法，程序的入口
    public static void main(String[] args) &#123;
        /*
        增加：put(K key, V value)
        删除：clear() remove(Object key)
        修改：
        查看：entrySet() get(Object key) keySet() size() values()
        判断：containsKey(Object key) containsValue(Object value)
            equals(Object o) isEmpty()
         */
        //创建一个Map集合：无序，唯一
        Map&lt;String,Integer&gt; map = new HashMap&lt;&gt;();
        System.out.println(map.put(&quot;lili&quot;, 10101010));
        map.put(&quot;nana&quot;,12345234);
        map.put(&quot;feifei&quot;,34563465);
        System.out.println(map.put(&quot;lili&quot;, 34565677));
        map.put(&quot;mingming&quot;,12323);
        /*map.clear();清空*/
        /*map.remove(&quot;feifei&quot;);移除*/
        System.out.println(map.size());
        System.out.println(map);
        System.out.println(map.containsKey(&quot;lili&quot;));
        System.out.println(map.containsValue(12323));
        Map&lt;String,Integer&gt; map2 = new HashMap&lt;&gt;();
        System.out.println(map2.put(&quot;lili&quot;, 10101010));
        map2.put(&quot;nana&quot;,12345234);
        map2.put(&quot;feifei&quot;,34563465);
        System.out.println(map2.put(&quot;lili&quot;, 34565677));
        map2.put(&quot;mingming2&quot;,12323);
        System.out.println(map==map2);
        System.out.println(map.equals(map2));//equals进行了重写，比较的是集合中的值是否一致
        System.out.println(&quot;判断是否为空：&quot;+map.isEmpty());
        System.out.println(map.get(&quot;nana&quot;));
        System.out.println(&quot;-----------------------------------&quot;);
        //keySet()对集合中的key进行遍历查看：
        Set&lt;String&gt; set = map.keySet();
        for(String s:set)&#123;
            System.out.println(s);
        &#125;
        System.out.println(&quot;-----------------------------------&quot;);
        //values()对集合中的value进行遍历查看：
        Collection&lt;Integer&gt; values = map.values();
        for(Integer i:values)&#123;
            System.out.println(i);
        &#125;
        System.out.println(&quot;-----------------------------------&quot;);
        //get(Object key) keySet()
        Set&lt;String&gt; set2 = map.keySet();
        for(String s:set2)&#123;
            System.out.println(map.get(s));
        &#125;
        System.out.println(&quot;-----------------------------------&quot;);
        //entrySet()
        Set&lt;Map.Entry&lt;String, Integer&gt;&gt; entries = map.entrySet();
        for(Map.Entry&lt;String, Integer&gt; e:entries)&#123;
            System.out.println(e.getKey()+&quot;----&quot;+e.getValue());
        &#125;
    &#125;
&#125;
</code></pre>
<h2 id="2-TreeMap"><a href="#2-TreeMap" class="headerlink" title="2 TreeMap"></a>2 TreeMap</h2><p>【1】key的类型为String类型：</p>
<pre><code class="java">public class Test02 &#123;
    //这是main方法，程序的入口
    public static void main(String[] args) &#123;
        Map&lt;String,Integer&gt; map = new TreeMap&lt;&gt;();
        map.put(&quot;blili&quot;,1234);
        map.put(&quot;alili&quot;,2345);
        map.put(&quot;blili&quot;,5467);
        map.put(&quot;clili&quot;,5678);
        map.put(&quot;dlili&quot;,2345);
        System.out.println(map.size());
        System.out.println(map);
    &#125;
&#125;
</code></pre>
<p>【2】key的类型是一个自定义的引用数据类型：<br>（1）内部比较器：</p>
<pre><code class="java">public class Test03 &#123;
    //这是main方法，程序的入口
    public static void main(String[] args) &#123;
        Map&lt;Student,Integer&gt; map = new TreeMap&lt;&gt;();
        map.put(new Student(19,&quot;blili&quot;,170.5),1001);
        map.put(new Student(18,&quot;blili&quot;,150.5),1003);
        map.put(new Student(19,&quot;alili&quot;,180.5),1023);
        map.put(new Student(17,&quot;clili&quot;,140.5),1671);
        map.put(new Student(10,&quot;dlili&quot;,160.5),1891);
        System.out.println(map);
        System.out.println(map.size());
    &#125;
&#125;
</code></pre>
<pre><code class="java">public class Student implements Comparable&lt;Student&gt;&#123;
    private int age;
    private String name;
    private double height;
    public int getAge() &#123;
        return age;
    &#125;
    public void setAge(int age) &#123;
        this.age = age;
    &#125;
    public String getName() &#123;
        return name;
    &#125;
    public void setName(String name) &#123;
        this.name = name;
    &#125;
    public double getHeight() &#123;
        return height;
    &#125;
    public void setHeight(double height) &#123;
        this.height = height;
    &#125;
    public Student(int age, String name, double height) &#123;
        this.age = age;
        this.name = name;
        this.height = height;
    &#125;
    @Override
    public String toString() &#123;
        return &quot;Student&#123;&quot; +
                &quot;age=&quot; + age +
                &quot;, name=&#39;&quot; + name + &#39;\&#39;&#39; +
                &quot;, height=&quot; + height +
                &#39;&#125;&#39;;
    &#125;
    @Override
    public int compareTo(Student o) &#123;
       /* return this.getAge()-o.getAge();*/
        return this.getName().compareTo(o.getName());
    &#125;
&#125;
</code></pre>
<p>（2）外部比较器：</p>
<pre><code class="java">public class Test03 &#123;
    //这是main方法，程序的入口
    public static void main(String[] args) &#123;
        Map&lt;Student,Integer&gt; map = new TreeMap&lt;&gt;(new Comparator&lt;Student&gt;() &#123;
            @Override
            public int compare(Student o1, Student o2) &#123;
                return ((Double)(o1.getHeight())).compareTo((Double)(o2.getHeight()));
            &#125;
        &#125;);
        map.put(new Student(19,&quot;blili&quot;,170.5),1001);
        map.put(new Student(18,&quot;blili&quot;,150.5),1003);
        map.put(new Student(19,&quot;alili&quot;,180.5),1023);
        map.put(new Student(17,&quot;clili&quot;,140.5),1671);
        map.put(new Student(10,&quot;dlili&quot;,160.5),1891);
        System.out.println(map);
        System.out.println(map.size());
    &#125;
&#125;
</code></pre>
<h2 id="3-Map部分整体结构图"><a href="#3-Map部分整体结构图" class="headerlink" title="3 Map部分整体结构图"></a>3 Map部分整体结构图</h2><img data-src="/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618174919194.png" class="">


<h2 id="4-源码部分"><a href="#4-源码部分" class="headerlink" title="4 源码部分"></a>4 源码部分</h2><h3 id="4-1-HashMap"><a href="#4-1-HashMap" class="headerlink" title="4.1 HashMap"></a>4.1 HashMap</h3><h4 id="4-1-1-代码展示特性"><a href="#4-1-1-代码展示特性" class="headerlink" title="4.1.1 代码展示特性"></a>4.1.1 代码展示特性</h4><pre><code class="java">public class Test &#123;
    //这是main方法，程序的入口
    public static void main(String[] args) &#123;
        //JDK1.7以后支持后面的&lt;&gt;中内容可以不写
        HashMap&lt;Integer,String&gt; hm = new HashMap&lt;&gt;();
        System.out.println(hm.put(12,&quot;丽丽&quot;));
        System.out.println(hm.put(7,&quot;菲菲&quot;));
        System.out.println(hm.put(19,&quot;露露&quot;));
        System.out.println(hm.put(12,&quot;明明&quot;));
        System.out.println(hm.put(6,&quot;莹莹&quot;));
        System.out.println(&quot;集合的长度：&quot;+hm.size());
        System.out.println(&quot;集合中内容查看：&quot;+hm);
    &#125;
&#125;
</code></pre>
<p>结果展示：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618175455959.png" class="">






<h4 id="4-1-2-先演示原理"><a href="#4-1-2-先演示原理" class="headerlink" title="4.1.2 先演示原理"></a>4.1.2 先演示原理</h4><p>先演示原理图，再看源码，直接看的话，有的人接不上就蒙了：<br>相当于先看原理，然后从源码中验证这个原理是否正确：把图搞懂了，就是事倍功半的效果<br>原理如下：(JDK1.7)</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618175512371.png" class="">






<h4 id="4-1-3-源码（JDK1-7版本）"><a href="#4-1-3-源码（JDK1-7版本）" class="headerlink" title="4.1.3 源码（JDK1.7版本）"></a>4.1.3 源码（JDK1.7版本）</h4><pre><code class="java">public class HashMap&lt;K,V&gt;
    extends AbstractMap&lt;K,V&gt; //【1】继承的AbstractMap中，已经实现了Map接口
        //【2】又实现了这个接口，多余，但是设计者觉得没有必要删除，就这么地了
    implements Map&lt;K,V&gt;, Cloneable, Serializable&#123;
                
                
        //【3】后续会用到的重要属性：先粘贴过来：
    static final int DEFAULT_INITIAL_CAPACITY = 16;//哈希表主数组的默认长度
        //定义了一个float类型的变量，以后作为：默认的装填因子，加载因子是表示Hsah表中元素的填满的程度
        //太大容易引起哈西冲突，太小容易浪费  0.75是经过大量运算后得到的最好值
        //这个值其实可以自己改，但是不建议改，因为这个0.75是大量运算得到的
        static final float DEFAULT_LOAD_FACTOR = 0.75f;
        transient Entry&lt;K,V&gt;[] table;//主数组,每个元素为Entry类型
        transient int size;
        int threshold;//数组扩容的界限值,门槛值   16*0.75=12 
        final float loadFactor;//用来接收装填因子的变量
        
        //【4】查看构造器：内部相当于：this(16,0.75f);调用了当前类中的带参构造器
        public HashMap() &#123;
        this(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR);
    &#125;
        //【5】本类中带参数构造器：--》作用给一些数值进行初始化的！
        public HashMap(int initialCapacity, float loadFactor) &#123;
        //【6】给capacity赋值，capacity的值一定是 大于你传进来的initialCapacity 的 最小的 2的倍数
        int capacity = 1;
        while (capacity &lt; initialCapacity)
            capacity &lt;&lt;= 1;
                //【7】给loadFactor赋值，将装填因子0.75赋值给loadFactor
        this.loadFactor = loadFactor;
                //【8】数组扩容的界限值,门槛值
        threshold = (int)Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + 1);
                
                //【9】给table数组赋值，初始化数组长度为16
        table = new Entry[capacity];
                   
    &#125;
        //【10】调用put方法：
        public V put(K key, V value) &#123;
                //【11】对空值的判断
        if (key == null)
            return putForNullKey(value);
                //【12】调用hash方法，获取哈希码
        int hash = hash(key);
                //【14】得到key对应在数组中的位置
        int i = indexFor(hash, table.length);
                //【16】如果你放入的元素，在主数组那个位置上没有值，e==null  那么下面这个循环不走
                //当在同一个位置上放入元素的时候
        for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123;
            Object k;
                        //哈希值一样  并且  equals相比一样   
                        //(k = e.key) == key  如果是一个对象就不用比较equals了
            if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;
                V oldValue = e.value;
                e.value = value;
                e.recordAccess(this);
                return oldValue;
            &#125;
        &#125;
        modCount++;
                //【17】走addEntry添加这个节点的方法：
        addEntry(hash, key, value, i);
        return null;
    &#125;
        
        //【13】hash方法返回这个key对应的哈希值，内部进行二次散列，为了尽量保证不同的key得到不同的哈希码！
        final int hash(Object k) &#123;
        int h = 0;
        if (useAltHashing) &#123;
            if (k instanceof String) &#123;
                return sun.misc.Hashing.stringHash32((String) k);
            &#125;
            h = hashSeed;
        &#125;
                //k.hashCode()函数调用的是key键值类型自带的哈希函数，
                //由于不同的对象其hashCode()有可能相同，所以需对hashCode()再次哈希，以降低相同率。
        h ^= k.hashCode();
        // This function ensures that hashCodes that differ only by
        // constant multiples at each bit position have a bounded
        // number of collisions (approximately 8 at default load factor).
                /*
                接下来的一串与运算和异或运算，称之为“扰动函数”，
                扰动的核心思想在于使计算出来的值在保留原有相关特性的基础上，
                增加其值的不确定性，从而降低冲突的概率。
                不同的版本实现的方式不一样，但其根本思想是一致的。
                往右移动的目的，就是为了将h的高位利用起来，减少哈西冲突
                */
        h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12);
        return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);
    &#125;
        //【15】返回int类型数组的坐标
        static int indexFor(int h, int length) &#123;
                //其实这个算法就是取模运算：h%length，取模效率不如位运算
        return h &amp; (length-1);
    &#125;
        //【18】调用addEntry
        void addEntry(int hash, K key, V value, int bucketIndex) &#123;
                //【25】size的大小  大于 16*0.75=12的时候，比如你放入的是第13个，这第13个你打算放在没有元素的位置上的时候
        if ((size &gt;= threshold) &amp;&amp; (null != table[bucketIndex])) &#123;
                        //【26】主数组扩容为2倍
            resize(2 * table.length);
                        //【30】重新调整当前元素的hash码
            hash = (null != key) ? hash(key) : 0;
                        //【31】重新计算元素位置
            bucketIndex = indexFor(hash, table.length);
        &#125;
                //【19】将hash,key,value,bucketIndex位置  封装为一个Entry对象：
        createEntry(hash, key, value, bucketIndex);
    &#125;
        //【20】
        void createEntry(int hash, K key, V value, int bucketIndex) &#123;
                //【21】获取bucketIndex位置上的元素给e
        Entry&lt;K,V&gt; e = table[bucketIndex];
                //【22】然后将hash, key, value封装为一个对象，然后将下一个元素的指向为e （链表的头插法）
                //【23】将新的Entry放在table[bucketIndex]的位置上
        table[bucketIndex] = new Entry&lt;&gt;(hash, key, value, e);
                //【24】集合中加入一个元素 size+1
        size++;
    &#125;
    //【27】
        void resize(int newCapacity) &#123;
        Entry[] oldTable = table;
        int oldCapacity = oldTable.length;
        if (oldCapacity == MAXIMUM_CAPACITY) &#123;
            threshold = Integer.MAX_VALUE;
            return;
        &#125;
                //【28】创建长度为newCapacity的数组
        Entry[] newTable = new Entry[newCapacity];
        boolean oldAltHashing = useAltHashing;
        useAltHashing |= sun.misc.VM.isBooted() &amp;&amp;
                (newCapacity &gt;= Holder.ALTERNATIVE_HASHING_THRESHOLD);
        boolean rehash = oldAltHashing ^ useAltHashing;
                //【28.5】转让方法：将老数组中的东西都重新放入新数组中
        transfer(newTable, rehash);
                //【29】老数组替换为新数组
        table = newTable;
                //【29.5】重新计算
        threshold = (int)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + 1);
    &#125;
        //【28.6】
        void transfer(Entry[] newTable, boolean rehash) &#123;
        int newCapacity = newTable.length;
        for (Entry&lt;K,V&gt; e : table) &#123;
            while(null != e) &#123;
                Entry&lt;K,V&gt; next = e.next;
                if (rehash) &#123;
                    e.hash = null == e.key ? 0 : hash(e.key);
                &#125;
                                //【28.7】将哈希值，和新的数组容量传进去，重新计算key在新数组中的位置
                int i = indexFor(e.hash, newCapacity);
                                //【28.8】头插法
                e.next = newTable[i];//获取链表上元素给e.next
                newTable[i] = e;//然后将e放在i位置 
                e = next;//e再指向下一个节点继续遍历
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<h4 id="4-1-4-细节讲解：主数组的长度为2的倍数"><a href="#4-1-4-细节讲解：主数组的长度为2的倍数" class="headerlink" title="4.1.4  细节讲解：主数组的长度为2的倍数"></a>4.1.4  细节讲解：主数组的长度为2的倍数</h4><p>【1】主数组的长度为2的倍数，</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618175628889.png" class="">


<p>因为这个length的长度，会影响 key的位置：<br>key的位置的计算：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618175638657.png" class="">




<p>实际上这个算法就是：  h%length   ,但是取模的话  效率太低，所以用位运算效率会很高。</p>
<p><strong>原因1：</strong><br><img data-src="/img/image-20220618175703663.png" alt="image-20220618175703663">和<img data-src="/img/image-20220618175712379.png" alt="image-20220618175712379">等效的前提就是  length必须是2的整数倍<br><strong>原因2：</strong></p>
<p>如果不是2的整数倍，那么 哈西碰撞 哈西冲突的概率就高了很多</p>
<p>位运算 就  涉及  到  length是不是2的整数倍：<br>比如是2的整数倍：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618175753914.png" class="">


<img data-src="/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618175800521.png" class="">


<p>并且这个得到的索引值，一定在 0-15之间（数组是16的时候）：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618175840905.png" class="">


<p>当然如果你扩容后数组长度为 32，那么这个索引就在0-31之间</p>
<p>比如如果不是2的整数倍：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618175850530.png" class="">


<p>发现：如果不是2的整数倍，那么 哈西碰撞 哈西冲突的概率就高了很多</p>
<h4 id="4-1-5-细节讲解：装填因子0-75的原因"><a href="#4-1-5-细节讲解：装填因子0-75的原因" class="headerlink" title="4.1.5 细节讲解：装填因子0.75的原因"></a>4.1.5 细节讲解：装填因子0.75的原因</h4><p>如果装填因子是1， 那么数组满了再扩容，可以做到  最大的空间利用率<br>但是这是一个理想状态，元素不可能完全的均匀分布，很可能就哈西碰撞产生链表了。产生链表的话 查询时间就长了。<br>—》空间好，时间不好</p>
<p>那么有人说 ，把装填因子搞小一点，0.5，  如果是0.5的话，就浪费空间，但是可以做到 到0.5就扩容 ，然后哈西碰撞就少，<br>不产生链表的话，那么查询效率很高<br>—》时间好，空间不好</p>
<p>所以在空间和时间中，<br>取中间值，平衡这个因素 就取值为 0.75</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618175921895.png" class="">


<p><strong>1.8版本</strong></p>
<h2 id="1-8底层遵照-哈希表结构-红黑树"><a href="#1-8底层遵照-哈希表结构-红黑树" class="headerlink" title="1.8底层遵照 哈希表结构 + 红黑树"></a>1.8底层遵照 <font color=red >哈希表结构 + 红黑树</font></h2><pre><code class="java">// HashMap&lt;String,Integer&gt; map = new HashMap&lt;&gt;(); --&gt;JDK 1.7开始类型推断，后面用钻石运算符即可。
public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; 		//【1】继承的AbstractMap中，已经实现了Map接口
    implements Map&lt;K,V&gt;, Cloneable, Serializable &#123; //【2】又实现了这个接口，多余，但是集合的设计者觉得没有必要删除，就这么地了

    //------------------属性部分：
    final float loadFactor;//【3-2】用来接收装填因子的变量
    /*
        【3-3】
        定义了一个float类型的变量，以后作为：默认的装填因子，加载因子是表示Hsah表中元素的填满的程度
        太大容易引起哈西冲突，太小容易浪费  0.75是经过大量运算后得到的最好值
        这个值其实可以自己改，但是不建议改，因为这个0.75是大量运算得到的
    */
    static final float DEFAULT_LOAD_FACTOR = 0.75f;
    int threshold;//【6-3】数组扩容的界限值,门槛值
    transient Node&lt;K,V&gt;[] table;//【7-5】底层主数组
    //------------------构造器：
    //【3】调用空构造器
    public HashMap() &#123;
        //【3-1】给装填因子loadFactor赋值
        this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted
    &#125;
    
    //【4】调用有参构造器：
    public HashMap(int initialCapacity) &#123;
        //【5】调用两个参数构造器
        this(initialCapacity, DEFAULT_LOAD_FACTOR);
    &#125;
    //【6】
    public HashMap(int initialCapacity, float loadFactor) &#123;
        //【6-1】健壮性考虑，传入的数据过小不行，过大不行
        if (initialCapacity &lt; 0)
            throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; +
                                               initialCapacity);
        if (initialCapacity &gt; MAXIMUM_CAPACITY)
            initialCapacity = MAXIMUM_CAPACITY;
        if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))
            throw new IllegalArgumentException(&quot;Illegal load factor: &quot; +
                                               loadFactor);
        //【6-2】给装填因子loadFactor赋值，赋值为0.75，这个值可以单独传入改变，但是不建议改变，一般都用默认的0.75
        this.loadFactor = loadFactor;
        //【6-3】给threshold赋值 
        this.threshold = tableSizeFor(initialCapacity);
    &#125;
    //【6-4】返回的是大于initialCapacity的最接近的2的整数倍  ，比如initialCapacity传入10，这个方法返回16
    static final int tableSizeFor(int cap) &#123;//（内部内容讲源码时候不用管，面试题中详讲）
        int n = cap - 1;
        n |= n &gt;&gt;&gt; 1;
        n |= n &gt;&gt;&gt; 2;
        n |= n &gt;&gt;&gt; 4;
        n |= n &gt;&gt;&gt; 8;
        n |= n &gt;&gt;&gt; 16;
        return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;
    &#125;
    
    //------------------方法：
    //【7】调用put方法
    public V put(K key, V value) &#123;
        //【7-1】首先调用hash方法计算哈希值：
        //【7-3】调用putVal方法传入五个参数：
        return putVal(hash(key), key, value, false, true);
    &#125;
    //【7-2】计算hash值
    static final int hash(Object key) &#123;
        int h;
        return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);
    &#125;
    //【7-4】调用
    final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
                   boolean evict) &#123;
        Node&lt;K,V&gt;[] tab;
        Node&lt;K,V&gt; p; 
        int n, i;
        //【7-6】将底层主数组table给tab，判断是否为null，第一次放数据一定是null
        if ((tab = table) == null || (n = tab.length) == 0)
            //【7-7】走入if分支：table是null，就对table进行扩容，走进resize方法
            n = (tab = resize()).length;//【7-21】table的length为16 ，n为16
        /*
        【7-22】
        i = (n - 1) &amp; hash 根据哈希值和n计算放入数组的位置
        取出这个位置上的元素，看是否为空，如果是第一个元素，一定是null
        */
        if ((p = tab[i = (n - 1) &amp; hash]) == null)
            //【7-23】在这个位置上将元素封装为Node对象，放入对应位置
            tab[i] = newNode(hash, key, value, null);//封装Node节点new Node&lt;&gt;(hash, key, value, null);
        else &#123;
            Node&lt;K,V&gt; e; K k;
            if (p.hash == hash &amp;&amp;
                ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))
                e = p;
            else if (p instanceof TreeNode)
                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);
            else &#123;
                for (int binCount = 0; ; ++binCount) &#123;
                    if ((e = p.next) == null) &#123;
                        p.next = newNode(hash, key, value, null);
                        if (binCount &gt;= TREEIFY_THRESHOLD - 1)  
                            treeifyBin(tab, hash);
                        break;
                    &#125;
                    if (e.hash == hash &amp;&amp;
                        ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))
                        break;
                    p = e;
                &#125;
            &#125;
            if (e != null) &#123;  
                V oldValue = e.value;
                if (!onlyIfAbsent || oldValue == null)
                    e.value = value;
                afterNodeAccess(e);
                return oldValue;
            &#125;
        &#125;
        ++modCount;
        //【7-25】size指的是放入集合的键值总数，size++操作，不大于threshold，resize方法不走
        if (++size &gt; threshold)
            resize();
        afterNodeInsertion(evict);
        return null;
    &#125;
    //【7-8】resize方法：---》假设最开始走的是HashMap的空构造器：
    final Node&lt;K,V&gt;[] resize() &#123;
        Node&lt;K,V&gt;[] oldTab = table;//【7-9】table 是null
        int oldCap = (oldTab == null) ? 0 : oldTab.length; //【7-10】oldCap:0
        int oldThr = threshold;//【7-11】threshold为16，oldThr：16
        int newCap, newThr = 0;
        if (oldCap &gt; 0) &#123;//【7-12】不走
            if (oldCap &gt;= MAXIMUM_CAPACITY) &#123;
                threshold = Integer.MAX_VALUE;
                return oldTab;
            &#125;
            else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;
                     oldCap &gt;= DEFAULT_INITIAL_CAPACITY)
                newThr = oldThr &lt;&lt; 1;
        &#125;
        else if (oldThr &gt; 0)  //【7-13】走
            newCap = oldThr;//newCap=16
        else &#123;               //【7-14】不走
             
            newCap = DEFAULT_INITIAL_CAPACITY;
             
            newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);
        &#125;
        if (newThr == 0) &#123;//【7-15】走
            float ft = (float)newCap * loadFactor;//【7-16】ft: 16*0.75=12
            newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?
                      (int)ft : Integer.MAX_VALUE); //【7-17】newThr = 12
        &#125;
        //【7-18】threshold赋值为newThr为12， ---》所以走空构造器这里threshold赋值为12，走有参构造器里面threshold赋值为12？？？？
        threshold = newThr;
        @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)
        //【7-19】创建Node数组，长度为newCap16
            Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];
        //【7-20】table赋值为newTab
        table = newTab;
        if (oldTab != null) &#123;
            for (int j = 0; j &lt; oldCap; ++j) &#123;
                Node&lt;K,V&gt; e;
                if ((e = oldTab[j]) != null) &#123;
                    oldTab[j] = null;
                    if (e.next == null)
                        newTab[e.hash &amp; (newCap - 1)] = e;
                    else if (e instanceof TreeNode)
                        ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);
                    else &#123; 
                        Node&lt;K,V&gt; loHead = null, loTail = null;
                        Node&lt;K,V&gt; hiHead = null, hiTail = null;
                        Node&lt;K,V&gt; next;
                        do &#123;
                            next = e.next;
                            if ((e.hash &amp; oldCap) == 0) &#123;
                                if (loTail == null)
                                    loHead = e;
                                else
                                    loTail.next = e;
                                loTail = e;
                            &#125;
                            else &#123;
                                if (hiTail == null)
                                    hiHead = e;
                                else
                                    hiTail.next = e;
                                hiTail = e;
                            &#125;
                        &#125; while ((e = next) != null);
                        if (loTail != null) &#123;
                            loTail.next = null;
                            newTab[j] = loHead;
                        &#125;
                        if (hiTail != null) &#123;
                            hiTail.next = null;
                            newTab[j + oldCap] = hiHead;
                        &#125;
                    &#125;
                &#125;
            &#125;
        &#125;
        return newTab;
    &#125;
&#125;
</code></pre>
<pre><code class="java">public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; 
    implements Map&lt;K,V&gt;, Cloneable, Serializable &#123; 
    final float loadFactor;
    static final float DEFAULT_LOAD_FACTOR = 0.75f;
    int threshold;
    transient Node&lt;K,V&gt;[] table;
    public HashMap() &#123;
        this.loadFactor = DEFAULT_LOAD_FACTOR; 
    &#125;
    
    public HashMap(int initialCapacity) &#123;
        this(initialCapacity, DEFAULT_LOAD_FACTOR);
    &#125;
    public HashMap(int initialCapacity, float loadFactor) &#123;
        if (initialCapacity &lt; 0)
            throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; +
                                               initialCapacity);
        if (initialCapacity &gt; MAXIMUM_CAPACITY)
            initialCapacity = MAXIMUM_CAPACITY;
        if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))
            throw new IllegalArgumentException(&quot;Illegal load factor: &quot; +
                                               loadFactor);
        this.loadFactor = loadFactor;
        this.threshold = tableSizeFor(initialCapacity);
    &#125;
    static final int tableSizeFor(int cap) &#123;
        int n = cap - 1;
        n |= n &gt;&gt;&gt; 1;
        n |= n &gt;&gt;&gt; 2;
        n |= n &gt;&gt;&gt; 4;
        n |= n &gt;&gt;&gt; 8;
        n |= n &gt;&gt;&gt; 16;
        return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;
    &#125;
    
    //【8-1】put方法
    public V put(K key, V value) &#123;
        //计算hash值
        return putVal(hash(key), key, value, false, true);
    &#125;

    static final int hash(Object key) &#123;
        int h;
        return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);
    &#125;
    //【8-2】调用putVal方法
    final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
                   boolean evict) &#123;
        Node&lt;K,V&gt;[] tab;
        Node&lt;K,V&gt; p; 
        int n, i;
        
        //【8-3】table不空了，不走if		
        if ((tab = table) == null || (n = tab.length) == 0)
            n = (tab = resize()).length;
        //【8-4】tab[i]不null，不走if
        if ((p = tab[i = (n - 1) &amp; hash]) == null)
            tab[i] = newNode(hash, key, value, null);
        else &#123;
            Node&lt;K,V&gt; e; K k;
            /*
                【8-5】
                判断p.hash == hash哈希值是否相等，即使hash相等也要做&amp;&amp;后续的判断，因为两个对象哈希值相等是有可能的
                (k = p.key) == key   == 比较地址值，String的话一样，不是字符串地址也不一样，
                Animal a1 = new Animal(19);		和 	Animal a2 = new Animal(19);	地址一定不同，就需要用后面的equals进行比较
            */
            if (p.hash == hash &amp;&amp;
                ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))   //----》哈希值相等，出现哈西碰撞
                //【8-6】将该数组位置的数据给e
                e = p;
            else if (p instanceof TreeNode)
                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);
            else &#123;
                for (int binCount = 0; ; ++binCount) &#123;
                    if ((e = p.next) == null) &#123;
                        p.next = newNode(hash, key, value, null);
                        if (binCount &gt;= TREEIFY_THRESHOLD - 1)  
                            treeifyBin(tab, hash);
                        break;
                    &#125;
                    if (e.hash == hash &amp;&amp;
                        ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))
                        break;
                    p = e;
                &#125;
            &#125;
            if (e != null) &#123;  
                V oldValue = e.value;
                if (!onlyIfAbsent || oldValue == null)
                    e.value = value;//【8-7】新value替换老value
                afterNodeAccess(e);
                return oldValue;//【8-8】返回老value
            &#125;
        &#125;
        ++modCount;

        if (++size &gt; threshold)
            resize();
        afterNodeInsertion(evict);
        return null;
    &#125;

    final Node&lt;K,V&gt;[] resize() &#123;
        Node&lt;K,V&gt;[] oldTab = table;
        int oldCap = (oldTab == null) ? 0 : oldTab.length; 
        int oldThr = threshold;
        int newCap, newThr = 0;
        if (oldCap &gt; 0) &#123;
            if (oldCap &gt;= MAXIMUM_CAPACITY) &#123;
                threshold = Integer.MAX_VALUE;
                return oldTab;
            &#125;
            else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;
                     oldCap &gt;= DEFAULT_INITIAL_CAPACITY)
                newThr = oldThr &lt;&lt; 1;
        &#125;
        else if (oldThr &gt; 0) 
            newCap = oldThr;
        else &#123;    
            newCap = DEFAULT_INITIAL_CAPACITY;
            newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);
        &#125;
        if (newThr == 0) &#123;
            float ft = (float)newCap * loadFactor;
            newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?
                      (int)ft : Integer.MAX_VALUE);
        &#125;
        threshold = newThr;
        @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)
            Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];
        table = newTab;
        if (oldTab != null) &#123;
            for (int j = 0; j &lt; oldCap; ++j) &#123;
                Node&lt;K,V&gt; e;
                if ((e = oldTab[j]) != null) &#123;
                    oldTab[j] = null;
                    if (e.next == null)
                        newTab[e.hash &amp; (newCap - 1)] = e;
                    else if (e instanceof TreeNode)
                        ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);
                    else &#123; 
                        Node&lt;K,V&gt; loHead = null, loTail = null;
                        Node&lt;K,V&gt; hiHead = null, hiTail = null;
                        Node&lt;K,V&gt; next;
                        do &#123;
                            next = e.next;
                            if ((e.hash &amp; oldCap) == 0) &#123;
                                if (loTail == null)
                                    loHead = e;
                                else
                                    loTail.next = e;
                                loTail = e;
                            &#125;
                            else &#123;
                                if (hiTail == null)
                                    hiHead = e;
                                else
                                    hiTail.next = e;
                                hiTail = e;
                            &#125;
                        &#125; while ((e = next) != null);
                        if (loTail != null) &#123;
                            loTail.next = null;
                            newTab[j] = loHead;
                        &#125;
                        if (hiTail != null) &#123;
                            hiTail.next = null;
                            newTab[j + oldCap] = hiHead;
                        &#125;
                    &#125;
                &#125;
            &#125;
        &#125;
        return newTab;
    &#125;
&#125;
</code></pre>
<pre><code class="java">public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; 
    implements Map&lt;K,V&gt;, Cloneable, Serializable &#123; 
    final float loadFactor;
    static final float DEFAULT_LOAD_FACTOR = 0.75f;
    int threshold;
    transient Node&lt;K,V&gt;[] table;
    public HashMap() &#123;
        this.loadFactor = DEFAULT_LOAD_FACTOR; 
    &#125;
    
    public HashMap(int initialCapacity) &#123;
        this(initialCapacity, DEFAULT_LOAD_FACTOR);
    &#125;
    public HashMap(int initialCapacity, float loadFactor) &#123;
        if (initialCapacity &lt; 0)
            throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; +
                                               initialCapacity);
        if (initialCapacity &gt; MAXIMUM_CAPACITY)
            initialCapacity = MAXIMUM_CAPACITY;
        if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))
            throw new IllegalArgumentException(&quot;Illegal load factor: &quot; +
                                               loadFactor);
        this.loadFactor = loadFactor;
        this.threshold = tableSizeFor(initialCapacity);
    &#125;
    static final int tableSizeFor(int cap) &#123;
        int n = cap - 1;
        n |= n &gt;&gt;&gt; 1;
        n |= n &gt;&gt;&gt; 2;
        n |= n &gt;&gt;&gt; 4;
        n |= n &gt;&gt;&gt; 8;
        n |= n &gt;&gt;&gt; 16;
        return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;
    &#125;
    
    //【9-1】put方法
    public V put(K key, V value) &#123;
        //计算hash值
        return putVal(hash(key), key, value, false, true);
    &#125;

    static final int hash(Object key) &#123;
        int h;
        return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);
    &#125;
    //【9-2】调用putVal方法
    final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
                   boolean evict) &#123;
        Node&lt;K,V&gt;[] tab;
        Node&lt;K,V&gt; p; 
        int n, i;
        
        //【9-3】table不空了，不走if		
        if ((tab = table) == null || (n = tab.length) == 0)
            n = (tab = resize()).length;
        //【9-4】tab[i]不null，不走if
        if ((p = tab[i = (n - 1) &amp; hash]) == null)
            tab[i] = newNode(hash, key, value, null);
        else &#123;
            Node&lt;K,V&gt; e; K k;
            /*
                【9-5】
                判断p.hash == hash哈希值是否相等，即使hash相等也要做&amp;&amp;后续的判断，因为两个对象哈希值相等是有可能的
                此时“通话”和“重地”的哈希值一致，但是key不一致，if不走
            */
            if (p.hash == hash &amp;&amp;
                ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))
                e = p;
            else if (p instanceof TreeNode)//【9-6】p也不是红黑树，不走if
                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);
            else &#123;
                //【9-7】走到这里，证明数组的这个位置是个链表了
                for (int binCount = 0; ; ++binCount) &#123;//【9-8】无条件的死循环   binCount 链表上节点的个数
                    //随着循环  p.next就是一路找链上元素
                    //p.next要是没有元素，就要开始追加了呗
                    if ((e = p.next) == null) &#123;//【9-10】一路next比较都没有key相同的数据
                    
                        p.next = newNode(hash, key, value, null);//【9-11】追加在链表尾部 ---》 前七后八
                        //【9-12】如果节点个数大于8，进行树化：要从链表转为红黑树
                        if (binCount &gt;= TREEIFY_THRESHOLD - 1)  
                            treeifyBin(tab, hash);//【9-13】这里还涉及 剪枝 问题，树节点在6个以下，就又变成链表了
                        break;
                    &#125;
                    //【9-9】比较过程中：如果比较链表某个key相同，就break结束了，不用继续走了
                    if (e.hash == hash &amp;&amp;
                        ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))
                        break;
                    p = e;
                &#125;
            &#125;
            if (e != null) &#123;  
                V oldValue = e.value;
                if (!onlyIfAbsent || oldValue == null)
                    e.value = value;//【8-7】新value替换老value
                afterNodeAccess(e);
                return oldValue;//【8-8】返回老value
            &#125;
        &#125;
        ++modCount;

        if (++size &gt; threshold)
            resize();
        afterNodeInsertion(evict);
        return null;
    &#125;

    final Node&lt;K,V&gt;[] resize() &#123;
        Node&lt;K,V&gt;[] oldTab = table;
        int oldCap = (oldTab == null) ? 0 : oldTab.length; 
        int oldThr = threshold;
        int newCap, newThr = 0;
        if (oldCap &gt; 0) &#123;
            if (oldCap &gt;= MAXIMUM_CAPACITY) &#123;
                threshold = Integer.MAX_VALUE;
                return oldTab;
            &#125;
            else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;
                     oldCap &gt;= DEFAULT_INITIAL_CAPACITY)
                newThr = oldThr &lt;&lt; 1;
        &#125;
        else if (oldThr &gt; 0) 
            newCap = oldThr;
        else &#123;    
            newCap = DEFAULT_INITIAL_CAPACITY;
            newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);
        &#125;
        if (newThr == 0) &#123;
            float ft = (float)newCap * loadFactor;
            newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?
                      (int)ft : Integer.MAX_VALUE);
        &#125;
        threshold = newThr;
        @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)
            Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];
        table = newTab;
        if (oldTab != null) &#123;
            for (int j = 0; j &lt; oldCap; ++j) &#123;
                Node&lt;K,V&gt; e;
                if ((e = oldTab[j]) != null) &#123;
                    oldTab[j] = null;
                    if (e.next == null)
                        newTab[e.hash &amp; (newCap - 1)] = e;
                    else if (e instanceof TreeNode)
                        ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);
                    else &#123; 
                        Node&lt;K,V&gt; loHead = null, loTail = null;
                        Node&lt;K,V&gt; hiHead = null, hiTail = null;
                        Node&lt;K,V&gt; next;
                        do &#123;
                            next = e.next;
                            if ((e.hash &amp; oldCap) == 0) &#123;
                                if (loTail == null)
                                    loHead = e;
                                else
                                    loTail.next = e;
                                loTail = e;
                            &#125;
                            else &#123;
                                if (hiTail == null)
                                    hiHead = e;
                                else
                                    hiTail.next = e;
                                hiTail = e;
                            &#125;
                        &#125; while ((e = next) != null);
                        if (loTail != null) &#123;
                            loTail.next = null;
                            newTab[j] = loHead;
                        &#125;
                        if (hiTail != null) &#123;
                            hiTail.next = null;
                            newTab[j + oldCap] = hiHead;
                        &#125;
                    &#125;
                &#125;
            &#125;
        &#125;
        return newTab;
    &#125;
&#125;
</code></pre>
<p><strong>总结：</strong></p>
<p>默认<strong>数组长度为16</strong>，<strong>最大程度${2^{30}}$</strong>,<strong>负载因子为0.75</strong>，扩容时<strong>扩大2倍</strong>，</p>
<p>1.8比1.7改变了底层数据结构而已</p>
<h4 id="4-1-6-HashSet底层原理"><a href="#4-1-6-HashSet底层原理" class="headerlink" title="4.1.6 HashSet底层原理"></a>4.1.6 HashSet底层原理</h4><pre><code class="java">public class HashSet&lt;E&gt;&#123;
    //重要属性：
    private transient HashMap&lt;E,Object&gt; map;
    private static final Object PRESENT = new Object();
    //构造器：
    public HashSet() &#123;
        map = new HashMap&lt;&gt;();//HashSet底层就是利用HashMap来完成的
    &#125;
        
    public boolean add(E e) &#123;
        return map.put(e, PRESENT)==null;
    &#125;      
&#125;
</code></pre>
<h3 id="4-2TreeMap"><a href="#4-2TreeMap" class="headerlink" title="4.2TreeMap"></a>4.2TreeMap</h3><p>【1】原理大致介绍：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618175955956.png" class="">


<p>【2】源码：</p>
<pre><code class="java">public class TreeMap&lt;K,V&gt;&#123;
        //重要属性：
        //外部比较器：
        private final Comparator&lt;? super K&gt; comparator;
        //树的根节点：
        private transient Entry&lt;K,V&gt; root = null;
        //集合中元素的数量：
        private transient int size = 0;
        //空构造器:
        public TreeMap() &#123;
        comparator = null;//如果使用空构造器，那么底层就不使用外部比较器
    &#125;
        //有参构造器：
        public TreeMap(Comparator&lt;? super K&gt; comparator) &#123;
        this.comparator = comparator;//如果使用有参构造器，那么就相当于指定了外部比较器
    &#125;
        
        public V put(K key, V value) &#123;//k,V的类型在创建对象的时候确定了
        //如果放入的是第一对元素，那么t的值为null
        Entry&lt;K,V&gt; t = root;//在放入第二个节点的时候，root已经是根节点了
                //如果放入的是第一个元素的话，走入这个if中：
        if (t == null) &#123;
                        //自己跟自己比
            compare(key, key); // type (and possibly null) check
                        //根节点确定为root
            root = new Entry&lt;&gt;(key, value, null);
                        //size值变为1
            size = 1;
            modCount++;
            return null;
        &#125;
                
        int cmp;
        Entry&lt;K,V&gt; parent;
        // split comparator and comparable paths
                //将外部比较器赋给cpr:
        Comparator&lt;? super K&gt; cpr = comparator;
                //cpr不等于null，意味着你刚才创建对象的时候调用了有参构造器，指定了外部比较器
        if (cpr != null) &#123;
            do &#123;
                parent = t;
                cmp = cpr.compare(key, t.key);//将元素的key值做比较
                                //cmp返回的值就是int类型的数据：
                                //要是这个值《0 =0  》0
                if (cmp &lt; 0)
                    t = t.left;
                else if (cmp &gt; 0)
                    t = t.right;
                else//cpm==0
                                //如果key的值一样，那么新的value替换老的value  但是key不变 因为key是唯一的
                    return t.setValue(value);
            &#125; while (t != null);
        &#125;
                //cpr等于null，意味着你刚才创建对象的时候调用了空构造器，没有指定外部比较器，使用内部比较器
        else &#123;
            if (key == null)
                throw new NullPointerException();
            Comparable&lt;? super K&gt; k = (Comparable&lt;? super K&gt;) key;
            do &#123;
                parent = t;
                cmp = k.compareTo(t.key);//将元素的key值做比较
                if (cmp &lt; 0)
                    t = t.left;
                else if (cmp &gt; 0)
                    t = t.right;
                else
                    return t.setValue(value);
            &#125; while (t != null);
        &#125;
        Entry&lt;K,V&gt; e = new Entry&lt;&gt;(key, value, parent);
        if (cmp &lt; 0)
            parent.left = e;
        else
            parent.right = e;
        fixAfterInsertion(e);
        size++;//size加1 操作
        modCount++;
        return null;
    &#125;
        
        
&#125;
 static final class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;
        K key;
        V value;
        Entry&lt;K,V&gt; left = null;
        Entry&lt;K,V&gt; right = null;
        Entry&lt;K,V&gt; parent;
        boolean color = BLACK;
 &#125;
</code></pre>
<h4 id="TreeSet源码"><a href="#TreeSet源码" class="headerlink" title="TreeSet源码"></a>TreeSet源码</h4><pre><code class="java">public class TreeSet&lt;E&gt; extends AbstractSet&lt;E&gt;
    implements NavigableSet&lt;E&gt;, Cloneable, java.io.Serializable&#123;
                //重要属性：
                private transient NavigableMap&lt;E,Object&gt; m;
                private static final Object PRESENT = new Object();
                
                //在调用空构造器的时候，底层创建了一个TreeMap
                public TreeSet() &#123;
                        this(new TreeMap&lt;E,Object&gt;());
                &#125;
                
                TreeSet(NavigableMap&lt;E,Object&gt; m) &#123;
                        this.m = m;
                &#125;
                
                public boolean add(E e) &#123;
        return m.put(e, PRESENT)==null;
    &#125;
                
                
        &#125;
</code></pre>
<h1 id="Collections工具类"><a href="#Collections工具类" class="headerlink" title="Collections工具类"></a>Collections工具类</h1><pre><code class="java">public class Test01 &#123;
    //这是main方法，程序的入口
    public static void main(String[] args) &#123;
        //Collections不支持创建对象，因为构造器私有化了
        /*Collections cols = new Collections();*/
        //里面的属性和方法都是被static修饰，我们可以直接用类名.去调用即可：
        //常用方法：
        //addAll：
        ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();
        list.add(&quot;cc&quot;);
        list.add(&quot;bb&quot;);
        list.add(&quot;aa&quot;);
        Collections.addAll(list,&quot;ee&quot;,&quot;dd&quot;,&quot;ff&quot;);
        Collections.addAll(list,new String[]&#123;&quot;gg&quot;,&quot;oo&quot;,&quot;pp&quot;&#125;);
        System.out.println(list);
        //binarySearch必须在有序的集合中查找：--》排序：
        Collections.sort(list);//sort提供的是升序排列
        System.out.println(list);
        //binarySearch
        System.out.println(Collections.binarySearch(list, &quot;cc&quot;));
        //copy:替换方法
        ArrayList&lt;String&gt; list2 = new ArrayList&lt;&gt;();
        Collections.addAll(list2,&quot;tt&quot;,&quot;ss&quot;);
        Collections.copy(list,list2);//将list2的内容替换到list上去
        System.out.println(list);
        System.out.println(list2);
        //fill 填充
        Collections.fill(list2,&quot;yyy&quot;);
        System.out.println(list2);
    &#125;
&#125;
</code></pre>
<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><pre><code class="java">public class Test &#123;
    //这是main方法，程序的入口
    public static void main(String[] args) &#123;
        /*
        Stack是Vector的子类，Vector里面两个重要的属性：
        Object[] elementData;底层依然是一个数组
        int elementCount;数组中的容量
         */
        Stack s = new Stack();
        s.add(&quot;A&quot;);
        s.add(&quot;B&quot;);
        s.add(&quot;C&quot;);
        s.add(&quot;D&quot;);
        System.out.println(s);//[A, B, C, D]
        System.out.println(&quot;栈是否为空：&quot; + s.empty());
        System.out.println(&quot;查看栈顶的数据，但是不移除：&quot; + s.peek());
        System.out.println(s);
        System.out.println(&quot;查看栈顶的数据，并且不移除：&quot; + s.pop());
        System.out.println(s);
        s.push(&quot;D&quot;);//和add方法执行的功能一样，就是返回值不同
        System.out.println(s);
    &#125;
&#125;
</code></pre>
<h2 id="同步类容器"><a href="#同步类容器" class="headerlink" title="同步类容器"></a>同步类容器</h2><p>比如ArrayList，HashMap，线程不安全，现在想把线程不安全的集合转换为线程安全的集合：</p>
<pre><code class="java">public class Test01 &#123;
    //这是main方法，程序的入口
    public static void main(String[] args) &#123;
        //ArrayList为案例：从线程不安全  转为线程安全：
        List list = Collections.synchronizedList(new ArrayList());
    &#125;
&#125;
</code></pre>
<p>试试ArrayList的线程不安全：</p>
<pre><code class="java">public class Demo &#123;
    //这是main方法，程序的入口
    public static void main(String[] args) &#123;
        //创建一个ArrayList集合：
        ArrayList list = new ArrayList();
        //创建一个线程池：线程池定长100
        ExecutorService es = Executors.newFixedThreadPool(100);
        //并发向集合中添加10000个数据：
        for (int i = 0; i &lt; 10000; i++) &#123;
            //每个线程处理任务：run方法中的内容就是线程单元，任务，实际线程执行的部分
            es.execute(new Runnable() &#123;
                @Override
                public void run() &#123;
                    list.add(&quot;aaa&quot;);
                &#125;
            &#125;);
        &#125;
        //关闭线程池：
        es.shutdown();
        //监控线程是否执行完毕：
        while(true)&#123;
            //线程都执行完以后返回true
            if(es.isTerminated())&#123;
                System.out.println(&quot;所有的子线程都执行完毕了！&quot;);
                //执行完毕以后看一下集合中元素的数量：
                System.out.println(list.size());
                if(list.size() == 10000)&#123;
                    System.out.println(&quot;线程安全！&quot;);
                &#125;else&#123;
                    System.out.println(&quot;线程不安全！&quot;);
                &#125;
                //线程执行完以后，while循环可以停止：
                break;
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<p>结果：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618180549466.png" class="">


<p>利用同步类容器解决：</p>
<pre><code class="java">public class Demo &#123;
    //这是main方法，程序的入口
    public static void main(String[] args) &#123;
        //创建一个ArrayList集合：
        ArrayList oldlist = new ArrayList();
        List list = Collections.synchronizedList(oldlist);
        //创建一个线程池：线程池定长100
        ExecutorService es = Executors.newFixedThreadPool(100);
        //并发向集合中添加10000个数据：
        for (int i = 0; i &lt; 10000; i++) &#123;
            //每个线程处理任务：run方法中的内容就是线程单元，任务，实际线程执行的部分
            es.execute(new Runnable() &#123;
                @Override
                public void run() &#123;
                    list.add(&quot;aaa&quot;);
                &#125;
            &#125;);
        &#125;
        //关闭线程池：
        es.shutdown();
        //监控线程是否执行完毕：
        while(true)&#123;
            //线程都执行完以后返回true
            if(es.isTerminated())&#123;
                System.out.println(&quot;所有的子线程都执行完毕了！&quot;);
                //执行完毕以后看一下集合中元素的数量：
                System.out.println(list.size());
                if(list.size() == 10000)&#123;
                    System.out.println(&quot;线程安全！&quot;);
                &#125;else&#123;
                    System.out.println(&quot;线程不安全！&quot;);
                &#125;
                //线程执行完以后，while循环可以停止：
                break;
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<p>结果：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618180623443.png" class="">


<p>源码解析：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618180635090.png" class="">




<h2 id="ConcurrentMap并发容器"><a href="#ConcurrentMap并发容器" class="headerlink" title="ConcurrentMap并发容器"></a>ConcurrentMap并发容器</h2><p>JDK5.0之后提供了多种并发类容器可以替代同步类容器，提升性能、吞吐量<br>ConcurrentHashMap替代HashMap、HashTable<br>ConcurrentSkipListMap替代TreeMap</p>
<p>简单原理：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618180711631.png" class="">


<p>并发情况下，验证提高性能：</p>
<p>ConcunrrentHashMap :</p>
<pre><code class="java">public class Test &#123;
    //这是main方法，程序的入口
    public static void main(String[] args) &#123;
        //选择一个容器：
        ConcurrentHashMap&lt;String,Integer&gt; map = new ConcurrentHashMap&lt;&gt;();
        
        //创建10个线程：
        for (int i = 0; i &lt; 10; i++) &#123;
            new Thread(new Runnable() &#123;
                @Override
                public void run() &#123;
                    long startTime = System.currentTimeMillis();
                    for (int j = 0; j &lt; 1000000; j++) &#123;
                        map.put(&quot;test&quot; + j , j);
                    &#125;
                    long endTime = System.currentTimeMillis();
                    System.out.println(&quot;一共需要的时间：&quot; + (endTime - startTime));
                &#125;
            &#125;).start();
        &#125;
    &#125;
&#125;
</code></pre>
<p>结果：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618180735265.png" class="">


<p>Hashtable：</p>
<pre><code class="java">public class Test &#123;
    //这是main方法，程序的入口
    public static void main(String[] args) &#123;
        //选择一个容器：
        //ConcurrentHashMap&lt;String,Integer&gt; map = new ConcurrentHashMap&lt;&gt;();
        Hashtable map = new Hashtable();
        //创建10个线程：
        for (int i = 0; i &lt; 10; i++) &#123;
            new Thread(new Runnable() &#123;
                @Override
                public void run() &#123;
                    long startTime = System.currentTimeMillis();
                    for (int j = 0; j &lt; 1000000; j++) &#123;
                        map.put(&quot;test&quot; + j , j);
                    &#125;
                    long endTime = System.currentTimeMillis();
                    System.out.println(&quot;一共需要的时间：&quot; + (endTime - startTime));
                &#125;
            &#125;).start();
        &#125;
    &#125;
&#125;
</code></pre>
<img data-src="/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618180757516.png" class="">


<p>HashMap：</p>
<pre><code class="java">public class Test &#123;
    //这是main方法，程序的入口
    public static void main(String[] args) &#123;
        //选择一个容器：
        //ConcurrentHashMap&lt;String,Integer&gt; map = new ConcurrentHashMap&lt;&gt;();
        //Hashtable map = new Hashtable();
        HashMap map = new HashMap();
        //创建10个线程：
        for (int i = 0; i &lt; 10; i++) &#123;
            new Thread(new Runnable() &#123;
                @Override
                public void run() &#123;
                    long startTime = System.currentTimeMillis();
                    for (int j = 0; j &lt; 1000000; j++) &#123;
                        map.put(&quot;test&quot; + j , j);
                    &#125;
                    long endTime = System.currentTimeMillis();
                    System.out.println(&quot;一共需要的时间：&quot; + (endTime - startTime));
                &#125;
            &#125;).start();
        &#125;
    &#125;
&#125;
</code></pre>
<img data-src="/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618180824896.png" class="">


<p>线程安全的HashMap：</p>
<pre><code class="java">public class Test &#123;
    //这是main方法，程序的入口
    public static void main(String[] args) &#123;
        //选择一个容器：
        //ConcurrentHashMap&lt;String,Integer&gt; map = new ConcurrentHashMap&lt;&gt;();
        //Hashtable map = new Hashtable();
        HashMap oldmap = new HashMap();
        Map map = Collections.synchronizedMap(oldmap);
        //创建10个线程：
        for (int i = 0; i &lt; 10; i++) &#123;
            new Thread(new Runnable() &#123;
                @Override
                public void run() &#123;
                    long startTime = System.currentTimeMillis();
                    for (int j = 0; j &lt; 1000000; j++) &#123;
                        map.put(&quot;test&quot; + j , j);
                    &#125;
                    long endTime = System.currentTimeMillis();
                    System.out.println(&quot;一共需要的时间：&quot; + (endTime - startTime));
                &#125;
            &#125;).start();
        &#125;
    &#125;
&#125;
</code></pre>
<img data-src="/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618180846459.png" class="">


<p>总结：</p>
<table>
<thead>
<tr>
<th align="center">ConcurrentHashMap</th>
<th align="center">性能高，线程安全</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Hashtable: 线程安全</td>
<td align="center">性能低</td>
</tr>
<tr>
<td align="center">HashMap:线程不安全</td>
<td align="center">性能高</td>
</tr>
</tbody></table>
<p>线程安全的HashMap：线程安全，性能低</p>
<h2 id="COW并发容器"><a href="#COW并发容器" class="headerlink" title="COW并发容器"></a>COW并发容器</h2><p>【1】COW类并发容器，全称：Copy  On  Write容器，写时复制容器。（读写分离容器）</p>
<p>【2】原理：<br>向容器中添加元素时，先将容器进行Copy复制出一个新容器，然后将元素添加到新容器中，再将原容器的引用指向新容器。<br>并发读的时候不需要锁定容器，因为原容器没有变化，所以可以读取原容器中的值，使用的是一种读写分离的思想。</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618181056593.png" class="">




<p>【3】这种设计的好处是什么呢？<br>注意上面的操作arr数组本身是无锁的，没有锁，在添加数据的时候，做了额外的复制，<br>此时如果有线程来读数据，那么读取的是老arr的数据，此时arr的地址还没有改呢，在我添加元素的过程中，<br>无论有多少个线程来读数据，都是读的原来的arr，不是新的arr<br>所以性能很高，读写分离。提高了并发的性能。如果再读再复制…</p>
<p>【4】注意：<br>CopyOnWrite容器只能保证数据的最终一致性，不能保证数据实时一致性。<br>所以如果你希望写入的的数据，马上能读到，请不要使用CopyOnWrite容器。</p>
<p>【5】适合特定场合：<br>这个应用场景显而易见，适合读多写少的情况。如果一万个线程都添加操作，都在集合中添加数据，那数组不断复制，长度不断+1，<br>那JVM肯定一直往上飙升，你用的时候肯定要评估使用场景的。<br>由于每次更新都会复制新容器，所以如果数据量较大并且更新操作频繁则对内存消耗很高，建议在高并发读的场景下使用。</p>
<p>【6】主要讲解：<br>COW容器有两种一种是CopyonWriteArrayList，一种是CopyOnWriteArraySet<br>一个是替代ArrayList，一个是代替Set</p>
<h3 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h3><pre><code class="java">public class Test &#123;
    //这是main方法，程序的入口
    public static void main(String[] args) &#123;
        CopyOnWriteArrayList&lt;Integer&gt; list = new CopyOnWriteArrayList&lt;&gt;();
        //添加方法：
        list.add(1);
        list.add(2);
        list.add(3);
        list.add(4);
        System.out.println(list);//[1, 2, 3, 4]
        list.add(3);//add方法无论元素是否存在，都可以添加进去--》添加重复的元素
        System.out.println(list);//[1, 2, 3, 4, 3]
        //adj. 缺席的；缺少的；心不在焉的；茫然的
        list.addIfAbsent(33);//添加不存在的元素--》不可以添加重复的数据
        System.out.println(list);//[1, 2, 3, 4, 3, 33]
    &#125;
&#125;
</code></pre>
<p>源码分析：</p>
<pre><code class="java">public class CopyOnWriteArrayList&lt;E&gt;&#123;
        //底层基于数组实现的
        private transient volatile Object[] array;
        
        public CopyOnWriteArrayList() &#123;
        setArray(new Object[0]);
    &#125;
        
        final void setArray(Object[] a) &#123;
        array = a; // array = new Object[0]
    &#125;
        //add方法：
        public boolean add(E e) &#123;
        final ReentrantLock lock = this.lock;
        lock.lock();
        try &#123;
                        //返回底层array数组,给了elements
            Object[] elements = getArray();
                        //获取elements的长度---》获取老数组的长度
            int len = elements.length;
                        //完成数组的复制，将老数组中的元素复制到新数组中，并且新数组的长度加1操作
            Object[] newElements = Arrays.copyOf(elements, len + 1);
                        //将e元素放入新数组最后位置
            newElements[len] = e;
                        //array数组的指向从老数组变为新数组
            setArray(newElements);
            return true;
        &#125; finally &#123;
            lock.unlock();
        &#125;
    &#125;
        
        
        final Object[] getArray() &#123;
        return array;//返回底层数组
    &#125;
        
        
        private boolean addIfAbsent(E e, Object[] snapshot) &#123;
        final ReentrantLock lock = this.lock;
        lock.lock();
        try &#123;
                        //取出array数组给current
            Object[] current = getArray();
            int len = current.length;
            if (snapshot != current) &#123;
                // Optimize for lost race to another addXXX operation
                int common = Math.min(snapshot.length, len);
                                //遍历老数组：
                for (int i = 0; i &lt; common; i++)
                                        //eq(e, current[i])将放入的元素和老数组的每一个元素进行比较，如果有重复的元素，就返回false，不添加了
                    if (current[i] != snapshot[i] &amp;&amp; eq(e, current[i]))
                        return false;
                if (indexOf(e, current, common, len) &gt;= 0)
                        return false;
            &#125;
                        //完成数组的复制，将老数组中的元素复制到新数组中，并且新数组的长度加1操作
            Object[] newElements = Arrays.copyOf(current, len + 1);
                        //将e元素放入新数组最后位置
            newElements[len] = e;
                        //array数组的指向从老数组变为新数组
            setArray(newElements);
            return true;
        &#125; finally &#123;
            lock.unlock();
        &#125;
    &#125;             
&#125;
</code></pre>
<h3 id="CopyOnWriteArraySet"><a href="#CopyOnWriteArraySet" class="headerlink" title="CopyOnWriteArraySet"></a>CopyOnWriteArraySet</h3><pre><code class="java">public class Test02 &#123;
    //这是main方法，程序的入口
    public static void main(String[] args) &#123;
        //创建一个集合：
        CopyOnWriteArraySet&lt;Integer&gt; set = new CopyOnWriteArraySet&lt;&gt;();
        //在这里也体现出Set和List的本质区别，就在于是否重复
        //所以add方法直接不可以添加重复数据进去
        set.add(1);
        set.add(2);
        set.add(2);
        set.add(7);
        System.out.println(set);//[1, 2, 7]
        
    &#125;
&#125;
</code></pre>
<p>源码：</p>
<pre><code class="java">public class CopyOnWriteArraySet&lt;E&gt;&#123;
        //CopyOnWriteArraySet底层基于CopyOnWriteArrayList
        private final CopyOnWriteArrayList&lt;E&gt; al;
        
        public CopyOnWriteArraySet() &#123;
        al = new CopyOnWriteArrayList&lt;E&gt;();
    &#125;
        
        //添加方法：
        public boolean add(E e) &#123;
        return al.addIfAbsent(e);//底层调用的还是CopyOnWriteArrayList的addIfAbsent
    &#125;
&#125;
</code></pre>
<p>总结：</p>
<p>由上面的源码看出，每次调用CopyOnWriteArraySet的add方法时候，其实底层是基于CopyOnWriteArrayList的addIfAbsent，<br>每次在addIfAbsent方法中每次都要对数组进行遍历，所以CopyOnWriteArraySet的性能低于CopyOnWriteArrayList</p>
<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>数据结构分为：<br>（1）逻辑结构 ：–》思想上的结构–》卧室，厨房，卫生间 —》线性表（数组，链表），图，树，栈，队列<br>（2）物理结构 ：–》真实结构–》钢筋混凝土+牛顿力学——》紧密结构（顺序结构），跳转结构（链式结构）</p>
<p>队列：特点：先进先出 （FIFO）（first in first out）</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618181454201.png" class="">


<img data-src="/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618181504415.png" class="">




<p>他有两端，一端是让新元素进去，一端是让老元素出去</p>
<p>在需要公平且经济地对各种自然或社会资源做管理或分配的场合，无论是调度银行和医院的服务窗口，还是管理轮耕的田地和轮伐的森林，队列都可大显身手。</p>
<p>甚至计算机及其网络自身内部的各种计算资源，无论是多进程共享的 CPU 时间，还是多用户共享的打印机，也都需要借助队列结构实现合理和优化的分配。</p>
<p>双端队列：两端都可以进行进队，出队的队列：</p>
<p>（1）前端，后端都可以进出：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618181511902.png" class="">




<p>（2）进行限制：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618181516928.png" class="">




<p>（3）特殊情况，双端队列实现栈操作:</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618181522040.png" class="">




<p>栈和队列的物理结构实现 可以用线性表的数组，链表都可以</p>
<h2 id="队列Queue"><a href="#队列Queue" class="headerlink" title="队列Queue"></a>队列Queue</h2><h3 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h3><h4 id="BlockingQueue介绍"><a href="#BlockingQueue介绍" class="headerlink" title="BlockingQueue介绍"></a>BlockingQueue介绍</h4><img data-src="/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618181740905.png" class="">


<p>总结：BlockingQueue继承Queue，Queue继承自Collection<br>所以Collection最基础的增删改查操作是有的，在这个基础上，多了Queue的特点，在这个基础上又多了阻塞的特点，最终形成了BlockingQueue</p>
<p>什么叫阻塞？</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618181750078.png" class="">


<img data-src="/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618181756012.png" class="">


<p>常用的API：<br>添加：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618181825630.png" class="">


<img data-src="/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618181805698.png" class="">


<img data-src="/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618181833424.png" class="">


<p>put是阻塞的</p>
<p>查询：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618181839103.png" class="">


<img data-src="/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618181845214.png" class="">




<p>take是阻塞的</p>
<p>删除：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618181852391.png" class="">




<h4 id="常见子类"><a href="#常见子类" class="headerlink" title="常见子类"></a>常见子类</h4><p><a href="#queue_impl1">ArrayBlockingQueue</a></p>
<p><a href="#queue_impl2">LinkedBlockingQueue</a></p>
<p><a href="#queue_impl3">SynchronousQueue</a></p>
<p><a href="#queue_impl4">PriorityBlockingQueue</a></p>
<p><a href="#queue_impl5">DelayQueue</a></p>
<div name=queue_impl1>



<blockquote>
<p>ArrayBlockingQueue</p>
</blockquote>
<p>源码中的注释的解释说明：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618181949074.png" class="">




<p>【1】添加元素：</p>
<pre><code class="java">public class Test01 &#123;
    //这是main方法，程序的入口
    public static void main(String[] args) throws InterruptedException &#123;
        //创建一个队列，队列可以指定容量指定长度3：
        ArrayBlockingQueue aq = new ArrayBlockingQueue(3);
        //添加元素：
        //【1】添加null元素：不可以添加null元素，会报空指针异常：NullPointerException
        //aq.add(null);
        //aq.offer(null);
        //aq.put(null);
        //【2】正常添加元素：
        aq.add(&quot;aaa&quot;);
        aq.offer(&quot;bbb&quot;);
        aq.put(&quot;ccc&quot;);
        System.out.println(aq);//[aaa, bbb, ccc]
        //【3】在队列满的情况下，再添加元素：
        //aq.add(&quot;ddd&quot;);//在队列满的情况下，添加元素 出现异常：Queue full
        //System.out.println(aq.offer(&quot;ddd&quot;));//没有添加成功，返回false
        //设置最大阻塞时间，如果时间到了，队列还是满的，就不再阻塞了
        //aq.offer(&quot;ddd&quot;,2, TimeUnit.SECONDS);
        //真正阻塞的方法： put ,如果队列满，就永远阻塞 
        aq.put(&quot;ddd&quot;);
        System.out.println(aq);
    &#125;
&#125;
</code></pre>
<p>【2】获取元素：</p>
<pre><code class="java">public class Test02 &#123;
    //这是main方法，程序的入口
    public static void main(String[] args) throws InterruptedException &#123;
        //创建一个队列，队列可以指定容量指定长度3：
        ArrayBlockingQueue aq = new ArrayBlockingQueue(3);
        aq.add(&quot;aaa&quot;);
        aq.add(&quot;bbb&quot;);
        aq.add(&quot;ccc&quot;);
        //得到头元素但是不移除
        System.out.println(aq.peek());
        System.out.println(aq);
        //得到头元素并且移除
        System.out.println(aq.poll());
        System.out.println(aq);
        //得到头元素并且移除
        System.out.println(aq.take());
        System.out.println(aq);
        //清空元素：
        aq.clear();
        System.out.println(aq);
        System.out.println(aq.peek());//null
        System.out.println(aq.poll());//null
        //设置阻塞事件，如果队列为空，返回null，时间到了以后就不阻塞了
        //System.out.println(aq.poll(2, TimeUnit.SECONDS));
        //真正阻塞：队列为空，永远阻塞
        System.out.println(aq.take());
    &#125;
&#125;
</code></pre>
<p>【3】源码：</p>
<pre><code class="java">public class ArrayBlockingQueue&lt;E&gt; &#123;
        //底层就是一个数组：
        final Object[] items;
        //取元素用到的索引，初始结果为0
        int takeIndex;
        //放元素用到的索引，初始结果为0
        int putIndex;
        //数组中元素的个数：
        int count;
        
        //一把锁：这个锁肯定很多方法中用到了，所以定义为属性，初始化以后可以随时使用
    final ReentrantLock lock;
    //锁伴随的一个等待吃：notEmpty
    private final Condition notEmpty;
    //锁伴随的一个等待吃：notFull
    private final Condition notFull;
        
        //构造器：
        public ArrayBlockingQueue(int capacity) &#123;//传入队列指定的容量
        this(capacity, false);
    &#125;
        
        public ArrayBlockingQueue(int capacity, boolean fair) &#123;//传入队列指定的容量
                //健壮性考虑
        if (capacity &lt;= 0)
            throw new IllegalArgumentException();
                //初始化底层数组
        this.items = new Object[capacity];
                //初始化锁 和  等待队列
        lock = new ReentrantLock(fair);
        notEmpty = lock.newCondition();
        notFull =  lock.newCondition();
    &#125;
        
        //两个基本方法：一个是入队，一个是出队  ，是其他方法的基础：
        //入队：
        private void enqueue(E x) &#123;
        // assert lock.getHoldCount() == 1;
        // assert items[putIndex] == null;
        final Object[] items = this.items;//底层数组赋给items
                //在对应的下标位置放入元素
        items[putIndex] = x;
        if (++putIndex == items.length) //++putIndex putIndex 索引 加1 
            putIndex = 0;
                //每放入一个元素，count加1操作
        count++;
        notEmpty.signal();
    &#125;
        
        
        //出队：
        private E dequeue() &#123;
        // assert lock.getHoldCount() == 1;
        // assert items[takeIndex] != null;
        final Object[] items = this.items;//底层数组赋给items
        @SuppressWarnings(&quot;unchecked&quot;)
        E x = (E) items[takeIndex];//在对应的位置取出元素
        items[takeIndex] = null;//对应位置元素取出后就置为null
        if (++takeIndex == items.length)//++takeIndex 加1操作
            takeIndex = 0;
        count--;//每取出一个元素，count减1操作
        if (itrs != null)
            itrs.elementDequeued();
        notFull.signal();
        return x;//将取出的元素作为方法的返回值
    &#125;       
&#125;
</code></pre>
<p>takeIndex和putIndex置为0的原因：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618182045354.png" class="">


<p>【4】其他的添加或者获取的方法都是依托与这个入队和出队的基础方法</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618182053419.png" class="">


<p>【5】感受一下put和take的阻塞：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618182101129.png" class="">


<p>上面的while不可以换为if，因为如果notFull中的线程被激活的瞬间，有其他线程放入元素，那么队列就又满了<br>那么沿着await后面继续执行就不可以，所以一定要反复确定队列是否满的，才能放入元素</p>
<div name=queue_impl2>



<blockquote>
<p>LinkedBlockingQueue</p>
</blockquote>
<p>一个可选择的有边界的队列：意思就是队列的长度可以指定，也可以不指定</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618182251224.png" class="">


<p>【1】添加元素：</p>
<pre><code class="java">public class Test01 &#123;
    //这是main方法，程序的入口
    public static void main(String[] args) throws InterruptedException &#123;
        //创建一个队列，队列可以指定容量指定长度3：
        LinkedBlockingQueue aq = new LinkedBlockingQueue(3);
        //添加元素：
        //【1】添加null元素：不可以添加null元素，会报空指针异常：NullPointerException
        //aq.add(null);
        //aq.offer(null);
        aq.put(null);
        //【2】正常添加元素：
        aq.add(&quot;aaa&quot;);
        aq.offer(&quot;bbb&quot;);
        aq.put(&quot;ccc&quot;);
        System.out.println(aq);//[aaa, bbb, ccc]
        //【3】在队列满的情况下，再添加元素：
        //aq.add(&quot;ddd&quot;);//在队列满的情况下，添加元素 出现异常：Queue full
        //System.out.println(aq.offer(&quot;ddd&quot;));//没有添加成功，返回false
        //设置最大阻塞时间，如果时间到了，队列还是满的，就不再阻塞了
        //aq.offer(&quot;ddd&quot;,2, TimeUnit.SECONDS);
        //真正阻塞的方法： put ,如果队列满，就永远阻塞
        aq.put(&quot;ddd&quot;);
        System.out.println(aq);
    &#125;
&#125;
</code></pre>
<p>【2】取出元素：</p>
<pre><code class="java">public class Test02 &#123;
    //这是main方法，程序的入口
    public static void main(String[] args) throws InterruptedException &#123;
        //创建一个队列，队列可以指定容量指定长度3：
        LinkedBlockingQueue aq = new LinkedBlockingQueue();
        aq.add(&quot;aaa&quot;);
        aq.add(&quot;bbb&quot;);
        aq.add(&quot;ccc&quot;);
        //得到头元素但是不移除
        System.out.println(aq.peek());
        System.out.println(aq);
        //得到头元素并且移除
        System.out.println(aq.poll());
        System.out.println(aq);
        //得到头元素并且移除
        System.out.println(aq.take());
        System.out.println(aq);
        //清空元素：
        aq.clear();
        System.out.println(aq);
        System.out.println(aq.peek());//null
        System.out.println(aq.poll());//null
        //设置阻塞事件，如果队列为空，返回null，时间到了以后就不阻塞了
        //System.out.println(aq.poll(2, TimeUnit.SECONDS));
        //真正阻塞：队列为空，永远阻塞
        System.out.println(aq.take());
    &#125;
&#125;
</code></pre>
<p>【3】特点：<br>ArrayBlockingQueue ： 不支持读写同时操作，底层基于数组的。<br>LinkedBlockingQueue：支持读写同时操作，并发情况下，效率高。底层基于链表。</p>
<p>【4】源码：<br>入队操作：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618182330212.png" class="">


<p>出队操作：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618182341368.png" class="">


<pre><code class="java">public class LinkedBlockingQueue&lt;E&gt;&#123;
        //内部类Node就是链表的节点的对象对应的类：
        static class Node&lt;E&gt; &#123;
        E item;//封装你要装的那个元素
        
        Node&lt;E&gt; next;//下一个Node节点的地址
        Node(E x) &#123; item = x; &#125;//构造器
    &#125;
        //链表的长度
        private final int capacity;
        //计数器：
        private final AtomicInteger count = new AtomicInteger();
        //链表的头结点
        transient Node&lt;E&gt; head;
        //链表的尾结点
        private transient Node&lt;E&gt; last;
        //取元素用的锁
        private final ReentrantLock takeLock = new ReentrantLock();
        //等待池
    private final Condition notEmpty = takeLock.newCondition();
    //放元素用的锁
    private final ReentrantLock putLock = new ReentrantLock();
    //等待池
    private final Condition notFull = putLock.newCondition();
        
        public LinkedBlockingQueue() &#123;
        this(Integer.MAX_VALUE);//调用类本类的空构造器，传入正21亿
    &#125;
        
        public LinkedBlockingQueue(int capacity) &#123;
                //健壮性考虑
        if (capacity &lt;= 0) throw new IllegalArgumentException();
                //给队列指定长度  
        this.capacity = capacity;
                //last，head指向一个新的节点，新的节点中 元素为null 
        last = head = new Node&lt;E&gt;(null);
    &#125;
        
        
        //入队：
        private void enqueue(Node&lt;E&gt; node) &#123;
        last = last.next = node;
    &#125;
        
        //出队：
        private E dequeue() &#123;
        Node&lt;E&gt; h = head;//h指向了head
        Node&lt;E&gt; first = h.next;//first 指向head的next
        h.next = h; // help GC   h.next指向自己，更容易被GC发现 被GC
        head = first;//head的指向指为first
        E x = first.item;//取出链中第一个元素，给了x
        first.item = null;
        return x;//把x作为方法的返回值
    &#125;
&#125;
</code></pre>
<p>【5】put的阻塞：</p>
<p>阻塞的前提是  队列是固定长度的</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618182407325.png" class="">




<div name=queue_impl3>



<blockquote>
<p>SynchronousQueue</p>
</blockquote>
<img data-src="/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618182455703.png" class="">


<p>这个特殊的队列设计的意义：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618182515070.png" class="">


<p>测试1：先添加元素：</p>
<pre><code class="java">public class Test01 &#123;
    //这是main方法，程序的入口
    public static void main(String[] args) &#123;
        SynchronousQueue sq = new SynchronousQueue();
        sq.add(&quot;aaa&quot;);
    &#125;
&#125;
</code></pre>
<p>直接报错：说队列满了，因为队列没有容量，理解为满也是正常的：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618182535474.png" class="">


<p>测试2：put方法  阻塞：队列是空的，可以理解为队列满了，满的话放入元素 put 一定会阻塞：</p>
<pre><code class="java">public class Test01 &#123;
    //这是main方法，程序的入口
    public static void main(String[] args) throws InterruptedException &#123;
        SynchronousQueue sq = new SynchronousQueue();
        sq.put(&quot;aaa&quot;);
    &#125;
&#125;
</code></pre>
<img data-src="/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618182600030.png" class="">


<p>测试3：先取  再放：</p>
<pre><code class="java">public class Test02 &#123;
    //这是main方法，程序的入口
    public static void main(String[] args) &#123;
        SynchronousQueue sq = new SynchronousQueue();
        //创建一个线程，取数据：
        new Thread(new Runnable() &#123;
            @Override
            public void run() &#123;
                while(true)&#123;
                    try &#123;
                        System.out.println(sq.take());
                    &#125; catch (InterruptedException e) &#123;
                        e.printStackTrace();
                    &#125;
                &#125;
            &#125;
        &#125;).start();
        //搞一个线程，往里面放数据：
        new Thread(new Runnable() &#123;
            @Override
            public void run() &#123;
                try &#123;
                    sq.put(&quot;aaa&quot;);
                    sq.put(&quot;bbb&quot;);
                    sq.put(&quot;ccc&quot;);
                    sq.put(&quot;ddd&quot;);
                &#125; catch (InterruptedException e) &#123;
                    e.printStackTrace();
                &#125;
            &#125;
        &#125;).start();
    &#125;
&#125;
</code></pre>
<img data-src="/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618182625271.png" class="">


<p>测试4：poll方法：</p>
<pre><code class="java">public class Test02 &#123;
    //这是main方法，程序的入口
    public static void main(String[] args) &#123;
        SynchronousQueue sq = new SynchronousQueue();
        //创建一个线程，取数据：
        new Thread(new Runnable() &#123;
            @Override
            public void run() &#123;
                while(true)&#123;
                    try &#123;
                        //设置一个阻塞事件：超出事件就不阻塞了
                        Object result = sq.poll(5, TimeUnit.SECONDS);
                        System.out.println(result);
                        if(result == null)&#123;
                            break;
                        &#125;
                    &#125; catch (InterruptedException e) &#123;
                        e.printStackTrace();
                    &#125;
                &#125;
            &#125;
        &#125;).start();
        //搞一个线程，往里面放数据：
        new Thread(new Runnable() &#123;
            @Override
            public void run() &#123;
                try &#123;
                    sq.put(&quot;aaa&quot;);
                    sq.put(&quot;bbb&quot;);
                    sq.put(&quot;ccc&quot;);
                    sq.put(&quot;ddd&quot;);
                &#125; catch (InterruptedException e) &#123;
                    e.printStackTrace();
                &#125;
            &#125;
        &#125;).start();
    &#125;
&#125;
</code></pre>
<img data-src="/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618182647289.png" class="">


<p>注意：取出元素 不能用peek，因为peek不会将元素从队列中拿走，只是查看的效果；</p>
<div name=queue_impl4>



<blockquote>
<p>PriorityBlockingQueue</p>
</blockquote>
<p>带有优先级的阻塞队列。<br>优先级队列，意味着队列有先后顺序的，数据有不同的权重。</p>
<p>无界的队列，没有长度限制，但是在你不指定长度的时候，默认初始长度为11，也可以手动指定，<br>当然随着数据不断的加入，底层（底层是数组Object[]）会自动扩容，直到内存全部消耗殆尽了，导致 OutOfMemoryError内存溢出 程序才会结束。</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618183001941.png" class="">


<p>不可以放入null元素的，不允许放入不可比较的对象（导致抛出ClassCastException），对象必须实现内部比较器或者外部比较器。</p>
<p>测试1：添加null数据：</p>
<pre><code class="java">public class Test &#123;
    //这是main方法，程序的入口
    public static void main(String[] args) &#123;
        PriorityBlockingQueue pq = new PriorityBlockingQueue();
        pq.put(null);
    &#125;
&#125;
</code></pre>
<img data-src="/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618183016134.png" class="">


<p>测试2：添加四个数据：</p>
<pre><code class="java">public class Student implements Comparable&lt;Student&gt; &#123;
    String name;
    int age;
    public Student() &#123;
    &#125;
    public Student(String name, int age) &#123;
        this.name = name;
        this.age = age;
    &#125;
    @Override
    public String toString() &#123;
        return &quot;Student&#123;&quot; +
                &quot;name=&#39;&quot; + name + &#39;\&#39;&#39; +
                &quot;, age=&quot; + age +
                &#39;&#125;&#39;;
    &#125;
    @Override
    public int compareTo(Student o) &#123;
        return this.age - o.age;
    &#125;
&#125;
</code></pre>
<pre><code class="java">public class Test02 &#123;
    //这是main方法，程序的入口
    public static void main(String[] args) &#123;
        PriorityBlockingQueue&lt;Student&gt; pq = new PriorityBlockingQueue&lt;&gt;();
        pq.put(new Student(&quot;nana&quot;,18));
        pq.put(new Student(&quot;lulu&quot;,11));
        pq.put(new Student(&quot;feifei&quot;,6));
        pq.put(new Student(&quot;mingming&quot;,21));
        System.out.println(pq);
    &#125;
&#125;
</code></pre>
<p>结果</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618183048547.png" class="">


<p>发现结果并没有按照优先级顺序排列</p>
<p>测试3：取出数据：</p>
<pre><code class="java">public class Test02 &#123;
    //这是main方法，程序的入口
    public static void main(String[] args) throws InterruptedException &#123;
        PriorityBlockingQueue&lt;Student&gt; pq = new PriorityBlockingQueue&lt;&gt;();
        pq.put(new Student(&quot;nana&quot;,18));
        pq.put(new Student(&quot;lulu&quot;,11));
        pq.put(new Student(&quot;feifei&quot;,6));
        pq.put(new Student(&quot;mingming&quot;,21));
        System.out.println(&quot;------------------------------------------&quot;);
        System.out.println(pq.take());
        System.out.println(pq.take());
        System.out.println(pq.take());
        System.out.println(pq.take());
    &#125;
&#125;
</code></pre>
<img data-src="/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618183114429.png" class="">


<p>从结果证明，这个优先级队列，并不是在put数据的时候计算谁在前谁在后<br>而是取数据的时候，才真正判断谁在前 谁在后</p>
<p>优先级 –》取数据的优先级</p>
<div name=queue_impl5>



<blockquote>
<p>DelayQueue</p>
</blockquote>
<p>一、DelayQueue是什么<br>DelayQueue是一个无界的BlockingQueue，用于放置实现了Delayed接口的对象，其中的对象只能在其到期时才能从队列中取走。</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618183216715.png" class="">


<p>​	 当生产者线程调用put之类的方法加入元素时，会触发Delayed接口中的compareTo方法进行排序，也就是说队列中元素的顺序是按到期时间排序的，而非它们进入队列的顺序。排在队列头部的元素是最早到期的，越往后到期时间赿晚。</p>
<p>消费者线程查看队列头部的元素，注意是查看不是取出。然后调用元素的getDelay方法，如果此方法返回的值小０或者等于０，则消费者线程会从队列中取出此元素，并进行处理。如果getDelay方法返回的值大于0，则消费者线程wait返回的时间值后，再从队列头部取出元素，此时元素应该已经到期。</p>
<p>​	注意：不能将null元素放置到这种队列中。</p>
<p>二、DelayQueue能做什么</p>
<ol>
<li><p>淘宝订单业务:下单之后如果三十分钟之内没有付款就自动取消订单。</p>
</li>
<li><p>饿了吗订餐通知:下单成功后60s之后给用户发送短信通知。</p>
</li>
<li><p>关闭空闲连接。服务器中，有很多客户端的连接，空闲一段时间之后需要关闭之。</p>
</li>
<li><p>缓存。缓存中的对象，超过了空闲时间，需要从缓存中移出。</p>
</li>
<li><p>任务超时处理。在网络协议滑动窗口请求应答式交互时，处理超时未响应的请求等。</p>
</li>
</ol>
<p>案例：</p>
<pre><code class="java">public class User implements Delayed &#123;
    private int id;//用户id
    private String name;//用户名字
    private long endTime;//结束时间
    public int getId() &#123;
        return id;
    &#125;
    public void setId(int id) &#123;
        this.id = id;
    &#125;
    public String getName() &#123;
        return name;
    &#125;
    public void setName(String name) &#123;
        this.name = name;
    &#125;
    public long getEndTime() &#123;
        return endTime;
    &#125;
    public void setEndTime(long endTime) &#123;
        this.endTime = endTime;
    &#125;
    public User(int id, String name, long endTime) &#123;
        this.id = id;
        this.name = name;
        this.endTime = endTime;
    &#125;
    //只包装用户名字就可以
    @Override
    public String toString() &#123;
        return &quot;User&#123;&quot; +
                &quot;name=&#39;&quot; + name + &#39;\&#39;&#39; +
                &#39;&#125;&#39;;
    &#125;
    @Override
    public long getDelay(TimeUnit unit) &#123;
        //计算剩余时间 剩余时间小于0 &lt;=0  证明已经到期
        return this.getEndTime() - System.currentTimeMillis();
    &#125;
    @Override
    public int compareTo(Delayed o) &#123;
        //队列中数据 到期时间的比较
        User other = (User)o;
        return ((Long)(this.getEndTime())).compareTo((Long)(other.getEndTime()));
    &#125;
&#125;
</code></pre>
<p>compareTo：看谁先被移除<br>getDelay ：看剩余时间</p>
<pre><code class="java">public class TestDelayQueue &#123;
    //创建一个队列：
    DelayQueue&lt;User&gt; dq = new DelayQueue&lt;&gt;();
    //登录游戏：
    public void login(User user)&#123;
        dq.add(user);
        System.out.println(&quot;用户：[&quot; + user.getId() +&quot;],[&quot; + user.getName() + &quot;]已经登录，预计下机时间为：&quot; + user.getEndTime() );
    &#125;
    //时间到，退出游戏，队列中移除：
    public void logout()&#123;
        //打印队列中剩余的人：
        System.out.println(dq);
        try &#123;
            User user = dq.take();
            System.out.println(&quot;用户：[&quot; + user.getId() +&quot;],[&quot; + user.getName() + &quot;]上机时间到，自动退出游戏&quot;);
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
    //获取在线人数：
    public int onlineSize()&#123;
        return dq.size();
    &#125;
    //这是main方法，程序的入口
    public static void main(String[] args) &#123;
        //创建测试类对象：
        TestDelayQueue test = new TestDelayQueue();
        //添加登录的用户：
        test.login(new User(1,&quot;张三&quot;,System.currentTimeMillis()+5000));
        test.login(new User(2,&quot;李四&quot;,System.currentTimeMillis()+2000));
        test.login(new User(3,&quot;王五&quot;,System.currentTimeMillis()+10000));
        //一直监控
        while(true)&#123;
            //到期的话，就自动下线：
            test.logout();
            //队列中元素都被移除了的话，那么停止监控，停止程序即可
            if(test.onlineSize() == 0)&#123;
                break;
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<img data-src="/2022/10/07/Java/%E7%AC%AC11%E7%AB%A0%E9%9B%86%E5%90%88/image-20220618183342855.png" class="">






<h3 id="双端队列Deque"><a href="#双端队列Deque" class="headerlink" title="双端队列Deque"></a>双端队列Deque</h3><pre><code class="java">public class Test03 &#123;
    //这是main方法，程序的入口
    public static void main(String[] args) &#123;
        /*
        双端队列：
        Deque&lt;E&gt; extends Queue
        Queue一端放 一端取的基本方法  Deque是具备的
        在此基础上 又扩展了 一些 头尾操作（添加，删除，获取）的方法
         */
        Deque&lt;String&gt; d = new LinkedList&lt;&gt;() ;
        d.offer(&quot;A&quot;);
        d.offer(&quot;B&quot;);
        d.offer(&quot;C&quot;);
        System.out.println(d);//[A, B, C]
        d.offerFirst(&quot;D&quot;);
        d.offerLast(&quot;E&quot;);
        System.out.println(d);//[D, A, B, C, E]
        System.out.println(d.poll());
        System.out.println(d);//[A, B, C, E]
        System.out.println(d.pollFirst());
        System.out.println(d.pollLast());
        System.out.println(d);
    &#125;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>JavaSE</category>
        <category>集合</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title>第12章IO</title>
    <url>/2022/10/07/Java/%E7%AC%AC12%E7%AB%A0IO/</url>
    <content><![CDATA[<h1 id="12-IO流"><a href="#12-IO流" class="headerlink" title="12 IO流"></a>12 IO流</h1><h1 id="File类"><a href="#File类" class="headerlink" title="File类"></a>File类</h1><h2 id="1-对文件进行操作"><a href="#1-对文件进行操作" class="headerlink" title="1 对文件进行操作"></a>1 对文件进行操作</h2><pre><code class="java">public class Test01 &#123;
    //这是一个main方法，是程序的入口：
    public static void main(String[] args) throws IOException &#123;
        //将文件封装为一个File类的对象：
        File f = new File(&quot;d:\\test.txt&quot;);
        File f1 = new File(&quot;d:\\test.txt&quot;);
        File f2 = new File(&quot;d:/test.txt&quot;);
        //File.separator属性帮我们获取当前操作系统的路径拼接符号
       //在windows，dos下，系统默认用“\”作为路径分隔符 ，在unix，url中，使用“/”作为路径分隔符。
        File f3 = new File(&quot;d:&quot;+File.separator+&quot;test.txt&quot;);//建议使用这种
        //常用方法：
        System.out.println(&quot;文件是否可读：&quot;+f.canRead());
        System.out.println(&quot;文件是否可写：&quot;+f.canWrite());
        System.out.println(&quot;文件的名字：&quot;+f.getName());
        System.out.println(&quot;上级目录：&quot;+f.getParent());
        System.out.println(&quot;是否是一个目录：&quot;+f.isDirectory());
        System.out.println(&quot;是否是一个文件：&quot;+f.isFile());
        System.out.println(&quot;是否隐藏：&quot;+f.isHidden());
        System.out.println(&quot;文件的大小：&quot;+f.length());
        System.out.println(&quot;是否存在：&quot;+f.exists());
        /*if(f.exists())&#123;//如果文件存在，将文件删除操作
            f.delete();
        &#125;else&#123;//如果不存在，就创建这个文件
            f.createNewFile();
        &#125;*/
        System.out.println(f == f1);//比较两个对象的地址
        System.out.println(f.equals(f1));//比较两个对象对应的文件的路径
        //跟路径相关的：
        System.out.println(&quot;绝对路径：&quot;+f.getAbsolutePath());
        System.out.println(&quot;相对路径：&quot;+f.getPath());
        System.out.println(&quot;toString:&quot;+f.toString());
        System.out.println(&quot;----------------------&quot;);
        File f5 = new File(&quot;demo.txt&quot;);
        if(!f5.exists())&#123;
            f5.createNewFile();
        &#125;
        //绝对路径指的就是：真实的一个精准的，完整的路径
        System.out.println(&quot;绝对路径：&quot;+f5.getAbsolutePath());
        //相对路径：有一个参照物，相对这个参照物的路径。
        //在main方法中，相对位置指的就是：D:\IDEA_workspace\TestJavaSE
        //在junit的测试方法中，相对路径指的就是模块位置
        System.out.println(&quot;相对路径：&quot;+f5.getPath());
        //toString的效果永远是  相对路径
        System.out.println(&quot;toString:&quot;+f5.toString());
        File f6 = new File(&quot;a/b/c/demo.txt&quot;);
        if(!f5.exists())&#123;
            f5.createNewFile();
        &#125;
        System.out.println(&quot;绝对路径：&quot;+f6.getAbsolutePath());
        System.out.println(&quot;相对路径：&quot;+f6.getPath());
    &#125;
&#125;
</code></pre>
<h2 id="2-对目录进行操作"><a href="#2-对目录进行操作" class="headerlink" title="2 对目录进行操作"></a>2 对目录进行操作</h2><pre><code class="java">public class Test02 &#123;
    //这是一个main方法，是程序的入口：
    public static void main(String[] args) &#123;
        //将目录封装为File类的对象：
        File f = new File(&quot;D:\\IDEA_workspace&quot;);
        System.out.println(&quot;文件是否可读：&quot;+f.canRead());
        System.out.println(&quot;文件是否可写：&quot;+f.canWrite());
        System.out.println(&quot;文件的名字：&quot;+f.getName());
        System.out.println(&quot;上级目录：&quot;+f.getParent());
        System.out.println(&quot;是否是一个目录：&quot;+f.isDirectory());
        System.out.println(&quot;是否是一个文件：&quot;+f.isFile());
        System.out.println(&quot;是否隐藏：&quot;+f.isHidden());
        System.out.println(&quot;文件的大小：&quot;+f.length());
        System.out.println(&quot;是否存在：&quot;+f.exists());
        System.out.println(&quot;绝对路径：&quot;+f.getAbsolutePath());
        System.out.println(&quot;相对路径：&quot;+f.getPath());
        System.out.println(&quot;toString:&quot;+f.toString());
        //跟目录相关的方法：
        File f2 = new File(&quot;D:\\a\\b\\c&quot;);
        //创建目录：
        //f2.mkdir();//创建单层目录
        //f2.mkdirs();//创建多层目录
        //删除：如果是删除目录的话，只会删除一层，并且前提：这层目录是空的，里面没有内容，如果内容就不会被删除
        f2.delete();
        //查看：
        String[] list = f.list();//文件夹下目录/文件对应的名字的数组
        for(String s:list)&#123;
            System.out.println(s);
        &#125;
        System.out.println(&quot;=========================&quot;);
        File[] files = f.listFiles();//作用更加广泛
        for(File file:files)&#123;
            System.out.println(file.getName()+&quot;,&quot;+file.getAbsolutePath());
        &#125;
    &#125;
&#125;
</code></pre>
<h1 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h1><h2 id="1-引入"><a href="#1-引入" class="headerlink" title="1 引入"></a>1 引入</h2><p>【1】File类：封装文件&#x2F;目录的各种信息，对目录&#x2F;文件进行操作，但是我们不可以获取到文件&#x2F;目录中的内容。<br>【2】引入：IO流：<br>I&#x2F;O ： Input&#x2F;Output的缩写，用于处理设备之间的数据的传输。<br>【3】形象理解：IO流 当做一根 “管”：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC12%E7%AB%A0IO/image-20220618184436805.png" class="">





<p>【4】IO流的体系结构：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC12%E7%AB%A0IO/image-20220618184443031.png" class="">






<h2 id="2-案例：通过java程序完成文件的复制操作"><a href="#2-案例：通过java程序完成文件的复制操作" class="headerlink" title="2 案例：通过java程序完成文件的复制操作"></a>2 案例：通过java程序完成文件的复制操作</h2><h3 id="功能分解1：文件–》程序：FileReader"><a href="#功能分解1：文件–》程序：FileReader" class="headerlink" title="功能分解1：文件–》程序：FileReader"></a>功能分解1：文件–》程序：FileReader</h3><p>一个字符一个字符的将文件中的内容读取到程序中了：</p>
<pre><code class="java">public class Test01 &#123;
    //这是一个main方法，是程序的入口：
    public static void main(String[] args) throws IOException &#123;
        //文件--》程序：
        //1.有一个文件：----》创建一个File类的对象
        File f = new File(&quot;d:\\Test.txt&quot;);
        //2.利用FileReader这个流，这个“管”怼到源文件上去   ---》创建一个FileReader的流的对象
        FileReader fr = new FileReader(f);
        //3.进行操作“吸”的动作  ---》读取动作
        /*下面的代码我们验证了：如果到了文件的结尾处，那么读取的内容为-1
        int n1 = fr.read();
        int n2 = fr.read();
        int n3 = fr.read();
        int n4 = fr.read();
        int n5 = fr.read();
        int n6 = fr.read();
        System.out.println(n1);
        System.out.println(n2);
        System.out.println(n3);
        System.out.println(n4);
        System.out.println(n5);
        System.out.println(n6);*/
        //方式1：
        /*int n = fr.read();
        while(n!=-1)&#123;
            System.out.println(n);
            n = fr.read();
        &#125;*/
        //方式2：
        int n;
        while((n = fr.read())!=-1)&#123;
            System.out.println((char)n);
        &#125;
        //4.“管”不用了，就要关闭  ---》关闭流
        //流，数据库，网络资源，靠jvm本身没有办法帮我们关闭，此时必须程序员手动关闭：
        fr.close();
    &#125;
&#125;
</code></pre>
<p>想一次性读取五个字符，不够的话下次再读五个字符：</p>
<pre><code class="java">public class Test02 &#123;
    //这是一个main方法，是程序的入口：
    public static void main(String[] args) throws IOException &#123;
        //文件--》程序：
        //1.创建一个File类的对象
        File f = new File(&quot;d:\\Test.txt&quot;);
        //2.创建一个FileReader的流的对象
        FileReader fr = new FileReader(f);
        //3.读取动作
        //引入一个“快递员的小车”，这个“小车”一次拉5个快递：
        char[] ch = new char[5];//缓冲数组
        int len = fr.read(ch);//一次读取五个:返回值是这个数组中 的有效长度
        while(len!=-1)&#123;
            //System.out.println(len);
            //错误方式：
            /*for (int i = 0 ;i &lt; ch.length;i++)&#123;
                System.out.println(ch[i]);
            &#125;*/
            //正确方式：
            /*for (int i = 0 ;i &lt; len;i++)&#123;
                System.out.println(ch[i]);
            &#125;*/
            //正确方式2：将数组转为String：
            String str = new String(ch,0,len);
            System.out.print(str);
            len = fr.read(ch);
        &#125;
        //4.关闭流
        fr.close();
    &#125;
&#125;
</code></pre>
<h3 id="功能分解2：程序–》文件：FileWriter"><a href="#功能分解2：程序–》文件：FileWriter" class="headerlink" title="功能分解2：程序–》文件：FileWriter"></a>功能分解2：程序–》文件：FileWriter</h3><p>一个字符一个字符的向外输出：</p>
<pre><code class="java">public class Test03 &#123;
    //这是一个main方法，是程序的入口：
    public static void main(String[] args) throws IOException &#123;
        //1.有个目标文件：
        File f = new File(&quot;d:\\demo.txt&quot;);
        //2.FileWriter管怼到文件上去：
        FileWriter fw = new FileWriter(f);
        //3.开始动作：输出动作：
        //一个字符一个字符的往外输出：
        String str = &quot;hello你好&quot;;
        for (int i = 0 ;i &lt; str.length();i++)&#123;
            fw.write(str.charAt(i));
        &#125;
        //4.关闭流：
        fw.close();
    &#125;
&#125;
</code></pre>
<p>发现：<br>如果目标文件不存在的话，那么会自动创建此文件。<br>如果目标文件存在的话：<br>new FileWriter(f)   相当于对原文件进行覆盖操作。<br>new FileWriter(f,false)  相当于对源文件进行覆盖操作。不是追加。<br>new FileWriter(f,true)   对原来的文件进行追加，而不是覆盖。</p>
<p><strong>利用缓冲数组：向外输出（利用缓冲数组：）</strong></p>
<pre><code class="java">public class Test03 &#123;
    //这是一个main方法，是程序的入口：
    public static void main(String[] args) throws IOException &#123;
        //1.有个目标文件：
        File f = new File(&quot;d:\\demo.txt&quot;);
        //2.FileWriter管怼到文件上去：
        FileWriter fw = new FileWriter(f,true);
        //3.开始动作：输出动作：
        //一个字符一个字符的往外输出：
        String str = &quot;你好中国&quot;;
        char[] chars = str.toCharArray();
        fw.write(chars);
        //4.关闭流：
        fw.close();
    &#125;
&#125;
</code></pre>
<h3 id="功能分解3：利用FileReader，FileWriter文件复制"><a href="#功能分解3：利用FileReader，FileWriter文件复制" class="headerlink" title="功能分解3：利用FileReader，FileWriter文件复制"></a>功能分解3：利用FileReader，FileWriter文件复制</h3><pre><code class="java">public class Test04 &#123;
    //这是一个main方法，是程序的入口：
    public static void main(String[] args) throws IOException &#123;
        //1.有一个源文件
        File f1 = new File(&quot;d:\\Test.txt&quot;);
        //2.有一个目标文件：
        File f2 = new File(&quot;d:\\Demo.txt&quot;);
        //3.搞一个输入的管 怼到源文件上：
        FileReader fr = new FileReader(f1);
        //4.搞一个输出的管，怼到目标文件上：
        FileWriter fw = new FileWriter(f2);
        //5.开始动作：
        //方式1：一个字符一个字符的复制：
        /*int n = fr.read();
        while(n!=-1)&#123;
            fw.write(n);
            n = fr.read();
        &#125;*/
        //方式2：利用缓冲字符数组：
        /*char[] ch = new char[5];
        int len = fr.read(ch);
        while(len!=-1)&#123;
            fw.write(ch,0,len);//将缓冲数组中有效长度写出
            len = fr.read(ch);
        &#125;*/
        //方式3：利用缓冲字符数组，将数组转为String写出。
        char[] ch = new char[5];
        int len = fr.read(ch);
        while(len!=-1)&#123;
            String s = new String(ch,0,len);
            fw.write(s);
            len = fr.read(ch);
        &#125;
        //6.关闭流：(关闭流的时候，倒着关闭，后用先关)
        fw.close();
        fr.close();
    &#125;
&#125;
</code></pre>
<h2 id="3-警告：不要用字符流去操作非文本文件"><a href="#3-警告：不要用字符流去操作非文本文件" class="headerlink" title="3 警告：不要用字符流去操作非文本文件"></a>3 警告：不要用字符流去操作非文本文件</h2><p>文本文件：.txt   .java  .c  .cpp  —》建议使用字符流操作<br>非文本文件：.jpg,  .mp3  ,   .mp4 , .doc  , .ppt  —》建议使用字节流操作</p>
<h2 id="4-用try-catch-finally处理异常方式"><a href="#4-用try-catch-finally处理异常方式" class="headerlink" title="4 用try-catch-finally处理异常方式"></a>4 用try-catch-finally处理异常方式</h2><pre><code class="java">public class Test04 &#123;
    //这是一个main方法，是程序的入口：
    public static void main(String[] args)  &#123;
        //1.有一个源文件
        File f1 = new File(&quot;d:\\Test.txt&quot;);
        //2.有一个目标文件：
        File f2 = new File(&quot;d:\\Demo.txt&quot;);
        //3.搞一个输入的管 怼到源文件上：
        FileReader fr = null;
        FileWriter fw = null;
        try &#123;
            fr = new FileReader(f1);
            //4.搞一个输出的管，怼到目标文件上：
            fw = new FileWriter(f2);
            //5.开始动作：
            char[] ch = new char[5];
            int len = fr.read(ch);
            while(len!=-1)&#123;
                String s = new String(ch,0,len);
                fw.write(s);
                len = fr.read(ch);
            &#125;
        &#125; catch (FileNotFoundException e) &#123;
            e.printStackTrace();
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125; finally &#123;
            //6.关闭流：(关闭流的时候，倒着关闭，后用先关)
            try &#123;
                if(fw!=null)&#123;//防止空指针异常
                    fw.close();
                &#125;
            &#125; catch (IOException e) &#123;
                e.printStackTrace();
            &#125;
            try &#123;
                if(fr!=null)&#123;
                    fr.close();
                &#125;
            &#125; catch (IOException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<h2 id="5-FileInputStream读取文件中内容"><a href="#5-FileInputStream读取文件中内容" class="headerlink" title="5 FileInputStream读取文件中内容"></a>5 FileInputStream读取文件中内容</h2><p>【1】读取文本文件：</p>
<pre><code class="java">public class Test01 &#123;
    //这是一个main方法，是程序的入口：
    public static void main(String[] args) throws IOException &#123;
        //功能：利用字节流将文件中内容读到程序中来：
        //1.有一个源文件：
        File f = new File(&quot;D:\\Test.txt&quot;);
        //2.将一个字节流这个管 怼  到 源文件上：
        FileInputStream fis = new FileInputStream(f);
        //3.开始读取动作
        /*
        细节1：
        文件是utf-8进行存储的，所以英文字符 底层实际占用1个字节
        但是中文字符，底层实际占用3个字节。
        细节2：
        如果文件是文本文件，那么就不要使用字节流读取了，建议使用字符流。
        细节3：
        read()读取一个字节，但是你有没有发现返回值是 int类型，而不是byte类型？
        read方法底层做了处理，让返回的数据都是“正数”
        就是为了避免如果字节返回的是-1的话，那到底是读入的字节，还是到文件结尾呢。
         */
        int n = fis.read();
        while(n!=-1)&#123;
            System.out.println(n);
            n = fis.read();
        &#125;
        //4.关闭流：
        fis.close();
    &#125;
&#125;
</code></pre>
<p>【2】利用字节流读取非文本文件：（以图片为案例：）–》一个字节一个字节的读取：</p>
<pre><code class="java">public class Test02 &#123;
    //这是一个main方法，是程序的入口：
    public static void main(String[] args) throws IOException &#123;
        //功能：利用字节流将文件中内容读到程序中来：
        //1.有一个源文件：
        File f = new File(&quot;D:\\LOL.jpg&quot;);
        //2.将一个字节流这个管 怼  到 源文件上：
        FileInputStream fis = new FileInputStream(f);
        //3.开始读取动作
        int count = 0;//定义一个计数器，用来计读入的字节的个数
        int n = fis.read();
        while(n!=-1)&#123;
            count++;
            System.out.println(n);
            n = fis.read();
        &#125;
        System.out.println(&quot;count=&quot;+count);
        //4.关闭流：
        fis.close();
    &#125;
&#125;
</code></pre>
<p>【3】利用字节类型的缓冲数组：</p>
<pre><code class="java">public class Test03 &#123;
    //这是一个main方法，是程序的入口：
    public static void main(String[] args) throws IOException &#123;
        //功能：利用字节流将文件中内容读到程序中来：
        //1.有一个源文件：
        File f = new File(&quot;D:\\LOL.jpg&quot;);
        //2.将一个字节流这个管 怼  到 源文件上：
        FileInputStream fis = new FileInputStream(f);
        //3.开始读取动作
        //利用缓冲数组：（快递员的小车）
        byte[] b = new byte[1024*6];
        int len = fis.read(b);//len指的就是读取的数组中的有效长度
        while(len!=-1)&#123;
            //System.out.println(len);
            for(int i = 0;i&lt;len;i++)&#123;
                System.out.println(b[i]);
            &#125;
            len = fis.read(b);
        &#125;
        //4.关闭流：
        fis.close();
    &#125;
&#125;
</code></pre>
<h2 id="6-FileInputStream-FileOutputStream完成非文本文件的复制"><a href="#6-FileInputStream-FileOutputStream完成非文本文件的复制" class="headerlink" title="6 FileInputStream,FileOutputStream完成非文本文件的复制"></a>6 FileInputStream,FileOutputStream完成非文本文件的复制</h2><p>【1】读入一个字节，写出一个字节：</p>
<pre><code class="java">public class Test04 &#123;
    //这是一个main方法，是程序的入口：
    public static void main(String[] args) throws IOException &#123;
        //功能：完成图片的复制：
        //1.有一个源图片
        File f1 = new File(&quot;d:\\LOL.jpg&quot;);
        //2.有一个目标图片：
        File f2 = new File(&quot;d:\\LOL2.jpg&quot;);
        //3.有一个输入的管道 怼 到 源文件：
        FileInputStream fis = new FileInputStream(f1);
        //4.有一个输出的管道 怼到  目标文件上：
        FileOutputStream fos = new FileOutputStream(f2);
        //5.开始复制：（边读边写）
        int n = fis.read();
        while(n!=-1)&#123;
            fos.write(n);
            n = fis.read();
        &#125;
        //6.关闭流：(倒着关闭流，先用后关)
        fos.close();
        fis.close();
    &#125;
&#125;
</code></pre>
<p>【2】利用缓冲字节数组：</p>
<pre><code class="java">public class Test05 &#123;
    //这是一个main方法，是程序的入口：
    public static void main(String[] args) throws IOException &#123;
        //功能：完成图片的复制：
        //1.有一个源图片
        File f1 = new File(&quot;d:\\LOL.jpg&quot;);
        //2.有一个目标图片：
        File f2 = new File(&quot;d:\\LOL2.jpg&quot;);
        //3.有一个输入的管道 怼 到 源文件：
        FileInputStream fis = new FileInputStream(f1);
        //4.有一个输出的管道 怼到  目标文件上：
        FileOutputStream fos = new FileOutputStream(f2);
        //5.开始复制：（边读边写）
        //利用缓冲数组：
        byte[] b = new byte[1024*8];
        int len = fis.read(b);
        while(len!=-1)&#123;
            fos.write(b,0,len);
            len = fis.read(b);
        &#125;
        //6.关闭流：(倒着关闭流，先用后关)
        fos.close();
        fis.close();
    &#125;
&#125;
</code></pre>
<h2 id="7-缓冲字节流-处理流-BufferedInputStream-BufferedOutputStream"><a href="#7-缓冲字节流-处理流-BufferedInputStream-BufferedOutputStream" class="headerlink" title="7 缓冲字节流(处理流)-BufferedInputStream ,BufferedOutputStream"></a>7 缓冲字节流(处理流)-BufferedInputStream ,BufferedOutputStream</h2><p>【1】读入一个字节，写出一个字节：</p>
<p>【2】利用缓冲字节数组：</p>
<p>【3】利用缓冲区：</p>
<p>想要完成上面的效果，单纯的靠FileInputStream,FileOutputStream是不可以完成的，这个时候就需要功能的加强，<br>这个加强就需要引入新的流（在FileInputStream,FileOutputStream外面再套一层流）：BufferedInputStream ,BufferedOutputStream. —–&gt;处理流</p>
<p>代码：</p>
<pre><code class="java">public class Test06 &#123;
    //这是一个main方法，是程序的入口：
    public static void main(String[] args) throws IOException &#123;
        //1.有一个源图片
        File f1 = new File(&quot;d:\\LOL.jpg&quot;);
        //2.有一个目标图片：
        File f2 = new File(&quot;d:\\LOL2.jpg&quot;);
        //3.有一个输入的管道 怼 到 源文件：
        FileInputStream fis = new FileInputStream(f1);
        //4.有一个输出的管道 怼到  目标文件上：
        FileOutputStream fos = new FileOutputStream(f2);
        //5.功能加强，在FileInputStream外面套一个管：BufferedInputStream:
        BufferedInputStream bis = new BufferedInputStream(fis);
        //6.功能加强，在FileOutputStream外面套一个管：BufferedOutputStream:
        BufferedOutputStream bos = new BufferedOutputStream(fos);
        //7.开始动作 ：
        byte[] b = new byte[1024*6];
        int len = bis.read(b);
        while(len!=-1)&#123;
            bos.write(b,0,len);
           /* bos.flush(); 底层已经帮我们做了刷新缓冲区的操作，不用我们手动完成：底层调用flushBuffer()*/
            len = bis.read(b);
        &#125;
        //8.关闭流：
        //倒着关：
        //如果处理流包裹着节点流的话，那么其实只要关闭高级流（处理流），那么里面的字节流也会随之被关闭。
        bos.close();
        bis.close();
        /*fos.close();
        fis.close();*/
    &#125;
&#125;
</code></pre>
<h2 id="8-比对非文本文件复制的三种方法的效率"><a href="#8-比对非文本文件复制的三种方法的效率" class="headerlink" title="8 比对非文本文件复制的三种方法的效率"></a>8 比对非文本文件复制的三种方法的效率</h2><p>【1】读入一个字节，写出一个字节：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC12%E7%AB%A0IO/image-20220618184948658.png" class="">


<p>【2】利用缓冲字节数组：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC12%E7%AB%A0IO/image-20220618184953685.png" class="">


<p>【3】利用缓冲区：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC12%E7%AB%A0IO/image-20220618184958715.png" class="">


<p>代码：</p>
<pre><code class="java">public class Test06 &#123;
    //这是一个main方法，是程序的入口：
    public static void main(String[] args) throws IOException &#123;
        //1.有一个源图片
        File f1 = new File(&quot;d:\\LOL.jpg&quot;);
        //2.有一个目标图片：
        File f2 = new File(&quot;d:\\LOL2.jpg&quot;);
        //3.有一个输入的管道 怼 到 源文件：
        FileInputStream fis = new FileInputStream(f1);
        //4.有一个输出的管道 怼到  目标文件上：
        FileOutputStream fos = new FileOutputStream(f2);
        //5.功能加强，在FileInputStream外面套一个管：BufferedInputStream:
        BufferedInputStream bis = new BufferedInputStream(fis);
        //6.功能加强，在FileOutputStream外面套一个管：BufferedOutputStream:
        BufferedOutputStream bos = new BufferedOutputStream(fos);
        //7.开始动作 ：
        long startTime = System.currentTimeMillis();
        byte[] b = new byte[1024];
        int len = bis.read(b);
        while(len!=-1)&#123;
            bos.write(b,0,len);
           /* bos.flush(); 底层已经帮我们做了刷新缓冲区的操作，不用我们手动完成：底层调用flushBuffer()*/
            len = bis.read(b);
        &#125;
        long endTime = System.currentTimeMillis();
        System.out.println(&quot;复制完成的时间为：&quot;+(endTime-startTime));
        //8.关闭流：
        //倒着关：
        //如果处理流包裹着节点流的话，那么其实只要关闭高级流（处理流），那么里面的字节流也会随之被关闭。
        bos.close();
        bis.close();
        /*fos.close();
        fis.close();*/
    &#125;
&#125;
</code></pre>
<h2 id="9-缓冲字符流-处理流-BufferedReader-BufferedWriter完成文本文件的复制"><a href="#9-缓冲字符流-处理流-BufferedReader-BufferedWriter完成文本文件的复制" class="headerlink" title="9 缓冲字符流(处理流)-BufferedReader,BufferedWriter完成文本文件的复制"></a>9 缓冲字符流(处理流)-BufferedReader,BufferedWriter完成文本文件的复制</h2><pre><code class="java">public class Test07 &#123;
    //这是一个main方法，是程序的入口：
    public static void main(String[] args) throws IOException &#123;
        //1.有一个源文件：
        File f1 = new File(&quot;d:\\Test.txt&quot;);
        //2.有一个目标文件：
        File f2 = new File(&quot;d:\\Demo.txt&quot;);
        //3.需要一个管 怼到 源文件：
        FileReader fr = new FileReader(f1);
        //4.需要一根管怼到目标文件：
        FileWriter fw = new FileWriter(f2);
        //5.套一根管在输入字符流外面：
        BufferedReader br = new BufferedReader(fr);
        //6.套一根管在输出字符流外面：
        BufferedWriter bw = new BufferedWriter(fw);
        //7.开始动作：
        //方式1：读取一个字符，输出一个字符：
        /*int n = br.read();
        while(n!=-1)&#123;
            bw.write(n);
            n = br.read();
        &#125;*/
        //方式2:利用缓冲数组：
        /*char[] ch = new char[30];
        int len = br.read(ch);
        while(len!=-1)&#123;
            bw.write(ch,0,len);
            len = br.read(ch);
        &#125;*/
        //方式3：读取String：
        String str = br.readLine();//每次读取文本文件中一行，返回字符串
        while(str!=null)&#123;
            bw.write(str);
            //在文本文件中应该再写出一个换行：
            bw.newLine();//新起一行
            str = br.readLine();
        &#125;
        //8.关闭流
        bw.close();
        br.close();
    &#125;
&#125;
</code></pre>
<h2 id="10-转换流-InputStreamReader-OutputStreamWriter"><a href="#10-转换流-InputStreamReader-OutputStreamWriter" class="headerlink" title="10 转换流-InputStreamReader,OutputStreamWriter"></a>10 转换流-InputStreamReader,OutputStreamWriter</h2><p>【1】转换流：作用：将字节流和字符流进行转换。<br>【2】转换流  属于 字节流还是字符流？属于字符流<br>InputStreamReader  ：字节输入流 —》字符的输入流<br>OutputStreamWriter  ： 字符输出流 –》字节的输出流</p>
<p>【3】图解：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC12%E7%AB%A0IO/image-20220618185049182.png" class="">


<p>【4】将输入的字节流转换为输入的字符流，然后完成文件–》程序 ：</p>
<pre><code class="java">public class Test01 &#123;
    //这是一个main方法，是程序的入口：
    public static void main(String[] args) throws IOException &#123;
        //文件---》程序：
        //1.有一个源文件：
        File f = new File(&quot;d:\\Test.txt&quot;);
        //2.需要一个输入的字节流接触文件：
        FileInputStream fis = new FileInputStream(f);
        //3.加入一个转换流，将字节流转换为字符流：（转换流属于一个处理流）
        //将字节转换为字符的时候，需要指定一个编码，这个编码跟文件本身的编码格式统一
        //如果编码格式不统一的话，那么在控制台上展示的效果就会出现乱码
        //InputStreamReader isr = new InputStreamReader(fis,&quot;utf-8&quot;);
        //获取程序本身的编码--》utf-8
        InputStreamReader isr = new InputStreamReader(fis);
        //4.开始动作，将文件中内容显示在控制台：
        char[] ch = new char[20];
        int len = isr.read(ch);
        while(len!=-1)&#123;
            //将缓冲数组转为字符串在控制台上打印出来
            System.out.print(new String(ch,0,len));
            len = isr.read(ch);
        &#125;
        //5.关闭流：
        isr.close();
    &#125;
&#125;
</code></pre>
<h2 id="11-转换流-InputStreamReader-OutputStreamWriter实现文本文件的复制"><a href="#11-转换流-InputStreamReader-OutputStreamWriter实现文本文件的复制" class="headerlink" title="11 转换流-InputStreamReader,OutputStreamWriter实现文本文件的复制"></a>11 转换流-InputStreamReader,OutputStreamWriter实现文本文件的复制</h2><pre><code class="java">public class Test02 &#123;
    //这是一个main方法，是程序的入口：
    public static void main(String[] args) throws IOException &#123;
        //1.有一个源文件
        File f1 = new File(&quot;d:\\Test.txt&quot;);
        //2.有一个目标文件：
        File f2 = new File(&quot;d:\\Demo.txt&quot;);
        //3.输入方向：
        FileInputStream fis = new FileInputStream(f1);
        InputStreamReader isr = new InputStreamReader(fis,&quot;utf-8&quot;);
        //4.输出方向：
        FileOutputStream fos = new FileOutputStream(f2);
        OutputStreamWriter osw = new OutputStreamWriter(fos,&quot;gbk&quot;);
        //5.开始动作：
        char[] ch = new char[20];
        int len = isr.read(ch);
        while(len!=-1)&#123;
            osw.write(ch,0,len);
            len = isr.read(ch);
        &#125;
        //6.关闭流：
        osw.close();
        isr.close();
    &#125;
&#125;
</code></pre>
<h2 id="12-System类对IO流的支持"><a href="#12-System类对IO流的支持" class="headerlink" title="12 System类对IO流的支持"></a>12 System类对IO流的支持</h2><p>【1】System的属性：<br>System.in  : “标准”输入流。—》默认情况下  从键盘输入<br>System.out  :“标准”输出流。 —》默认情况下，输出到控制台。</p>
<p>【2】System.in ：“标准”输入流。—》默认情况下  从键盘输入</p>
<pre><code class="java">public class Test01 &#123;
    //这是一个main方法，是程序的入口：
    public static void main(String[] args) throws IOException &#123;
        //得到的是标准的输入流：--》从键盘输入：
        //InputStream in = System.in;
        //调用方法：
        //int n = in.read();//read方法等待键盘的录入，所以这个方法是一个阻塞方法。
        //System.out.println(n);
        //以前案例：从键盘录入一个int类型的数据：
        //从上面的代码证明，键盘录入实际上是：System.in
        //形象的理解：System.in管，这个管怼到键盘上去了，所以你从键盘录入的话，就从这个管到程序中了
        //Scanner的作用：扫描器：起扫描作用的，扫键盘的从这根管出来的数据
        /*Scanner sc = new Scanner(System.in);
        int i = sc.nextInt();
        System.out.println(i);*/
        //既然Scanner是扫描的作用，不一定非得扫 System.in进来的东西，还可以扫描其他管的内容：
        Scanner sc = new Scanner(new FileInputStream(new File(&quot;d:\\Test.txt&quot;)));
        while(sc.hasNext())&#123;
            System.out.println(sc.next());
        &#125;
    &#125;
&#125;
</code></pre>
<p>【3】System.out  : 返回的输出流 、 打印流（PrintStream）</p>
<pre><code class="java">public class Test02 &#123;
    //这是一个main方法，是程序的入口：
    public static void main(String[] args) &#123;
        //写到控制台：
        PrintStream out = System.out;
        //调用方法：
        out.print(&quot;你好1&quot;);//直接在控制台写出，但是不换行
        out.print(&quot;你好2&quot;);
        out.print(&quot;你好3&quot;);
        out.print(&quot;你好4&quot;);
        out.println(&quot;我是中国人1&quot;);//直接在控制台写出，并且换行操作
        out.println(&quot;我是中国人2&quot;);
        out.println(&quot;我是中国人3&quot;);
        out.println(&quot;我是中国人4&quot;);
        System.out.println(&quot;你是&quot;);
        System.out.print(&quot;中国人&quot;);
    &#125;
&#125;
</code></pre>
<h2 id="13-练习：键盘录入内容输出到文件中"><a href="#13-练习：键盘录入内容输出到文件中" class="headerlink" title="13 练习：键盘录入内容输出到文件中"></a>13 练习：键盘录入内容输出到文件中</h2><p>【1】解决思路：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC12%E7%AB%A0IO/image-20220618185310964.png" class="">


<p>【2】代码：</p>
<pre><code class="java">public class Test03 &#123;
    //这是一个main方法，是程序的入口：
    public static void main(String[] args) throws IOException &#123;
        //1.先准备输入方向：
        //键盘录入：
        InputStream in = System.in;//属于字节流
        //字节流--》字符流：
        InputStreamReader isr = new InputStreamReader(in);
        //在isr外面再套一个缓冲流：
        BufferedReader br = new BufferedReader(isr);
        //2.再准备输出方向：
        //准备目标文件
        File f = new File(&quot;d:\\Demo1.txt&quot;);
        FileWriter fw = new FileWriter(f);
        BufferedWriter bw = new BufferedWriter(fw);
        //3.开始动作：
        String s = br.readLine();
        while(!s.equals(&quot;exit&quot;))&#123;
            bw.write(s);
            bw.newLine();//文件中换行
            s = br.readLine();
        &#125;
        //4.关闭流：
        bw.close();
        br.close();
    &#125;
&#125;
</code></pre>
<h2 id="14-数据流-DataInputStream-DataOutputStream"><a href="#14-数据流-DataInputStream-DataOutputStream" class="headerlink" title="14 数据流-DataInputStream,DataOutputStream"></a>14 数据流-DataInputStream,DataOutputStream</h2><p>【1】数据流：用来操作基本数据类型和字符串的<br>【2】<br>DataInputStream:将文件中存储的基本数据类型和字符串  写入  内存的变量中<br>DataOutputStream:  将内存中的基本数据类型和字符串的变量 写出  文件中</p>
<p>【3】代码：</p>
<p>利用DataOutputStream向外写出变量：</p>
<pre><code class="java">public class Test01 &#123;
    //这是一个main方法，是程序的入口：
    public static void main(String[] args) throws IOException &#123;
        //DataOutputStream:  将内存中的基本数据类型和字符串的变量 写出  文件中
        /*File f = new File(&quot;d:\\Demo2.txt&quot;);
        FileOutputStream fos = new FileOutputStream(f);
        DataOutputStream dos = new DataOutputStream(fos);*/
        DataOutputStream dos = new DataOutputStream(new FileOutputStream(new File(&quot;d:\\Demo2.txt&quot;)));
        //向外将变量写到文件中去：
        dos.writeUTF(&quot;你好&quot;);
        dos.writeBoolean(false);
        dos.writeDouble(6.9);
        dos.writeInt(82);
        //关闭流：
        dos.close();
    &#125;
&#125;
</code></pre>
<p>在Demo2.txt文件中，我们看到：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC12%E7%AB%A0IO/image-20220618185411994.png" class="">





<p>发现：这个内容我们看不懂，是给程序看的</p>
<p>所以下面我们开始读取的程序：</p>
<pre><code class="java">public class Test02 &#123;
    //这是一个main方法，是程序的入口：
    public static void main(String[] args) throws IOException &#123;
        //DataInputStream:将文件中存储的基本数据类型和字符串  写入  内存的变量中
        DataInputStream dis = new DataInputStream(new FileInputStream(new File(&quot;d:\\Demo2.txt&quot;)));
        //将文件中内容读取到程序中来：
        System.out.println(dis.readUTF());
        System.out.println(dis.readBoolean());
        System.out.println(dis.readDouble());
        System.out.println(dis.readInt());
        //关闭流：
        dis.close();
    &#125;
&#125;
</code></pre>
<img data-src="/2022/10/07/Java/%E7%AC%AC12%E7%AB%A0IO/image-20220618185431650.png" class="">


<p>验证：那个文件，我们看不懂，程序看得懂<br>要求：<br>写出的类型跟读入的类型 必须 要匹配！</p>
<h2 id="15-对象流-ObjectInputStream-ObjectOutputStream"><a href="#15-对象流-ObjectInputStream-ObjectOutputStream" class="headerlink" title="15 对象流-ObjectInputStream,ObjectOutputStream"></a>15 对象流-ObjectInputStream,ObjectOutputStream</h2><p>【1】对象流：ObjectInputStream，ObjectInputStream<br>用于存储和读取基本数据类型数据或对象的处理流。<br>它的强大之处就是可以把Java中的对象写入到数据源中，也能把对象从数据源中还原回来。</p>
<p>【2】序列化和反序列化：<br>ObjectOutputStream 类 ： 把内存中的Java对象转换成平台无关的二进制数据，从而允许把这种二进制数据持久地保存在磁盘上，或通过网络将这种二进制数据传输到另一个网络节点。—-》序列化<br>用ObjectInputStream类 ： 当其它程序获取了这种二进制数据，就可以恢复成原来的Java对象。—-》反序列化</p>
<p>【3】代码：操作字符串对象：<br>首先将一个字符串对象写到文件中去：—-》序列化</p>
<pre><code class="java">public class Test01 &#123;
    //这是一个main方法，是程序的入口：
    public static void main(String[] args) throws IOException &#123;
        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(new File(&quot;d:\\Demo3.txt&quot;)));
        //将内存中的字符串写出到文件中：
        oos.writeObject(&quot;你好&quot;);
        //关闭流：
        oos.close();
    &#125;
&#125;
</code></pre>
<p>查看文件：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC12%E7%AB%A0IO/image-20220618185509008.png" class="">


<p>我们看不懂文件的内容，但是程序是可以看懂的，所以可以写一个程序读文件中内容：—-》反序列化</p>
<pre><code class="java">public class Test02 &#123;
    //这是一个main方法，是程序的入口：
    public static void main(String[] args) throws IOException, ClassNotFoundException &#123;
        //将文件中保存的字符串 读入到 内存：
        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(new File(&quot;d:\\Demo3.txt&quot;)));
        //读取：
        String s = (String)(ois.readObject());
        System.out.println(s);
        //关闭流：
        ois.close();
    &#125;
&#125;
</code></pre>
<img data-src="/2022/10/07/Java/%E7%AC%AC12%E7%AB%A0IO/image-20220618185547246.png" class="">


<p>【4】代码：操作自定义类的对象：<br>自定义的Person类：</p>
<pre><code class="java">public class Person &#123;
    private String name;
    private int age;
    public String getName() &#123;
        return name;
    &#125;
    public void setName(String name) &#123;
        this.name = name;
    &#125;
    public int getAge() &#123;
        return age;
    &#125;
    public void setAge(int age) &#123;
        this.age = age;
    &#125;
    public Person() &#123;
    &#125;
    public Person(String name, int age) &#123;
        this.name = name;
        this.age = age;
    &#125;
&#125;
</code></pre>
<p>测试类：</p>
<pre><code class="java">public class Test01 &#123;
    //这是一个main方法，是程序的入口：
    public static void main(String[] args) throws IOException &#123;
        //序列化：将内存中对象 ---》 文件：
        //有一个对象：
        Person p = new Person(&quot;lili&quot;,19);
        //有对象流：
        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(new File(&quot;d:\\Demo4.txt&quot;)));
        //向外写：
        oos.writeObject(p);
        //关闭流：
        oos.close();
    &#125;
&#125;
</code></pre>
<p>运行的时候发现出现异常：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC12%E7%AB%A0IO/image-20220618185638520.png" class="">


<p>出现异常的原因：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC12%E7%AB%A0IO/image-20220618185644074.png" class="">


<p>起到标识作用，标识什么呢？只要实现这个接口的类的对象才能序列化，否则不可以。</font></p>
<p>解决办法：将Person 实现这个标识接口就可以：</p>
<pre><code class="java">public class Person implements Serializable &#123;
    private String name;
    private int age;
    public String getName() &#123;
        return name;
    &#125;
    public void setName(String name) &#123;
        this.name = name;
    &#125;
    public int getAge() &#123;
        return age;
    &#125;
    public void setAge(int age) &#123;
        this.age = age;
    &#125;
    public Person() &#123;
    &#125;
    public Person(String name, int age) &#123;
        this.name = name;
        this.age = age;
    &#125;
&#125;
</code></pre>
<p>测试：发现序列化成功，Person具备了序列化的能力。</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC12%E7%AB%A0IO/image-20220618185843749.png" class="">


<p>这个二进制数据我们看不懂，但是程序可以看懂，所以我们可以用程序实现 反序列化操作：<br>将这个对象 恢复到内存中来：</p>
<pre><code class="java">public class Test02 &#123;
    //这是一个main方法，是程序的入口：
    public static void main(String[] args) throws IOException, ClassNotFoundException &#123;
        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(new File(&quot;d:\\Demo4.txt&quot;)));
        //读入内存：
        Person p = (Person)(ois.readObject());
        System.out.println(p/*.toString()*/);
        //关闭流：
        ois.close();
    &#125;
&#125;
</code></pre>
<p>结果：<br>因为我们没有重写toString方法，所以结果为：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC12%E7%AB%A0IO/image-20220618185906147.png" class="">


<p>证明了反序列化成功：   将二进制数据 –》内存</p>
<p>【5】serialVersionUID：<br>凡是实现Serializable接口（标识接口）的类都有一个表示序列化版本标识符的静态常量:<br>➢private static final long serialVersionUID;<br>➢serialVersionUID用来表明类的不同版本间的兼容性。简言之，其目的是以序列化对象进行版本控制，有关各版本反序加化时是否兼容。<br>➢如果类没有显示定义这个静态变量，它的值是Java运行时环境根据类的内部细节自动生成的。若类的实例变量做了修改，serialVersionUID 可能发生变化。故建议，显式声明。</p>
<p>➢简单来说，Java的序列化机制是通过在运行时判断类的serialVersionUID来验证版本一致性的。在进行反序列化时，JVM会把传来的字节流中的serialVersionUID与本地相应实体类的serialVersionUID进行比较，如果相同就认为是一致的，可以进行反序列化，否则就会出现序列化版本不一致的异常。(InvalidCastException)</p>
<p>我现在在Person类中加入toString方法：</p>
<pre><code class="java">public class Person implements Serializable &#123;
    private String name;
    private int age;
    public String getName() &#123;
        return name;
    &#125;
    public void setName(String name) &#123;
        this.name = name;
    &#125;
    public int getAge() &#123;
        return age;
    &#125;
    public void setAge(int age) &#123;
        this.age = age;
    &#125;
    public Person() &#123;
    &#125;
    public Person(String name, int age) &#123;
        this.name = name;
        this.age = age;
    &#125;
    @Override
    public String toString() &#123;
        return &quot;Person&#123;&quot; +
                &quot;name=&#39;&quot; + name + &#39;\&#39;&#39; +
                &quot;, age=&quot; + age +
                &#39;&#125;&#39;;
    &#125;
&#125;
</code></pre>
<p>再次运行测试类：<br>出现异常：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC12%E7%AB%A0IO/image-20220618193403947.png" class="">



<p>出现异常的原因：</p>
<p>解决：给这个类 加入一个 序列号：serialVersionUID</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC12%E7%AB%A0IO/image-20220618193411439.png" class="">




<p>【6】IDEA中配置序列化版本号：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC12%E7%AB%A0IO/image-20220618193419904.png" class="">




<p>在Person类上：alt+enter:</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC12%E7%AB%A0IO/image-20220618193429703.png" class="">


<p>回车即可生成</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC12%E7%AB%A0IO/image-20220618193434654.png" class="">


<p>【7】序列化细节：<br>（1）被序列化的类的内部的所有属性，必须是可序列化的 （基本数据类型都是可序列化的）</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC12%E7%AB%A0IO/image-20220618193446336.png" class="">



<p>（2）static，transient修饰的属性 不可以被序列化。</p>
<pre><code class="java">public class Person implements Serializable &#123;
    private static final long serialVersionUID = 8027651838638826533L;
    private transient String name;
    private static int age;
    private Famaily f = new Famaily();
    public String getName() &#123;
        return name;
    &#125;
    public void setName(String name) &#123;
        this.name = name;
    &#125;
    public int getAge() &#123;
        return age;
    &#125;
    public void setAge(int age) &#123;
        this.age = age;
    &#125;
    public Person() &#123;
    &#125;
    @Override
    public String toString() &#123;
        return &quot;Person&#123;&quot; +
                &quot;name=&#39;&quot; + name + &#39;\&#39;&#39; +
                &quot;, f=&quot; + f + &quot;,age=&quot; + age +
                &#39;&#125;&#39;;
    &#125;
&#125;
</code></pre>
<img data-src="/2022/10/07/Java/%E7%AC%AC12%E7%AB%A0IO/image-20220618193501694.png" class="">




]]></content>
      <categories>
        <category>JavaSE</category>
        <category>IO</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title>第13章多线程</title>
    <url>/2022/10/07/Java/%E7%AC%AC13%E7%AB%A0%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>【1】程序，进程，线程<br>➢程序(program)：是为完成特定任务、用某种语言编写的一组指令的集合,是一段静态的代码。 （程序是静态的）</p>
<p>➢进程(process)：是程序的一次执行过程。正在运行的一个程序，进程作为资源分配的单位，在内存中会为每个进程分配不同的内存区域。 （进程是动态的）是一个动的过程 ，进程的生命周期  :  有它自身的产生、存在和消亡的过程</p>
<p>➢线程(thread)，进程可进一步细化为线程， 是一个程序内部的一条执行路径。<br>若一个进程同一时间并行执行多个线程，就是支持多线程的。</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC13%E7%AB%A0%E5%A4%9A%E7%BA%BF%E7%A8%8B/image-20220618194135831.png" class="">



<p>【2】单核CPU与多核CPU的任务执行：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC13%E7%AB%A0%E5%A4%9A%E7%BA%BF%E7%A8%8B/image-20220618194141865.png" class="">


<img data-src="/2022/10/07/Java/%E7%AC%AC13%E7%AB%A0%E5%A4%9A%E7%BA%BF%E7%A8%8B/image-20220618194149206.png" class="">




<p>【3】并行和并发：<br>并行：多个CPU同时执行多个任务<br>并发：一个CPU“同时”执行多个任务（采用时间片切换）</p>
<h1 id="1-创建线程的三种方式"><a href="#1-创建线程的三种方式" class="headerlink" title="1 创建线程的三种方式"></a>1 创建线程的三种方式</h1><h2 id="第一种：继承Thread类"><a href="#第一种：继承Thread类" class="headerlink" title="第一种：继承Thread类"></a>第一种：继承Thread类</h2><p>【1】在学习多线程一章之前，以前的代码是单线程的吗？不是，以前也是有三个线程同时执行的。</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC13%E7%AB%A0%E5%A4%9A%E7%BA%BF%E7%A8%8B/image-20220618194435926.png" class="">


<p>【2】现在我想自己制造多线程—》创建线程 ？？<br>线程类–》线程对象</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC13%E7%AB%A0%E5%A4%9A%E7%BA%BF%E7%A8%8B/image-20220618194442238.png" class="">


<pre><code class="java">/**
 * 线程类叫：TestThread，不是说你名字中带线程单词你就具备多线程能力了（争抢资源能力）
 * 现在想要具备能力，继承一个类：Thread，具备了争抢资源的能力
 */
public class TestThread extends Thread&#123;
    /*
    一会线程对象就要开始争抢资源了，这个线程要执行的任务到底是啥？这个任务你要放在方法中
    但是这个方法不能是随便写的一个方法，必须是重写Thread类中的run方法
    然后线程的任务/逻辑写在run方法中
     */
    @Override
    public void run() &#123;
        //输出1-10
        for (int i = 1; i &lt;= 10 ; i++) &#123;
            System.out.println(i);
        &#125;
    &#125;
&#125;
</code></pre>
<pre><code class="java">public class Test &#123;
    //这是main方法，程序的入口
    public static void main(String[] args) &#123;
        //主线程中也要输出十个数：
        for (int i = 1; i &lt;= 10 ; i++) &#123;
            System.out.println(&quot;main1-----&quot;+i);
        &#125;
        //制造其他线程，要跟主线程争抢资源：
        //具体的线程对象：子线程
        TestThread tt = new TestThread();
        //tt.run();//调用run方法，想要执行线程中的任务 --&gt;这个run方法不能直接调用，直接调用就会被当做一个普通方法
        //想要tt子线程真正起作用比如要启动线程：
        tt.start();//start()是Thread类中的方法
        //主线程中也要输出十个数：
        for (int i = 1; i &lt;= 10 ; i++) &#123;
            System.out.println(&quot;main2-----&quot;+i);
        &#125;
    &#125;
&#125;
</code></pre>
<p>运行结果：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC13%E7%AB%A0%E5%A4%9A%E7%BA%BF%E7%A8%8B/image-20220618194526775.png" class="">


<h3 id="设置读取线程名字"><a href="#设置读取线程名字" class="headerlink" title="设置读取线程名字"></a>设置读取线程名字</h3><p>【1】setName,getName方法来进行设置读取：</p>
<pre><code class="java">/**
 * 线程类叫：TestThread，不是说你名字中带线程单词你就具备多线程能力了（争抢资源能力）
 * 现在想要具备能力，继承一个类：Thread，具备了争抢资源的能力
 */
public class TestThread extends Thread&#123;
    /*
    一会线程对象就要开始争抢资源了，这个线程要执行的任务到底是啥？这个任务你要放在方法中
    但是这个方法不能是随便写的一个方法，必须是重写Thread类中的run方法
    然后线程的任务/逻辑写在run方法中
     */
    @Override
    public void run() &#123;
        //输出1-10
        for (int i = 1; i &lt;= 10 ; i++) &#123;
            System.out.println(this.getName()+i);
        &#125;
    &#125;
&#125;
</code></pre>
<pre><code class="java">public class Test &#123;
    //这是main方法，程序的入口
    public static void main(String[] args) &#123;
        //给main方法这个主线程设置名字：
        //Thread.currentThread()作用获取当前正在执行的线程
        Thread.currentThread().setName(&quot;主线程&quot;);
        //主线程中也要输出十个数：
        for (int i = 1; i &lt;= 10 ; i++) &#123;
            System.out.println(Thread.currentThread().getName()+&quot;1-------&quot;+i);
        &#125;
        //制造其他线程，要跟主线程争抢资源：
        //具体的线程对象：子线程
        TestThread tt = new TestThread();
        tt.setName(&quot;子线程&quot;);
        //tt.run();//调用run方法，想要执行线程中的任务 --&gt;这个run方法不能直接调用，直接调用就会被当做一个普通方法
        //想要tt子线程真正起作用比如要启动线程：
        tt.start();//start()是Thread类中的方法
        //主线程中也要输出十个数：
        for (int i = 1; i &lt;= 10 ; i++) &#123;
            System.out.println(Thread.currentThread().getName()+&quot;2-------&quot;+i);
        &#125;
    &#125;
&#125;
</code></pre>
<p>【2】通过构造器设置 名字：</p>
<pre><code class="java">/**
 * 线程类叫：TestThread，不是说你名字中带线程单词你就具备多线程能力了（争抢资源能力）
 * 现在想要具备能力，继承一个类：Thread，具备了争抢资源的能力
 */
public class TestThread extends Thread&#123;
    public TestThread(String name)&#123;
        super(name);//调用父类的有参构造器
    &#125;
    /*
    一会线程对象就要开始争抢资源了，这个线程要执行的任务到底是啥？这个任务你要放在方法中
    但是这个方法不能是随便写的一个方法，必须是重写Thread类中的run方法
    然后线程的任务/逻辑写在run方法中
     */
    @Override
    public void run() &#123;
        //输出1-10
        for (int i = 1; i &lt;= 10 ; i++) &#123;
            System.out.println(this.getName()+i);
        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="习题：买火车票"><a href="#习题：买火车票" class="headerlink" title="习题：买火车票"></a>习题：买火车票</h3><p>【1】原理：每个窗口都是一个线程对象：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC13%E7%AB%A0%E5%A4%9A%E7%BA%BF%E7%A8%8B/image-20220618194717605.png" class="">





<p>【2】代码：</p>
<pre><code class="java">public class BuyTicketThread extends Thread &#123;
    public BuyTicketThread(String name)&#123;
        super(name);
    &#125;
    //一共10张票：
    static int ticketNum = 10;//多个对象共享10张票
    //每个窗口都是一个线程对象：每个对象执行的代码放入run方法中
    @Override
    public void run() &#123;
        //每个窗口后面有100个人在抢票：
        for (int i = 1; i &lt;= 100 ; i++) &#123;
            if(ticketNum &gt; 0)&#123;//对票数进行判断，票数大于零我们才抢票
                System.out.println(&quot;我在&quot;+this.getName()+&quot;买到了从北京到哈尔滨的第&quot; + ticketNum-- + &quot;张车票&quot;);
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<pre><code class="java">public class Test &#123;
    public static void main(String[] args) &#123;
        //多个窗口抢票：三个窗口三个线程对象：
        BuyTicketThread t1 = new BuyTicketThread(&quot;窗口1&quot;);
        t1.start();
        BuyTicketThread t2 = new BuyTicketThread(&quot;窗口2&quot;);
        t2.start();
        BuyTicketThread t3 = new BuyTicketThread(&quot;窗口3&quot;);
        t3.start();
    &#125;
&#125;
</code></pre>
<h2 id="第二种：实现Runnable接口"><a href="#第二种：实现Runnable接口" class="headerlink" title="第二种：实现Runnable接口"></a>第二种：实现Runnable接口</h2><p>【1】代码：</p>
<pre><code class="java">/**
 * TestThread实现了这个接口，才会变成一个线程类
 */
public class TestThread implements Runnable&#123;
    @Override
    public void run() &#123;
        //输出1-10数字：
        for (int i = 1; i &lt;= 10 ; i++) &#123;
            System.out.println(Thread.currentThread().getName()+&quot;----&quot;+i);
        &#125;
    &#125;
&#125;
</code></pre>
<pre><code class="java">public class Test &#123;
    public static void main(String[] args) &#123;
        //创建子线程对象：
        TestThread tt = new TestThread();
        Thread t = new Thread(tt,&quot;子线程&quot;);
        t.start();
        //主线程里面也是打印1-10数字：
        for (int i = 1; i &lt;= 10 ; i++) &#123;
            System.out.println(Thread.currentThread().getName()+&quot;---&quot;+i);
        &#125;
    &#125;
&#125;
</code></pre>
<p>运行结果：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC13%E7%AB%A0%E5%A4%9A%E7%BA%BF%E7%A8%8B/image-20220618194854683.png" class="">


<h3 id="习题：买火车票-1"><a href="#习题：买火车票-1" class="headerlink" title="习题：买火车票"></a>习题：买火车票</h3><p>【1】代码：</p>
<pre><code class="java">public class BuyTicketThread implements Runnable &#123;
    int ticketNum = 10;
    @Override
    public void run() &#123;
        for (int i = 1; i &lt;= 100 ; i++) &#123;
            if(ticketNum &gt; 0)&#123;
                System.out.println(&quot;我在&quot;+Thread.currentThread().getName()+&quot;买到了北京到哈尔滨的第&quot; + ticketNum-- + &quot;张车票&quot;);
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<pre><code class="java">public class Test &#123;
    //这是main方法，程序的入口
    public static void main(String[] args) &#123;
        //定义一个线程对象：
        BuyTicketThread t = new BuyTicketThread();
        //窗口1买票：
        Thread t1 = new Thread(t,&quot;窗口1&quot;);
        t1.start();
        //窗口2买票：
        Thread t2 = new Thread(t,&quot;窗口2&quot;);
        t2.start();
        //窗口3买票：
        Thread t3 = new Thread(t,&quot;窗口3&quot;);
        t3.start();
    &#125;
&#125;
</code></pre>
<p>【2】实际开发中，方式1 继承Thread类   还是  方式2 实现Runnable接口这种方式多呢？–》方式2</p>
<p>（1）方式1的话有 Java单继承的局限性，因为继承了Thread类，就不能再继承其它的类了</p>
<p>（2）方式2的共享资源的能力也会强一些，不需要非得加个static来修饰</p>
<p>【3】Thread类 Runnable接口 有联系吗？</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC13%E7%AB%A0%E5%A4%9A%E7%BA%BF%E7%A8%8B/image-20220618195007939.png" class="">


<p>对比第一种和第二种创建线程的方式发现，无论第一种继承Thread类的方式还是第二种实现Runnable接口的方式，都需要有一个run方法，<br>但是这个run方法有不足：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC13%E7%AB%A0%E5%A4%9A%E7%BA%BF%E7%A8%8B/image-20220618195022846.png" class="">


<p>（1）没有返回值<br>（2）不能抛出异常</p>
<p>基于上面的两个不足，在JDK1.5以后出现了第三种创建线程的方式：实现Callable接口：</p>
<p>实现Callable接口好处：（1）有返回值  （2）能抛出异常<br>缺点：线程创建比较麻烦</p>
<pre><code class="java">public class TestRandomNum implements Callable&lt;Integer&gt; &#123;
    /*
    1.实现Callable接口，可以不带泛型，如果不带泛型，那么call方式的返回值就是Object类型
    2.如果带泛型，那么call的返回值就是泛型对应的类型
    3.从call方法看到：方法有返回值，可以跑出异常
     */
    @Override
    public Integer call() throws Exception &#123;
        return new Random().nextInt(10);//返回10以内的随机数
    &#125;
&#125;
class Test&#123;
    //这是main方法，程序的入口
    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;
        //定义一个线程对象：
        TestRandomNum trn = new TestRandomNum();
        FutureTask ft = new FutureTask(trn);
        Thread t = new Thread(ft);
        t.start();
        //获取线程得到的返回值：
        Object obj = ft.get();
        System.out.println(obj);
    &#125;
&#125;
</code></pre>
<h1 id="2-线程的生命周期"><a href="#2-线程的生命周期" class="headerlink" title="2 线程的生命周期"></a>2 线程的生命周期</h1><p>【1】线程声明周期：线程开始–》线程消亡<br>【2】线程经历哪些阶段：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC13%E7%AB%A0%E5%A4%9A%E7%BA%BF%E7%A8%8B/image-20220618195248025.png" class="">


<h1 id="3-线程常见方法"><a href="#3-线程常见方法" class="headerlink" title="3 线程常见方法"></a>3 线程常见方法</h1><p>（1）start() :  启动当前线程，表面上调用start方法，实际在调用线程里面的run方法</p>
<p>（2）run() : 线程类 继承 Thread类 或者 实现Runnable接口的时候，都要重新实现这个run方法，run方法里面是线程要执行的内容</p>
<p>（3）currentThread :Thread类中一个静态方法：获取当前正在执行的线程</p>
<p>（4）setName 设置线程名字</p>
<p>（5）getName 读取线程名字</p>
<h2 id="设置优先级"><a href="#设置优先级" class="headerlink" title="设置优先级"></a>设置优先级</h2><p>【1】同优先级别的线程，采取的策略就是先到先服务，使用时间片策略</p>
<p>【2】如果优先级别高，被CPU调度的概率就高</p>
<p>【3】级别：1-10   默认的级别为5</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC13%E7%AB%A0%E5%A4%9A%E7%BA%BF%E7%A8%8B/image-20220618195340695.png" class="">





<p>【4】代码：</p>
<pre><code class="java">public class TestThread01 extends Thread &#123;
    @Override
    public void run() &#123;
        for (int i = 1; i &lt;= 10; i++) &#123;
            System.out.println(i);
        &#125;
    &#125;
&#125;
class TestThread02 extends Thread&#123;
    @Override
    public void run() &#123;
        for (int i = 20; i &lt;= 30 ; i++) &#123;
            System.out.println(i);
        &#125;
    &#125;
&#125;
class Test&#123;
    //这是main方法，程序的入口
    public static void main(String[] args) &#123;
        //创建两个子线程，让这两个子线程争抢资源：
        TestThread01 t1 = new TestThread01();
        t1.setPriority(10);//优先级别高
        t1.start();
        TestThread02 t2 = new TestThread02();
        t2.setPriority(1);//优先级别低
        t2.start();
    &#125;
&#125;
</code></pre>
<h2 id="join"><a href="#join" class="headerlink" title="join"></a>join</h2><p>join方法：当一个线程调用了join方法，这个线程就会先被执行，它执行结束以后才可以去执行其余的线程。</p>
<blockquote>
<p>注意：必须先start，再join才有效。</p>
</blockquote>
<pre><code class="java">public class TestThread extends Thread &#123;
    public TestThread(String name)&#123;
        super(name);
    &#125;
    @Override
    public void run() &#123;
        for (int i = 1; i &lt;= 10 ; i++) &#123;
            System.out.println(this.getName()+&quot;----&quot;+i);
        &#125;
    &#125;
&#125;
class Test&#123;
    //这是main方法，程序的入口
    public static void main(String[] args) throws InterruptedException &#123;
        for (int i = 1; i &lt;= 100 ; i++) &#123;
            System.out.println(&quot;main-----&quot;+i);
            if(i == 6)&#123;
                //创建子线程：
                TestThread tt = new TestThread(&quot;子线程&quot;);
                tt.start();
                tt.join();//“半路杀出个程咬金”
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<h2 id="sleep"><a href="#sleep" class="headerlink" title="sleep"></a>sleep</h2><p><span class="exturl" data-url="aHR0cHM6Ly9nby56YmouY29tL25ld3MvMjAxNDYuaHRtbA==">https://go.zbj.com/news/20146.html</span> （段子）</p>
<p>【1】sleep : 人为的制造阻塞事件</p>
<pre><code class="java">public class Test01 &#123;
    //这是main方法，程序的入口
    public static void main(String[] args) &#123;
        try &#123;
            Thread.sleep(3000);
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;
        System.out.println(&quot;00000000000000&quot;);
    &#125;
&#125;
</code></pre>
<p>【2】案例：完成秒表功能：</p>
<pre><code class="java">public class Test02 &#123;
    //这是main方法，程序的入口
    public static void main(String[] args) &#123;
        //2.定义一个时间格式：
        DateFormat df = new SimpleDateFormat(&quot;HH:mm:ss&quot;);
        while(true)&#123;
            //1.获取当前时间：
            Date d = new Date();
            //3.按照上面定义的格式将Date类型转为指定格式的字符串：
            System.out.println(df.format(d));
            try &#123;
                Thread.sleep(1000);
            &#125; catch (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<h2 id="setDaemon"><a href="#setDaemon" class="headerlink" title="setDaemon"></a>setDaemon</h2><p>【1】设置伴随线程<br>将子线程设置为主线程的伴随线程，主线程停止的时候，子线程也不要继续执行了<br>案例：皇上 –》驾崩 —》妃子陪葬</p>
<pre><code class="java">public class TestThread extends Thread &#123;
    @Override
    public void run() &#123;
        for (int i = 1; i &lt;= 1000 ; i++) &#123;
            System.out.println(&quot;子线程----&quot;+i);
        &#125;
    &#125;
&#125;
class Test&#123;
    //这是main方法，程序的入口
    public static void main(String[] args) &#123;
        //创建并启动子线程：
        TestThread tt = new TestThread();
        tt.setDaemon(true);//设置伴随线程  注意：先设置，再启动
        tt.start();
        //主线程中还要输出1-10的数字：
        for (int i = 1; i &lt;= 10 ; i++) &#123;
            System.out.println(&quot;main---&quot;+i);
        &#125;
    &#125;
&#125;
</code></pre>
<p>结果：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC13%E7%AB%A0%E5%A4%9A%E7%BA%BF%E7%A8%8B/image-20220618195552686.png" class="">


<h2 id="stop"><a href="#stop" class="headerlink" title="stop"></a>stop</h2><pre><code class="java">public class Demo &#123;
    //这是main方法，程序的入口
    public static void main(String[] args) &#123;
        for (int i = 1; i &lt;= 100 ; i++) &#123;
            if(i == 6)&#123;
                Thread.currentThread().stop();//过期方法，不建议使用
            &#125;
            System.out.println(i);
        &#125;
    &#125;
&#125;
</code></pre>
<h1 id="4-线程安全问题"><a href="#4-线程安全问题" class="headerlink" title="4 线程安全问题"></a>4 线程安全问题</h1><h2 id="方法1：同步代码块"><a href="#方法1：同步代码块" class="headerlink" title="方法1：同步代码块"></a>方法1：同步代码块</h2><p>【1】同步代码块演示1：</p>
<pre><code class="java">package com.msb.test04;
/**
 * @author : msb-zhaoss
 */
public class BuyTicketThread implements Runnable &#123;
    int ticketNum = 10;
    @Override
    public void run() &#123;
        //此处有1000行代码
        for (int i = 1; i &lt;= 100 ; i++) &#123;
            synchronized (this)&#123;//把具有安全隐患的代码锁住即可，如果锁多了就会效率低 --》this就是这个锁
                if(ticketNum &gt; 0)&#123;
                    System.out.println(&quot;我在&quot;+Thread.currentThread().getName()+&quot;买到了北京到哈尔滨的第&quot; + ticketNum-- + &quot;张车票&quot;);
                &#125;
            &#125;
        &#125;
        //此处有1000行代码
    &#125;
&#125;
</code></pre>
<p>【2】同步代码块演示2：</p>
<pre><code class="java">public class BuyTicketThread extends Thread &#123;
    public BuyTicketThread(String name)&#123;
        super(name);
    &#125;
    //一共10张票：
    static int ticketNum = 10;//多个对象共享10张票
    //每个窗口都是一个线程对象：每个对象执行的代码放入run方法中
    @Override
    public void run() &#123;
        //每个窗口后面有100个人在抢票：
        for (int i = 1; i &lt;= 100 ; i++) &#123;
            synchronized (BuyTicketThread.class)&#123;//锁必须多个线程用的是同一把锁！！！
                if(ticketNum &gt; 0)&#123;//对票数进行判断，票数大于零我们才抢票
                    System.out.println(&quot;我在&quot;+this.getName()+&quot;买到了从北京到哈尔滨的第&quot; + ticketNum-- + &quot;张车票&quot;);
                &#125;
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<h2 id="方法2：同步方法"><a href="#方法2：同步方法" class="headerlink" title="方法2：同步方法"></a>方法2：同步方法</h2><p>【1】代码展示：</p>
<pre><code class="java">public class BuyTicketThread implements Runnable &#123;
    int ticketNum = 10;
    @Override
    public void run() &#123;
        //此处有1000行代码
        for (int i = 1; i &lt;= 100 ; i++) &#123;
            buyTicket();
        &#125;
        //此处有1000行代码
    &#125;
    public synchronized void buyTicket()&#123;//锁住的是this
        if(ticketNum &gt; 0)&#123;
            System.out.println(&quot;我在&quot;+Thread.currentThread().getName()+&quot;买到了北京到哈尔滨的第&quot; + ticketNum-- + &quot;张车票&quot;);
        &#125;
    &#125;
&#125;
</code></pre>
<pre><code class="java">public class BuyTicketThread extends Thread &#123;
    public BuyTicketThread(String name)&#123;
        super(name);
    &#125;
    //一共10张票：
    static int ticketNum = 10;//多个对象共享10张票
    //每个窗口都是一个线程对象：每个对象执行的代码放入run方法中
    @Override
    public void run() &#123;
        //每个窗口后面有100个人在抢票：
        for (int i = 1; i &lt;= 100 ; i++) &#123;
            buyTicket();
        &#125;
    &#125;
    public static synchronized void buyTicket()&#123;//锁住的  同步监视器： BuyTicketThread.class
        if(ticketNum &gt; 0)&#123;//对票数进行判断，票数大于零我们才抢票
            System.out.println(&quot;我在&quot;+Thread.currentThread().getName()+&quot;买到了从北京到哈尔滨的第&quot; + ticketNum-- + &quot;张车票&quot;);
        &#125;
    &#125;
&#125;
</code></pre>
<p>【2】总结：<br>总结1：<br>多线程在争抢资源，就要实现线程的同步（就要进行加锁，并且这个锁必须是共享的，必须是唯一的。<br>咱们的锁一般都是引用数据类型的。</p>
<p>目的：解决了线程安全问题。</p>
<p>总结2：关于同步方法</p>
<ol>
<li>不要将run()定义为同步方法</li>
<li>非静态同步方法的同步监视器是this<br>静态同步方法的同步监视器是 类名.class 字节码信息对象</li>
<li>同步代码块的效率要高于同步方法<br>原因：同步方法是将线程挡在了方法的外部，而同步代码块锁将线程挡在了代码块的外部，但是却是方法的内部</li>
<li>同步方法的锁是this，一旦锁住一个方法，就锁住了所有的同步方法；同步代码块只是锁住使用该同步监视器的代码块，而没有锁住使用其他监视器的代码块</li>
</ol>
<h2 id="方法3：Lock锁"><a href="#方法3：Lock锁" class="headerlink" title="方法3：Lock锁"></a>方法3：Lock锁</h2><p>【1】Lock锁引入：<br>JDK1.5后新增新一代的线程同步方式:Lock锁<br>与采用synchronized相比，lock可提供多种锁方案，更灵活</p>
<p>synchronized是Java中的关键字，这个关键字的识别是靠JVM来识别完成的呀。是虚拟机级别的。<br>但是Lock锁是API级别的，提供了相应的接口和对应的实现类，这个方式更灵活，表现出来的性能优于之前的方式。</p>
<p>【2】代码演示：</p>
<pre><code class="java">public class BuyTicketThread implements Runnable &#123;
    int ticketNum = 10;
    //拿来一把锁：
    Lock lock = new ReentrantLock();//多态  接口=实现类  可以使用不同的实现类
    @Override
    public void run() &#123;
        //此处有1000行代码
        for (int i = 1; i &lt;= 100 ; i++) &#123;
            //打开锁：
            lock.lock();
            try&#123;
                if(ticketNum &gt; 0)&#123;
                    System.out.println(&quot;我在&quot;+Thread.currentThread().getName()+&quot;买到了北京到哈尔滨的第&quot; + ticketNum-- + &quot;张车票&quot;);
                &#125;
            &#125;catch (Exception ex)&#123;
                ex.printStackTrace();
            &#125;finally &#123;
                //关闭锁：---&gt;即使有异常，这个锁也可以得到释放
                lock.unlock();
            &#125;
        &#125;
        //此处有1000行代码
    &#125;
&#125;
</code></pre>
<p>【3】 Lock和synchronized的区别</p>
<pre><code>    1.Lock是显式锁（手动开启和关闭锁，别忘记关闭锁），synchronized是隐式锁
    2.Lock只有代码块锁，synchronized有代码块锁和方法锁
    3.使用Lock锁，JVM将花费较少的时间来调度线程，性能更好。并且具有更好的扩展性（提供更多的子类）
</code></pre>
<p>【4】优先使用顺序：</p>
<pre><code>    Lock----同步代码块（已经进入了方法体，分配了相应资源）----同步方法（在方法体之外）
</code></pre>
<h2 id="线程同步的优缺点"><a href="#线程同步的优缺点" class="headerlink" title="线程同步的优缺点"></a>线程同步的优缺点</h2><p>【1】对比：<br>线程安全，效率低<br>线程不安全，效率高</p>
<p>【2】可能造成死锁：<br>死锁</p>
<blockquote>
<p>不同的线程分别占用对方需要的同步资源不放弃，都在等待对方放弃自己需要的同步资源，就形成了线程的死锁<br>出现死锁后，不会出现异常，不会出现提示，只是所有的线程都处于阻塞状态，无法继续</p>
</blockquote>
<p>【3】代码演示：</p>
<pre><code class="java">public class TestDeadLock implements Runnable &#123;
    public int flag = 1;
    static Object o1 = new Object(),o2 = new Object();
        
        
    public void run()&#123;
        System.out.println(&quot;flag=&quot; + flag);
        // 当flag==1锁住o1
        if (flag == 1) &#123;
            synchronized (o1) &#123;
                try &#123;
                    Thread.sleep(500);
                &#125; catch (Exception e) &#123;
                    e.printStackTrace();
                &#125;
                // 只要锁住o2就完成
                synchronized (o2) &#123;
                    System.out.println(&quot;2&quot;);
                &#125;
            &#125;
        &#125;
        // 如果flag==0锁住o2
        if (flag == 0) &#123;
            synchronized (o2) &#123;
                try &#123;
                    Thread.sleep(500);
                &#125; catch (Exception e) &#123;
                    e.printStackTrace();
                &#125;
                // 只要锁住o1就完成
                synchronized (o1) &#123;
                    System.out.println(&quot;3&quot;);
                &#125;
            &#125;
        &#125;
    &#125;
        
        
    public static void main(String[] args) &#123;
        // 实例2个线程类
        TestDeadLock td1 = new TestDeadLock();
        TestDeadLock td2 = new TestDeadLock();
        td1.flag = 1;
        td2.flag = 0;
        // 开启2个线程
        Thread t1 = new Thread(td1);
        Thread t2 = new Thread(td2);
        t1.start();
        t2.start();
    &#125;
&#125;
</code></pre>
<p>【4】解决方法： 减少同步资源的定义，避免嵌套同步</p>
<h1 id="5-线程通信问题"><a href="#5-线程通信问题" class="headerlink" title="5 线程通信问题"></a>5 线程通信问题</h1><p>应用场景：生产者和消费者问题<br>假设仓库中只能存放一件产品，生产者将生产出来的产品放入仓库，消费者将仓库中产品取走消费<br>如果仓库中没有产品，则生产者将产品放入仓库，否则停止生产并等待，直到仓库中的产品被消费者取走为止<br>如果仓库中放有产品，则消费者可以将产品取走消费，否则停止消费并等待，直到仓库中再次放入产品为止</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC13%E7%AB%A0%E5%A4%9A%E7%BA%BF%E7%A8%8B/image-20220618200150740.png" class="">


<p>代码结果展示：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC13%E7%AB%A0%E5%A4%9A%E7%BA%BF%E7%A8%8B/image-20220618200157334.png" class="">


<p>代码：<br>1.商品：属性：品牌 ，名字<br>2.线程1：生产者<br>3.线程2：消费者</p>
<h2 id="分解1"><a href="#分解1" class="headerlink" title="分解1"></a>分解1</h2><p>出现问题：<br>1.生产者和消费者没有交替输出</p>
<p>2.打印数据错乱<br>哈尔滨 - null<br>费列罗啤酒<br>哈尔滨巧克力<br>—-没有加同步</p>
<p>代码展示：</p>
<pre><code class="java">public class Product &#123;//商品类
    //品牌
    private String brand;
    //名字
    private String name;
    //setter,getter方法；
    public String getBrand() &#123;
        return brand;
    &#125;
    public void setBrand(String brand) &#123;
        this.brand = brand;
    &#125;
    public String getName() &#123;
        return name;
    &#125;
    public void setName(String name) &#123;
        this.name = name;
    &#125;
&#125;
</code></pre>
<pre><code class="java">public class ProducerThread extends Thread&#123;//生产者线程
    //共享商品：
    private Product p;
    public ProducerThread(Product p) &#123;
        this.p = p;
    &#125;
    @Override
    public void run() &#123;
        for (int i = 1; i &lt;= 10 ; i++) &#123;//生产十个商品 i:生产的次数
            if(i % 2 == 0)&#123;
                //生产费列罗巧克力
                p.setBrand(&quot;费列罗&quot;);
                try &#123;
                    Thread.sleep(100);
                &#125; catch (InterruptedException e) &#123;
                    e.printStackTrace();
                &#125;
                p.setName(&quot;巧克力&quot;);
            &#125;else&#123;
                //生产哈尔滨啤酒
                p.setBrand(&quot;哈尔滨&quot;);
                try &#123;
                    Thread.sleep(100);
                &#125; catch (InterruptedException e) &#123;
                    e.printStackTrace();
                &#125;
                p.setName(&quot;啤酒&quot;);
            &#125;
            //将生产信息做一个打印：
            System.out.println(&quot;生产者生产了：&quot; + p.getBrand() + &quot;---&quot; + p.getName());
        &#125;
    &#125;
&#125;
</code></pre>
<pre><code class="java">public class CustomerThread extends Thread&#123;//消费者线程
    //共享商品：
    private Product p;
    public CustomerThread(Product p) &#123;
        this.p = p;
    &#125;
    @Override
    public void run() &#123;
        for (int i = 1; i &lt;= 10 ; i++) &#123;//i:消费次数
            System.out.println(&quot;消费者消费了：&quot; + p.getBrand() + &quot;---&quot; + p.getName());
        &#125;
    &#125;
&#125;
</code></pre>
<h2 id="分解2"><a href="#分解2" class="headerlink" title="分解2"></a>分解2</h2><p>【1】利用同步代码块解决问题：</p>
<pre><code class="java">public class ProducerThread extends Thread&#123;//生产者线程
    //共享商品：
    private Product p;
    public ProducerThread(Product p) &#123;
        this.p = p;
    &#125;
    @Override
    public void run() &#123;
        for (int i = 1; i &lt;= 10 ; i++) &#123;//生产十个商品 i:生产的次数
            synchronized (p)&#123;
                if(i % 2 == 0)&#123;
                    //生产费列罗巧克力
                    p.setBrand(&quot;费列罗&quot;);
                    try &#123;
                        Thread.sleep(100);
                    &#125; catch (InterruptedException e) &#123;
                        e.printStackTrace();
                    &#125;
                    p.setName(&quot;巧克力&quot;);
                &#125;else&#123;
                    //生产哈尔滨啤酒
                    p.setBrand(&quot;哈尔滨&quot;);
                    try &#123;
                        Thread.sleep(100);
                    &#125; catch (InterruptedException e) &#123;
                        e.printStackTrace();
                    &#125;
                    p.setName(&quot;啤酒&quot;);
                &#125;
                //将生产信息做一个打印：
                System.out.println(&quot;生产者生产了：&quot; + p.getBrand() + &quot;---&quot; + p.getName());
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<pre><code class="java">public class CustomerThread extends Thread&#123;//消费者线程
    //共享商品：
    private Product p;
    public CustomerThread(Product p) &#123;
        this.p = p;
    &#125;
    @Override
    public void run() &#123;
        for (int i = 1; i &lt;= 10 ; i++) &#123;//i:消费次数
            synchronized (p)&#123;
                System.out.println(&quot;消费者消费了：&quot; + p.getBrand() + &quot;---&quot; + p.getName());
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<p>【2】利用同步方法解决问题：</p>
<pre><code class="java">public class Product &#123;//商品类
    //品牌
    private String brand;
    //名字
    private String name;
    //setter,getter方法；
    public String getBrand() &#123;
        return brand;
    &#125;
    public void setBrand(String brand) &#123;
        this.brand = brand;
    &#125;
    public String getName() &#123;
        return name;
    &#125;
    public void setName(String name) &#123;
        this.name = name;
    &#125;
    //生产商品
    public synchronized void setProduct(String brand,String name)&#123;
        this.setBrand(brand);
        try &#123;
            Thread.sleep(100);
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;
        this.setName(name);
        //将生产信息做一个打印：
        System.out.println(&quot;生产者生产了：&quot; + this.getBrand() + &quot;---&quot; + this.getName());
    &#125;
    //消费商品：
    public synchronized void getProduct()&#123;
        System.out.println(&quot;消费者消费了：&quot; + this.getBrand() + &quot;---&quot; + this.getName());
    &#125;
&#125;
</code></pre>
<pre><code class="java">public class CustomerThread extends Thread&#123;//消费者线程
    //共享商品：
    private Product p;
    public CustomerThread(Product p) &#123;
        this.p = p;
    &#125;
    @Override
    public void run() &#123;
        for (int i = 1; i &lt;= 10 ; i++) &#123;//i:消费次数
            p.getProduct();;
        &#125;
    &#125;
&#125;
</code></pre>
<pre><code class="java">public class ProducerThread extends Thread&#123;//生产者线程
    //共享商品：
    private Product p;
    public ProducerThread(Product p) &#123;
        this.p = p;
    &#125;
    @Override
    public void run() &#123;
        for (int i = 1; i &lt;= 10 ; i++) &#123;//生产十个商品 i:生产的次数
            if(i % 2 == 0)&#123;
                p.setProduct(&quot;费列罗&quot;,&quot;巧克力&quot;);
            &#125;else&#123;
                p.setProduct(&quot;哈尔滨&quot;,&quot;啤酒&quot;);
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<p>（这个else中的代码在分解3中 演示了错误）</p>
<h2 id="分解3"><a href="#分解3" class="headerlink" title="分解3"></a>分解3</h2><p>【1】原理：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC13%E7%AB%A0%E5%A4%9A%E7%BA%BF%E7%A8%8B/image-20220618200412158.png" class="">



<p>【2】代码：</p>
<pre><code class="java">public class Product &#123;//商品类
    //品牌
    private String brand;
    //名字
    private String name;
    //引入一个灯：true:红色  false 绿色
    boolean flag = false;//默认情况下没有商品 让生产者先生产  然后消费者再消费
    //setter,getter方法；
    public String getBrand() &#123;
        return brand;
    &#125;
    public void setBrand(String brand) &#123;
        this.brand = brand;
    &#125;
    public String getName() &#123;
        return name;
    &#125;
    public void setName(String name) &#123;
        this.name = name;
    &#125;
    //生产商品
    public synchronized void setProduct(String brand,String name)&#123;
        if(flag == true)&#123;//灯是红色，证明有商品，生产者不生产，等着消费者消费
            try &#123;
                wait();
            &#125; catch (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;
        //灯是绿色的，就生产：
        this.setBrand(brand);
        try &#123;
            Thread.sleep(100);
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;
        this.setName(name);
        //将生产信息做一个打印：
        System.out.println(&quot;生产者生产了：&quot; + this.getBrand() + &quot;---&quot; + this.getName());
        //生产完以后，灯变色：变成红色：
        flag = true;
        //告诉消费者赶紧来消费：
        notify();
    &#125;
    //消费商品：
    public synchronized void getProduct()&#123;
        if(!flag)&#123;//flag == false没有商品，等待生产者生产：
            try &#123;
                wait();
            &#125; catch (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;
        //有商品，消费：
        System.out.println(&quot;消费者消费了：&quot; + this.getBrand() + &quot;---&quot; + this.getName());
        //消费完：灯变色：
        flag = false;
        //通知生产者生产：
        notify();
    &#125;
&#125;
</code></pre>
<p>【3】原理：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC13%E7%AB%A0%E5%A4%9A%E7%BA%BF%E7%A8%8B/image-20220618200442747.png" class="">


<p>注意：wait方法和notify方法  是必须放在同步方法或者同步代码块中才生效的 （因为在同步的基础上进行线程的通信才是有效的）<br>注意：sleep和wait的区别：sleep进入阻塞状态没有释放锁，wait进入阻塞状态但是同时释放了锁<br>【4】线程生命周期完整图：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC13%E7%AB%A0%E5%A4%9A%E7%BA%BF%E7%A8%8B/image-20220618200450798.png" class="">


<h2 id="Loc锁情况下的线程通信"><a href="#Loc锁情况下的线程通信" class="headerlink" title="Loc锁情况下的线程通信"></a>Loc锁情况下的线程通信</h2><p>Condition是在Java 1.5中才出现的，它用来替代传统的Object的wait()、notify()实现线程间的协作，相比使用Object的wait()、notify()，使用Condition1的await()、signal()这种方式实现线程间协作更加安全和高效。</p>
<p>它的更强大的地方在于：能够更加精细的控制多线程的休眠与唤醒。对于同一个锁，我们可以创建多个Condition，在不同的情况下使用不同的Condition</p>
<p>一个Condition包含一个等待队列。一个Lock可以产生多个Condition，所以可以有多个等待队列。</p>
<p>在Object的监视器模型上，一个对象拥有一个同步队列和等待队列，<font color="red">而Lock（同步器）拥有一个同步队列和多个等待队列</font>。</p>
<p>Object中的wait(),notify(),notifyAll()方法是和”同步锁”(synchronized关键字)捆绑使用的；而Condition是需要与”互斥锁”&#x2F;“共享锁”捆绑使用的。</p>
<p>调用Condition的await()、signal()、signalAll()方法，都必须在lock保护之内，<font color="red">就是说必须在lock.lock()和lock.unlock之间才可以使用 </font></p>
<p>· Conditon中的await()对应Object的wait()；</p>
<p>· Condition中的signal()对应Object的notify()；<br>· Condition中的signalAll()对应Object的notifyAll()。</p>
<p>void await()  throws InterruptedException</p>
<p>造成当前线程在接到信号或被中断之前一直处于等待状态。</p>
<p>与此 Condition 相关的锁以原子方式释放，并且出于线程调度的目的，将禁用当前线程，且在发生以下四种情况之一 以前，当前线程将一直处于休眠状态：</p>
<p>· 其他某个线程调用此 Condition 的 signal() 方法，并且碰巧将当前线程选为被唤醒的线程；或者<br>· 其他某个线程调用此 Condition 的 signalAll() 方法；或者<br>· 其他某个线程中断当前线程，且支持中断线程的挂起；或者<br>· 发生“虚假唤醒”</p>
<p>在所有情况下，在此方法可以返回当前线程之前，都必须重新获取与此条件有关的锁。在线程返回时，可以保证它保持此锁。</p>
<p>void <strong>signal()</strong></p>
<p>唤醒一个等待线程。</p>
<p>如果所有的线程都在等待此条件，则选择其中的一个唤醒。在从 await 返回之前，该线程必须重新获取锁。</p>
<p>void <strong>signalAll()</strong></p>
<p>唤醒所有等待线程。</p>
<p>如果所有的线程都在等待此条件，则唤醒所有线程。在从 await 返回之前，每个线程都必须重新获取锁。</p>
<p>更改代码：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC13%E7%AB%A0%E5%A4%9A%E7%BA%BF%E7%A8%8B/image-20220618200641119.png" class="">


<pre><code class="java">public class Product &#123;//商品类
    //品牌
    private String brand;
    //名字
    private String name;
    //声明一个Lock锁：
    Lock lock = new ReentrantLock();
    //搞一个生产者的等待队列：
    Condition produceCondition = lock.newCondition();
    //搞一个消费者的等待队列：
    Condition consumeCondition = lock.newCondition();
    //引入一个灯：true:红色  false 绿色
    boolean flag = false;//默认情况下没有商品 让生产者先生产  然后消费者再消费
    //setter,getter方法；
    public String getBrand() &#123;
        return brand;
    &#125;
    public void setBrand(String brand) &#123;
        this.brand = brand;
    &#125;
    public String getName() &#123;
        return name;
    &#125;
    public void setName(String name) &#123;
        this.name = name;
    &#125;
    //生产商品
    public void setProduct(String brand,String name)&#123;
        lock.lock();
        try&#123;
            if(flag == true)&#123;//灯是红色，证明有商品，生产者不生产，等着消费者消费
                try &#123;
                    //wait();
                    //生产者阻塞，生产者进入等待队列中
                    produceCondition.await();
                &#125; catch (InterruptedException e) &#123;
                    e.printStackTrace();
                &#125;
            &#125;
            //灯是绿色的，就生产：
            this.setBrand(brand);
            try &#123;
                Thread.sleep(100);
            &#125; catch (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;
            this.setName(name);
            //将生产信息做一个打印：
            System.out.println(&quot;生产者生产了：&quot; + this.getBrand() + &quot;---&quot; + this.getName());
            //生产完以后，灯变色：变成红色：
            flag = true;
            //告诉消费者赶紧来消费：
            //notify();
            consumeCondition.signal();
        &#125;finally &#123;
            lock.unlock();
        &#125;
    &#125;
    //消费商品：
    public void getProduct()&#123;
        lock.lock();
        try&#123;
            if(!flag)&#123;//flag == false没有商品，等待生产者生产：
                try &#123;
                   // wait();
                    //消费者等待，消费者线程进入等待队列：
                    consumeCondition.await();
                &#125; catch (InterruptedException e) &#123;
                    e.printStackTrace();
                &#125;
            &#125;
            //有商品，消费：
            System.out.println(&quot;消费者消费了：&quot; + this.getBrand() + &quot;---&quot; + this.getName());
            //消费完：灯变色：
            flag = false;
            //通知生产者生产：
            //notify();
            produceCondition.signal();
        &#125;finally &#123;
            lock.unlock();
        &#125;
    &#125;
&#125;
</code></pre>
<h1 id="未完成！！！！！！！！！！"><a href="#未完成！！！！！！！！！！" class="headerlink" title="未完成！！！！！！！！！！"></a>未完成！！！！！！！！！！</h1>]]></content>
      <categories>
        <category>JavaSE</category>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title>第14章_网络编程</title>
    <url>/2022/10/07/Java/%E7%AC%AC14%E7%AB%A0_%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h1><p>【1】网络编程：</p>
<p>把分布在不同地理区域的计算机与专门的外部设备用通信线路互连成一个规模大、功能强的网络系统，从而使众多的计算机可以方便地互相传递信息、共享硬件、软件、数据信息等资源。</p>
<p>设备之间在网络中进行数据的传输，发送&#x2F;接收数据。</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC14%E7%AB%A0_%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/1a93dfa9d1c3ca81040d0cc18afb4aba.png" class="">


<p>【2】通信两个重要的要素：IP+PORT</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC14%E7%AB%A0_%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/c79c4973d3a3792ab9aef4710b01f370.png" class="">


<p>域名：<span class="exturl" data-url="aHR0cDovL3d3dy5iYWlkdS5jb20v">www.baidu.com</span> ——&gt;DNS服务器解析 —-&gt; IP地址</p>
<p><span class="exturl" data-url="aHR0cDovL3d3dy5tYXNoaWJpbmcuY29tLw==">www.mashibing.com</span></p>
<p><span class="exturl" data-url="aHR0cDovL3d3dy5zaW5hLmNvbS8=">www.sina.com</span></p>
<p><span class="exturl" data-url="aHR0cDovL3d3dy53YW5kYS5jb20v">www.wanda.com</span></p>
<p><span class="exturl" data-url="aHR0cDovL3d3dy5iYmJiLmNvbS8=">www.bbbb.com</span></p>
<p>【3】设备之间进行传输的时候，必须遵照一定的规则 —》通信协议：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC14%E7%AB%A0_%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/7dc2fafdf26997c871032c7bc7a91256.png" class="">


<img data-src="/2022/10/07/Java/%E7%AC%AC14%E7%AB%A0_%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/ae2d4c32ffafe3daac392da2ffcb1c5f.png" class="">


<p>【4】TCP协议：可靠的</p>
<p>建立连接： 三次握手</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC14%E7%AB%A0_%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/fc9427567eb4c9d54c08677d02e4ccfe.png" class="">


<p>释放连接：四次挥手</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC14%E7%AB%A0_%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/bb485bb37ea12a870dcb3ba2799c07d9.png" class="">


<p>【5】UDP协议：不可靠的</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC14%E7%AB%A0_%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/5e71f2ea6eb08ea6a59c1853accb6681.png" class="">


<h1 id="InetAddress-InetSocketAddress"><a href="#InetAddress-InetSocketAddress" class="headerlink" title="InetAddress,InetSocketAddress"></a>InetAddress,InetSocketAddress</h1><p>前情提要：File —》 封装盘符一个文件</p>
<p>【1】InetAddress —》 封装了IP</p>
<pre><code class="java">public class Test01 &#123;
    //这是一个main方法，是程序的入口：
    public static void main(String[] args) throws UnknownHostException &#123;
        //封装IP：
        //InetAddress ia = new InetAddress();不能直接创建对象，因为InetAddress()被default修饰了。
        InetAddress ia = InetAddress.getByName(&quot;192.168.199.217&quot;);
        System.out.println(ia);
        InetAddress ia2 = InetAddress.getByName(&quot;localhost&quot;);//localhost指代的是本机的ip地址
        System.out.println(ia2);
        InetAddress ia3 = InetAddress.getByName(&quot;127.0.0.1&quot;);//127.0.0.1指代的是本机的ip地址
        System.out.println(ia3);
        InetAddress ia4 = InetAddress.getByName(&quot;LAPTOP-CRIVSRRU&quot;);//封装计算机名
        System.out.println(ia4);
        InetAddress ia5 = InetAddress.getByName(&quot;www.mashibing.com&quot;);//封装域名
        System.out.println(ia5);

        System.out.println(ia5.getHostName());//获取域名
        System.out.println(ia5.getHostAddress());//获取ip地址
    &#125;
&#125;
</code></pre>
<p>【2】InetSocketAddress —》封装了IP，端口号</p>
<pre><code class="java">public class Test02 &#123;
    //这是一个main方法，是程序的入口：
    public static void main(String[] args) &#123;
        InetSocketAddress isa = new InetSocketAddress(&quot;192.168.199.217&quot;,8080);
        System.out.println(isa);
        System.out.println(isa.getHostName());
        System.out.println(isa.getPort());

        InetAddress ia = isa.getAddress();
        System.out.println(ia.getHostName());
        System.out.println(ia.getHostAddress());
    &#125;
&#125;
</code></pre>
<h1 id="网络通信原理–套接字"><a href="#网络通信原理–套接字" class="headerlink" title="网络通信原理–套接字"></a>网络通信原理–套接字</h1><img data-src="/2022/10/07/Java/%E7%AC%AC14%E7%AB%A0_%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/62ac948054889d710868c47aea8165d8.png" class="">


<h2 id="基于TCP的网络编程"><a href="#基于TCP的网络编程" class="headerlink" title="基于TCP的网络编程"></a>基于TCP的网络编程</h2><p>功能：模拟网站的登录，客户端录入账号密码，然后服务器端进行验证。</p>
<h3 id="功能分解1：单向通信"><a href="#功能分解1：单向通信" class="headerlink" title="功能分解1：单向通信"></a>功能分解1：单向通信</h3><p>功能：客户端发送一句话到服务器：</p>
<p>客户端：</p>
<pre><code class="java">public class TestClient &#123;//客户端

    //这是一个main方法，是程序的入口：
    public static void main(String[] args) throws IOException &#123;
        //1.创建套接字：指定服务器的ip和端口号：
        Socket s = new Socket(&quot;192.168.199.217&quot;,8888);
        //2.对于程序员来说，向外发送数据 感受 --》利用输出流：
        OutputStream os = s.getOutputStream();
        DataOutputStream dos = new DataOutputStream(os);
        //利用这个OutputStream就可以向外发送数据了，但是没有直接发送String的方法
        //所以我们又在OutputStream外面套了一个处理流：DataOutputStream
        dos.writeUTF(&quot;你好&quot;);

        //3.关闭流 + 关闭网络资源：
        dos.close();
        os.close();
        s.close();
    &#125;
&#125;
</code></pre>
<p>服务器：</p>
<pre><code class="java">public class TestServer &#123;//服务器

    //这是一个main方法，是程序的入口：
    public static void main(String[] args) throws IOException &#123;
        //1.创建套接字： 指定服务器的端口号
        ServerSocket ss = new ServerSocket(8888);
        //2.等着客户端发来的信息：
        Socket s = ss.accept();//阻塞方法:等待接收客户端的数据，什么时候接收到数据，什么时候程序继续向下执行。
        //accept()返回值为一个Socket，这个Socket其实就是客户端的Socket
        //接到这个Socket以后，客户端和服务器才真正产生了连接，才真正可以通信了
        //3.感受到的操作流：
        InputStream is = s.getInputStream();
        DataInputStream dis = new DataInputStream(is);

        //4.读取客户端发来的数据：
        String str = dis.readUTF();
        System.out.println(&quot;客户端发来的数据为：&quot;+str);

        //5.关闭流+关闭网络资源：
        dis.close();
        is.close();
        s.close();
        ss.close();
    &#125;
&#125;
</code></pre>
<p>测试：</p>
<p>（1）先开启客户端还是先开启服务器：先开服务器，再开启客户端</p>
<p>侧面验证：先开客户端：出错：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC14%E7%AB%A0_%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/8de05d3a78c633604b764ff81cf5c54c.png" class="">


<h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="功能分解2：双向通信"><a href="#功能分解2：双向通信" class="headerlink" title="功能分解2：双向通信"></a>功能分解2：双向通信</h3><p>服务器端：</p>
<ol start="2">
<li></li>
</ol>
<pre><code class="java">import java.io.\*;
import java.net.ServerSocket;
import java.net.Socket;

/\*\*
    \* @author : msb-zhaoss
        \*/
        public class TestServer &#123;//服务器

            //这是一个main方法，是程序的入口：
            public static void main(String[] args) throws IOException &#123;
                //1.创建套接字： 指定服务器的端口号
                ServerSocket ss = new ServerSocket(8888);
                //2.等着客户端发来的信息：
                Socket s = ss.accept();//阻塞方法:等待接收客户端的数据，什么时候接收到数据，什么时候程序继续向下执行。
                //accept()返回值为一个Socket，这个Socket其实就是客户端的Socket
                //接到这个Socket以后，客户端和服务器才真正产生了连接，才真正可以通信了
                //3.感受到的操作流：
                InputStream is = s.getInputStream();
                DataInputStream dis = new DataInputStream(is);

                //4.读取客户端发来的数据：
                String str = dis.readUTF();
                System.out.println(&quot;客户端发来的数据为：&quot;+str);

                //向客户端输出一句话：---》操作流---》输出流
                OutputStream os = s.getOutputStream();
                DataOutputStream dos = new DataOutputStream(os);
                dos.writeUTF(&quot;你好，我是服务器端，我接受到你的请求了&quot;);


                //5.关闭流+关闭网络资源：
                dos.close();
                os.close();
                dis.close();
                is.close();
                s.close();
                ss.close();
            &#125;
        &#125;

</code></pre>
<p>客户端：</p>
<ol start="2">
<li></li>
</ol>
<pre><code class="java">import java.io.\*;
import java.net.Socket;

public class TestClient &#123;//客户端

    //这是一个main方法，是程序的入口：
    public static void main(String[] args) throws IOException &#123;
        //1.创建套接字：指定服务器的ip和端口号：
        Socket s = new Socket(&quot;192.168.199.217&quot;,8888);
        //2.对于程序员来说，向外发送数据 感受 --》利用输出流：
        OutputStream os = s.getOutputStream();
        DataOutputStream dos = new DataOutputStream(os);
        //利用这个OutputStream就可以向外发送数据了，但是没有直接发送String的方法
        //所以我们又在OutputStream外面套了一个处理流：DataOutputStream
        dos.writeUTF(&quot;你好&quot;);

        //接收服务器端的回话--》利用输入流：
        InputStream is = s.getInputStream();
        DataInputStream dis = new DataInputStream(is);
        String str = dis.readUTF();
        System.out.println(&quot;服务器端对我说：&quot;+str);

        //3.关闭流 + 关闭网络资源：
        dis.close();
        is.close();
        dos.close();
        os.close();
        s.close();
    &#125;
&#125;

</code></pre>
<p>注意：关闭防火墙</p>
<h3 id="功能分解3：对象流传送"><a href="#功能分解3：对象流传送" class="headerlink" title="功能分解3：对象流传送"></a>功能分解3：对象流传送</h3><p>封装的User类：</p>
<ol start="2">
<li></li>
</ol>
<pre><code class="java">import java.io.Serializable;


public class User implements Serializable &#123;
    private static final long serialVersionUID = 9050691344308365540L;
    private String name;
    private String pwd;

    public String getName() &#123;
        return name;
    &#125;

    public void setName(String name) &#123;
        this.name = name;
    &#125;

    public String getPwd() &#123;
        return pwd;
    &#125;

    public void setPwd(String pwd) &#123;
        this.pwd = pwd;
    &#125;

    public User(String name, String pwd) &#123;
        this.name = name;
        this.pwd = pwd;
    &#125;
&#125;

</code></pre>
<p>客户端：</p>
<ol start="2">
<li></li>
</ol>
<pre><code class="java">import java.io.\*;
import java.net.Socket;
import java.util.Scanner;

public class TestClient &#123;//客户端

    //这是一个main方法，是程序的入口：
    public static void main(String[] args) throws IOException &#123;
        //1.创建套接字：指定服务器的ip和端口号：
        Socket s = new Socket(&quot;192.168.199.217&quot;,8888);

        //录入用户的账号和密码：
        Scanner sc = new Scanner(System.in);
        System.out.println(&quot;请录入您的账号：&quot;);
        String name = sc.next();
        System.out.println(&quot;请录入您的密码：&quot;);
        String pwd = sc.next();
        //将账号和密码封装为一个User的对象：
        User user = new User(name,pwd);


        //2.对于程序员来说，向外发送数据 感受 --》利用输出流：
        OutputStream os = s.getOutputStream();
        ObjectOutputStream oos = new ObjectOutputStream(os);
        oos.writeObject(user);


        //接收服务器端的回话--》利用输入流：
        InputStream is = s.getInputStream();
        DataInputStream dis = new DataInputStream(is);
        boolean b = dis.readBoolean();
        if(b)&#123;
            System.out.println(&quot;恭喜，登录成功&quot;);
        &#125;else&#123;
            System.out.println(&quot;对不起，登录失败&quot;);
        &#125;

        //3.关闭流 + 关闭网络资源：
        dis.close();
        is.close();
        oos.close();
        os.close();
        s.close();
    &#125;
&#125;

</code></pre>
<p>服务器：</p>
<ol start="2">
<li></li>
</ol>
<pre><code class="java">import java.io.\*;
import java.net.ServerSocket;
import java.net.Socket;


public class TestServer &#123;//服务器

    //这是一个main方法，是程序的入口：
    public static void main(String[] args) throws IOException, ClassNotFoundException &#123;
        //1.创建套接字： 指定服务器的端口号
        ServerSocket ss = new ServerSocket(8888);
        //2.等着客户端发来的信息：
        Socket s = ss.accept();//阻塞方法:等待接收客户端的数据，什么时候接收到数据，什么时候程序继续向下执行。
        //accept()返回值为一个Socket，这个Socket其实就是客户端的Socket
        //接到这个Socket以后，客户端和服务器才真正产生了连接，才真正可以通信了
        //3.感受到的操作流：
        InputStream is = s.getInputStream();
        ObjectInputStream ois = new ObjectInputStream(is);

        //4.读取客户端发来的数据：
        User user = (User)(ois.readObject());

        //对对象进行验证：
        boolean flag = false;
        if(user.getName().equals(&quot;娜娜&quot;)&amp;&amp;user.getPwd().equals(&quot;123123&quot;))&#123;
            flag = true;
        &#125;

        //向客户端输出结果：---》操作流---》输出流
        OutputStream os = s.getOutputStream();
        DataOutputStream dos = new DataOutputStream(os);
        dos.writeBoolean(flag);


        //5.关闭流+关闭网络资源：
        dos.close();
        os.close();
        ois.close();
        is.close();
        s.close();
        ss.close();
    &#125;
&#125;

</code></pre>
<h3 id="功能分解4：加入完整的处理异常方式"><a href="#功能分解4：加入完整的处理异常方式" class="headerlink" title="功能分解4：加入完整的处理异常方式"></a>功能分解4：加入完整的处理异常方式</h3><p>服务器端：</p>
<ol start="2">
<li></li>
</ol>
<pre><code class="java">import java.io.\*;
import java.net.ServerSocket;
import java.net.Socket;


public class TestServer &#123;//服务器

    //这是一个main方法，是程序的入口：
    public static void main(String[] args) &#123;
        //1.创建套接字： 指定服务器的端口号
        ServerSocket ss = null;
        Socket s = null;
        InputStream is = null;
        ObjectInputStream ois = null;
        OutputStream os = null;
        DataOutputStream dos = null;
        try &#123;
            ss = new ServerSocket(8888);
            //2.等着客户端发来的信息：
            s = ss.accept();//阻塞方法:等待接收客户端的数据，什么时候接收到数据，什么时候程序继续向下执行。
            //accept()返回值为一个Socket，这个Socket其实就是客户端的Socket
            //接到这个Socket以后，客户端和服务器才真正产生了连接，才真正可以通信了
            //3.感受到的操作流：
            is = s.getInputStream();
            ois = new ObjectInputStream(is);

            //4.读取客户端发来的数据：
            User user = (User)(ois.readObject());

            //对对象进行验证：
            boolean flag = false;
            if(user.getName().equals(&quot;娜娜&quot;)&amp;&amp;user.getPwd().equals(&quot;123123&quot;))&#123;
                flag = true;
            &#125;

            //向客户端输出结果：---》操作流---》输出流
            os = s.getOutputStream();
            dos = new DataOutputStream(os);
            dos.writeBoolean(flag);
        &#125; catch (IOException \| ClassNotFoundException e) &#123;
            e.printStackTrace();
        &#125; finally &#123;
            //5.关闭流+关闭网络资源：
            try &#123;
                if(dos!=null)&#123;
                    dos.close();
                &#125;
            &#125; catch (IOException e) &#123;
                e.printStackTrace();
            &#125;
            try &#123;
                if(os!=null)&#123;
                    os.close();
                &#125;
            &#125; catch (IOException e) &#123;
                e.printStackTrace();
            &#125;
            try &#123;
                if(ois!=null)&#123;
                    ois.close();
                &#125;
            &#125; catch (IOException e) &#123;
                e.printStackTrace();
            &#125;
            try &#123;
                if(is!=null)&#123;
                    is.close();
                &#125;
            &#125; catch (IOException e) &#123;
                e.printStackTrace();
            &#125;
            try &#123;
                if(s!=null)&#123;
                    s.close();
                &#125;
            &#125; catch (IOException e) &#123;
                e.printStackTrace();
            &#125;
            try &#123;
                if(ss!=null)&#123;
                    ss.close();
                &#125;
            &#125; catch (IOException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;




    &#125;
&#125;

</code></pre>
<p>客户端：</p>
<ol start="2">
<li></li>
</ol>
<pre><code class="java">import java.io.\*;
import java.net.Socket;
import java.util.Scanner;


public class TestClient &#123;//客户端

    //这是一个main方法，是程序的入口：
    public static void main(String[] args)&#123;
        //1.创建套接字：指定服务器的ip和端口号：
        Socket s = null;
        OutputStream os = null;
        ObjectOutputStream oos = null;
        InputStream is = null;
        DataInputStream dis = null;
        try &#123;
            s = new Socket(&quot;192.168.199.217&quot;,8888);
            //录入用户的账号和密码：
            Scanner sc = new Scanner(System.in);
            System.out.println(&quot;请录入您的账号：&quot;);
            String name = sc.next();
            System.out.println(&quot;请录入您的密码：&quot;);
            String pwd = sc.next();
            //将账号和密码封装为一个User的对象：
            User user = new User(name,pwd);
            //2.对于程序员来说，向外发送数据 感受 --》利用输出流：
            os = s.getOutputStream();
            oos = new ObjectOutputStream(os);
            oos.writeObject(user);
            //接收服务器端的回话--》利用输入流：
            is = s.getInputStream();
            dis = new DataInputStream(is);
            boolean b = dis.readBoolean();
            if(b)&#123;
                System.out.println(&quot;恭喜，登录成功&quot;);
            &#125;else&#123;
                System.out.println(&quot;对不起，登录失败&quot;);
            &#125;
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125; finally&#123;
            //3.关闭流 + 关闭网络资源：
            try &#123;
                if(dis!=null)&#123;
                    dis.close();
                &#125;
            &#125; catch (IOException e) &#123;
                e.printStackTrace();
            &#125;
            try &#123;
                if(is!=null)&#123;
                    is.close();
                &#125;
            &#125; catch (IOException e) &#123;
                e.printStackTrace();
            &#125;
            try &#123;
                if(oos!=null)&#123;
                    oos.close();
                &#125;
            &#125; catch (IOException e) &#123;
                e.printStackTrace();
            &#125;
            try &#123;
                if(os!=null)&#123;
                    os.close();
                &#125;
            &#125; catch (IOException e) &#123;
                e.printStackTrace();
            &#125;
            try &#123;
                if(s!=null)&#123;
                    s.close();
                &#125;
            &#125; catch (IOException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;




    &#125;
&#125;

</code></pre>
<h3 id="功能分解5：多线程接收用户请求"><a href="#功能分解5：多线程接收用户请求" class="headerlink" title="功能分解5：多线程接收用户请求"></a>功能分解5：多线程接收用户请求</h3><p>遗留问题：服务器针对一个请求服务，之后服务器就关闭了（程序自然结束了）</p>
<p>现在需要解决：服务器必须一直在监听 ，一直开着，等待客户端的请求</p>
<p>在当前代码中，客户端不用动了</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC14%E7%AB%A0_%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/55e902e4e9bedbb725045b7b82e8a9d8.png" class="">


<p>更改服务器代码：</p>
<ol start="2">
<li></li>
</ol>
<pre><code class="java">import java.io.\*;
import java.net.Socket;


public class ServerThread extends Thread &#123;//线程：专门处理客户端的请求
    InputStream is = null;
    ObjectInputStream ois = null;
    OutputStream os = null;
    DataOutputStream dos = null;
    Socket s = null;
    public ServerThread(Socket s)&#123;
        this.s = s;
    &#125;
    @Override
    public void run() &#123;
        try&#123;
            //2.等着客户端发来的信息：

            is = s.getInputStream();
            ois = new ObjectInputStream(is);

            //4.读取客户端发来的数据：
            User user = (User)(ois.readObject());

            //对对象进行验证：
            boolean flag = false;
            if(user.getName().equals(&quot;娜娜&quot;)&amp;&amp;user.getPwd().equals(&quot;123123&quot;))&#123;
                flag = true;
            &#125;

            //向客户端输出结果：---》操作流---》输出流
            os = s.getOutputStream();
            dos = new DataOutputStream(os);
            dos.writeBoolean(flag);
        &#125;catch (IOException \| ClassNotFoundException e) &#123;
            e.printStackTrace();
        &#125;finally &#123;
            try &#123;
                if(dos!=null)&#123;
                    dos.close();
                &#125;
            &#125; catch (IOException e) &#123;
                e.printStackTrace();
            &#125;
            try &#123;
                if(os!=null)&#123;
                    os.close();
                &#125;
            &#125; catch (IOException e) &#123;
                e.printStackTrace();
            &#125;
            try &#123;
                if(ois!=null)&#123;
                    ois.close();
                &#125;
            &#125; catch (IOException e) &#123;
                e.printStackTrace();
            &#125;
            try &#123;
                if(is!=null)&#123;
                    is.close();
                &#125;
            &#125; catch (IOException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;
    &#125;
&#125;

</code></pre>
<pre><code class="java">import java.io.\*;
import java.net.ServerSocket;
import java.net.Socket;

public class TestServer &#123;//服务器

    //这是一个main方法，是程序的入口：
    public static void main(String[] args) &#123;
        System.out.println(&quot;服务器启动了&quot;);
        //1.创建套接字： 指定服务器的端口号
        ServerSocket ss = null;
        Socket s = null;
        int count = 0;//定义一个计数器，用来计数 客户端的请求
        try &#123;
            ss = new ServerSocket(8888);
            while(true)&#123;//加入死循环，服务器一直监听客户端是否发送数据
                s = ss.accept();//阻塞方法:等待接收客户端的数据，什么时候接收到数据，什么时候程序继续向下执行。
                //每次过来的客户端的请求 靠 线程处理：
                new ServerThread(s).start();
                count++;
                //输入请求的客户端的信息：
                System.out.println(&quot;当前是第&quot;+count+&quot;个用户访问我们的服务器,对应的用户是：&quot;+s.getInetAddress());
            &#125;
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;

</code></pre>
<h2 id="基于UDP的网络编程"><a href="#基于UDP的网络编程" class="headerlink" title="基于UDP的网络编程"></a>基于UDP的网络编程</h2><p>TCP:</p>
<p>客户端：Socket</p>
<p>程序感受到的 使用流 ：输出流</p>
<p>服务器端： ServerSocket —&gt;Socket 程序感受到的 使用流 ：输入流</p>
<p>（客户端和服务器端地位不平等。）</p>
<p>UDP:</p>
<p>发送方：DatagramSocket 发送：数据包 DatagramPacket</p>
<p>接收方：DatagramSocket 接收：数据包 DatagramPacket</p>
<p>（发送方和接收方的地址是平等的。）</p>
<p>UDP案例： 完成网站的咨询聊天</p>
<h3 id="功能分解1：单向通信-1"><a href="#功能分解1：单向通信-1" class="headerlink" title="功能分解1：单向通信"></a>功能分解1：单向通信</h3><p>发送方：</p>
<ol start="2">
<li></li>
</ol>
<pre><code class="java">import java.io.IOException;
import java.net.\*;


public class TestSend &#123;//发送方：

    //这是一个main方法，是程序的入口：
    public static void main(String[] args) throws IOException &#123;
        System.out.println(&quot;学生上线。。。&quot;);
        //1.准备套接字： 指定发送方的端口号
        DatagramSocket ds = new DatagramSocket(8888);
        //2.准备数据包
        String str = &quot;你好&quot;;
        byte[] bytes = str.getBytes();
        /\*
            需要四个参数：
            1.指的是传送数据转为字节数组
            2.字节数组的长度
            3.封装接收方的ip
            4.指定接收方的端口号
            \*/
            DatagramPacket dp = new DatagramPacket(bytes,bytes.length, InetAddress.getByName(&quot;localhost&quot;),9999);
        //发送：
        ds.send(dp);

        //关闭资源
        ds.close();
    &#125;
&#125;

</code></pre>
<p>接收方：</p>
<ol start="2">
<li></li>
</ol>
<pre><code class="java">import java.io.IOException;
import java.net.DatagramPacket;
import java.net.DatagramSocket;
import java.net.SocketException;


public class TestReceive &#123;//接收方

    //这是一个main方法，是程序的入口：
    public static void main(String[] args) throws IOException &#123;
        System.out.println(&quot;老师上线了。。&quot;);
        //1.创建套接字：指定接收方的端口
        DatagramSocket ds = new DatagramSocket(9999);
        //2.有一个空的数据包，打算用来接收 对方传过来的数据包：
        byte[] b = new byte[1024];
        DatagramPacket dp = new DatagramPacket(b,b.length);
        //3.接收对方的数据包，然后放入我们的dp数据包中填充
        ds.receive(dp);//接收完以后 dp里面就填充好内容了

        //4.取出数据：
        byte[] data = dp.getData();
        String s = new String(data,0,dp.getLength());//dp.getLength()数组包中的有效长度
        System.out.println(&quot;学生对我说：&quot;+s);

        //5.关闭资源：
        ds.close();


    &#125;
&#125;

</code></pre>
<h3 id="-1"><a href="#-1" class="headerlink" title=""></a></h3><h3 id="功能分解2：双向通信-1"><a href="#功能分解2：双向通信-1" class="headerlink" title="功能分解2：双向通信"></a>功能分解2：双向通信</h3><p>发送方：</p>
<ol start="2">
<li></li>
</ol>
<pre><code class="java">import java.io.IOException;
import java.net.\*;
import java.util.Scanner;

public class TestSend &#123;//发送方：

    //这是一个main方法，是程序的入口：
    public static void main(String[] args) throws IOException &#123;
        System.out.println(&quot;学生上线。。。&quot;);
        //1.准备套接字： 指定发送方的端口号
        DatagramSocket ds = new DatagramSocket(8888);
        //2.准备数据包
        Scanner sc = new Scanner(System.in);
        System.out.print(&quot;学生：&quot;);
        String str = sc.next();
        byte[] bytes = str.getBytes();
        /\*
            需要四个参数：
            1.指的是传送数据转为Z字节数组
            2.字节数组的长度
            3.封装接收方的ip
            4.指定接收方的端口号
            \*/
            DatagramPacket dp = new DatagramPacket(bytes,bytes.length, InetAddress.getByName(&quot;localhost&quot;),9999);
        //发送：
        ds.send(dp);

        //接收老师发送回来的信息：
        byte[] b = new byte[1024];
        DatagramPacket dp2 = new DatagramPacket(b,b.length);
        ds.receive(dp2);//接收完以后 dp2里面就填充好内容了

        //取出数据：
        byte[] data = dp2.getData();
        String s = new String(data,0,dp2.getLength());//dp.getLength()数组包中的有效长度
        System.out.println(&quot;老师对我说：&quot;+s);

        //关闭资源
        ds.close();
    &#125;
&#125;

</code></pre>
<p>接收方：</p>
<ol start="2">
<li></li>
</ol>
<pre><code class="java">import java.io.IOException;
import java.net.DatagramPacket;
import java.net.DatagramSocket;
import java.net.InetAddress;
import java.net.SocketException;
import java.util.Scanner;


public class TestReceive &#123;//接收方

    //这是一个main方法，是程序的入口：
    public static void main(String[] args) throws IOException &#123;
        System.out.println(&quot;老师上线了。。&quot;);
        //1.创建套接字：指定接收方的端口
        DatagramSocket ds = new DatagramSocket(9999);
        //2.有一个空的数据包，打算用来接收 对方传过来的数据包：
        byte[] b = new byte[1024];
        DatagramPacket dp = new DatagramPacket(b,b.length);
        //3.接收对方的数据包，然后放入我们的dp数据包中填充
        ds.receive(dp);//接收完以后 dp里面就填充好内容了

        //4.取出数据：
        byte[] data = dp.getData();
        String s = new String(data,0,dp.getLength());//dp.getLength()数组包中的有效长度
        System.out.println(&quot;学生对我说：&quot;+s);

        //老师进行回复：
        Scanner sc = new Scanner(System.in);
        System.out.print(&quot;老师：&quot;);
        String str = sc.next();
        byte[] bytes = str.getBytes();
        //封装数据，并且指定学生的ip和端口号
        DatagramPacket dp2 = new DatagramPacket(bytes,bytes.length, InetAddress.getByName(&quot;localhost&quot;),8888);
        //发送：
        ds.send(dp2);
        //5.关闭资源：
        ds.close();


    &#125;
&#125;

</code></pre>
<h3 id="功能分解3：加入完整的处理异常方式"><a href="#功能分解3：加入完整的处理异常方式" class="headerlink" title="功能分解3：加入完整的处理异常方式"></a>功能分解3：加入完整的处理异常方式</h3><p>发送方：</p>
<ol start="2">
<li></li>
</ol>
<pre><code class="java">import java.io.IOException;
import java.net.\*;
import java.util.Scanner;


public class TestSend &#123;//发送方：

    //这是一个main方法，是程序的入口：
    public static void main(String[] args) &#123;
        System.out.println(&quot;学生上线。。。&quot;);
        //1.准备套接字： 指定发送方的端口号
        DatagramSocket ds = null;
        try &#123;
            ds = new DatagramSocket(8888);
            //2.准备数据包
            Scanner sc = new Scanner(System.in);
            System.out.print(&quot;学生：&quot;);
            String str = sc.next();
            byte[] bytes = str.getBytes();
            /\*
                需要四个参数：
                1.指的是传送数据转为Z字节数组
                2.字节数组的长度
                3.封装接收方的ip
                4.指定接收方的端口号
                \*/
                DatagramPacket dp = new DatagramPacket(bytes,bytes.length, InetAddress.getByName(&quot;localhost&quot;),9999);
            //发送：
            ds.send(dp);

            //接收老师发送回来的信息：
            byte[] b = new byte[1024];
            DatagramPacket dp2 = new DatagramPacket(b,b.length);
            ds.receive(dp2);//接收完以后 dp2里面就填充好内容了

            //取出数据：
            byte[] data = dp2.getData();
            String s = new String(data,0,dp2.getLength());//dp.getLength()数组包中的有效长度
            System.out.println(&quot;老师对我说：&quot;+s);
        &#125; catch (SocketException e) &#123;
            e.printStackTrace();
        &#125; catch (UnknownHostException e) &#123;
            e.printStackTrace();
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125; finally &#123;
            //关闭资源
            ds.close();
        &#125;



    &#125;
&#125;

</code></pre>
<p>接收方：</p>
<ol start="2">
<li></li>
</ol>
<pre><code class="java">import java.io.IOException;
import java.net.\*;
import java.util.Scanner;

public class TestReceive &#123;//接收方

    //这是一个main方法，是程序的入口：
    public static void main(String[] args)&#123;
        System.out.println(&quot;老师上线了。。&quot;);
        //1.创建套接字：指定接收方的端口
        DatagramSocket ds = null;
        try &#123;
            ds = new DatagramSocket(9999);
            //2.有一个空的数据包，打算用来接收 对方传过来的数据包：
            byte[] b = new byte[1024];
            DatagramPacket dp = new DatagramPacket(b,b.length);
            //3.接收对方的数据包，然后放入我们的dp数据包中填充
            ds.receive(dp);//接收完以后 dp里面就填充好内容了

            //4.取出数据：
            byte[] data = dp.getData();
            String s = new String(data,0,dp.getLength());//dp.getLength()数组包中的有效长度
            System.out.println(&quot;学生对我说：&quot;+s);

            //老师进行回复：
            Scanner sc = new Scanner(System.in);
            System.out.print(&quot;老师：&quot;);
            String str = sc.next();
            byte[] bytes = str.getBytes();
            //封装数据，并且指定学生的ip和端口号
            DatagramPacket dp2 = new DatagramPacket(bytes,bytes.length, InetAddress.getByName(&quot;localhost&quot;),8888);
            //发送：
            ds.send(dp2);
        &#125; catch (SocketException e) &#123;
            e.printStackTrace();
        &#125; catch (UnknownHostException e) &#123;
            e.printStackTrace();
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125; finally &#123;
            //5.关闭资源：
            ds.close();
        &#125;




    &#125;
&#125;
</code></pre>
<h3 id="功能分解4：正常通信"><a href="#功能分解4：正常通信" class="headerlink" title="功能分解4：正常通信"></a>功能分解4：正常通信</h3><p>发送方：</p>
<ol start="2">
<li></li>
</ol>
<pre><code class="java">import java.io.IOException;
import java.net.\*;
import java.util.Scanner;

public class TestSend &#123;//发送方：

    //这是一个main方法，是程序的入口：
    public static void main(String[] args) &#123;
        System.out.println(&quot;学生上线。。。&quot;);
        //1.准备套接字： 指定发送方的端口号
        DatagramSocket ds = null;
        try &#123;
            ds = new DatagramSocket(8888);
            while(true)&#123;
                //2.准备数据包
                Scanner sc = new Scanner(System.in);
                System.out.print(&quot;学生：&quot;);
                String str = sc.next();

                byte[] bytes = str.getBytes();
                /\*
                    需要四个参数：
                    1.指的是传送数据转为Z字节数组
                    2.字节数组的长度
                    3.封装接收方的ip
                    4.指定接收方的端口号
                    \*/
                    DatagramPacket dp = new DatagramPacket(bytes,bytes.length, InetAddress.getByName(&quot;localhost&quot;),9999);
                //发送：
                ds.send(dp);
                if(str.equals(&quot;byebye&quot;))&#123;
                    System.out.println(&quot;学生下线。。&quot;);
                    break;
                &#125;
                //接收老师发送回来的信息：
                byte[] b = new byte[1024];
                DatagramPacket dp2 = new DatagramPacket(b,b.length);
                ds.receive(dp2);//接收完以后 dp2里面就填充好内容了

                //取出数据：
                byte[] data = dp2.getData();
                String s = new String(data,0,dp2.getLength());//dp.getLength()数组包中的有效长度
                System.out.println(&quot;老师对我说：&quot;+s);
            &#125;
        &#125; catch (SocketException e) &#123;
            e.printStackTrace();
        &#125; catch (UnknownHostException e) &#123;
            e.printStackTrace();
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125; finally &#123;
            //关闭资源
            ds.close();
        &#125;



    &#125;
&#125;

</code></pre>
<p>接收方：</p>
<ol start="2">
<li></li>
</ol>
<pre><code class="java">import java.io.IOException;
import java.net.\*;
import java.util.Scanner;


public class TestReceive &#123;//接收方

    //这是一个main方法，是程序的入口：
    public static void main(String[] args)&#123;
        System.out.println(&quot;老师上线了。。&quot;);
        //1.创建套接字：指定接收方的端口
        DatagramSocket ds = null;
        try &#123;
            ds = new DatagramSocket(9999);
            while(true)&#123;
                //2.有一个空的数据包，打算用来接收 对方传过来的数据包：
                byte[] b = new byte[1024];
                DatagramPacket dp = new DatagramPacket(b,b.length);
                //3.接收对方的数据包，然后放入我们的dp数据包中填充
                ds.receive(dp);//接收完以后 dp里面就填充好内容了

                //4.取出数据：
                byte[] data = dp.getData();
                String s = new String(data,0,dp.getLength());//dp.getLength()数组包中的有效长度
                System.out.println(&quot;学生对我说：&quot;+s);
                if(s.equals(&quot;byebye&quot;))&#123;
                    System.out.println(&quot;学生已经下线了，老师也下线。。。&quot;);
                    break;
                &#125;

                //老师进行回复：
                Scanner sc = new Scanner(System.in);
                System.out.print(&quot;老师：&quot;);
                String str = sc.next();
                byte[] bytes = str.getBytes();
                //封装数据，并且指定学生的ip和端口号
                DatagramPacket dp2 = new DatagramPacket(bytes,bytes.length, InetAddress.getByName(&quot;localhost&quot;),8888);
                //发送：
                ds.send(dp2);
            &#125;
        &#125; catch (SocketException e) &#123;
            e.printStackTrace();
        &#125; catch (UnknownHostException e) &#123;
            e.printStackTrace();
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125; finally &#123;
            //5.关闭资源：
            ds.close();
        &#125;




    &#125;
</code></pre>
]]></content>
      <categories>
        <category>JavaSE</category>
        <category>网络编程</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title>第15章Junit注解_枚举</title>
    <url>/2022/10/07/Java/%E7%AC%AC15%E7%AB%A0Junit%E6%B3%A8%E8%A7%A3_%E6%9E%9A%E4%B8%BE/</url>
    <content><![CDATA[<h1 id="第15章-Junit-注解-枚举"><a href="#第15章-Junit-注解-枚举" class="headerlink" title="第15章_Junit_注解_枚举"></a>第15章_Junit_注解_枚举</h1><h1 id="Junit单元测试"><a href="#Junit单元测试" class="headerlink" title="Junit单元测试"></a>Junit单元测试</h1><h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><p>【1】软件测试的目的：</p>
<p>软件测试的目的是在规定的条件下对程序进行操作,以发现程序错误,衡量软件质量,并对其是否能满足设计要求进行评估的过程。</p>
<p>【2】测试分类：</p>
<p>（1）黑盒测试：</p>
<p>软件的黑盒测试意味着测试要在软件的接口处进行。这种方法是把测试对象看做一个黑盒子,测试人员完全不考虑程序内部的逻辑结构和内部特性,只依据程序的需求规格说明书,检查程序的功能是否符合它的功能说明。因此黑盒测试又叫功能测试。</p>
<p>（2）白盒测试：—》Junit属于白盒测试。</p>
<p>软件的白盒测试是对软件的过程性细节做细致的检查。这种方法是把测试对象看做一个打开的盒子,它允许测试人员利用程序内部的逻辑结构及有关信息,设计或选择测试用例,对程序的所有逻辑路径进行测试,通过在不同点检查程序状态,确定实际状态是否与预期的状态一致。因此白盒测试又称为结构测试。</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC15%E7%AB%A0Junit%E6%B3%A8%E8%A7%A3_%E6%9E%9A%E4%B8%BE/42a7ac6afb1bc65c1526524fb22c0cf6.png" class="">


<h2 id="没有Junit的情况下如何测试"><a href="#没有Junit的情况下如何测试" class="headerlink" title="没有Junit的情况下如何测试"></a>没有Junit的情况下如何测试</h2><p>在没有使用Junit的时候，缺点：</p>
<p>（1）测试一定走main方法，是程序的入口，main方法的格式必须不能写错。</p>
<p>（2）要是在同一个main方法中测试的话，那么不需要测试的东西必须注释掉。</p>
<p>（3）测试逻辑如果分开的话，需要定义多个测试类，麻烦。</p>
<p>（4）业务逻辑和测试代码，都混淆了。</p>
<p>代码：</p>
<pre><code class="java">public class Calculator &#123;
    //加法：
    public int add(int a,int b)&#123;
        return a+b;
    &#125;

    //减法：
    public int sub(int a,int b)&#123;
        return a-b;
    &#125;
&#125;

public class Test &#123;
    //这是一个main方法，是程序的入口：
    public static void main(String[] args) &#123;
        //测试加法：
        Calculator cal = new Calculator();
        int result = cal.add(10, 20);
        System.out.println(result);
        //测试减法：
        /\* int result = cal.sub(30, 10);
        System.out.println(result);\*/
    &#125;
&#125;
public class Test02 &#123;
    //这是一个main方法，是程序的入口：
    public static void main(String[] args) &#123;
        Calculator cal = new Calculator();
        //测试减法：
        int result = cal.sub(30, 10);
        System.out.println(result);
    &#125;
&#125;

</code></pre>
<h2 id="Junit的使用"><a href="#Junit的使用" class="headerlink" title="Junit的使用"></a>Junit的使用</h2><p>【1】一般测试和业务做一个分离，分离为不同的包：</p>
<p>建议起名：公司域名倒着写+test</p>
<p>以后测试类就单独放在这个包下</p>
<p>【2】测试类的名字：****Test —&gt;见名知意</p>
<p>【3】测试方法的定义–》这个方法可以独立运行，不依托于main方法</p>
<p>建议：</p>
<p>名字：testAdd() testSub() 见名知意</p>
<p>参数：无参</p>
<p>返回值：void</p>
<p>【4】测试方法定义完以后，不能直接就独立运行了，必须要在方法前加入一个注解： @Test</p>
<p>【5】导入Junit的依赖的环境：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC15%E7%AB%A0Junit%E6%B3%A8%E8%A7%A3_%E6%9E%9A%E4%B8%BE/46fb99bb996eae46795d2c8db94485f6.png" class="">


<p>【6】代码：</p>
<pre><code class="java">public class CalculatorTest &#123;
    //测试add方法
    @Test
    public void testAdd()&#123;
        System.out.println(&quot;测试add方法&quot;);
        Calculator cal = new Calculator();
        int result = cal.add(10, 30);
        System.out.println(result);
    &#125;

    //测试sub方法
    @Test
    public void testSub()&#123;
        System.out.println(&quot;测试sub方法&quot;);
        Calculator cal = new Calculator();
        int result = cal.sub(10, 30);
        System.out.println(result);
    &#125;
&#125;

</code></pre>
<p>【7】判定结果：</p>
<p>绿色：正常结果</p>
<p>红色：出现异常</p>
<p>【8】即使出现绿色效果，也不意味着你的测试就通过了，因为代码中逻辑也可能出现问题，这种情况怎么解决呢？</p>
<p>加入断言</p>
<pre><code class="java">public class CalculatorTest &#123;
    //测试add方法
    @Test
    public void testAdd()&#123;
        System.out.println(&quot;测试add方法&quot;);
        Calculator cal = new Calculator();
        int result = cal.add(10, 30);
        //System.out.println(result);--》程序的运行结果可以不关注
        //加入断言：预测一下结果，判断一下我预测的结果和 实际的结果是否一致：
        Assert.assertEquals(40,result);//第一个参数：预测结果 第二个参数：实际结果
    &#125;

    //测试sub方法
    @Test
    public void testSub()&#123;
        System.out.println(&quot;测试sub方法&quot;);
        Calculator cal = new Calculator();
        int result = cal.sub(10, 30);
        System.out.println(result);
    &#125;
&#125;

</code></pre>
<img data-src="/2022/10/07/Java/%E7%AC%AC15%E7%AB%A0Junit%E6%B3%A8%E8%A7%A3_%E6%9E%9A%E4%B8%BE/f28545eda706a96a1dc81a62bd94b0b6.png" class="">


<h2 id="Before-After"><a href="#Before-After" class="headerlink" title="@Before_@After"></a>@Before_@After</h2><p>@Before:</p>
<p>某一个方法中，加入了@Before注解以后，那么这个方法中的功能会在测试方法执行前先执行</p>
<p>一般会在@Beforer修饰的那个方法中加入：加入一些申请资源的代码：申请数据库资源，申请IO资源，申请网络资源。。。</p>
<p>@After:</p>
<p>某一个方法中，加入了@After注解以后，那么这个方法中的功能会在测试方法执行后先执行</p>
<p>一般会在@After修饰的那个方法中加入：加入释放资源的代码：释放数据库资源，释放IO资源，释放网络资源。。。</p>
<p>代码：</p>
<pre><code class="java">public class CalculatorTest &#123;
    @Before
    public void init()&#123;
        System.out.println(&quot;方法执行开始了。。。&quot;);
    &#125;
    @After
    public void close()&#123;
        System.out.println(&quot;方法执行结束了。。。&quot;);
    &#125;
    //测试add方法
    @Test
    public void testAdd()&#123;
        System.out.println(&quot;测试add方法&quot;);
        Calculator cal = new Calculator();
        int result = cal.add(10, 30);
        //System.out.println(result);--》程序的运行结果可以不关注
        //加入断言：预测一下结果，判断一下我预测的结果和 实际的结果是否一致：
        Assert.assertEquals(40,result);//第一个参数：预测结果 第二个参数：实际结果
    &#125;

    //测试sub方法
    @Test
    public void testSub()&#123;
        System.out.println(&quot;测试sub方法&quot;);
        Calculator cal = new Calculator();
        int result = cal.sub(10, 30);
        System.out.println(result);
    &#125;
&#125;

</code></pre>
<h1 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h1><h2 id="引入-1"><a href="#引入-1" class="headerlink" title="引入"></a>引入</h2><p>【1】历史：</p>
<p>JDK5.0 新增 — 注解（Annotation）,也叫元数据</p>
<p>【2】什么是注解？</p>
<p>注解其实就是代码里的特殊标记，这些标记可以在编译,类加载,运行时被读取,并执行相应的处理。通过使用注解,程序员可以在不改变原有逻辑的情况下，在源文件中嵌入一些补充信息。代码分析工具、开发工具和部署工具可以通过这些补充信息进行验证或者进行部署。</p>
<p>使用注解时要在其前面增加@符号,并把该注解当成一个修饰符使用。用于修饰它支持的程序元素。</p>
<p>【3】注解的重要性：</p>
<p>Annotation 可以像修饰符一样被使用，可用于修饰包，类，构造器,方法，成员变量,参数，局部变量的声明，这些信息被保存在Annotation的”name&#x3D;value”对中。在JavaSE中，注解的使用目的比较简单，例如标记过时的功能，忽略警告等。在JavaEE&#x2F;ArIdroid中注解占据了更重要的角色，例如用来配置应用程序的任何切面，代替JavaEE旧版中所遗留的繁冗代码和XML配置等。未来的开发模式都是基于注解的，JPA(java的持久化API)是基于注解的，Spring2.5以. E都是基于注解的，Hibernate3.x以后也是基于注解的，现在的Struts2有一部分也是基于注解的了，注解是一种趋势，一定程度上可以说 ：框架&#x3D;注解+反射+设计模式。</p>
<h2 id="注解的使用实例"><a href="#注解的使用实例" class="headerlink" title="注解的使用实例"></a>注解的使用实例</h2><h3 id="Junit的注解"><a href="#Junit的注解" class="headerlink" title="Junit的注解"></a>Junit的注解</h3><p>@Test</p>
<p>@Before</p>
<p>@After</p>
<p>代码：</p>
<pre><code class="java">

 public class CalculatorTest &#123;
 @Before
 public void init()&#123;
 System.out.println(&quot;方法执行开始了。。。&quot;);
 &#125;
 @After
 public void close()&#123;
 System.out.println(&quot;方法执行结束了。。。&quot;);
 &#125;
 @Test
 public void testAdd()&#123;
 System.out.println(&quot;测试add方法&quot;);
 Calculator cal = new Calculator();
 int result = cal.add(10, 30);
 Assert.assertEquals(40,result);//第一个参数：预测结果 第二个参数：实际结果
 &#125;
 &#125;
</code></pre>
<h3 id="文档相关的注解"><a href="#文档相关的注解" class="headerlink" title="文档相关的注解"></a>文档相关的注解</h3><p>说明注释允许你在程序中嵌入关于程序的信息。你可以使用 javadoc 工具软件来生成信息，并输出到HTML文件中。</p>
<p>说明注释，使你更加方便的记录你的程序信息。</p>
<p>文档注解我们一般使用在文档注释中，配合javadoc工具</p>
<p>javadoc 工具软件识别以下标签：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC15%E7%AB%A0Junit%E6%B3%A8%E8%A7%A3_%E6%9E%9A%E4%B8%BE/23874004c970e81a5f5e4f59177c0a6f.png" class="">


<p>其中注意：</p>
<p>Ø @param @return和@exception这三个标记都是只用于方法的。</p>
<p>Ø @param的格式要求: @param 形参名 形参类型 形参说明</p>
<p>Ø @return的格式要求: @return 返回值类型返回值说明，如果方法的返回值类型是void就不能写</p>
<p>Ø @exception的格式要求: @exception 异常类型异常说明</p>
<p>Ø @param和@exception可以并列多个</p>
<p>代码：</p>
<pre><code class="java">public class Person &#123;
    /**
 * 下面是eat方法，实现了XXX功能。
 * @param num1 就餐人数
 * @param num2 点了几个菜
 */
    public void eat(int num1,int num2)&#123;

    &#125;

    /\*\*
        \* @param age 年龄
        \* @return int
        \* @exception RuntimeException 当年龄过大的时候
        \* @exception IndexOutOfBoundsException 当年龄过小的时候
        \* @see Student
        \*/
        public int sleep(int age)&#123;
        new Student();
        if(age\&gt;100)&#123;
            throw new RuntimeException();
        &#125;
        if(age\&lt;0)&#123;
            throw new IndexOutOfBoundsException();
        &#125;
        return 10;
    &#125;
&#125;
</code></pre>
<p>IDEA中的javadoc使用：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC15%E7%AB%A0Junit%E6%B3%A8%E8%A7%A3_%E6%9E%9A%E4%B8%BE/1887cd6739c2f89c5a4ef2d33ec03b55.png" class="">


<p>防止乱码：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC15%E7%AB%A0Junit%E6%B3%A8%E8%A7%A3_%E6%9E%9A%E4%B8%BE/7fe5daf476aadfa53d22106b5979d514.png" class="">


<img data-src="/2022/10/07/Java/%E7%AC%AC15%E7%AB%A0Junit%E6%B3%A8%E8%A7%A3_%E6%9E%9A%E4%B8%BE/010eb501804b4f0f6a550a3a3c8617a2.png" class="">


<h3 id="JDK内置的3个注解"><a href="#JDK内置的3个注解" class="headerlink" title="JDK内置的3个注解"></a>JDK内置的3个注解</h3><p>@Override:限定重写父类方法，该注解只能用于方法</p>
<pre><code class="java">
</code></pre>
<p>| ———————————————————— |</p>
<pre><code class="java">
</code></pre>
<p>@Deprecated:用于表示所修饰的元素(类,方法，构造器，属性等)已过时。通常是因为所修饰的结构危险或存在更好的选择</p>
<pre><code class="java">public class Student extends Person &#123;
    /\*
        @Override的作用：限定重写的方法，只要重写方法有问题，就有错误提示。
        \*/
        @Override
        public void eat()&#123;
        System.out.println(&quot;子类eat..&quot;);
    &#125;
    /\*
        在方法前加入@Deprecated，这个方法就会变成一个废弃方法/过期方法/过时方法
        \*/

        @Deprecated
        public void study()&#123;
        System.out.println(&quot;学习。。&quot;);
    &#125;
&#125;
</code></pre>
<img data-src="/2022/10/07/Java/%E7%AC%AC15%E7%AB%A0Junit%E6%B3%A8%E8%A7%A3_%E6%9E%9A%E4%B8%BE/e87bd738286630379a4436ddeb991a7f.png" class="">


<p>@SuppressWarnings:抑制编译器警告</p>
<pre><code class="java">public class Test02 &#123;
    //这是一个main方法，是程序的入口：
    public static void main(String[] args) &#123;
        @SuppressWarnings(&quot;unused&quot;)
        int age = 10;

        int num = 10;
        System.out.println(num);
        @SuppressWarnings(&#123;&quot;unused&quot;,&quot;rwatypes&quot;&#125;)
        ArrayList al = new ArrayList();
    &#125;
&#125;
</code></pre>
<h3 id="实现替代配置文件功能的注解"><a href="#实现替代配置文件功能的注解" class="headerlink" title="实现替代配置文件功能的注解"></a>实现替代配置文件功能的注解</h3><p>在servlet3.0之前的配置：</p>
<table>
<thead>
<tr>
<th>&lt;?xml version&#x3D;”1.0” encoding&#x3D;”UTF-8”?&gt;  &lt;web-app xmlns&#x3D;”<span class="exturl" data-url="aHR0cDovL3htbG5zLmpjcC5vcmcveG1sL25zL2phdmFlZSZxdW90Ow==">http://xmlns.jcp.org/xml/ns/javaee&quot;</span>   xmlns:xsi&#x3D;”<span class="exturl" data-url="aHR0cDovL3d3dy53My5vcmcvMjAwMS9YTUxTY2hlbWEtaW5zdGFuY2UmcXVvdDs=">http://www.w3.org/2001/XMLSchema-instance&quot;</span>   xsi:schemaLocation&#x3D;”<span class="exturl" data-url="aHR0cDovL3htbG5zLmpjcC5vcmcveG1sL25zL2phdmFlZQ==">http://xmlns.jcp.org/xml/ns/javaee</span> <span class="exturl" data-url="aHR0cDovL3htbG5zLmpjcC5vcmcveG1sL25zL2phdmFlZS93ZWItYXBwXzRfMC54c2QmcXVvdDs=">http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;</span>   version&#x3D;”4.0”&gt;   &lt;!–配置Servlet–&gt;   &lt;!–配置Servlet的信息–&gt;   &lt;servlet&gt;   &lt;servlet-name&gt;HelloServlet&lt;&#x2F;servlet-name&gt;   &lt;servlet-class&gt;com.bjsxt.servlet.HelloServlet&lt;&#x2F;servlet-class&gt;   &lt;&#x2F;servlet&gt;   &lt;!–配置Servlet的映射路径–&gt;   &lt;servlet-mapping&gt;   &lt;servlet-name&gt;HelloServlet&lt;&#x2F;servlet-name&gt;   &lt;!–<span class="exturl" data-url="aHR0cDovL2xvY2FsaG9zdDo4MDgwLzAxLWhlbGxvLXNlcnZsZXQvaGVsbG8tLS8mZ3Q7">http://localhost:8080/01-hello-servlet/hello--\&gt;</span>   &lt;url-pattern&gt;&#x2F;hello&lt;&#x2F;url-pattern&gt;   &lt;&#x2F;servlet-mapping&gt;  &lt;&#x2F;web-app&gt;</th>
</tr>
</thead>
</table>
<p>在servlet3.0之后使用注解：替代配置文件。</p>
<pre><code class="java">
</code></pre>
<p>|——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————–|</p>
<h2 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h2><p>【1】自定义注解使用很少，一般情况下都是用现成的注解。</p>
<p>【2】如何自定义注解：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC15%E7%AB%A0Junit%E6%B3%A8%E8%A7%A3_%E6%9E%9A%E4%B8%BE/4b5d48a592cbac3d289f687d5e9ec1e7.png" class="">


<img data-src="/2022/10/07/Java/%E7%AC%AC15%E7%AB%A0Junit%E6%B3%A8%E8%A7%A3_%E6%9E%9A%E4%B8%BE/1f30647690be446463b91286618f3176.png" class="">


<p>发现定义的注解的声明使用的关键字：<span class="exturl" data-url="ZmlsZTovLy9EOlzkuIvovb1AaW50ZXJmYWNl">@interface</span>，跟接口没有一点关系。</p>
<p>【3】注解的内部：</p>
<p>以<span class="exturl" data-url="ZmlsZTovLy9EOlzkuIvovb1AU3VwcHJlc3NXYXJuaW5ncw==">@SuppressWarnings</span>为例，发现内部：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC15%E7%AB%A0Junit%E6%B3%A8%E8%A7%A3_%E6%9E%9A%E4%B8%BE/258a1b996f98d74fa67f5511b0957b01.png" class="">


<p>这value是属性还是方法？</p>
<p>答案：看上去是无参数方法，实际上理解为一个成员变量，一个属性</p>
<p>无参数方法名字–》成员变量的名字</p>
<p>无参数方法的返回值–》成员变量的类型</p>
<p>这个参数叫 配置参数</p>
<p>无参数方法的类型：基本数据类型（八种），String，枚举，注解类型，还可以是以上类型对应的数组。</p>
<p>PS：注意：如果只有一个成员变量的话，名字尽量叫value。</p>
<p>【4】使用注解：</p>
<p>（1）使用注解的话，如果你定义了配置参数，就必须给配置参数进行赋值操作：</p>
<pre><code class="java">@MyAnnotation(value=&#123;&quot;abc&quot;,&quot;def&quot;,&quot;hij&quot;&#125;)
public class Person &#123;
 &#125;
</code></pre>
<p>（2）如果只有一个参数，并且这个参数的名字为value的话，那么value&#x3D;可以省略不写。</p>
<pre><code class="java">@MyAnnotation(&#123;&quot;abc&quot;,&quot;def&quot;,&quot;hij&quot;&#125;)
public class Person &#123;
 &#125;
</code></pre>
<p>（3）如果你给配置参数设置默认的值了，那么使用的时候可以无需传值：</p>
<ol>
<li>public @interface MyAnnotation2 {</li>
<li>String value() default “abc”;</li>
<li>}</li>
</ol>
<p>使用：</p>
<pre><code class="java">@MyAnnotation2
@MyAnnotation(&#123;&quot;abc&quot;,&quot;def&quot;,&quot;hij&quot;&#125;)
public class Person &#123;
    
 &#125;
</code></pre>
<p>（4）一个注解的内部是可以不定义配置参数的：</p>
<pre><code class="java">  public @interface MyAnnotation3 &#123;
  &#125;
</code></pre>
<p>内部没有定义配置参数的注解–》可以叫做标记</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC15%E7%AB%A0Junit%E6%B3%A8%E8%A7%A3_%E6%9E%9A%E4%B8%BE/5a3c24803c3f8ed92d3272ac78b52ce7.png" class="">


<p>内部定义配置参数的注解–》元数据</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC15%E7%AB%A0Junit%E6%B3%A8%E8%A7%A3_%E6%9E%9A%E4%B8%BE/0f6376fb4928988abc36de912ae6e857.png" class="">


<p>【5】注解的使用：</p>
<p>现在只学习注解的大致技能点，具体怎么应用 后面慢慢学习。</p>
<h2 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h2><p>元注解是用于修饰其它注解的注解。</p>
<p>举例：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC15%E7%AB%A0Junit%E6%B3%A8%E8%A7%A3_%E6%9E%9A%E4%B8%BE/34f66e3c7b9665d0d116172ef2d023e3.png" class="">


<p>JDK5.0提供了四种元注解：Retention, Target, Documented, Inherited</p>
<h3 id="Retention"><a href="#Retention" class="headerlink" title="Retention"></a>Retention</h3><p>@Retention:用于修饰注解，用于指定修饰的那个注解的生命周期，@Rentention包含一个RetentionPolicy枚举类型的成员变量,使用@Rentention时必须为该value成员变量指定值:</p>
<p>➢RetentionPolicy.SOURCE:在源文件中有效(即源文件保留),编译器直接丢弃这种策略的注释，在.class文件中不会保留注解信息</p>
<p>案例：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC15%E7%AB%A0Junit%E6%B3%A8%E8%A7%A3_%E6%9E%9A%E4%B8%BE/d3e2e82ebd228e73e7c31cc574e94c62.png" class="">


<img data-src="/2022/10/07/Java/%E7%AC%AC15%E7%AB%A0Junit%E6%B3%A8%E8%A7%A3_%E6%9E%9A%E4%B8%BE/4d2c3bc743b41c72b97faabb8603e63d.png" class="">


<p>反编译查看字节码文件：发现字节码文件中没有MyAnnotation这个注解：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC15%E7%AB%A0Junit%E6%B3%A8%E8%A7%A3_%E6%9E%9A%E4%B8%BE/ef82a6553de8c7049479945ca1d4435e.png" class="">


<p>➢RetentionPolicy.CLASS:在class文件中有效(即class保留)，保留在.class文件中，但是当运行Java程序时，他就不会继续加载了，不会保留在内存中，JVM不会保留注解。如果注解没有加Retention元注解，那么相当于默认的注解就是这种状态。</p>
<p>案例：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC15%E7%AB%A0Junit%E6%B3%A8%E8%A7%A3_%E6%9E%9A%E4%B8%BE/f23af522879c92eb18b5b6a6de68eb92.png" class="">


<img data-src="/2022/10/07/Java/%E7%AC%AC15%E7%AB%A0Junit%E6%B3%A8%E8%A7%A3_%E6%9E%9A%E4%B8%BE/b6d188929cf9db1376241c79683d1e86.png" class="">


<p>反编译看字节码文件，字节码文件中带有MyAnnotation注解：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC15%E7%AB%A0Junit%E6%B3%A8%E8%A7%A3_%E6%9E%9A%E4%B8%BE/ce86fb17bc2a2f453556cdbac9a35524.png" class="">


<p>➢RetentionPolicy.RUNTIME:在运行时有效(即运行时保留),当运行 Java程序时，JVM会保留注释，加载在内存中了，那么程序可以通过反射获取该注释。</p>
<h3 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h3><p>用于修饰注解的注解，用于指定被修饰的注解能用于修饰哪些程序元素。@Target也包含一个名为value的成员变量。</p>
<p>案例：</p>
<pre><code class="java">@Target(&#123;TYPE,CONSTRUCTOR,METHOD&#125;)
public @interface MyAnnotation4 &#123;
&#125;
</code></pre>
<p>使用：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC15%E7%AB%A0Junit%E6%B3%A8%E8%A7%A3_%E6%9E%9A%E4%B8%BE/f7fc8775a65c517683db05e1714142d4.png" class="">


<h3 id="Documented（很少）"><a href="#Documented（很少）" class="headerlink" title="Documented（很少）"></a>Documented（很少）</h3><p>用于指定被该元注解修饰的注解类将被javadoc工具提取成文档。默认情况下，javadoc是 不包括注解的，但是加上了这个注解生成的文档中就会带着注解了</p>
<p>案例：</p>
<p>如果：Documented注解修饰了Deprecated注解，</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC15%E7%AB%A0Junit%E6%B3%A8%E8%A7%A3_%E6%9E%9A%E4%B8%BE/2c2e47e5817fc9dce848588c74c99fca.png" class="">


<p>那么Deprecated注解就会在javadoc提取的时候，提取到API中：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC15%E7%AB%A0Junit%E6%B3%A8%E8%A7%A3_%E6%9E%9A%E4%B8%BE/eaffd4880e967c3b2924741f4ce2213c.png" class="">


<h3 id="Inherited（极少）"><a href="#Inherited（极少）" class="headerlink" title="Inherited（极少）"></a>Inherited（极少）</h3><p>被它修饰的Annotation将具有继承性。如果某个类使用了被</p>
<p>@Inherited修饰的Annotation,则其子类将自动具有该注解。</p>
<p>案例：</p>
<p>注解：如果MyAnno注解使用了@Inherited之后，就具备了继承性，那么相当于子类Student也使用了这个MyAnno</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC15%E7%AB%A0Junit%E6%B3%A8%E8%A7%A3_%E6%9E%9A%E4%B8%BE/30e71681fd1e8664b949a536691dc82f.png" class="">


<p>父类：  </p>
<img data-src="/2022/10/07/Java/%E7%AC%AC15%E7%AB%A0Junit%E6%B3%A8%E8%A7%A3_%E6%9E%9A%E4%B8%BE/2a385f34e462174022fc8abb73112b4f.png" class="">


<p>子类：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC15%E7%AB%A0Junit%E6%B3%A8%E8%A7%A3_%E6%9E%9A%E4%B8%BE/0f863775e4fc46e421d2a5189572c538.png" class="">


<h1 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h1><h2 id="引入-2"><a href="#引入-2" class="headerlink" title="引入"></a>引入</h2><p>【1】数学：枚举法：</p>
<p>1&lt;x&lt;4</p>
<p>2&lt;y&lt;5</p>
<p>求x+y&#x3D;6</p>
<p>枚举法：一枚一枚的列举出来。前提：有限，确定</p>
<p>【2】在java中，类的对象是有限个，确定的。这个类我们可以定义为枚举类。</p>
<p>举例：</p>
<p>星期：一二三四五六日</p>
<p>性别：男女</p>
<p>季节：春夏秋冬</p>
<p>【3】自定义枚举类：（JDK1.5之前自定义枚举类）</p>
<ol start="2">
<li></li>
<li>&#x2F;**</li>
<li>* @author : msb-zhaoss</li>
<li>* 定义枚举类：季节</li>
<li>*&#x2F;</li>
</ol>
<pre><code class="java">public class Season &#123;
    //属性：
    private final String seasonName ;//季节名字
    private final String seasonDesc ;//季节描述
    //利用构造器对属性进行赋值操作：
    //构造器私有化，外界不能调用这个构造器，只能Season内部自己调用
    private Season(String seasonName,String seasonDesc)&#123;
        this.seasonName = seasonName;
        this.seasonDesc = seasonDesc;
    &#125;

    //提供枚举类的有限的 确定的对象：
    public static final Season SPRING = new Season(&quot;春天&quot;,&quot;春暖花开&quot;);
    public static final Season SUMMER = new Season(&quot;夏天&quot;,&quot;烈日炎炎&quot;);
    public static final Season AUTUMN = new Season(&quot;秋天&quot;,&quot;硕果累累&quot;);
    public static final Season WINTER = new Season(&quot;冬天&quot;,&quot;冰天雪地&quot;);

    //额外因素：

    public String getSeasonName() &#123;
        return seasonName;
    &#125;

    public String getSeasonDesc() &#123;
        return seasonDesc;
    &#125;

    //toString();

    @Override
    public String toString() &#123;
        return &quot;Season&#123;&quot; +
            &quot;seasonName=&#39;&quot; + seasonName + &#39;\\&#39;&#39; +
            &quot;, seasonDesc=&#39;&quot; + seasonDesc + &#39;\\&#39;&#39; +
            &#39;&#125;&#39;;
    &#125;
&#125;

</code></pre>
<p>测试类：</p>
<pre><code class="java">public class TestSeason &#123;
    //这是一个main方法，是程序的入口：
    public static void main(String[] args) &#123;
        Season summer = Season.SUMMER;
        System.out.println(summer/\*.toString()\*/);
        System.out.println(summer.getSeasonName());
    &#125;
&#125;
</code></pre>
<h2 id="JDK1-5之后使用enum关键字来创建枚举类"><a href="#JDK1-5之后使用enum关键字来创建枚举类" class="headerlink" title="JDK1_5之后使用enum关键字来创建枚举类"></a>JDK1_5之后使用enum关键字来创建枚举类</h2><p>JDK1.5以后使用enum关键字创建枚举类：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC15%E7%AB%A0Junit%E6%B3%A8%E8%A7%A3_%E6%9E%9A%E4%B8%BE/657e63e35654f2386483ef6f014c3be2.png" class="">


<p>变为下面的枚举类：</p>
<pre><code class="java">public enum Season &#123;
    //提供枚举类的有限的 确定的对象：---\&gt;enum枚举类要求对象（常量）必须放在最开始位置
    //多个对象之间用，进行连接，最后一个对象后面用;结束
    SPRING(&quot;春天&quot;,&quot;春暖花开&quot;),
    SUMMER(&quot;夏天&quot;,&quot;烈日炎炎&quot;),
    AUTUMN(&quot;秋天&quot;,&quot;硕果累累&quot;),
    WINTER(&quot;冬天&quot;,&quot;冰天雪地&quot;);
    //属性：
    private final String seasonName ;//季节名字
    private final String seasonDesc ;//季节描述
    //利用构造器对属性进行赋值操作：
    //构造器私有化，外界不能调用这个构造器，只能Season内部自己调用
    private Season(String seasonName, String seasonDesc)&#123;
        this.seasonName = seasonName;
        this.seasonDesc = seasonDesc;
    &#125;



    //额外因素：

    public String getSeasonName() &#123;
        return seasonName;
    &#125;

    public String getSeasonDesc() &#123;
        return seasonDesc;
    &#125;

    //toString();

    @Override
    public String toString() &#123;
        return &quot;Season&#123;&quot; +
            &quot;seasonName=&#39;&quot; + seasonName + &#39;\\&#39;&#39; +
            &quot;, seasonDesc=&#39;&quot; + seasonDesc + &#39;\\&#39;&#39; +
            &#39;&#125;&#39;;
    &#125;
&#125;
</code></pre>
<p>使用枚举类：</p>
<pre><code class="java">public class TestSeason &#123;
    //这是一个main方法，是程序的入口：
    public static void main(String[] args) &#123;
        Season winter = Season.WINTER;
        System.out.println(winter);
        //enum关键字对应的枚举类的上层父类是 ：java.lang.Enum
        //但是我们自定义的枚举类的上层父类：Object
        System.out.println(Season.class.getSuperclass().getName());//java.lang.Enum
    &#125;
&#125;

</code></pre>
<p>在源码中经常看到别人定义的枚举类形态：</p>
<pre><code class="java">public enum Season &#123;
    SPRING,
    SUMMER,
    AUTUMN,
    WINTER;
&#125;
</code></pre>
<p>为什么这么简单：因为这个枚举类底层没有属性，属性，构造器，toString，get方法都删掉不写了，然后案例来说应该</p>
<p>写为：SPRING() 现在连（）可以省略 就变成 SPRING</p>
<p>看到的形态就剩：常量名（对象名）</p>
<p>案例：Thread中的枚举类：State</p>
<pre><code class="java">
public enum State &#123;
    /\*\*
        \* Thread state for a thread which has not yet started.
            \*/
            NEW,

    /\*\*
        \* Thread state for a runnable thread. A thread in the runnable
            \* state is executing in the Java virtual machine but it may
            \* be waiting for other resources from the operating system
                \* such as processor.
                \*/
                RUNNABLE,

    /\*\*
        \* Thread state for a thread blocked waiting for a monitor lock.
            \* A thread in the blocked state is waiting for a monitor lock
                \* to enter a synchronized block/method or
                \* reenter a synchronized block/method after calling
                \* &#123;@link Object\#wait() Object.wait&#125;.
                \*/
                BLOCKED,

    /\*\*
        \* Thread state for a waiting thread.
            \* A thread is in the waiting state due to calling one of the
            \* following methods:
    \* \&lt;ul\&gt;
        \* \&lt;li\&gt;&#123;@link Object\#wait() Object.wait&#125; with no timeout\&lt;/li\&gt;
        \* \&lt;li\&gt;&#123;@link \#join() Thread.join&#125; with no timeout\&lt;/li\&gt;
        \* \&lt;li\&gt;&#123;@link LockSupport\#park() LockSupport.park&#125;\&lt;/li\&gt;
        \* \&lt;/ul\&gt;
        \*
        \* \&lt;p\&gt;A thread in the waiting state is waiting for another thread to
            \* perform a particular action.
            \*
            \* For example, a thread that has called \&lt;tt\&gt;Object.wait()\&lt;/tt\&gt;
            \* on an object is waiting for another thread to call
                \* \&lt;tt\&gt;Object.notify()\&lt;/tt\&gt; or \&lt;tt\&gt;Object.notifyAll()\&lt;/tt\&gt; on
                \* that object. A thread that has called \&lt;tt\&gt;Thread.join()\&lt;/tt\&gt;
                \* is waiting for a specified thread to terminate.
                    \*/
                    WAITING,

    /\*\*
        \* Thread state for a waiting thread with a specified waiting time.
            \* A thread is in the timed waiting state due to calling one of
            \* the following methods with a specified positive waiting time:
    \* \&lt;ul\&gt;
        \* \&lt;li\&gt;&#123;@link \#sleep Thread.sleep&#125;\&lt;/li\&gt;
        \* \&lt;li\&gt;&#123;@link Object\#wait(long) Object.wait&#125; with timeout\&lt;/li\&gt;
        \* \&lt;li\&gt;&#123;@link \#join(long) Thread.join&#125; with timeout\&lt;/li\&gt;
        \* \&lt;li\&gt;&#123;@link LockSupport\#parkNanos LockSupport.parkNanos&#125;\&lt;/li\&gt;
        \* \&lt;li\&gt;&#123;@link LockSupport\#parkUntil LockSupport.parkUntil&#125;\&lt;/li\&gt;
        \* \&lt;/ul\&gt;
        \*/
        TIMED_WAITING,

    /\*\*
        \* Thread state for a terminated thread.
            \* The thread has completed execution.
            \*/
            TERMINATED;
&#125;
</code></pre>
<h2 id="Enum类的常用方法"><a href="#Enum类的常用方法" class="headerlink" title="Enum类的常用方法"></a>Enum类的常用方法</h2><pre><code class="java">public class TestSeason &#123;
    //这是一个main方法，是程序的入口：
    public static void main(String[] args) &#123;
        //用enum关键字创建的Season枚举类上面的父类是：java.lang.Enum,常用方法子类Season可以直接拿过来使用：
        //toString();---\&gt;获取对象的名字
        Season autumn = Season.AUTUMN;
        System.out.println(autumn/\*.toString()\*/);//AUTUMN

        System.out.println(&quot;--------------------&quot;);
        //values:返回枚举类对象的数组
        Season[] values = Season.values();
        for(Season s:values)&#123;
            System.out.println(s/\*.toString()\*/);
        &#125;

        System.out.println(&quot;--------------------&quot;);
        //valueOf：通过对象名字获取这个枚举对象
        //注意：对象的名字必须传正确，否则抛出异常
        Season autumn1 = Season.valueOf(&quot;AUTUMN&quot;);
        System.out.println(autumn1);
    &#125;
&#125;

</code></pre>
<h2 id="枚举类实现接口"><a href="#枚举类实现接口" class="headerlink" title="枚举类实现接口"></a>枚举类实现接口</h2><p>定义一个接口：</p>
<pre><code class="java">public interface TestInterface &#123;
    void show();
&#125;
</code></pre>
<p>枚举类实现接口，并且重写show方法：</p>
<pre><code class="java">public enum Season implements TestInterface &#123;
    SPRING,
    SUMMER,
    AUTUMN,
    WINTER;

    @Override
    public void show() &#123;
        System.out.println(&quot;这是Season....&quot;);
    &#125;
&#125;
</code></pre>
<p>测试类：</p>
<pre><code class="java">public class Test &#123;
    //这是一个main方法，是程序的入口：
    public static void main(String[] args) &#123;
        Season autumn = Season.AUTUMN;
        autumn.show();
        Season summer = Season.SUMMER;
        summer.show();
    &#125;
&#125;
</code></pre>
<p>上面发现所有的枚举对象，调用这个show方法的时候走的都是同一个方法，结果都一样：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC15%E7%AB%A0Junit%E6%B3%A8%E8%A7%A3_%E6%9E%9A%E4%B8%BE/1f3767921901f0bdaab9e90f542d92ee.png" class="">


<p>但是现在我想要：不同的对象 调用的show方法也不同：</p>
<pre><code class="java">public enum Season implements TestInterface &#123;
    SPRING&#123;
        @Override
        public void show() &#123;
            System.out.println(&quot;这是春天。。。&quot;);
        &#125;
    &#125;,
    SUMMER&#123;
        @Override
        public void show() &#123;
            System.out.println(&quot;这是夏天。。&quot;);
        &#125;
    &#125;,
    AUTUMN&#123;
        @Override
        public void show() &#123;
            System.out.println(&quot;这是秋天&quot;);
        &#125;
    &#125;,
    WINTER&#123;
        @Override
        public void show() &#123;
            System.out.println(&quot;这是冬天&quot;);
        &#125;
    &#125;;

    /\*@Override
        public void show() &#123;
        System.out.println(&quot;这是Season....&quot;);
    &#125;\*/
&#125;
</code></pre>
<pre><code class="java">
public class Test &#123;
    //这是一个main方法，是程序的入口：
    public static void main(String[] args) &#123;
        Season autumn = Season.AUTUMN;
        autumn.show();
        Season summer = Season.SUMMER;
        summer.show();
    &#125;
&#125;
</code></pre>
<img data-src="/2022/10/07/Java/%E7%AC%AC15%E7%AB%A0Junit%E6%B3%A8%E8%A7%A3_%E6%9E%9A%E4%B8%BE/5739ebe7587a21e7d7144b96ec7a5833.png" class="">


<h2 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h2><pre><code class="java">public class Person &#123;
    //属性：
    private int age;
    private String name;
    private Gender sex;

    public int getAge() &#123;
        return age;
    &#125;

    public void setAge(int age) &#123;
        this.age = age;
    &#125;

    public String getName() &#123;
        return name;
    &#125;

    public void setName(String name) &#123;
        this.name = name;
    &#125;

    public Gender getSex() &#123;
        return sex;
    &#125;

    public void setSex(Gender sex) &#123;
        this.sex = sex;
    &#125;

    @Override
    public String toString() &#123;
        return &quot;Person&#123;&quot; +
            &quot;age=&quot; + age +
            &quot;, name=&#39;&quot; + name + &#39;\\&#39;&#39; +
            &quot;, sex=&#39;&quot; + sex + &#39;\\&#39;&#39; +
            &#39;&#125;&#39;;
    &#125;
&#125;

public enum Gender &#123;
    男,
    女;
&#125;

public class Test &#123;
    //这是一个main方法，是程序的入口：
    public static void main(String[] args) &#123;
        Person p = new Person();
        p.setAge(19);
        p.setName(&quot;lili&quot;);
        p.setSex(Gender.男);//传入枚举类Gender的对象：--\&gt;在入口处对参数进行了限制
        System.out.println(p);
    &#125;
&#125;

</code></pre>
<p>还可以通过枚举结合switch处理：</p>
<pre><code class="java">public class Test02 &#123;
    //这是一个main方法，是程序的入口：
    public static void main(String[] args) &#123;
        Gender sex = Gender.男;
        //switch后面的（）中可以传入枚举类型
        //switch后面的（）:int,short,byte,char,String ,枚举
        switch (sex)&#123;
            case 女:
                System.out.println(&quot;是个女孩&quot;);
                break;
            case 男:
                System.out.println(&quot;是个男孩&quot;);
                break;
        &#125;
    &#125;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>JavaSE</category>
        <category>Junit注解_枚举</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title>第16章_反射</title>
    <url>/2022/10/07/Java/%E7%AC%AC16%E7%AB%A0_%E5%8F%8D%E5%B0%84/</url>
    <content><![CDATA[<h1 id="通过案例体会反射的好处"><a href="#通过案例体会反射的好处" class="headerlink" title="通过案例体会反射的好处"></a>通过案例体会反射的好处</h1><p>案例：美团外卖 —&gt;付款 —》要么用微信支付 要么用支付宝支付</p>
<pre><code class="java">//接口的制定方：美团外卖
public interface Mtwm &#123;
    //在线支付功能：
    void payOnline();
&#125;

public class WeChat implements Mtwm&#123;
    @Override
    public void payOnline() &#123;
        //具体实现微信支付的功能：
        System.out.println(&quot;我已经点了外卖，正在使用微信支付&quot;);
    &#125;
&#125;
public class AliPay implements Mtwm &#123;
    @Override
    public void payOnline() &#123;
        //具体的支付宝支付：
        System.out.println(&quot;我已经点了外卖，我正在使用支付宝进行支付&quot;);
    &#125;
&#125;
public class BankCard implements Mtwm&#123;
    @Override
    public void payOnline() &#123;
        System.out.println(&quot;我已经定了外卖，我正在用招商银行信用卡支付&quot;);
    &#125;
&#125;
</code></pre>
<pre><code class="java"> public class Test &#123;
 public static void main(String[] args) &#123;
 //定义一个字符串，用来模拟前台的支付方式：
 String str = &quot;微信&quot;;
 if(&quot;微信&quot;.equals(str))&#123;//str.equals(&quot;微信&quot;)---？避免空指针异常
 //微信支付：
 //new WeChat().payOnline();
 pay(new WeChat());
 &#125;

 if(&quot;支付宝&quot;.equals(str))&#123;
 //支付宝支付：
 //new AliPay().payOnline();
 pay(new AliPay());
 &#125;

 if(&quot;招商银行&quot;.equals(str))&#123;
 pay(new BankCard());
 &#125;
 &#125;
 //微信支付
 public static void pay(WeChat wc)&#123;
 wc.payOnline();
 &#125;
 //支付宝支付
 public static void pay(AliPay ap)&#123;
 ap.payOnline();
 &#125;

 //招商银行支付
 public static void pay(BankCard bc)&#123;
 bc.payOnline();
 &#125;
 &#125;
</code></pre>
<p>为了提高代码的扩展性—》面向对象特性：多态：</p>
<pre><code class="java">public class Test &#123;
    public static void main(String[] args) &#123;
        //定义一个字符串，用来模拟前台的支付方式：
        String str = &quot;微信&quot;;
        if(&quot;微信&quot;.equals(str))&#123;//str.equals(&quot;微信&quot;)---？避免空指针异常
            //微信支付：
            pay(new WeChat());
        &#125;

        if(&quot;支付宝&quot;.equals(str))&#123;
            //支付宝支付：
            pay(new AliPay());
        &#125;

        if(&quot;招商银行&quot;.equals(str))&#123;
            pay(new BankCard());
        &#125;
    &#125;
    //方法形参是接口，具体传入的是接口的实现类的对象---》多态的一种形式
    public static void pay(Mtwm m)&#123;
        m.payOnline();
    &#125;
&#125;


</code></pre>
<p>多态确实可以提高代码的扩展性，但是：扩展性没有达到最好。</p>
<p>怎么没有达到最好：上面的分支，还是需要手动的删除或者添加。</p>
<p>解决办法：反射机制</p>
<p>利用反射实现上述功能：</p>
<pre><code class="java">public class Demo &#123;
    public static void main(String[] args) throws Exception &#123;
        //定义一个字符串，用来模拟前台的支付方式：
        String str = &quot;com.zhaoss.test01.AliPay&quot;; //字符串：实际上：就是微信类的全限定路径

        //下面的代码就是利用反射：
        Class cls = Class.forName(str);//cls--\&gt;Class类具体的对象--》AliPay字节码信息
        Object o = cls.newInstance();
        Method method = cls.getMethod(&quot;payOnline&quot;);
        method.invoke(o);
    &#125;
&#125;
</code></pre>
<h1 id="通过概念再体会反射"><a href="#通过概念再体会反射" class="headerlink" title="通过概念再体会反射"></a>通过概念再体会反射</h1><p>JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，</p>
<p>都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称为java语言的反射机制。</p>
<p>在编译后产生字节码文件的时候，类加载器子系统通过二进制字节流，负责从文件系统加载class文件。</p>
<p>在执行程序（java.exe）时候，将字节码文件读入JVM中—&gt;这个过程叫做类的加载。然后在内存中对应创建一个java.lang.Class对象–&gt;这个对象会被放入字节码信息中,这个Class对象,就对应加载那个字节码信息,这个对象将被作为程序访问方法区中的这个类的各种数据的外部接口。</p>
<p>所以：我们可以通过这个对象看到类的结构，这个对象就好像是一面镜子，透过镜子看到类的各种信息，我们形象的称之为反射</p>
<p>这种“看透”class的能力（the ability of the program to examine itself）被称为introspection（内省、内观、反省）。Reflection和introspection是常被并提的两个术语。</p>
<p>说明：在运行期间，如果我们要产生某个类的对象，Java虚拟机(JVM)会检查该类型的Class对象是否已被加载。</p>
<p>如果没有被加载，JVM会根据类的名称找到.class文件并加载它。一旦某个类型的Class对象已被加载到内存，就可以用它来产生该类型的所有对象。</p>
<p>补充:</p>
<p>动态语膏vs静态语言</p>
<p>1、动态语言</p>
<p>是一类在运行时可以改变其结构的语言:例如新的函数、对象、甚至代码可以</p>
<p>被引进，已有的函数可以被删除或是其他结构上的变化。通俗点说就是在运</p>
<p>行时代码可以根据某些条件改变自身结构。</p>
<p>主要动态语言: Object-C、 C#、JavaScript、 PHP、 Python、 Erlang 。</p>
<p>2、静态语言</p>
<p>与动态语言相对应的，运行时结构不可变的语言就是静态语言。如Java、C、</p>
<p>C++。</p>
<p>所以Java不是动态语言，但Java可以称之为“准动态语言”。即Java有一定的动</p>
<p>态性，我们可以利用反射机制、字节码操作获得类似动态语言的特性。</p>
<p>Java的动态性让编程的时候更加灵活!</p>
<p>Class类的理解</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC16%E7%AB%A0_%E5%8F%8D%E5%B0%84/6d8b0c266d2a65f30295f32185c3256c.png" class="">


<h1 id="提供丰富的类"><a href="#提供丰富的类" class="headerlink" title="提供丰富的类"></a>提供丰富的类</h1><pre><code class="java">//作为一个父类
public class Person &#123;
    //属性
    private int age;
    public String name;

    //方法
    private void eat()&#123;
        System.out.println(&quot;Person---eat&quot;);
    &#125;
    public void sleep()&#123;
        System.out.println(&quot;Person---sleep&quot;);
    &#125;
&#125;
</code></pre>
<pre><code class="java">//Student作为子类
public class Student extends Person &#123;
    //属性：
    private int sno;//学号
    double height;//身高
    protected double weight;//体重
    public double score;//成绩

    //方法：
    public String showInfo()&#123;
        return &quot;我是一名三好学生&quot;;
    &#125;
    private void work()&#123;
        System.out.println(&quot;我以后会找工作--》成为码农 程序员 程序猿 程序媛&quot;);
    &#125;

    //构造器
    public Student()&#123;
        System.out.println(&quot;空参构造器&quot;);
    &#125;
    private Student(int sno)&#123;
        this.sno = sno;
    &#125;
    Student(int sno,double weight)&#123;
        this.sno = sno;
        this.weight = weight;
    &#125;
&#125;
</code></pre>
<h1 id="获取字节码信息的四种形式"><a href="#获取字节码信息的四种形式" class="headerlink" title="获取字节码信息的四种形式"></a>获取字节码信息的四种形式</h1><pre><code class="java">
public class Test &#123;
    public static void main(String[] args) throws ClassNotFoundException &#123;
        //案例：以Person的字节码信息为案例
        //方式1：通过getClass()方法获取
        Person p = new Person();
        Class c1 = p.getClass();
        System.out.println(c1);

        //方式2：通过内置class属性：
        Class c2 = Person.class;
        System.out.println(c2);

        System.out.println(c1==c2);

        //注意：方式1和方式2 不常用

        //方式3：--》用的最多：调用Class类提供的静态方法forName
        Class c3 = Class.forName(&quot;com.zhaoss.test02.Person&quot;);
        //方式4：利用类的加载器(了解技能点)
        ClassLoader loader = Test.class.getClassLoader();
        Class c4 = loader.loadClass(&quot;com.zhaoss.test02.Person&quot;);
    &#125;
&#125;
</code></pre>
<h1 id="可以作为Class类的实例的种类"><a href="#可以作为Class类的实例的种类" class="headerlink" title="可以作为Class类的实例的种类"></a>可以作为Class类的实例的种类</h1><p>Class类的具体的实例：</p>
<p>（1）类：外部类，内部类</p>
<p>（2）接口</p>
<p>（3）注解</p>
<p>（4）数组</p>
<p>（5）基本数据类型</p>
<p>（6）void</p>
<p>验证：</p>
<pre><code class="java">

public class Demo &#123;
    public static void main(String[] args) &#123;
        /\*
            Class类的具体的实例：
            （1）类：外部类，内部类
            （2）接口
            （3）注解
            （4）数组
            （5）基本数据类型
            （6）void
            \*/
            Class c1 = Person.class;
        Class c2 = Comparable.class;
        Class c3 = Override.class;

        int[] arr1 = &#123;1,2,3&#125;;
        Class c4 = arr1.getClass();
        int[] arr2 = &#123;5,6,7&#125;;
        Class c5 = arr2.getClass();
        System.out.println(c4==c5);//结果：true .同一个维度，同一个元素类型,得到的字节码就是同一个

        Class c6 = int.class;
        Class c7 = void.class;
    &#125;
&#125;
</code></pre>
<h1 id="获取运行时类的完整结构"><a href="#获取运行时类的完整结构" class="headerlink" title="获取运行时类的完整结构"></a>获取运行时类的完整结构</h1><h2 id="补充完善上面提供的丰富的类"><a href="#补充完善上面提供的丰富的类" class="headerlink" title="补充完善上面提供的丰富的类"></a>补充完善上面提供的丰富的类</h2><ol>
<li>&#x2F;&#x2F;作为一个父类</li>
</ol>
<pre><code class="java">public class Person implements Serializable &#123;
    //属性
    private int age;
    public String name;

    //方法
    private void eat()&#123;
        System.out.println(&quot;Person---eat&quot;);
    &#125;
    public void sleep()&#123;
        System.out.println(&quot;Person---sleep&quot;);
    &#125;
&#125;
</code></pre>
<pre><code class="java">//Student作为子类
@MyAnnotation(value=&quot;hello&quot;)
public class Student extends Person implements MyInterface&#123;
    //属性：
    private int sno;//学号
    double height;//身高
    protected double weight;//体重
    public double score;//成绩

    //方法：
    @MyAnnotation(value=&quot;himethod&quot;)
    public String showInfo()&#123;
        return &quot;我是一名三好学生&quot;;
    &#125;
    public String showInfo(int a,int b)&#123;
        return &quot;重载方法====我是一名三好学生&quot;;
    &#125;
    private void work()&#123;
        System.out.println(&quot;我以后会找工作--》成为码农 程序员 程序猿 程序媛&quot;);
    &#125;
    void happy()&#123;
        System.out.println(&quot;做人最重要的就是开心每一天&quot;);
    &#125;
    protected int getSno()&#123;
        return sno;
    &#125;

    //构造器
    public Student()&#123;
        System.out.println(&quot;空参构造器&quot;);
    &#125;
    private Student(int sno)&#123;
        this.sno = sno;
    &#125;
    Student(int sno,double weight)&#123;
        this.sno = sno;
        this.weight = weight;
    &#125;
    protected Student(int sno,double height,double weight)&#123;
        this.sno = sno;
    &#125;

    @Override
    @MyAnnotation(value=&quot;hellomyMethod&quot;)
    public void myMethod() &#123;
        System.out.println(&quot;我重写了myMethod方法。。&quot;);
    &#125;

    @Override
    public String toString() &#123;
        return &quot;Student&#123;&quot; +
            &quot;sno=&quot; + sno +
            &quot;, height=&quot; + height +
            &quot;, weight=&quot; + weight +
            &quot;, score=&quot; + score +
            &#39;&#125;&#39;;
    &#125;
&#125;
</code></pre>
<pre><code class="java">/\*
    @Target:定义当前注解能够修饰程序中的哪些元素
        @Retention:定义注解的声明周期
            \*/
@Target(&#123;TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE&#125;)
            @Retention(RetentionPolicy.RUNTIME)
            public @interface MyAnnotation &#123;
            String value();//属性
        &#125;
</code></pre>
<pre><code class="java"> public interface MyInterface &#123;//自定义的接口
 //随便定义一个抽象方法：
 void myMethod();
 &#125;
</code></pre>
<h2 id="获取构造器和创建对象"><a href="#获取构造器和创建对象" class="headerlink" title="获取构造器和创建对象"></a>获取构造器和创建对象</h2><pre><code class="java">public class Test01 &#123;
    public static void main(String[] args) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException &#123;
        //获取字节码信息：
        Class cls = Student.class;

        //通过字节码信息可以获取构造器：
        //getConstructors只能获取当前运行时类的被public修饰的构造器
        Constructor[] c1 = cls.getConstructors();
        for(Constructor c:c1)&#123;
            System.out.println(c);
        &#125;

        System.out.println(&quot;-------------------&quot;);
        //getDeclaredConstructors:获取运行时类的全部修饰符的构造器
        Constructor[] c2 = cls.getDeclaredConstructors();
        for(Constructor c:c2)&#123;
            System.out.println(c);
        &#125;
        System.out.println(&quot;-------------------&quot;);
        //获取指定的构造器：
        //得到空构造器
        Constructor con1 = cls.getConstructor();
        System.out.println(con1);

        //得到两个参数的有参构造器：
        Constructor con2 = cls.getConstructor(double.class, double.class);
        System.out.println(con2);

        //得到一个参数的有参构造器：并且是private修饰的
        Constructor con3 = cls.getDeclaredConstructor(int.class);
        System.out.println(con3);

        //有了构造器以后我就可以创建对象：
        Object o1 = con1.newInstance();
        System.out.println(o1);

        Object o2 = con2.newInstance(180.5, 170.6);
        System.out.println(o2);
    &#125;
&#125;
</code></pre>
<h2 id="获取属性和对属性进行赋值"><a href="#获取属性和对属性进行赋值" class="headerlink" title="获取属性和对属性进行赋值"></a>获取属性和对属性进行赋值</h2><pre><code class="java">public class Test02 &#123;
    public static void main(String[] args) throws NoSuchFieldException, IllegalAccessException, InstantiationException &#123;
        //获取运行时类的字节码信息：
        Class cls = Student.class;
        //获取属性：
        //getFields：获取运行时类和父类中被public修饰的属性
        Field[] fields = cls.getFields();
        for(Field f:fields)&#123;
            System.out.println(f);
        &#125;
        System.out.println(&quot;---------------------&quot;);
        //getDeclaredFields：获取运行时类中的所有属性
        Field[] declaredFields = cls.getDeclaredFields();
        for(Field f:declaredFields)&#123;
            System.out.println(f);
        &#125;
        System.out.println(&quot;---------------------&quot;);
        //获取指定的属性：
        Field score = cls.getField(&quot;score&quot;);
        System.out.println(score);
        Field sno = cls.getDeclaredField(&quot;sno&quot;);
        System.out.println(sno);

        System.out.println(&quot;---------------------&quot;);
        //属性的具体结构：
        //获取修饰符
        /\*int modifiers = sno.getModifiers();
        System.out.println(modifiers);
        System.out.println(Modifier.toString(modifiers));\*/
            System.out.println(Modifier.toString(sno.getModifiers()));
        //获取属性的数据类型：
        Class clazz = sno.getType();
        System.out.println(clazz.getName());

        //获取属性的名字：
        String name = sno.getName();
        System.out.println(name);
        System.out.println(&quot;-------------------------------&quot;);
        //给属性赋值：(给属性设置值，必须要有对象)
        Field sco = cls.getField(&quot;score&quot;);
        Object obj = cls.newInstance();
        sco.set(obj,98);//给obj这个对象的score属性设置具体的值，这个值为98
        System.out.println(obj);
    &#125;
&#125;
</code></pre>
<h2 id="获取方法和调用方法"><a href="#获取方法和调用方法" class="headerlink" title="获取方法和调用方法"></a>获取方法和调用方法</h2><pre><code class="java">public class Test03 &#123;
    public static void main(String[] args) throws NoSuchMethodException, IllegalAccessException, InstantiationException, InvocationTargetException &#123;
        //获取字节码信息：
        Class cls = Student.class;
        //获取方法：
        //getMethods:获取运行时类的方法还有所有父类中的方法（被public修饰）
        Method[] methods = cls.getMethods();
        for(Method m:methods)&#123;
            System.out.println(m);
        &#125;
        System.out.println(&quot;-----------------------&quot;);
        //getDeclaredMethods:获取运行时类中的所有方法：
        Method[] declaredMethods = cls.getDeclaredMethods();
        for(Method m:declaredMethods)&#123;
            System.out.println(m);
        &#125;
        System.out.println(&quot;-----------------------&quot;);
        //获取指定的方法：
        Method showInfo1 = cls.getMethod(&quot;showInfo&quot;);
        System.out.println(showInfo1);
        Method showInfo2 = cls.getMethod(&quot;showInfo&quot;, int.class, int.class);
        System.out.println(showInfo2);
        Method work = cls.getDeclaredMethod(&quot;work&quot;,int.class);
        System.out.println(work);
        System.out.println(&quot;-----------------------&quot;);
        //获取方法的具体结构：
        /\*
            @注解
            修饰符 返回值类型 方法名(参数列表) throws XXXXX&#123;&#125;
        \*/
            //名字：
            System.out.println(work.getName());
        //修饰符：
        int modifiers = work.getModifiers();
        System.out.println(Modifier.toString(modifiers));
        //返回值：
        System.out.println(work.getReturnType());
        //参数列表：
        Class[] parameterTypes = work.getParameterTypes();
        for(Class c:parameterTypes)&#123;
            System.out.println(c);
        &#125;

        //获取注解：
        Method myMethod = cls.getMethod(&quot;myMethod&quot;);
        Annotation[] annotations = myMethod.getAnnotations();
        for(Annotation a:annotations)&#123;
            System.out.println(a);
        &#125;

        //获取异常：
        Class[] exceptionTypes = myMethod.getExceptionTypes();
        for(Class c:exceptionTypes)&#123;
            System.out.println(c);
        &#125;


        //调用方法：
        Object o = cls.newInstance();
        myMethod.invoke(o);//调用o对象的mymethod方法

        System.out.println(showInfo2.invoke(o,12,45));;

    &#125;
&#125;
</code></pre>
<h2 id="获取类的接口，所在包，注解"><a href="#获取类的接口，所在包，注解" class="headerlink" title="获取类的接口，所在包，注解"></a>获取类的接口，所在包，注解</h2><pre><code class="java">

public class Test04 &#123;
    public static void main(String[] args) &#123;
        //获取字节码信息：
        Class cls = Student.class;
        //获取运行时类的接口：
        Class[] interfaces = cls.getInterfaces();
        for(Class c:interfaces)&#123;
            System.out.println(c);
        &#125;

        //得到父类的接口：
        //先得到父类的字节码信息：
        Class superclass = cls.getSuperclass();

        //得到接口：
        Class[] interfaces1 = superclass.getInterfaces();
        for(Class c:interfaces1)&#123;
            System.out.println(c);
        &#125;

        //获取运行时类所在的包：
        Package aPackage = cls.getPackage();
        System.out.println(aPackage);
        System.out.println(aPackage.getName());

        //获取运行类的注解：
        Annotation[] annotations = cls.getAnnotations();
        for(Annotation a:annotations)&#123;
            System.out.println(a);
        &#125;

    &#125;
&#125;
</code></pre>
<h2 id="关于反射的面试题"><a href="#关于反射的面试题" class="headerlink" title="关于反射的面试题"></a>关于反射的面试题</h2><p>【1】问题1：创建Person的对象，以后用new Person()创建,还是用反射创建？</p>
<p>【2】问题2：反射是否破坏了面向对象的封装性？</p>
]]></content>
      <categories>
        <category>JavaSE</category>
        <category>反射</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title>第1章初识JAVA</title>
    <url>/2022/10/07/Java/%E7%AC%AC1%E7%AB%A0%E5%88%9D%E8%AF%86JAVA/</url>
    <content><![CDATA[<h1 id="计算机语言的发展历史"><a href="#计算机语言的发展历史" class="headerlink" title="计算机语言的发展历史"></a>计算机语言的发展历史</h1><p>计算机编程语言的发展，是随着计算机本身硬件发展而发展的。硬件速度越快、体积越小、成本越低，应用到人类社会的场景就会越多，那么所需要的算法就会越复杂，也就要求计算机编程语言越高级。最初重达几十吨但一秒只能运算5000次的ENIAC(世界上第一台计算机)，只能做非常小的应用，比如：某些情况的弹道计算。现在任何一个人的手机运算能力都可以秒杀那个年代地球上所有计算机运算能力的总和。计算机编程语言的发展历经了从低级到高级发展。发展的核心思想就是“让人更容易编程”。越容易使用的语言，就有越多人使用；越多人使用，就有越多协作；越多协作，就可以创造越复杂的物体；计算机语言经历了三代：第一代是机器语言，第二代是汇编语言，第三代是高级语言。</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC1%E7%AB%A0%E5%88%9D%E8%AF%86JAVA/df224ffde641b2f50849b0d7ced03e3a.png" class="">


<p>【1】第一代：机器语言（相当于人类的原始阶段）</p>
<p>机器语言是机器指令的集合，机器指令展开来讲就是一台机器可以正确执行的命令。电子计算机的机器指令是一列二进制数字。计算机将之转变为一列高低电平，以使计算机的电子器件受到驱动，从而进行运算。上面所说的计算机，指的是可以执行机器指令，进行运算的机器。这是早期计算机的概念。早期的程序设计均使用机器语言。程序员们将用 0、1 数字编程的程序代码打在纸袋或卡片上，1打孔，0不打孔，再将程序通过纸带机或卡片机输入计算机，从而进行运算。</p>
<p>应用8086CPU完成运算s&#x3D;768+12288-1280，机器码如下:</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC1%E7%AB%A0%E5%88%9D%E8%AF%86JAVA/cabe563631cd20b0be237288f14a60fd.png" class="">


<p>假如将程序错写成以下的错误，请你找出错误:</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC1%E7%AB%A0%E5%88%9D%E8%AF%86JAVA/f3810a59f77dc88b809a08882fdbf11b.png" class="">


<p>书写和阅读机器码程序不是一件简单的工作，要记住所有抽象的二进制码。上面只是一个非常简单的小程序，就暴露出机器码的晦涩难懂和不易查错。写如此小的一个程序尚且如此，实际上一个有用的程序至少要有几十行的机器码。那么，情况将会怎么样呢？</p>
<p>在显示器输出“welcome to masm”，机器码如下：</p>
<p>看到这样的程序，你有什么感想？如果程序里有一个“1”被误写成为“0”，又如何去查找错误呢？</p>
<p>【2】第二代：汇编语言（相当于人类的手工业阶段）</p>
<p>为了编程的方便，以及解决更加复杂的问题。程序员开始改进机器语言，使用英文缩写的助记符来表示基本的计算机操作。这些助记符构成了汇编语言的基础。如下是一些常见的汇编语言助记符(单词)比如：mov，add，sub之类，这样人更容易使用了。识别几百、几千个单词，感觉要比几百几千个数字，美妙多了。汇编语言相当于人类的手工业社会，需要技术极其娴熟的工匠，但是开发效率也非常低。汇编语言虽然能编写高效率的程序，但是学习和使用都不是易事，并且很难调试。另一个复杂的问题，汇编语言以及早期的计算机语言（Basic、Fortran等）没有考虑结构化设计原则，而是使用goto语句来作为程序流程控制的主要方法。这样做的后果是：一大堆混乱的调转语句使得程序几乎不可能被读懂。对于那个时代的程序员，能读懂上个月自己写的代码都成为一种挑战。 汇编语言仍然应用于工业电子编程领域、软件的加密解密、计算机病毒分析等。</p>
<p>下面以Masm软件为例，编写一个简单的“hello world!”程序。</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC1%E7%AB%A0%E5%88%9D%E8%AF%86JAVA/25f4d0464a08bc680d211dc16e3fbdea.png" class="">


<p>【3】第三代：高级语言（相当于人类的工业阶段）</p>
<p>对于简单的任务，汇编语言可以胜任。但是随着计算机的发展，渗透到了工作生活的更多的方面，一些复杂的任务出现了，汇编语言就显得力不从心（应该说是程序员使用汇编语言解决复杂问题出现了瓶颈）。于是，出现了高级语言。像我们熟知的C、C++、Java等等都是高级语言。</p>
<p>高级语言允许程序员使用接近日常英语的指令来编写程序。例如下图所示:</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC1%E7%AB%A0%E5%88%9D%E8%AF%86JAVA/087eeecede8f63fad58301244c34660a.png" class="">


<h1 id="JAVA简史"><a href="#JAVA简史" class="headerlink" title="JAVA简史"></a>JAVA简史</h1><p><strong>【1】SUN公司</strong></p>
<p>美国SUN(Stanford University Network)公司在中国大陆的正式中文名为“太阳计算机系统（中国）有限公司” ，在台湾中文名为“升 阳电脑公司”。</p>
<p><strong>【2】Java为什么被发明</strong></p>
<p>Green项目。</p>
<p>应用环境：像电视盒这样的消费类电子产品</p>
<p>要求： 语言本身是中立的，也就是跨平台</p>
<p>1996年Java第一次发布就引起了人们的极大兴趣。关注Java的人士不仅限于计算机出版界， 还有诸如《纽约时报》《华盛顿邮报》《商业周刊》这样的主流媒体。Java 是第一种也是唯一种在National Public Radio上占用了10分钟时间来进行介绍的程序设计语言，并且还得到了$100000000的风险投资基金。这些基金全部用来支持用这种特别的计算机语言开发的产品。重温那些令人兴奋的日子是很有意思的。我们将简要地介绍一下Java语言的发展历史：</p>
<p>Java的历史要追溯到1991年，由Patrick Naughton 及其伙伴James Gosling (一个全能的计算机奇才)带领的Sun公同的工程师小组想要设计一种小型的计算机语言，主要用于像有线电视转换盒这类的消费设备。由于这些消费设备的处理能力和内存都很有限，所以语言必须非常小且能够生成非常紧凑的代码。另外，由于不同的厂商会选择不同的中央处理器(CPU)，因此这种语言的关键是不能与任何特定的体系结构捆绑在一起。这个项目被命名为”Green”。</p>
<p>所有就要求有这样的一种代码： 代码短小、紧凑且与平台无关。但是，Sun公司的人都有UNIX的应用背景。因此，所开发的语言以C++为基础。 是Gosling率先创造了这个语言，把这种语言称为“Oak”(这么起名的原因大概是因为他非常喜欢自己办公室外的橡树)。Sun 公司的人后来发现Oak是一种已有的计算机语言的名字，于是，将其改名为Java。</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC1%E7%AB%A0%E5%88%9D%E8%AF%86JAVA/b777a728d94309940fcfe8684bcc3f1b.png" class="">


<p><strong>【3】Java的发明人</strong></p>
<p>James Gosling </p>
<p><strong>【4】经历阶段</strong></p>
<p>1991年，James Gosling在SUN公司的工程师小组想要设计这样一种小型计算机语言。该语言主要用于像电视盒这样的消费类电子产品。另外，由于不同的厂商选择不同的CPU和操作系统，因此，要求该语言不能和特定的体系结构绑在一起，要求语言本身是中立的，也就是跨平台的。所以，将这个语言命名为“Green”，类似于绿色软件的意思。后来，改名为Oak，橡树的意思。改名后发现已经有一种语言叫这个名字了，再改名叫Java。Java语言发展到今天经历了一系列的过程：</p>
<p> 1991年，SUN公司的Green项目，Oak</p>
<p> 1995年，推出Java测试版</p>
<p> 1996年，JDK1.0</p>
<p> 1997年，JDK1.1</p>
<p> 1998年，JDK1.2，大大改进了早期版本缺陷，是一个革命性的版本，更名为Java2。</p>
<p> 2004年，J2SE 5.0 (1.5.0) Tiger老虎 成为Java语言发展史上的又一里程碑。为了表示该版本的重要性，J2SE1.5更名为Java SE 5.0</p>
<p> 2005年，Java的各种版本已经更名，以取消其中的数字”2”： J2ME更名为Java ME， J2SE更名为Java SE， J2EE更名为Java EE；</p>
<p> 2006年，J2SE 6.0 (1.6.0) Mustang野马</p>
<p> 2009年，甲骨文(oracle)收购SUN，交易高达价格74亿</p>
<p> 2011年，JavaSE7.0 Dolphin海豚</p>
<p> 2014年，JavaSE8.0</p>
<p>2017年，JAVA 9.0</p>
<p> 2018年3月，JAVA 10</p>
<p> 2018年9月，JAVA 11</p>
<p> 2019年3月，JAVA 12</p>
<p> 2019年9月，JAVA 13</p>
<p> 2020年3月，JAVA 14</p>
<p>注意：SUN公司已经被oracle公司收购，目前每半年更新一次java的版本。但是，企业中的主流仍然以7和8为主。对于初学者，应该以企业主流应用版本为核心进行学习，没有必须在此处追求最新版本。</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC1%E7%AB%A0%E5%88%9D%E8%AF%86JAVA/e1e4acc66aa1b1f2c1e46059b1421c38.png" class="">


<p><strong>【5】不同版本JDK说明</strong></p>
<p>JDK Version 1.1</p>
<p>于1997-02-19发行。</p>
<p>引入的新特性包括：</p>
<p>引入JDBC（Java Database Connectivity）；</p>
<p>支持内部类；</p>
<p>引入Java Bean；</p>
<p>引入RMI（Remote Method Invocation）；</p>
<p>引入反射（仅用于内省）。</p>
<p>J2SE Version 1.2</p>
<p>开发代号为Playground（操场），于1998-12-08发行。</p>
<p>引入的新特性包括：</p>
<p>引入集合（Collection）框架；</p>
<p>对字符串常量做内存映射；</p>
<p>引入JIT（Just In Time）编译器；</p>
<p>引入对打包的Java文件进行数字签名；</p>
<p>引入控制授权访问系统资源的策略工具；</p>
<p>引入JFC（Java Foundation Classes），包括Swing 1.0、拖放和Java 2D类库；</p>
<p>引入Java 插件；</p>
<p>在JDBC中引入可滚动结果集、BLOB、CLOB、批量更新和用户自定义类型；</p>
<p>在Applet中添加声音支持。</p>
<p>J2SE Version 1.3</p>
<p>开发代号为Kestrel（红隼），于2000-05-08发行。</p>
<p>引入的新特性包括：</p>
<p>引入Java Sound API；</p>
<p>jar文件索引；</p>
<p>对Java的各个方面都做了大量优化和增强。</p>
<p>J2SE Version 1.4</p>
<p>开发代号为Merlin（隼），于2004-02-06发行（首次在JCP下发行）。</p>
<p>引入的新特性包括:</p>
<p>XML处理；</p>
<p>Java打印服务；</p>
<p>引入Logging API；</p>
<p>引入Java Web Start；</p>
<p>引入JDBC 3.0 API；</p>
<p>引入断言；</p>
<p>引入Preferences API；</p>
<p>引入链式异常处理；</p>
<p>支持IPv6；</p>
<p>支持正则表达式；</p>
<p>引入Image I&#x2F;O slot machine API。</p>
<p>Java Version SE 5.0</p>
<p>开发代号为Tiger（老虎），于2004-09-30发行。</p>
<p>引入的新特性包括:</p>
<p>引入泛型；</p>
<p>增强循环，可以使用迭代方式；</p>
<p>自动装箱与自动拆箱；</p>
<p>类型安全的枚举；</p>
<p>可变参数；</p>
<p>静态引入；</p>
<p>元数据（注解）；</p>
<p>引入Instrumentation。</p>
<p>Java Version SE 6</p>
<p>开发代号为Mustang（野马），于2006-12-11发行。</p>
<p>引入的新特性包括：</p>
<p>支持脚本语言；</p>
<p>引入JDBC 4.0 API；</p>
<p>引入Java Compiler API；</p>
<p>可插拔注解；</p>
<p>增加对Native PKI(Public Key Infrastructure)、Java GSS(Generic Security Service)、Kerberos和LDAP(Lightweight Directory Access Protocol)的支持；</p>
<p>继承Web Services；</p>
<p>做了很多优化。</p>
<p>Java Version SE 7</p>
<p>开发代号是Dolphin（海豚），于2011-07-28发行。</p>
<p>引入的新特性包括：</p>
<p>switch语句块中允许以字符串作为分支条件；</p>
<p>在创建泛型对象时应用类型推断；</p>
<p>在一个语句块中捕获多种异常；</p>
<p>支持动态语言；</p>
<p>支持try-with-resources；</p>
<p>引入Java NIO.2开发包；</p>
<p>数值类型可以用2进制字符串表示，并且可以在字符串表示中添加下划线；</p>
<p>钻石型语法；</p>
<p>null值的自动处理。</p>
<p>Java Version SE 8</p>
<p>开发代号是Spider（蜘蛛），于2014-03-18发行。</p>
<p>支持 lambda支持；</p>
<p>增强日期与时间API的功能；</p>
<p>对垃圾回收的性能也进行了改进；</p>
<p>并且移除了permgen区。</p>
<p>Lambdas表达式与Functional接口</p>
<p>接口的默认与静态方法</p>
<p>方法引用</p>
<p>重复注解</p>
<p>更好的类型推测机制</p>
<p>扩展注解的支持</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC1%E7%AB%A0%E5%88%9D%E8%AF%86JAVA/cc266d289e8e3cb0c93696162df2eb73.png" class="">




<h1 id="JAVA体系结构"><a href="#JAVA体系结构" class="headerlink" title="JAVA体系结构"></a>JAVA体系结构</h1><p><strong>JavaSE（Java Standard Edition）：标准版，定位在个人计算机上的应用</strong></p>
<p>这个版本是Java平台的核心，它提供了非常丰富的API来开发一般个人计算机上的应用程序，包括用户界面接口AWT及Swing，网络功能与国际化、图像处理能力以及输入输出支持等。在上世纪90年代末互联网上大放异彩的Applet也属于这个版本。Applet后来为Flash取代，Flash即将被HTML5取代。</p>
<p><strong>JavaEE（Java Enterprise Edition）：企业版，定位在服务器端的应用</strong></p>
<p>JavaEE是JavaSE的扩展，增加了用于服务器开发的类库。如：JDBC是让程序员能直接在Java内使用的SQL的语法来访问数据库内的数据；Servlet能够延伸服务器的功能，通过请求-响应的模式来处理客户端的请求；JSP是一种可以将Java程序代码内嵌在网页内的技术；</p>
<p><strong>JavaME（Java Micro Edition）：微型版，定位在消费性电子产品的应用上</strong></p>
<p>JavaME是JavaSE的内伸，包含J2SE的一部分核心类，也有自己的扩展类,增加了适合微小装置的类库：javax.microedition.io.*等。该版本针对资源有限的电子消费产品的需求精简核心类库，并提供了模块化的架构让不同类型产品能够随时增加支持的能力。</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC1%E7%AB%A0%E5%88%9D%E8%AF%86JAVA/4eac508d70b7f6ffc64ed3fdcfc23406.png" class="">


<h1 id="JAVA的特性和优势"><a href="#JAVA的特性和优势" class="headerlink" title="JAVA的特性和优势"></a>JAVA的特性和优势</h1><p> <strong>跨平台&#x2F;可移植性</strong></p>
<p>这是Java的核心优势。Java在设计时就很注重移植和跨平台性。比如：Java的int永远都是32位。不像C++可能是16，32，可能是根据编译器厂商规定的变化。这样的话程序的移植就会非常麻烦。</p>
<p> <strong>安全性</strong></p>
<p>Java适合于网络&#x2F;分布式环境，为了达到这个目标，在安全性方面投入了很大的精力，使Java可以很容易构建防病毒，防篡改的系统。</p>
<p> <strong>面向对象</strong></p>
<p>面向对象是一种程序设计技术，非常适合大型软件的设计和开发。由于C++为了照顾大量C语言使用者而兼容了C，使得自身仅仅成为了带类的C语言，多少影响了其面向对象的彻底性！Java则是完全的面向对象语言。</p>
<p> <strong>简单性</strong></p>
<p>Java就是C++语法的简化版，我们也可以将Java称之为“C++-”。跟我念“C加加减”，指的就是将C++的一些内容去掉；比如：头文件，指针运算，结构，联合，操作符重载，虚基类等等。同时，由于语法基于C语言，因此学习起来完全不费力。</p>
<p> <strong>高性能</strong></p>
<p>Java最初发展阶段，总是被人诟病“性能低”；客观上，高级语言运行效率总是低于低级语言的，这个无法避免。Java语言本身发展中通过虚拟机的优化提升了几十倍运行效率。比如，通过JIT(JUST IN TIME)即时编译技术提高运行效率。 将一些“热点”字节码编译成本地机器码，并将结果缓存起来，在需要的时候重新调用。这样的话，使Java程序的执行效率大大提高，某些代码甚至接待C++的效率。</p>
<p>因此，Java低性能的短腿，已经被完全解决了。业界发展上，我们也看到很多C++应用转到Java开发，很多C++程序员转型为Java程序员。</p>
<p> <strong>分布式</strong></p>
<p>Java是为Internet的分布式环境设计的，因为它能够处理TCP&#x2F;IP协议。事实上，通过URL访问一个网络资源和访问本地文件是一样简单的。Java还支持远程方法调用(RMI,Remote Method Invocation)，使程序能够通过网络调用方法。</p>
<p> <strong>多线程</strong></p>
<p>多线程的使用可以带来更好的交互响应和实时行为。 Java多线程的简单性是Java成为主流服务器端开发语言的主要原因之一。</p>
<p> <strong>健壮性</strong></p>
<p>Java是一种健壮的语言，吸收了C&#x2F;C++ 语言的优点，但去掉了其影响程序健壮性的部分（如：指针、内存的申请与释放等）。Java程序不可能造成计算机崩溃。即使Java程序也可能有错误。如果出现某种出乎意料之事，程序也不会崩溃，而是把该异常抛出，再通过异常处理机制加以处理。</p>
<p>总结：一句话：java很好！</p>
<p>但是，并不是说学习了java，以后所有的东西都要用java开发了：某些领域其他语言有更出色的表现，比如，Objective C和后来的Swift在iOS设备上就有着无可取代的地位。浏览器中的处理几乎完全由JavaScript掌控。Windows程序通常都用C++或C#编写。Java在服务器端编程和跨平台客户端应用领域则很有优势。</p>
<p>只能说，不同的语言之间，平分秋色！</p>
<h1 id="核心机制"><a href="#核心机制" class="headerlink" title="核心机制"></a>核心机制</h1><h2 id="垃圾收集机制"><a href="#垃圾收集机制" class="headerlink" title="垃圾收集机制"></a>垃圾收集机制</h2><p>垃圾收集的目的在除不再使用的对象，当对象建立的时候垃圾收集期，就开始监控对象的动态情况，垃圾收集主要是对内存的释放。创建对象的时候申请一个空间</p>
<p>1.不再使用的内存空间应回收—》垃圾收集；</p>
<p>2.Java消除了程序员回收无用内存空间的职责；提供一种系统级线程跟踪存储空间的分配情况。在JVM的空闲时，检查并释放可被释放的存储器空间；相比c++,开发人员负责要自己收回无用内存。</p>
<p>3.垃圾收集在Java程序运行过程中自动进行，程序员无法精确控制和干预；</p>
<p>4.GC的自动回收，提高了内存空间的利用效率，也提高了编程人员的效率，很大程度上减少了因为没有释放空间而导致的内存泄露。</p>
<p>后续：</p>
<p>更高级：</p>
<p>1.垃圾收集器有几种</p>
<p>2.垃圾收集器底层原理剖析</p>
<p>3.垃圾收集器算法，优化</p>
<h2 id="跨平台原理"><a href="#跨平台原理" class="headerlink" title="跨平台原理"></a>跨平台原理</h2><p>JAVA跨平台原理的解释：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC1%E7%AB%A0%E5%88%9D%E8%AF%86JAVA/c9214cebbc48ea99d832cf9899a52a8d.png" class="">


<p>C语言的跨平台解释：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC1%E7%AB%A0%E5%88%9D%E8%AF%86JAVA/66913892f5b4f71e30d054375cccb7c9.png" class="">


<p>总结</p>
<p>JVM(Java Virtual Machine)就是一个虚拟的用于执行bytecode字节码的”虚拟计算机”。他也定义了指令集、寄存器集、结构栈、垃圾收集堆、内存区域。JVM负责将Java字节码解释运行，边解释边运行，这样，速度就会受到一定的影响。</p>
<p>不同的操作系统有不同的虚拟机。Java 虚拟机机制屏蔽了底层运行平台的差别，实现了“一次编译，随处运行”。 Java虚拟机是实现跨平台的核心机制。如图所示：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC1%E7%AB%A0%E5%88%9D%E8%AF%86JAVA/9f86e99d761144f8e5f1025c263d727d.png" class="">


<p>我们说的语言跨平台是编译后的文件跨平台，而不是源程序跨平台。</p>
<p>接下来我们再比较下两种方式的差异：第一，C语言是编译执行的，编译器与平台相关，编译生成的可执行文件与平台相关；第二，Java是解释执行的，编译为中间码的编译器与平台无关，编译生成的中间码也与平台无关（一次编译，到处运行），中间码再由解释器解释执行，解释器是与平台相关的，也就是不同的平台需要不同的解释器.</p>
<h1 id="常用DOS命令"><a href="#常用DOS命令" class="headerlink" title="常用DOS命令"></a>常用DOS命令</h1><p><strong>【1】DOS操作系统</strong></p>
<p>--Microsoft公司推出的操作系统。（在windows之前的操作系统）</p>
<p>--DOS是英文”Disk Operating System”的缩写,其中文含意是”磁盘操作系统”.</p>
<p>--DOS是单用户、单任务的操作系统.（只能执行一个任务）</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC1%E7%AB%A0%E5%88%9D%E8%AF%86JAVA/b5c2c79cb5570c6e91dabc56e2eb2d91.png" class="">


<p><strong>【2】DOS命令</strong></p>
<p>--在windows中，我们通过鼠标菜单等来操作系统，而在dos操作系统中，要通过dos命令来操作系统。</p>
<p>--是DOS操作系统的命令，是一种面向磁盘的操作命令，</p>
<p>--不区分大小写。</p>
<p><strong>【3】命令学习：</strong></p>
<p>windows给我们保留了类似dos系统的操作界面，可以直接操作磁盘！</p>
<p>dos 也是一种<span class="exturl" data-url="aHR0cHM6Ly93d3cuYmFpZHUuY29tL3M/d2Q9JUU2JTkzJThEJUU0JUJEJTlDJUU3JUIzJUJCJUU3JUJCJTlGJnRuPVNFX1BjWmhpZGFvbndoY19uZ3BhZ21qeiZyc3ZfZGw9Z2hfcGNfemhpZGFv">操作系统</span>，是在windows出现以前用的，后来windows出来后基本没人用了，但是当windows崩溃的时候，还是要的dos方式解决，它是一种纯命令方式，cmd其实就是在windows状态下进入dos方式。</p>
<p>控制命令台：win+r—&gt;cmd</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC1%E7%AB%A0%E5%88%9D%E8%AF%86JAVA/3b0f71b42623023480dda23aabe8aee4.png" class="">


<p><strong>【4】具体dos命令：</strong></p>
<p>（1）切换盘符： c: d: e: 大小写没有区分</p>
<p>（2）显示详细信息：dir</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC1%E7%AB%A0%E5%88%9D%E8%AF%86JAVA/1740909b2c155106334ed54298cadda0.png" class="">


<p>（3）改变当前目录：cd</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC1%E7%AB%A0%E5%88%9D%E8%AF%86JAVA/362c58e6a0f56fc1ace0bd31f0b741c2.png" class="">


<p>（4）</p>
<p>. 当前目录</p>
<p>.. 代表上一层目录</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC1%E7%AB%A0%E5%88%9D%E8%AF%86JAVA/5c967bca035c35add1b2104ca5649d38.png" class="">


<img data-src="/2022/10/07/Java/%E7%AC%AC1%E7%AB%A0%E5%88%9D%E8%AF%86JAVA/acefdb41934d2aab97dfa5e969eff0cb.png" class="">


<p>（5）清屏：cls</p>
<p>（6）切换历史命令：上下箭头</p>
<p>（7）补全命令： tab按键</p>
<p>（8）创建目录：md</p>
<p>删除目录：rd</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC1%E7%AB%A0%E5%88%9D%E8%AF%86JAVA/09422f27f704dcbf9dae20fd1c3f6084.png" class="">


<p>（9）复制文件命令：copy:</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC1%E7%AB%A0%E5%88%9D%E8%AF%86JAVA/0626fb05c5350a48f3194a4612623a9d.png" class="">


<p>（10）删除文件：del</p>
<p>del后面如果接的是文件夹&#x2F;目录：那么删除的就是这个文件夹下的文件，而不是文件夹</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC1%E7%AB%A0%E5%88%9D%E8%AF%86JAVA/d5a261b9a18b4a7c852e02a84d2143bc.png" class="">


<h1 id="JAVA环境准备–-gt-JDK"><a href="#JAVA环境准备–-gt-JDK" class="headerlink" title="JAVA环境准备–&gt;JDK"></a>JAVA环境准备–&gt;JDK</h1><h2 id="【1】下载JDK"><a href="#【1】下载JDK" class="headerlink" title="【1】下载JDK"></a><strong>【1】下载JDK</strong></h2><p><span class="exturl" data-url="aHR0cDovL3d3dy5vcmFjbGUuY29tL3RlY2huZXR3b3JrL2phdmEvamF2YXNlL2Rvd25sb2Fkcy9pbmRleC5odG1s">www.oracle.com/technetwork/java/javase/downloads/index.html</span></p>
<img data-src="/2022/10/07/Java/%E7%AC%AC1%E7%AB%A0%E5%88%9D%E8%AF%86JAVA/f5e306fff865e78e7cf4b3e0853d0a46.jpeg" class="">


<p><strong>【2】安装JDK</strong></p>
<img data-src="/2022/10/07/Java/%E7%AC%AC1%E7%AB%A0%E5%88%9D%E8%AF%86JAVA/76e9d157917264af13c9a2457ad03b0f.png" class="">


<img data-src="/2022/10/07/Java/%E7%AC%AC1%E7%AB%A0%E5%88%9D%E8%AF%86JAVA/7d3e5ef356992506ea31a463b166089a.png" class="">


<img data-src="/2022/10/07/Java/%E7%AC%AC1%E7%AB%A0%E5%88%9D%E8%AF%86JAVA/febc26a8ad5ca5d7a450a55ddd7c62d1.png" class="">


<h2 id="【3】卸载JDK"><a href="#【3】卸载JDK" class="headerlink" title="【3】卸载JDK"></a><strong>【3】卸载JDK</strong></h2><p>控制面板卸载即可</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC1%E7%AB%A0%E5%88%9D%E8%AF%86JAVA/f697774350b18624b56bed0f6254a517.png" class="">


<h2 id="【4】-验证JDK是否安装成功"><a href="#【4】-验证JDK是否安装成功" class="headerlink" title="【4】 验证JDK是否安装成功"></a><strong>【4】 验证JDK是否安装成功</strong></h2><p>（1）方式1：去安装目录下看一眼：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC1%E7%AB%A0%E5%88%9D%E8%AF%86JAVA/ac22249991f5294b4a9d223d5fcf5268.png" class="">


<p>（2）方式2：通过控制命令台查看：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC1%E7%AB%A0%E5%88%9D%E8%AF%86JAVA/39ae7561d4f131368eae9a9ccb2af553.png" class="">


<p>（3）方式3：通过控制面板查看：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC1%E7%AB%A0%E5%88%9D%E8%AF%86JAVA/261ebbcb3bc9cd8f43196c2baa4634c9.png" class="">


<p><strong>【5】JDK和JRE：</strong></p>
<p>JDK： Java Development kit —-&gt;编写Java程序的程序员使用的软件</p>
<p>JRE : Java Runtime Enviroment —-》运行Java程序的用户使用的软件</p>
<h2 id="安装notepad-，配置path环境变量"><a href="#安装notepad-，配置path环境变量" class="headerlink" title="安装notepad++，配置path环境变量"></a>安装notepad++，配置path环境变量</h2><p>【1】安装记事本：notepad</p>
<p>【2】安装：一直下一步</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC1%E7%AB%A0%E5%88%9D%E8%AF%86JAVA/abbe25e7ed8b045edea86256baa3f138.png" class="">


<p>【3】打开记事本进行设置：</p>
<p>设置–》首选项：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC1%E7%AB%A0%E5%88%9D%E8%AF%86JAVA/c8dca7e180ad4bc69dd81c0953b1873c.png" class="">


<p>设置–》语言格式设置：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC1%E7%AB%A0%E5%88%9D%E8%AF%86JAVA/0542de937b85e18e1ef81e7cadea58ca.png" class="">


<p>【4】打开notepad++:</p>
<p>（1）方式1：通过快捷方式：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC1%E7%AB%A0%E5%88%9D%E8%AF%86JAVA/be5c9d085c34c660cb272341c751ae2e.png" class="">


<p>（2）方式2：通过可执行文件：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC1%E7%AB%A0%E5%88%9D%E8%AF%86JAVA/9e8f1330d48c571f0f4d0f2f33c8b6a7.png" class="">


<p>（3）方式3：利用控制命令台：</p>
<p>win+r–&gt;cmd:</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC1%E7%AB%A0%E5%88%9D%E8%AF%86JAVA/701079b46451e26f184c5effbf08f14c.png" class="">


<p>(4)方式4：在任意的路径下去执行notepad++.exe这个命令：</p>
<p>但是发现报错：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC1%E7%AB%A0%E5%88%9D%E8%AF%86JAVA/98e40692478ec2772c3fd5aa37bbbe3a.png" class="">


<p>需要配置系统环境变量：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC1%E7%AB%A0%E5%88%9D%E8%AF%86JAVA/a8158c92fcc94f4cd7c16d98982d4f89.png" class="">


<p>找系统环境变量：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC1%E7%AB%A0%E5%88%9D%E8%AF%86JAVA/404df775e0f1df92adca292f150e2817.png" class="">


<img data-src="/2022/10/07/Java/%E7%AC%AC1%E7%AB%A0%E5%88%9D%E8%AF%86JAVA/ba3326c542f0f0e4073bb51b03ed8b04.png" class="">


<p>将notepad++.exe所在的路径配置到path环境变量中去：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC1%E7%AB%A0%E5%88%9D%E8%AF%86JAVA/a300969b9a9314375cb30c8d1e32608f.png" class="">


<p>这样我就可以在任意的路径下去执行这个命令：（注意：控制命令台需要重启）</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC1%E7%AB%A0%E5%88%9D%E8%AF%86JAVA/422abd1f5e358db4fb883d2e6bbf7ed9.png" class="">


<p>path环境变量作用：</p>
<p>将命令所在的路径配置到path中去，就相当于在计算机中“注册”了一样，以后找这个命令，会直接去你配置的路径下寻找。</p>
<p>达到了一个效果：在任意的路径下去执行某个命令—》path环境针对整个操作系统而言。</p>
<h1 id="第一段程序"><a href="#第一段程序" class="headerlink" title="第一段程序"></a>第一段程序</h1><p><strong>【1】用notepad编写代码：</strong></p>
<ol>
<li>public class HelloWorld{</li>
<li>public static void main(String[] args){</li>
<li>System.out.println(“hi 这是一段Java程序。。。”);</li>
<li>}</li>
<li>}</li>
</ol>
<p>记得保存 ctrl+s</p>
<p><strong>【2】进行编译：</strong></p>
<img data-src="/2022/10/07/Java/%E7%AC%AC1%E7%AB%A0%E5%88%9D%E8%AF%86JAVA/43511ae71bacbf69c11b6d85f9c2194a.png" class="">


<p>发现出错了，分析出错原因：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC1%E7%AB%A0%E5%88%9D%E8%AF%86JAVA/298f40fc2221174be201d03882646bf2.png" class="">


<p>解决办法：</p>
<p>将javac.exe所在的路径 配置到 环境变量path中去，这样我就可以在任意的路径下去执行这个命令：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC1%E7%AB%A0%E5%88%9D%E8%AF%86JAVA/efb27daee94a0e9016cf2bd8310c0a16.png" class="">


<p>配置好环境变量以后发现代码可以成功编译：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC1%E7%AB%A0%E5%88%9D%E8%AF%86JAVA/37a72dfd5ff1298fbecf36cd6f527b25.png" class="">


<p>验证：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC1%E7%AB%A0%E5%88%9D%E8%AF%86JAVA/8674f3596089c78139529ce26525fe26.png" class="">


<p><strong>【3】进行解释&#x2F;翻译&#x2F;执行:</strong></p>
<img data-src="/2022/10/07/Java/%E7%AC%AC1%E7%AB%A0%E5%88%9D%E8%AF%86JAVA/36f7e5bb879297158184c3d4b245a048.png" class="">


<p>上面执行过程成功的原因：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC1%E7%AB%A0%E5%88%9D%E8%AF%86JAVA/a82f8d964fbb8a2243431f8b013374de.png" class="">


<h1 id="程序中常见问题"><a href="#程序中常见问题" class="headerlink" title="程序中常见问题"></a>程序中常见问题</h1><p>【1】最低级的错误：单词拼写错误</p>
<p>【2】要求源文件名字和类名必须一模一样：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC1%E7%AB%A0%E5%88%9D%E8%AF%86JAVA/086728a33b6323fa8f6a7b901bb643c5.png" class="">


<p>出错：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC1%E7%AB%A0%E5%88%9D%E8%AF%86JAVA/310b7744316d2a235c93f190c14121f1.png" class="">


<p>【3】所有的标点必须是英文状态下的：</p>
<p>中文状态：【】（）{} ！；：“‘《》？</p>
<p>英文状态：[] () {} ! ; : “ &amp;apos; &lt;&gt; ?</p>
<p><strong>【4】成对编程：</strong></p>
<p>[] {} () &lt;&gt; “” &amp;apos;&amp;apos;</p>
<p><strong>【5】注意缩进</strong> ：只要遇到{}就进行缩进 —&gt;为了格式好看</p>
<p>缩进：tab</p>
<p>向前缩进： shift+tab</p>
<p><strong>【6】编译：</strong></p>
<p>javac HelloWorld.java</p>
<p><strong>【7】执行：</strong></p>
<p>java HelloWorld</p>
<p><strong>【8】java中大小写严格区分，大小敏感：</strong></p>
<p>HelloWorld Helloworld</p>
<p>a A</p>
<p>public PUBLIC</p>
<p><strong>【9】我们要写代码：就当做有一个“框子”</strong></p>
<ol>
<li>public class HelloWorld{</li>
<li>public static void main(String[] args){</li>
<li></li>
<li></li>
<li>}</li>
<li>}</li>
</ol>
<p><strong>【10】一个源文件中可以有多个类，只能有一个类被public修饰，源文件的名字必须跟public修饰的那个类名保持一致。</strong></p>
<img data-src="/2022/10/07/Java/%E7%AC%AC1%E7%AB%A0%E5%88%9D%E8%AF%86JAVA/2fe1f0ad62885c1a9cc2e8d3b7e8caea.png" class="">


<p>多个类会产生独立的字节码文件：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC1%E7%AB%A0%E5%88%9D%E8%AF%86JAVA/2007ac8281d6622434662d7ca51549fb.png" class="">


<p>执行的时候执行各自独立的字节码文件即可：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC1%E7%AB%A0%E5%88%9D%E8%AF%86JAVA/3f43072f8d79a015c2c78e6e602f90c5.png" class="">


<h1 id="编译方式"><a href="#编译方式" class="headerlink" title="编译方式"></a>编译方式</h1><p><strong>【1】方式1：</strong></p>
<img data-src="/2022/10/07/Java/%E7%AC%AC1%E7%AB%A0%E5%88%9D%E8%AF%86JAVA/1a5be2e20f08cca2554764864b52483e.png" class="">


<p><strong>【2】方式2：</strong></p>
<img data-src="/2022/10/07/Java/%E7%AC%AC1%E7%AB%A0%E5%88%9D%E8%AF%86JAVA/a969ad6fbcf2440708966d0ebb881780.png" class="">


<p><strong>【3】方式3：</strong></p>
<img data-src="/2022/10/07/Java/%E7%AC%AC1%E7%AB%A0%E5%88%9D%E8%AF%86JAVA/8fadab9466291f8d906886b25466c0b1.png" class="">


<p><strong>【4】方式4：</strong></p>
<p>在notepad中右键文件 –》打开文件夹所在命令行</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC1%E7%AB%A0%E5%88%9D%E8%AF%86JAVA/1309fcc40c24dc16194ec6d3d118bcc1.png" class="">


<h1 id="扩展：classpath环境变量"><a href="#扩展：classpath环境变量" class="headerlink" title="扩展：classpath环境变量"></a>扩展：classpath环境变量</h1><p><strong>【1】系统有一个环境变量叫：</strong>classpath，现在我们将classpath环境变量显式的写出来：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC1%E7%AB%A0%E5%88%9D%E8%AF%86JAVA/56653738bf699fa4839a1ad7a800d5b5.png" class="">


<p>classpath作用：只要你配置到classpath中的路径，在执行java的字节码文件的时候，就会去这个配置的路径下找 对应的字节码文件：</p>
<p>现在我不配置.\了 我配置：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC1%E7%AB%A0%E5%88%9D%E8%AF%86JAVA/45e1d0b90c634f8ae4ad6cd0e6754d6c.png" class="">


<p>自从我配置了这个环境变量以后，可以在任意的路径下去执行字节码文件：</p>
<p>总结：</p>
<p>classpath作用：针对java执行字节码文件而产生的环境变量，只要配置了字节码文件所在的路径以后，那么以后你在任意位置都可以执行对应的字节码文件</p>
<h1 id="扩展：JAVA-HOME环境变量"><a href="#扩展：JAVA-HOME环境变量" class="headerlink" title="扩展：JAVA_HOME环境变量"></a>扩展：JAVA_HOME环境变量</h1><p>后续我们会用到一个软件：tomcat，在执行startup.bat的时候会出现闪退问题：</p>
<p>解决： 必须要配置一个环境变量叫：JAVA_HOME</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC1%E7%AB%A0%E5%88%9D%E8%AF%86JAVA/d79c197731fc2fabf7d1eeffe68c3010.png" class="">


<p>我再次启动才会成功：</p>
<p>然后我们的path环境变量中刚好可以借助JAVA_HOME里面的内容，通过%%做引入 %JAVA_HOME%\bin</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC1%E7%AB%A0%E5%88%9D%E8%AF%86JAVA/eef1348dc722f99221851230d6166e99.png" class="">


<h1 id="API"><a href="#API" class="headerlink" title="API"></a>API</h1><img data-src="/2022/10/07/Java/%E7%AC%AC1%E7%AB%A0%E5%88%9D%E8%AF%86JAVA/1cee5f8ef4a6dd22f4c2427ac9f9586f.png" class="">


<ul>
<li>JDK帮助文档</li>
<li>SUN公司为JDK工具包提供了一整套文档资料,我们习惯上称之为JDK文档。</li>
<li>JDK文档中提供了Java中的各种技术的详细资料,以及JDK中提供的各种类的帮助说明。</li>
<li>JDk文档是Java语言的完整说明,大多数书籍中的类的介绍都要参照它来完成,它是编程者经常查阅的资料</li>
<li>如何理解API：就当做是一个“字典”，“使用手册”，API就相当于是一个电子的帮助文档，可以帮我们查看JDK提供的类的信息，平时查看的时候可结合百度一起看。</li>
</ul>
<p>其实API没有什么神奇的，就是一个电子文档而已，帮助我们查看JAVA中涉及到的一些技能点：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC1%E7%AB%A0%E5%88%9D%E8%AF%86JAVA/82e7900da21d11f6aa3c7c76599b84ed.png" class="">


<h1 id="代码量统计工具"><a href="#代码量统计工具" class="headerlink" title="代码量统计工具"></a>代码量统计工具</h1><img data-src="/2022/10/07/Java/%E7%AC%AC1%E7%AB%A0%E5%88%9D%E8%AF%86JAVA/7e64582ee7bad7b2c12ddece5c19f06b.png" class="">


<h1 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h1><p>为了方便程序的阅读，Java语言允许程序员在程序中写上一些说明性的文字，用来提高程序的可读性，这些文字性的说明就称为注释。</p>
<p>注释不会出现在字节码文件中，即Java编译器编译时会跳过注释语句。</p>
<p>在Java中根据注释的功能不同，主要分为单行注释、多行注释和文档注释。</p>
<ul>
<li>单行注释</li>
</ul>
<p>单行注释使用“&#x2F;&#x2F;”开头，“&#x2F;&#x2F;”后面的单行内容均为注释。</p>
<ul>
<li>多行注释</li>
</ul>
<p>多行注释以“&#x2F;*”开头以“*&#x2F;”结尾，在“&#x2F;*”和“*&#x2F;”之间的内容为注释，我们也可以使用多行注释作为行内注释。但是在使用时要注意，多行注释不能嵌套使用。</p>
<ul>
<li>文档注释</li>
</ul>
<p>文档注释以“&#x2F;**”开头以“*&#x2F;”结尾， 注释中包含一些说明性的文字及一些JavaDoc标签（后期写项目时，可以生成项目的API）</p>
<h2 id="单行注释和多行注释"><a href="#单行注释和多行注释" class="headerlink" title="单行注释和多行注释"></a>单行注释和多行注释</h2><ol>
<li>&#x2F;&#x2F;下面是一段标准代码</li>
<li>&#x2F;&#x2F;这是代码的“框子”，当前阶段你可以当做一个模板</li>
<li>&#x2F;&#x2F;其实这就是一个类，类的名字是HelloWorld，这个名字可以随便起，但是一般首字母大写，驼峰命名，见名知意</li>
<li>public class HelloWorld{</li>
<li>&#x2F;&#x2F;下面是一个main方法，方法的格式是固定的</li>
<li>public static void main(String[] args){</li>
<li>&#x2F;&#x2F;下面这句话的作用：将双引号中的内容进行原样输出</li>
<li>&#x2F;*</li>
<li>这是多行注释</li>
<li>每行都可以写</li>
<li>单行注释和多行注释，按照你自己的需求去使用即可</li>
<li>*&#x2F;</li>
<li>System.out.println(“hi….java”);</li>
<li>}</li>
<li>}</li>
</ol>
<p>注意：</p>
<p>1.注释不会参与编译，编译后产生的字节码文件中不会有注释的内容</p>
<p>2.注释的作用：</p>
<p>（1）注释就起到了标注解释的作用，提高代码的可读性，方便自己，方便他人–》是一个非常良好，非常专业的习惯！！！</p>
<p>（2）方便代码的调试：</p>
<ol>
<li>public class HelloWorld2{</li>
<li>public static void main(String[] args){</li>
<li>System.out.println(“hi….java1”);</li>
<li>&#x2F;&#x2F;System.out.println(“hi….java2”)</li>
<li>System.out.println(“hi….java3”);</li>
<li>}</li>
<li>}</li>
</ol>
<h2 id="文档注释"><a href="#文档注释" class="headerlink" title="文档注释"></a>文档注释</h2><ol>
<li>&#x2F;**</li>
<li>文档注释</li>
<li>@author zhaoss</li>
<li>@version 1.0</li>
<li>这是我们第一章文档注释的代码，比较重要</li>
<li>*&#x2F;</li>
<li>public class HelloWorld3{</li>
<li>public static void main(String[] args){</li>
<li>System.out.println(“hi….java1”);</li>
<li>}</li>
<li>&#x2F;**</li>
<li>@param name 姓名</li>
<li>@param age 年龄</li>
<li>*&#x2F;</li>
<li>public void eat(String name,int age){</li>
<li>System.out.println(“hello”);</li>
<li>}</li>
<li>}</li>
</ol>
<p>一般文档注释可以配合：jdk提供的工具javadoc.exe来一起使用，通过javadoc.exe可以对文档注释进行解析，生成一套以网页文件形式体现的该程序的说明文档。（自定义类对应的API）</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC1%E7%AB%A0%E5%88%9D%E8%AF%86JAVA/5f36c3576cf9a48034a4b4ddd4ddf78b.png" class="">


<img data-src="/2022/10/07/Java/%E7%AC%AC1%E7%AB%A0%E5%88%9D%E8%AF%86JAVA/239a7203195d3aa10f754e0cb4886fff.png" class="">


<img data-src="/2022/10/07/Java/%E7%AC%AC1%E7%AB%A0%E5%88%9D%E8%AF%86JAVA/34f6260e1d8116cec2ddc29382b5d49c.png" class="">


<img data-src="/2022/10/07/Java/%E7%AC%AC1%E7%AB%A0%E5%88%9D%E8%AF%86JAVA/63cfa40391722ade39f74d2cbdb5315f.png" class="">


<h1 id="反编译工具的使用"><a href="#反编译工具的使用" class="headerlink" title="反编译工具的使用"></a>反编译工具的使用</h1><ul>
<li>编译</li>
</ul>
<p>源代码—–&gt;class</p>
<ul>
<li>反编译</li>
</ul>
<p>class—-&gt;源代码</p>
<ul>
<li>反编译工具</li>
</ul>
<p>jd-gui.exe</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC1%E7%AB%A0%E5%88%9D%E8%AF%86JAVA/ddc58027ebdd9a708cbf6ff40e6f525b.png" class="">


<h1 id="本章最后一段代码"><a href="#本章最后一段代码" class="headerlink" title="本章最后一段代码"></a>本章最后一段代码</h1><ol>
<li>public class HiWorld{</li>
<li>public static void main(String[] args){</li>
<li>&#x2F;&#x2F;进行自我介绍：</li>
<li>System.out.print(“姓名：”);</li>
<li>System.out.print(“\t丽丽\n”);</li>
<li>System.out.print(“职业：”);</li>
<li>System.out.print(“\t学生”);</li>
<li>&#x2F;*</li>
<li>(1)System.out.print和System.out.println区别联系：</li>
<li>System.out.print ： 将双引号中内容原样输出，不换行</li>
<li>System.out.println ：将双引号中内容原样输出，换行</li>
<li>(2)转义字符：</li>
<li>\就是转义字符：作用：将后面普通的字母转换为特殊含义</li>
<li>\n : 换行</li>
<li>\t : 距离前面有一个制表符位置</li>
<li>*&#x2F;</li>
<li></li>
<li>System.out.println();&#x2F;&#x2F;换行</li>
<li>System.out.println(“1111111111111111111”);</li>
<li>System.out.println(“11111111\t2222”);</li>
<li>}</li>
<li>}</li>
</ol>
<h1 id="扩展面试题：JDK，JRE，JVM的区别"><a href="#扩展面试题：JDK，JRE，JVM的区别" class="headerlink" title="扩展面试题：JDK，JRE，JVM的区别"></a>扩展面试题：JDK，JRE，JVM的区别</h1><p>JDK,JRE,JVM的关系:</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC1%E7%AB%A0%E5%88%9D%E8%AF%86JAVA/63bfd9d6c63ebea3b5f9cf17f98644a4.png" class="">


<p>先说JDK和JRE:</p>
<p>初学JAVA很容易被其中的很多概念弄的傻傻分不清楚，首先从概念上理解一下吧，JDK（Java Development Kit）简单理解就是Java开发工具包，JRE(Java Runtime Enviroment)是Java的运行环境，JVM( java virtual machine)也就是常常听到Java虚拟机。JDK是面向开发者的，JRE是面向使用JAVA程序的用户，上面只是简单的区别</p>
<p>通过上图发现发现有两个JRE文件夹，如果细看里面的内容基本上是一样的，如果是只是Java程序使用者，那么只会有最外层的那个JRE目录，JDK中是JRE自带的，你如果安装了JDK必然里面会有一个JRE.那么问题来了，为什么会有两套JRE呢？</p>
<p>从侧面证明:</p>
<p>利用javac.exe进行编译:</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC1%E7%AB%A0%E5%88%9D%E8%AF%86JAVA/9c783ba968cea227029eece87e12f9fa.png" class="">


<p>然后我将C:\Program Files\Java\jdk1.8.0_151\lib\tools.jar改个名字,再去编译:</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC1%E7%AB%A0%E5%88%9D%E8%AF%86JAVA/43325d9c5156144d0eeb92d48c4ab23c.png" class="">


<p>证明:dt.jar和tools.jar是两个java最基本的包，里面包含了从java最重要的lang包到各种高级功能如可视化的swing包，是java必不可少的。而path下面的bin里面都是java的可执行的编译器及其工具，如java，javadoc等,报错的原因就是输入的javac的命令不是去JDK中bin目录去找的javac.exe，而是去JDK中lib目录中的tools.jar中com.sun.tools.javac.Main中执行，因此javac.exe只是一个包装器（Wrapper），存在的目的是为了让开发者免于输入过长的指命。这个时候发现JDK里的工具几乎是用Java所编写，同属于Java应用程序，因此要使用JDK所附的工具来开发Java程序，所以自身需要附一套JRE才能运行。上图中与jdk同级目录下的JRE就是用来运行一般Java程序用的。</p>
<p>两套JRE运行的时候究竟运行哪一个呢，这个时候JDK中java.exe先从自身目录中找，然后父级目录中找，如果都没有就去注册表中找</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC1%E7%AB%A0%E5%88%9D%E8%AF%86JAVA/774e13c2fe05e00b2b88485d66878cb5.png" class="">


<p>再说JRE和JVM:</p>
<p>JVM – java virtual machineJVM就是我们常说的java虚拟机，它是整个java实现跨平台的最核心的部分，所有的java程序会首先被编译为.class的类文件，这种类文件可以在虚拟机上执行，class文件并不直接与机器的操作系统相对应，而是经过虚拟机间接与操作系统交互，由虚拟机将程序解释给本地系统执行，类似于C#中的CLR。</p>
<p>JVM不能单独搞定class的执行，解释class的时候JVM需要调用解释所需要的类库lib。在JDK下面的的jre目录里面有两个文件夹bin和lib,在这里可以认为bin里的就是jvm，lib中则是jvm工作所需要的类库，而jvm和 lib和起来就称为jre。</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC1%E7%AB%A0%E5%88%9D%E8%AF%86JAVA/a6a57ddcf4dbbce6ec083f177185b938.png" class="">


<p>JVM+Lib&#x3D;JRE，如果讲的具体点就是bin目录下的jvm.dll文件， jvm.dll无法单独工作，当jvm.dll启动后，会使用explicit的方法(就是使用Win32 API之中的LoadLibrary()与GetProcAddress()来载入辅助用的动态链接库)，而这些辅助用的动态链接库(.dll)都必须位 于jvm.dll所在目录的父目录之中。因此想使用哪个JVM，只需要设置PATH，指向JRE所在目录下的jvm.dll。</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC1%E7%AB%A0%E5%88%9D%E8%AF%86JAVA/3b5991d32e4ea2cdd83dfc682380f30f.png" class="">

]]></content>
      <categories>
        <category>JavaSE</category>
        <category>JAVA简介</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title>第2章_数据类型</title>
    <url>/2022/10/07/Java/%E7%AC%AC2%E7%AB%A0_%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h1><p><strong>【1】标识符：读音 biao zhi fu</strong></p>
<p><strong>【2】什么是标识符？</strong></p>
<p>包，类，变量，方法…..等等,只要是起名字的地方,那个<strong>名字</strong>就是标识符</p>
<p><strong>【3】标识符定义规则：</strong></p>
<p>1.四个可以（组成部分）：数字，字母，下划线_，美元符号$</p>
<p>注意：字母概念比较宽泛，指的是英文字母，汉字，日语，俄语……</p>
<p>但是我们一般起名字尽量使用英文字母</p>
<p>2.两个不可以：不可以以数字开头，不可以使用java中的关键字</p>
<p>3.见名知意：增加可读性</p>
<p><strong>4.大小写敏感</strong>： int a ; int A;</p>
<p><strong>5.遵照驼峰命名：</strong></p>
<p>类名：首字母大写，其余遵循驼峰命名</p>
<p>方法名，变量名：首字母小写，其余遵循驼峰命名</p>
<p>包名：全部小写，不遵循驼峰命名</p>
<p><strong>6.长度无限制，但是不建议太长 asdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasfd</strong></p>
<h1 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h1><p><strong>关键字：</strong>被JAVA语言赋予了特殊含义，用作专门用途的单词</p>
<p>特点：JAVA中所有关键字都为小写</p>
<p>官网：<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLm9yYWNsZS5jb20vamF2YXNlL3R1dG9yaWFsL2phdmEvbnV0c2FuZGJvbHRzL19rZXl3b3Jkcy5odG1s">https://docs.oracle.com/javase/tutorial/java/nutsandbolts/_keywords.html</span></p>






<h1 id="变量和常量"><a href="#变量和常量" class="headerlink" title="变量和常量"></a>变量和常量</h1><p>举例：</p>
<p>丽丽的年龄：去年17岁，今年18岁，明年19岁</p>
<p>年龄：17–》18—》19 –》值不断变化</p>
<p>年龄—》变量</p>
<p>常量： 17 ， 18 ， 19 —-》 常量中的字面常量</p>
<h2 id="字面常量"><a href="#字面常量" class="headerlink" title="字面常量"></a>字面常量</h2><p><strong>常量分为两种：</strong></p>
<p>常量通常指的是一个固定的值，例如：1、2、3、’a’、’b’、true、false、”helloWorld”等。</p>
<p>在Java语言中，主要是利用关键字final来定义一个常量。 常量一旦被初始化后不能再更改其值。</p>
<p>为了更好的区分和表述，一般将1、2、3、’a’、’b’、true、false、”helloWorld”等称为字面常量，而使用final修饰的PI等称为符号常量（字符常量）。</p>
<p><strong>字面常量的类型：</strong></p>



<p>注意：逻辑常量就两个值，一个是true，一个是false</p>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>变量本质上就是代表一个”可操作的存储空间”，空间位置是确定的，但是里面放置什么值不确定。我们可通过变量名来访问“对应的存储空间”，从而操纵这个“存储空间”存储的值。Java是一种强类型语言，每个变量都必须声明其数据类型。变量的数据类型决定了变量占据存储空间的大小。 比如，int a&#x3D;3; 表示a变量的空间大小为4个字节。变量作为程序中最基本的存储单元，其要素包括变量名，变量类型和作用域。变量在使用前必须对其声明, 只有在变量声明以后，才能为其分配相应长度的存储空间。</p>
<p>【1】变量声明格式：</p>
<p>type varName [&#x3D;value][,varName[&#x3D;value]…]; &#x2F;&#x2F;[ ]中的内容为可选项，即可有可无</p>
<p>数据类型 变量名 [&#x3D;初始值] [,变量名 [&#x3D;初始值]…];</p>
<p>案例：</p>
<p>int age &#x3D; 19 , age2 &#x3D; 90 ;</p>
<p>int age,age2;</p>
<p>【2】变量的声明：</p>
<p>（1）如果你只定义一个变量，没有给变量进行赋值的话，那么其实这个变量相当于没有定义：</p>



<p>（2）变量如果没有进行赋值的话，那么使用的时候会出错，告诉你：尚未初始化变量：</p>



<p>【3】变量的赋值：</p>



<p>我们自己定义的时候直接就可以用一句话定义：</p>
<p>int age &#x3D; 10;</p>
<p>变量的值可以更改：</p>
<pre><code class="java">public class TestVar01&#123;
    public static void main(String[] args)&#123;
        //变量的声明（定义变量）（以年龄为案例讲解）
        //java是一个强类型的语言，只要声明变量就必须定义类型：定义整数类型
        int age ; //定义一个整数类型的变量，变量名字为age
        //对变量进行赋值操作：
        age = 10; //变量名字为age，具体的值为10
        age = 12;
        age = 20;
        age = age + 4;
        age = 9;
        age = 9;
        System.out.println(age);
        
    &#125;
&#125;
</code></pre>
<p>变量不可以重复定义：</p>



<p>【4】变量的使用：</p>
<pre><code class="java">public class TestVar01&#123;
    public static void main(String[] args)&#123;
        //变量的声明（定义变量）（以年龄为案例讲解）
        //java是一个强类型的语言，只要声明变量就必须定义类型：定义整数类型
        int age ; //定义一个整数类型的变量，变量名字为age
        //对变量进行赋值操作：
        age = 10; //变量名字为age，具体的值为10
        age = 12;
        age = 20;
        age = age + 4;
        age = 9;
        age = 9;
        System.out.println(age);
        System.out.println(age-2);
        System.out.println(age+10);
        int num = age + 66;
        System.out.println(num);
        
    &#125;
&#125;
</code></pre>
<p>扩展：</p>
<pre><code class="java">public class TestVar02&#123;
    public static void main(String[] args)&#123;
        int a = 10;
        int b = 20;
        int c = a + b ;
    &#125;
&#125;
</code></pre>
<p>现在对上述代码进行“反编译过程”“反汇编过程”</p>






<p>【5】变量的内存：</p>



<p>【6】习题：</p>
<pre><code class="java">public class TestVar03&#123;
    public static void main(String[] args)&#123;
        int num1 = 10;
        int num2 = 20;
        num1 = num2;
        num2 = num2 + 10;
        num1 = num2 - 10;
        num2 = num1;
        System.out.println(&quot;num1=&quot;+num1);
        System.out.println(&quot;num2=&quot;+num2);
    &#125;
&#125;
</code></pre>
<p>内存分析：</p>



<p>结果：</p>



<p>【7】变量的作用域：</p>
<p>作用域指的就是作用范围，变量在什么范围中有效</p>
<p>作用范围就是离它最近的{}</p>
<p>备注：一会我们写的代码，不要去运行，会出错</p>
<pre><code class="java">/\*
    局部变量：定义在方法中
    成员变量：定义在类中，方法外
    \*/
public class TestVar04&#123;
    int b = 20;
    public static void main(String[] args)&#123;
        System.out.println(a);//no
        int a = 10;
        System.out.println(a);//yes
        System.out.println(b);//yes
        &#123;
            int c = 40;
            System.out.println(c);//yes
            int a = 50;//属于变量的重复定义
        &#125;
        System.out.println(c);//no
    &#125;

    public void eat()&#123;
        System.out.println(b);//yes
        System.out.println(a);//no
        int a = 30;//不是变量的重复定义
        System.out.println(a);//yes
    &#125;
&#125;
</code></pre>
<h1 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h1><p>Java是一种强类型语言，每个变量都必须声明其数据类型。</p>
<p>Java的数据类型可分为两大类：基本数据类型（primitive data type）和引用数据类型（reference data type）。</p>



<p>PS:巧妙记忆：除了基本数据类型以外的所有类型都属于引用数据类型，本章重点：基本数据类型</p>
<h2 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h2><h3 id="整数类型常量"><a href="#整数类型常量" class="headerlink" title="整数类型常量"></a>整数类型常量</h3><p>十进制整数，如：99, -500, 0</p>
<p>八进制整数，要求以 0 开头，如：015</p>
<p>十六进制数，要求 0x 或 0X 开头，如：0x15</p>
<p>二进制：要求0b或者0B开头，如：0b11</p>
<p>几进制：就是逢几进1的问题：</p>
<p>平时实际生活中用的最多的是：十进制</p>
<p>计算机用二进制最多</p>



<p>扩展：进制转换问题</p>
<p>【1】二进制转换为十进制：</p>
<p>二进制： 1101</p>
<p>1*2^3 + 1*2^2 + 0*2^1 + 1*2^0</p>
<p>&#x3D; 8 + 4 + 0 + 1</p>
<p>&#x3D; 13</p>
<p>【2】十进制转换为二进制：</p>
<p>十进制 13</p>



<p>【3】八进制转换十进制：</p>
<p>八进制： 16</p>
<p>1*8^1 + 6*8^0</p>
<p>&#x3D; 8 + 6</p>
<p>&#x3D;14</p>
<p>【4】十进制转换为八进制：</p>
<p>十进制14：</p>



<p>【5】八进制转换为十六进制：</p>
<p>把十进制当做一个中转站：</p>
<p>八进制—》十进制—》十六进制</p>
<p>实际上根本不用自己转换这么麻烦：我们可以直接用系统中提供给我们的计算器：</p>



<h3 id="整数类型变量"><a href="#整数类型变量" class="headerlink" title="整数类型变量"></a>整数类型变量</h3><p><strong>整型数据类型：</strong></p>



<p>比如：byte的右侧表数范围127怎么算出来的？</p>
<p>byte: 1字节 &#x3D; 8位</p>
<p>二进制：01111111</p>
<p>1*2^6 + 1*2^5 + 1*2^4 + 1*2^3 + 1*2^2 + 1*2^1 + 1*2^0</p>
<p>&#x3D; 64 + 32 + 16 +8 +4 + 2 +1</p>
<p>&#x3D; 127</p>
<p>代码：</p>
<pre><code class="java">public class TestVar05&#123;
    public static void main(String[] args)&#123;
        //定义整数类型的变量：
        //给变量赋值的时候，值可以为不同进制的：
        int num1 = 12 ;//默认情况下赋值就是十进制的情况
        System.out.println(num1);
        int num2 = 012;//前面加上0，这个值就是八进制的
        System.out.println(num2);
        int num3 = 0x12;//前面加上0x或者0X，这个值就是十六进制的
        System.out.println(num3);
        int num4 = 0b10;//前面加上0b或者0B,这个值就是二进制的
        System.out.println(num4);
        
        //定义byte类型的变量：
        byte b = 126;//定义了一个byte类型的变量，名字叫b，赋值为12
        System.out.println(b);
        //注意：超范围的赋值会报错。
        short s = 30000;
        System.out.println(s);
        int i = 1234;
        System.out.println(i);
        //整数类型默认就是int类型的，所以12345678910是一个int类型的数，对于int类型来说，它超出范围了
        //要想把一个数给long类型变量，那么后面加上L(推荐)或者l就可以了
        long num5 = 12345678910L;
        System.out.println(num5);
        //注意：只有这个数超出int类型的范围了后面才需要加上L，否则无需加L也可以赋值给long类型：
        long num6 = 12;
        System.out.println(num6);
        
    &#125;
&#125;
</code></pre>
<h2 id="浮点类型"><a href="#浮点类型" class="headerlink" title="浮点类型"></a>浮点类型</h2><h3 id="浮点类型常量"><a href="#浮点类型常量" class="headerlink" title="浮点类型常量"></a>浮点类型常量</h3><p>（1）十进制数形式，例如:</p>
<p>3.14 314.0 0.314</p>
<p>（2）科学记数法形式，如</p>
<p>314e2 314E2 (E的大小写没有区分) 314E-2</p>
<p>double f &#x3D; 314e2; &#x2F;&#x2F;314*10^2–&gt;31400.0</p>
<p>double f2 &#x3D; 314e-2; &#x2F;&#x2F;314*10^(-2)–&gt;3.14</p>
<h3 id="浮点类型变量"><a href="#浮点类型变量" class="headerlink" title="浮点类型变量"></a>浮点类型变量</h3><p>float类型又被称作单精度类型，尾数可以精确到7位有效数字，在很多情况下，float类型的精度很难满足需求。</p>
<p>而double表示这种类型的数值精度约是float类型的两倍，又被称作双精度类型，绝大部分应用程序都采用double类型。</p>
<p>float类型的数值有一个后缀F或者f ，没有后缀F&#x2F;f的浮点数值默认为double类型。</p>
<p>也可以在浮点数值后添加后缀D或者d， 以明确其为double类型。</p>



<p>PS：有效数字指的是从左开始第一个不为0的数到最后一个数</p>
<p>代码：</p>
<pre><code class="java">public class TestVar06&#123;
    public static void main(String[] args)&#123;
        //浮点类型的常量有两种形式：
        //十进制形式：
        double num1 = 3.14;
        System.out.println(num1);
        //科学计数法形式：
        double num2 = 314E-2;
        System.out.println(num2);
        
        //浮点类型的变量：
        //注意：浮点型默认是double类型的，要想将一个double类型的数赋给float类型，必须后面加上F或者f
        float f1 = 3.14234567898623F;
        System.out.println(f1);
        //注意：double类型后面可以加D或者d，但是一般我们都省略不写
        double d1 = 3.14234567898623D;
        System.out.println(d1);
        
        //注意：我们最好不要进行浮点类型的比较：
        float f2 = 0.3F;
        double d2 = 0.3;
        System.out.println(f2==d2);
        /\*
            区别：
            = 赋值运算： 将等号右侧的值赋给等号左侧
            == 判断==左右两侧的值是否相等 ：结果要么相等 要么不相等
            ==运算符的结果就是要么是true，要么是false
            \*/
            
    &#125;
&#125;
</code></pre>
<h2 id="字符类型"><a href="#字符类型" class="headerlink" title="字符类型"></a>字符类型</h2><p>【1】Java中使用单引号来表示字符常量，字符型在内存中占2个字节。</p>
<p>char 类型用来表示在Unicode编码表中的字符。Unicode编码被设计用来处理各种语言的文字，它占2个字节，可允许有65536个字符。</p>
<p>【2】转义字符：</p>



<p>【3】ASCII表：</p>



<p>【4】Unicode编码表：</p>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vY3NndW8vcC83NDAxODc0Lmh0bWw=">https://www.cnblogs.com/csguo/p/7401874.html</span></p>
<p>代码1：</p>
<pre><code class="java">public class TestVar07&#123;
    public static void main(String[] args)&#123;
        //定义字符类型的变量：
        char ch1 = &#39;a&#39;;
        System.out.println(ch1);
        char ch2 = &#39;A&#39;;
        System.out.println(ch2);
        char ch3 = &#39;4&#39;;
        System.out.println(ch3);
        char ch4 = &#39;中&#39;;
        System.out.println(ch4);
        char ch5 = &#39;?&#39;;
        System.out.println(ch5);
        //java中无论：字母，数字，符号，中文都是字符类型的常量，都占用2个字节。
        char ch6 = &#39; &#39;;
        System.out.println(ch6);
        //字符类型：单引号引起来的单个字符
        System.out.println(&quot;--------------------------------&quot;);
        /\*
            转义字符：
            \\将后面的普通字符转换为特殊含义
            \*/
            char ch7 = &#39;\\n&#39;;
        System.out.println(&quot;aaa&quot;+ch7+&quot;bbb&quot;);
        
        System.out.println(&quot;aaa\\nbbb&quot;);// \\n 换行
        
        System.out.println(&quot;aaaaaaa\\tbbb&quot;); // \\t 制表符
        
        System.out.println(&quot;aaa\\bbbb&quot;);//aabbb \\b 向前退一格
        System.out.println(&quot;aaa\\rbbb&quot;);//bbb \\r 将光标到本行开头 ：回车
        
        System.out.println(&quot;\\&quot;java\\&quot;&quot;); // \\&quot; 将双引号原样输出 \\&#39; 将单引号原样输出 \\\\ 将\\原样输出
    &#125;
&#125;
</code></pre>
<p>代码2：</p>
<pre><code class="java">public class TestVar08&#123;
    public static void main(String[] args)&#123;
        char ch1 = &#39;A&#39;;
        System.out.println(ch1);//A
        System.out.println(ch1+90);//155
        System.out.println(155-ch1);//90
        //char类型我们看到的样子就是它本身的字面常量,但是底层在进行计算的时候，实际上是按照一个码进行计算的。
        //这个码就是ASCII
        //之前说char类型是按照Unicode码表进行存储的 (Unicode兼容了ASCII码，Unicode的前128位置ASCII)
        
        char ch2 = &#39;中&#39;;
        System.out.println(ch2);// 中
        System.out.println(ch2+90);// 20103
        System.out.println(20103-ch2);// 90
        
        //转换：
        int num1 = (int)ch2;
        System.out.println(num1);//20013
        
        char ch = (char)20013;
        System.out.println(ch);
        
        int num2 = &#39;中&#39;;
        char ch5 = 20013;
        System.out.println(ch5);
        
        //面试题：
        char ch6 = &#39;2&#39;+2;
        System.out.println(ch6);//&#39;4&#39;---\&gt;4
    &#125;
&#125;
</code></pre>
<h3 id="编码和字符集"><a href="#编码和字符集" class="headerlink" title="编码和字符集"></a>编码和字符集</h3><p>【1】什么是编码？</p>



<p>【2】通过生活案例：</p>



<p>【3】由权威机构形成的编码表才可以称之为：字符集</p>
<ul>
<li>ASCII</li>
</ul>
<p>英文字符集</p>
<p>用一个字节的7位表示</p>
<ul>
<li>IOS8859-1</li>
</ul>
<p>西欧字符集</p>
<p>用一个字节的8位表示</p>
<ul>
<li>GB2312</li>
</ul>
<p>简体中文字符集</p>
<p>最多使用两个字节编码</p>
<p>PS：中文：2个字节</p>
<p>GB2312兼容了ASCII中的字符：</p>
<ul>
<li>GBK</li>
</ul>
<p>GB2312的升级，加入了繁体字</p>
<p>最多使用两个字节编码</p>
<p>疑问：</p>



<p>首位如果是0：一个字节代码代表一个字符</p>
<p>首位如果是1：那么一个字节不够，要加上后面的字节才能完整的表示一个字符。</p>
<ul>
<li>Unicode</li>
</ul>
<p>国际通用字符集，融合了目前人类使用的所有字符。为每个字符分配唯一的字符码。</p>
<p>退出了UTF标准：</p>
<p>三种编码方案： UTF-8，UTF-16,UTF-32</p>
<p>以UTF-8为案例讲解：</p>
<p>中文： 珊 —》Unicode ： 29642</p>






<p>底层存储：</p>



<p>UTF-8标准最多可以用6个字节表示：</p>



<p>以后我们用的最多的就是UTF-8.</p>
<h3 id="解释乱码问题"><a href="#解释乱码问题" class="headerlink" title="解释乱码问题"></a>解释乱码问题</h3>


<p>用记事本选择编码方法的时候一般要选择为ANSI—》获取当前操作系统的编码格式：GBK</p>
<h2 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h2><p>boolean类型有两个常量值，true和false，在内存中占一位（不是一个字节），不可以使用 0 或非 0 的整数替代 true 和 false ，这点和C语言不同。 boolean 类型用来判断逻辑条件，一般用于程序流程控制 。</p>
<pre><code class="java">public class TestVar09&#123;
    public static void main(String[] args)&#123;
        //创建一个布尔类型的变量：
        boolean flag1 = true;
        System.out.println(flag1);
        boolean flag2 = false;
        System.out.println(flag2);
        boolean flag3 = 5==9;
        System.out.println(flag3);
        boolean flag4 = 5\&lt;9;
        System.out.println(flag4);
    &#125;
&#125;
</code></pre>
<h2 id="基本数据类型的转换"><a href="#基本数据类型的转换" class="headerlink" title="基本数据类型的转换"></a>基本数据类型的转换</h2><p>【1】什么是类型转换：</p>
<p>在赋值运算或者算数运算的时候，要求数据类型一致，就要进行类型的转换。</p>
<p>【2】类型转换的种类：</p>
<p>自动转换，强制转换</p>
<p>【3】内存演示：</p>



<p>【4】代码：</p>
<pre><code class="java">public class TestVar10&#123;
    public static void main(String[] args)&#123;
        //类型转换的两种形式：
        double d = 6;//int--\&gt;double 自动类型转换
        System.out.println(d);
        int i = (int)6.5;//double---\&gt;int 强制类型转换 （强转）
        System.out.println(i);
        
        //在同一个表达式中，有多个数据类型的时候，应该如何处理：
        //多种数据类型参与运算的时候，整数类型，浮点类型，字符类型都可以参与运算，唯独布尔类型不可以参与运算。
        //double d2 = 12+1294L+8.5F+3.81+&#39;a&#39;+true;
        double d2 = 12+1294L+8.5F+3.81+&#39;a&#39;;
        System.out.println(d2);
        /\*
            类型级别：(从低到高的)
            byte,short,char--\&gt;int---\&gt;long---\&gt;float---\&gt;double
            级别用来做什么？当一个表达式中有多种数据类型的时候，要找出当前表达式中级别最高的那个类型，然后
            其余的类型都转换为当前表达式中级别最高的类型进行计算。
            double d2 = 12+1294L+8.5F+3.81+&#39;a&#39;;
        = 12.0+1294.0+8.5+3.81+97.0
            \*/
            int i2 = (int)(12+1294L+8.5F+3.81+&#39;a&#39;);
        System.out.println(i2);
        /\*
            在进行运算的时候：
            左=右 : 直接赋值
                左\&lt;右 ：强转
                左\&gt;右 ：直接自动转换
                \*/
                
                //以下情况属于特殊情形：对于byte，short，char类型来说，只要在他们的表数范围中，赋值的时候就不需要进行
                //强转了直接赋值即可。
                byte b = 12;
        System.out.println(b);
        byte b2 = (byte)270;
        System.out.println(b2);
        
        
        
    &#125;
&#125;
</code></pre>
<h2 id="练习：final，字符常量，Scanner的使用"><a href="#练习：final，字符常量，Scanner的使用" class="headerlink" title="练习：final，字符常量，Scanner的使用"></a>练习：final，字符常量，Scanner的使用</h2><pre><code class="java">import java.util.Scanner;//形象理解：在java.util下将Scanner拿过来用
public class TestVar11&#123;
    public static void main(String[] args)&#123;
        //实现功能：求圆的周长和面积
        //【1】提取变量：提取变量，就是为了一劳永逸，以后只要改变变量的值，下面只要用到这个变量的地方，取值也都发生变化了
        //【2】一个变量被final修饰，这个变量就变成了一个常量，这个常量的值就不可变了
        // 这个常量就是我们所说的 字符常量 ---》pi
        // 约定俗成的规定：字符常量的名字全部大写
        //【3】使用扫描器：Scanner的使用--》注意通过形象的理解去使用
        final double PI = 3.14;
        //拿来一个扫描器：
        Scanner sc = new Scanner(System.in);
        //给一个友好性的提示：
        System.out.print(&quot;请录入一个半径：&quot;);
        //让扫描器扫描键盘录入的int类型的数据：
        int r = sc.nextInt();
        
        //求周长：
        double c = 2\*PI\*r;
        System.out.println(&quot;周长为：&quot;+c);
        
        //求面积：
        //PI = 9.29;报错：TestVar11.java:12: 错误: 无法为最终变量pi分配值
        double s = PI\*r\*r;
        System.out.println(&quot;面积为：&quot;+s);
        
        
    &#125;
&#125;
</code></pre>
<h2 id="练习：加深对Scanner的使用"><a href="#练习：加深对Scanner的使用" class="headerlink" title="练习：加深对Scanner的使用"></a>练习：加深对Scanner的使用</h2>


<pre><code class="java">import java.util.Scanner;
public class TestVar12&#123;
    public static void main(String[] args)&#123;
        //键盘录入学生的信息：年龄，身高，姓名，性别：
        //键盘录入年龄：(接收int类型数据)
        Scanner sc = new Scanner(System.in);
        System.out.print(&quot;请录入年龄：&quot;);
        int age = sc.nextInt();
        //键盘录入身高：（接收double类型数据）
        System.out.print(&quot;请录入身高：&quot;);
        double height = sc.nextDouble();
        //键盘录入姓名：(接收String类型数据--》字符串)
        System.out.print(&quot;请录入姓名：&quot;);
        String name = sc.next();
        //键盘录入性别：(接受char类型)
        System.out.print(&quot;请录入性别：&quot;);
        String sexStr = sc.next();
        char sex = sexStr.charAt(0);
        //上面两句可以合为一句表示：char sex = sc.next().charAt(0);
        System.out.println(&quot;该学生的信息为:姓名是：&quot;+name+&quot;,年龄是：&quot;+age+&quot;,身高为：&quot;+height+&quot;,性别是：&quot;+sex);
    &#125;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>JavaSE</category>
        <category>数据类型</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title>第3章_运算符</title>
    <url>/2022/10/07/Java/%E7%AC%AC3%E7%AB%A0_%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
    <content><![CDATA[<h1 id="Java中的运算符"><a href="#Java中的运算符" class="headerlink" title="Java中的运算符"></a>Java中的运算符</h1><p>【1】Java 语言支持如下运算符：</p>
<ul>
<li>算术运算符</li>
</ul>
<p>+，-，*，&#x2F;，%，++（自增），–（自减）</p>
<ul>
<li>赋值运算符</li>
</ul>
<p>&#x3D;</p>
<ul>
<li>扩展赋值运算符</li>
</ul>
<p>+&#x3D;，-&#x3D;，*&#x3D;，&#x2F;&#x3D;</p>
<ul>
<li>关系运算符</li>
</ul>
<p>&gt;，&lt;，&gt;&#x3D;，&lt;&#x3D;，&#x3D;&#x3D;，!&#x3D;</p>
<ul>
<li>逻辑运算符</li>
</ul>
<p>&amp;，|， &amp;&amp;，||，!，^</p>
<ul>
<li>位运算符</li>
</ul>
<p>&amp;，|，^，~ ， &gt;&gt;，&lt;&lt;，&gt;&gt;&gt; (了解！！！)</p>
<ul>
<li>条件运算符</li>
</ul>
<p>？：</p>
<p>【2】相关概念辨析</p>
<p>+ 运算符 操作符 Operator</p>
<p>5+6 表达式 expression</p>
<p>5 6 操作数 Operand</p>
<p>int m &#x3D;5+6; 语句 Sentence</p>
<h1 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h1><h2 id="x2F-和"><a href="#x2F-和" class="headerlink" title="&#x2F;和%"></a>&#x2F;和%</h2><p>【1】&#x2F; 除法运算符 ： 表示两个数相除运算</p>
<p>% 取余运算符： 用来求余数的</p>
<pre><code class="java">public class TestOpe01&#123;

    public static void main(String[] args)&#123;

        //打印结果：

        System.out.println(12/3);

        System.out.println(12%5);

        System.out.println(12/3.0);

        System.out.println(12%5.0);

    &#125;

&#125;
</code></pre>
<p>【2】练习：</p>
<pre><code class="java">import java.util.Scanner;

public class TestOpe02&#123;

    public static void main(String[] args)&#123;

        //实现功能：任意给出一个四位数，求出每位上的数字并输出

        

        //1.任意给出一个四位数：

        Scanner input = new Scanner(System.in);

        System.out.println(&quot;请录入一个四位数：&quot;);

        int num = input.nextInt();

        

        

        //2.求出每位上的数字：

        //个位数：

        int num1 = num%10;

        //十位数：

        int num2 = num/10%10;//1234---\&gt;123---\&gt;3

        //百位数：

        int num3 = num/100%10;//1234---\&gt;12---\&gt;2

        //千位数：

        int num4 = num/1000;//1234---\&gt;1

        

        

        //3.输出每位上的数字：

        System.out.println(&quot;个位上的数为：&quot;+num1);

        System.out.println(&quot;十位上的数为：&quot;+num2);

        System.out.println(&quot;百位上的数为：&quot;+num3);

        System.out.println(&quot;千位上的数为：&quot;+num4);

    &#125;

    

&#125;
</code></pre>
<h2 id=""><a href="#" class="headerlink" title="+"></a>+</h2><p>【1】+的作用：</p>
<p>（1）表示正数</p>
<p>（2）表示相加操作</p>
<p>（3）进行字符串的拼接</p>
<p>【2】代码练习：</p>
<pre><code class="java">public class TestOpe03&#123;

    public static void main(String[] args)&#123;

        //表示正数：

        System.out.println(+5);//5

        //相加操作：

        System.out.println(5+6);//11

        System.out.println(5+&#39;6&#39;);//59

        //字符串的拼接：

        //规则：+左右两侧的任意一侧有字符串，那么这个加号就是字符串拼接的作用，结果一定是字符串

        int num = 56;

        System.out.println(&quot;num=&quot;+num);//&quot;num=56&quot; ---\&gt; num=56

        System.out.println(5+6+&quot;7&quot;);//11+&quot;7&quot;---\&gt;&quot;117&quot; ---\&gt;117

        System.out.println(5+&#39;6&#39;+&quot;7&quot;);//59 +&quot;7&quot;---\&gt;&quot;597&quot; ---\&gt;597

        System.out.println(&quot;5&quot;+6+&quot;7&quot;);//&quot;56&quot;+&quot;7&quot; ---\&gt;&quot;567&quot;---\&gt;567

        System.out.println(&quot;5&quot;+&#39;6&#39;+&quot;7&quot;);//&quot;56&quot;+&quot;7&quot;---\&gt;&quot;567&quot;---\&gt;567

        System.out.println(&quot;5&quot;+&#39;6&#39;+&#39;7&#39;);//&quot;56&quot;+&#39;7&#39;---\&gt;&quot;567&quot;---567

    &#125;

&#125;
</code></pre>
<h2 id="-1"><a href="#-1" class="headerlink" title="++"></a>++</h2><p>【1】++：</p>
<pre><code class="java">public class TestOpe04&#123;

    public static void main(String[] args)&#123;

        int a = 5;

        a++;//理解为：相当于 a=a+1 操作

        System.out.println(a);//6

        

        a = 5;

        \++a;//理解为：相当于 a=a+1 操作

        System.out.println(a); //6

        

        //总结：++单独使用的时候，无论放在前还是后，都是加1操作

        

        //将++参与到运算中：

        //规则：看++在前还是在后，如果++在后：先运算，后加1 如果++在前，先加1，后运算

        a = 5;

        int m = a++ + 7;//先运算 m=a+7 再加1： a = a+1

        System.out.println(m);//12

        System.out.println(a);//6

        

        a = 5;

        int n = ++a + 7;//先加1 a=a+1 再运算： n = a+7

        System.out.println(n);//13

        System.out.println(a);//6

    &#125;

&#125;
</code></pre>
<p>无论这个变量是否参与到运算中去，只要用++运算符，这个变量本身就加1操作</p>
<p>只是说如果变量参与到运算中去的话，对运算结果是产生影响：</p>
<p>看++在前还是在后，如果++在后：先运算，后加1 如果++在前，先加1，后运算</p>
<p>【2】练习：</p>
<pre><code class="java">public class TestOpe05&#123;

    public static void main(String[] args)&#123;

        int a = 5;

        System.out.println(a++ + a++);

        System.out.println(a++ + ++a);

        System.out.println(++a + a++);

        System.out.println(++a + ++a);

    &#125;

&#125;
</code></pre>
<p>运算过程：</p>



<h1 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h1><p>【1】&#x3D;的作用： 将等号右侧的值赋给等号左侧：</p>
<p>int age &#x3D; 19;</p>
<p>int age &#x3D; 10+3+8;</p>
<p>【2】练习：</p>
<pre><code class="java">public class TestOpe06&#123;
    public static void main(String[] args)&#123;
        //任意给出两个数，交换两个数并输出：
        //1.给出两个数：
        int num1 = 10;
        int num2 = 20;
        
        //2.输出交换前的两个数：
        System.out.println(&quot;交换前：&quot;+num1+&quot;\\t&quot;+num2);
        
        //3.交换
        /\*
            错误代码：
            num1 = num2;
        num2 = num1;
        \*/
            //解决办法：
            //引入一个中间变量:
            int t;
        t = num1;
        num1 = num2;
        num2 = t;
        /\*
            int t;
        t = num2;
        num2 = num1;
        num1 = t;
        
        \*/
            
            //4.输出交换后的两个数：
            System.out.println(&quot;交换后：&quot;+num1+&quot;\\t&quot;+num2);
    &#125;
&#125;
</code></pre>



<p>面试题：两个数交换的四种方式：<span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vQnJhZC1MZWUvcC81ODA4Mjk5Lmh0bWw=">https://www.cnblogs.com/Brad-Lee/p/5808299.html</span></p>
<h1 id="扩展赋值运算符"><a href="#扩展赋值运算符" class="headerlink" title="扩展赋值运算符"></a>扩展赋值运算符</h1><p>【1】代码：</p>
<pre><code class="java">public class TestOpe07&#123;
    public static void main(String[] args)&#123;
        //实现功能：给出三个数，求和：
        //1.给出三个数：
        int num1 = 10;
        int num2 = 20;
        int num3 = 30;
        //2.求和
        //int sum = num1+num2+num3;
        //定义一个变量，用来接收和：
        int sum = 0;
        sum = sum + num1;//等效： sum += num1;
        sum = sum + num2;// sum += num2;
        sum = sum + num3;//sum += num3;
        //3.将和输出：
        System.out.println(&quot;和：&quot;+sum);
    &#125;
&#125;
</code></pre>
<p>内存：</p>



<p>【2】a+&#x3D;b 和 a&#x3D;a+b 区别：</p>
<p>（1）a+&#x3D;b 可读性稍差 编译效率高 底层自动进行类型转换</p>
<p>（2）a&#x3D;a+b 可读性好 编译效率低 手动进行类型转换</p>
<p>【3】面试题</p>
<p>（1）请问a+&#x3D;b相当于a&#x3D;a+b,那么也相当于 a&#x3D;b+a吗？</p>



<p>（2）下面的代码哪一句出错： 4</p>
<p>byte a &#x3D; 10; —&gt;1</p>
<p>int b &#x3D; 20; —&gt;2</p>
<p>a+&#x3D;b; —-&gt;3</p>
<p>a &#x3D; a+b ;—-&gt;4</p>
<p>更正： a &#x3D; (byte)(a+b);</p>
<h1 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h1><pre><code class="java">public class TestOpe08&#123;
    public static void main(String[] args)&#123;
        //\&gt;，\&lt;，\&gt;=，\&lt;=，==，!=
        //关系运算符最终结果：要么是true要么是false
        System.out.println(4\&gt;9);//false
        System.out.println(4\&lt;9);//true
        System.out.println(4\&gt;=9);//false
        System.out.println(4\&lt;=9);//true
        System.out.println(4==9);//false
        System.out.println(4!=9);//true
        System.out.println((5\&lt;9)!=(6==8));//true
    &#125;
&#125;
</code></pre>
<h1 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h1><p>&amp;，|， &amp;&amp;，||，!，^</p>
<p>逻辑运算符：进行逻辑运算的，运算符左右连接的都是 布尔类型的操作数，最终表达式的结果是布尔值：要么是true，要么false</p>
<p>代码：</p>
<pre><code class="java">public class TestOpe09&#123;
    public static void main(String[] args)&#123;
        // 逻辑与 ：&amp; 规律：只要有一个操作数是false，那么结果一定是false
        System.out.println(true&amp;true);
        System.out.println(true&amp;false);
        System.out.println(false&amp;false);
        System.out.println(false&amp;true);
        
        // 短路与：&amp;&amp; 规律：效率高一些，只要第一个表达式是false，那么第二个表达式就不用计算了，结果一定是false
        System.out.println(true&amp;&amp;true);
        System.out.println(true&amp;&amp;false);
        System.out.println(false&amp;&amp;false);
        System.out.println(false&amp;&amp;true);
        
        // 逻辑或：\| 规律：只要有一个操作数是true，那么结果一定是true
        System.out.println(true\|true);
        System.out.println(true\|false);
        System.out.println(false\|false);
        System.out.println(false\|true);
        
        // 短路或：\|\| 规律：效率高一些，只要第一个表达式是true，那么第二个表达式就不用计算了，结果一定是true
        System.out.println(true\|\|true);
        System.out.println(true\|\|false);
        System.out.println(false\|\|false);
        System.out.println(false\|\|true);
        
        //逻辑非： ! 规律：相反结果
        System.out.println(!true);//false
        System.out.println(!false);//true
        
        //逻辑异或： \^ 规律：两个操作数相同，结果为false，不相同，结果为true
        System.out.println(true\^true);
        System.out.println(true\^false);
        System.out.println(false\^false);
        System.out.println(false\^true);
    &#125;
&#125;
</code></pre>
<p>再做一个加深的练习：看代码 说结果：</p>
<pre><code class="java">public class TestOpe10&#123;
    public static void main(String[] args)&#123;
        int i=8;
        System.out.println((5\&gt;7)&amp;&amp;(i++==2)); //false
        System.out.println(i); //8


        int a=8;
        System.out.println((5\&gt;7)&amp;(a++==2)); //false
        System.out.println(a); //9


        int m=8;
        System.out.println((5\&lt;7)&amp;&amp;(m++==2)); //false
        System.out.println(m); //9

        int b=2;
        System.out.println((5\&lt;7)&amp;(b++==2)); //true
        System.out.println(b); //3

        int c=2;
        System.out.println((5\&lt;7)&amp;(++c==2)); //false
        System.out.println(c); //3
    &#125;
&#125;
</code></pre>
<h1 id="条件运算符"><a href="#条件运算符" class="headerlink" title="条件运算符"></a>条件运算符</h1><p>【1】条件运算符：又称： 三元运算符&#x2F;三目运算符</p>
<p>【2】格式：</p>
<p>a?b:c</p>
<p>其中a是一个布尔类型的表达式，返回结果要么是true要么false，通过a的结果决定最终表达式的结果:</p>
<p>如果a的结果是true，那么表达式最终结果为b</p>
<p>如果a的结果是false，那么表达式最终结果为c</p>
<p>代码：</p>
<pre><code class="java">public class TestOpe11&#123;
    public static void main(String[] args)&#123;
        int num = (5\&gt;7)?6:9 ;
        System.out.println(num);

        String str = (4==4)?&quot;你好&quot;:&quot;你不好&quot; ;
        System.out.println(str);

        System.out.println((4==4)?&quot;你好&quot;:&quot;你不好&quot;);
    &#125;
&#125;
</code></pre>
<p>练习：</p>
<ol>
<li>import java.util.*;&#x2F;&#x2F;*代表所有</li>
</ol>
<pre><code class="java"> public class TestOpe12&#123;
 public static void main(String[] args)&#123;
 //实现功能：男孩女孩选择晚饭吃什么，如果意见一致，听男生的，如果意见不一致，听女生的
 
 //1.要让男孩女孩选择晚饭吃什么：
 Scanner sc = new Scanner(System.in);
 System.out.println(&quot;请选择今晚吃什么：1.火锅 2.烧烤 3.麻辣烫 4.西餐&quot;);
 System.out.println(&quot;请男孩选择：&quot;);
 int boyChoice = sc.nextInt();
 System.out.println(&quot;请女孩选择：&quot;);
 int girlChoice = sc.nextInt();
 //2.判断：
 System.out.println(boyChoice==girlChoice?&quot;听男孩的&quot;:&quot;听女孩的&quot;);
 &#125;
 &#125;
</code></pre>
<p>PS:三目运算符可以代替后续我们要学习的if-else</p>
<h1 id="位运算符-了解"><a href="#位运算符-了解" class="headerlink" title="位运算符(了解)"></a>位运算符(了解)</h1><p>位运算符：&amp;，|，^，~ ， &gt;&gt;，&lt;&lt;，&gt;&gt;&gt;</p>
<p>如何区分逻辑运算符和位运算符：</p>
<p>逻辑运算符：左右连接的是布尔类型的操作数</p>
<p>位运算符：左右连接的是具体的数值</p>
<p>【1】&lt;&lt; 左移</p>
<p>3&lt;&lt;2 &#x3D; 12</p>



<p>面试题： 4乘以8最快的方式： 4&lt;&lt;3</p>
<p>【2】&gt;&gt; 有符号右移</p>
<p>6&gt;&gt;2 &#x3D; 1</p>



<p>-6&gt;&gt;2 &#x3D; -2</p>



<p>【3】&gt;&gt;&gt; 无符号右移：</p>
<p>6&gt;&gt;&gt;2 &#x3D; 1</p>



<p>【4】 &amp; 与</p>
<p>6&amp;3 &#x3D; 2</p>



<p>【5】| 或</p>
<p>6|3&#x3D;7</p>



<p>【6】^异或：</p>
<p>6^3 &#x3D; 5</p>



<p>【7】~反：</p>
<p>~6 &#x3D; -7</p>



<p>PS：</p>
<p>byte类型的表数范围的 -128是怎么算出来的</p>
<p>127： 01111111</p>
<p>-128： 10000000</p>
<p>一看就是个负数</p>
<p>减1： 01111111</p>
<p>取反： 10000000 —》2^7 &#x3D; 128</p>
<p>加负号： -128</p>
<h1 id="运算符总结"><a href="#运算符总结" class="headerlink" title="运算符总结"></a>运算符总结</h1>








<h1 id="运算符的优先级别"><a href="#运算符的优先级别" class="headerlink" title="运算符的优先级别"></a>运算符的优先级别</h1>


<p>不需要去刻意的记优先级关系</p>
<p>赋值&lt;三目&lt;逻辑&lt;关系&lt;算术&lt;单目</p>
<p>理解运算符的结合性</p>
<p>PS:实际开发中我们不会写特别复杂的表达式，你要想先算谁就用()</p>
<p>案例：</p>
<p>5&lt;6 | &amp;apos;A&amp;apos;&gt;&amp;apos;a&amp;apos; &amp;&amp; 12*6&lt;&#x3D;45+23&amp;&amp;!true</p>
<p>&#x3D;5&lt;6 | &amp;apos;A&amp;apos;&gt;&amp;apos;a&amp;apos; &amp;&amp; 12*6&lt;&#x3D;45+23&amp;&amp;false</p>
<p>&#x3D; 5&lt;6 | &amp;apos;A&amp;apos;&gt;&amp;apos;a&amp;apos; &amp;&amp;72&lt;&#x3D;68&amp;&amp;false</p>
<p>&#x3D; true|false&amp;&amp;false&amp;&amp;false</p>
<p>&#x3D; true&amp;&amp;false&amp;&amp;false</p>
<p>&#x3D;false&amp;&amp;false</p>
<p>&#x3D;false</p>
]]></content>
      <categories>
        <category>JavaSE</category>
        <category>运算符</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title>第4章_流程控制</title>
    <url>/2022/10/07/Java/%E7%AC%AC4%E7%AB%A0_%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/</url>
    <content><![CDATA[<h1 id="第4章-流程控制"><a href="#第4章-流程控制" class="headerlink" title="第4章_流程控制"></a>第4章_流程控制</h1><h1 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h1><p>【1】流程控制的作用：</p>
<p>流程控制语句是用来控制程序中各语句执行顺序的语句，可以把语句组合成能完成一定功能的小逻辑模块。</p>
<p>【2】控制语句的分类：</p>
<p>控制语句分为三类：顺序、选择和循环。</p>
<p>“顺序结构”代表“先执行a，再执行b”的逻辑。</p>
<p>“条件判断结构”代表“如果…，则…”的逻辑。</p>
<p>“循环结构”代表“如果…，则再继续…”的逻辑。</p>
<p>三种流程控制语句就能表示所有的事情！不信，你可以试试拆分你遇到的各种事情。这三种基本逻辑结构是相互支撑的，它们共同构成了算法的基本结构，无论怎样复杂的逻辑结构，都可以通过它们来表达。所以任何一种高级语言都具备上述两种结构。</p>
<p>本章是大家真正进入编程界的“门票”。</p>
<p>【3】流程控制的流程：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC4%E7%AB%A0_%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/0be7aaf463c4b8bcab05594f71875ce8.png" class="">


<h1 id="分支结构-选择结构"><a href="#分支结构-选择结构" class="headerlink" title="分支结构(选择结构)"></a>分支结构(选择结构)</h1><h1 id="if"><a href="#if" class="headerlink" title="if"></a>if</h1><h3 id="单分支"><a href="#单分支" class="headerlink" title="单分支"></a>单分支</h3><p>【1】语法结构:</p>
<table>
<thead>
<tr>
<th>if(布尔表达式){   语句块  }</th>
</tr>
</thead>
</table>
<p>if语句对布尔表达式进行一次判定，若判定为真，则执行{}中的语句块，否则跳过该语句块。流程图如图所示：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC4%E7%AB%A0_%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/0931341f710ef8def2eeccb5d15e57c6.png" class="">


<p>【2】代码：</p>
<pre><code class="java">public class TestIf01&#123;
    public static void main(String[] args)&#123;
        //实现一个功能：给出三个数（1-6），对三个数求和计算，根据和的大小来分配不同的奖品
        //1.给出三个数：
        int num1 = 6;
        int num2 = 2;
        int num3 = 3;
        //2.求和
        int sum = 0;
        sum += num1;
        sum += num2;
        sum += num3;
        System.out.println(&quot;和为：&quot;+sum);

        //3.根据和判断奖品：
        //如果和大于等于14，那么就是一等奖
        if(sum\&gt;=14)&#123;
            System.out.println(&quot;一等奖&quot;);
            System.out.println(&quot;恭喜你很幸运，中了一等奖&quot;);
        &#125;

        if(sum\&gt;=10&amp;&amp;sum\&lt;14)&#123;
            System.out.println(&quot;二等奖&quot;);
        &#125;

        if(sum\&gt;=6&amp;&amp;sum\&lt;10)&#123;
            System.out.println(&quot;三等奖&quot;);
        &#125;

        if(sum\&lt;6)&#123;
            System.out.println(&quot;四等奖&quot;);
        &#125;

        /\*
            if-单分支：
                （1）结构：
                if(条件表达式，这个表达式的结果是布尔值：要么是false，要么是true)&#123;
                    //如果上面()中的表达式返回结果是true，那么执行&#123;&#125;中代码
                    //如果上面()中的表达式返回结果是false ，那么不执行&#123;&#125;中代码
                    //PS:&#123;&#125;中的代码是否执行，取决于()中表达式的返回结果
                &#125;
        （2）上面的代码中，我用四个单分支拼凑出四个选择，每个选择是独立的，依次判断执行的
            （3）if后面的()中的条件，要按照自己需求尽量完善
            （4）&#123;&#125;可以省略不写,但是一旦省略，这个if就只负责后面的一句话，所以我们不建议初学者省略
            \*/
    &#125;
&#125;
</code></pre>
<h3 id="多分支"><a href="#多分支" class="headerlink" title="多分支"></a>多分支</h3><p>【1】语法结构：</p>
<table>
<thead>
<tr>
<th>if(布尔表达式1) {   语句块1;  } else if(布尔表达式2) {   语句块2;  }……  else if(布尔表达式n){   语句块n;  } else {   语句块n+1;  }</th>
</tr>
</thead>
</table>
<p>当布尔表达式1为真时，执行语句块1；否则，判断布尔表达式2，当布尔表达式2为真时，执行语句块2；否则，继续判断布尔表达式3······；如果1~n个布尔表达式均判定为假时，则执行语句块n+1，也就是else部分。流程图如图所示：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC4%E7%AB%A0_%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/c88bacdaa34dd27e9d243e5982d3ed6f.png" class="">


<p>【2】数轴分析：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC4%E7%AB%A0_%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/7dd5d0a3ce4defddad8b915dbd61c4fd.png" class="">


<p>【3】代码：</p>
<pre><code class="java">public class TestIf02&#123;
    public static void main(String[] args)&#123;
        //实现一个功能：给出三个数（1-6），对三个数求和计算，根据和的大小来分配不同的奖品
        //1.给出三个数：
        int num1 = 6;
        int num2 = 4;
        int num3 = 2;
        //2.求和
        int sum = 0;
        sum += num1;
        sum += num2;
        sum += num3;
        System.out.println(&quot;和为：&quot;+sum);

        //3.根据和判断奖品：
        /\*
            利用一个多分支
            【1】结构：
            if()&#123;

            &#125;else if()&#123;

            &#125;else if()&#123;

            &#125;...
                else&#123;

                &#125;
        【2】else:隐藏了一个条件，跟上面分支条件表达式相反的功能 (详见数轴分析)
            【3】多分支：好处：只要满足一个 分支以后，后面的分支就不需要判断了 --》效率高
            【4】我们写代码的时候，尽量保证else的存在--》else分支相当于“兜底”“备胎”的作用，别的分支都不走，就会走这个分支了
            \*/
            if(sum\&gt;=14)&#123;
                System.out.println(&quot;一等奖&quot;);
            &#125;else if(sum\&gt;=10)&#123;//隐藏了sum\&lt;14
                System.out.println(&quot;二等奖&quot;);
            &#125;else if(sum\&gt;=6)&#123;//隐藏了sum\&lt;10
                System.out.println(&quot;三等奖&quot;);
            &#125;else&#123;//隐藏了sum\&lt;6
                System.out.println(&quot;四等奖&quot;);
            &#125;



    &#125;
&#125;
</code></pre>
<h3 id="双分支"><a href="#双分支" class="headerlink" title="双分支"></a>双分支</h3><p>【1】语法结构:</p>
<table>
<thead>
<tr>
<th>if(布尔表达式){  语句块1  }else{   语句块2  }</th>
</tr>
</thead>
</table>
<p>当布尔表达式为真时，执行语句块1，否则，执行语句块2。也就是else部分。流程图如图所示：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC4%E7%AB%A0_%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/27925a9f266f6f323822dfd891938abf.png" class="">


<h3 id="随机数"><a href="#随机数" class="headerlink" title="随机数"></a>随机数</h3><p>随机数：这个数在生成之前我们不确定这个数是多少，不可知</p>
<p>在java中依靠一个类：Math类帮助我们生成，这个类中有一个方法专门用来生成随机数：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC4%E7%AB%A0_%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/dc25d09059fb76e3d1c8468c2bc3b071.png" class="">


<p>Math.random() ——-&gt; [0.0,1.0)</p>
<p>Math.random()*6 —–&gt;[0.0,6.0)</p>
<p>(int)(Math.random()*6) —–&gt;[0,5]</p>
<p>(int)(Math.random()*6) +1 —–&gt;[1,6]</p>
<p>应用到程序中：</p>
<pre><code class="java">int num1 = (int)(Math.random()\*6) +1;
int num2 = (int)(Math.random()\*6) +1;
int num3 = (int)(Math.random()\*6) +1;
</code></pre>
<p>练习：</p>
<p>[32,98] - [0,66]+32 - (int)(Math.random()*67) + 32</p>
<h3 id="分支的嵌套使用"><a href="#分支的嵌套使用" class="headerlink" title="分支的嵌套使用"></a>分支的嵌套使用</h3><p>分支结构练习1</p>
<p>练习：</p>
<p>会员购物时，不同积分享受的折扣不同，规则如下：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC4%E7%AB%A0_%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/83f88cbff6a2d8323bd5195d7274fb6e.png" class="">


<p>计算会员购物时获得的折扣，效果如下：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC4%E7%AB%A0_%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/84cd71a572646a9eb1d109050b80331c.png" class="">


<p>本题主要考的是 程序的优化：</p>
<pre><code class="java">import java.util.Scanner;
public class TestIf04&#123;
    public static void main(String[] args)&#123;
        //1.给出积分：
        Scanner sc = new Scanner(System.in);
        System.out.print(&quot;请输入会员积分：&quot;);

        //先判断键盘录入的数据是不是int类型的
        if(sc.hasNextInt()==true)&#123;//是int类型数据：
            //将这个int类型的数据接收：
            int score = sc.nextInt();
            //判断这个积分是否是正数：
            if(score\&gt;=0)&#123;
                String discount = &quot;&quot;;
                //2.根据积分判断折扣：
                if(score\&gt;=8000)&#123;
                    discount = &quot;0.6&quot;;
                &#125;else if(score\&gt;=4000)&#123;
                    discount = &quot;0.7&quot;;
                &#125;else if(score\&gt;=2000)&#123;
                    discount = &quot;0.8&quot;;
                &#125;else&#123;
                    discount = &quot;0.9&quot;;
                &#125;
                System.out.println(&quot;该会员享受的折扣为：&quot;+discount);

            &#125;else&#123;//score\&lt;0
                System.out.println(&quot;对不起，你录入的积分是负数！不符合需求！&quot;);
            &#125;
        &#125;else&#123;//不是int类型的数据
            System.out.println(&quot;你录入的积分不是整数！&quot;);
        &#125;

    &#125;
&#125;
</code></pre>
<p>分支结构练习2</p>
<p>练习：</p>
<p>小朋友搬桌子：</p>
<p>年龄大于7岁，可以搬桌子；</p>
<p>如果年龄大于5岁，性别是男，可以搬桌子；</p>
<p>否则不可以搬动桌子，提示：你还太小了</p>
<p>本题主要考的是：逻辑</p>
<p>方式1：性别用0或者1接收：</p>
<pre><code class="java">import java.util.Scanner;
public class TestIf05&#123;
    public static void main(String[] args)&#123;
        //1.录入小朋友的年龄：
        Scanner sc = new Scanner(System.in);
        System.out.println(&quot;请录入小朋友的年龄：&quot;);
        int age = sc.nextInt();

        //2.根据年龄判断：
        if(age\&gt;=7)&#123;
            System.out.println(&quot;yes&quot;);
        &#125;else if(age\&gt;=5)&#123;
            //录入小朋友的性别；
            System.out.println(&quot;请录入小朋友的性别：男：1 女 ：0&quot;);
            int sex = sc.nextInt();
            if(sex==1)&#123;//男生
                System.out.println(&quot;yes&quot;);
            &#125;else&#123;//女孩
                System.out.println(&quot;no&quot;);
            &#125;
        &#125;else&#123;//age\&lt;5
            System.out.println(&quot;no&quot;);
        &#125;
    &#125;
&#125;
</code></pre>
<p>方式2：性别用男或者女接收：</p>
<pre><code class="java">import java.util.Scanner;
public class TestIf06&#123;
    public static void main(String[] args)&#123;
        //1.录入小朋友的年龄：
        Scanner sc = new Scanner(System.in);
        System.out.println(&quot;请录入小朋友的年龄：&quot;);
        int age = sc.nextInt();

        //2.根据年龄判断：
        if(age\&gt;=7)&#123;
            System.out.println(&quot;yes&quot;);
        &#125;else if(age\&gt;=5)&#123;
            //录入小朋友的性别；
            System.out.println(&quot;请录入小朋友的性别：&quot;);
            String str = sc.next();
            char sex = str.charAt(0);
            if(sex==&#39;男&#39;)&#123;
                System.out.println(&quot;yes&quot;);
            &#125;else&#123;
                System.out.println(&quot;no&quot;);
            &#125;
        &#125;else&#123;//age\&lt;5
            System.out.println(&quot;no&quot;);
        &#125;
    &#125;
&#125;
</code></pre>
<h2 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h2><p>【1】switch多分支结构(多值情况)</p>
<p>语法结构：</p>
<table>
<thead>
<tr>
<th>switch (表达式) {   case 值1:   语句序列1;   [break];   case 值2:   语句序列2;   [break];   … … … … …   [default:默认语句;]  }</th>
</tr>
</thead>
</table>
<p>switch语句会根据表达式的值从相匹配的case标签处开始执行，一直执行到break语句处或者是switch语句的末尾。如果表达式的值与任一case值不匹配，则进入default语句（如果存在default语句的情况）。根据表达式值的不同可以执行许多不同的操作。switch语句中case标签在JDK1.5之前必须是整数（long类型除外）或者枚举，不能是字符串，在JDK1.7之后允许使用字符串(String)。大家要注意，当布尔表达式是等值判断的情况，可以使用if-else if-else多分支结构或者switch结构，如果布尔表达式区间判断的情况，则只能使用if-else if-else多分支结构。switch多分支结构的流程图如图所示：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC4%E7%AB%A0_%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/2f1d12c7b2e144d52b36c7aace3d6024.png" class="">


<p>【2】练习</p>
<pre><code class="java">public class TestSwitch&#123;
    public static void main(String[] args)&#123;
        /\*
            实现一个功能：
            根据给出的学生分数，判断学生的等级：
            \&gt;=90 -----A
            \&gt;=80 -----B
            \&gt;=70 -----C
            \&gt;=60 -----D
            \&lt;60 -----E

            用if分支：
            if(score\&gt;=90)&#123;

            &#125;else if(score\&gt;=80)&#123;

            &#125;
        \*/
            //1.给出学生的成绩：
            int score = 167;
        //2.根据成绩判断学生的等级：
        switch(score/10)&#123;
            case 10 :
            case 9 : System.out.println(&quot;A级&quot;);break;
            case 8 : System.out.println(&quot;B级&quot;);break;
            case 7 : System.out.println(&quot;C级&quot;);break;
            case 6 : System.out.println(&quot;D级&quot;);break;
            default:System.out.println(&quot;成绩错误&quot;);break;
            case 5 :
            case 4 :
            case 3 :
            case 2 :
            case 1 :
            case 0 : System.out.println(&quot;E级&quot;);break;

        &#125;
        /\*
            【1】语法结构：
            switch()&#123;
                case \* :
                case \* :
                    .......
            &#125;
        【2】switch后面是一个()，()中表达式返回的结果是一个等值，这个等值的类型可以为：
            int,byte,short,char,String,枚举类型
            【3】这个()中的等值会依次跟case后面的值进行比较，如果匹配成功，就执行:后面的代码
            【4】为了防止代码的“穿透”效果：在每个分支后面加上一个关键词break，遇到break这个分支就结束了
            【5】类似else的“兜底”“备胎”的分支：default分支
            【6】default分支可以写在任意的位置上，但是如果没有在最后一行，后面必须加上break关键字，
            如果在最后一行的话，break可以省略
            【7】相邻分支逻辑是一样的，那么就可以只保留最后一个分支，上面的都可以省去不写了
            【8】switch分支和if分支区别：
            表达式是等值判断的话--》if ，switch都可以
            如果表达式是区间判断的情况---》if最好
            【9】switch应用场合：就是等值判断，等值的情况比较少的情况下
            \*/
    &#125;
&#125;
</code></pre>
<h1 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h1><h2 id="while"><a href="#while" class="headerlink" title="while"></a>while</h2><p>【1】语法结构：</p>
<table>
<thead>
<tr>
<th>while (布尔表达式) {   循环体;  }</th>
</tr>
</thead>
</table>
<p>在循环刚开始时，会计算一次“布尔表达式”的值，若条件为真，执行循环体。而对于后来每一次额外的循环，都会在开始前重新计算一次。</p>
<p>语句中应有使循环趋向于结束的语句，否则会出现无限循环–––”死”循环。</p>
<p>while循环结构流程图如图所示:</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC4%E7%AB%A0_%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/d9a799db990ed9073c404c284874e3c7.png" class="">


<p>【2】练习：1+2+3+4+5</p>
<pre><code class="java">public class TestWhile&#123;
    public static void main(String[] args)&#123;
        //功能：1+2+3+4+5
        //1.定义变量：
        int num1 = 1;
        int num2 = 2;
        int num3 = 3;
        int num4 = 4;
        int num5 = 5;
        //2.定义一个求和变量，用来接收和：
        int sum = 0;
        sum += num1;
        sum += num2;
        sum += num3;
        sum += num4;
        sum += num5;

        //3.输出和
        System.out.println(sum);
    &#125;
&#125;
</code></pre>
<p>上述代码缺点：变量的定义个数太多了</p>
<p>解决：</p>
<pre><code class="java">public class TestWhile&#123;
    public static void main(String[] args)&#123;
        //功能：1+2+3+4+5
        //1.定义变量：
        int num = 1;
        //2.定义一个求和变量，用来接收和：
        int sum = 0;
        sum += num;
        num++;
        sum += num;
        num++;
        sum += num;
        num++;
        sum += num;
        num++;
        sum += num;
        num++;

        //3.输出和
        System.out.println(sum);
    &#125;
&#125;
</code></pre>
<p>上述代码缺点：重复写的代码太多了</p>
<p>解决：—》引入java中循环结构：</p>
<pre><code class="java">public class TestWhile&#123;
    public static void main(String[] args)&#123;
        //功能：1+2+3+4+5
        //1.定义变量：
        int num = 1;**[1]条件初始化**
            //2.定义一个求和变量，用来接收和：
            int sum = 0;
        while(num\&lt;=5)&#123;**[2]条件判断**
            sum += num;**[3]循环体**
                num++;**[4]迭代**
                      &#125;
        //3.输出和
        System.out.println(sum);
    &#125;
&#125;
</code></pre>
<p>总结：</p>
<p>【1】循环作用：将部分代码重复执行。</p>
<p>循环只是提高了程序员编写代码的效率，但是底层执行的时候依然是重复执行。</p>
<p>【2】循环四要素：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC4%E7%AB%A0_%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/ca11475c2f0a778cad36886cf66366a1.png" class="">


<p>初始化谁，就判断谁，判断谁，就迭代谁</p>
<p>执行过程：[1][2][3][4] [2][3][4] [2][3][4]。。。。</p>
<p>【3】循环的执行过程：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC4%E7%AB%A0_%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/2ff230667c913bd5e87743476c334561.png" class="">


<p>【4】验证循环的执行过程：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC4%E7%AB%A0_%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/a5f3022962bd6c9af4a1e9a1e9da5f56.png" class="">


<h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><p>【1】1+2+3+4+5+。。。。+100</p>
<p>【2】2+4+6+8+。。。。+998+1000</p>
<p>【3】5+10+15+20+。。。+100</p>
<p>【4】99+97+95+。。5+3+1</p>
<p>【5】1*3*5*7*9*11*13</p>
<pre><code class="java">public class TestWhile02&#123;
    public static void main(String[] args)&#123;
        /\*
            【1】1+2+3+4+5+。。。。+100
            int i = 1;
        int sum = 0;
        while(i\&lt;=100)&#123;
            sum += i;
            i++;
        &#125;
        System.out.println(sum);
        【2】2+4+6+8+。。。。+998+1000
            int i = 2;
        int sum = 0;
        while(i\&lt;=1000)&#123;
            sum += i;
            i = i+2;
        &#125;
        System.out.println(sum);
        【3】5+10+15+20+。。。+100
            int i = 5;
        int sum = 0;
        while(i\&lt;=100)&#123;
            sum += i;
            i = i+5;
        &#125;
        System.out.println(sum);

        【4】99+97+95+。。5+3+1
            int i = 99;
        int sum = 0;
        while(i\&gt;=1)&#123;
            sum += i;
            i = i-2;
        &#125;
        System.out.println(sum);
        【5】1\*3\*5\*7\*9\*11\*13

            \*/
            int i = 1;
        int result = 1;
        while(i\&lt;=13)&#123;
            result \*= i;
            i = i+2;
        &#125;
        System.out.println(result);
    &#125;
&#125;
</code></pre>
<h2 id="do-while"><a href="#do-while" class="headerlink" title="do-while"></a>do-while</h2><p>【1】语法结构：</p>
<table>
<thead>
<tr>
<th>do {   循环体;   } while(布尔表达式) ;</th>
</tr>
</thead>
</table>
<p>do-while循环结构会先执行循环体，然后再判断布尔表达式的值，若条件为真，执行循环体，当条件为假时结束循环。do-while循环的循环体至少执行一次。do-while循环结构流程图如图所示：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC4%E7%AB%A0_%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/0a5138cc1b27bf3150998a807c0084ff.png" class="">


<p>【2】代码：</p>
<pre><code class="java">public class TestDoWhile&#123;
    public static void main(String[] args)&#123;
        //1+2+3+4+...100
        //while方式:
        /\*
            int i = 101;
        int sum = 0;
        while(i\&lt;=100)&#123;
            sum += i;
            i++;
        &#125;
        System.out.println(i);//101
        System.out.println(sum);//0
        \*/
            //do-while方式：

            int i = 101;
        int sum = 0;
        do&#123;
            sum += i;
            i++;
        &#125;while(i\&lt;=100);//一定要注意写这个分号，否则编译出错
        System.out.println(i);//102
        System.out.println(sum);//101
        /\*
            【1】while和do-while的区别:
        while:先判断，再执行
            do-while:先执行，再判断---》至少被执行一次，从第二次开始才进行判断
                【2】什么场合使用do-while:

        while(考试是否通过)&#123;
            考试；
        &#125;
        \---》不合适
            do&#123;
                考试；
            &#125;while(考试是否通过);
        \---》合适
            \*/

    &#125;
&#125;
</code></pre>
<h2 id="for"><a href="#for" class="headerlink" title="for"></a>for</h2><p>【1】语法结构：</p>
<table>
<thead>
<tr>
<th>for (初始表达式; 布尔表达式; 迭代因子) {   循环体;  }</th>
</tr>
</thead>
</table>
<p>for循环语句是支持迭代的一种通用结构，是最有效、最灵活的循环结构。for循环在第一次反复之前要进行初始化，即执行初始表达式；随后，对布尔表达式进行判定，若判定结果为true，则执行循环体，否则，终止循环；最后在每一次反复的时候，进行某种形式的“步进”，即执行迭代因子。</p>
<ol>
<li>初始化部分设置循环变量的初值</li>
<li>条件判断部分为任意布尔表达式</li>
<li>迭代因子控制循环变量的增减</li>
</ol>
<p>for循环在执行条件判定后，先执行的循环体部分，再执行步进。</p>
<p>for循环结构的流程图如图所示：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC4%E7%AB%A0_%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/e65934410d1164966962fc0ec10b942f.png" class="">


<p>【2】代码：</p>
<pre><code class="java">public class TestFor01&#123;
    public static void main(String[] args)&#123;
        //1+2+3+..+100
        //while:
        /\*int i = 1;
        int sum = 0;
        while(i\&lt;=100)&#123;
            sum += i;
            i++;
        &#125;
        System.out.println(sum);
        \*/

            //for:
            int sum = 0;
        int i;
        for(i = 1;i\&lt;=100;i++)&#123;
            sum += i;
        &#125;
        System.out.println(sum);
        System.out.println(i);

        /\*
            【1】for的结构：
            for(条件初始化;条件判断;迭代)&#123;
                循环体；
            &#125;

        【2】i的作用域：作用范围：离变量最近&#123;&#125; ---\&gt;可以自己去控制
            【3】for循环格式特别灵活：格式虽然很灵活，但是我们自己写代码的时候不建议灵活着写。
            for(;;)&#123;&#125; --\&gt;死循环

                int i = 1;
        for(;i\&lt;=100;)&#123;
            sum += i;
            i++;
        &#125;

        【4】死循环：
            for(;;)&#123;&#125;

        while(true)&#123;&#125;

        do&#123;

        &#125;while(true);

        【5】循环分为两大类：
            第一类：当型 while()&#123;&#125; for(;;)&#123;&#125;
        第二类：直到型 do&#123;&#125;while();

        【6】以后常用：for循环
            【7】do-while,while,for循环谁的效率高？ 一样高
                \*/
                &#125;
&#125;
</code></pre>
<h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><p>在任何循环语句的主体部分，均可用break控制循环的流程。break用于强行退出循环，不执行循环中剩余的语句。</p>
<p>continue 语句用在循环语句体中，用于终止某次循环过程，即跳过循环体中尚未执行的语句，接着进行下一次是否执行循环的判定。</p>
<p>return的作用,结束当前所在方法的执行.</p>
<h3 id="break"><a href="#break" class="headerlink" title="break"></a>break</h3><p>【1】通过练习感受break的作用：作用：停止循环：</p>
<pre><code class="java">public class TestFor02&#123;
    public static void main(String[] args)&#123;
        //功能：求1-100的和，当和第一次超过300的时候，停止程序
        int sum = 0;
        for(int i=1;i\&lt;=100;i++)&#123;
            sum += i;
            if(sum\&gt;300)&#123;//当和第一次超过300的时候
                //停止循环
                break;//停止循环
            &#125;
            System.out.println(sum);
        &#125;

    &#125;
&#125;
</code></pre>
<p>【2】加深理解：</p>
<pre><code class="java">public class TestFor03&#123;
    public static void main(String[] args)&#123;
        //break的作用：停止最近的循环
        /\*
            for(int i=1;i\&lt;=100;i++)&#123;
                System.out.println(i);
                if(i==36)&#123;
                    break;//1-36
                &#125;
            &#125;
        \*/
            for(int i=1;i\&lt;=100;i++)&#123;
                System.out.println(i);
                while(i==36)&#123;
                    break; //1-100 ---》break停止的是while循环，而不是外面的for循环
                &#125;
            &#125;
    &#125;
&#125;
</code></pre>
<p>【3】break带标签的使用：</p>
<pre><code class="java">public class TestFor04&#123;
    public static void main(String[] args)&#123;
        outer: ----》定义标签结束的位置
            for(int i=1;i\&lt;=100;i++)&#123;
                System.out.println(i);
                while(i==36)&#123;
                    break outer; ----》根据标签来结束循环
                &#125;
            &#125;
    &#125;
&#125;
</code></pre>
<p>多层循环也可以使用标签，按照自己的需求去设定即可：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC4%E7%AB%A0_%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/edd6160d15c42695164e614a174da464.png" class="">


<h3 id="continue"><a href="#continue" class="headerlink" title="continue"></a>continue</h3><p>【1】通过案例感受continue的作用：结束本次循环，继续下一次循环</p>
<pre><code class="java">public class TestFor05&#123;
    public static void main(String[] args)&#123;
        //功能：输出1-100中被6整除的数：
        //方式1：
        /\*
            for(int i=1;i\&lt;=100;i++)&#123;
                if(i%6==0)&#123;//被6整除
                    System.out.println(i);
                &#125;
            &#125;
        \*/

            //方式2：
            for(int i=1;i\&lt;=100;i++)&#123;
                if(i%6!=0)&#123;//不被6整除
                    continue;//停止本次循环，继续下一次循环
                &#125;
                System.out.println(i);
            &#125;
    &#125;
&#125;
</code></pre>
<p>【2】加深理解：</p>
<pre><code class="java">public class TestFor06&#123;
    public static void main(String[] args)&#123;
        //continue:结束本次离它近的循环，继续下一次循环
        /\*
            for(int i=1;i\&lt;=100;i++)&#123;
                if(i==36)&#123;
                    continue;//1-100中间没有36
                &#125;
                System.out.println(i);
            &#125;
        \*/

            for(int i=1;i\&lt;=100;i++)&#123;
                while(i==36)&#123;
                    System.out.println(&quot;------&quot;);
                    continue; //1-35+死循环
                &#125;
                System.out.println(i);
            &#125;
    &#125;
&#125;
</code></pre>
<p>【3】continue带标签的使用：</p>
<pre><code class="java">public class TestFor07&#123;
    public static void main(String[] args)&#123;

        outer:
        for(int i=1;i\&lt;=100;i++)&#123;
            while(i==36)&#123;
                continue outer; //1-100没有36
            &#125;
            System.out.println(i);
        &#125;
    &#125;
&#125;
</code></pre>
<img data-src="/2022/10/07/Java/%E7%AC%AC4%E7%AB%A0_%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/fc2cc84a39aeaca59d8b618b6a71a46c.png" class="">


<h3 id="return"><a href="#return" class="headerlink" title="return"></a>return</h3><p>return的作用：跟循环无关，就是程序中遇到return那么return所在的那个方法就停止执行了：</p>
<pre><code class="java">public class TestFor08&#123;
    public static void main(String[] args)&#123;
        //return:遇到return结束当前正在执行的方法
        for(int i=1;i\&lt;=100;i++)&#123;
            while(i==36)&#123;
                return;
            &#125;
            System.out.println(i);
        &#125;

        System.out.println(&quot;-----&quot;);
    &#125;
&#125;
</code></pre>
<h2 id="循环练习"><a href="#循环练习" class="headerlink" title="循环练习"></a>循环练习</h2><p>【1】练习1：</p>
<pre><code class="java">public class TestFor09&#123;
    public static void main(String[] args)&#123;
        /\* 输出1-100中被5整除的数,每行输出6个\*/
            //引入一个计数器：
            int count = 0;//初始值为0
        for(int i=1;i\&lt;=100;i++)&#123;
            if(i%5==0)&#123;//被5整除的数
                System.out.print(i+&quot;\\t&quot;);
                count++;//每在控制台输出一个数，count就加1操作
                if(count%6==0)&#123;
                    System.out.println();//换行
                &#125;
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<p>【2】练习2：</p>
<pre><code class="java">import java.util.Scanner;
public class TestFor10&#123;
    public static void main(String[] args)&#123;
        /\*
            实现一个功能：
            【1】请录入10个整数，当输入的数是666的时候，退出程序。
            【2】判断其中录入正数的个数并输出。
            【3】判断系统的退出状态：是正常退出还是被迫退出。
            \*/
            //引入一个计数器：
            int count = 0;
        //引入一个布尔类型的变量：
        boolean flag = true; //---》理解为一个“开关”，默认情况下开关是开着的
        Scanner sc = new Scanner(System.in);
        for(int i=1;i\&lt;=10;i++)&#123;//i:循环次数
            System.out.println(&quot;请录入第&quot;+i+&quot;个数：&quot;);
            int num = sc.nextInt();
            if(num\&gt;0)&#123;//录入的正数
                count++;
            &#125;
            if(num==666)&#123;
                flag = false;//当遇到666的时候，“开关”被关上了
                //退出循环：
                break;
            &#125;

        &#125;

        System.out.println(&quot;你录入的正数的个数为：&quot;+count);


        if(flag)&#123;//flag==true
            System.out.println(&quot;正常退出！&quot;);
        &#125;else&#123;//flag==false
            System.out.println(&quot;被迫退出！&quot;);
        &#125;



    &#125;
&#125;
</code></pre>
<h2 id="循环的嵌套使用"><a href="#循环的嵌套使用" class="headerlink" title="循环的嵌套使用"></a>循环的嵌套使用</h2><h3 id="双重循环"><a href="#双重循环" class="headerlink" title="双重循环"></a>双重循环</h3><p>乘法口诀</p>
<p>乘法口诀：</p>
<p>1*1&#x3D;1</p>
<p>1*2&#x3D;2 2*2&#x3D;4</p>
<p>1*3&#x3D;3 2*3&#x3D;6 3*3&#x3D;9</p>
<p>1*4&#x3D;4 2*4&#x3D;8 3*4&#x3D;12 4*4&#x3D;16</p>
<p>1*5&#x3D;5 2*5&#x3D;10 3*5&#x3D;15 4*5&#x3D;20 5*5&#x3D;25</p>
<p>1*6&#x3D;6 2*6&#x3D;12 3*6&#x3D;18 4*6&#x3D;24 5*6&#x3D;30 6*6&#x3D;36</p>
<p>1*7&#x3D;7 2*7&#x3D;14 3*7&#x3D;21 4*7&#x3D;28 5*7&#x3D;35 6*7&#x3D;42 7*7&#x3D;49</p>
<p>1*8&#x3D;8 2*8&#x3D;16 3*8&#x3D;24 4*8&#x3D;32 5*8&#x3D;40 6*8&#x3D;48 7*8&#x3D;56 8*8&#x3D;64</p>
<p>1*9&#x3D;9 2*9&#x3D;18 3*9&#x3D;27 4*9&#x3D;36 5*9&#x3D;45 6*9&#x3D;54 7*9&#x3D;63 8*9&#x3D;72 9*9&#x3D;81</p>
<p>代码：</p>
<pre><code class="java">public class TestFor11&#123;
    public static void main(String[] args)&#123;
        //1\*6=6 2\*6=12 3\*6=18 4\*6=24 5\*6=30 6\*6=36
        /\*
            System.out.print(&quot;1\*6=6&quot;+&quot;\\t&quot;);
        System.out.print(&quot;2\*6=12&quot;+&quot;\\t&quot;);
        System.out.print(&quot;3\*6=18&quot;+&quot;\\t&quot;);
        System.out.print(&quot;4\*6=24&quot;+&quot;\\t&quot;);
        System.out.print(&quot;5\*6=30&quot;+&quot;\\t&quot;);
        System.out.print(&quot;6\*6=36&quot;+&quot;\\t&quot;);

        for(int i=1;i\&lt;=6;i++)&#123;
            System.out.print(i+&quot;\*6=&quot;+i\*6+&quot;\\t&quot;);
        &#125;
        //换行
        System.out.println();

        //1\*7=7 2\*7=14 3\*7=21 4\*7=28 5\*7=35 6\*7=42 7\*7=49
        for(int i=1;i\&lt;=7;i++)&#123;
            System.out.print(i+&quot;\*7=&quot;+i\*7+&quot;\\t&quot;);
        &#125;
        //换行
        System.out.println();

        //1\*8=8 2\*8=16 3\*8=24 4\*8=32 5\*8=40 6\*8=48 7\*8=56 8\*8=64
        for(int i=1;i\&lt;=8;i++)&#123;
            System.out.print(i+&quot;\*8=&quot;+i\*8+&quot;\\t&quot;);
        &#125;
        //换行
        System.out.println();
        \*/

            for(int j=1;j\&lt;=9;j++)&#123;
                for(int i=1;i\&lt;=j;i++)&#123;
                    System.out.print(i+&quot;\*&quot;+j+&quot;=&quot;+i\*j+&quot;\\t&quot;);
                &#125;
                //换行
                System.out.println();
            &#125;
    &#125;
&#125;
</code></pre>
<p>1*9&#x3D;9 2*9&#x3D;18 3*9&#x3D;27 4*9&#x3D;36 5*9&#x3D;45 6*9&#x3D;54 7*9&#x3D;63 8*9&#x3D;72 9*9&#x3D;81</p>
<p>1*8&#x3D;8 2*8&#x3D;16 3*8&#x3D;24 4*8&#x3D;32 5*8&#x3D;40 6*8&#x3D;48 7*8&#x3D;56 8*8&#x3D;64</p>
<p>1*7&#x3D;7 2*7&#x3D;14 3*7&#x3D;21 4*7&#x3D;28 5*7&#x3D;35 6*7&#x3D;42 7*7&#x3D;49</p>
<p>1*6&#x3D;6 2*6&#x3D;12 3*6&#x3D;18 4*6&#x3D;24 5*6&#x3D;30 6*6&#x3D;36</p>
<p>1*5&#x3D;5 2*5&#x3D;10 3*5&#x3D;15 4*5&#x3D;20 5*5&#x3D;25</p>
<p>1*4&#x3D;4 2*4&#x3D;8 3*4&#x3D;12 4*4&#x3D;16</p>
<p>1*3&#x3D;3 2*3&#x3D;6 3*3&#x3D;9</p>
<p>1*2&#x3D;2 2*2&#x3D;4</p>
<p>1*1&#x3D;1</p>
<p>代码：</p>
<pre><code class="java">public class TestFor12&#123;
    public static void main(String[] args)&#123;

        /\*
            //1\*8=8 2\*8=16 3\*8=24 4\*8=32 5\*8=40 6\*8=48 7\*8=56 8\*8=64
            for(int i=1;i\&lt;=8;i++)&#123;
                System.out.print(i+&quot;\*8=&quot;+i\*8+&quot;\\t&quot;);
            &#125;
        //换行
        System.out.println();


        //1\*7=7 2\*7=14 3\*7=21 4\*7=28 5\*7=35 6\*7=42 7\*7=49
        for(int i=1;i\&lt;=7;i++)&#123;
            System.out.print(i+&quot;\*7=&quot;+i\*7+&quot;\\t&quot;);
        &#125;
        //换行
        System.out.println();

        //1\*6=6 2\*6=12 3\*6=18 4\*6=24 5\*6=30 6\*6=36
        for(int i=1;i\&lt;=6;i++)&#123;
            System.out.print(i+&quot;\*6=&quot;+i\*6+&quot;\\t&quot;);
        &#125;
        //换行
        System.out.println();




        \*/

            for(int j=9;j\&gt;=1;j--)&#123;
                for(int i=1;i\&lt;=j;i++)&#123;
                    System.out.print(i+&quot;\*&quot;+j+&quot;=&quot;+i\*j+&quot;\\t&quot;);
                &#125;
                //换行
                System.out.println();
            &#125;
    &#125;
&#125;
</code></pre>
<p>打印各种形状</p>
<p>【1】长方形：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC4%E7%AB%A0_%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/34a4f4344ea5d5ffd88f932d98827359.png" class="">


<pre><code class="java">for(int j=1;j\&lt;=4;j++)&#123;//j:控制行数
    //\*\*\*\*\*\*\*\*\*
    for(int i=1;i\&lt;=9;i++)&#123;//i:控制\*的个数
        System.out.print(&quot;\*&quot;);
    &#125;
    //换行：
    System.out.println();
&#125;
</code></pre>
<p>【2】距离前面有一定空隙的长方形：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC4%E7%AB%A0_%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/53f97abfc48cab59034a76006c1c1c71.png" class="">


<ol>
<li>for(int j&#x3D;1;j&lt;&#x3D;4;j++){&#x2F;&#x2F;j:控制行数</li>
<li>&#x2F;&#x2F;加入空格：</li>
<li>for(int i&#x3D;1;i&lt;&#x3D;5;i++){&#x2F;&#x2F;i:控制空格的个数</li>
<li>System.out.print(“ “);</li>
<li>}</li>
<li>&#x2F;&#x2F;*********</li>
<li>for(int i&#x3D;1;i&lt;&#x3D;9;i++){&#x2F;&#x2F;i:控制*的个数</li>
<li>System.out.print(“*“);</li>
<li>}</li>
<li>&#x2F;&#x2F;换行：</li>
<li>System.out.println();</li>
<li>}</li>
</ol>
<p>【3】平行四边形：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC4%E7%AB%A0_%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/67d40798af8ec1921f09d49c09d0137c.png" class="">


<ol>
<li>for(int j&#x3D;1;j&lt;&#x3D;4;j++){&#x2F;&#x2F;j:控制行数</li>
<li>&#x2F;&#x2F;加入空格：</li>
<li>for(int i&#x3D;1;i&lt;&#x3D;(9-j);i++){&#x2F;&#x2F;i:控制空格的个数</li>
<li>System.out.print(“ “);</li>
<li>}</li>
<li>&#x2F;&#x2F;*********</li>
<li>for(int i&#x3D;1;i&lt;&#x3D;9;i++){&#x2F;&#x2F;i:控制*的个数</li>
<li>System.out.print(“*“);</li>
<li>}</li>
<li>&#x2F;&#x2F;换行：</li>
<li>System.out.println();</li>
<li>}</li>
</ol>
<p>【4】三角形：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC4%E7%AB%A0_%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/49555021efb328437055bea6119ae9f2.png" class="">


<ol>
<li>for(int j&#x3D;1;j&lt;&#x3D;4;j++){&#x2F;&#x2F;j:控制行数</li>
<li>&#x2F;&#x2F;加入空格：</li>
<li>for(int i&#x3D;1;i&lt;&#x3D;(9-j);i++){&#x2F;&#x2F;i:控制空格的个数</li>
<li>System.out.print(“ “);</li>
<li>}</li>
<li>&#x2F;&#x2F;*********</li>
<li>for(int i&#x3D;1;i&lt;&#x3D;(2*j-1);i++){&#x2F;&#x2F;i:控制*的个数</li>
<li>System.out.print(“*“);</li>
<li>}</li>
<li>&#x2F;&#x2F;换行：</li>
<li>System.out.println();</li>
<li>}</li>
</ol>
<p>【5】菱形：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC4%E7%AB%A0_%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/d798118edc1454a1bb0e83bb70d60758.png" class="">


<ol>
<li>&#x2F;&#x2F;上面三角形：</li>
<li>for(int j&#x3D;1;j&lt;&#x3D;4;j++){&#x2F;&#x2F;j:控制行数</li>
<li>&#x2F;&#x2F;加入空格：</li>
<li>for(int i&#x3D;1;i&lt;&#x3D;(9-j);i++){&#x2F;&#x2F;i:控制空格的个数</li>
<li>System.out.print(“ “);</li>
<li>}</li>
<li>&#x2F;&#x2F;*********</li>
<li>for(int i&#x3D;1;i&lt;&#x3D;(2*j-1);i++){&#x2F;&#x2F;i:控制*的个数</li>
<li>System.out.print(“*“);</li>
<li>}</li>
<li>&#x2F;&#x2F;换行：</li>
<li>System.out.println();</li>
<li>}</li>
<li></li>
<li>&#x2F;&#x2F;下面三角形：</li>
<li>for(int j&#x3D;1;j&lt;&#x3D;3;j++){&#x2F;&#x2F;j:控制行数</li>
<li>&#x2F;&#x2F;加入空格：</li>
<li>for(int i&#x3D;1;i&lt;&#x3D;(j+5);i++){&#x2F;&#x2F;i:控制空格的个数</li>
<li>System.out.print(“ “);</li>
<li>}</li>
<li>&#x2F;&#x2F;*********</li>
<li>for(int i&#x3D;1;i&lt;&#x3D;(7-2*j);i++){&#x2F;&#x2F;i:控制*的个数</li>
<li>System.out.print(“*“);</li>
<li>}</li>
<li>&#x2F;&#x2F;换行：</li>
<li>System.out.println();</li>
<li>}</li>
</ol>
<p>【6】空心菱形：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC4%E7%AB%A0_%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/7df2cd3380e772f02c2dcbcc4d6a3438.png" class="">


<ol>
<li>&#x2F;&#x2F;上面三角形：</li>
<li>for(int j&#x3D;1;j&lt;&#x3D;4;j++){&#x2F;&#x2F;j:控制行数</li>
<li>&#x2F;&#x2F;加入空格：</li>
<li>for(int i&#x3D;1;i&lt;&#x3D;(9-j);i++){&#x2F;&#x2F;i:控制空格的个数</li>
<li>System.out.print(“ “);</li>
<li>}</li>
<li>&#x2F;&#x2F;*********</li>
<li>for(int i&#x3D;1;i&lt;&#x3D;(2*j-1);i++){&#x2F;&#x2F;i:控制*的个数</li>
<li>if(i&#x3D;&#x3D;1||i&#x3D;&#x3D;(2*j-1)){</li>
<li>System.out.print(“*“);</li>
<li>}else{</li>
<li>System.out.print(“ “);</li>
<li>}</li>
<li>}</li>
<li>&#x2F;&#x2F;换行：</li>
<li>System.out.println();</li>
<li>}</li>
<li></li>
<li>&#x2F;&#x2F;下面三角形：</li>
<li>for(int j&#x3D;1;j&lt;&#x3D;3;j++){&#x2F;&#x2F;j:控制行数</li>
<li>&#x2F;&#x2F;加入空格：</li>
<li>for(int i&#x3D;1;i&lt;&#x3D;(j+5);i++){&#x2F;&#x2F;i:控制空格的个数</li>
<li>System.out.print(“ “);</li>
<li>}</li>
<li>&#x2F;&#x2F;*********</li>
<li>for(int i&#x3D;1;i&lt;&#x3D;(7-2*j);i++){&#x2F;&#x2F;i:控制*的个数</li>
<li>if(i&#x3D;&#x3D;1||i&#x3D;&#x3D;(7-2*j)){</li>
<li>System.out.print(“*“);</li>
<li>}else{</li>
<li>System.out.print(“ “);</li>
<li>}</li>
<li>}</li>
<li>&#x2F;&#x2F;换行：</li>
<li>System.out.println();</li>
<li>}</li>
</ol>
<p>扩展：菱形打印方式2</p>
<p>【1】实心菱形：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC4%E7%AB%A0_%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/745dd4be231e5197141fa4721b372fa9.png" class="">


<pre><code class="java">public class TestFor14&#123;
    public static void main(String[] args)&#123;
        //先打印出一个正方形，然后某些位置上打印\* 某些位置上打印空格：
        int size = 17;
        int startNum = size/2+1;//起始列号
        int endNum = size/2+1;//结束列号
        //引入一个布尔类型的变量---》理解为“开关”
        boolean flag = true;
        for(int j=1;j\&lt;=size;j++)&#123;
            //\*\*\*\*\*
            for(int i=1;i\&lt;=size;i++)&#123;
                if(i\&gt;=startNum&amp;&amp;i\&lt;=endNum)&#123;
                    System.out.print(&quot;\*&quot;);
                &#125;else&#123;
                    System.out.print(&quot; &quot;);
                &#125;
            &#125;
            //换行
            System.out.println();
            if(endNum==size)&#123;
                flag = false;
            &#125;

            if(flag)&#123;//flag是true相当于在菱形的上半侧 flag是false相当于在菱形的下半侧
                startNum--;
                endNum++;
            &#125;else&#123;
                startNum++;
                endNum--;
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<p>【2】空心菱形：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC4%E7%AB%A0_%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/8938fc30a4da55ff90c902646c105355.png" class="">


<pre><code class="java">public class TestFor14&#123;
    public static void main(String[] args)&#123;
        //先打印出一个正方形，然后某些位置上打印\* 某些位置上打印空格：
        int size = 17;
        int startNum = size/2+1;//起始列号
        int endNum = size/2+1;//结束列号
        //引入一个布尔类型的变量---》理解为“开关”
        boolean flag = true;
        for(int j=1;j\&lt;=size;j++)&#123;
            //\*\*\*\*\*
            for(int i=1;i\&lt;=size;i++)&#123;
                if(i==startNum\|\|i==endNum)&#123;
                    System.out.print(&quot;\*&quot;);
                &#125;else&#123;
                    System.out.print(&quot; &quot;);
                &#125;
            &#125;
            //换行
            System.out.println();
            if(endNum==size)&#123;
                flag = false;
            &#125;

            if(flag)&#123;//flag是true相当于在菱形的上半侧 flag是false相当于在菱形的下半侧
                startNum--;
                endNum++;
            &#125;else&#123;
                startNum++;
                endNum--;
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="三重循环"><a href="#三重循环" class="headerlink" title="三重循环"></a>三重循环</h3><p>百钱买百鸡</p>
<p>【1】二重循环可以帮我们解决：二元一次方程组的问题：</p>
<pre><code class="java">public   class   TestFor15 &#123;
    public   static   void   main (String[] args)&#123;
        for ( int  a=1;a\&lt;=5;a++)&#123;
            for ( int  b=3;b\&lt;=6;b++)&#123;
                if (a+b==7)&#123;
                    System. out .println(a+&quot;----&quot;+b);
                &#125;
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<p>【2】三重循环可以帮我们解决：三元一次方程组的问题：</p>
]]></content>
      <categories>
        <category>JavaSE</category>
        <category>流程控制</category>
      </categories>
      <tags>
        <tag>-JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title>第5章_方法的定义_调用_重载</title>
    <url>/2022/10/07/Java/%E7%AC%AC5%E7%AB%A0_%E6%96%B9%E6%B3%95%E7%9A%84%E5%AE%9A%E4%B9%89_%E8%B0%83%E7%94%A8_%E9%87%8D%E8%BD%BD/</url>
    <content><![CDATA[<h1 id="方法的定义和调用"><a href="#方法的定义和调用" class="headerlink" title="方法的定义和调用"></a>方法的定义和调用</h1><p>【1】什么是方法？</p>
<p>方法(method)就是一段用来完成特定功能的代码片段，类似于其它语言的函数(function)。</p>
<p>方法用于定义该类或该类的实例的行为特征和功能实现。 方法是类和对象行为特征的抽象。方法很类似于面向过程中的函数。面向过程中，函数是最基本单位，整个程序由一个个函数调用组成。面向对象中，整个程序的基本单位是类，方法是从属于类和对象的。</p>
<p>【2】方法声明格式：</p>
<table>
<thead>
<tr>
<th>[修饰符1 修饰符2 …] 返回值类型 方法名(形式参数列表){   Java语句；… … …  }</th>
</tr>
</thead>
</table>
<p>【3】方法的调用方式：</p>
<table>
<thead>
<tr>
<th>对象名.方法名(实参列表)</th>
</tr>
</thead>
</table>
<p>【4】方法的详细说明</p>
<ul>
<li>形式参数：在方法声明时用于接收外界传入的数据。</li>
<li>实参：调用方法时实际传给方法的数据。</li>
<li>返回值：方法在执行完毕后返还给调用它的环境的数据。</li>
<li>返回值类型：事先约定的返回值的数据类型，如无返回值，必须显示指定为为void。</li>
</ul>
<p>【5】代码：</p>
<pre><code class="java">public class TestMethod01&#123;

    //方法的定义：（写方法）
    public static int add(int num1,int num2)&#123;
        int sum = 0;
        sum += num1;
        sum += num2;
        return sum;//将返回值返回到方法的调用处
    &#125;

    public static void main(String[] args)&#123;
        //10+20:
        //方法的调用：（用方法）
        int num = add(10,20);
        System.out.println(num);
        /\*
            int num1 = 10;
        int num2 = 20;
        int sum = 0;
        sum += num1;
        sum += num2;
        System.out.println(sum);
        \*/
            //30+90:
            int sum = add(30,90);
        System.out.println(sum);
        /\*
            int num3 = 30;
        int num4 = 90;
        int sum1 = 0 ;
        sum1 += num3;
        sum1 += num4;
        System.out.println(sum1);
        \*/
            //50+48:
            System.out.println(add(50,48));

    &#125;


&#125;
</code></pre>
<p>【6】总结：</p>
<p>1.方法是：对特定的功能进行提取，形成一个代码片段，这个代码片段就是我们所说的方法</p>
<p>2.方法和方法是并列的关系，所以我们定义的方法不能写到main方法中</p>
<p>3.方法的定义–》格式：</p>
<p>修饰符 方法返回值类型 方法名(形参列表){</p>
<p>方法体;</p>
<p>return 方法返回值;</p>
<p>}</p>
<p>4.方法的作用：提高代码的复用性</p>
<p>5.总结方法定义的格式：</p>
<ol>
<li><p>修饰符: 暂时使用public static —&gt;面向对象一章讲解</p>
</li>
<li><p>方法返回值类型 : 方法的返回值对应的数据类型</p>
</li>
</ol>
<p>数据类型： 可以是基本数据类型（byte,short,int,long,float,double,char,boolean） 也可以是引用数据类型</p>
<ol start="3">
<li><p>方法名 :见名知意，首字母小写，其余遵循驼峰命名， eg: addNum ,一般尽量使用英文来命名</p>
</li>
<li><p>形参列表 :方法定义的时候需要的形式参数 ： int num1, int num2 –&gt;相当于告诉方法的调用者：需要传入几个参数，需要传入的参数的类型</p>
</li>
</ol>
<p>实际参数：方法调用的时候传入的具体的参数： 10,20 –&gt;根据形式参数的需要传入的</p>
<p>5)方法体：具体的业务逻辑代码</p>
<ol start="6">
<li>return 方法返回值;</li>
</ol>
<p>方法如果有返回值的话： return+方法返回值，将返回值返回到方法的调用处</p>
<p>方法没有返回值的话：return可以省略不写了，并且方法的返回值类型为：void</p>
<pre><code class="java">public class TestMethod02&#123;

    public static void add(int num1,int num2)&#123;
        int sum = 0;
        sum += num1;
        sum += num2;
        System.out.println(sum);
        //return;
    &#125;

    public static void main(String[] args)&#123;
        //10+20:
        //方法的调用：（用方法）
        add(10,20);
        //30+90:
        add(30,90);
        //50+48:
        //System.out.println(add(50,48));//报错：TestMethod02.java:22: 错误: 此处不允许使用 &#39;空&#39; 类型

    &#125;

&#125;
</code></pre>
<p>什么时候有返回值，什么时候没有返回值？ 看心情–》看需求</p>
<p>6.方法的定义需要注意什么？</p>
<p>1）形参列表要怎么写：定义几个参数，分别是什么类型的 —》不确定因素我们会当做方法的形参</p>
<ol start="2">
<li>方法到底是否需要返回值 ，如果需要的话，返回值的类型是什么</li>
</ol>
<p>7.方法的调用需要注意什么？</p>
<p>1）实际参数要怎么传入：传入几个参数，传入什么类型的</p>
<p>2） 方法是否有返回值需要接受</p>
<h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p>【1】基本功能：</p>
<pre><code class="java">import java.util.Scanner;
public class TestMethod03&#123;
    public static void main(String[] args)&#123;
        //功能：我心里有一个数，你来猜，看是否猜对
        //1.你猜一个数
        Scanner sc = new Scanner(System.in);
        System.out.println(&quot;请你猜一个数：&quot;);
        int yourGuessNum = sc.nextInt();
        //2.我心里有一个数
        int myHeartNum = 5;
        //3.将两个数比对：
        System.out.println(yourGuessNum==myHeartNum?&quot;猜对了&quot;:&quot;猜错了&quot;);
    &#125;
&#125;
</code></pre>
<p>对猜数功能提取为一个方法：</p>
<pre><code class="java">import java.util.Scanner;
public class TestMethod03&#123;
    public static void main(String[] args)&#123;
        //功能：我心里有一个数，你来猜，看是否猜对
        //1.你猜一个数
        Scanner sc = new Scanner(System.in);
        System.out.println(&quot;请你猜一个数：&quot;);
        int yourGuessNum = sc.nextInt();

        //调用猜数的方法：
        guessNum(yourGuessNum);
    &#125;

    //方法的定义：功能：实现猜数功能：
    public static void guessNum(int yourNum)&#123;
        //我心里有一个数(1-6)
        int myHeartNum = (int)(Math.random()\*6)+1;
        //将两个数比对：
        System.out.println(yourNum==myHeartNum?&quot;猜对了&quot;:&quot;猜错了&quot;);
    &#125;
&#125;
</code></pre>
<h2 id="面试题：两个数交换是否成功"><a href="#面试题：两个数交换是否成功" class="headerlink" title="面试题：两个数交换是否成功"></a>面试题：两个数交换是否成功</h2><p>【1】面试题：请问下面代码中两个数是否交换成功：</p>
<pre><code class="java">
</code></pre>
<p>|———————————————————————————————————————————————————————————————————————————————————————————————————————————-|</p>
<p>结果：没有交换成功：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC5%E7%AB%A0_%E6%96%B9%E6%B3%95%E7%9A%84%E5%AE%9A%E4%B9%89_%E8%B0%83%E7%94%A8_%E9%87%8D%E8%BD%BD/d6adc25927a033764c5d084d040d5d88.png" class="">


<p>原因：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC5%E7%AB%A0_%E6%96%B9%E6%B3%95%E7%9A%84%E5%AE%9A%E4%B9%89_%E8%B0%83%E7%94%A8_%E9%87%8D%E8%BD%BD/2a7e512536fdb2b6389db0fa7b3f959f.png" class="">


<h1 id="方法的重载"><a href="#方法的重载" class="headerlink" title="方法的重载"></a>方法的重载</h1><p>【1】什么是方法的重载：</p>
<p>方法的重载是指一个类中可以定义多个方法名相同，但参数不同的方法。 调用时，会根据不同的参数自动匹配对应的方法。</p>
<p>注意本质：重载的方法，实际是完全不同的方法，只是名称相同而已！</p>
<p>【2】构成方法重载的条件：</p>
<p>❀不同的含义：形参类型、形参个数、形参顺序不同</p>
<p>❀ 只有返回值不同不构成方法的重载</p>
<p>如：int a(String str){}与 void a(String str){}不构成方法重载</p>
<p>❀ 只有形参的名称不同，不构成方法的重载</p>
<p>如：int a(String str){}与int a(String s){}不构成方法重载</p>
<p>【3】代码：</p>
<pre><code class="java">public class TestMethod05&#123;
    public static void main(String[] args)&#123;
        //10+20:
        int sum = add(10,20);
        System.out.println(sum);

        //20+40+80:
        //System.out.println(add(add(20,40),80));
        System.out.println(add(20,40,80));
        //30+60+90+120:
        //System.out.println(add(add(30,60),add(90,120)));
        System.out.println(add(30,60,90,120));
        //9.8+4.7:
        //System.out.println(add(9.8,4.7));
        System.out.println(add(9.8,4.7));
    &#125;

    //定义一个方法：两个数相加：两个int类型数据相加
    public static int add(int num1,int num2)&#123;
        return num1+num2;
    &#125;

    //定义一个方法：三个数相加：
    public static int add(int num1,int num2,int num3)&#123;
        return num1+num2+num3;
    &#125;

    //定义一个方法：四个数相加：
    public static int add(int num1,int num2,int num3,int num4)&#123;
        return num1+num2+num3+num4;
    &#125;
    //定义一个方法：两个数相加：两个double类型的数据相加
    public static double add(double num1,double num2)&#123;
        return num1+num2;
    &#125;


&#125;
</code></pre>
<p>总结：</p>
<p>1.方法的重载：在同一个类中，方法名相同，形参列表不同的多个方法，构成了方法的重载。</p>
<p>2.方法的重载只跟：方法名和形参列表有关，与修饰符，返回值类型无关。</p>
<p>3.注意：形参列表不同指的是什么？</p>
<p>（1）个数不同</p>
<p>add() add(int num1) add(int num1,int num2)</p>
<p>（2）顺序不同</p>
<p>add(int num1,double num2) add(double num1,int num2)</p>
<p>（3）类型不同</p>
<p>add(int num1) add(double num1)</p>
<p>4.请问下面的方法是否构成了方法的重载？</p>
<p>(1)add(int a) 和 add(int b) —&gt;不构成,相当于方法的重复定义</p>
<p>(2)public static int add(int a) 和 public static void add(int b) —&gt;不构成</p>
<p>【4】扩充：</p>
<pre><code class="java">public class TestMethod06&#123;
    public static void main(String[] args)&#123;
        add(5);
        //级别：byte,short,char--\&gt;int--\&gt;long--\&gt;float---\&gt;double
    &#125;
    
    public static void add(double num1)&#123;
        System.out.println(&quot;------2&quot;);
    &#125;
    public static void add(float num1)&#123;
        System.out.println(&quot;------3&quot;);
    &#125;
    public static void add(long num1)&#123;
        System.out.println(&quot;------4&quot;);
    &#125;
    /\*
        public static void add(int num1)&#123;
        System.out.println(&quot;------1&quot;);
    &#125;
    \*/
&#125;
</code></pre>
]]></content>
      <categories>
        <category>JavaSE</category>
        <category>方法的定义_调用_重载</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title>第6章_数组</title>
    <url>/2022/10/07/Java/%E7%AC%AC6%E7%AB%A0_%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h1 id="数组的引入"><a href="#数组的引入" class="headerlink" title="数组的引入"></a>数组的引入</h1><p>【1】习题引入：</p>
<pre><code class="java">import java.util.Scanner;
public class TestArray01&#123;
    public static void main(String[] args)&#123;
        //功能：键盘录入十个学生的成绩，求和，求平均数：
        //定义一个求和的变量：
        int sum = 0;
        Scanner sc = new Scanner(System.in);

        for(int i=1;i\&lt;=10;i++)&#123;//i:控制循环次数
            System.out.print(&quot;请录入第&quot;+i+&quot;个学生的成绩：&quot;);
            int score = sc.nextInt();
            sum += score;
        &#125;

        System.out.println(&quot;十个学生的成绩之和为：&quot;+sum);
        System.out.println(&quot;十个学生的成绩平均数为：&quot;+sum/10);

        //本题的缺点：
        //求第6个学生的成绩：？？？？？---》不能

    &#125;
&#125;
</code></pre>
<p>缺点：就是不能求每个学生的成绩具体是多少</p>
<p>解决：将成绩进行存储 —-》 引入 ： 数组</p>
<p>感受到数组的作用：数组用来存储数据的，在程序设计中，为了处理方便，数组用来将相同类型的若干数据组织起来。</p>
<p>这个若干数据的集合我们称之为数组。</p>
<h1 id="数组的学习"><a href="#数组的学习" class="headerlink" title="数组的学习"></a>数组的学习</h1><p>【1】数组的定义</p>
<p>数组是相同类型数据的有序集合。数组描述的是相同类型的若干个数据，按照一定的先后次序排列组合而成。其中，每一个数据称作一个元素，每个元素可以通过一个索引（下标）来访问它们。</p>
<p>数组的四个基本特点：</p>
<p>1.长度是确定的。数组一旦被创建，它的大小就是不可以改变的。</p>
<p>2.其元素的类型必须是相同类型，不允许出现混合类型。</p>
<p>3.数组类型可以是任何数据类型，包括基本类型和引用类型。</p>
<p>4.数组有索引的：索引从0开始，到 数组.length-1 结束</p>
<p>5.数组变量属于引用类型，数组也是对象。</p>
<p>PS:数组变量属于引用类型，数组也是对象，数组中的每个元素相当于该对象的成员变量。数组本身就是对象，Java中对象是在堆中的，因此数组无论保存原始类型还是其他对象类型，数组对象本身是在堆中存储的。</p>
<p>【2】数组的学习：</p>
<pre><code class="java">public class TestArray02&#123;
    public static void main(String[] args)&#123;
        //数组的作用：用来存储相同类型的数据
        //以int类型数据为案例：数组用来存储int类型数据
        //1.声明(定义数组)
        int[] arr; //定义一个int类型的数组，名字叫arr
        //int arr2[];
        //如果数组只声明，没有后续操作，那么这个数组相当于没定义
        //int[] arr3 = null;//空 辨别：数组赋值为null和什么都没有赋值 不一样的效果

        //2.创建
        arr = new int[4];//给数组开辟了一个长度为4的空间
        //编译期声明和创建会被合为一句话: int[] arr = new int[4];

        //3.赋值
        arr[0] = 12;
        arr[3] = 47;
        arr[2] = 98;
        arr[1] = 56;
        arr[2] = 66;
        /\*
            arr[4] = 93;
        出现异常：Exception in thread &quot;main&quot; java.lang.ArrayIndexOutOfBoundsException: 4
            Array 数组
            Index 索引
            OutOf 超出
            Bounds 界限
            Exception 异常
            \---》数组索引越界异常
            \*/

            //4.使用
            System.out.println(arr[2]);
        System.out.println(arr[0]+100);
        //通过数组一个属性来获取 length 长度
        System.out.println(&quot;数组的长度是：&quot;+arr.length);
    &#125;
&#125;
</code></pre>
<h2 id="内存分析"><a href="#内存分析" class="headerlink" title="内存分析"></a>内存分析</h2><img data-src="/2022/10/07/Java/%E7%AC%AC6%E7%AB%A0_%E6%95%B0%E7%BB%84/046af579ec25dd3f79d0c86ae6002a90.png" class="">


<h1 id="完善引入的习题-数组的遍历"><a href="#完善引入的习题-数组的遍历" class="headerlink" title="完善引入的习题_数组的遍历"></a>完善引入的习题_数组的遍历</h1><p>【1】代码：</p>
<pre><code class="java">import java.util.Scanner;
public class TestArray03&#123;
    public static void main(String[] args)&#123;
        //功能：键盘录入十个学生的成绩，求和，求平均数：
        //定义一个int类型的数组，长度为10 ：
        int[] scores = new int[10];
        //定义一个求和的变量：
        int sum = 0;
        Scanner sc = new Scanner(System.in);

        for(int i=1;i\&lt;=10;i++)&#123;//i:控制循环次数
            System.out.print(&quot;请录入第&quot;+i+&quot;个学生的成绩：&quot;);
            int score = sc.nextInt();
            scores[i-1] = score;
            sum += score;
        &#125;

        System.out.println(&quot;十个学生的成绩之和为：&quot;+sum);
        System.out.println(&quot;十个学生的成绩平均数为：&quot;+sum/10);


        //求第6个学生的成绩：
        //System.out.println(scores[5]);
        /\*
            System.out.println(scores[0]);
        System.out.println(scores[1]);
        System.out.println(scores[2]);
        System.out.println(scores[3]);
        //....
        System.out.println(scores[9]);
        \*/
            //将数组中的每个元素进行查看--》数组的遍历：
            //方式1：普通for循环---》正向遍历：
            for(int i=0;i\&lt;=9;i++)&#123;
                System.out.println(&quot;第&quot;+(i+1)+&quot;个学生的成绩为：&quot;+scores[i]);
            &#125;

        //方式2：增强for循环:
        //对scores数组进行遍历，遍历出来每个元素都用int类型的num接收：
        int count = 0;
        for(int num:scores)&#123;
            count++;
            //每次都将num在控制台输出
            System.out.println(&quot;第&quot;+count+&quot;个学生的成绩为：&quot;+num);
        &#125;

        /\*
            增强for循环：
            优点：代码简单
            缺点：单纯的增强for循环不能涉及跟索引相关的操作
            \*/

            //方式3：利用普通for循环： 逆向遍历：
            for(int i=9;i\&gt;=0;i--)&#123;
                System.out.println(&quot;第&quot;+(i+1)+&quot;个学生的成绩为：&quot;+scores[i]);
            &#125;

    &#125;
&#125;
</code></pre>
<p>【2】用IDEA验证数组的确将数据进行存储了：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC6%E7%AB%A0_%E6%95%B0%E7%BB%84/8a7a660c15849bc9d85e42452b74c0a5.png" class="">


<h1 id="数组的三种初始化方式"><a href="#数组的三种初始化方式" class="headerlink" title="数组的三种初始化方式"></a>数组的三种初始化方式</h1><p>数组的初始化方式总共有三种：静态初始化、动态初始化、默认初始化。</p>
<ul>
<li>静态初始化</li>
</ul>
<p>除了用new关键字来产生数组以外，还可以直接在定义数组的同时就为数组元素分配空间并赋值。</p>
<p>eg:</p>
<pre><code class="java">int[] arr = &#123;12,23,45&#125;;

int[] arr = new int[]&#123;12,23,45&#125;;

注意：

1.new int[3]&#123;12,23,45&#125;;--\&gt;错误

2.int[] arr ;

arr = &#123;12,23,45&#125;; ---\&gt;错误
</code></pre>
<ul>
<li>动态初始化</li>
</ul>
<p>数组定义与为数组元素分配空间并赋值的操作分开进行。</p>
<p>eg:</p>
<pre><code class="java">int[] arr ;

arr = new int[3]

arr[0] = 12;

arr[1] = 23;

arr[2] = 45;
</code></pre>
<ul>
<li>默认初始化</li>
</ul>
<p>数组是引用类型，它的元素相当于类的实例变量，因此数组一经分配空间，其中的每个元素也被按照实例变量同样的方式被隐式初始化。</p>
<p>int[] arr &#x3D; new int[3]; —&gt; 数组有默认的初始化值</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC6%E7%AB%A0_%E6%95%B0%E7%BB%84/7dd1ca8911a4defc392409e9442bb532.png" class="">


<h1 id="数组的应用题"><a href="#数组的应用题" class="headerlink" title="数组的应用题"></a>数组的应用题</h1><h2 id="最值问题"><a href="#最值问题" class="headerlink" title="最值问题"></a>最值问题</h2><p>【1】实现一个功能：给定一个数组int[] arr &#x3D; {12,3,7,4,8,125,9,45}; ，求出数组中最大的数。</p>
<p>思路图：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC6%E7%AB%A0_%E6%95%B0%E7%BB%84/70c971a42c3219e306e6ece0eb9e41d8.png" class="">


<pre><code class="java">public class TestArray04&#123;
    public static void main(String[] args)&#123;
        //实现一个功能：给定一个数组int[] arr = &#123;12,3,7,4,8,125,9,45&#125;; ，求出数组中最大的数。
        //1.给定一个数组
        int[] arr = &#123;12,3,7,4,8,125,9,45,666,36&#125;;

        //2.求出数组中的最大值：
        //先找一个数上擂台，假定认为这个数最大：
        int maxNum = arr[0];
        for(int i=0;i\&lt;arr.length;i++)&#123;
            if(arr[i]\&gt;maxNum)&#123;
                maxNum = arr[i];
            &#125;
        &#125;
        System.out.println(&quot;当前数组中最大的数为：&quot;+maxNum);

    &#125;
&#125;
</code></pre>
<p>【2】将求最大值的方法提取出来：</p>
<pre><code class="java">public class TestArray04&#123;
    public static void main(String[] args)&#123;
        //实现一个功能：给定一个数组int[] arr = &#123;12,3,7,4,8,125,9,45&#125;; ，求出数组中最大的数。
        //1.给定一个数组
        int[] arr = &#123;12,3,7,4,8,725,9,45,666,36&#125;;

        //2.求出数组中的最大值：
        //调用方法：
        int num = getMaxNum(arr);
        System.out.println(&quot;当前数组中最大的数为：&quot;+num);
    &#125;

    /\*
        想提取一个方法：求数组中的最大值
        求哪个数组中的最大值 ---》不确定因素：哪个数组 (形参)---》返回值：最大值
        \*/
        public static int getMaxNum(int[] arr)&#123;
        //先找一个数上擂台，假定认为这个数最大：
        int maxNum = arr[0];
        for(int i=0;i\&lt;arr.length;i++)&#123;
            if(arr[i]\&gt;maxNum)&#123;
                maxNum = arr[i];
            &#125;
        &#125;
        return maxNum;

    &#125;
&#125;
</code></pre>
<p>【3】画内存：</p>
<p>方法的实参传递给形参的时候一定要注意：一切都是值传递：</p>
<p>如果是基本数据类型，那么传递的就是字面值</p>
<p>如果是引用数据类型，那么传递的就是地址值</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC6%E7%AB%A0_%E6%95%B0%E7%BB%84/9fcaf17f1bd6f6c30ecdf3db3fb2a57c.png" class="">


<h2 id="查询问题"><a href="#查询问题" class="headerlink" title="查询问题"></a>查询问题</h2><p>【1】查询指定位置的元素</p>
<pre><code class="java">public class TestArray05&#123;
    public static void main(String[] args)&#123;
        //查询指定位置的元素
        //给定一个数组：
        int[] arr = &#123;12,34,56,7,3,10&#125;;
        //查找索引为2的位置上对应的元素是什么？
        System.out.println(arr[2]);
    &#125;
&#125;
</code></pre>
<p>上面代码体现了数组的一个优点：</p>
<p>在按照位置查询的时候，直接一步到位，效率非常高</p>
<p>【2】查询指定元素的位置–》找出元素对应的索引</p>
<pre><code class="java">public class TestArray06&#123;
    public static void main(String[] args)&#123;
        //查询指定元素的位置--》找出元素对应的索引
        //给定一个数组：
        int[] arr = &#123;12,34,56,7,3,56&#125;;
        // 0 1 2 3 4 5

        //功能：查询元素888对应的索引：
        int index = -1; //这个初始值只要不是数组的索引即可
        for(int i=0;i\&lt;arr.length;i++)&#123;
            if(arr[i]==12)&#123;
                index = i;//只要找到了元素，那么index就变成为i
                break;//只要找到这个元素，循环就停止
            &#125;
        &#125;
        if(index!=-1)&#123;
            System.out.println(&quot;元素对应的索引：&quot;+index);
        &#125;else&#123;//index==-1
            System.out.println(&quot;查无次数！&quot;);
        &#125;
    &#125;
&#125;
</code></pre>
<p>【3】将查指定元素对应的索引的功能提取为方法：</p>
<pre><code class="java">public class TestArray06&#123;
    public static void main(String[] args)&#123;
        //查询指定元素的位置--》找出元素对应的索引
        //给定一个数组：
        int[] arr = &#123;12,34,56,7,3,56&#125;;
        // 0 1 2 3 4 5

        //功能：查询元素888对应的索引：
        //调用方法：
        int index = getIndex(arr,999);
        //后续对index的值进行判断：
        if(index!=-1)&#123;
            System.out.println(&quot;元素对应的索引：&quot;+index);
        &#125;else&#123;//index==-1
            System.out.println(&quot;查无次数！&quot;);
        &#125;
    &#125;

    /\*
        定义一个方法：查询数组中指定的元素对应的索引：
        不确定因素：哪个数组，哪个指定元素 （形参）
        返回值：索引

        \*/
        public static int getIndex(int[] arr,int ele)&#123;
        int index = -1; //这个初始值只要不是数组的索引即可
        for(int i=0;i\&lt;arr.length;i++)&#123;
            if(arr[i]==ele)&#123;
                index = i;//只要找到了元素，那么index就变成为i
                break;//只要找到这个元素，循环就停止
            &#125;
        &#125;
        return index;
    &#125;
&#125;
</code></pre>
<h2 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h2><p>【1】实现一个功能：</p>
<p>添加逻辑：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC6%E7%AB%A0_%E6%95%B0%E7%BB%84/b8b369a935a5784a33f79bddc13e998b.png" class="">


<pre><code class="java">public class TestArray07&#123;
    public static void main(String[] args)&#123;
        //功能：给定一个数组,在数组下标为2的位置上添加一个元素91

        //1.给定一个数组：
        int[] arr = &#123;12,34,56,7,3,10,55,66,77,88,999,89&#125;;
        // 0 1 2 3 4 5
        //2.输出增加元素前的数组：
        System.out.print(&quot;增加元素前的数组：&quot;);
        for(int i=0;i\&lt;arr.length;i++)&#123;
            if(i!=arr.length-1)&#123;
                System.out.print(arr[i]+&quot;,&quot;);
            &#125;else&#123;//i==arr.length-1 最后一个元素不用加,
                System.out.print(arr[i]);
            &#125;
        &#125;

        //3.增加元素
        /\*
            arr[5] = arr[4];
        arr[4] = arr[3];
        arr[3] = arr[2];
        \*/
            int index = 1;//在这个指定位置添加 元素
        for(int i=arr.length-1;i\&gt;=(index+1);i--)&#123;
            arr[i] = arr[i-1];
        &#125;
        arr[index] = 666;


        //4.输出增加元素后的数组：
        System.out.print(&quot;\\n增加元素后的数组：&quot;);
        for(int i=0;i\&lt;arr.length;i++)&#123;
            if(i!=arr.length-1)&#123;
                System.out.print(arr[i]+&quot;,&quot;);
            &#125;else&#123;//i==arr.length-1 最后一个元素不用加,
                System.out.print(arr[i]);
            &#125;
        &#125;

    &#125;
&#125;
</code></pre>
<p>【2】将添加功能提取为一个 方法：</p>
<pre><code class="java">import java.util.Scanner;
public class TestArray07&#123;
    public static void main(String[] args)&#123;
        //功能：给定一个数组,在数组下标为2的位置上添加一个元素91

        //1.给定一个数组：
        int[] arr = &#123;12,34,56,7,3,10,55,66,77,88,999,89&#125;;
        // 0 1 2 3 4 5
        //2.输出增加元素前的数组：
        /\*
            System.out.print(&quot;增加元素前的数组：&quot;);
        for(int i=0;i\&lt;arr.length;i++)&#123;
            if(i!=arr.length-1)&#123;
                System.out.print(arr[i]+&quot;,&quot;);
            &#125;else&#123;//i==arr.length-1 最后一个元素不用加,
                System.out.print(arr[i]);
            &#125;
        &#125;
        \*/

            //从键盘接收数据：
            Scanner sc = new Scanner(System.in);
        System.out.println(&quot;请录入你要添加元素的指定下标：&quot;);
        int index = sc.nextInt();
        System.out.println(&quot;请录入你要添加的元素：&quot;);
        int ele = sc.nextInt();

        //3.增加元素
        //调用方法：
        insertEle(arr,index,ele);



        //4.输出增加元素后的数组：
        System.out.print(&quot;\\n增加元素后的数组：&quot;);
        for(int i=0;i\&lt;arr.length;i++)&#123;
            if(i!=arr.length-1)&#123;
                System.out.print(arr[i]+&quot;,&quot;);
            &#125;else&#123;//i==arr.length-1 最后一个元素不用加,
                System.out.print(arr[i]);
            &#125;
        &#125;

    &#125;


    /\*
        提取一个添加元素的方法：
        在数组的指定位置上添加一个指定的元素。
        在哪个数组的哪个位置添加哪个元素！
        不确定因素：形参：哪个数组，哪个位置，哪个元素
        返回值：无

        \*/
        public static void insertEle(int[] arr,int index,int ele)&#123;
        for(int i=arr.length-1;i\&gt;=(index+1);i--)&#123;
            arr[i] = arr[i-1];
        &#125;
        arr[index] = ele;
    &#125;
&#125;
</code></pre>
<h2 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h2><p>【1】实现一个功能：删除指定位置上的元素</p>
<p>逻辑：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC6%E7%AB%A0_%E6%95%B0%E7%BB%84/6c0276c47a14681f40e5ee09c6f35150.png" class="">


<pre><code class="java">import java.util.Arrays;
public class TestArray08&#123;
    public static void main(String[] args)&#123;
        //功能：给定一个数组,删除下标为2元素

        //1.给定一个数组：
        int[] arr = &#123;12,34,56,7,3,10,34,45,56,7,666&#125;;
        // 0 1 2 3 4 5
        //2.输出删除前的数组：
        System.out.println(&quot;删除元素前的数组：&quot;+Arrays.toString(arr));

        //3.删除
        /\*
            arr[2] = arr[3];
        arr[3] = arr[4];
        arr[4] = arr[5];
        \*/
            int index = 0;
        for(int i=index;i\&lt;=arr.length-2;i++)&#123;
            arr[i] = arr[i+1];
        &#125;
        arr[arr.length-1] = 0;

        //4.输出删除后的数组：
        System.out.println(&quot;删除元素后的数组：&quot;+Arrays.toString(arr));
    &#125;
&#125;
</code></pre>
<p>【2】实现一个功能：删除指定元素</p>
<pre><code class="java">import java.util.Arrays;
public class TestArray09&#123;
    public static void main(String[] args)&#123;
        //功能：给定一个数组,删除元素3：

        //1.给定一个数组：
        int[] arr = &#123;12,34,56,7,3,10,34,45,56,7,666&#125;;

        //2.输出删除前的数组：
        System.out.println(&quot;删除元素前的数组：&quot;+Arrays.toString(arr));


        //找到要删除的元素对应的索引即可：
        int index = -1 ;
        for(int i=0;i\&lt;arr.length;i++)&#123;
            if(arr[i]==1200)&#123;
                index = i;
                break;
            &#125;
        &#125;

        //3.删除

        if(index!=-1)&#123;
            for(int i=index;i\&lt;=arr.length-2;i++)&#123;
                arr[i] = arr[i+1];
            &#125;
            arr[arr.length-1] = 0;
        &#125;else&#123;//index==-1
            System.out.println(&quot;根本没有你要删除的元素！&quot;);
        &#125;


        //4.输出删除后的数组：
        System.out.println(&quot;删除元素后的数组：&quot;+Arrays.toString(arr));
    &#125;
&#125;
</code></pre>
<h1 id="详述main方法"><a href="#详述main方法" class="headerlink" title="详述main方法"></a>详述main方法</h1><p>【1】main方法：程序的入口，在同一个类中，如果有多个方法，那么虚拟机就会识别main方法，从这个方法作为程序的入口</p>
<p>【2】main方法格式严格要求：</p>
<p>public static void main(String[] args){}</p>
<p>public static —&gt;修饰符 ，暂时用这个 –&gt;面向对象一章</p>
<p>void —&gt;代表方法没有返回值 对应的类型void</p>
<p>main —&gt;见名知意名字</p>
<p>String[] args —&gt;形参 —》不确定因素</p>
<p>【3】问题：程序中是否可以有其他的方法也叫main方法？</p>
<p>可以，构成了方法的重载。</p>
<pre><code class="java">public class TestArray10&#123;
    public static void main(String[] args)&#123;

    &#125;
    public static void main(String str)&#123;

    &#125;
&#125;
</code></pre>
<p>【4】形参为String[] 那么实参到底是什么？</p>
<pre><code class="java">public class TestArray10&#123;
    public static void main(String[] args)&#123;
        //从侧面验证：
        //int[] arr1; //如果对数组只声明，没有后续操作，那么相当于 白定义了。
        //int[] arr2 = null;
        //System.out.println(arr2.length);//Exception in thread &quot;main&quot; java.lang.NullPointerException
        //int[] arr3 = new int[0];
        //System.out.println(arr3.length);
        //int[] arr4 = new int[4];
        //System.out.println(arr4.length);

        //System.out.println(args.length);//0
        //从这个结果证明，参数是String[],实参是 new String[0]
        //默认情况下，虚拟机在调用main方法的时候就是传入了一个长度为0的数组

        System.out.println(args.length);
        for(String str:args)&#123;
            System.out.println(str);
        &#125;
    &#125;
&#125;
</code></pre>
<p>手动传入实参：</p>
<p>有特殊符号的时候可以加上“”</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC6%E7%AB%A0_%E6%95%B0%E7%BB%84/d3da5aadcf3237a0ded3957e968da17a.png" class="">


<p>没有特殊符号用空格隔开即可：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC6%E7%AB%A0_%E6%95%B0%E7%BB%84/a7c9de6cf8fb43afc60fbbcea917ed21.png" class="">


<h1 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h1><pre><code class="java">public class TestArray12&#123;
    /\*
        1.可变参数：作用提供了一个方法，参数的个数是可变的 ,解决了部分方法的重载问题
        int...num
        double...num
        boolean...num


        2.可变参数在JDK1.5之后加入的新特性
        3.方法的内部对可变参数的处理跟数组是一样
        4.可变参数和其他数据一起作为形参的时候，可变参数一定要放在最后
        5.我们自己在写代码的时候，建议不要使用可变参数。
        \*/
        public static void main(String[] args)&#123;
        //method01(10);
        //method01();
        //method01(20,30,40);
        method01(30,40,50,60,70);
        //method01(new int[]&#123;11,22,33,44&#125;);
    &#125;
    public static void method01(int num2,int...num)&#123;
        System.out.println(&quot;-----1&quot;);
        for(int i:num)&#123;
            System.out.print(i+&quot;\\t&quot;);
        &#125;
        System.out.println();

        System.out.println(num2);
    &#125;
&#125;
</code></pre>
<h1 id="Arrays工具类"><a href="#Arrays工具类" class="headerlink" title="Arrays工具类"></a>Arrays工具类</h1><p>为了方便我们对数组进行操作，系统提供一个类Arrays，我们将它当做工具类来使用。</p>
<pre><code class="java">import java.util.Arrays;
public class TestArray13&#123;
    public static void main(String[] args)&#123;
        //给定一个数组：
        int[] arr = &#123;1,3,7,2,4,8&#125;;
        //toString:对数组进行遍历查看的，返回的是一个字符串，这个字符串比较好看
        System.out.println(Arrays.toString(arr));

        //binarySearch:二分法查找：找出指定数组中的指定元素对应的索引：
        //这个方法的使用前提：一定要查看的是一个有序的数组：
        //sort：排序 --\&gt;升序
        Arrays.sort(arr);
        System.out.println(Arrays.toString(arr));
        System.out.println(Arrays.binarySearch(arr,4));

        int[] arr2 = &#123;1,3,7,2,4,8&#125;;
        //copyOf:完成数组的复制：
        int[] newArr = Arrays.copyOf(arr2,4);
        System.out.println(Arrays.toString(newArr));

        //copyOfRange:区间复制：
        int[] newArr2 = Arrays.copyOfRange(arr2,1,4);//[1,4)--\&gt;1,2,3位置
        System.out.println(Arrays.toString(newArr2));

        //equals:比较两个数组的值是否一样：
        int[] arr3 = &#123;1,3,7,2,4,8&#125;;
        int[] arr4 = &#123;1,3,7,2,4,8&#125;;
        System.out.println(Arrays.equals(arr3,arr4));//true
        System.out.println(arr3==arr4);//false ==比较左右两侧的值是否相等，比较的是左右的地址值，返回结果一定是false

        //fill：数组的填充：
        int[] arr5 = &#123;1,3,7,2,4,8&#125;;
        Arrays.fill(arr5,10);
        System.out.println(Arrays.toString(arr5));
    &#125;
&#125;
</code></pre>
<h1 id="数组的复制操作"><a href="#数组的复制操作" class="headerlink" title="数组的复制操作"></a>数组的复制操作</h1><img data-src="/2022/10/07/Java/%E7%AC%AC6%E7%AB%A0_%E6%95%B0%E7%BB%84/f55029455c828e6298cac80b7e99f3d4.png" class="">


<img data-src="/2022/10/07/Java/%E7%AC%AC6%E7%AB%A0_%E6%95%B0%E7%BB%84/fe8cc0293b38bcca7c79d0f53366bf51.png" class="">


<p>原理：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC6%E7%AB%A0_%E6%95%B0%E7%BB%84/c646de79c14443e0f59dbfd4df86acc9.png" class="">


<p>代码：</p>
<pre><code class="java">import java.util.Arrays;
public class TestArray14&#123;
    public static void main(String[] args)&#123;
        //给一个源数组：
        int[] srcArr = &#123;11,22,33,44,55,66,77,88&#125;;
        //给一个目标数组：
        int[] destArr = new int[10];

        //复制：
        System.arraycopy(srcArr,1,destArr,3,3);
        //遍历查看目标数组：
        System.out.println(Arrays.toString(destArr));
    &#125;

&#125;
</code></pre>
<p>结果：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC6%E7%AB%A0_%E6%95%B0%E7%BB%84/449d70aa26b1dd58faf4391d631b23c9.png" class="">


<h1 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h1><p>【1】引入：本质上全部都是一维数组：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC6%E7%AB%A0_%E6%95%B0%E7%BB%84/34650d8b02d5b0ec054c9dca9a6d89fd.png" class="">


<p>【2】基本代码：</p>
<pre><code class="java">public class TestArray15&#123;
    public static void main(String[] args)&#123;
        //定义一个二维数组：
        int[][] arr = new int[3][];//本质上定义了一个一维数组，长度为3

        int[] a1 = &#123;1,2,3&#125;;
        arr[0] = a1;

        arr[1] = new int[]&#123;4,5,6,7&#125;;

        arr[2] = new int[]&#123;9,10&#125;;

    &#125;
&#125;
</code></pre>
<p>对应内存：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC6%E7%AB%A0_%E6%95%B0%E7%BB%84/7b1ecb2fa93e9b387e7ad62603746e33.png" class="">


<p>【3】四种遍历方式：</p>
<pre><code class="java">public class TestArray15&#123;
    public static void main(String[] args)&#123;
        //定义一个二维数组：
        int[][] arr = new int[3][];//本质上定义了一个一维数组，长度为3

        int[] a1 = &#123;1,2,3&#125;;
        arr[0] = a1;

        arr[1] = new int[]&#123;4,5,6,7&#125;;

        arr[2] = new int[]&#123;9,10&#125;;

        //读取6这个元素：
        //System.out.println(arr[1][2]);

        //对二维数组遍历：
        //方式1：外层普通for循环+内层普通for循环：
        for(int i=0;i\&lt;arr.length;i++)&#123;
            for(int j=0;j\&lt;arr[i].length;j++)&#123;
                System.out.print(arr[i][j]+&quot;\\t&quot;);
            &#125;
            System.out.println();
        &#125;

        //方式2：外层普通for循环+内层增强for循环：
        for(int i=0;i\&lt;arr.length;i++)&#123;
            for(int num:arr[i])&#123;
                System.out.print(num+&quot;\\t&quot;);
            &#125;
            System.out.println();
        &#125;

        //方式3：外层增强for循环+内层增强for循环：
        for(int[] a:arr)&#123;
            for(int num:a)&#123;
                System.out.print(num+&quot;\\t&quot;);
            &#125;
            System.out.println();
        &#125;

        //方式4：外层增强for循环+内层普通for循环：
        for(int[] a:arr)&#123;
            for(int i=0;i\&lt;a.length;i++)&#123;
                System.out.print(a[i]+&quot;\\t&quot;);
            &#125;
            System.out.println();
        &#125;

    &#125;
&#125;
</code></pre>
<h1 id="二维数组的初始化方式"><a href="#二维数组的初始化方式" class="headerlink" title="二维数组的初始化方式"></a>二维数组的初始化方式</h1><p>数组的初始化方式总共有三种：静态初始化、动态初始化、默认初始化。</p>
<ul>
<li>静态初始化</li>
</ul>
<p>除了用new关键字来产生数组以外，还可以直接在定义数组的同时就为数组元素分配空间并赋值。</p>
<p>eg:</p>
<pre><code class="java">int[][] arr = &#123;&#123;1,2&#125;,&#123;4,5,6&#125;,&#123;4,5,6,7,8,9,9&#125;&#125;;

int[][] arr =new int[][] &#123;&#123;1,2&#125;,&#123;4,5,6&#125;,&#123;4,5,6,7,8,9,9&#125;&#125;;
</code></pre>
<ul>
<li>动态初始化</li>
</ul>
<p>数组定义与为数组元素分配空间并赋值的操作分开进行。</p>
<p>eg:</p>
<pre><code class="java">int[][] arr = new int[3][]; //本质上定义了一维数组长度为3，每个“格子”中放入的是一个数组

arr[0] = new int[]&#123;1,2&#125;;

arr[1] = new int[]&#123;3,4,5,6&#125;;

arr[2] = new int[]&#123;34,45,56&#125;;
</code></pre>
<p>eg:</p>
<pre><code class="java">int[][] arr = new int[3][2];
</code></pre>
<ul>
<li>默认初始化</li>
</ul>
<p>数组是引用类型，它的元素相当于类的实例变量，因此数组一经分配空间，其中的每个元素也被按照实例变量同样的方式被隐式初始化。</p>
]]></content>
      <categories>
        <category>JavaSE</category>
        <category>数组</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title>第7章_IDEA的使用</title>
    <url>/2022/10/07/Java/%E7%AC%AC7%E7%AB%A0_IDEA%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="IDE"><a href="#IDE" class="headerlink" title="IDE"></a>IDE</h1><p>集成开发环境（IDE，Integrated Development Environment ）是用于提供程序开发环境的应用程序，一般包括代码编辑器、编译器、调试器和图形用户界面等工具。集成了代码编写功能、分析功能、编译功能、调试功能等一体化的开发软件服务套。所有具备这一特性的软件或者软件套（组）都可以叫集成开发环境。如微软的Visual Studio系列，Borland的C++ Builder、Delphi系列等。该程序可以独立运行，也可以和其它程序并用。IDE多被用于开发HTML应用软件。例如，许多人在设计网站时使用IDE（如HomeSite、DreamWeaver等），因为很多项任务会自动生成。编程开发软件将编辑、编译、调试等功能集成在一个桌面环境中,这样就大大方便了用户。</p>
<p>❀优点</p>
<p>节省时间和精力。IDE的目的就是要让开发更加快捷方便，通过提供工具和各种性能来帮助开发者组织资源，减少失误，提供捷径。</p>
<p>建立统一标准。当一组程序员使用同一个开发环境时，就建立了统一的工作标准，当IDE提供预设的模板，或者不同团队分享代码库时，这一效果就更加明显了。</p>
<p>管理开发工作。首先，IDE提供文档工具，可以自动输入开发者评论，或者迫使开发者在不同区域编写评论。其次，IDE可以展示资源，更便于发现应用所处位置，无需在文件系统里面艰难的搜索。</p>
<p>❀缺点</p>
<p>学习曲线问题。IDE基本上是比较复杂的工具，为了更好的熟练使用，需要一定的时间和耐心。</p>
<p>初学者的困难。对初学者来说，使用IDE来学习开发有相当的难度，不适合学习一种新语言时使用。</p>
<p>无法修复坏代码或设计。开发者不能完全依赖工具的便捷，还是必须保持专业水准和熟练度，开发的成果好坏主要还是看开发员的技术。</p>
<h1 id="JetBrains公司介绍"><a href="#JetBrains公司介绍" class="headerlink" title="JetBrains公司介绍"></a>JetBrains公司介绍</h1><p>【1】IntelliJ IDEA就是Java的IDE。</p>
<p>【2】市场占有率竹节攀升，超过了Eclipse。</p>
<p>【3】JetBrains公司介绍：</p>
<p>JetBrains是一家捷克的软件开发公司，该公司位于捷克的布拉格，并在俄罗斯的圣彼得堡及美国麻州波士顿都设有办公室，该公司最为人所熟知的产品是Java编程语言开发撰写时所用的<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTklOUIlODYlRTYlODglOTAlRTUlQkMlODAlRTUlOEYlOTElRTclOEUlQUYlRTUlQTIlODMvMjk4NTI0">集成开发环境</span>：IntelliJ IDEA。公司旗下还有其它产品，比如：</p>
<p>➢WebStorm: 用于开发JavaScript、HTML5、 CS3等前端技术;</p>
<p>➢PyCharm: 用于开发python（python语言热度排行榜排名第一，在人工智能大数据领域应用）</p>
<p>➢PhpStorm: 用于开发PHP</p>
<p>➢RubyMine: 用于开发Ruby&#x2F;Rails</p>
<p>➢AppCode: 用于开发Objective - C&#x2F;Swift,替换xcode的</p>
<p>➢CLion: 用于开发C&#x2F;C++</p>
<p>➢DataGrip: 用于开发数据库和SQL</p>
<p>➢Rider: 用于开发.NET</p>
<p>➢GoLand: 用于开发Go（区块链主流开发语言就是Go语言）</p>
<p>【4】官网：<span class="exturl" data-url="aHR0cHM6Ly93d3cuamV0YnJhaW5zLmNvbS8=">https://www.jetbrains.com/</span></p>
<img data-src="/2022/10/07/Java/%E7%AC%AC7%E7%AB%A0_IDEA%E7%9A%84%E4%BD%BF%E7%94%A8/f362feebfb46d136a1d0b793447e81ea.png" class="">


<h1 id="IntelliJ-IDEA介绍"><a href="#IntelliJ-IDEA介绍" class="headerlink" title="IntelliJ_IDEA介绍"></a>IntelliJ_IDEA介绍</h1><p>【1】IDEA 全称IntelliJ IDEA，是用于java语言开发的集成环境IDE(Integrated Development Environment)，也可用于其他语言。</p>
<p>IntelliJ在业界被公认为最好的java开发工具之一，尤其在智能代码助手、代码自动提示、重构、J2EE支持、Ant、JUnit、CVS整合、代码审查、 创新的GUI设计等方面的功能可以说是超常的。</p>
<p>IDEA是JetBrains公司的产品，这家公司总部位于捷克共和国的首都布拉格，开发人员以严谨著称的东欧程序员为主。</p>
<p>【2】IDEA的支持：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC7%E7%AB%A0_IDEA%E7%9A%84%E4%BD%BF%E7%94%A8/9a9495032bd248f3996d975a1f8e42bb.png" class="">


<img data-src="/2022/10/07/Java/%E7%AC%AC7%E7%AB%A0_IDEA%E7%9A%84%E4%BD%BF%E7%94%A8/105733bb7ad26ddef778db2103e8c4cf.png" class="">


<p>【3】IDEA的优势（相对于Eclipse）</p>
<p>①强大的整合能力。比如: Git、 Maven、 Spring 等</p>
<p>②提示功能的快速、便捷</p>
<p>③提示功能的范围广</p>
<p>④好用的快捷键和代码模板</p>
<p>⑤精准搜索</p>
<h1 id="IntelliJ-IDEA的下载和安装的准备"><a href="#IntelliJ-IDEA的下载和安装的准备" class="headerlink" title="IntelliJ_IDEA的下载和安装的准备"></a>IntelliJ_IDEA的下载和安装的准备</h1><img data-src="/2022/10/07/Java/%E7%AC%AC7%E7%AB%A0_IDEA%E7%9A%84%E4%BD%BF%E7%94%A8/35f4cb2446e40dde79002379353ccabb.png" class="">


<p>【2】安装的准备：</p>
<p>（1）硬件环境：</p>
<p>内存8G以上</p>
<p>CPU i5以上</p>
<p>安装在固态硬盘下</p>
<p>（2）软件环境：</p>
<p>需要安装JDK</p>
<h1 id="IDEA的卸载"><a href="#IDEA的卸载" class="headerlink" title="IDEA的卸载"></a>IDEA的卸载</h1><p>对于免安装的idea：</p>
<p>（1）删除安装文件</p>
<p>（2）到用户下将idea的缓存，配置的目录删除掉即可</p>
<p>安装idea:</p>
<p>(1)可以用控制面板–》程序</p>
<h1 id="IDEA页面展示"><a href="#IDEA页面展示" class="headerlink" title="IDEA页面展示"></a>IDEA页面展示</h1><p>【1】项目下内容：</p>
<p>➢工程下的src类似于Eclipse下的src目录，用于存放代码。。</p>
<p>➢工程下的.idea 和TestProject.iml文件都是IDEA工程特有的。类似于Eclipse 工程下的settings、.classpath、.project 等。</p>
<p>【2】配置：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC7%E7%AB%A0_IDEA%E7%9A%84%E4%BD%BF%E7%94%A8/1a7cb74f3df7fbe79e6ba069bf4dc546.png" class="">


<img data-src="/2022/10/07/Java/%E7%AC%AC7%E7%AB%A0_IDEA%E7%9A%84%E4%BD%BF%E7%94%A8/7cbbe2dc58eda1196a34dd448e7bca5b.png" class="">


<h1 id="Module的概念和使用"><a href="#Module的概念和使用" class="headerlink" title="Module的概念和使用"></a>Module的概念和使用</h1><p>【1】在Eclipse中我们有Workspace (工作空间)和Project (工程)的概念，在IDEA中只有Project (工程)和Module (模块)的概念。</p>
<p>这里的对应关系为:</p>
<table>
<thead>
<tr>
<th>IDEA官网说明:  An Eclipse workspace is similar to a project in IntelliJ IDEA  An Eclipse project maps to a module in IntelliJ IDEA</th>
</tr>
</thead>
<tbody><tr>
<td>翻译:  Eclipse中 workspace 相当于 IDEA中的Project  Eclipse中 Project 相当于 IDEA中的Module</td>
</tr>
</tbody></table>
<p>在IntelliJ IDEA中Project(工程) 是最顶级的级别，次级别是Module(模块)。</p>
<p>一个Project下可以有多个Module。</p>
<p>【2】从Eclipse 转过来的人总是下意识地要在同一个窗口管理n个项目，这在Intellij IDEA是无法做到的。Intellij IDEA提供的解决方案是打开多个项目实例，即打开多个项目窗口。即:一个Project 打开一个Window窗口。</p>
<p>【3】IDEA这样设置的原因：</p>
<p>目前主流的大型项目都是分布式部署的，结构都是类似这种多Module的。</p>
<p>这类项目一般是这样划分的，比如: 积分模块、任务模块、活动模块等等，模块之间彼此可以相互依赖。这些Module之间都是处于同一个项目业务下的模块，彼此之间是有不可分割的业务关系的。</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC7%E7%AB%A0_IDEA%E7%9A%84%E4%BD%BF%E7%94%A8/4b4fbdbfa923e2591cb2a7f701c738b0.png" class="">


<p>【4】out目录的说明：里面存放的是编译后的字节码文件</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC7%E7%AB%A0_IDEA%E7%9A%84%E4%BD%BF%E7%94%A8/f817b14883ed0ace61fc69631f5c6b71.png" class="">


<p>【5】删除模块：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC7%E7%AB%A0_IDEA%E7%9A%84%E4%BD%BF%E7%94%A8/b052b9c22ae29325f823db7e69e542f3.png" class="">


<img data-src="/2022/10/07/Java/%E7%AC%AC7%E7%AB%A0_IDEA%E7%9A%84%E4%BD%BF%E7%94%A8/af8bd2a497a5f963c8d8dde9cbe0289e.png" class="">


<h1 id="IDEA的常用设置"><a href="#IDEA的常用设置" class="headerlink" title="IDEA的常用设置"></a>IDEA的常用设置</h1><p>【1】进入设置：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC7%E7%AB%A0_IDEA%E7%9A%84%E4%BD%BF%E7%94%A8/2122254fa737cc380ce88f392c2a78cd.png" class="">


<img data-src="/2022/10/07/Java/%E7%AC%AC7%E7%AB%A0_IDEA%E7%9A%84%E4%BD%BF%E7%94%A8/ff7ec5c53e192881c538304fd2126de7.png" class="">


<img data-src="/2022/10/07/Java/%E7%AC%AC7%E7%AB%A0_IDEA%E7%9A%84%E4%BD%BF%E7%94%A8/62073c876d3f02e4124f4d448ef6688b.png" class="">


<p>【2】设置主题：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC7%E7%AB%A0_IDEA%E7%9A%84%E4%BD%BF%E7%94%A8/a88a39e6124b6ce58feea16fb7222564.png" class="">


<p>【3】编辑区的字体变大或者变小：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC7%E7%AB%A0_IDEA%E7%9A%84%E4%BD%BF%E7%94%A8/4be07f5bae751ae60b3f710c4542a394.png" class="">


<p>【4】鼠标悬浮在代码上有提示：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC7%E7%AB%A0_IDEA%E7%9A%84%E4%BD%BF%E7%94%A8/6a2a4a6748c4a79cf49cfa184d03830b.png" class="">


<p>【5】自动导包和优化多余的包：</p>
<p>手动导包：快捷键：alt+enter</p>
<p>自动导包和优化多余的包：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC7%E7%AB%A0_IDEA%E7%9A%84%E4%BD%BF%E7%94%A8/ae52672fe1d257f8c341969321d8a069.png" class="">


<p>【6】同一个包下的类，超过指定个数的时候，导包合并为*</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC7%E7%AB%A0_IDEA%E7%9A%84%E4%BD%BF%E7%94%A8/881a90cec620ed6f85dd6cb5ed9bdd36.png" class="">


<img data-src="/2022/10/07/Java/%E7%AC%AC7%E7%AB%A0_IDEA%E7%9A%84%E4%BD%BF%E7%94%A8/f90fc12b1369268eccf01e27bcebd82b.png" class="">


<p>【7】显示行号 ， 方法和方法间的分隔符：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC7%E7%AB%A0_IDEA%E7%9A%84%E4%BD%BF%E7%94%A8/99d7a1252fb6b7875100125d44a85331.png" class="">


<p>【8】忽略大小写，进行提示：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC7%E7%AB%A0_IDEA%E7%9A%84%E4%BD%BF%E7%94%A8/ccaa47c6e69e912e33532a31e2318df5.png" class="">


<p>【9】多个类不隐藏，多行显示：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC7%E7%AB%A0_IDEA%E7%9A%84%E4%BD%BF%E7%94%A8/5120dab3e7cda14f9d0050ea46857bf5.png" class="">


<p>【10】设置默认的字体，字体大小，字体行间距：(编辑区和控制台都会变化)</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC7%E7%AB%A0_IDEA%E7%9A%84%E4%BD%BF%E7%94%A8/2a62492e45c48ceea2c42b47dfef33fd.png" class="">


<p>【11】修改代码中注释的字体颜色：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC7%E7%AB%A0_IDEA%E7%9A%84%E4%BD%BF%E7%94%A8/9b5a6ee63fb86a251a8fb50d89a06a58.png" class="">


<p>【12】修改类头的文档注释信息：—》注意：对新建的类才有效</p>
<p>&#x2F;**</p>
<p>* @Auther: zhaoss</p>
<p>* @Date: ${DATE} - ${MONTH} - ${DAY} - ${TIME}</p>
<p>* @Description: ${PACKAGE_NAME}</p>
<p>* @version: 1.0</p>
<p>*&#x2F;</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC7%E7%AB%A0_IDEA%E7%9A%84%E4%BD%BF%E7%94%A8/b0b5e655926c1a39182d6e702b8f19f4.png" class="">


<p>【13】设置项目文件编码：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC7%E7%AB%A0_IDEA%E7%9A%84%E4%BD%BF%E7%94%A8/1ec297778834824cec1030cceb9a35a7.png" class="">


<p>文件右下角可以调节编码格式：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC7%E7%AB%A0_IDEA%E7%9A%84%E4%BD%BF%E7%94%A8/372613a9deca43cb5531ab639ccb93c5.png" class="">


<p>【14】自动编译：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC7%E7%AB%A0_IDEA%E7%9A%84%E4%BD%BF%E7%94%A8/99364bdcbac808e8a9283f7bf4d00f74.png" class="">


<p>【15】省电模式：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC7%E7%AB%A0_IDEA%E7%9A%84%E4%BD%BF%E7%94%A8/29648a84a17bd70f4a67e3fed4edaa86.png" class="">


<p>【16】代码显示结构：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC7%E7%AB%A0_IDEA%E7%9A%84%E4%BD%BF%E7%94%A8/d7a0885c61310238679d9ceaf73305d6.png" class="">


<p>【17】导入jar包：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC7%E7%AB%A0_IDEA%E7%9A%84%E4%BD%BF%E7%94%A8/9702df3179e89f4b31db86f2b40e6d15.png" class="">


<p>【18】生成序列化版本号：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC7%E7%AB%A0_IDEA%E7%9A%84%E4%BD%BF%E7%94%A8/e25056c4b5486ac9139430f1da3a6928.png" class="">


<img data-src="/2022/10/07/Java/%E7%AC%AC7%E7%AB%A0_IDEA%E7%9A%84%E4%BD%BF%E7%94%A8/144c56bd5d909172bf01f3aff56304e2.png" class="">


<h1 id="IDEA的常用快捷键"><a href="#IDEA的常用快捷键" class="headerlink" title="IDEA的常用快捷键"></a>IDEA的常用快捷键</h1><p>【1】创建内容：alt+insert</p>
<p>【2】main方法：psvm</p>
<p>【3】输出语句：sout<br>【4】复制行：ctrl+d</p>
<p>【5】删除行：ctrl+y</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC7%E7%AB%A0_IDEA%E7%9A%84%E4%BD%BF%E7%94%A8/1de3898fffc8b5ec0ae35b447d852504.png" class="">


<p>【6】代码向上&#x2F;下移动：Ctrl + Shift + Up &#x2F; Down</p>
<p>【7】搜索类： ctrl+n</p>
<p>【8】生成代码 ：alt + Insert（如构造函数等，getter,setter,hashCode,equals,toString）</p>
<p>【9】百能快捷键 : alt + Enter （导包，生成变量等）</p>
<p>【10】单行注释或多行注释 ： Ctrl + &#x2F; 或 Ctrl + Shift + &#x2F;</p>
<p>【11】重命名 shift+f6</p>
<p>【12】for循环 直接 ：fori 回车即可</p>
<p>【13】代码块包围：try-catch,if,while等 ctrl+alt+t</p>
<p>【14】 代码自动补全提示:</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC7%E7%AB%A0_IDEA%E7%9A%84%E4%BD%BF%E7%94%A8/93e80fcfe447c7cb0a98a2369aa78beb.png" class="">


<p>【15】 idea代码字体大小放大和缩小的快捷键</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC7%E7%AB%A0_IDEA%E7%9A%84%E4%BD%BF%E7%94%A8/99248f6b95a9feb45be9eab9b874a74e.png" class="">


<p>【16】代码一层一层调用的快捷键：</p>
<p>点进源码：ctrl+鼠标悬浮在代码上+点进去即可：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC7%E7%AB%A0_IDEA%E7%9A%84%E4%BD%BF%E7%94%A8/2e55ee66a1a3d5b2dc4d0ea0976d20e7.png" class="">


<p>【17】显示代码结构 : alt + 7</p>
<p>【18】显示导航栏： alt +1</p>
<p>【19】撤回：ctrl+z</p>
<p>【20】REDO操作：</p>
<p>如果跟搜狗输入法的快捷键冲突，可以选择将搜狗的快捷键取消。</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC7%E7%AB%A0_IDEA%E7%9A%84%E4%BD%BF%E7%94%A8/8f5fe14e09048ef82253d1fd802f9a47.png" class="">


<p>【21】缩进：tab 取消缩进： shift+tab</p>
<h1 id="模板的使用"><a href="#模板的使用" class="headerlink" title="模板的使用"></a>模板的使用</h1><h2 id="代码模板是什么"><a href="#代码模板是什么" class="headerlink" title="代码模板是什么"></a>代码模板是什么</h2><p>它的原理就是配置一些常用代码字母缩写，在输入简写时可以出现你预定义的固定模式的代码，使得开发效率大大提高，同时也可以增加个性化。最简单的例子就是在Java中输入sout会出现System.out.println();</p>
<p>（一）所处位置：</p>
<p>（1）Live Templates</p>
<p>（2）Postfix Completion</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC7%E7%AB%A0_IDEA%E7%9A%84%E4%BD%BF%E7%94%A8/44e87a0a66f725ae3cfddbda8bd1589e.png" class="">


<p>（二）区别：</p>
<p>【1】</p>
<p>Live Templates中可以做用户的个性化定制。</p>
<p>Postfix Completion中只能用，不能修改。</p>
<p>【2】使用方式不同</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC7%E7%AB%A0_IDEA%E7%9A%84%E4%BD%BF%E7%94%A8/7b200ed579ae2298e6a2fe9ea46fa4fe.png" class="">


<img data-src="/2022/10/07/Java/%E7%AC%AC7%E7%AB%A0_IDEA%E7%9A%84%E4%BD%BF%E7%94%A8/a7b86e5aff479f5b201a801d9ed6ad45.png" class="">


<h2 id="修改现有模板"><a href="#修改现有模板" class="headerlink" title="修改现有模板"></a>修改现有模板</h2><p>【1】案例1：改main方法： psvm</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC7%E7%AB%A0_IDEA%E7%9A%84%E4%BD%BF%E7%94%A8/b04c099b7f0015f617ee1efce204b916.png" class="">


<img data-src="/2022/10/07/Java/%E7%AC%AC7%E7%AB%A0_IDEA%E7%9A%84%E4%BD%BF%E7%94%A8/e8cc33bcf3c8a81d002bd204e5a90b6d.png" class="">


<p>【2】案例2：修饰属性的修饰符：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC7%E7%AB%A0_IDEA%E7%9A%84%E4%BD%BF%E7%94%A8/0450041e947e4b790f5d4c0c8c4ec683.png" class="">


<img data-src="/2022/10/07/Java/%E7%AC%AC7%E7%AB%A0_IDEA%E7%9A%84%E4%BD%BF%E7%94%A8/9f613bedeea2a0e7b0de3bb0a670044e.png" class="">


<h2 id="常用的代码模板"><a href="#常用的代码模板" class="headerlink" title="常用的代码模板"></a>常用的代码模板</h2><p>【1】模板1： main方法：</p>
<p>main 或者 psvm</p>
<p>【2】模板2：输出语句：</p>
<p>sout 或者 .sout</p>
<p>一些变型：<br>soutp:打印方法的形参</p>
<p>soutm:打印方法的名字</p>
<p>soutv:打印变量</p>
<p>【3】模板3： 循环</p>
<p>普通for循环： fori（正向） 或者 .fori （正向） . forr(逆向)</p>
<p>增强for循环： iter 或者 .for</p>
<p>（可以用于数组的遍历，集合的遍历）</p>
<p>【4】模板4： 条件判断</p>
<p>ifn 或者 .null ：判断是否为null （if null）</p>
<p>inn 或者 .nn ：判断不等于null (if not null)</p>
<p>【5】模板5： 属性修饰符：</p>
<p>prsf : private static final</p>
<p>psf :public static final</p>
<h2 id="自定义模板"><a href="#自定义模板" class="headerlink" title="自定义模板"></a>自定义模板</h2><p>【1】测试方法：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC7%E7%AB%A0_IDEA%E7%9A%84%E4%BD%BF%E7%94%A8/eedbf8c570d40d09fcdba50c22849a53.png" class="">


<p>【2】常用属性：($$中的内容其实就是在定义光标的位置，光标可以切换，用回车切换)</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC7%E7%AB%A0_IDEA%E7%9A%84%E4%BD%BF%E7%94%A8/fd705090e45097098e2b7353d8a61be9.png" class="">


<p>【3】方法注释模板：</p>
<p>&#x2F;**</p>
<p>* 功能描述:</p>
<p>* @param: $param$</p>
<p>* @return: $return$</p>
<p>* @auther: $user$</p>
<p>* @date: $date$ $time$</p>
<p>*&#x2F;</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC7%E7%AB%A0_IDEA%E7%9A%84%E4%BD%BF%E7%94%A8/0ea3381f82d736afa0bf29f5dd66627d.png" class="">


<h1 id="IDEA中的断点调试"><a href="#IDEA中的断点调试" class="headerlink" title="IDEA中的断点调试"></a>IDEA中的断点调试</h1><h2 id="常用断点调试快捷键"><a href="#常用断点调试快捷键" class="headerlink" title="常用断点调试快捷键"></a>常用断点调试快捷键</h2><p>调试在开发中大量应用：</p>
<p>【1】Debug的优化设置：更加节省内存空间：</p>
<p>设置Debug连接方式，默认是Socket。 Shared memory是Windows 特有的一个属性，一般在Windows系统下建议使用此设置，</p>
<p>内存占用相对较少。</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC7%E7%AB%A0_IDEA%E7%9A%84%E4%BD%BF%E7%94%A8/d698443a9071f2169d0927c70c319d27.png" class="">


<p>【2】常用断点调试快捷键：</p>
一步一步的向下运行代码，不会走入任何方法中。

一步一步的向下运行代码，不会走入系统类库的方法中，但是会走入自定义的方法中。

一步一步的向下运行代码，会走入系统类库的方法中，也会走入自定义的方法中。

跳出方法

结束程序

进入到下一个断点，如果没有下一个断点了，就直接运行到程序结束。

 在当前次取消未执行的断点。

<h2 id="条件判断，查看表达式的值"><a href="#条件判断，查看表达式的值" class="headerlink" title="条件判断，查看表达式的值"></a>条件判断，查看表达式的值</h2><p>【1】条件判断：</p>
<p>说明:</p>
<p>调试的时候，在循环里增加条件判断，可以极大的提高效率，心情也能惧悦。</p>
<p>具体操作:</p>
<p>在断点处右击调出条件断点。可以在满足某个条件下，实施断点。</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC7%E7%AB%A0_IDEA%E7%9A%84%E4%BD%BF%E7%94%A8/a93800a6aeec05869df076e73dd0e2a5.png" class="">


<p>【2】查看表达式的值：</p>
<p>选择行，alt+f8。</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC7%E7%AB%A0_IDEA%E7%9A%84%E4%BD%BF%E7%94%A8/ddfa7ec0690cfd5ea999e455ca4ef922.png" class="">

]]></content>
      <categories>
        <category>JavaSE</category>
        <category>IDEA的使用</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title>第9章_异常</title>
    <url>/2022/10/07/Java/%E7%AC%AC9%E7%AB%A0_%E5%BC%82%E5%B8%B8/</url>
    <content><![CDATA[<h1 id="习题的引入"><a href="#习题的引入" class="headerlink" title="习题的引入"></a>习题的引入</h1><p>【1】代码：</p>
<pre><code class="java">public class Test &#123;
    //这是一个main方法，是程序的入口：
    public static void main(String[] args) &#123;
        //实现一个功能：键盘录入两个数，求商：
        Scanner sc = new Scanner(System.in);
        System.out.println(&quot;请录入第一个数：&quot;);
        int num1 = sc.nextInt();
        System.out.println(&quot;请录入第二个数：&quot;);
        int num2 = sc.nextInt();
        System.out.println(&quot;商：&quot;+num1/num2);

    &#125;
&#125;
</code></pre>
<p>运行结果：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC9%E7%AB%A0_%E5%BC%82%E5%B8%B8/56f8af6619f13a967fd59a493803ae88.png" class="">


<p>测试过程发现问题：</p>
<p>录入的数据应为int类型，但是录入非int类型数据的时候，出异常：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC9%E7%AB%A0_%E5%BC%82%E5%B8%B8/70fd21c0b8969ead54a12fe1afc5c8f6.png" class="">


<p>除数为0的时候：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC9%E7%AB%A0_%E5%BC%82%E5%B8%B8/6ac232ad5d4a32bdd682ee7df14a2a2a.png" class="">


<p>异常：Exception：在程序的运行过程中，发生了不正常的现象，阻止了程序的运行，我们称之为发生异常。</p>
<h1 id="通过if-else解决异常"><a href="#通过if-else解决异常" class="headerlink" title="通过if-else解决异常"></a>通过if-else解决异常</h1><pre><code class="java">public class Test &#123;
    //这是一个main方法，是程序的入口：
    public static void main(String[] args) &#123;
        //实现一个功能：键盘录入两个数，求商：
        Scanner sc = new Scanner(System.in);
        System.out.println(&quot;请录入第一个数：&quot;);
        if(sc.hasNextInt())&#123;
            int num1 = sc.nextInt();
            System.out.println(&quot;请录入第二个数：&quot;);
            if(sc.hasNextInt())&#123;
                int num2 = sc.nextInt();
                if(num2 == 0)&#123;
                    System.out.println(&quot;对不起，除数不能为0&quot;);
                &#125;else&#123;
                    System.out.println(&quot;商：&quot;+num1/num2);
                &#125;
            &#125;else&#123;
                System.out.println(&quot;对不起，你录入的不是int类型的数据！&quot;);
            &#125;
        &#125;else&#123;
            System.out.println(&quot;对不起，你录入的不是int类型的数据！&quot;);
        &#125;
    &#125;
&#125;

</code></pre>
<p>用if-else堵漏洞的缺点：</p>
<p>（1）代码臃肿，业务代码和处理异常的代码混在一起。</p>
<p>（2）可读性差</p>
<p>（3）程序员需要花费大量的经历来维护这个漏洞</p>
<p>（4）程序员很难堵住所有的漏洞。</p>
<h1 id=""><a href="#" class="headerlink" title=""></a></h1><h1 id="try-catch"><a href="#try-catch" class="headerlink" title="try-catch"></a>try-catch</h1><p>【1】基于if-else处理异常缺点太多，所以java中专门出了一个异常处理机制：</p>
<p>“异常三连” try-catch-finally</p>
<p>【2】异常出现了以后怎么看：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC9%E7%AB%A0_%E5%BC%82%E5%B8%B8/bb3e30a8d6384f5a856b898d56f6aae4.png" class="">


<p>【3】捕获异常： try-catch</p>
<p>对应代码：</p>
<pre><code class="java">public class Test2 &#123;
    public static void main(String[] args) &#123;
        //实现一个功能：键盘录入两个数，求商：
        try&#123;
            Scanner sc = new Scanner(System.in);
            System.out.println(&quot;请录入第一个数：&quot;);
            int num1 = sc.nextInt();
            System.out.println(&quot;请录入第二个数：&quot;);
            int num2 = sc.nextInt();
            System.out.println(&quot;商：&quot;+num1/num2);
        &#125;catch(Exception ex)&#123;
            System.out.println(&quot;对不起，程序出现异常！&quot;);
        &#125;

        System.out.println(&quot;----谢谢你使用计算器111&quot;);
        System.out.println(&quot;----谢谢你使用计算器222&quot;);
        System.out.println(&quot;----谢谢你使用计算器333&quot;);
        System.out.println(&quot;----谢谢你使用计算器444&quot;);
        System.out.println(&quot;----谢谢你使用计算器555&quot;);
        System.out.println(&quot;----谢谢你使用计算器666&quot;);
    &#125;
&#125;
</code></pre>
<p>原理：</p>
<p>把可能出现异常的代码放入try代码块中，然后将异常封装为对象，被catch后面的()中的那个异常对象接收，接收以后：执行catch后面的{}里面的代码，然后try-catch后面的代码，该怎么执行就怎么执行。</p>
<p>详细说一下：</p>
<p>（1）try中没有异常，catch中代码不执行。</p>
<p>（2）try中有异常，catch进行捕获：</p>
<p>如果catch中异常类型和你出的异常类型匹配的话：走catch中的代码–》进行捕获</p>
<p>如果catch中异常类型和你出的异常类型不匹配的话：不走catch中的代码–》没有捕获成功，程序相当于遇到异常了，中断了，后续代码不执行</p>
<p>注意：</p>
<p>（1）try中如果出现异常，然后用catch捕获成功的话，那么try中后续的代码是不会执行的。</p>
<p>（2）如果catch捕获异常成功，那么try-catch后面的代码该执行还是执行没有影响。</p>
<h1 id="catch中如何处理异常"><a href="#catch中如何处理异常" class="headerlink" title="catch中如何处理异常"></a>catch中如何处理异常</h1><pre><code class="java">public class Test3 &#123;
    public static void main(String[] args) &#123;
        //实现一个功能：键盘录入两个数，求商：
        try&#123;
            Scanner sc = new Scanner(System.in);
            System.out.println(&quot;请录入第一个数：&quot;);
            int num1 = sc.nextInt();
            System.out.println(&quot;请录入第二个数：&quot;);
            int num2 = sc.nextInt();
            System.out.println(&quot;商：&quot;+num1/num2);
        &#125;catch(Exception ex)&#123;
            //第一种处理：什么都不写，什么都不做

            //第二种处理：输出自定义异常信息
            //System.out.println(&quot;对不起，你的代码有问题！&quot;);

            //第三种处理：打印异常信息：
            /\*(1)调用toString方法，显示异常的类名（全限定路径）\*/
                /\*System.out.println(ex);
            System.out.println(ex.toString());\*/
                /\*(2)显示异常描述信息对应的字符串，如果没有就显示null
                System.out.println(ex.getMessage());\*/
                /\*(3)显示异常的堆栈信息：将异常信息捕获以后，在控制台将异常的效果给我们展示出来，方便我们查看异常\*/
                /\* ex.printStackTrace();\*/

                //第四种处理：抛出异常：
                throw ex;
        &#125;

        System.out.println(&quot;----谢谢你使用计算器111&quot;);
    &#125;
&#125;

</code></pre>
<h1 id="try-catch-finally"><a href="#try-catch-finally" class="headerlink" title="try-catch-finally"></a>try-catch-finally</h1><p><strong>【1】在什么情况下，try-catch后面的代码不执行？</strong></p>
<p>（1）throw抛出异常的情况</p>
<p>（2）catch中没有正常的进行异常捕获</p>
<p>（3）在try中遇到return</p>
<p><strong>【2】怎么样才可以将 try-catch后面的代码 必须执行？</strong></p>
<p>只要将必须执行的代码放入finally中，那么这个代码无论如何一定执行。</p>
<p><strong>【3】return和finally执行顺序？</strong></p>
<p>先执行finally最后执行return</p>
<p><strong>【4】什么代码会放在finally中呢？</strong></p>
<p>关闭数据库资源，关闭IO流资源，关闭socket资源。</p>
<p><strong>【5】有一句话代码很厉害，它可以让finally中代码不执行!</strong></p>
<p><span class="exturl" data-url="ZmlsZTovLy9EOlzkuIvovb1cU3lzdGVtLmV4aXQoMCk7XOe7iOatouW9k+WJjeeahOiZmuaLn+acuuaJp+ihjA==">System.exit(0);&#x2F;&#x2F;终止当前的虚拟机执行</span></p>
<p>代码：</p>
<pre><code class="java">import java.util.Scanner;

public class Test3 &#123;
    public static void main(String[] args) &#123;
        //实现一个功能：键盘录入两个数，求商：
        try&#123;
            Scanner sc = new Scanner(System.in);
            System.out.println(&quot;请录入第一个数：&quot;);
            int num1 = sc.nextInt();
            System.out.println(&quot;请录入第二个数：&quot;);
            int num2 = sc.nextInt();
            System.out.println(&quot;商：&quot;+num1/num2);
            System.exit(0);//终止当前的虚拟机执行
            return;
        &#125;catch(ArithmeticException ex)&#123;
            //throw ex;
        &#125;finally &#123;
            System.out.println(&quot;----谢谢你使用计算器111&quot;);
        &#125;


    &#125;
&#125;

</code></pre>
<h1 id="多重catch"><a href="#多重catch" class="headerlink" title="多重catch"></a>多重catch</h1><p>【1】try中出现异常以后，将异常类型跟catch后面的类型依次比较，按照代码的顺序进行比对，执行第一个与异常类型匹配的catch语句</p>
<p>【2】一旦执行其中一条catch语句之后，后面的catch语句就会被忽略了！</p>
<p>【3】在安排catch语句的顺序的时候，一般会将特殊异常放在前面（并列），一般化的异常放在后面。</p>
<p>先写子类异常，再写父类异常。</p>
<p>【4】在JDK1.7以后，异常新处理方式：可以并列用|符号连接：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC9%E7%AB%A0_%E5%BC%82%E5%B8%B8/fed2c319de1a9a8d184482f4c55ef6e4.png" class="">


<pre><code class="java">import java.util.InputMismatchException;
import java.util.Scanner;

public class Test4 &#123;
    public static void main(String[] args) &#123;
        Integer
            //实现一个功能：键盘录入两个数，求商：
            try&#123;
                Scanner sc = new Scanner(System.in);
                System.out.println(&quot;请录入第一个数：&quot;);
                int num1 = sc.nextInt();
                System.out.println(&quot;请录入第二个数：&quot;);
                int num2 = sc.nextInt();
                System.out.println(&quot;商：&quot;+num1/num2);
            &#125;catch(ArithmeticException ex)&#123;
                System.out.println(&quot;对不起，除数不可以为0&quot;);
            &#125;catch(InputMismatchException ex)&#123;
                System.out.println(&quot;对不起，你录入的数据不是int类型的数据&quot;);
            &#125;catch(Exception ex)&#123;
                System.out.println(&quot;对不起，你的程序出现异常&quot;);
            &#125;finally &#123;
                System.out.println(&quot;----谢谢你使用计算器111&quot;);
            &#125;
    &#125;
&#125;

</code></pre>
<h1 id="异常的分类"><a href="#异常的分类" class="headerlink" title="异常的分类"></a>异常的分类</h1><p>【1】层次结构：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC9%E7%AB%A0_%E5%BC%82%E5%B8%B8/49c007ec5d133e1d0e68827b9cf4b03e.png" class="">


<p>注意：程序中语法错误，逻辑错误 都不属于上面的Error，Exception</p>
<p>【2】运行时异常：</p>
<pre><code class="java">public class Test5 &#123;
    //这是一个main方法，是程序的入口：
    public static void main(String[] args) &#123;
        //运行时异常：
        int[] arr = &#123;1,2,3&#125;;
        System.out.println(arr.length);
        /\*int[] arr2 = null;
        System.out.println(arr2.length);\*/
            System.out.println(arr[10]);
    &#125;
&#125;
</code></pre>
<p>【3】检查异常：</p>
<p>处理方式1：try-catch嵌套try-catch</p>
<pre><code class="java">public class Test6 &#123;
    //这是一个main方法，是程序的入口：
    public static void main(String[] args) &#123;
        //检查异常：
        try &#123;
            try &#123;
                Class.forName(&quot;com.msb.test01.Test&quot;).newInstance();
            &#125; catch (InstantiationException e) &#123;
                e.printStackTrace();
            &#125; catch (IllegalAccessException e) &#123;
                e.printStackTrace();
            &#125;
        &#125; catch (ClassNotFoundException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;
</code></pre>
<p>处理方式2：多重catch</p>
<pre><code class="java">public class Test6 &#123;
    //这是一个main方法，是程序的入口：
    public static void main(String[] args) &#123;
        //检查异常：
        try &#123;
            Class.forName(&quot;com.msb.test01.Test&quot;).newInstance();
        &#125; catch (ClassNotFoundException \| InstantiationException \| IllegalAccessException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;
</code></pre>
<p>处理方式3：throws</p>
<pre><code class="java">public class Test6 &#123;
    //这是一个main方法，是程序的入口：
    public static void main(String[] args) throws ClassNotFoundException, IllegalAccessException, InstantiationException &#123;
        //检查异常：
        Class.forName(&quot;com.msb.test01.Test&quot;).newInstance();
    &#125;
&#125;
</code></pre>
<h1 id="throw和throws的区别"><a href="#throw和throws的区别" class="headerlink" title="throw和throws的区别"></a>throw和throws的区别</h1><pre><code class="java">import java.util.Scanner;

public class Test7 &#123;
    //这是一个main方法，是程序的入口：
    public static void main(String[] args) throws Exception &#123;
        //实现一个功能：两个数相除，当除数为0的时候，程序出现异常。
        /\*try &#123;
            devide();
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
        &#125;\*/
            devide();
    &#125;
    public static void devide() throws Exception &#123;
        Scanner sc = new Scanner(System.in);
        System.out.println(&quot;请录入第一个数：&quot;);
        int num1 = sc.nextInt();
        System.out.println(&quot;请录入第二个数：&quot;);
        int num2 = sc.nextInt();
        if(num2 == 0 )&#123;//除数为0 ，制造异常。
            //制造运行时异常：
            /\*throw new RuntimeException();\*/
                //制造检查异常：
                /\*try &#123;
                    throw new Exception();
                &#125; catch (Exception e) &#123;
                    e.printStackTrace();
                &#125;\*/
                    throw new Exception();
        &#125;else&#123;
            System.out.println(&quot;商：&quot;+num1/num2);
        &#125;
    &#125;
&#125;

</code></pre>
<p>总结：</p>
<p>throw和throws的区别：</p>
<p>（1）位置不同：</p>
<p>throw：方法内部</p>
<p>throws: 方法的签名处，方法的声明处</p>
<p>（2）内容不同：</p>
<p>throw+异常对象（检查异常，运行时异常）</p>
<p>throws+异常的类型（可以多个类型，用，拼接）</p>
<p>（3）作用不同：</p>
<p>throw：异常出现的源头，制造异常。</p>
<p>throws:在方法的声明处，告诉方法的调用者，这个方法中可能会出现我声明的这些异常。然后调用者对这个异常进行处理：</p>
<p>要么自己处理要么再继续向外抛出异常</p>
<h2 id="练习："><a href="#练习：" class="headerlink" title="练习："></a>练习：</h2><pre><code class="java">
public class Student &#123;
    private String name;
    private int age;
    private String sex;

    public String getName() &#123;
        return name;
    &#125;

    public void setName(String name) &#123;
        this.name = name;
    &#125;

    public int getAge() &#123;
        return age;
    &#125;

    public void setAge(int age) &#123;
        this.age = age;
    &#125;

    public String getSex() &#123;
        return sex;
    &#125;

    public void setSex(String sex) throws Exception &#123;
        if(sex.equals(&quot;男&quot;)\|\|sex.equals(&quot;女&quot;))&#123;
            this.sex = sex;
        &#125;else&#123;//非男非女
            //解决办法1：
            /\*this.sex = &quot;男&quot;;\*/
                //解决办法2：给个友好型提示，但是打印结果为默认的null效果
                /\*System.out.println(&quot;对不起，你的性别错误了&quot;);\*/
                //解决办法3：
                //制造运行时异常：
                /\*throw new RuntimeException(&quot;性别不对！&quot;);\*/
                //制造检查异常
                /\*try &#123;
                    throw new Exception();
                &#125; catch (Exception e) &#123;
                    e.printStackTrace();
                &#125;\*/
                    throw new Exception();
        &#125;
    &#125;

    @Override
    public String toString() &#123;
        return &quot;Student&#123;&quot; +
            &quot;name=&#39;&quot; + name + &#39;\\&#39;&#39; +
            &quot;, age=&quot; + age +
            &quot;, sex=&#39;&quot; + sex + &#39;\\&#39;&#39; +
            &#39;&#125;&#39;;
    &#125;

    public Student() &#123;
    &#125;

    public Student(String name, int age, String sex) &#123;
        this.name = name;
        this.age = age;
        //this.sex = sex;
        try &#123;
            this.setSex(sex);
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;



public class Test &#123;
    //这是一个main方法，是程序的入口：
    public static void main(String[] args) &#123;
        //创建一个Student的对象：
        /\*Student s = new Student();
        s.setName(&quot;菲菲&quot;);
        s.setAge(19);
        try &#123;
            s.setSex(&quot;asdfasdfasdf&quot;);
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
        &#125;
        System.out.println(s);\*/

            Student s2 = new Student(&quot;娜娜&quot;,21,&quot;asdfasdfasdf&quot;);
        System.out.println(s2);
    &#125;
&#125;

</code></pre>
<h1 id="重载和重写的异常"><a href="#重载和重写的异常" class="headerlink" title="重载和重写的异常"></a>重载和重写的异常</h1><img data-src="/2022/10/07/Java/%E7%AC%AC9%E7%AB%A0_%E5%BC%82%E5%B8%B8/cf74eead97b51814e21b234c60586c9a.png" class="">


<p>【1】重载：</p>
<pre><code class="java">public class Demo &#123;
    public void a() throws Exception&#123;

    &#125;
    public void a(int age) throws ArithmeticException&#123;

    &#125;
&#125;

</code></pre>
<p>【2】重写：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC9%E7%AB%A0_%E5%BC%82%E5%B8%B8/0ee7a011f038160bdfaa00237577e0c1.png" class="">


<img data-src="/2022/10/07/Java/%E7%AC%AC9%E7%AB%A0_%E5%BC%82%E5%B8%B8/3243038ec840d0d3cc6dc909e039f3df.png" class="">


<p>子类 &lt;&#x3D; 父类</p>
<h1 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h1><p>自定义的异常可以继承：运行时异常</p>
<pre><code class="java">public class MyException extends RuntimeException &#123;

    static final long serialVersionUID = -70348971907L;

    public MyException()&#123;

    &#125;
    public MyException(String msg)&#123;
        super(msg);
    &#125;
&#125;
</code></pre>
<p>也可以继承检查异常：</p>
<pre><code class="java">public class MyException extends Exception &#123;

    static final long serialVersionUID = -70348971907L;

    public MyException()&#123;

    &#125;
    public MyException(String msg)&#123;
        super(msg);
    &#125;
&#125;

</code></pre>
<p>如果继承的是运行时异常，那么在使用的时候无需额外处理</p>
<p>如果继承的是检查异常，那么使用的时候需要try-catch捕获或者throws向上抛</p>
]]></content>
      <categories>
        <category>JavaSE</category>
        <category>异常</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title>第8章_面向对象</title>
    <url>/2022/10/07/Java/%E7%AC%AC8%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h1 id="面向过程和面向对象的区别"><a href="#面向过程和面向对象的区别" class="headerlink" title="面向过程和面向对象的区别"></a>面向过程和面向对象的区别</h1><p>面向过程：当事件比较简单的时候，利用面向过程，注重的是事件的具体的步骤&#x2F;过程，注重的是过程中的具体的行为，以函数为最小单位，考虑怎么做。</p>
<p>面向对象：注重找“参与者”,将功能封装进对象，强调具备了功能的对象，以类&#x2F;对象为最小单位，考虑谁来做。</p>
<p>案例：</p>
<p>人把大象装进冰箱：</p>
<p>面向过程：</p>
<p>函数1：打开冰箱(){人站在冰箱前，打开冰箱，冰箱卡到30度角的时候，冰箱的灯打开了………}</p>
<p>函数2：储存大象(){大象先迈左腿，再迈右退，考虑冰箱能不能装下……}</p>
<p>函数3：关闭冰箱(){人站在冰箱前，关闭冰箱，冰箱开到30度角的时候，冰箱的灯关闭了……….}</p>
<p>面向对象：</p>
<p>人{</p>
<p>打开(冰箱){</p>
<p>冰箱.打开();</p>
<p>}</p>
<p>存储(大象){</p>
<p>大象.进入();</p>
<p>}</p>
<p>关闭(冰箱){</p>
<p>冰箱.关闭();</p>
<p>}</p>
<p>}</p>
<p>冰箱{</p>
<p>打开（）{ 1.2.3.}</p>
<p>关闭（）{}</p>
<p>}</p>
<p>柜子{</p>
<p>}</p>
<p>大象{</p>
<p>进入(冰箱){</p>
<p>}</p>
<p>}</p>
<p>面向过程 —&gt; 面向对象 , 其实就是由执行者 —&gt; 指挥者的 一个过渡</p>
<p>面向过程：编年体<br>面向对象：纪传体</p>
<p>二者相辅相成,并不是对立的。解决复杂问题,通过面向对象方式便于我们从宏观上把握事物之间复杂的关系、方便我们分析整个系统;具体到微观操作,仍然使用面向过程方式来处理</p>
<h1 id="类和对象的关系"><a href="#类和对象的关系" class="headerlink" title="类和对象的关系"></a>类和对象的关系</h1><p>【1】万事万物皆对象</p>
<p>【2】</p>
<p>对象：具体的事物，具体的实体，具体的实例，模板下具体的产品</p>
<p>类：对对象向上抽取出像的部分，公共的部分，形成类，类是抽象的，是一个模板</p>
<p>【3】一般在写代码的时候先写类，然后在根据类创建对应的对象。</p>
<h1 id="面向对象三个阶段"><a href="#面向对象三个阶段" class="headerlink" title="面向对象三个阶段"></a>面向对象三个阶段</h1><p>面向对象三个阶段：</p>
<p>【1】面向对象分析OOA – Object Oriented Analysis</p>
<p>对象：张三，王五，朱六，你，我</p>
<p>抽取出一个类—-》人类</p>
<p>类里面有什么：</p>
<p>动词–》动态特性–》方法</p>
<p>名词–》静态特性–》属性</p>
<p>【2】面向对象设计OOD – Object Oriented Design</p>
<p>先有类，再有对象：</p>
<p>类：人类： Person</p>
<p>对象：zhangsan ，lisi，zhuliu</p>
<p>【3】面向对象编程OOP – Object Oriented Programming</p>
<p>创建类：</p>
<p>（1）属性（field 成员变量）</p>
<p>属性用于定义该类或该类对象包含的数据或者说静态特征。属性作用范围是整个类体。</p>
<p>属性定义格式：</p>
<table>
<thead>
<tr>
<th>[修饰符] 方法返回值类型 方法名(形参列表) {   &#x2F;&#x2F; n条语句  }</th>
</tr>
</thead>
</table>
<p>（2）方法</p>
<p>方法用于定义该类或该类实例的行为特征和功能实现。方法是类和对象行为特征的抽象。方法很类似于面向过程中的函数。面向过程中，函数是最基本单位，整个程序由一个个函数调用组成。面向对象中，整个程序的基本单位是类，方法是从属于类和对象的。</p>
<p>方法定义格式：</p>
<table>
<thead>
<tr>
<th>[修饰符] 方法返回值类型 方法名(形参列表) {   &#x2F;&#x2F; n条语句  }</th>
</tr>
</thead>
</table>
<p>void代表没有返回值；方法的作用：重用代码，封装功能，便于修改</p>
<p>代码：</p>
<ol>
<li></li>
</ol>
<pre><code class="java">package com.msb;

public class Person &#123;
    //名词---》属性---》成员变量---》放在类中方法外（注意：我们只把有需要的内容写到代码里，不相关的东西不要放在代码中）
    int age ;//年龄
    String name;//姓名
    double height;//身高
    double weight;//体重

    //动词---》方法
    //吃饭
    public void eat()&#123;
        int num = 10;//局部变量：放在方法中
        System.out.println(&quot;我喜欢吃饭&quot;);
    &#125;
    //睡觉：
    public void sleep(String address)&#123;
        System.out.println(&quot;我在&quot;+address+&quot;睡觉&quot;);
    &#125;
    //自我介绍：
    public String introduce()&#123;
        return &quot;我的名字是：&quot;+name+&quot;，我的年龄是：&quot;+age+&quot;,我的身高是：&quot;+height+&quot;,我的体重是：&quot;+weight;
    &#125;
&#125;

</code></pre>
<h1 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h1><ol>
<li></li>
</ol>
<pre><code class="java">package com.msb;

public class Test &#123;//测试类

    //这是一个main方法，是程序的入口：
    public static void main(String[] args) &#123;
        //创建一个人类的具体的对象/实例：
        //创建一个对象，对象的名字叫：zs
        //Person 属于 引用数据类型
        //第一次加载类的时候，会进行类的加载，初始化创建对象的时候，对象的属性没有给赋值，有默认的初始化的值。
        Person zs = new Person();
        zs.name = &quot;张三&quot;;
        zs.age = 19;
        zs.height = 180.4;
        zs.weight = 170.4;

        //再创建一个对象：
        //再次创建类的时候，就不会进行类的加载了，类的加载只在第一次需要的时候加载一次
        Person ls = new Person();
        ls.name = &quot;李四&quot;;
        ls.age = 18;
        ls.height = 170.6;
        ls.weight = 160.5;

        //对属性值进行读取：
        System.out.println(zs.name);
        System.out.println(ls.age);

        //对方法进行操作：
        //不同的对象，属性有自己的特有的值，但是方法都是调用类中通用的方法。
        //属性：各个对象的属性是独立的，
        //方法：各个对象的方法是共享的。
        zs.eat();
        ls.eat();
        zs.sleep(&quot;教室&quot;);
        /\*String str = zs.introduce();
        System.out.println(str);\*/
            System.out.println(zs.introduce());
    &#125;
&#125;

</code></pre>
<h1 id="局部变量和成员变量的区别"><a href="#局部变量和成员变量的区别" class="headerlink" title="局部变量和成员变量的区别"></a>局部变量和成员变量的区别</h1><p><strong>区别1：</strong>代码中位置不同</p>
<p>成员变量：类中方法外定义的变量</p>
<p>局部变量：方法中定义的变量 代码块中定义的变量</p>
<p><strong>区别2：</strong>代码的作用范围</p>
<p>成员变量：当前类的很多方法</p>
<p>局部变量：当前一个方法（当前代码块）</p>
<p><strong>区别3：</strong>是否有默认值</p>
<p>成员变量：有</p>
<p>局部变量：没有</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC8%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/fa7d1bf775d1f357c4dec5d94d02d2f2.png" class="">


<p>引用数据类型： null</p>
<p><strong>区别4：</strong>是否要初始化</p>
<p>成员变量：不需要，不建议初始化，后续使用的时候再赋值即可</p>
<p>局部变量：一定需要，不然直接使用的时候报错</p>
<p><strong>区别5</strong>：内存中位置不同</p>
<p>成员变量：堆内存</p>
<p>局部变量：栈内存</p>
<p><strong>区别6：</strong>作用时间不同</p>
<p>成员变量：当前对象从创建到销毁</p>
<p>局部变量：当前方法从开始执行到执行完毕</p>
<p>代码：</p>
<ol>
<li>package com.msb;</li>
<li></li>
<li>&#x2F;**</li>
<li>* @Auther: msb-zhaoss</li>
<li>*&#x2F;</li>
</ol>
<pre><code class="java">public class Student &#123;
    byte e;
    short s;
    int c ;//成员变量：在类中方法外
    long num2;
    float f ;
    double d;
    char ch;
    boolean bo;
    String name;
    public void study()&#123;
        int num = 10 ; //局部变量：在方法中
        System.out.println(num);//10
        //int num ;重复命名，出错了
        &#123;
            int a;//局部变量：在代码块中
        &#125;
        int a;
        if(1==3)&#123;
            int b;
        &#125;
        System.out.println(c);
    &#125;
    public void eat()&#123;
        System.out.println(c);
    &#125;

    //这是一个main方法，是程序的入口：
    public static void main(String[] args) &#123;
        Student s = new Student();
        System.out.println(s.c);
        System.out.println(s.bo);
        System.out.println(s.ch);
        System.out.println(s.d);
        System.out.println(s.e);
        System.out.println(s.f);
        System.out.println(s.name);
        System.out.println(s.num2);
        System.out.println(s.s);

        s.d = 10.4;
    &#125;
&#125;

</code></pre>
<p>运行结果：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC8%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/92101fdba0ac0fe94fbe9079ab09ab40.png" class="">


<h1 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h1><pre><code class="java">public class Person &#123;
    //构造器：没有任何参数的构造器我们叫做：空参构造器--》空构造器
    public Person()&#123;
        /\*age = 19;
        name = &quot;lili&quot;;
        height = 169.5;\*/
    &#125;
    //属性：
    String name;
    int age;
    double height;
    //方法：
    public void eat()&#123;
        System.out.println(&quot;我喜欢吃饭&quot;);
    &#125;
&#125;

package com.msb2;

/\*\*
    \* @Auther: msb-zhaoss
        \*/
        public class Test &#123;
            //这是一个main方法，是程序的入口：
            public static void main(String[] args) &#123;
                //创建一个Person类的具体的对象/实例/实体：
                /\*
                    创建对象的过程：
                    1.第一次遇到Person的时候，进行类的加载（只加载一次）
                    2.创建对象，为这个对象在堆中开辟空间
                    3.为对象进行属性的初始化动作

                    new关键字实际上是在调用一个方法，这个方法叫构造方法（构造器）
                    调用构造器的时候，如果你的类中没有写构造器，那么系统会默认给你分配一个构造器，只是我们看不到罢了。
                    可以自己显式 的将构造器编写出来：
                    构造器的格式：
                    [修饰符] 构造器的名字()&#123;

                &#125;
                构造器和方法的区别：
                    1.没有方法的返回值类型
                    2.方法体内部不能有return语句
                    3.构造器的名字很特殊，必须跟类名一样

                    构造器的作用：不是为了创建对象，因为在调用构造器之前，这个对象就已经创建好了，并且属性有默认的初始化的值。
                    调用构造器的目的是给属性进行赋值操作的。

                    注意：我们一般不会在空构造器中进行初始化操作，因为那样的话每个对象的属性就一样了。
                    实际上，我们只要保证空构造器的存在就可以了，里面的东西不用写
                    \*/
                    Person p = new Person();
                System.out.println(p.age);
                System.out.println(p.name);
                System.out.println(p.height);

                Person p2 = new Person();
                System.out.println(p2.age);
                System.out.println(p2.name);
                System.out.println(p2.height);
            &#125;
        &#125;

</code></pre>
<h1 id="构造器的重载"><a href="#构造器的重载" class="headerlink" title="构造器的重载"></a>构造器的重载</h1><pre><code class="java">public class Person &#123;

    //属性：
    String name;
    int age;
    double height;

    //空构造器
    public Person()&#123;

    &#125;
    public Person(String name,int age,double height)&#123;
        //当形参名字和属性名字重名的时候，会出现就近原则：
        //在要表示对象的属性前加上this.来修饰 ，因为this代表的就是你创建的那个对象
        this.name = name;
        this.age = age;
        this.height = height;
    &#125;
    public Person(String a,int b)&#123;
        name = a;
        age = b;
    &#125;

    //方法：
    public void eat()&#123;
        System.out.println(&quot;我喜欢吃饭&quot;);
    &#125;
&#125;
package com.msb3.msb2;

/\*\*
    \* @Auther: msb-zhaoss
        \*/
        public class Test &#123;
            //这是一个main方法，是程序的入口：
            public static void main(String[] args) &#123;
                /\*
                    1.一般保证空构造器的存在，空构造器中一般不会进行属性的赋值操作
                    2.一般我们会重载构造器，在重载的构造器中进行属性赋值操作
                    3.在重载构造器以后，假如空构造器忘写了，系统也不会给你分配默认的空构造器了，那么你要调用的话就会出错了。
                    4\. 当形参名字和属性名字重名的时候，会出现就近原则：
                    在要表示对象的属性前加上this.来修饰 ，因为this代表的就是你创建的那个对象

                    \*/

                    Person p = new Person();
                /\*p.age = 19;
                p.name = &quot;lili&quot;;
                p.height = 180.4;\*/

                    Person p2 = new Person(&quot;lili&quot;,19,180.4);
                System.out.println(p2.age);
                System.out.println(p2.height);
                System.out.println(p2.name);

            &#125;
        &#125;
</code></pre>
<h1 id="内存分析"><a href="#内存分析" class="headerlink" title="内存分析"></a>内存分析</h1><h2 id="代码1"><a href="#代码1" class="headerlink" title="代码1"></a>代码1</h2><table>
<thead>
<tr>
<th>public class Person {   int id;   int age;    public static void main(String args[]){   Person p1&#x3D; new Person();   }  }</th>
</tr>
</thead>
</table>
<p>内存分析：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC8%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/79c1914e1e30446244e44849e42197d1.png" class="">


<h2 id="代码2"><a href="#代码2" class="headerlink" title="代码2"></a>代码2</h2><pre><code class="java">public class Person &#123;
    int id;
    int age;
    String school;
    public Person (int a,int b,String c)&#123;
        id=a;
        age=b;
        school=c;
    &#125;
    public static void main(String args[])&#123;
        Person p= new Person(1,20, &quot;海淀&quot;);
    &#125;
&#125;
</code></pre>
<img data-src="/2022/10/07/Java/%E7%AC%AC8%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/c1037dadb36bf06b082ec248a4d08482.png" class="">


<h2 id="代码3"><a href="#代码3" class="headerlink" title="代码3"></a>代码3</h2><table>
<thead>
<tr>
<th>class Person{   int id;   int age;   String school;   Person (int a,int b,String c){   id&#x3D;a;   age&#x3D;b;   school&#x3D;c;   }    public void setAge(int a){   age&#x3D;a;   }  }</th>
</tr>
</thead>
</table>
<pre><code class="java">
</code></pre>
<p>|————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————–|</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC8%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/886999b72f2ada92abc161d2ab8e4df0.png" class="">


<p>this</p>
<p>【1】创建对象的过程：</p>
<p>（1）在第一次遇到一个类的时候，对这个类要进行加载，只加载一次。</p>
<p>（2）创建对象，在堆中开辟空间</p>
<p>（3）对对象进行初始化操作，属性赋值都是默认的初始值。</p>
<p>（4）new关键字调用构造器，执行构造方法，在构造器中对属性重新进行赋值</p>
<p>this:</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC8%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/e59335fd9cf3566613aab1164ac0711b.png" class="">


<img data-src="/2022/10/07/Java/%E7%AC%AC8%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/5b8476d675f8c1b9000590c4031a7005.png" class="">


<p>从上面的效果能够看到：this指代的就是当前对象：</p>
<p>内存：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC8%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/4eda9c8a53fa801bd70b6fe32f281919.png" class="">


<p>this关键字 用法：</p>
<p>（1）this可以修饰属性：</p>
<p>总结：当属性名字和形参发生重名的时候，或者 属性名字 和局部变量重名的时候，都会发生就近原则，所以如果我要是直接使用变量名字的话就指的是离的近的那个形参或者局部变量，这时候如果我想要表示属性的话，在前面要加上：this.修饰</p>
<p>如果不发生重名问题的话，实际上你要是访问属性也可以省略this.</p>
<pre><code class="java">public class Person &#123;
    //属性
    int age;
    String name;
    double height;
    //空构造器
    public Person()&#123;

    &#125;
    //有参构造器
    public Person(int age,String name,double height)&#123;
        this.age = age;
        this.name = name;
        this.height = height;
    &#125;
    //方法：
    public void eat()&#123;
        int age = 10;
        System.out.println(age);//就近原则，age指的是离它近的age--》局部变量的age
        System.out.println(this.age);//这里指代的就是属性的age
        System.out.println(&quot;我喜欢吃饭&quot;);
    &#125;
&#125;

</code></pre>
<p>（2）this修饰方法：</p>
<p>总结：在同一个类中，方法可以互相调用，this.可以省略不写。</p>
<pre><code class="java">public class Person &#123;
    //属性
    int age;
    String name;
    double height;
    //空构造器
    public Person()&#123;

    &#125;
    //有参构造器
    public Person(int age,String name,double height)&#123;
        this.age = age;
        this.name = name;
        this.height = height;
    &#125;
    //方法：
    /\*public void eat()&#123;
        int age = 10;
        System.out.println(age);//就近原则，age指的是离它近的age--》局部变量的age
        System.out.println(this.age);//这里指代的就是属性的age
        System.out.println(&quot;我喜欢吃饭&quot;);
    &#125;\*/

        public void play()&#123;
        /\*this.\*/eat();
        System.out.println(&quot;上网&quot;);
        System.out.println(&quot;洗澡&quot;);
    &#125;

    public void eat()&#123;
        System.out.println(/\*this.\*/age);
        System.out.println(&quot;吃饭&quot;);
    &#125;
&#125;

</code></pre>
<p>（3）this可以修饰构造器：</p>
<p>总结：同一个类中的构造器可以相互用this调用，注意：this修饰构造器必须放在第一行</p>
<pre><code class="java">public class Person &#123;
    //属性
    int age;
    String name;
    double height;
    //空构造器
    public Person()&#123;

    &#125;
    //有参构造器
    public Person(int age,String name,double height)&#123;
        this(age,name);
        this.height = height;

    &#125;
    public Person(int age,String name)&#123;
        this(age);
        this.name = name;
    &#125;
    public Person(int age)&#123;
        this.age = age;
    &#125;
    //方法：
    /\*public void eat()&#123;
        int age = 10;
        System.out.println(age);//就近原则，age指的是离它近的age--》局部变量的age
        System.out.println(this.age);//这里指代的就是属性的age
        System.out.println(&quot;我喜欢吃饭&quot;);
    &#125;\*/

        public void play()&#123;
        /\*this.\*/eat();
        System.out.println(&quot;上网&quot;);
        System.out.println(&quot;洗澡&quot;);
    &#125;

    public void eat()&#123;
        System.out.println(/\*this.\*/age);
        System.out.println(&quot;吃饭&quot;);
    &#125;
&#125;

</code></pre>
<h1 id="static"><a href="#static" class="headerlink" title="static"></a>static</h1><p>【1】static可以修饰：属性，方法，代码块，内部类。</p>
<p>【2】static修饰属性；</p>
<pre><code class="java">public class Test &#123;
    //属性：
    int id;
    static int sid;

    //这是一个main方法，是程序的入口：
    public static void main(String[] args) &#123;
        //创建一个Test类的具体的对象
        Test t1 = new Test();
        t1.id = 10;
        t1.sid = 10;

        Test t2 = new Test();
        t2.id = 20;
        t2.sid = 20;

        Test t3 = new Test();
        t3.id = 30;
        t3.sid = 30;

        //读取属性的值：
        System.out.println(t1.id);
        System.out.println(t2.id);
        System.out.println(t3.id);

        System.out.println(t1.sid);
        System.out.println(t2.sid);
        System.out.println(t3.sid);

    &#125;
&#125;

</code></pre>
<p>内存分析：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC8%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/86494081f26104991702618717098030.png" class="">


<p>一般官方的推荐访问方式：可以通过类名.属性名的方式去访问：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC8%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/300391675e1efe8df337d8171c8bb6d7.png" class="">


<p>static修饰属性总结：</p>
<p>（1）在类加载的时候一起加载入方法区中的静态域中</p>
<p>（2）先于对象存在</p>
<p>（3）访问方式： 对象名.属性名 类名.属性名（推荐）</p>
<p>static修饰属性的应用场景：某些特定的数据想要在内存中共享，只有一块 –》这个情况下，就可以用static修饰的属性</p>
<pre><code class="java">public class MsbStudent &#123;
    //属性：
    String name;
    int age;
    static String school;

    //这是一个main方法，是程序的入口：
    public static void main(String[] args) &#123;
        MsbStudent.school = &quot;马士兵教育&quot;;
        //创建学生对象：
        MsbStudent s1 = new MsbStudent();
        s1.name = &quot;张三&quot;;
        s1.age = 19;
        //s1.school = &quot;马士兵教育&quot;;

        MsbStudent s2 = new MsbStudent();
        s2.name = &quot;李四&quot;;
        s2.age = 21;
        //s2.school = &quot;马士兵教育&quot;;

        System.out.println(s2.school);




    &#125;

&#125;

</code></pre>
<p>属性：</p>
<p>静态属性 （类变量）</p>
<p>非静态属性（实例变量）</p>
<p>【3】static修饰方法；</p>
<pre><code class="java">public class Demo &#123;
    int id;
    static int sid;

    public void a()&#123;
        System.out.println(id);
        System.out.println(sid);
        System.out.println(&quot;------a&quot;);
    &#125;
    //1.static和public都是修饰符，并列的没有先后顺序，先写谁后写谁都行
    static public void b()&#123;
        //System.out.println(this.id);//4.在静态方法中不能使用this关键字
        //a();//3.在静态方法中不能访问非静态的方法
        //System.out.println(id);//2.在静态方法中不能访问非静态的属性
        System.out.println(sid);
        System.out.println(&quot;------b&quot;);
    &#125;

    //这是一个main方法，是程序的入口：
    public static void main(String[] args) &#123;
        //5.非静态的方法可以用对象名.方法名去调用
        Demo d = new Demo();
        d.a();
        //6.静态的方法可以用 对象名.方法名去调用 也可以 用 类名.方法名 （推荐）
        Demo.b();
        d.b();
        &#123;% asset_img 4bb83b402c7aad5b29b09c46fe3a60b9.png  %&#125;
    &#125;
&#125;

</code></pre>
<h1 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h1><p>【1】类的组成：属性，方法，构造器，代码块，内部类</p>
<p>【2】代码块分类：普通块，构造块，静态块，同步块（多线程）</p>
<p>【3】代码：</p>
<pre><code class="java">public class Test &#123;
    //属性
    int a;
    static int sa;

    //方法
    public void a()&#123;
        System.out.println(&quot;-----a&quot;);
        &#123;
            //普通块限制了局部变量的作用范围
            System.out.println(&quot;这是普通块&quot;);
            System.out.println(&quot;----000000&quot;);
            int num = 10;
            System.out.println(num);
        &#125;
        //System.out.println(num);
        //if()&#123;&#125;
        //while()&#123;&#125;
    &#125;
    public static void b()&#123;
        System.out.println(&quot;------b&quot;);
    &#125;

    //构造块
    &#123;
        System.out.println(&quot;------这是构造块&quot;);
    &#125;
    //静态块
    static&#123;
        System.out.println(&quot;-----这是静态块&quot;);
        //在静态块中只能方法：静态属性，静态方法
        System.out.println(sa);
        b();
    &#125;


    //构造器
    public Test()&#123;
        System.out.println(&quot;这是空构造器&quot;);
    &#125;
    public Test(int a)&#123;
        this.a = a;
    &#125;


    //这是一个main方法，是程序的入口：
    public static void main(String[] args) &#123;
        Test t = new Test();
        t.a();

        Test t2 = new Test();
        t2.a();
    &#125;



&#125;

</code></pre>
<p>总结：</p>
<p>（1）代码块执行顺序：</p>
<p>最先执行静态块，只在类加载的时候执行一次，所以一般以后实战写项目：创建工厂，数据库的初始化信息都放入静态块。</p>
<p>一般用于执行一些全局性的初始化操作。</p>
<p>再执行构造块，（不常用）</p>
<p>再执行构造器，</p>
<p>再执行方法中的普通块。</p>
<h1 id="包，import"><a href="#包，import" class="headerlink" title="包，import"></a>包，import</h1><p>【1】生活案例：</p>
<p>邮寄快递：中国.北京.通州区.****小区.5号楼.3单元.101房.赵珊珊</p>
<p>历史：常山赵子龙</p>
<p>【2】包的作用：</p>
<p>为了解决重名问题（实际上包对应的就是盘符上的目录）</p>
<p>解决权限问题</p>
<p>【3】创建包：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC8%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/4c01c78e65328aa2cc03c43c7dc51cd7.png" class="">


<img data-src="/2022/10/07/Java/%E7%AC%AC8%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/b813c37b6345ac6463be51d3c6c7ff77.png" class="">


<p>包名定义：</p>
<p>（1）名字全部小写</p>
<p>（2）中间用.隔开</p>
<p>（3）一般都是公司域名倒着写 ： com.jd com.msb</p>
<p>（4）加上模块名字：</p>
<p>com.jd.login com.jd.register</p>
<p>（5）不能使用系统中的关键字：nul,con,com1—com9…..</p>
<p>（6）包声明的位置一般都在非注释性代码的第一行：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC8%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/c54ecb2742a2b971e196ee55f9ab9193.png" class="">


<p>【4】导包问题：</p>
<pre><code class="java">import com.msb2.Person; //导包：就是为了进行定位

import java.util.Date;

public class Test &#123;
    //这是一个main方法，是程序的入口：
    public static void main(String[] args) &#123;
        new Person();
        new Date();
        new java.sql.Date(1000L);//在导包以后，还想用其他包下同名的类，就必须要手动自己写所在的包。
        new Demo();
    &#125;
&#125;

</code></pre>
<p>总结：</p>
<pre><code class="java">
</code></pre>
<p>（2）在导包以后，还想用其他包下同名的类，就必须要手动自己写所在的包。</p>
<p>（3）同一个包下的类想使用不需要导包，可以直接使用。</p>
<p>（4）在java.lang包下的类，可以直接使用无需导包：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC8%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/0b7459093a2491a103c60fc5b7d9a6b9.png" class="">


<p>（5）IDEA中导包快捷键：alt+enter</p>
<p>可以自己设置自动导包</p>
<p>（6）可以直接导入*：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC8%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/69d91ed24222309df909ff777d89d08f.png" class="">


<p>【5】在Java中的导包没有包含和被包含的关系：</p>
<p>设置目录平级的格式（不是包含和被包含的显示）：  </p>
<img data-src="/2022/10/07/Java/%E7%AC%AC8%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/26efc24659a7281452240f746bfc8f2f.png" class="">


<img data-src="/2022/10/07/Java/%E7%AC%AC8%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/6d440aaefd446325e269a62253689110.png" class="">


<p>【6】静态导入：</p>
<ol>
<li>package com.msb11;</li>
<li>&#x2F;&#x2F;静态导入：</li>
</ol>
<pre><code class="java"> import static java.lang.Math.\*;
 //导入：java.lang下的Math类中的所有静态的内容

 public class Test &#123;
 //这是一个main方法，是程序的入口：
 public static void main(String[] args) &#123;
 System.out.println(random());
 System.out.println(PI);
 System.out.println(round(5.6));
 &#125;
 //在静态导入后，同一个类中有相同的方法的时候，会优先走自己定义的方法。
 public static int round(double a)&#123;
 return 1000;
 &#125;
 &#125;
 
</code></pre>
<h1 id="三大特性"><a href="#三大特性" class="headerlink" title="三大特性"></a>三大特性</h1><h2 id="封装-Encapsulation"><a href="#封装-Encapsulation" class="headerlink" title="封装(Encapsulation)"></a>封装(Encapsulation)</h2><p><strong>【1】生活案例：</strong></p>
<p>ATM , 电线</p>
<p><strong>【2】Java中封装的理解：</strong></p>
<p>将某些东西进行隐藏，然后提供相应的方式进行获取。</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC8%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/95a55583bf15b892c21ed0eb2380eed9.png" class="">


<p>我们程序设计追求“高内聚，低耦合”。</p>
<p>➢高内聚:类的内部数据操作细节自己完成，不允许外部干涉;</p>
<p>➢低耦合:仅对外暴露少量的方法用于使用。</p>
<p>隐藏对象内部的复杂性，只对外公开简单的接口。便于外界调用，从而提</p>
<p>高系统的可扩展性、可维护性。通俗的说，把该隐藏的隐藏起来，该暴露</p>
<p>的暴露出来。这就是封装性的设计思想。</p>
<p><strong>【3】封装的好处：</strong></p>
<p>提高代码的安全性</p>
<p><strong>【4】代码：通过一个属性感受封装：</strong></p>
<ol>
<li>package com.msb.test01;</li>
<li></li>
<li>&#x2F;**</li>
<li>* @Auther: msb-zhaoss</li>
<li>*&#x2F;</li>
</ol>
<pre><code class="java">public class Girl &#123;//女孩
    //属性：
    private int age;

    //读取年龄：
    public int duquAge()&#123;
        return age;
    &#125;

    //设置年龄：
    public void shezhiAge(int age)&#123;
        if(age \&gt;= 30 )&#123;
            this.age = 18;
        &#125;else&#123;
            this.age = age;
        &#125;

    &#125;


&#125;

package com.msb.test01;


public class Test &#123;
    //这是一个main方法，是程序的入口：
    public static void main(String[] args) &#123;
        //创建一个Girl类的对象：
        Girl g = new Girl();
        /\*g.age = 33;
        System.out.println(g.age);\*/
            //设置年龄：
            g.shezhiAge(31);
        //读取年龄：
        System.out.println(g.duquAge());

    &#125;
&#125;

</code></pre>
<p>上面的代码，对于属性age来说，我加了修饰符private，这样外界对它的访问就受到了限制，现在我还想加上其他的限制条件，但是在属性本身上没有办法再加了，所以我们通过定义方法来进行限制条件的添加。</p>
<p>以属性为案例：</p>
<p>进行封装：</p>
<p>（1）将属性私有化，被private修饰–》加入权限修饰符</p>
<p>一旦加入了权限修饰符，其他人就不可以随意的获取这个属性</p>
<p>（2）提供public修饰的方法让别人来访问&#x2F;使用</p>
<p>（3）即使外界可以通过方法来访问属性了，但是也不能随意访问，因为咱们在方法中可以加入 限制条件。</p>
<p><strong>【5】实际开发中，方法一般会写成 setter，getter方法：</strong></p>
<p>可以利用IDEA快捷键生成：alt+insert –&gt;getter and setter:</p>
<pre><code class="java">public class Girl &#123;//女孩
    //属性：
    private int age;

    //读取年龄：
    public int getAge()&#123;
        return age;
    &#125;

    //设置年龄：
    public void setAge(int age)&#123;
        if(age \&gt;= 30 )&#123;
            this.age = 18;
        &#125;else&#123;
            this.age = age;
        &#125;
    &#125;
&#125;

</code></pre>
<p><strong>【6】加深练习：</strong></p>
<pre><code class="java">public class Student &#123;
    //属性：
    private int age;
    private String name;
    private String sex;

    //加入对应的setter和getter方法：
    public int getAge() &#123;
        return age;
    &#125;

    public void setAge(int age) &#123;
        this.age = age;
    &#125;

    public String getName() &#123;
        return name;
    &#125;

    public void setName(String name) &#123;
        this.name = name;
    &#125;

    public String getSex() &#123;
        return sex;
    &#125;

    public void setSex(String sex) &#123;
        if(&quot;男&quot;.equals(sex) \|\| &quot;女&quot;.equals(sex) )&#123;//sex是男 或者 是 女
            this.sex = sex;
        &#125;else&#123;
            this.sex = &quot;男&quot;;
        &#125;
    &#125;

    //加入构造器：
    public Student()&#123;

    &#125;

    public Student(int age,String name,String sex)&#123;
        this.age = age;
        this.name = name;
        //this.sex = sex;
        this.setSex(sex);
    &#125;
&#125;

package com.msb.test2;


public class Test &#123;
    //这是一个main方法，是程序的入口：
    public static void main(String[] args) &#123;
        //创建一个Student对象：
        Student s1 = new Student();
        s1.setName(&quot;nana&quot;);
        s1.setAge(19);
        s1.setSex(&quot;女&quot;);
        System.out.println(s1.getName()+&quot;---&quot;+s1.getAge()+&quot;----&quot;+s1.getSex());

        Student s2 = new Student(18,&quot;菲菲&quot;,&quot;asdfasdfsadf&quot;);
        System.out.println(s2.getName()+&quot;---&quot;+s2.getAge()+&quot;----&quot;+s2.getSex());
    &#125;
&#125;

</code></pre>
<h2 id="继承-Inheritance"><a href="#继承-Inheritance" class="headerlink" title="继承(Inheritance)"></a>继承(Inheritance)</h2><p><strong>【1】类是对对象的抽象：</strong></p>
<p>举例：</p>
<p>荣耀20 ，小米 红米3，华为 p40 pro —&gt; 类：手机类</p>
<p><strong>【2】继承是对类的抽象：</strong></p>
<p>举例：</p>
<p>学生类：Student：</p>
<p>属性：姓名，年龄，身高，学生编号</p>
<p>方法：吃饭，睡觉，喊叫，学习</p>
<p>教师类：Teacher:</p>
<p>属性：姓名，年龄，身高，教师编号</p>
<p>方法：吃饭，睡觉，喊叫，教学</p>
<p>员工类：Emploee:</p>
<p>属性：姓名，年龄，身高，员工编号</p>
<p>方法：吃饭，睡觉，喊叫，工作</p>
<p>共同的东西：</p>
<p>人类：</p>
<p>属性：姓名，年龄，身高</p>
<p>方法：吃饭，睡觉，喊叫</p>
<p>学生类&#x2F;教师类&#x2F;员工类 继承 自 人类</p>
<p>以后定义代码：</p>
<p>先定义人类：</p>
<p>人类： —》父类，基类，超类</p>
<p>属性：姓名，年龄，身高</p>
<p>方法：吃饭，睡觉，喊叫</p>
<p>再定义 ： —》子类，派生类</p>
<p>学生类：Student：</p>
<p>属性：学生编号</p>
<p>方法：学习</p>
<p>教师类：Teacher:</p>
<p>属性：教师编号</p>
<p>方法：教学</p>
<p>员工类：Emploee:</p>
<p>属性：员工编号</p>
<p>方法：工作</p>
<p>子类 继承自 父类</p>
<p>狗类：</p>
<p>属性：姓名，年龄，身高</p>
<p>方法：吃饭，睡觉，喊叫</p>
<p>我们的继承关系，是在合理的范围中进行的抽取 ，抽取出子类父类的关系：</p>
<p>上面的案例中：</p>
<p>学生类&#x2F;教师类&#x2F;员工类 继承 自 人类 —》合理</p>
<p>学生类&#x2F;教师类&#x2F;员工类 继承 自 狗类 —》不合理</p>
<p>区分：</p>
<p>学生是一个人</p>
<p>教师是一个人</p>
<p>员工是一个人 —》合理</p>
<p>学生是一个狗 —》不合理</p>
<p>总结：继承 就是 is - a 的关系</p>
<p><strong>【3】代码层面的解释：</strong></p>
<p>先写父类，再写子类：</p>
<p>父类：人类 Person</p>
<p>子类：学生类 Student</p>
<ol>
<li>package com.msb.test03;</li>
<li></li>
<li>&#x2F;**</li>
<li>* @Auther: msb-zhaoss</li>
<li>*&#x2F;</li>
</ol>
<pre><code class="java">public class Person &#123;
    //属性：
    private int age;
    private String name;
    private double height;

    //提供setter getter方法：

    public int getAge() &#123;
        return age;
    &#125;

    public void setAge(int age) &#123;
        this.age = age;
    &#125;

    public String getName() &#123;
        return name;
    &#125;

    public void setName(String name) &#123;
        this.name = name;
    &#125;

    public double getHeight() &#123;
        return height;
    &#125;

    public void setHeight(double height) &#123;
        this.height = height;
    &#125;

    //方法：
    public void eat()&#123;
        System.out.println(&quot;可以吃饭。。。&quot;);
    &#125;

    public void sleep()&#123;
        System.out.println(&quot;可以睡觉。。。&quot;);
    &#125;

&#125;
</code></pre>
<pre><code class="java">
package com.msb.test03;

public class Student extends Person &#123;//子类Student 继承 父类Person
    //属性：
    private int sno;//学号

    public int getSno() &#123;
        return sno;
    &#125;

    public void setSno(int sno) &#123;
        this.sno = sno;
    &#125;

    //方法：
    public void study()&#123;
        System.out.println(&quot;学生可以学习&quot;);
    &#125;

&#125;
</code></pre>
<pre><code class="java">package com.msb.test03;

public class Test &#123;
    //这是一个main方法，是程序的入口：
    public static void main(String[] args) &#123;
        //创建子类Student的对象
        Student s = new Student();
        s.setSno(1001);
        s.setAge(18);
        s.setName(&quot;菲菲&quot;);
        s.setHeight(180.4);

        System.out.println(&quot;学生名字为：&quot;+s.getName()+&quot;,学生的年纪：&quot;+s.getAge());

        //访问方法：
        s.study();
        s.eat();
        s.sleep();
    &#125;
&#125;
</code></pre>
<p><strong>【4】继承的好处：</strong>提高代码的复用性</p>
<p>父类定义的内容，子类可以直接拿过来用就可以了，不用代码上反复重复定义了</p>
<p>需要注意的点：</p>
<p>父类private修饰的内容，子类实际上也继承，只是因为封装的特性阻碍了直接调用，但是提供了间接调用的方式，可以间接调用。</p>
<p><strong>【5】总结：</strong></p>
<p><strong>（1）继承关系 ：</strong></p>
<p>父类&#x2F;基类&#x2F;超类</p>
<p>子类&#x2F;派生类</p>
<p>子类继承父类一定在合理的范围进行继承的 子类 extends 父类</p>
<p><strong>（2）继承的好处：</strong></p>
<p>1.提高了代码的复用性，父类定义的内容，子类可以直接拿过来用就可以了，不用代码上反复重复定义了</p>
<p>2.便于代码的扩展</p>
<p>3.为了以后多态的使用。是多态的前提。</p>
<p>（3）父类private修饰的内容，子类也继承过来了。</p>
<p>（4）一个父类可以有多个子类。</p>
<p>（5）一个子类只能有一个直接父类。</p>
<p>但是可以间接的继承自其它类。</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC8%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/853b3f04c4932ab081cea980b8b93937.png" class="">


<p>（6）继承具有传递性：</p>
<p>Student –》继承自 Person —》继承自Object</p>
<p>Object类是所有类的根基父类。</p>
<p>所有的类都直接或者间接的继承自Object。</p>
<h3 id="内存分析-1"><a href="#内存分析-1" class="headerlink" title="内存分析"></a>内存分析</h3><img data-src="/2022/10/07/Java/%E7%AC%AC8%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/efb4a8c9189aea82cd25ed76bb83892b.png" class="">


<h3 id="权限修饰符"><a href="#权限修饰符" class="headerlink" title="权限修饰符"></a>权限修饰符</h3><img data-src="/2022/10/07/Java/%E7%AC%AC8%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/6362352d7d72827f6e8330b2314e50fe.png" class="">


<p>【1】private：权限：在当前类中可以访问</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC8%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/f49850ada620326d3c6e3e969491ea0f.png" class="">


<img data-src="/2022/10/07/Java/%E7%AC%AC8%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/d1051cf6836474d0bd46cebbc5e9f2b7.png" class="">


<img data-src="/2022/10/07/Java/%E7%AC%AC8%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/748f9a251587c5c3f527c6b60ae68961.png" class="">


<p>【2】default:缺省修饰符：权限：到同一个包下的其他类都可以访问</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC8%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/a9adb2a0ee7b22a158499bdf9264e927.png" class="">


<img data-src="/2022/10/07/Java/%E7%AC%AC8%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/507700aaac0bb1ea4c9ea49935843e06.png" class="">


<img data-src="/2022/10/07/Java/%E7%AC%AC8%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/a1884c8b37bef224d8111b5d03a6fba7.png" class="">


<p>【3】protected：权限：最大到不同包下的子类</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC8%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/c9f4fec14f259e36b1d3b1d0f84666a1.png" class="">


<img data-src="/2022/10/07/Java/%E7%AC%AC8%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/14538a4729c730bee00cb172b0bbaf69.png" class="">


<img data-src="/2022/10/07/Java/%E7%AC%AC8%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/1ba8b04d798285212551e94f9beb2a27.png" class="">


<p>【4】public：在整个项目中都可以访问</p>
<p>总结：</p>
<p>属性，方法：修饰符：四种：private，缺省，protected，public</p>
<p>类：修饰符：两种：缺省，public</p>
<p>以后写代码</p>
<p>一般属性：用private修饰 ，方法：用public修饰</p>
<h3 id="方法的重写"><a href="#方法的重写" class="headerlink" title="方法的重写"></a>方法的重写</h3><p><strong>【1】重写：</strong></p>
<p>发生在子类和父类中，当子类对父类提供的方法不满意的时候，要对父类的方法进行重写。</p>
<p><strong>【2】重写有严格的格式要求：</strong></p>
<p>子类的方法名字和父类必须一致，参数列表（个数，类型，顺序）也要和父类一致。</p>
<p><strong>【3】代码：</strong></p>
<pre><code class="java">public class Person &#123;
    public void eat()&#123;
        System.out.println(&quot;吃食物&quot;);
    &#125;
    public void sleep()&#123;
        System.out.println(&quot;睡觉&quot;);
    &#125;
&#125;

public class Student extends Person &#123;
    public void study()&#123;
        System.out.println(&quot;学习&quot;);
    &#125;
    @override
    public void eat()&#123;
        System.out.println(&quot;我喜欢吃小龙虾喝啤酒。。&quot;);
    &#125;
&#125;
</code></pre>
<img data-src="/2022/10/07/Java/%E7%AC%AC8%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/bd618aafd593ad295ce5c750618dc32a.png" class="">


<pre><code class="java">public class Test &#123;
    //这是一个main方法，是程序的入口：
    public static void main(String[] args) &#123;
        //创建一个Student类的对象：
        Student s = new Student();
        s.eat();
    &#125;
&#125;
</code></pre>
<p><strong>【4】内存：</strong></p>
<img data-src="/2022/10/07/Java/%E7%AC%AC8%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/e938358a339565fc850e88e0fb056438.png" class="">


<p><strong>【5】重载和重写的区别：</strong></p>
<p>重载：在同一个类中，当方法名相同，形参列表不同的时候 多个方法构成了重载</p>
<p>重写：在不同的类中，子类对父类提供的方法不满意的时候，要对父类的方法进行重写。</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC8%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/d5872fc2effee86b2e0573634c6c876c.png" class="">


<h3 id="super"><a href="#super" class="headerlink" title="super"></a>super</h3><p>【1】super:指的是： 父类的</p>
<p>【2】super可以修饰属性，可以修饰方法；</p>
<p>在子类的方法中，可以通过 super.属性 super.方法 的方式，显示的去调用父类提供的属性，方法。在通常情况下，super.可以省略不写：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC8%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/9c34efb863bf488a0d6c9a5e631a6a1d.png" class="">


<p>在特殊情况下，当子类和父类的属性重名时，你要想使用父类的属性，必须加上修饰符super.，只能通过super.属性来调用</p>
<p>在特殊情况下，当子类和父类的方法重名时，你要想使用父类的方法，必须加上修饰符super.，只能通过super.方法来调用</p>
<p>在这种情况下，super.就不可以省略不写。</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC8%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/af3658cad9ff80c0cd50ec8a8957809b.png" class="">


<p><strong>【3】super修饰构造器：</strong></p>
<p>其实我们平时写的构造器的第一行都有：super() –&gt;作用：调用父类的空构造器，只是我们一般都省略不写</p>
<p>（所有构造器的第一行默认情况下都有super(),但是一旦你的构造器中显示的使用super调用了父类构造器，那么这个super()就不会给你默认分配了。如果构造器中没有显示的调用父类构造器的话，那么第一行都有super(),可以省略不写）</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC8%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/f83b1b34f45ed2c2fa508c0bfd3edff2.png" class="">


<p>如果构造器中已经显示的调用super父类构造器，那么它的第一行就没有默认分配的super();了</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC8%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/2b726c25c19f6d0bda87b121df9e5c17.png" class="">


<p>在构造器中，super调用父类构造器和this调用子类构造器只能存在一个，两者不能共存：</p>
<p>因为super修饰构造器要放在第一行，this修饰构造器也要放在第一行：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC8%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/0d12186c6df4682072262dac8a7ebc6b.png" class="">


<p>改正二选一即可：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC8%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/b1232bfc50729fc5ae34b3bb8e24c495.png" class="">


<p><strong>【4】以后写代码构造器的生成可以直接使用IDEA提供的快捷键：</strong></p>
<p>alt+insert</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC8%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/3a4ffc5a8078225efe692487eaaa27f9.png" class="">


<h3 id="继承条件下构造方法的执行过程"><a href="#继承条件下构造方法的执行过程" class="headerlink" title="继承条件下构造方法的执行过程"></a>继承条件下构造方法的执行过程</h3><img data-src="/2022/10/07/Java/%E7%AC%AC8%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/e486184aee5d5ed004fbe3a9bc06497a.png" class="">




<pre><code class="java">public class Person &#123;
    int age;
    String name;

    public Person(int age, String name) &#123;
        super();
        this.age = age;
        this.name = name;
    &#125;

    public Person() &#123;
    &#125;
&#125;

public class Student extends Person &#123;
    double height ;

    public Student() &#123;
    &#125;

    public Student(int age, String name, double height) &#123;
        super(age, name);
        this.height = height;
    &#125;
&#125;

public class Test &#123;
    //这是一个main方法，是程序的入口：
    public static void main(String[] args) &#123;
        Student s = new Student(19,&quot;feifei&quot;,160.8);
    &#125;
&#125;

</code></pre>
<h3 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h3><p>所有类都直接或间接的继承自Object类，Object类是所有Java类的根基类。</p>
<p>也就意味着所有的Java对象都拥有Object类的属性和方法。</p>
<p>如果在类的声明中未使用extends关键字指明其父类，则默认继承Object类。</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC8%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/aeccaa6fc133025b43dc6e9670f17d44.png" class="">


<p>toString()方法</p>
<p><strong>【1】Object类的toString()的作用：</strong></p>
<img data-src="/2022/10/07/Java/%E7%AC%AC8%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/899bcc0c91c446dfb749301b53563996.png" class="">


<p>方法的原理：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC8%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/745b80c0db126d2edafc1f7daf1f955a.png" class="">


<p>现在，使用toString方法的时候，打印出来的东西 “不好看”，对于其他人来说不友好，可读性不好</p>
<p>我们现在是想知道对象的信息，名字，年龄，身高。。。。。。</p>
<p>现在的格式不好：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC8%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/d377d6556ae80f216e00404592999e77.png" class="">


<p>出现的问题：子类Student对父类Object提供的toString方法不满意，不满意–》对toString方法进行重写：</p>
<pre><code class="java">public class Student /\*extends Object\*/&#123;
    private String name;
    private int age;
    private double height;

    public String getName() &#123;
        return name;
    &#125;

    public void setName(String name) &#123;
        this.name = name;
    &#125;

    public int getAge() &#123;
        return age;
    &#125;

    public void setAge(int age) &#123;
        this.age = age;
    &#125;

    public double getHeight() &#123;
        return height;
    &#125;

    public void setHeight(double height) &#123;
        this.height = height;
    &#125;

    public Student() &#123;
    &#125;

    public Student(String name, int age, double height) &#123;
        this.name = name;
        this.age = age;
        this.height = height;
    &#125;

    public String toString() &#123;
        return &quot;这是一个Student对象，这个对象的名字：&quot;+name+&quot;,年龄：&quot;+age+&quot;,身高：&quot;+height;
    &#125;
&#125;

</code></pre>
<p>测试类：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC8%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/777945b54a0ad9f5d6284ac3acf271d0.png" class="">


<p>总结：toString的作用就是对对象进行“自我介绍”，一般子类对父类提供的toString都不满意，都要进行重写。</p>
<p>IDEA提供了快捷键：</p>
<pre><code class="java">public class Student /\*extends Object\*/&#123;
    private String name;
    private int age;
    private double height;

    public String getName() &#123;
        return name;
    &#125;

    public void setName(String name) &#123;
        this.name = name;
    &#125;

    public int getAge() &#123;
        return age;
    &#125;

    public void setAge(int age) &#123;
        this.age = age;
    &#125;

    public double getHeight() &#123;
        return height;
    &#125;

    public void setHeight(double height) &#123;
        this.height = height;
    &#125;

    public Student() &#123;
    &#125;

    public Student(String name, int age, double height) &#123;
        this.name = name;
        this.age = age;
        this.height = height;
    &#125;

    /\*public String toString() &#123;
        return &quot;这是一个Student对象，这个对象的名字：&quot;+name+&quot;,年龄：&quot;+age+&quot;,身高：&quot;+height;
    &#125;\*/

        @Override
        public String toString() &#123;
        return &quot;Student&#123;&quot; +
            &quot;name=&#39;&quot; + name + &#39;\\&#39;&#39; +
            &quot;, age=&quot; + age +
            &quot;, height=&quot; + height +
            &#39;&#125;&#39;;
    &#125;
&#125;

</code></pre>
<p>equals方法</p>
<pre><code class="java">public class Phone &#123;//手机类：
    //属性：
    private String brand;//品牌型号
    private double price;//价格
    private int year ;//出产年份
    //方法：

    public String getBrand() &#123;
        return brand;
    &#125;

    public void setBrand(String brand) &#123;
        this.brand = brand;
    &#125;

    public double getPrice() &#123;
        return price;
    &#125;

    public void setPrice(double price) &#123;
        this.price = price;
    &#125;

    public int getYear() &#123;
        return year;
    &#125;

    public void setYear(int year) &#123;
        this.year = year;
    &#125;

    @Override
    public String toString() &#123;
        return &quot;Phone&#123;&quot; +
            &quot;brand=&#39;&quot; + brand + &#39;\\&#39;&#39; +
            &quot;, price=&quot; + price +
            &quot;, year=&quot; + year +
            &#39;&#125;&#39;;
    &#125;

    //构造器：

    public Phone() &#123;
    &#125;

    public Phone(String brand, double price, int year) &#123;
        this.brand = brand;
        this.price = price;
        this.year = year;
    &#125;


    //对equals方法进行重写：
    public boolean equals(Object obj) &#123;//Object obj = new Phone();
        //将obj转为Phone类型：
        Phone other = (Phone)obj;//向下转型，为了获取子类中特有的内容
        if(this.getBrand()==other.getBrand()&amp;&amp;this.getPrice()==other.getPrice()&amp;&amp;this.getYear()==other.getYear())&#123;
            return true;
        &#125;
        return false;
    &#125;
&#125;
</code></pre>
<pre><code class="java">public class Test &#123;
    //这是一个main方法，是程序的入口：
    public static void main(String[] args) &#123;

        //创建Phone类的对象：
        Phone p1 = new Phone(&quot;华为P40&quot;,2035.98,2020);
        Phone p2 = new Phone(&quot;华为P40&quot;,2035.98,2020);
        //比较两个对象：p1和p2对象：
        //==的作用：比较左右两侧的值是否想的，要么相等，返回true,要么不相等,返回false
        System.out.println(p1==p2);//--\&gt;\&gt;\&gt;对于引用数据类型来说，比较的是地址值。---\&gt;一定返回的是false

        //Object类提供了一个方法 equals方法 ：作用：比较对象具体内容是否相等。
        boolean flag = p1.equals(p2);//点进源码发现：底层依旧比较的是==，比较的还是地址值。
        System.out.println(flag);

    &#125;
&#125;
</code></pre>
<p>总结：</p>
<p>equals作用：这个方法提供了对对象的内容是否相等 的一个比较方式，对象的内容指的就是属性。</p>
<p>父类Object提供的equals就是在比较&#x3D;&#x3D;地址，没有实际的意义，我们一般不会直接使用父类提供的方法，</p>
<p>而是在子类中对这个方法进行重写。</p>
<p>instanceof</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC8%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/30e52b9618d9cbd40553fdef0f60675b.png" class="">


<p>利用集成开发工具生成equals方法</p>
<p><strong>【1】利用eclipse：</strong></p>
<img data-src="/2022/10/07/Java/%E7%AC%AC8%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/91bbe52ca5d21f371941360962dea206.png" class="">


<p><strong>【2】利用idea：</strong></p>
<img data-src="/2022/10/07/Java/%E7%AC%AC8%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/97956cd439b862107cbc346e52ba17c3.png" class="">


<h3 id="类和类的关系"><a href="#类和类的关系" class="headerlink" title="类和类的关系"></a>类和类的关系</h3><p>代码</p>
<p>总结：</p>
<p><strong>【1】面向对象的思维：</strong>找参与者，找女孩类，找男孩类</p>
<p><strong>【2】体会了什么叫方法的性擦，什么叫方法的实参：</strong></p>
<img data-src="/2022/10/07/Java/%E7%AC%AC8%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/a4ab41dc30f6f798d4f7e210c42f758e.png" class="">


<p>具体传入的内容 实参：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC8%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/2c75ac587a45937e5652a3096bfe6126.png" class="">


<p><strong>【3】类和类可以产生关系：</strong></p>
<p>（1）将一个类作为另一个类中的方法的形参</p>
<p>（2）将一个类作为另一个类的属性</p>
<pre><code class="java">public class Girl &#123;
    //属性：
    String name;
    double weight;
    Mom m /\*= new Mom()\*/;
    //方法：
    public void add(int a)&#123;//参数是基本数据类型
        System.out.println(a);
        System.out.println(a+100);
    &#125;
    //谈恋爱的方法：
    public void love(Boy b)&#123;//参数是引用数据类型Boy
        System.out.println(&quot;我男朋友的名字是：&quot;+b.name+&quot;，我男朋友的年龄是：&quot;+b.age);
        b.buy();
    &#125;

    //女孩跟妈妈聊天：
    public void wechat()&#123;
        m.say();
    &#125;

    //构造器：
    public Girl(String name, double weight) &#123;
        this.name = name;
        this.weight = weight;
    &#125;
&#125;
public class Boy &#123;
    //属性：
    int age;
    String name;
    //方法：
    public void buy()&#123;
        System.out.println(&quot;跟我谈恋爱，我给你买买买。。。&quot;);
    &#125;
    //构造器：
    public Boy(int age, String name) &#123;
        this.age = age;
        this.name = name;
    &#125;
&#125;
public class Mom &#123;
    //方法：
    public void say()&#123;
        System.out.println(&quot;妈妈唠唠叨叨 都是爱，听妈妈的话。。&quot;);
    &#125;
&#125;

public class Test &#123;
    //这是一个main方法，是程序的入口：
    public static void main(String[] args) &#123;
        //创建一个Boy类的具体的对象：
        Boy boy = new Boy(30,&quot;鹿晗&quot;);
        //创建一个Girl类的具体的对象：
        Girl girl = new Girl(&quot;关晓彤&quot;,100);
        //谈恋爱：
        //girl.love(boy);
        Boy boy2 = new Boy(35,&quot;陈伟霆&quot;);
        girl.love(boy2);

        //还可以跟妈妈微信聊天：
        girl.m = new Mom();
        girl.wechat();
    &#125;
&#125;
</code></pre>
<p>总结</p>
<p>一、继承关系</p>
<p>继承指的是一个类（称为子类、子接口）继承另外的一个类（称为父类、父接口）的功能，并可以增加它自己的新功能的能力。在Java中继承关系通过关键字extends明确标识，在设计时一般没有争议性。在UML类图设计中，继承用一条带空心三角箭头的实线表示，从子类指向父类，或者子接口指向父接口。</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC8%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/6df8fcf572c5c9257622c561c3f9b8ce.png" class="">


<p>二、实现关系</p>
<p>实现指的是一个class类实现interface接口（可以是多个）的功能，实现是类与接口之间最常见的关系。在Java中此类关系通过关键字implements明确标识，在设计时一般没有争议性。在UML类图设计中，实现用一条带空心三角箭头的虚线表示，从类指向实现的接口。</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC8%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/7980497e067f9fb24a419ae71874f7c9.png" class="">


<p>三、依赖关系</p>
<p>简单的理解，依赖就是一个类A使用到了另一个类B，而这种使用关系是具有偶然性的、临时性的、非常弱的，但是类B的变化会影响到类A。比如某人要过河，需要借用一条船，此时人与船之间的关系就是依赖。表现在代码层面，让类B作为参数被类A在某个method方法中使用。在UML类图设计中，依赖关系用由类A指向类B的带箭头虚线表示。</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC8%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/d43f314a327103dae3f6211ba1668d9f.png" class="">


<p>四、关联关系</p>
<p>关联体现的是两个类之间语义级别的一种强依赖关系，比如我和我的朋友，这种关系比依赖更强、不存在依赖关系的偶然性、关系也不是临时性的，一般是长期性的，而且双方的关系一般是平等的。关联可以是单向、双向的。表现在代码层面，为被关联类B以类的属性形式出现在关联类A中，也可能是关联类A引用了一个类型为被关联类B的全局变量。在UML类图设计中，关联关系用由关联类A指向被关联类B的带箭头实线表示，在关联的两端可以标注关联双方的角色和多重性标记。</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC8%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/18a919f662aae552a4f799f592a76428.png" class="">


<p>五、聚合关系</p>
<p>聚合是关联关系的一种特例，它体现的是整体与部分的关系，即has-a的关系。此时整体与部分之间是可分离的，它们可以具有各自的生命周期，部分可以属于多个整体对象，也可以为多个整体对象共享。比如计算机与CPU、公司与员工的关系等，比如一个航母编队包括海空母舰、驱护舰艇、舰载飞机及核动力攻击潜艇等。表现在代码层面，和关联关系是一致的，只能从语义级别来区分。在UML类图设计中，聚合关系以空心菱形加实线箭头表示。</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC8%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/f588bbc3aa0176674ac7a0ad91269ee5.png" class="">


<p>六、组合关系</p>
<p>组合也是关联关系的一种特例，它体现的是一种contains-a的关系，这种关系比聚合更强，也称为强聚合。它同样体现整体与部分间的关系，但此时整体与部分是不可分的，整体的生命周期结束也就意味着部分的生命周期结束，比如人和人的大脑。表现在代码层面，和关联关系是一致的，只能从语义级别来区分。在UML类图设计中，组合关系以实心菱形加实线箭头表示。</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC8%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/1b8ae6d948c959d7a1a598bcf58ae9ba.png" class="">


<p>七、总结</p>
<p>对于继承、实现这两种关系没多少疑问，它们体现的是一种类和类、或者类与接口间的纵向关系。其他的四种关系体现的是类和类、或者类与接口间的引用、横向关系，是比较难区分的，有很多事物间的关系要想准确定位是很难的。前面也提到，这四种关系都是语义级别的，所以从代码层面并不能完全区分各种关系，但总的来说，后几种关系所表现的强弱程度依次为：组合&gt;聚合&gt;关联&gt;依赖。</p>
<h2 id="多态-Polymorphism"><a href="#多态-Polymorphism" class="headerlink" title="多态(Polymorphism)"></a>多态(Polymorphism)</h2><p><strong>【1】多态跟属性无关，多态指的是方法的多态，而不是属性的多态。</strong></p>
<p>【<strong>2】案例代入：</strong></p>
<pre><code class="java">public class Animal &#123;//父类：动物：
    public void shout()&#123;
        System.out.println(&quot;我是小动物，我可以叫。。。&quot;);
    &#125;
&#125;
public class Cat extends Animal&#123;
    //喊叫方法：
    public void shout()&#123;
        System.out.println(&quot;我是小猫，可以喵喵叫&quot;);
    &#125;
    public void scratch()&#123;
        System.out.println(&quot;我是小猫，我可以挠人&quot;);
    &#125;
&#125;
public class Dog extends Animal&#123;
    //喊叫：
    public void shout()&#123;
        System.out.println(&quot;我是小狗，我可以汪汪叫&quot;);
    &#125;
    public void guard()&#123;
        System.out.println(&quot;我是小狗，我可以看家护院，保护我的小主人。。。&quot;);
    &#125;
&#125;
public class Pig extends Animal&#123;
    public void shout()&#123;
        System.out.println(&quot;我是小猪，我嗯嗯嗯的叫&quot;);
    &#125;
    public void eat()&#123;
        System.out.println(&quot;我是小猪，我爱吃东西。。&quot;);
    &#125;

&#125;
public class Girl &#123;
    //跟猫玩耍：
    /\*public void play(Cat cat)&#123;
        cat.shout();
    &#125;\*/
        //跟狗玩耍：
        /\*public void play(Dog dog)&#123;
        dog.shout();
    &#125;\*/
        //跟小动物玩耍：
        public void play(Animal an)&#123;
        an.shout();
    &#125;
&#125;
public class Test &#123;
    //这是一个main方法，是程序的入口：
    public static void main(String[] args) &#123;
        //具体的猫：--》猫的对象
        //Cat c = new Cat();
        //具体的小女孩：--》女孩的对象
        Girl g = new Girl();
        //小女孩跟猫玩：
        //g.play(c);
        //具体的狗---》狗的对象：
        //Dog d = new Dog();
        //小女孩跟狗玩：
        //g.play(d);
        //具体的动物：--》动物的对象：
        //Cat c = new Cat();
        //Dog d = new Dog();
        Pig p = new Pig();
        Animal an = p;
        g.play(an);
    &#125;
&#125;
</code></pre>
<p><strong>【3】总结：</strong></p>
<p>（1）先有父类，再有子类：–》继承 先有子类，再抽取父类 —-》泛化</p>
<p>（2）什么是多态：</p>
<p>多态就是多种状态：同一个行为，不同的子类表现出来不同的形态。</p>
<p>多态指的就是同一个方法调用，然后由于对象不同会产生不同的行为。</p>
<p>（3）多态的好处：</p>
<p>为了提高代码的扩展性，符合面向对象的设计原则：开闭原则。</p>
<p>开闭原则：指的就是扩展是 开放的，修改是关闭的。</p>
<p>注意：多态可以提高扩展性，但是扩展性没有达到最好，以后我们会学习 反射</p>
<p>（4）多态的要素：</p>
<p>一，继承： Cat extends Animal ,Pig extends Animal, Dog extends Animal</p>
<p>二，重写：子类对父类的方法shout()重写</p>
<p>三， 父类引用指向子类对象：</p>
<ol>
<li>Pig p &#x3D; new Pig();</li>
<li>Animal an &#x3D; p;</li>
</ol>
<p>将上面的代码合为一句话：</p>
<p>Animal an &#x3D; new Pig();</p>
<p>&#x3D;左侧：编译期的类型</p>
<p>&#x3D;右侧：运行期的类型</p>
<p>Animal an &#x3D; new Pig();</p>
<p>g.play(an); &#x2F;&#x2F;</p>
<ol>
<li>public void play(Animal an){&#x2F;&#x2F;Animal an &#x3D; an &#x3D; new Pig();</li>
<li>an.shout();</li>
<li>}</li>
</ol>
<p>上面的代码，也是多态的一种非常常见的应用场合：父类当方法的形参，然后传入的是具体的子类的对象，</p>
<p>然后调用同一个方法，根据传入的子类的不同展现出来的效果也不同，构成了多态。</p>
<h3 id="内存分析-2"><a href="#内存分析-2" class="headerlink" title="内存分析"></a>内存分析</h3><img data-src="/2022/10/07/Java/%E7%AC%AC8%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/f791313852aa2be7d3c356e48db838ff.png" class="">


<h3 id="向下转型，向上转型"><a href="#向下转型，向上转型" class="headerlink" title="向下转型，向上转型"></a>向下转型，向上转型</h3><img data-src="/2022/10/07/Java/%E7%AC%AC8%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/e1446c03705f221dabfc73404636e7f9.png" class="">


<img data-src="/2022/10/07/Java/%E7%AC%AC8%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/dde65c5b8a65a38de394553d0009de33.png" class="">


<p>现在我就想访问到eat()方法和weight属性：</p>
<pre><code class="java">public class Demo &#123;
    //这是一个main方法，是程序的入口：
    public static void main(String[] args) &#123;
        Pig p = new Pig();
        Animal an = p;//转型：向上转型
        an.shout();

        //加入转型的代码：
        //将Animal转为Pig类型：
        Pig pig = (Pig)an ;//转型：向下转型
        pig.eat();
        pig.age = 10;
        pig.weight = 60.8;
    &#125;
&#125;
</code></pre>
<p>对应内存：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC8%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/b2f3a4672a7467f639d8429662e933e8.png" class="">


<p>思考之前的equals方法：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC8%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/25ce73d23e12ac98e7b1f7aa81f9ff22.png" class="">


<h3 id="简单工厂设计模式"><a href="#简单工厂设计模式" class="headerlink" title="简单工厂设计模式"></a>简单工厂设计模式</h3><p>不仅可以使用父类做方法的形参，还可以使用父类做方法的返回值类型，真实返回的对象可以是该类的任意一个子类对象。</p>
<p>简单工厂模式的实现，它是解决大量对象创建问题的一个解决方案。将创建和使用分开，工厂负责创建，使用者直接调用即可。简单工厂模式的基本要求是</p>
<p>² 定义一个static方法，通过类名直接调用</p>
<p>² 返回值类型是父类类型，返回的可以是其任意子类类型</p>
<p>² 传入一个字符串类型的参数，工厂根据参数创建对应的子类产品</p>
<pre><code class="java">public class Test &#123;
    public static void main(String[] args) &#123;
        Girl g = new Girl();

        //Cat c = new Cat();
        //Dog d = new Dog();
        //Pig p = new Pig();
        Animal an = PetStore.getAnimal(&quot;狗&quot;);

        g.play(an);
    &#125;
&#125;
public class PetStore &#123;//宠物店 ---》工厂类
    //方法：提供动物
    public static Animal getAnimal(String petName)&#123;//多态的应用场合（二）
        Animal an = null;

        if(&quot;猫&quot;.equals(petName))&#123;//petName.equals(&quot;猫&quot;) --》这样写容易发生空指针异常
            an = new Cat();
        &#125;

        if(&quot;狗&quot;.equals(petName))&#123;
            an = new Dog();
        &#125;

        if(&quot;猪&quot;.equals(petName))&#123;
            an = new Pig();
        &#125;

        return an;
    &#125;
&#125;
</code></pre>
<h1 id="final"><a href="#final" class="headerlink" title="final"></a>final</h1><p><strong>【1】修饰变量；</strong></p>
<pre><code class="java">public class Test &#123;
    //这是一个main方法，是程序的入口：
    public static void main(String[] args) &#123;
        //第1种情况：
        //final修饰一个变量，变量的值不可以改变，这个变量也变成了一个字符常量，约定俗称的规定：名字大写
        final int A = 10;//final修饰基本数据类型
        //A = 20; 报错：不可以修改值
        //第2种情况：
        final Dog d = new Dog();//final修饰引用数据类型，那么地址值就不可以改变
        //d = new Dog(); --\&gt;地址值不可以更改
        //d对象的属性依然可以改变：
        d.age = 10;
        d.weight = 13.7;

        //第3种情况：
        final Dog d2 = new Dog();
        a(d2);
        //第4种情况：
        b(d2);

    &#125;
    public static void a(Dog d)&#123;
        d = new Dog();
    &#125;
    public static void b(final Dog d)&#123;//d被final修饰 ，指向不可以改变
        //d = new Dog();
    &#125;
&#125;
</code></pre>
<p><strong>【2】修饰方法；</strong></p>
<p>final修饰方法，那么这个方法不可以被该类的子类重写：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC8%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/e2ac79b24d344d5b0d6b8faa62f96090.png" class="">


<p><strong>【3】修饰类；</strong></p>
<p>final修饰类，代表没有子类，该类不可以被继承：</p>
<p>一旦一个类被final修饰，那么里面的方法也没有必要用final修饰了（final可以省略不写）</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC8%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/5598439b682631d58965e571cf796ae3.png" class="">


<p><strong>【4】案例：JDK提供的Math类：</strong>看源码发现：</p>
<p>（1）使用Math类的时候无需导包，直接使用即可：</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC8%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/3acfdc8f04f80a895820a2d9947c1a59.png" class="">


<p>（2）Math类没有子类，不能被其他类继承了</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC8%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/0febe174ebc78d4977b9ac8a6259fef8.png" class="">


<p>（3）里面的属性全部被final修饰，方法也是被final修饰的，只是省略不写了</p>
<p>原因：子类没有必要进行重写。</p>
<p>（4）外界不可以创建对象：</p>
<p>Math m &#x3D; new Math();</p>
<img data-src="/2022/10/07/Java/%E7%AC%AC8%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/97205d348a09e70cdda26b24ec220407.png" class="">


<p>（5）发现Math类中的所有的属性，方法都被static修饰</p>
<p>那么不用创建对象去调用，只能通过类名.属性名 类名.方法名 去调用</p>
<h1 id="抽象类，抽象方法"><a href="#抽象类，抽象方法" class="headerlink" title="抽象类，抽象方法"></a>抽象类，抽象方法</h1><p>【1】抽象类和抽象方法的关系：</p>
<p>抽象类中可以定义0-n个抽象方法。</p>
<p>【2】抽象类作用：</p>
<p>在抽象类中定义抽象方法，目的是为了为子类提供一个通用的模板，子类可以在模板的基础上进行开发，先重写父类的抽象方法，然后可以扩展子类自己的内容。抽象类设计避免了子类设计的随意性，通过抽象类，子类的设计变得更加严格，进行某些程度上的限制。</p>
<p>使子类更加的通用。</p>
<p>【3】代码：</p>
<pre><code class="java">//4.一个类中如果有方法是抽象方法，那么这个类也要变成一个抽象类。
//5.一个抽象类中可以有0-n个抽象方法
public abstract class Person &#123;
    //1.在一个类中，会有一类方法，子类对这个方法非常满意，无需重写，直接使用
    public void eat()&#123;
        System.out.println(&quot;一顿不吃饿得慌&quot;);
    &#125;
    //2.在一个类中，会有一类方法，子类对这个方法永远不满意，会对这个方法进行重写。
    //3.一个方法的方法体去掉，然后被abstract修饰，那么这个方法就变成了一个抽象方法
    public abstract void say();
    public abstract void sleep();
&#125;

//6.抽象类可以被其他类继承：
//7.一个类继承一个抽象类，那么这个类可以变成抽象类
//8.一般子类不会加abstract修饰，一般会让子类重写父类中的抽象方法
//9.子类继承抽象类，就必须重写全部的抽象方法
//10.子类如果没有重写父类全部的抽象方法，那么子类也可以变成一个抽象类。
class Student extends Person&#123;

    @Override
    public void say() &#123;
        System.out.println(&quot;我是东北人，我喜欢说东北话。。&quot;);
    &#125;

    @Override
    public void sleep() &#123;
        System.out.println(&quot;东北人喜欢睡炕。。&quot;);
    &#125;
&#125;
</code></pre>
<pre><code class="java">class Demo&#123;
    //这是一个main方法，是程序的入口：
    public static void main(String[] args) &#123;
        //11.创建抽象类的对象：--\&gt;抽象类不可以创建对象
        //Person p = new Person();
        
        //12.创建子类对象：
        Student s = new Student();
        s.sleep();
        s.say();
        
        //13.多态的写法：父类引用只想子类对象：
        Person p = new Student();
        p.say();
        p.sleep();
    &#125;
&#125;
</code></pre>
<p>【4】面试题：</p>
<p>（1）抽象类不能创建对象，那么抽象类中是否有构造器？</p>
<p>抽象类中一定有构造器。构造器的作用 给子类初始化对象的时候要先super调用父类的构造器。</p>
<p>（2）抽象类是否可以被final修饰？</p>
<p>不能被final修饰，因为抽象类设计的初衷就是给子类继承用的。要是被final修饰了这个抽象类了，就不存在继承了，就没有子类。</p>
<h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><p><strong>【1】接口声明格式：</strong></p>
<table>
<thead>
<tr>
<th>[访问修饰符] interface 接口名 [extends 父接口1，父接口2…] {   常量定义；   方法定义；  }</th>
</tr>
</thead>
</table>
<p><strong>【2】代码：</strong></p>
<pre><code class="java">package com.msb.test04;

/**
    * 1.类是类，接口是接口，它们是同一层次的概念。
    * 2.接口中没有构造器
    * 3.接口如何声明：interface
    * 4.在JDK1.8之前，接口中只有两部分内容：
    * （1）常量：固定修饰符：public static final
    * （2）抽象方法：固定修饰符：public abstract
    * 注意：修饰符可以省略不写，IDE会帮你自动补全，但是初学者建议写上，防止遗忘。
*/
public interface TestInterface01 &#123;
    //常量：
    /\*public static final\*/ int NUM = 10;
    //抽象方法：
    /\*public abstract\*/ void a();
    /\*public abstract\*/ void b(int num);
    /\*public abstract\*/ int c(String name);
&#125;

interface TestInterface02&#123;
    void e();
    void f();
&#125;
/\*
    5.类和接口的关系是什么？ 实现关系 类实现接口：
    6.一旦实现一个接口，那么实现类要重写接口中的全部的抽象方法：
    7.如果没有全部重写抽象方法，那么这个类可以变成一个抽象类。
    8.java只有单继承，java还有多实现
    一个类继承其他类，只能直接继承一个父类
    但是实现类实现接口的话，可以实现多个接口
    9.写法：先继承 再实现：extends Person implements TestInterface01,TestInterface02
    \*/
    class Student extends Person implements TestInterface01,TestInterface02 &#123;
        @Override
        public void a() &#123;
            System.out.println(&quot;---1&quot;);
        &#125;

        @Override
        public void b(int num) &#123;
            System.out.println(&quot;---2&quot;);
        &#125;

        @Override
        public int c(String name) &#123;
            return 100;
        &#125;

        @Override
        public void e() &#123;
            System.out.println(&quot;---3&quot;);
        &#125;

        @Override
        public void f() &#123;
            System.out.println(&quot;---4&quot;);
        &#125;
    &#125;


class Test&#123;
    //这是一个main方法，是程序的入口：
    public static void main(String[] args) &#123;
        //10.接口不能创建对象：
        //TestInterface02 t = new TestInterface02();
        TestInterface02 t = new Student();//接口指向实现类 ---》多态

        //11.接口中常量如何访问：
        System.out.println(TestInterface01.NUM);
        System.out.println(Student.NUM);
        Student s = new Student();
        System.out.println(s.NUM);
        TestInterface01 t2 = new Student();
        System.out.println(t2.NUM);
    &#125;
&#125;
</code></pre>
<p><strong>【3】接口的作用是什么？</strong></p>
<p>定义规则，只是跟抽象类不同地方在哪？它是接口不是类。</p>
<p>接口定义好规则之后，实现类负责实现即可。</p>
<p><strong>【4】</strong></p>
<p>继承：子类对父类的继承</p>
<p>实现：实现类对接口的实现</p>
<p>手机 是不是 照相机</p>
<p>继承：手机 extends 照相机 “is-a”的关系，手机是一个照相机</p>
<p>上面的写法 不好：</p>
<p>实现： 手机 implements 拍照功能 “has-a”的关系，手机具备照相的能力</p>
<p>案例：飞机，小鸟，风筝</p>
<p>定义一个接口： Flyable</p>
<p><strong>【5】多态的应用场合：</strong></p>
<p>（1）父类当做方法的形参，传入具体的子类的对象</p>
<p>（2）父类当做方法的返回值，返回的是具体的子类的对象</p>
<p>（3）接口当做方法的形参，传入具体的实现类的对象</p>
<p>（4）接口当做方法的返回值，返回的是具体的实现类的对象</p>
<p><strong>【6】接口和抽象类的区别：</strong></p>
<img data-src="/2022/10/07/Java/%E7%AC%AC8%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/ff922aa23cf8364987c661f524bf9d58.png" class="">


<h2 id="JDK1-8以后的接口新增内容"><a href="#JDK1-8以后的接口新增内容" class="headerlink" title=" JDK1.8以后的接口新增内容"></a> JDK1.8以后的接口新增内容</h2><p><strong>在JDK1.8之前，接口中只有两部分内容：</strong><br>（1）常量：固定修饰符：public static final<br>（2）抽象方法：固定修饰符：public abstract</p>
<p><strong>在JDK1.8之后，新增非抽象方法：</strong></p>
<p>（1）被public default修饰的非抽象方法：</p>
<p>注意1：default修饰符必须要加上，否则出错</p>
<p>注意2：实现类中要是想重写接口中的非抽象方法，那么default修饰符必须不能加，否则出错。</p>
<pre><code class="java">public interface TestInterface &#123;
    //常量：
    public static final int NUM= 10;
    //抽象方法：
    public abstract void a();
    //public default修饰的非抽象方法：
    public default void b()&#123;
        System.out.println(&quot;-------TestInterface---b()-----&quot;);
    &#125;
&#125;
class Test implements TestInterface&#123;
    public void c()&#123;
        //用一下接口中的b方法：
        b();//可以
        //super.b();不可以
        TestInterface.super.b();//可以
    &#125;
    @Override
    public void a() &#123;
        System.out.println(&quot;重写了a方法&quot;);
    &#125;

    @Override
    public void b() &#123;

    &#125;
&#125;
</code></pre>
<p>（2）静态方法：</p>
<p>注意1：static不可以省略不写</p>
<p>注意2：静态方法不能重写</p>
<pre><code class="java">public interface TestInterface2 &#123;
    //常量：
    public static final int NUM = 10;
    //抽象方法：
    public abstract void a();
    //public default非抽象方法；
    public default void b()&#123;
        System.out.println(&quot;-----TestInterface2---b&quot;);
    &#125;
    //静态方法：
    public static void c()&#123;
        System.out.println(&quot;TestInterface2中的静态方法&quot;);
    &#125;
&#125;

class Demo implements TestInterface2&#123;
    @Override
    public void a() &#123;
        System.out.println(&quot;重写了a方法&quot;);
    &#125;
    public static void c()&#123;
        System.out.println(&quot;Demo中的静态方法&quot;);
    &#125;
&#125;

class A &#123;
    //这是一个main方法，是程序的入口：
    public static void main(String[] args) &#123;
        Demo d = new Demo();
        d.c();
        Demo.c();
        TestInterface2.c();
    &#125;
&#125;
</code></pre>
<p>疑问：为什么要在接口中加入非抽象方法？？？</p>
<p>如果接口中只能定义抽象方法的话，那么我要是修改接口中的内容，那么对实现类的影响太大了，所有实现类都会受到影响。</p>
<p>现在在接口中加入非抽象方法，对实现类没有影响，想调用就去调用即可。</p>
<h1 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h1><h2 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h2><pre><code class="java">/**
* 1.类的组成：属性，方法，构造器，代码块（普通块，静态块，构造块，同步块），内部类
* 2.一个类TestOuter的内部的类SubTest叫内部类， 内部类 ：SubTest 外部类：TestOuter
* 3.内部类：成员内部类 (静态的，非静态的) 和 局部内部类（位置：方法内，块内，构造器内）
* 4.成员内部类:
* 里面属性，方法，构造器等
* 修饰符：private，default，protect，public，final,abstract
*/
public class TestOuter &#123;
    //非静态的成员内部类：
    public class D&#123;
        int age = 20;
        String name;
        public void method()&#123;
            //5.内部类可以访问外部类的内容
            /\*System.out.println(age);
            a();\*/
                int age = 30;

            //8.内部类和外部类属性重名的时候，如何进行调用：
            System.out.println(age);//30
            System.out.println(this.age);//20
            System.out.println(TestOuter.this.age);//10
        &#125;
    &#125;

    //静态成员内部类：
    static class E&#123;
        public void method()&#123;
            //6.静态内部类中只能访问外部类中被static修饰的内容
            /\*System.out.println(age);
            a();\*/
        &#125;
    &#125;
    //属性：
    int age = 10;
    //方法：
    public void a()&#123;
        System.out.println(&quot;这是a方法&quot;);
        &#123;
            System.out.println(&quot;这是一个普通块&quot;);
            class B&#123;

            &#125;
        &#125;
        class A&#123;

        &#125;
        //7.外部类想要访问内部类的东西，需要创建内部类的对象然后进行调用
        D d = new D();
        System.out.println(d.name);
        d.method();

    &#125;
    static&#123;
        System.out.println(&quot;这是静态块&quot;);
    &#125;
    &#123;
        System.out.println(&quot;这是构造块&quot;);
    &#125;
    //构造器：
    public TestOuter()&#123;
        class C&#123;

        &#125;
    &#125;

    public TestOuter(int age) &#123;
        this.age = age;
    &#125;
&#125;

class Demo&#123;
    //这是一个main方法，是程序的入口：
    public static void main(String[] args) &#123;
        //创建外部类的对象：
        TestOuter to = new TestOuter();
        to.a();

        //9.创建内部类的对象：
        //静态的成员内部类创建对象：
        TestOuter.E e = new TestOuter.E();
        //非静态的成员内部类创建对象：
        //错误：TestOuter.D d = new TestOuter.D();
        TestOuter t = new TestOuter();
        TestOuter.D d = t.new D();

    &#125;
&#125;

</code></pre>
<h2 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h2><ol>
<li></li>
</ol>
<pre><code class="java">public class TestOuter &#123;
    //1.在局部内部类中访问到的变量必须是被final修饰的
    public void method()&#123;
        final int num = 10;
        class A&#123;
            public void a()&#123;
                //num = 20;
                System.out.println(num);
            &#125;
        &#125;
    &#125;
    //2.如果类B在整个项目中只使用一次，那么就没有必要单独创建一个B类，使用内部类就可以了
    public Comparable method2()&#123;
        class B implements Comparable&#123;
            @Override
            public int compareTo(Object o) &#123;
                return 100;
            &#125;
        &#125;
        return new B();
    &#125;

    public Comparable method3()&#123;
        //3.匿名内部类
        return new Comparable()&#123;

            @Override
            public int compareTo(Object o) &#123;
                return 200;
            &#125;
        &#125;;
    &#125;

    public void teat()&#123;
        Comparable com = new Comparable()&#123;

            @Override
            public int compareTo(Object o) &#123;
                return 200;
            &#125;
        &#125;;

        System.out.println(com.compareTo(&quot;abc&quot;));
    &#125;
&#125;

</code></pre>
<h1 id="面向对象项目"><a href="#面向对象项目" class="headerlink" title="面向对象项目"></a>面向对象项目</h1><h2 id="项目需求"><a href="#项目需求" class="headerlink" title="项目需求"></a>项目需求</h2><img data-src="/2022/10/07/Java/%E7%AC%AC8%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/55242c8d1c966467d3474bfd5be55072.png" class="">


<h2 id="项目结构分析"><a href="#项目结构分析" class="headerlink" title="项目结构分析"></a>项目结构分析</h2><img data-src="/2022/10/07/Java/%E7%AC%AC8%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/71e9407d4bd6fa1ac73e649f555944d3.png" class="">


<h2 id="最终代码"><a href="#最终代码" class="headerlink" title="最终代码"></a>最终代码</h2><p>匹萨父类：</p>
<pre><code class="java">public class Pizza &#123;
    //属性
    private String name;//名称
    private int size;//大小
    private int price;//价格

    //方法

    public String getName() &#123;
        return name;
    &#125;

    public void setName(String name) &#123;
        this.name = name;
    &#125;

    public int getSize() &#123;
        return size;
    &#125;

    public void setSize(int size) &#123;
        this.size = size;
    &#125;

    public int getPrice() &#123;
        return price;
    &#125;

    public void setPrice(int price) &#123;
        this.price = price;
    &#125;

    //展示匹萨信息：
    public String showPizza()&#123;
        return &quot;匹萨的名字是：&quot;+name+&quot;\\n匹萨的大小是：&quot;+size+&quot;寸\\n匹萨的价格：&quot;+price+&quot;元&quot;;
    &#125;


    //构造器

    public Pizza() &#123;
    &#125;

    public Pizza(String name, int size, int price) &#123;
        this.name = name;
        this.size = size;
        this.price = price;
    &#125;
&#125;

</code></pre>
<p>培根匹萨：</p>
<pre><code class="java">public class BaconPizza extends Pizza &#123;
    //属性：
    private int weight;

    public int getWeight() &#123;
        return weight;
    &#125;

    public void setWeight(int weight) &#123;
        this.weight = weight;
    &#125;

    //构造器：

    public BaconPizza() &#123;
    &#125;

    public BaconPizza(String name, int size, int price, int weight) &#123;
        super(name, size, price);
        this.weight = weight;
    &#125;

    //重写父类showPizza方法：

    @Override
    public String showPizza() &#123;
        return super.showPizza()+&quot;\\n培根的克数是：&quot;+weight+&quot;克&quot;;
    &#125;
&#125;

</code></pre>
<p>水果匹萨：</p>
<pre><code class="java">public class FruitsPizza extends Pizza&#123;
    //属性：
    private String burdening;

    public String getBurdening() &#123;
        return burdening;
    &#125;

    public void setBurdening(String burdening) &#123;
        this.burdening = burdening;
    &#125;

    //构造器：

    public FruitsPizza() &#123;
    &#125;

    public FruitsPizza(String name, int size, int price, String burdening) &#123;
        super(name, size, price);
        this.burdening = burdening;
    &#125;

    //重写父类showPizza方法：

    @Override
    public String showPizza() &#123;
        return super.showPizza()+&quot;\\n你要加入的水果：&quot;+burdening;
    &#125;
&#125;

</code></pre>
<p>测试类：</p>
<pre><code class="java">public class Test &#123;
    //这是一个main方法，是程序的入口：
    public static void main(String[] args) &#123;
        //选择购买匹萨：
        Scanner sc = new Scanner(System.in);
        System.out.println(&quot;请选择你想要购买的匹萨（1.培根匹萨 2.水果匹萨）:&quot;);
        int choice = sc.nextInt();//选择
        //通过工厂获取匹萨：
        Pizza pizza = PizzaStore.getPizza(choice);
        System.out.println(pizza.showPizza());

    &#125;
&#125;

</code></pre>
<p>工厂类：</p>
<pre><code class="java">import java.util.Scanner;


public class PizzaStore &#123;
    public static Pizza getPizza(int choice)&#123;
        Scanner sc = new Scanner(System.in);
        Pizza p = null;
        switch (choice)&#123;
            case 1:
                &#123;
                    System.out.println(&quot;请录入培根的克数：&quot;);
                    int weight = sc.nextInt();
                    System.out.println(&quot;请录入匹萨的大小：&quot;);
                    int size = sc.nextInt();
                    System.out.println(&quot;请录入匹萨的价格：&quot;);
                    int price = sc.nextInt();
                    //将录入的信息封装为培根匹萨的对象：
                    BaconPizza bp = new BaconPizza(&quot;培根匹萨&quot;,size,price,weight);
                    p = bp;
                &#125;
                break;
            case 2:
                &#123;
                    System.out.println(&quot;请录入你想要加入的水果：&quot;);
                    String burdening = sc.next();
                    System.out.println(&quot;请录入匹萨的大小：&quot;);
                    int size = sc.nextInt();
                    System.out.println(&quot;请录入匹萨的价格：&quot;);
                    int price = sc.nextInt();
                    //将录入的信息封装为水果匹萨的对象：
                    FruitsPizza fp = new FruitsPizza(&quot;水果匹萨&quot;,size,price,burdening);
                    p = fp;
                &#125;
                break;
        &#125;
        return p;
    &#125;
&#125;

</code></pre>
]]></content>
      <categories>
        <category>JavaSE</category>
        <category>面向对象</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title>MybatisPlus</title>
    <url>/2022/10/07/ORM/MybatisPlus/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2Jhb21pZG91L215YmF0aXMtcGx1cw==">MyBatis-Plus (opens new window)</span>（简称 MP）是一个 <span class="exturl" data-url="aHR0cHM6Ly93d3cubXliYXRpcy5vcmcvbXliYXRpcy0zLw==">MyBatis (opens new window)</span>的增强工具，在 MyBatis 的基础上只做增强不做改变，为简化开发、提高效率而生。</p>
<blockquote>
<p>愿景</p>
<p>我们的愿景是成为 MyBatis 最好的搭档，就像 <span class="exturl" data-url="aHR0cHM6Ly9iYW9taWRvdS5jb20vaW1nL2NvbnRyYS5qcGc=">魂斗罗</span> 中的 1P、2P，基友搭配，效率翻倍。</p>
</blockquote>
<h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ul>
<li><strong>无侵入</strong>：只做增强不做改变，引入它不会对现有工程产生影响，如丝般顺滑</li>
<li><strong>损耗小</strong>：启动即会自动注入基本 CURD，性能基本无损耗，直接面向对象操作</li>
<li><strong>强大的 CRUD 操作</strong>：内置通用 Mapper、通用 Service，仅仅通过少量配置即可实现单表大部分 CRUD 操作，更有强大的条件构造器，满足各类使用需求</li>
<li><strong>支持 Lambda 形式调用</strong>：通过 Lambda 表达式，方便的编写各类查询条件，无需再担心字段写错</li>
<li><strong>支持主键自动生成</strong>：支持多达 4 种主键策略（内含分布式唯一 ID 生成器 - Sequence），可自由配置，完美解决主键问题</li>
<li><strong>支持 ActiveRecord 模式</strong>：支持 ActiveRecord 形式调用，实体类只需继承 Model 类即可进行强大的 CRUD 操作</li>
<li><strong>支持自定义全局通用操作</strong>：支持全局通用方法注入（ Write once, use anywhere ）</li>
<li><strong>内置代码生成器</strong>：采用代码或者 Maven 插件可快速生成 Mapper 、 Model 、 Service 、 Controller 层代码，支持模板引擎，更有超多自定义配置等您来使用</li>
<li><strong>内置分页插件</strong>：基于 MyBatis 物理分页，开发者无需关心具体操作，配置好插件之后，写分页等同于普通 List 查询</li>
<li><strong>分页插件支持多种数据库</strong>：支持 MySQL、MariaDB、Oracle、DB2、H2、HSQL、SQLite、Postgre、SQLServer 等多种数据库</li>
<li><strong>内置性能分析插件</strong>：可输出 SQL 语句以及其执行时间，建议开发测试时启用该功能，能快速揪出慢查询</li>
<li><strong>内置全局拦截插件</strong>：提供全表 delete 、 update 操作智能分析阻断，也可自定义拦截规则，预防误操作</li>
</ul>
<h2 id="支持数据库"><a href="#支持数据库" class="headerlink" title="支持数据库"></a><span class="exturl" data-url="aHR0cHM6Ly9iYW9taWRvdS5jb20vcGFnZXMvMjQxMTJmLyMlRTYlOTQlQUYlRTYlOEMlODElRTYlOTUlQjAlRTYlOEQlQUUlRTUlQkElOTM="></span>支持数据库</h2><blockquote>
<p>任何能使用 <code>MyBatis</code> 进行 CRUD, 并且支持标准 SQL 的数据库，具体支持情况如下，如果不在下列表查看分页部分教程 PR 您的支持。</p>
</blockquote>
<ul>
<li>MySQL，Oracle，DB2，H2，HSQL，SQLite，PostgreSQL，SQLServer，Phoenix，Gauss ，ClickHouse，Sybase，OceanBase，Firebird，Cubrid，Goldilocks，csiidb</li>
<li>达梦数据库，虚谷数据库，人大金仓数据库，南大通用(华库)数据库，南大通用数据库，神通数据库，瀚高数据库</li>
</ul>
<h2 id="框架结构"><a href="#框架结构" class="headerlink" title="框架结构"></a><span class="exturl" data-url="aHR0cHM6Ly9iYW9taWRvdS5jb20vcGFnZXMvMjQxMTJmLyMlRTYlQTElODYlRTYlOUUlQjYlRTclQkIlOTMlRTYlOUUlODQ="></span>框架结构</h2><img data-src="/2022/10/07/ORM/MybatisPlus/mybatis-plus-framework.jpg" class="" title="framework">



<h1 id="快速使用"><a href="#快速使用" class="headerlink" title="快速使用"></a>快速使用</h1><blockquote>
<p>使用的mybatis 3.5之前版本，也就是官方的旧版本</p>
</blockquote>
<h2 id="初始化工程"><a href="#初始化工程" class="headerlink" title="初始化工程"></a>初始化工程</h2><p>创建一个空的 Spring Boot 工程（工程将以 H2 作为默认数据库进行演示）</p>
<p>提示</p>
<p>可以使用 <span class="exturl" data-url="aHR0cHM6Ly9zdGFydC5zcHJpbmcuaW8v">Spring Initializer (opens new window)</span>快速初始化一个 Spring Boot 工程</p>
<h2 id="pom-添加依赖"><a href="#pom-添加依赖" class="headerlink" title="pom 添加依赖"></a><code>pom</code> 添加依赖</h2><pre><code class="xml">    &lt;properties&gt;
        &lt;java.version&gt;1.8&lt;/java.version&gt;
        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
        &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;
        &lt;spring-boot.version&gt;2.3.7.RELEASE&lt;/spring-boot.version&gt;
    &lt;/properties&gt;

    &lt;dependencies&gt;
        &lt;!--freemarker--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.freemarker&lt;/groupId&gt;
            &lt;artifactId&gt;freemarker&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;!--velocity--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.apache.velocity&lt;/groupId&gt;
            &lt;artifactId&gt;velocity-engine-core&lt;/artifactId&gt;
            &lt;version&gt;2.2&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!--generator--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.baomidou&lt;/groupId&gt;
            &lt;artifactId&gt;mybatis-plus-generator&lt;/artifactId&gt;
            &lt;version&gt;3.4.1&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!--mybatis-plus--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.baomidou&lt;/groupId&gt;
            &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;
            &lt;version&gt;3.4.1&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!--jdbc--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;mysql&lt;/groupId&gt;
            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
            &lt;scope&gt;runtime&lt;/scope&gt;
        &lt;/dependency&gt;
        &lt;!--lombok--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
            &lt;artifactId&gt;lombok&lt;/artifactId&gt;
            &lt;optional&gt;true&lt;/optional&gt;
        &lt;/dependency&gt;
        &lt;!--spring-start-web--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;!--spring-test--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
            &lt;scope&gt;test&lt;/scope&gt;
            &lt;exclusions&gt;
                &lt;exclusion&gt;
                    &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt;
                    &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt;
                &lt;/exclusion&gt;
            &lt;/exclusions&gt;
        &lt;/dependency&gt;
        &lt;!--junit4--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;junit&lt;/groupId&gt;
            &lt;artifactId&gt;junit&lt;/artifactId&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

    &lt;dependencyManagement&gt;
        &lt;dependencies&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
                &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt;
                &lt;version&gt;$&#123;spring-boot.version&#125;&lt;/version&gt;
                &lt;type&gt;pom&lt;/type&gt;
                &lt;scope&gt;import&lt;/scope&gt;
            &lt;/dependency&gt;
        &lt;/dependencies&gt;
    &lt;/dependencyManagement&gt;

    &lt;build&gt;
        &lt;plugins&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
                &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;
                &lt;version&gt;3.8.1&lt;/version&gt;
                &lt;configuration&gt;
                    &lt;source&gt;1.8&lt;/source&gt;
                    &lt;target&gt;1.8&lt;/target&gt;
                    &lt;encoding&gt;UTF-8&lt;/encoding&gt;
                &lt;/configuration&gt;
            &lt;/plugin&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
                &lt;version&gt;2.3.7.RELEASE&lt;/version&gt;
                &lt;configuration&gt;
                    &lt;mainClass&gt;com.example.TestMybatisplusApplication&lt;/mainClass&gt;
                &lt;/configuration&gt;
                &lt;executions&gt;
                    &lt;execution&gt;
                        &lt;id&gt;repackage&lt;/id&gt;
                        &lt;goals&gt;
                            &lt;goal&gt;repackage&lt;/goal&gt;
                        &lt;/goals&gt;
                    &lt;/execution&gt;
                &lt;/executions&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/build&gt;
</code></pre>
<h2 id="模板准备"><a href="#模板准备" class="headerlink" title="模板准备"></a>模板准备</h2><p>因为个人习惯原因，我修改了一下entity的模板。</p>
<blockquote>
<p>在<code>resource/templates </code>下创建一个<code>MyEntity.java.ftl</code>(就这个名字吧，不然还要改代码，再者这个没啥用，只用于我们的逆向工程) ，直接将下面的内容粘贴创建即可。</p>
<p>注意：</p>
<ul>
<li>我用的模板引擎是 <code>freemarker</code> 一定得加依赖</li>
<li>用 .vm 就要加 <code>velocity</code> 依赖</li>
</ul>
</blockquote>
<h3 id="ftl文件"><a href="#ftl文件" class="headerlink" title=".ftl文件"></a>.ftl文件</h3><pre><code class="ftl">package $&#123;package.Entity&#125;;

&lt;#list table.importPackages as pkg&gt;
import $&#123;pkg&#125;;
&lt;/#list&gt;
&lt;#if swagger2&gt;
&lt;/#if&gt;
&lt;#if entityLombokModel&gt;
import lombok.*;
&lt;/#if&gt;

/**
 * &lt;p&gt;
 * $&#123;table.comment!&#125;
 * &lt;/p&gt;
 *
 * @author $&#123;author&#125;
 * @since $&#123;date&#125;
 */
&lt;#if entityLombokModel&gt;
    &lt;#if superEntityClass??&gt;
@EqualsAndHashCode(callSuper = true)
    &lt;#else&gt;
@EqualsAndHashCode(callSuper = false)
    &lt;/#if&gt;
    &lt;#if chainModel&gt;
@Accessors(chain = true)
    &lt;/#if&gt;
&lt;/#if&gt;
&lt;#if table.convert&gt;
@TableName(&quot;$&#123;table.name&#125;&quot;)
&lt;/#if&gt;
@AllArgsConstructor
@NoArgsConstructor
@Data
@ToString
&lt;#if superEntityClass??&gt;
public class $&#123;entity&#125; extends $&#123;superEntityClass&#125;&lt;#if activeRecord&gt;&lt;$&#123;entity&#125;&gt;&lt;/#if&gt; &#123;
&lt;#elseif activeRecord&gt;
public class $&#123;entity&#125; extends Model&lt;$&#123;entity&#125;&gt; &#123;
&lt;#else&gt;
public class $&#123;entity&#125; implements Serializable &#123;
&lt;/#if&gt;

&lt;#if entitySerialVersionUID&gt;
    private static final long serialVersionUID = 1L;
&lt;/#if&gt;
&lt;#-- ----------  BEGIN 字段循环遍历  ----------&gt;
&lt;#list table.fields as field&gt;
    &lt;#if field.keyFlag&gt;
        &lt;#assign keyPropertyName=&quot;$&#123;field.propertyName&#125;&quot;/&gt;
    &lt;/#if&gt;

    &lt;#if field.comment!?length gt 0&gt;
        &lt;#if swagger2&gt;
    @ApiModelProperty(value = &quot;$&#123;field.comment&#125;&quot;)
        &lt;#else&gt;
    /**
     * $&#123;field.comment&#125;
     */
        &lt;/#if&gt;
    &lt;/#if&gt;
    &lt;#if field.keyFlag&gt;
        &lt;#-- 主键 --&gt;
        &lt;#if field.keyIdentityFlag&gt;
    @TableId(value = &quot;$&#123;field.annotationColumnName&#125;&quot;, type = IdType.AUTO)
        &lt;#elseif idType??&gt;
    @TableId(value = &quot;$&#123;field.annotationColumnName&#125;&quot;, type = IdType.$&#123;idType&#125;)
        &lt;#elseif field.convert&gt;
    @TableId(&quot;$&#123;field.annotationColumnName&#125;&quot;)
        &lt;/#if&gt;
        &lt;#-- 普通字段 --&gt;
    &lt;#elseif field.fill??&gt;
    &lt;#-- -----   存在字段填充设置   -----&gt;
        &lt;#if field.convert&gt;
    @TableField(value = &quot;$&#123;field.annotationColumnName&#125;&quot;, fill = FieldFill.$&#123;field.fill&#125;)
        &lt;#else&gt;
    @TableField(fill = FieldFill.$&#123;field.fill&#125;)
        &lt;/#if&gt;
    &lt;#elseif field.convert&gt;
    @TableField(&quot;$&#123;field.annotationColumnName&#125;&quot;)
    &lt;/#if&gt;
    &lt;#-- 乐观锁注解 --&gt;
    &lt;#if (versionFieldName!&quot;&quot;) == field.name&gt;
    @Version
    &lt;/#if&gt;
    &lt;#-- 逻辑删除注解 --&gt;
    &lt;#if (logicDeleteFieldName!&quot;&quot;) == field.name&gt;
    @TableLogic
    &lt;/#if&gt;
    private $&#123;field.propertyType&#125; $&#123;field.propertyName&#125;;
&lt;/#list&gt;
&lt;#------------  END 字段循环遍历  ----------&gt;

&lt;#if !entityLombokModel&gt;
    &lt;#list table.fields as field&gt;
        &lt;#if field.propertyType == &quot;boolean&quot;&gt;
            &lt;#assign getprefix=&quot;is&quot;/&gt;
        &lt;#else&gt;
            &lt;#assign getprefix=&quot;get&quot;/&gt;
        &lt;/#if&gt;
    public $&#123;field.propertyType&#125; $&#123;getprefix&#125;$&#123;field.capitalName&#125;() &#123;
        return $&#123;field.propertyName&#125;;
    &#125;

    &lt;#if chainModel&gt;
    public $&#123;entity&#125; set$&#123;field.capitalName&#125;($&#123;field.propertyType&#125; $&#123;field.propertyName&#125;) &#123;
    &lt;#else&gt;
    public void set$&#123;field.capitalName&#125;($&#123;field.propertyType&#125; $&#123;field.propertyName&#125;) &#123;
    &lt;/#if&gt;
        this.$&#123;field.propertyName&#125; = $&#123;field.propertyName&#125;;
        &lt;#if chainModel&gt;
        return this;
        &lt;/#if&gt;
    &#125;
    &lt;/#list&gt;
&lt;/#if&gt;

&lt;#if entityColumnConstant&gt;
    &lt;#list table.fields as field&gt;
    public static final String $&#123;field.name?upper_case&#125; = &quot;$&#123;field.name&#125;&quot;;

    &lt;/#list&gt;
&lt;/#if&gt;
&lt;#if activeRecord&gt;
    @Override
    protected Serializable pkVal() &#123;
    &lt;#if keyPropertyName??&gt;
        return this.$&#123;keyPropertyName&#125;;
    &lt;#else&gt;
        return null;
    &lt;/#if&gt;
    &#125;

&lt;/#if&gt;
&lt;#if !entityLombokModel&gt;
    @Override
    public String toString() &#123;
        return &quot;$&#123;entity&#125;&#123;&quot; +
    &lt;#list table.fields as field&gt;
        &lt;#if field_index==0&gt;
            &quot;$&#123;field.propertyName&#125;=&quot; + $&#123;field.propertyName&#125; +
        &lt;#else&gt;
            &quot;, $&#123;field.propertyName&#125;=&quot; + $&#123;field.propertyName&#125; +
        &lt;/#if&gt;
    &lt;/#list&gt;
        &quot;&#125;&quot;;
    &#125;
&lt;/#if&gt;
&#125;
</code></pre>
<h3 id="vm文件"><a href="#vm文件" class="headerlink" title=".vm文件"></a>.vm文件</h3><pre><code class="vm">package $&#123;package.Entity&#125;;

#foreach($pkg in $&#123;table.importPackages&#125;)
import $&#123;pkg&#125;;
#end
#if($&#123;entityLombokModel&#125;)
import lombok.*;
#end

/**
 * &lt;p&gt;
 * $!&#123;table.comment&#125;
 * &lt;/p&gt;
 *
 * @author $&#123;author&#125;
 * @since $&#123;date&#125;
 */
#if($&#123;entityLombokModel&#125;)
  #if($&#123;superEntityClass&#125;)
@EqualsAndHashCode(callSuper = true)
  #else
@EqualsAndHashCode(callSuper = false)
  #end
#end
#if($&#123;table.convert&#125;)
@TableName(&quot;$&#123;table.name&#125;&quot;)
#end
@AllArgsConstructor
@NoArgsConstructor
@Data
@ToString
#if($&#123;superEntityClass&#125;)
public class $&#123;entity&#125; extends $&#123;superEntityClass&#125;#if($&#123;activeRecord&#125;)&lt;$&#123;entity&#125;&gt;#end &#123;
#elseif($&#123;activeRecord&#125;)
public class $&#123;entity&#125; extends Model&lt;$&#123;entity&#125;&gt; &#123;
#else
public class $&#123;entity&#125; implements Serializable &#123;
#end

#if($&#123;entitySerialVersionUID&#125;)
    private static final long serialVersionUID = 1L;
#end
## ----------  BEGIN 字段循环遍历  ----------
#foreach($field in $&#123;table.fields&#125;)

#if($&#123;field.keyFlag&#125;)
#set($keyPropertyName=$&#123;field.propertyName&#125;)
#end
#if(&quot;$!field.comment&quot; != &quot;&quot;)
  #if($&#123;swagger2&#125;)
    @ApiModelProperty(value = &quot;$&#123;field.comment&#125;&quot;)
  #else
    /**
     * $&#123;field.comment&#125;
     */
  #end
#end
#if($&#123;field.keyFlag&#125;)
## 主键
  #if($&#123;field.keyIdentityFlag&#125;)
    @TableId(value = &quot;$&#123;field.annotationColumnName&#125;&quot;, type = IdType.AUTO)
  #elseif(!$null.isNull($&#123;idType&#125;) &amp;&amp; &quot;$!idType&quot; != &quot;&quot;)
    @TableId(value = &quot;$&#123;field.annotationColumnName&#125;&quot;, type = IdType.$&#123;idType&#125;)
  #elseif($&#123;field.convert&#125;)
    @TableId(&quot;$&#123;field.annotationColumnName&#125;&quot;)
  #end
## 普通字段
#elseif($&#123;field.fill&#125;)
## -----   存在字段填充设置   -----
  #if($&#123;field.convert&#125;)
    @TableField(value = &quot;$&#123;field.annotationColumnName&#125;&quot;, fill = FieldFill.$&#123;field.fill&#125;)
  #else
    @TableField(fill = FieldFill.$&#123;field.fill&#125;)
  #end
#elseif($&#123;field.convert&#125;)
    @TableField(&quot;$&#123;field.annotationColumnName&#125;&quot;)
#end
## 乐观锁注解
#if($&#123;versionFieldName&#125;==$&#123;field.name&#125;)
    @Version
#end
## 逻辑删除注解
#if($&#123;logicDeleteFieldName&#125;==$&#123;field.name&#125;)
    @TableLogic
#end
    private $&#123;field.propertyType&#125; $&#123;field.propertyName&#125;;
#end
## ----------  END 字段循环遍历  ----------

#if(!$&#123;entityLombokModel&#125;)
#foreach($field in $&#123;table.fields&#125;)
  #if($&#123;field.propertyType.equals(&quot;boolean&quot;)&#125;)
    #set($getprefix=&quot;is&quot;)
  #else
    #set($getprefix=&quot;get&quot;)
  #end

    public $&#123;field.propertyType&#125; $&#123;getprefix&#125;$&#123;field.capitalName&#125;() &#123;
        return $&#123;field.propertyName&#125;;
    &#125;

  #if($&#123;chainModel&#125;)
    public $&#123;entity&#125; set$&#123;field.capitalName&#125;($&#123;field.propertyType&#125; $&#123;field.propertyName&#125;) &#123;
  #else
    public void set$&#123;field.capitalName&#125;($&#123;field.propertyType&#125; $&#123;field.propertyName&#125;) &#123;
  #end
        this.$&#123;field.propertyName&#125; = $&#123;field.propertyName&#125;;
  #if($&#123;chainModel&#125;)
        return this;
  #end
    &#125;
#end
## --foreach end---
#end
## --end of #if(!$&#123;entityLombokModel&#125;)--

#if($&#123;entityColumnConstant&#125;)
  #foreach($field in $&#123;table.fields&#125;)
    public static final String $&#123;field.name.toUpperCase()&#125; = &quot;$&#123;field.name&#125;&quot;;

  #end
#end
#if($&#123;activeRecord&#125;)
    @Override
    protected Serializable pkVal() &#123;
  #if($&#123;keyPropertyName&#125;)
        return this.$&#123;keyPropertyName&#125;;
  #else
        return null;
  #end
    &#125;

#end
#if(!$&#123;entityLombokModel&#125;)
    @Override
    public String toString() &#123;
        return &quot;$&#123;entity&#125;&#123;&quot; +
  #foreach($field in $&#123;table.fields&#125;)
    #if($!&#123;foreach.index&#125;==0)
        &quot;$&#123;field.propertyName&#125;=&quot; + $&#123;field.propertyName&#125; +
    #else
        &quot;, $&#123;field.propertyName&#125;=&quot; + $&#123;field.propertyName&#125; +
    #end
  #end
        &quot;&#125;&quot;;
    &#125;
#end
&#125;
</code></pre>
<h2 id="逆向工程"><a href="#逆向工程" class="headerlink" title="逆向工程"></a>逆向工程</h2><blockquote>
<p>通用模板代码，符合我的习惯。</p>
<p>其他具体的风格配置可以因人而异再次修改。代码中注释很多</p>
</blockquote>
<pre><code class="java">import com.baomidou.mybatisplus.core.toolkit.StringPool;
import com.baomidou.mybatisplus.generator.AutoGenerator;
import com.baomidou.mybatisplus.generator.InjectionConfig;
import com.baomidou.mybatisplus.generator.config.*;
import com.baomidou.mybatisplus.generator.config.po.TableInfo;
import com.baomidou.mybatisplus.generator.config.rules.NamingStrategy;
import com.baomidou.mybatisplus.generator.engine.FreemarkerTemplateEngine;

import java.util.ArrayList;
import java.util.List;
import java.util.Objects;
import java.util.Scanner;

public class Generator &#123;

    /*
    * 逆向工程
    * 要修改前缀、后缀的东西策略中，
    * 其他的修改去代码里面翻一翻，大多数都注释了，找不到了可以看官网
    *  */
    public static void main(String[] args) &#123;
        Scanner scanner = new Scanner(System.in);
        System.out.println(&quot;====================================&quot;);
        System.out.println(&quot;==============1.生成部分表============&quot;);
        System.out.println(&quot;==============2.生成全部表============&quot;);
        System.out.println(&quot;=====================================&quot;);
        int i = scanner.nextInt();
        switch (i) &#123;
            case 1:
                System.out.println(&quot;请输入你要逆向生成的表名，用 , 号分开&quot;);
                String name = scanner.next();
                generator(name);
                break;
            case 2: generator(null);break;
        &#125;
    &#125;
    public static void generator(String tableName)&#123;
        // 代码生成器
        AutoGenerator mpg = new AutoGenerator();

        // 全局配置
        GlobalConfig gc = new GlobalConfig();
        String projectPath = System.getProperty(&quot;user.dir&quot;);
        gc.setOutputDir(projectPath + &quot;/src/main/java&quot;);
        gc.setAuthor(&quot;zjj&quot;); //作者
        gc.setOpen(false); //是否打开目录
        gc.setBaseResultMap(true);//xml开启BaseResultMap
        gc.setBaseColumnList(true);//xml 开启BaseColumn
        // gc.setSwagger2(true); //实体属性 Swagger2 注解
        mpg.setGlobalConfig(gc);

        // 数据源配置
        DataSourceConfig dsc = new DataSourceConfig();
        dsc.setUrl(&quot;jdbc:mysql://localhost:3306/mydb?useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=Asia/Shanghai&quot;);
        // dsc.setSchemaName(&quot;public&quot;);
        dsc.setDriverName(&quot;com.mysql.cj.jdbc.Driver&quot;);
        dsc.setUsername(&quot;root&quot;);
        dsc.setPassword(&quot;root&quot;);
        mpg.setDataSource(dsc);

        // 包配置
        PackageConfig pc = new PackageConfig();
        //pc.setModuleName(scanner(&quot;模块名&quot;));
        pc.setParent(&quot;com.zjj&quot;)
                .setEntity(&quot;pojo&quot;)
                .setMapper(&quot;mapper&quot;)
                .setService(&quot;service&quot;)
                .setServiceImpl(&quot;service.impl&quot;)
                .setController(&quot;controller&quot;);
        mpg.setPackageInfo(pc);

        // 自定义配置
        InjectionConfig cfg = new InjectionConfig() &#123;
            @Override
            public void initMap() &#123;
                // to do nothing
            &#125;
        &#125;;

        // 如果模板引擎是 freemarker
        String templatePath = &quot;/templates/mapper.xml.ftl&quot;;
        // 如果模板引擎是 velocity
        // String templatePath = &quot;/templates/mapper.xml.vm&quot;;

        // 自定义输出配置
        List&lt;FileOutConfig&gt; focList = new ArrayList&lt;&gt;();
        // 自定义配置会被优先输出
        focList.add(new FileOutConfig(templatePath) &#123;
            @Override
            public String outputFile(TableInfo tableInfo) &#123;
                // 自定义输出文件名 ， 如果你 Entity 设置了前后缀、此处注意 xml 的名称会跟着发生变化！！
                System.out.println(pc.getModuleName());
                return projectPath + &quot;/src/main/resources/mapper&quot; + pc.getModuleName()
                        + &quot;/&quot; + tableInfo.getEntityName() + &quot;Mapper&quot; + StringPool.DOT_XML;
            &#125;
        &#125;);

        cfg.setFileOutConfigList(focList);
        mpg.setCfg(cfg);

        // 配置模板
        TemplateConfig templateConfig = new TemplateConfig();
        // 配置自定义输出模板
        //指定自定义模板路径，注意不要带上.ftl/.vm, 会根据使用的模板引擎自动识别
        templateConfig.setEntity(&quot;/templates/MyEntity.java&quot;);
        // templateConfig.setService();
        // templateConfig.setController();
        templateConfig.setXml(null);
        mpg.setTemplate(templateConfig);

        // 策略配置
        StrategyConfig strategy = new StrategyConfig();
        //数据库表映射到实体的命名策略
        strategy.setNaming(NamingStrategy.underline_to_camel);
        //数据库表字段映射到实体的命名策略
        strategy.setColumnNaming(NamingStrategy.no_change);
        //strategy.setSuperEntityClass(&quot;你自己的父类实体,没有就不用设置!&quot;);
        //lombok模型
        strategy.setEntityLombokModel(true);
        //生成RestController
        strategy.setRestControllerStyle(true);
        // 公共父类
        //strategy.setSuperControllerClass(&quot;你自己的父类控制器,没有就不用设置!&quot;);
        // 写于父类中的公共字段
        //strategy.setSuperEntityColumns(&quot;id&quot;);
        if (!Objects.isNull(tableName)) &#123;
            //strategy.setInclude(scanner(&quot;表名，多个英文逗号分割&quot;).split(&quot;,&quot;));
            strategy.setInclude(tableName.split(&quot;,&quot;));
        &#125;

        strategy.setControllerMappingHyphenStyle(true);
        //表前缀
        // strategy.setTablePrefix(&quot;t_&quot;);
        mpg.setStrategy(strategy);
        mpg.setTemplateEngine(new FreemarkerTemplateEngine());
        mpg.execute();
    &#125;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>MybatisPlus</category>
      </categories>
      <tags>
        <tag>框架</tag>
        <tag>ORM</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis</title>
    <url>/2022/10/07/ORM/Mybatis/</url>
    <content><![CDATA[<h1 id="1-Mybatis入门"><a href="#1-Mybatis入门" class="headerlink" title="1 Mybatis入门"></a>1 Mybatis入门</h1><p>原生JDBC实现CURD的问题</p>
<blockquote>
<p>1 编码繁琐<br>2 需要我们自己将结果集映射成对象<br>3 性能不太好  连接池 缓存<br>4 SQL语句和java代码的耦合度特别高<br>5 … …</p>
</blockquote>
<p>MyBatis 本是Apache的一个开源项目iBatis, 2010年这个项目由Apache Software Foundation 迁移到了Google Code，且改名为MyBatis 。2013年11月迁移到GitHub。iBATIS一词来源于“internet”和“abatis”的组合，是一个基于Java的持久层框架。<br>MyBatis 是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 POJOs(Plain Ordinary Java Object,普通的 Java对象)映射成数据库中的记录。</p>
<img data-src="/2022/10/07/ORM/Mybatis/image-20220617191731748.png" class="" title="image-20220617191731748">





<h2 id="1-认识框架"><a href="#1-认识框架" class="headerlink" title="1 认识框架"></a>1 认识框架</h2><p>框架（Framework）是一个框子——指其约束性，也是一个架子——指其支撑性。是一个基本概念上的结构，用于去解决或者处理复杂的问题。框架这个广泛的定义使用的十分流行，尤其在软件概念。<br>框架( Framework )对于java来说,就是一系列为了解决特定问题而定义的一系列接口和实现类,在组织框架代码时,使用了一系列优秀的设计模式,使代码无论在性能上还是API操作上得到很大提升.框架可以看做是项目开发的半成品,基本的底层操作已经封装完毕,通过框架,程序员可以从底层代码中解脱出来,专注于业务逻辑的完成和性能的优化。框架规定了你的应用的体系结构。它定义了整体结构，类和对象的分割，各部分的主要责任，类和对象怎么协作，以及控制流程。框架预定义了这些设计参数，以便于应用设计者或实现者能集中精力于应用本身的特定细节。</p>
<p>如果将开发完成的软件比作是一套已经装修完毕的新房，那框架就好比是一套已经修建好的毛坯房。用户直接购买毛坯房，建筑质量和户型合理有保证，还省去了自己建造房屋的时间，一举多得。<br>在开发过程是使用框架，同样可以保证减少开发时间、降低开发难度，并且还保证设计质量。好比和世界上最优秀的软件工程师是一个项目的，并且他们完成的还是基础、全局的工作。想想是不是很嗨的一件事情。</p>
<img data-src="/2022/10/07/ORM/Mybatis/image-20220617191818381.png" class="" title="image-20220617191818381">





<p>框架还有一个作用是约束。莎士比亚说,”一千个观众眼中有一千个哈姆雷特” 即仁者见仁,智者见智.说每个人都会对作品有不同的理解，每个人对待任何事物都有自己的看法，一千个人就有可能有一千种不同的看法1000人心中有1000个哈姆雷特。同样的技术解决同样的问题会产生不同流程和风格的解决方案，而采用一种框架其实就是限制用户必须使用其规定的方案来实现，<strong>可以降低程序员之间沟通以及日后维护的成本。</strong></p>
<p>常用的基于JavaEE的三大开源框架，已经从SSH、SSH2过渡到了SSM：SpringMVC、Spring、MyBatis &gt;&gt;&gt; springBoot</p>
<p><font face="微软雅黑" size=6 color=#FF0000>总之，框架是一个半成品，已经对基础的代码进行了封装并提供相应的API，开发者在使用框架是直接调用封装好的API可以省去很多代码编写，从而提高工作效率和开发速度。</font></p>
<h2 id="2-认识ORM"><a href="#2-认识ORM" class="headerlink" title="2 认识ORM"></a>2 认识ORM</h2><p>DBC的缺点：</p>
<p>需要手动的完成面向对象的Java语言、面向关系的数据库之间数据的转换，代码繁琐无技术含量，影响了开发效率。</p>
<p>如图所示，查询是需要手动的将结果集的列数据转换为Java对象的属性；而添加操作时需要手动将Java对象的属性转换为数据库表的列字段。</p>
<p>关于面向对象的Java语言、面向关系的数据库之间数据的转换必须要做，问题在于这个转换是否可以不由开发者来做。可以的。ORM框架就是专门来做这个问题的，相当于在面向对象语言和关系数据库之间搭建一个桥梁。</p>
<p>&#x3D;&#x3D;ORM，Object-Relationl Mapping，对象关系映射，它的作用是在关系型数据库和对象之间作一个映射，这样我们在具体的操作数据库的时候，只要像平时操作对象一样操作它就可以了，ORM框架会根据映射完成对数据库的操作，就不需要再去和复杂的SQL语句打交道了&#x3D;&#x3D;。</p>
<img data-src="/2022/10/07/ORM/Mybatis/image-20220617192304044.png" class="" title="image-20220617192304044">


<p>另外学习ORM必须知道两个概念：持久化、持久层</p>
<p><strong>什么是“持久化”</strong></p>
<p>持久（Persistence），<font color=#FF0000>即把数据（如内存中的对象）保存到可永久保存的存储设备中（如磁盘）</font>。持久化的主要应用是将内存中的数据存储在关系型的数据库中，当然也可以存储在磁盘文件中、XML数据文件中等等。</p>
<p><strong>什么是 “持久层”</strong></p>
<p>持久层（Persistence Layer），即专注于实现数据持久化应用领域的某个特定系统的一个逻辑层面，将数据使用者和数据实体相关联。之前使用JDBC访问数据库的DAO层，后面采用MyBatis访问数据库的mapper层，就是持久层。</p>
<p><strong>Mybatis是一持久层的款半自动的ORM映射框架</strong></p>
<h2 id="3-认识MyBatis"><a href="#3-认识MyBatis" class="headerlink" title="3 认识MyBatis"></a>3 认识MyBatis</h2><blockquote>
<p>MyBatis 本是Apache的一个开源项目iBatis, 2010年这个项目由Apache Software Foundation 迁移到了Google Code，且改名为MyBatis 。2013年11月迁移到GitHub。iBATIS一词来源于“internet”和“abatis”的组合，是一个基于Java的持久层框架。</p>
</blockquote>
<p>MyBatis 是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 POJOs(Plain Ordinary Java Object,普通的 Java对象)映射成数据库中的记录。</p>
<img data-src="/2022/10/07/ORM/Mybatis/image-20220617192446302.png" class="" title="image-20220617192446302">

<p>精简解释：MyBatis是一个半自动ORM框架，其本质是对JDBC的封装。使用MyBatis重点需要程序员编写SQL命令，不需要写一行JDBC代码</p>
<h1 id="2-MyBatis初次使用"><a href="#2-MyBatis初次使用" class="headerlink" title="2 MyBatis初次使用"></a>2 MyBatis初次使用</h1><h2 id="1-创建maven项目导入相关依赖"><a href="#1-创建maven项目导入相关依赖" class="headerlink" title="1 创建maven项目导入相关依赖"></a>1 创建maven项目导入相关依赖</h2><p>但凡是框架,使用都是分三步走</p>
<p>1导入jar文件,maven</p>
<p>2处理配置文件</p>
<p>3开发业务代码</p>
<p>先创建一个空项目,用于存放后面Mybatis相关项目模块</p>
<img data-src="/2022/10/07/ORM/Mybatis/image-20220617192550409.png" class="" title="image-20220617192550409">


<p>项目名为mybatisAll即可</p>
<img data-src="/2022/10/07/ORM/Mybatis/image-20220617192555641.png" class="" title="image-20220617192555641">




<p>这里不显示项目名 没关系,如果想看到项目名,可以close项目后,再次open即可</p>
<img data-src="/2022/10/07/ORM/Mybatis/image-20220617192604832.png" class="" title="image-20220617192604832">




<p>关闭项目</p>
<img data-src="/2022/10/07/ORM/Mybatis/image-20220617192611548.png" class="" title="image-20220617192611548">


<p>再次open</p>
<img data-src="/2022/10/07/ORM/Mybatis/image-20220617192630884.png" class="" title="image-20220617192630884">






<p>项目名就显示了</p>
<img data-src="/2022/10/07/ORM/Mybatis/image-20220617192636190.png" class="" title="image-20220617192636190">


<p>接下来设置maven为我们自己安装的,不用idea自带的(当然用自带的也行)</p>
<img data-src="/2022/10/07/ORM/Mybatis/image-20220617192641520.png" class="" title="image-20220617192641520">



<img data-src="/2022/10/07/ORM/Mybatis/image-20220617192647200.png" class="" title="image-20220617192647200">


<p>在当前项目中创建模块</p>
<img data-src="/2022/10/07/ORM/Mybatis/image-20220617192652567.png" class="" title="image-20220617192652567">


<p>选择maven项目 next</p>
<img data-src="/2022/10/07/ORM/Mybatis/image-20220617192703265.png" class="" title="image-20220617192703265">






<p>输入groupid和aitifactid  然后finish</p>
<img data-src="/2022/10/07/ORM/Mybatis/image-20220617192713221.png" class="" title="image-20220617192713221">


<p>检查项目目前在磁盘上的存放路径 然后next</p>
<img data-src="/2022/10/07/ORM/Mybatis/image-20220617192719403.png" class="" title="image-20220617192719403">




<p>检查项目目录结构是否有缺失</p>
<img data-src="/2022/10/07/ORM/Mybatis/image-20220617192723928.png" class="" title="image-20220617192723928">


<p>MyBatis官网说明文档   <span class="exturl" data-url="aHR0cHM6Ly9teWJhdGlzLm9yZy9teWJhdGlzLTMvemgvaW5kZXguaHRtbA==">https://mybatis.org/mybatis-3/zh/index.html</span></p>
<p>在pom.xml中导入MyBatis相关依赖jar文件</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
    &lt;groupId&gt;com.msb&lt;/groupId&gt;
    &lt;artifactId&gt;mybatisTest01&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;packaging&gt;jar&lt;/packaging&gt;
    &lt;dependencies&gt;
        &lt;!--mysqlConnector--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;mysql&lt;/groupId&gt;
            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
            &lt;version&gt;8.0.16&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!--mybatis 核心jar包--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
            &lt;artifactId&gt;mybatis&lt;/artifactId&gt;
            &lt;version&gt;3.5.3&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!--junit--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;junit&lt;/groupId&gt;
            &lt;artifactId&gt;junit&lt;/artifactId&gt;
            &lt;version&gt;4.13.1&lt;/version&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;
        &lt;!--lombok --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
            &lt;artifactId&gt;lombok&lt;/artifactId&gt;
            &lt;version&gt;1.18.12&lt;/version&gt;
            &lt;scope&gt;provided&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/project&gt;
</code></pre>
<p>安装lombok插件后,重启idea</p>
<img data-src="/2022/10/07/ORM/Mybatis/image-20220617192808470.png" class="" title="image-20220617192808470">




<p>导入lombok依赖后,单独设置启用注解处理</p>
<img data-src="/2022/10/07/ORM/Mybatis/image-20220617192814365.png" class="" title="image-20220617192814365">



<h2 id="2-准备数据库-包结构和实体类"><a href="#2-准备数据库-包结构和实体类" class="headerlink" title="2  准备数据库_包结构和实体类"></a>2  准备数据库_包结构和实体类</h2><p>数据库</p>
<p><img data-src="/../spring/img/image-20220617192857161.png" alt="image-20220617192857161"></p>
<p>项目结构</p>
<img data-src="/2022/10/07/ORM/Mybatis/image-20220617192901785.png" class="" title="image-20220617192901785">

<p> 实体类Dept</p>
<pre><code class="java"> package com.msb.pojo;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import java.io.Serializable;
/**

 * @Author: Ma HaiYang
 * @Description: MircoMessage:Mark_7001
    */
    @Data
    @AllArgsConstructor
    @NoArgsConstructor
    public class Dept implements Serializable &#123;
    private Integer deptno;
    private String dname;
    private String loc;
    &#125;
</code></pre>
<h2 id="3-准备Mapper映射文件和核心配置文件"><a href="#3-准备Mapper映射文件和核心配置文件" class="headerlink" title="3 准备Mapper映射文件和核心配置文件"></a>3 准备Mapper映射文件和核心配置文件</h2><p>resources目录下 创建 com&#x2F;msb&#x2F;mapper目录,然后添加DeptMapper.xml映射文件</p>
<img data-src="/2022/10/07/ORM/Mybatis/image-20220617193030929.png" class="" title="image-20220617193030929">

<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper
        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;aaa&quot;&gt;
    &lt;!--public List&lt;Dept&gt; findAll()&#123;    &#125;--&gt;
    &lt;select id=&quot;findAll&quot; resultType=&quot;com.msb.pojo.Dept&quot; &gt;
        select * from dept
    &lt;/select&gt;
&lt;/mapper&gt;
</code></pre>
<p>resources目录下准备sqlMapConfig.xml 核心配置文件</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE configuration
        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;
&lt;configuration&gt;
    &lt;environments default=&quot;development&quot;&gt;
        &lt;environment id=&quot;development&quot;&gt;
            &lt;transactionManager type=&quot;JDBC&quot;/&gt;
            &lt;dataSource type=&quot;POOLED&quot;&gt;
                &lt;property name=&quot;driver&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt;
                &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://127.0.0.1:3306/mydb?useSSL=false&amp;amp;useUnicode=true&amp;amp;characterEncoding=UTF-8&amp;amp;serverTimezone=Asia/Shanghai&quot;/&gt;
                &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;
                &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt;
            &lt;/dataSource&gt;
        &lt;/environment&gt;
    &lt;/environments&gt;
    &lt;!--加载mapper映射文件--&gt;
    &lt;mappers&gt;
        &lt;mapper resource=&quot;com/msb/mapper/DeptMapper.xml&quot;/&gt;
    &lt;/mappers&gt;
&lt;/configuration&gt;
</code></pre>
<h2 id="4-运行测试"><a href="#4-运行测试" class="headerlink" title="4 运行测试"></a>4 运行测试</h2><img data-src="/2022/10/07/ORM/Mybatis/image-20220617193244713.png" class="" title="image-20220617193244713">

<p>在test目录下开发测试代码并运行</p>
<p><img data-src="/../spring/img/image-20220617193259351.png" alt="image-20220617193259351"></p>
<pre><code class="java"> package com.msb.test;
import com.msb.pojo.Dept;
import org.apache.ibatis.io.Resources;
import org.apache.ibatis.session.SqlSession;
import org.apache.ibatis.session.SqlSessionFactory;
import org.apache.ibatis.session.SqlSessionFactoryBuilder;
import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import java.io.IOException;
import java.io.InputStream;
import java.util.List;
/**

 * @Author: Ma HaiYang
 * @Description: MircoMessage:Mark_7001
    */
    public class Test1 &#123;
    private SqlSession sqlSession;
    @Before
    public void init()&#123;
        SqlSessionFactoryBuilder ssfb =new SqlSessionFactoryBuilder();
        InputStream resourceAsStream = null;
        try &#123;
            resourceAsStream = Resources.getResourceAsStream(&quot;sqlMapConfig.xml&quot;);
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125;
        SqlSessionFactory factory=ssfb.build(resourceAsStream) ;
        sqlSession=factory.openSession();
    &#125;
    @Test
    public void testFindAll()&#123;
        // 调用SQL语句
        List&lt;Dept&gt; list = sqlSession.selectList(&quot;findAll&quot;);
        for (Dept dept : list) &#123;
            System.out.println(dept);
        &#125;
    &#125;
    @After
    public void release()&#123;
        // 关闭SQLSession
        sqlSession.close();
    &#125;
    &#125;
</code></pre>
<h1 id="3-MyBatis配置详解"><a href="#3-MyBatis配置详解" class="headerlink" title="3 MyBatis配置详解"></a>3 MyBatis配置详解</h1><h3 id="1-log4j1和log4j2的简单配置"><a href="#1-log4j1和log4j2的简单配置" class="headerlink" title="1_log4j1和log4j2的简单配置"></a>1_log4j1和log4j2的简单配置</h3><p>项目中添加依赖</p>
<pre><code class="xml">&lt;!-- log4j2 --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;
    &lt;artifactId&gt;log4j-core&lt;/artifactId&gt;
    &lt;version&gt;2.12.1&lt;/version&gt;
&lt;/dependency&gt;
&lt;!-- log4j1 --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;log4j&lt;/groupId&gt;
    &lt;artifactId&gt;log4j&lt;/artifactId&gt;
    &lt;version&gt;1.2.17&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<pre><code>在mybatis.cfg.xml中配置MyBatis所使用的具体日志实现。如果不指定将自动搜索。可能会搜到log4j，但是如果优先搜到了其他的日志实现呢，所以还是设置为好。这一来log4j就跑不了了。
</code></pre>
<p>log4j 1</p>
<pre><code>将log4j.properties文件负责到src下。另外在其中可以将全局的日志级别调高，避免大量debug信息的干扰。同时将对映射文件的操作调低，可以用来显示SQL语句的调试信息。开发阶段，建议启动控制的日志。
</code></pre>
<p> #定义全局日志级别调试阶段推荐debug</p>
<pre><code class="properties">log4j.rootLogger=debug,stdout 
log4j.appender.stdout=org.apache.log4j.ConsoleAppender
log4j.appender.stdout.Target=System.err
log4j.appender.stdout.layout=org.apache.log4j.SimpleLayout
log4j.appender.logfile=org.apache.log4j.FileAppender
log4j.appender.logfile.File=d:/msb.log
log4j.appender.logfile.layout=org.apache.log4j.PatternLayout
log4j.appender.logfile.layout.ConversionPattern=%d&#123;yyyy-MM-dd HH:mm:ss&#125; %l %F %p %m%n
</code></pre>
<p>在核心配置文件中可以选择的其他日志处理方式</p>
<p>log4j 2</p>
<p>将log4j2.xml文件负责到resources下。</p>
<pre><code class="xml"> &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;Configuration status=&quot;DEBUG&quot;&gt;
    &lt;Appenders&gt;
        &lt;Console name=&quot;Console&quot; target=&quot;SYSTEM_ERR&quot;&gt;
            &lt;PatternLayout pattern=&quot;%d&#123;YYYY-MM-dd HH:mm:ss&#125; [%t] %-5p %c&#123;1&#125;:%L - %msg%n&quot; /&gt;
        &lt;/Console&gt;
        &lt;RollingFile name=&quot;RollingFile&quot; filename=&quot;log/test.log&quot;
                     filepattern=&quot;$&#123;logPath&#125;/%d&#123;YYYYMMddHHmmss&#125;-fargo.log&quot;&gt;
            &lt;PatternLayout pattern=&quot;%d&#123;YYYY-MM-dd HH:mm:ss&#125; [%t] %-5p %c&#123;1&#125;:%L - %msg%n&quot; /&gt;
            &lt;Policies&gt;
                &lt;SizeBasedTriggeringPolicy size=&quot;10 MB&quot; /&gt;
            &lt;/Policies&gt;
            &lt;DefaultRolloverStrategy max=&quot;20&quot; /&gt;
        &lt;/RollingFile&gt;
    &lt;/Appenders&gt;
    &lt;Loggers&gt;
        &lt;Root level=&quot;INFO&quot;&gt;
            &lt;AppenderRef ref=&quot;Console&quot; /&gt;
        &lt;/Root&gt;
    &lt;/Loggers&gt;
&lt;/Configuration&gt;
</code></pre>
<p>核心配置文件中可以指定日志打印方式</p>
<img data-src="/2022/10/07/ORM/Mybatis/image-20220617193736735.png" class="" title="image-20220617193736735">



<h2 id="2-关于事务配置"><a href="#2-关于事务配置" class="headerlink" title="2_关于事务配置"></a>2_关于事务配置</h2><img data-src="/2022/10/07/ORM/Mybatis/image-20220617193831478.png" class="" title="image-20220617193831478">

<p>在mybatis核心配置文件中 envirment中 通过transactionManager配置事务的处理策略</p>
<p><font color=#FF000>JDBC</font> – 这个配置直接简单使用了 JDBC 的提交和回滚设置。它依赖于从数据源得到的连接来管理事务范围。</p>
<p><font color=#FF000>MANAGED </font>– 这个配置几乎没做什么。它从来不提交或回滚一个连接。而它会让容器来管理事务的整个生命周期(比如 Spring 或 JEE 应用服务器的上下文) 默认情况下它会关闭连接。然而一些容器并不希望这样, 因此如果你需要从连接中停止它,将closeConnection 属性设置为 false. mybatis本身并不做事务的处理,交给其他框架去处理事务,如spring</p>
<h2 id="3-关于映射文件的加载方式"><a href="#3-关于映射文件的加载方式" class="headerlink" title="3_关于映射文件的加载方式"></a>3_关于映射文件的加载方式</h2><p>1.mapper映射文件的文件路径导入 使用的mapper标签的resource属性</p>
<p>2.网络资源路径 使用的mapper标签的url属性</p>
<p>3.接口的全限定名导入 使用的是mapper标签的class属性 (基于接口的代理模式开发)</p>
<p>4.包扫描形式加载所有的mapper映射文件 使用的是 package标签</p>
<img data-src="/2022/10/07/ORM/Mybatis/image-20220617193946594.png" class="" title="image-20220617193946594">

<h2 id="4-关于实体类别名处理"><a href="#4-关于实体类别名处理" class="headerlink" title="4_关于实体类别名处理"></a>4_关于实体类别名处理</h2><p>在mybatis核心配置文件中使用别名处理</p>
<pre><code class="xml"> &lt;!--设置实体类别名--&gt;
&lt;typeAliases&gt;
    &lt;!--
    通过包扫描给所有的实体类起别名
    给指定报名下的所有类起别名
    默认每个实体类的别名是首字母小写的类名
    Dept   dept
    Emp    emp
    --&gt;
    &lt;package name=&quot;com.msb.pojo&quot;/&gt;
&lt;/typeAliases&gt;
</code></pre>
<p>在映射文件的resultType 返回值类型  和paramterType 上就可以使用别名了</p>
<pre><code class="xml">&lt;select id=&quot;selectByEmpno&quot;  resultType=&quot;emp&quot;&gt;
    select * from emp where empno = 7566
&lt;/select&gt;
</code></pre>
<h2 id="5-关于外部属性配置文件存储数据库连接信息"><a href="#5-关于外部属性配置文件存储数据库连接信息" class="headerlink" title="5_关于外部属性配置文件存储数据库连接信息"></a>5_关于外部属性配置文件存储数据库连接信息</h2><p>在resources下准备jdbc.properties属性配置文件</p>
<img data-src="/2022/10/07/ORM/Mybatis/image-20220617194131042.png" class="" title="image-20220617194131042">


<p>配置文件中的内容</p>
<pre><code class="properties">jdbc_driver=com.mysql.cj.jdbc.Driver
jdbc_url=jdbc:mysql://127.0.0.1:3306/mydb?useSSL=false&amp;useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=Asia/Shanghai
jdbc_username=root
jdbc_password=root
</code></pre>
<p>在核心配置文件中引入db.properties属性文件</p>
<pre><code class="xml"> &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!-- xml文档约束 约束xml文档中可以有哪些标签,哪些属性,以及标签的包含关系和顺序....
dtd 约束
schema 约束
--&gt;

&lt;!DOCTYPE configuration
        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;
&lt;configuration&gt;
    &lt;properties resource=&quot;jdbc.properties&quot;&gt;&lt;/properties&gt;
    &lt;settings&gt;
        &lt;!--设置日志处理方式--&gt;
        &lt;setting name=&quot;logImpl&quot; value=&quot;LOG4J&quot;/&gt;
    &lt;/settings&gt;
    &lt;!--设置实体类别名--&gt;
    &lt;typeAliases&gt;
        &lt;!--
        通过包扫描给所有的实体类起别名
        给指定报名下的所有类起别名
        默认每个实体类的别名是首字母小写的类名
        Dept   dept
        Emp    emp
        --&gt;
        &lt;package name=&quot;com.msb.pojo&quot;/&gt;
    &lt;/typeAliases&gt;
    &lt;!--配置数据库链接信息--&gt;
    &lt;environments default=&quot;mysql&quot;&gt;
        &lt;!--数据源1--&gt;
        &lt;environment id=&quot;mysql&quot;&gt;
            &lt;transactionManager type=&quot;JDBC&quot;/&gt;
            &lt;!--一个数据源--&gt;
            &lt;dataSource type=&quot;POOLED&quot;&gt;
                &lt;property name=&quot;driver&quot; value=&quot;$&#123;jdbc_driver&#125;&quot;/&gt;
                &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc_url&#125;&quot;/&gt;
                &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc_username&#125;&quot;/&gt;
                &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc_password&#125;&quot;/&gt;
            &lt;/dataSource&gt;
        &lt;/environment&gt;
    &lt;/environments&gt;
    &lt;!--加载映射文件的--&gt;
    &lt;mappers&gt;
        &lt;mapper resource=&quot;com/msb/mapper/DeptMapper.xml&quot;/&gt;
    &lt;/mappers&gt;
&lt;/configuration&gt;
</code></pre>
<h1 id="4-MyBatis传统DAO模式开发"><a href="#4-MyBatis传统DAO模式开发" class="headerlink" title="4 MyBatis传统DAO模式开发"></a>4 MyBatis传统DAO模式开发</h1><blockquote>
<pre><code>普通模式,也称为传统DAO模式,就是在传统DAO模式下,定义接口和实现类,如 interface EmpDao  class EmpDaoImpl implements EmpDao.  在实现类中,用SQLSession对象调用select insert delete update 等方法实现.目前极为少见.在传统模式下,我们需要知道SqlSession对象 实现CURD和 参数传递的处理
</code></pre>
</blockquote>
<h2 id="1-sqlSession查询的三种方式"><a href="#1-sqlSession查询的三种方式" class="headerlink" title="1_sqlSession查询的三种方式"></a>1_sqlSession查询的三种方式</h2><p>SqlSession对象本身的API中就有三个查询方法,分别能够实现如下查询方式</p>
<p>1返回单个对象 selectOne</p>
<p>2返回对象List集合 selectList</p>
<p>3返回对象Map集合 selectMap</p>
<p>接下来我们就对这三个方法进行一个快速的学习</p>
<img data-src="/2022/10/07/ORM/Mybatis/image-20220617194257643.png" class="" title="image-20220617194257643">


<p>创建Emp实体类</p>
<pre><code class="java">@AllArgsConstructor
@NoArgsConstructor
@Data
public class Emp implements Serializable &#123;
    private Integer empno;
    private String ename;
    private String job;
    private Integer mgr;
    private Date hiredate;
    private Double sal;
    private Double comm;
    private Integer deptno;
&#125;
</code></pre>
<p>准备Mapper映射文件</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper
        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;EmpMapper&quot;&gt;
    &lt;!--
    返回单个对象
    public Emp findOne();
    id 相当于方法名
    resultType 相当于返回值类型
        sql语句的查询结果用哪个类来进行封装 如果返回值类型是集合,这里写的也是集合中的元素对应的类,不是集合本身作为类型
    paramaterType 参数类型
    SQL语句就是具体的方法体的实现
    --&gt;
    &lt;select id=&quot;findOne&quot; resultType=&quot;emp&quot; &gt;
        select * from emp where empno = 7499
    &lt;/select&gt;
    &lt;!--
    返回多个对象List集合
    查询全部的员工信息
    public List&lt;Emp&gt; findAll()
    --&gt;
    &lt;select id=&quot;findAll&quot; resultType=&quot;emp&quot;&gt;
        select * from emp
    &lt;/select&gt;
    &lt;!--返回多个对象的Map集合
    把查询出来的数据中的某一列作为键,整条数据封装的对象作为值
    public Map&lt;key,Emp&gt; findEmpMap()
    &lt;empno,Emp&gt;
    &lt;key,Emp&gt;
    --&gt;
    &lt;select id=&quot;findEmpMap&quot; resultType=&quot;map&quot;&gt;
        select * from emp
    &lt;/select&gt;
&lt;/mapper&gt;
</code></pre>
<p>sqlMapConfig中导入EmpMapper映射文件</p>
<pre><code class="xml">&lt;!--加载mapper映射文件--&gt;
&lt;mappers&gt;
    &lt;mapper resource=&quot;com/msb/mapper/DeptMapper.xml&quot;/&gt;
    &lt;mapper resource=&quot;com/msb/mapper/EmpMapper.xml&quot;/&gt;
&lt;/mappers&gt;
</code></pre>
<p>测试代码</p>
<pre><code class="java">package com.msb.test;
import com.msb.pojo.Dept;
import com.msb.pojo.Emp;
import org.apache.ibatis.io.Resources;
import org.apache.ibatis.session.SqlSession;
import org.apache.ibatis.session.SqlSessionFactory;
import org.apache.ibatis.session.SqlSessionFactoryBuilder;
import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import java.io.IOException;
import java.io.InputStream;
import java.util.List;
import java.util.Map;
import java.util.Set;
/**

 * @Author: Ma HaiYang
 * @Description: MircoMessage:Mark_7001
    */
    public class Test2 &#123;
    private SqlSession sqlSession;
    @Before
    public void init()&#123;
        SqlSessionFactoryBuilder ssfb =new SqlSessionFactoryBuilder();
        InputStream resourceAsStream = null;
        try &#123;
            resourceAsStream = Resources.getResourceAsStream(&quot;sqlMapConfig.xml&quot;);
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125;
        SqlSessionFactory factory=ssfb.build(resourceAsStream) ;
        sqlSession=factory.openSession();
    &#125;
    @Test
    public void testSelectOne()&#123;
        // 查询单个对象
        System.out.println(&quot;sqlSession查询单个对象&quot;);
        Emp emp = sqlSession.selectOne(&quot;findOne&quot;);
        System.out.println(emp);
    &#125;
    @Test
    public void testSelectList()&#123;
        // 查询多个对象的List集合
        System.out.println(&quot;sqlSession查询对象List集合&quot;);
        List&lt;Emp&gt; emps = sqlSession.selectList(&quot;EmpMapper.findAll&quot;);
        emps.forEach(System.out::println);
    &#125;
    @Test
    public void testSelectMap()&#123;
        // 查询多个对象的Map集合
        System.out.println(&quot;sqlSession查询对象Map集合&quot;);
        Map&lt;Integer, Emp&gt; empMap = sqlSession.selectMap(&quot;findEmpMap&quot;, &quot;EMPNO&quot;);
        Set&lt;Integer&gt; empnos = empMap.keySet();
        for (Integer empno : empnos) &#123;
            System.out.println(empno+&quot; :&quot; +empMap.get(empno));
        &#125;
    &#125;
    @After
    public void release()&#123;
        // 关闭SQLSession
        sqlSession.close();
    &#125;
&#125;
</code></pre>
<h2 id="2-sqlSession传递参数的三种方式"><a href="#2-sqlSession传递参数的三种方式" class="headerlink" title="2_sqlSession传递参数的三种方式"></a>2_sqlSession传递参数的三种方式</h2><p>1 单个基础数据类型作为参数</p>
<p>2 多个基础数据类型的map 集合作为参数</p>
<p>3 引用类型作为参数</p>
<p>Mapper映射文件</p>
<pre><code class="xml"> &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper
        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;EmpMapper2&quot;&gt;
    &lt;!--
    参数为一个基本数据类型
    根据员工工号查询员工的全部信息,返回单个员工对象
    public Emp findByEmpno(int empno);
    parameterType 在有参数情况下也是可以省略不写  mybatis 可以根据实际情况自动判断
    如果要写parameterType 那么就要写对
    在SQL语句上可以使用$&#123;&#125;  #&#123;&#125; 代表参数的占位
    如果参数是单个基本数据类型,&#123;&#125;中名字可以随便写,见名知意
    $&#123;&#125; 代表mybatis底层使用Statment语句对象,参数是以字符串拼接的形式设置
    #&#123;&#125; 代表mybatis底层使用的preparedStatment语句对象,参数使用?作为占位符处理
    #&#123;&#125; 以后常用
    --&gt;
    &lt;select id=&quot;findByEmpno&quot; resultType=&quot;emp&quot; parameterType=&quot;int&quot;&gt;
        select  * from emp where empno = #&#123;empno&#125;
    &lt;/select&gt;
    &lt;!--
    参数为map集合
    查询指定部门号和指定最低薪资的员工信息
    20 号部门 且工资在1500以上的员工信息
    public List&lt;Emp&gt; findEmpByDeptnoAndSal(int deptno,double sal);
    &lt;  &gt;  最好要进行转译处理,参照HTML转译  w3school在线文档中有转译符号对应规则
     Map&lt;String,Object&gt; args=new HashMap&lt;&gt;();
        args.put(&quot;deptno&quot;, 20);
        args.put(&quot;sal&quot;, 1500.0);
    #&#123;&#125;中写的是map集合中,参数的键
    --&gt;
    &lt;select id=&quot;findEmpByDeptnoAndSal&quot; resultType=&quot;emp&quot; parameterType=&quot;map&quot;&gt;
    &lt;/select&gt;
    &lt;!--
   参数为对象
   emp &gt;&gt;&gt;  deptno   sal
   参数是我们自定义的类型,那么 #&#123;&#125;中写的是参数的属性名
   --&gt;
    &lt;select id=&quot;findEmpByDeptnoAndSal2&quot; resultType=&quot;emp&quot; parameterType=&quot;emp&quot;&gt;
    &lt;/select&gt;
&lt;/mapper&gt;
</code></pre>
<p>测试代码</p>
<pre><code class="java"> package com.msb.test;
import com.msb.pojo.Emp;
import org.apache.ibatis.io.Resources;
import org.apache.ibatis.session.SqlSession;
import org.apache.ibatis.session.SqlSessionFactory;
import org.apache.ibatis.session.SqlSessionFactoryBuilder;
import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import java.io.IOException;
import java.io.InputStream;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
/**

 * @Author: Ma HaiYang
 * @Description: MircoMessage:Mark_7001
    */
    public class Test3 &#123;
    private SqlSession sqlSession;
    @Before
    public void init()&#123;
        SqlSessionFactoryBuilder ssfb =new SqlSessionFactoryBuilder();
        InputStream resourceAsStream = null;
        try &#123;
            resourceAsStream = Resources.getResourceAsStream(&quot;sqlMapConfig.xml&quot;);
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125;
        SqlSessionFactory factory=ssfb.build(resourceAsStream) ;
        sqlSession=factory.openSession();
    &#125;
    @Test
    public void testSingleArg()&#123;
        // 测试单个基本数据类型作为参数
        Emp emp = sqlSession.selectOne(&quot;findByEmpno&quot;, 7499);
        System.out.println(emp);
    &#125;
    @Test
    public void testMapArg()&#123;
        // 测试Map集合作为参数
        Map&lt;String,Object&gt; args=new HashMap&lt;&gt;();
        args.put(&quot;deptno&quot;, 20);
        args.put(&quot;sal&quot;, 3000.0);
        List&lt;Emp&gt; emps = sqlSession.selectList(&quot;findEmpByDeptnoAndSal&quot;, args);
        emps.forEach(System.out::println);
    &#125;
    @Test
    public void testEmpArg()&#123;
        // 测试Map集合作为参数
        Emp arg =new Emp();
        arg.setDeptno(10);
        arg.setSal(2000.0);
        List&lt;Emp&gt; emps = sqlSession.selectList(&quot;findEmpByDeptnoAndSal2&quot;, arg);
        emps.forEach(System.out::println);
    &#125;
    @After
    public void release()&#123;
        // 关闭SQLSession
        sqlSession.close();
    &#125;
&#125;
</code></pre>
<h2 id="3-sqlSession完成DML所有操作"><a href="#3-sqlSession完成DML所有操作" class="headerlink" title="3_sqlSession完成DML所有操作"></a>3_sqlSession完成DML所有操作</h2><p>Mapper映射文件</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper
        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;EmpMapper3&quot;&gt;
    &lt;!--
    增删方法的返回值类型都是int
    resultType就无需指定了
    insert update delete 标签中没有resultType
    但是仍然可以有paramaterType
    --&gt;
    &lt;!-- 增加方法
    public int addEmp(Emp emp);
    --&gt;
    &lt;insert id=&quot;addEmp&quot; parameterType=&quot;emp&quot;&gt;
    &lt;/insert&gt;
    &lt;!--修改
    根据工号修改员工姓名
    public int updateEmp(Emp emp);
    --&gt;
    &lt;update id=&quot;updateEmp&quot; parameterType=&quot;emp&quot;&gt;
    &lt;/update&gt;
    &lt;!-- 删除
    删除大于给定工号的员工信息
    public int deleteEmp(int empno)
    --&gt;
    &lt;delete id=&quot;deleteEmp&quot; parameterType=&quot;int&quot;&gt;
        delete from emp where empno &gt;= #&#123;empno&#125;
    &lt;/delete&gt;
&lt;/mapper&gt;
</code></pre>
<p>测试代码</p>
<pre><code class="java">package com.msb.test;
import com.msb.pojo.Emp;
import org.apache.ibatis.io.Resources;
import org.apache.ibatis.session.SqlSession;
import org.apache.ibatis.session.SqlSessionFactory;
import org.apache.ibatis.session.SqlSessionFactoryBuilder;
import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import java.io.IOException;
import java.io.InputStream;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
/**
 * @Author: Ma HaiYang
 * @Description: MircoMessage:Mark_7001
 */
public class Test4 &#123;
    private SqlSession sqlSession;
    @Before
    public void init()&#123;
        SqlSessionFactoryBuilder ssfb =new SqlSessionFactoryBuilder();
        InputStream resourceAsStream = null;
        try &#123;
            resourceAsStream = Resources.getResourceAsStream(&quot;sqlMapConfig.xml&quot;);
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125;
        SqlSessionFactory factory=ssfb.build(resourceAsStream) ;
        sqlSession=factory.openSession(true);
    &#125;
    @Test
    public void testInsert()&#123;
        Emp emp =new Emp(null,&quot;按住啦Baby&quot;,&quot;SALESMAN&quot;,7839,new Date(),3100.0, 200.0,10 );
        int rows = sqlSession.insert(&quot;addEmp&quot;, emp);
        System.out.println(rows);
        // 手动提交事务
        //sqlSession.commit();
        /*增删改 要提交事务
        * sqlSession.commit();手动提交事务
        * sqlSession=factory.openSession(true); 设置事务自动提交
        * */
    &#125;
    @Test
    public void testUpdate()&#123;
        Emp emp =new Emp( );
        emp.setEname(&quot;晓明&quot;);
        emp.setEmpno(7937);
        int rows = sqlSession.update(&quot;updateEmp&quot;, emp);
        System.out.println(rows);
    &#125;
    @Test
    public void testDelete()&#123;
        int rows = sqlSession.delete(&quot;deleteEmp&quot;, 7936);
        System.out.println(rows);
    &#125;
    @After
    public void release()&#123;
        // 关闭SQLSession
        sqlSession.close();
    &#125;
&#125;
</code></pre>
<h1 id="5-MyBatis代理模式开发"><a href="#5-MyBatis代理模式开发" class="headerlink" title="5 MyBatis代理模式开发"></a>5 MyBatis代理模式开发</h1><p>前面已经使用MyBatis完成了对Emp表的CRUD操作，都是由SqlSession调用自身方法发送SQL命令并得到结果的，实现了MyBatis的入门。</p>
<p>但是却存在如下缺点：</p>
<ol>
<li><p>不管是selectList()、selectOne()、selectMap()，都是通过SQLSession对象的API完成增删改查,都只能提供一个查询参数。如果要多个参数，需要封装到JavaBean或者Map中，并不一定永远是一个好办法。</p>
</li>
<li><p>返回值类型较固定。</p>
</li>
<li><p>只提供了映射文件，没有提供数据库操作的接口，不利于后期的维护扩展。</p>
</li>
</ol>
<p>在MyBatis中提供了另外一种成为<strong>Mapper代理（或称为接口绑定）</strong>的操作方式。在实际开发中也使用该方式。下面我们就是要Mapper代理的方式来实现对Emp表的CRUD操作吧，还有完成多个参数传递、模糊查询、自增主键回填等更多的技能实现。搭建好的项目框架如图所示，相比而言，增加了接口EmployeeMapper。但是却会引起映射文件和测试类的变化。</p>
<p>优点:</p>
<p>1有接口 模块之间有规范了</p>
<p>2参数的处理多样了,接口中的方法参数列表由我们自己决定</p>
<p>3通过代理模式由mybatis提供接口的实现类对象 我们不用写实现类了</p>
<p>项目结构:注意文件路径和文件位置!!!</p>
<img data-src="/2022/10/07/ORM/Mybatis/image-20220617195010768.png" class="" title="image-20220617195010768">


<p>准备接口和mapper映射文件</p>
<p>EmpMapper接口</p>
<pre><code class="java">package com.msb.mapper;
import com.msb.pojo.Emp;
import java.util.List;
/**

 * @Author: Ma HaiYang
 * @Description: MircoMessage:Mark_7001
    */
public interface EmpMapper &#123;
    /**
     * 该方法用于查询全部的员工信息
     * @return 全部员工信息封装的Emp对象的List集合
        */
    List&lt;Emp&gt; findAll();
 &#125;
</code></pre>
<p>EmpMapper.xml映射文件</p>
<pre><code class="xml"> &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper
        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;com.msb.mapper.EmpMapper&quot;&gt;
    &lt;!--
    1 接口的名字和Mapper映射为文件名字必须保持一致(不包含拓展名)
    2 Mapper映射文件的namespace必须是接口的全路径名
    3 sql语句的id必须是对应方法的名
    4 DeptMapper映射文件应该和接口编译之后放在同一个目录下
    --&gt;
    &lt;!--List&lt;Emp&gt; findAll();--&gt;
    &lt;select id=&quot;findAll&quot; resultType=&quot;emp&quot; &gt;
        select * from emp
    &lt;/select&gt;
&lt;/mapper&gt;
</code></pre>
<p>在sqlMapConfig.xml核心配置文件中使用包扫描形式加载所有的映射文件</p>
<pre><code class="xml"> &lt;!--加载mapper映射文件--&gt;
&lt;mappers&gt;
    &lt;!--通过类的全路径去找mapper映射文件--&gt;
    &lt;mapper class=&quot;com.msb.mapper.EmpMapper&quot;/&gt;
&lt;/mappers&gt;
</code></pre>
<p> 测试代码</p>
<pre><code class="java">package com.msb.test;
import com.msb.mapper.EmpMapper;
import com.msb.pojo.Dept;
import com.msb.pojo.Emp;
import org.apache.ibatis.io.Resources;
import org.apache.ibatis.session.SqlSession;
import org.apache.ibatis.session.SqlSessionFactory;
import org.apache.ibatis.session.SqlSessionFactoryBuilder;
import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import java.io.IOException;
import java.io.InputStream;
import java.util.List;
/**

 * @Author: Ma HaiYang
 * @Description: MircoMessage:Mark_7001
    */
    public class Test1 &#123;
    private SqlSession sqlSession;
    @Before
    public void init()&#123;
        SqlSessionFactoryBuilder ssfb =new SqlSessionFactoryBuilder();
        InputStream resourceAsStream = null;
        try &#123;
            resourceAsStream = Resources.getResourceAsStream(&quot;sqlMapConfig.xml&quot;);
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125;
        SqlSessionFactory factory=ssfb.build(resourceAsStream) ;
        sqlSession=factory.openSession();
    &#125;
    @Test
    public void testFindAll()&#123;
        EmpMapper empMapper=sqlSession.getMapper(EmpMapper.class);
        List&lt;Emp&gt; emps = empMapper.findAll();
        emps.forEach(System.out::println);
    &#125;
    @After
    public void release()&#123;
        // 关闭SQLSession
        sqlSession.close();
    &#125;
&#125;
</code></pre>
<p><strong>代理模式浅析</strong></p>
<p>mybatis是如何通过代理模式实现查询的</p>
<p>这条语句的底层使用了动态代理模式，动态创建一个EmployeeMapper的一个代理对象并赋给接口引用。所以在MyBatis中不需要显式提供Mapper接口的实现类，这也是简单的地方。</p>
<h1 id="6-代理模式下开发各种功能"><a href="#6-代理模式下开发各种功能" class="headerlink" title="6 代理模式下开发各种功能"></a>6 代理模式下开发各种功能</h1><h2 id="1-多种参数传递问题"><a href="#1-多种参数传递问题" class="headerlink" title="1_多种参数传递问题"></a>1_多种参数传递问题</h2><blockquote>
<p>1单个基本数据类型</p>
<p>2多个基本数据类型</p>
<p>3单个引用数据类型</p>
<p>4map集合数据类型</p>
<p>5多个引用数据类型</p>
</blockquote>
<p>接口</p>
<pre><code class="java">package com.msb.mapper;
import com.msb.pojo.Emp;
import org.apache.ibatis.annotations.Param;
import java.util.List;
import java.util.Map;
/**
 * @Author: Ma HaiYang
 * @Description: MircoMessage:Mark_7001
 */
public interface EmpMapper &#123;
    /**
     * 该方法用于查询全部的员工信息
     * @return 全部员工信息封装的Emp对象的List集合
     */
    List&lt;Emp&gt; findAll();
    /**
     * 根据员工编号查询单个员工信息的方法
     * @param empno 员工编号
     * @return 如果找到了返回Emp对象,找不到返回null
     */
    Emp findByEmpno(int empno);
    /**
     * 根据员工编号和薪资下限去查询员工信息
     * @param empno 员工编号
     * @param sal 薪资下限
     * @return 多个Emp对象的List集合
     */
    List&lt;Emp&gt; findByDeptnoAndSal(@Param(&quot;deptno&quot;) int deptno,@Param(&quot;sal&quot;) double sal);
    List&lt;Emp&gt; findByDeptnoAndSal2(Map&lt;String,Object&gt; map);
    List&lt;Emp&gt; findByDeptnoAndSal3(Emp emp);
    List&lt;Emp&gt; findByDeptnoAndSal4(@Param(&quot;empa&quot;) Emp empa,@Param(&quot;empb&quot;) Emp empb);
&#125;
</code></pre>
<p>mapper映射文件</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper
        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;com.msb.mapper.EmpMapper&quot;&gt;
    &lt;!--
    1 接口的名字和Mapper映射为文件名字必须保持一致(不包含拓展名)
    2 Mapper映射文件的namespace必须是接口的全路径名
    3 sql语句的id必须是对应方法的名
    4 DeptMapper映射文件应该和接口编译之后放在同一个目录下
    --&gt;
    &lt;!--List&lt;Emp&gt; findAll();--&gt;
    &lt;select id=&quot;findAll&quot; resultType=&quot;emp&quot; &gt;
        select * from emp
    &lt;/select&gt;
    &lt;!--
    单个基本数据类型作为方法参数
    #&#123;&#125;中可以随便写,遵循见名知意
    Emp findByEmpno(int empno);
    --&gt;
    &lt;select id=&quot;findByEmpno&quot; resultType=&quot;emp&quot; &gt;
        select * from emp where empno =#&#123;empno&#125;
    &lt;/select&gt;
    &lt;!--
     多个基本数据类型作为方法参数
     List&lt;Emp&gt; findByDeptnoAndSal(@Param(&quot;detpno&quot;) int deptno,@Param(&quot;sal&quot;) double sal);
     方式1 arg*     arg0 arg1 arg2 数字是索引,从0开始
     方式2 param*   param1 param2 param3 数字是编号,从1开始
     使用别名
     List&lt;Emp&gt; findByDeptnoAndSal(@Param(&quot;detpno&quot;) int deptno,@Param(&quot;sal&quot;) double sal);
     通过@Param注解使用别名之后,就不能再使用arg* 但是可以继续使用param*
    --&gt;
    &lt;select id=&quot;findByDeptnoAndSal&quot; resultType=&quot;emp&quot;&gt;
    &lt;/select&gt;
    &lt;!--
    参数是map,&#123;&#125;写键的名字
    --&gt;
    &lt;select id=&quot;findByDeptnoAndSal2&quot; resultType=&quot;emp&quot; parameterType=&quot;map&quot; &gt;
    &lt;/select&gt;
    &lt;!--单个引用类型,&#123;&#125;中写的使用对象的属性名--&gt;
    &lt;select id=&quot;findByDeptnoAndSal3&quot; resultType=&quot;emp&quot; parameterType=&quot;emp&quot; &gt;
    &lt;/select&gt;
    &lt;!--
    多个引用类型作为方法参数
     List&lt;Emp&gt; findByDeptnoAndSal4(@Param(&quot;empa&quot;) Emp empa,@Param(&quot;empb&quot;) Emp empb);
     如果用@Param定义了别名,那么就不能使用arg*.属性名,但是可以使用param*.属性名和别名.属性名
    --&gt;
    &lt;select id=&quot;findByDeptnoAndSal4&quot; resultType=&quot;emp&quot;  &gt;
    &lt;/select&gt;
&lt;/mapper&gt;
</code></pre>
<p>测试 代码</p>
<pre><code class="java">package com.msb.testDemo;
import com.msb.mapper.EmpMapper;
import com.msb.pojo.Emp;
import com.msb.util.SqlSessionUtil;
import org.apache.ibatis.session.SqlSession;
import java.util.List;
public class Test1 &#123;
    public static void main(String[] args) &#123;
        SqlSession sqlSession = SqlSessionUtil.getSqlSession(true);
        /*
        * 帮助我们生成一个接口下的实现类对象的
        *
        * */
        EmpMapper mapper = sqlSession.getMapper(EmpMapper.class);
        List&lt;Emp&gt; emps = mapper.getAllEmp();
        for(Emp emp:emps) &#123;
            System.out.println(emp);
        &#125;
        // 1单个基本数据类型作为方法参数
        Emp emp = mapper.getByEmpno(7902);
        System.out.println(emp);
        // 2多个基本数据类型作为方法参数
        List&lt;Emp&gt; emps2 = mapper.getByDeptnoAndSal(10, 1500);
        for(Emp em:emps2) &#123;
            System.out.println(em);
        &#125;
        // 3单个引用类型作为方法参数
        Emp condition=new Emp();
        condition.setDeptno(10);
        condition.setSal(1500.0);
        List&lt;Emp&gt; emps3 = mapper.getByDeptnoAndSal2(condition);
        for(Emp em:emps3) &#123;
            System.out.println(em);
        &#125;
        // 4多个引用类型作为方法参数
        Emp condition1=new Emp();
        condition1.setDeptno(10);
        Emp condition2=new Emp();
        condition2.setSal(1500.0);
        List&lt;Emp&gt; emps4 = mapper.getByDeptnoAndSal3(condition1,condition2);
        for(Emp em:emps4) &#123;
            System.out.println(em);
        &#125;
        sqlSession.close();
    &#125;
&#125;
</code></pre>
<h2 id="2-模糊查询功能"><a href="#2-模糊查询功能" class="headerlink" title="2 模糊查询功能"></a>2 模糊查询功能</h2><pre><code>在进行模糊查询时，在映射文件中可以使用concat()函数来连接参数和通配符。另外注意对于特殊字符，比如&lt;，不能直接书写，应该使用字符实体替换。
</code></pre>
<p>接口</p>
<pre><code class="java">/**
 * 根据名字做模糊查询
 * @param name 模糊查询的文字
 * @return  Emp对象List集合
 */
List&lt;Emp&gt; findByEname( String name);
</code></pre>
<p>mapper映射文件</p>
<pre><code class="xml">&lt;!--List&lt;Emp&gt; getByName(String name);--&gt;
&lt;select id=&quot;findByEname&quot;  resultType=&quot;emp&quot; &gt;
    select * from emp where ename like concat(&#39;%&#39;,#&#123;name&#125;,&#39;%&#39;)
&lt;/select&gt;
</code></pre>
<h2 id="3-主键自增回填"><a href="#3-主键自增回填" class="headerlink" title="3_主键自增回填"></a>3_主键自增回填</h2><pre><code>MySQL支持主键自增。有时候完成添加后需要立刻获取刚刚自增的主键，由下一个操作来使用。比如结算构造车后，主订单的主键确定后，需要作为后续订单明细项的外键存在。如何拿到主键呢，MyBatis提供了支持，可以非常简单的获取。
</code></pre>
<p>接口</p>
<pre><code class="java">public interface DeptMapper &#123;
    int addDept(Dept dept);
    int addDept2(Dept dept);
&#125;
</code></pre>
<p>mapper映射文件</p>
<pre><code class="xml">&lt;mapper namespace=&quot;com.msb.mapper.DeptMapper&quot;&gt;
   &lt;!-- int addDept(Dept dept);
   useGeneratedKeys=&quot;true&quot; 返回数据库帮我们生成的主键
   keyProperty=&quot;deptno&quot; 生成的主键值用我们dept对象那个属性存储
   --&gt;
    &lt;insert id=&quot;addDept&quot; parameterType=&quot;dept&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;deptno&quot;&gt;
    &lt;/insert&gt;
    &lt;insert id=&quot;addDept2&quot; parameterType=&quot;dept&quot;&gt;
        &lt;selectKey order=&quot;AFTER&quot; keyProperty=&quot;deptno&quot;  resultType=&quot;int&quot;&gt;
            select @@identity
        &lt;/selectKey&gt;
    &lt;/insert&gt;
&lt;/mapper&gt;
</code></pre>
<p>测试代码</p>
<pre><code class="java">SqlSession sqlSession = SqlSessionUtil.getSqlSession(true);
DeptMapper mapper = sqlSession.getMapper(DeptMapper.class);
Dept dept =new Dept(null,&quot;AI学院&quot;,&quot;北京&quot;);
int i = mapper.addDept2(dept);
System.out.println(i);
System.out.println(dept.getDeptno());
sqlSession.close();
</code></pre>
<p>方式1</p>
<p>useGeneratedKeys：表示要使用自增的主键</p>
<p>keyProperty：表示把自增的主键赋给JavaBean的哪个成员变量。</p>
<p>以添加Dept对象为例，添加前Dept对象的deptno是空的，添加完毕后可以通过getDeptno() 获取自增的主键。</p>
<p>方式2</p>
<p>order：取值AFTER|BEFORE，表示在新增之后|之前执行<selectKey>中的SQL命令</p>
<p>keyProperty：执行select @@identity后结果填充到哪个属性中</p>
<p>resultType：结果类型。</p>
<p><strong>技术扩展</strong><br>在很多应用场景中需要新增数据后获取到新增数据的主键值，针对这样的需求一般由三种解决方式：</p>
<ul>
<li>主键自定义，用户通过UUID或时间戳等方式生成唯一主键，把这个值当做主键值。在分布式场景中应用较多。</li>
<li>查询后通过select max(主键) from 表获取主键最大值。这种方式在多线程访问情况下可能出现问题。</li>
<li>查询后通过select @@identity获取最新生成主键。要求这条SQL必须在insert操作之后，且数据库连接没有关闭。</li>
</ul>
<h2 id="4-实现DML操作"><a href="#4-实现DML操作" class="headerlink" title="4_实现DML操作"></a>4_实现DML操作</h2><p>EmpMapper接口</p>
<pre><code class="java">/**
 * 增加员工信息
 * @param emp 存储新增员工信息的Emp对象
 * @return 对数据库数据产生影响的行数
 */
int addEmp(Emp emp);
/**
 * 根据员工编号修改员工姓名的方法
 * @param empno 要修改的员工编号
 * @param ename 修改之后的新的员工名字
 * @return 对数据库数据产生影响的行数
 */
int updateEnameByEmpno(@Param(&quot;empno&quot;) int empno,@Param(&quot;ename&quot;) String ename);
/**
 * 根据员工编号删除员工信息
 * @param empno 要删除的员工编号
 * @return 对数据库数据产生影响的行数
 */
int deleteByEmpno(int empno);
</code></pre>
<p>EmpMapper映射 文件</p>
<pre><code class="xml">&lt;!--int addEmp(Emp emp);--&gt;
&lt;insert id=&quot;addEmp&quot; &gt;
&lt;/insert&gt;
&lt;!--int updateEnameByEmpno(@Param(&quot;empno&quot;) int empno,@Param(&quot;ename&quot;) String ename);--&gt;
&lt;update id=&quot;updateEnameByEmpno&quot; &gt;
&lt;/update&gt;
&lt;!--int deleteByEmpno(int empno);--&gt;
&lt;update id=&quot;deleteByEmpno&quot; &gt;
    delete from emp where empno =#&#123;empno&#125;
&lt;/update&gt;
</code></pre>
<p>测试代码</p>
<pre><code class="java">package com.msb.test;
import com.msb.mapper.DeptMapper;
import com.msb.mapper.EmpMapper;
import com.msb.pojo.Dept;
import com.msb.pojo.Emp;
import org.apache.ibatis.io.Resources;
import org.apache.ibatis.session.SqlSession;
import org.apache.ibatis.session.SqlSessionFactory;
import org.apache.ibatis.session.SqlSessionFactoryBuilder;
import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import java.io.IOException;
import java.io.InputStream;
import java.util.Date;
/**
 * @Author: Ma HaiYang
 * @Description: MircoMessage:Mark_7001
 */
public class Test3 &#123;
    private SqlSession sqlSession;
    @Before
    public void init()&#123;
        SqlSessionFactoryBuilder ssfb =new SqlSessionFactoryBuilder();
        InputStream resourceAsStream = null;
        try &#123;
            resourceAsStream = Resources.getResourceAsStream(&quot;sqlMapConfig.xml&quot;);
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125;
        SqlSessionFactory factory=ssfb.build(resourceAsStream) ;
        sqlSession=factory.openSession();
    &#125;
    @Test
    public void testAddEmp()&#123;
        EmpMapper mapper = sqlSession.getMapper(EmpMapper.class);
        mapper.addEmp(new Emp(null, &quot;TOM&quot;, &quot;SALESMAN&quot;, 7521, new Date(), 2314.0, 100.0, 10));
        sqlSession.commit();
    &#125;
    @Test
    public void testUpdateEnameByEmpno()&#123;
        EmpMapper mapper = sqlSession.getMapper(EmpMapper.class);
        mapper.updateEnameByEmpno(7938, &quot;TOM&quot;);
        sqlSession.commit();
    &#125;
    @Test
    public void testDeletByEmpno()&#123;
        EmpMapper mapper = sqlSession.getMapper(EmpMapper.class);
        mapper.deleteByEmpno(7938);
        sqlSession.commit();
    &#125;
    @After
    public void release()&#123;
        // 关闭SQLSession
        sqlSession.close();
    &#125;
&#125;
</code></pre>
<h1 id="7-动态SQL"><a href="#7-动态SQL" class="headerlink" title="7 动态SQL"></a>7 动态SQL</h1><pre><code>经常遇到很多按照很多查询条件进行查询的情况，比如京东根据不同的条件筛选商品。其中经常出现很多条件不取值的情况，在后台应该如何完成最终的SQL语句呢？









如果采用JDBC进行处理，需要根据条件是否取值进行SQL语句的拼接，一般情况下是使用StringBuilder类及其append方法实现，还是有些繁琐的。如果你有使用 JDBC 或其它类似框架的经验，你就能体会到根据不同条件拼接 SQL语句的痛苦。例如拼接时要确保不能忘记添加必要的空格，还要注意去掉列表最后一个列名的逗号。利用动态 SQL 这一特性可以彻底摆脱这种痛苦。

MyBatis在简化操作方法提出了动态SQL功能，将使用Java代码拼接SQL语句，改变为在XML映射文件中截止标签拼接SQL语句。相比而言，大大减少了代码量，更灵活、高度可配置、利于后期维护。

MyBatis中动态SQL是编写在mapper.xml中的，其语法和JSTL类似，但是却是基于强大的OGNL表达式实现的。

MyBatis也可以在注解中配置SQL，但是由于注解功能受限，尤其是对于复杂的SQL语句，可读性很差，所以较少使用。
</code></pre>
<h2 id="1-if标签"><a href="#1-if标签" class="headerlink" title="1_if标签"></a>1_if标签</h2><p>接口</p>
<pre><code class="java">public interface EmpMapper2 &#123;
  List&lt;Emp&gt; findByCondition(Emp emp);
&#125;
</code></pre>
<p>映射文件</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper
        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;com.msb.mapper.EmpMapper2&quot;&gt;
&lt;!--List&lt;Emp&gt; findByCondition(Emp emp);--&gt;
    &lt;select id=&quot;findByCondition&quot; resultType=&quot;emp&quot;&gt;
        select * from emp where 1=1
        &lt;if test=&quot;empno != null&quot;&gt;
            and empno =#&#123;empno&#125;
        &lt;/if&gt;
        &lt;if test=&quot;ename != null and ename != &#39;&#39;&quot;&gt;
            and ename like concat(&#39;%&#39;,#&#123;ename&#125;,&#39;%&#39;)
        &lt;/if&gt;
        &lt;if test=&quot;job != null and job != &#39;&#39;&quot;&gt;
            and job =#&#123;job&#125;
        &lt;/if&gt;
        &lt;if test=&quot;mgr != null&quot;&gt;
            and mgr =#&#123;mgr&#125;
        &lt;/if&gt;
        &lt;if test=&quot;hiredate != null&quot;&gt;
            and hiredate =#&#123;hiredate&#125;
        &lt;/if&gt;
        &lt;if test=&quot;sal != null&quot;&gt;
            and sal =#&#123;sal&#125;
        &lt;/if&gt;
        &lt;if test=&quot;comm != null&quot;&gt;
            and comm =#&#123;comm&#125;
        &lt;/if&gt;
        &lt;if test=&quot;deptno != null&quot;&gt;
            and deptno =#&#123;deptno&#125;
        &lt;/if&gt;
    &lt;/select&gt;
&lt;/mapper&gt;
</code></pre>
<p>测试代码</p>
<pre><code class="java">public static void main(String[] args) &#123;
    SqlSession sqlSession = MyBatisUtil.getSqlSession(false);
    EmpMapper2 mapper = sqlSession.getMapper(EmpMapper2.class);
    Emp condition =new Emp();
   /* condition.setDeptno(20);*/
   /* condition.setSal(3000.0);*/
   /*condition.setHiredate(new java.sql.Date(81,1,22));*/
   condition.setComm(0.0);
   condition.setDeptno(20);
    List&lt;Emp&gt; emps = mapper.findEmpByCondition(condition);
    for (Emp e:emps
         ) &#123;
        System.out.println(e);
    &#125;
&#125;
</code></pre>
<h2 id="2-where标签"><a href="#2-where标签" class="headerlink" title="2_where标签"></a>2_where标签</h2><blockquote>
<p>用于处理where关键字和and</p>
<p>默认删除第一个and逻辑连接符</p>
</blockquote>
<pre><code class="xml">&lt;select id=&quot;findEmpByCondition&quot; resultType=&quot;emp&quot;&gt;
    select * from emp
    &lt;where&gt;
        &lt;if test=&quot;empno != null&quot;&gt;
            and empno= #&#123;empno&#125;
        &lt;/if&gt;
        &lt;if test=&quot;ename != null and ename != &#39;&#39;&quot;&gt;
            and ename= #&#123;ename&#125;
        &lt;/if&gt;
        &lt;if test=&quot;job != null and job != &#39;&#39;&quot;&gt;
            and job= #&#123;job&#125;
        &lt;/if&gt;
        &lt;if test=&quot;mgr != null &quot;&gt;
            and mgr= #&#123;mgr&#125;
        &lt;/if&gt;
        &lt;if test=&quot;hiredate != null &quot;&gt;
            and hiredate= #&#123;hiredate&#125;
        &lt;/if&gt;
        &lt;if test=&quot;sal != null&quot;&gt;
            and sal= #&#123;sal&#125;
        &lt;/if&gt;
        &lt;if test=&quot;comm != null &quot;&gt;
             and comm =#&#123;comm&#125;
        &lt;/if&gt;
        &lt;if test=&quot;deptno != null &quot;&gt;
            and deptno= #&#123;deptno&#125;
        &lt;/if&gt;
    &lt;/where&gt;
&lt;/select&gt;
</code></pre>
<h2 id="3-choose标签"><a href="#3-choose标签" class="headerlink" title="3_choose标签"></a>3_choose标签</h2><p>前面的when条件成立 后面的 when就不再判断了</p>
<pre><code class="xml"> &lt;select id=&quot;findEmpByCondition2&quot; resultType=&quot;emp&quot;&gt;
    select * from emp
    &lt;where&gt;
        &lt;choose&gt;
            &lt;when test=&quot;empno != null&quot;&gt;
                and empno= #&#123;empno&#125;
            &lt;/when&gt;
            &lt;when test=&quot;ename != null and ename != &#39;&#39;&quot;&gt;
                and ename= #&#123;ename&#125;
            &lt;/when&gt;
            &lt;when test=&quot;job != null and job != &#39;&#39;&quot;&gt;
                and job= #&#123;job&#125;
            &lt;/when&gt;
            &lt;when test=&quot;mgr != null &quot;&gt;
                and mgr= #&#123;mgr&#125;
            &lt;/when&gt;
            &lt;when test=&quot;hiredate != null &quot;&gt;
                and hiredate= #&#123;hiredate&#125;
            &lt;/when&gt;
            &lt;when test=&quot;sal != null&quot;&gt;
                and sal= #&#123;sal&#125;
            &lt;/when&gt;
            &lt;when test=&quot;comm != null &quot;&gt;
                and comm =#&#123;comm&#125;
            &lt;/when&gt;
            &lt;when test=&quot;deptno != null &quot;&gt;
                and deptno= #&#123;deptno&#125;
            &lt;/when&gt;
        &lt;/choose&gt;
    &lt;/where&gt;
&lt;/select&gt;
</code></pre>
<h2 id="4-set标签"><a href="#4-set标签" class="headerlink" title="4_set标签"></a>4_set标签</h2><p>接口</p>
<pre><code class="java"> int updateEmpByCondtion(Emp emp);
</code></pre>
<p>映射文件</p>
<pre><code class="xml"> &lt;!--int updateEmpByCondtion(Emp emp);--&gt;
&lt;update id=&quot;updateEmpByCondtion&quot; &gt;
    update emp
    &lt;set&gt;
        &lt;if test=&quot;ename != null and ename != &#39;&#39; &quot;&gt;
            , ename =#&#123;ename&#125;
        &lt;/if&gt;
        &lt;if test=&quot;job != null and ename != &#39;&#39; &quot;&gt;
            , job =#&#123;job&#125;
        &lt;/if&gt;
        &lt;if test=&quot;mgr != null &quot;&gt;
            , mgr =#&#123;mgr&#125;
        &lt;/if&gt;
        &lt;if test=&quot;hiredate != null &quot;&gt;
            , hiredate =#&#123;hiredate&#125;
        &lt;/if&gt;
        &lt;if test=&quot;sal != null &quot;&gt;
            , sal =#&#123;sal&#125;
        &lt;/if&gt;
        &lt;if test=&quot;comm != null &quot;&gt;
            , comm =#&#123;comm&#125;
        &lt;/if&gt;
        &lt;if test=&quot;deptno != null &quot;&gt;
            , deptno =#&#123;deptno&#125;
        &lt;/if&gt;
    &lt;/set&gt;
    where empno =#&#123;empno&#125;
&lt;/update&gt;
</code></pre>
<h2 id="5-trim标签"><a href="#5-trim标签" class="headerlink" title="5_trim标签"></a>5_trim标签</h2><blockquote>
<p>Trim 标签处理 set  ，可以为他包裹起来的SQL语句前后 增加&#x2F;删除 关键词&#x2F;固定字符</p>
</blockquote>
<pre><code class="xml">&lt;update id=&quot;updateEmpByCondition2&quot; &gt;
    update emp
    &lt;!--prefix 要增加什么前缀
    prefixOverrides 要去除什么前缀
    suffix 要增加什么后缀
    suffixOverrides 要去除什么后缀
    set 是trim的一种特殊情况
    --&gt;
    &lt;trim prefix=&quot;set&quot;  suffixOverrides=&quot;,&quot; &gt;
        &lt;if test=&quot;ename != null and ename != &#39;&#39;&quot;&gt;
            ename= #&#123;ename&#125;,
        &lt;/if&gt;
        &lt;if test=&quot;job != null and job != &#39;&#39;&quot;&gt;
            job= #&#123;job&#125;,
        &lt;/if&gt;
        &lt;if test=&quot;mgr != null &quot;&gt;
            mgr= #&#123;mgr&#125;,
        &lt;/if&gt;
        &lt;if test=&quot;hiredate != null &quot;&gt;
            hiredate= #&#123;hiredate&#125;,
        &lt;/if&gt;
        &lt;if test=&quot;sal != null&quot;&gt;
            sal= #&#123;sal&#125;,
        &lt;/if&gt;
        &lt;if test=&quot;comm != null &quot;&gt;
            comm =#&#123;comm&#125;,
        &lt;/if&gt;
        &lt;if test=&quot;deptno != null &quot;&gt;
            deptno= #&#123;deptno&#125;,
        &lt;/if&gt;
    &lt;/trim&gt;
    where  empno = #&#123;empno&#125;
&lt;/update&gt;
</code></pre>
<p>Trim标签  处理where</p>
<pre><code class="xml">    &lt;select id=&quot;findByCondition&quot; resultMap=&quot;EmpMap&quot;&gt;
        select * from emp 
        &lt;trim prefix=&quot;where&quot; prefixOverrides=&quot;and&quot;&gt;
            &lt;if test=&quot;empno != null&quot;&gt;
                and empno =#&#123;empno&#125;
            &lt;/if&gt;
            &lt;if test=&quot;ename != null and ename != &#39;&#39;&quot;&gt;
                &lt;bind name=&quot;likePattern&quot; value=&quot;&#39;%&#39;+ename+&#39;%&#39;&quot;/&gt;
                and ename like #&#123;likePattern&#125;
            &lt;/if&gt;
            &lt;if test=&quot;job != null and job != &#39;&#39;&quot;&gt;
                and job =#&#123;job&#125;
            &lt;/if&gt;
            &lt;if test=&quot;mgr != null&quot;&gt;
                and mgr =#&#123;mgr&#125;
            &lt;/if&gt;
            &lt;if test=&quot;hiredate != null&quot;&gt;
                and hiredate =#&#123;hiredate&#125;
            &lt;/if&gt;
            &lt;if test=&quot;sal != null&quot;&gt;
                and sal =#&#123;sal&#125;
            &lt;/if&gt;
            &lt;if test=&quot;comm != null&quot;&gt;
                and comm =#&#123;comm&#125;
            &lt;/if&gt;
            &lt;if test=&quot;deptno != null&quot;&gt;
                and deptno =#&#123;deptno&#125;
            &lt;/if&gt;
        &lt;/trim&gt;
    &lt;/select&gt;
</code></pre>
<h2 id="6-bind标签"><a href="#6-bind标签" class="headerlink" title="6_bind标签"></a>6_bind标签</h2><p>一般用于处理模糊查询的模板</p>
<p>接口</p>
<img data-src="/2022/10/07/ORM/Mybatis/image-20220617200421440.png" class="" title="image-20220617200421440">


<p>SQL语句</p>
<pre><code class="xml">&lt;!-- bind 写一个局部SQL模板，模糊 like 常用--&gt;
    &lt;select id=&quot;findEmpByEname&quot; resultMap=&quot;EmpMap&quot;&gt;
        &lt;bind name=&quot;likePatten&quot; value=&quot;&#39;%&#39;+param1+&#39;%&#39;&quot;/&gt;
        select * from emp where ename like #&#123;likePatten&#125;;
    &lt;/select&gt;
</code></pre>
<h2 id="7-nclude"><a href="#7-nclude" class="headerlink" title="7_nclude"></a>7_nclude</h2><p>引用提前写好的 SQL 标签的SQL语句</p>
<pre><code class="xml">    &lt;sql id=&quot;empColumn&quot;&gt;empno,ename,job,mgr,hiredate,sal,comm,deptno&lt;/sql&gt;
    &lt;sql id=&quot;baseSelect&quot;&gt;
        select &lt;include refid=&quot;empColumn&quot;&gt;&lt;/include&gt; from emp
    &lt;/sql&gt;
</code></pre>
<h2 id="8-sql标签"><a href="#8-sql标签" class="headerlink" title="8_sql标签"></a>8_sql标签</h2><pre><code class="xml"> &lt;sql id=&quot;empColumn&quot;&gt;empno,ename,job,mgr,hiredate,sal,comm,deptno&lt;/sql&gt;
&lt;sql id=&quot;baseSelect&quot;&gt;select &lt;include refid=&quot;empColumn&quot;&gt;&lt;/include&gt; from emp&lt;/sql&gt;
&lt;!--List&lt;Emp&gt; findByCondition(Emp emp);--&gt;
&lt;select id=&quot;findByCondition&quot; resultType=&quot;emp&quot;&gt;
    &lt;include refid=&quot;baseSelect&quot;&gt;&lt;/include&gt;
    &lt;trim prefix=&quot;where&quot; prefixOverrides=&quot;and&quot;&gt;
        &lt;if test=&quot;empno != null&quot;&gt;
            and empno =#&#123;empno&#125;
        &lt;/if&gt;
        &lt;if test=&quot;ename != null and ename != &#39;&#39;&quot;&gt;
            &lt;bind name=&quot;likePattern&quot; value=&quot;&#39;%&#39;+ename+&#39;%&#39;&quot;/&gt;
            and ename like #&#123;likePattern&#125;
        &lt;/if&gt;
        &lt;if test=&quot;job != null and job != &#39;&#39;&quot;&gt;
            and job =#&#123;job&#125;
        &lt;/if&gt;
        &lt;if test=&quot;mgr != null&quot;&gt;
            and mgr =#&#123;mgr&#125;
        &lt;/if&gt;
        &lt;if test=&quot;hiredate != null&quot;&gt;
            and hiredate =#&#123;hiredate&#125;
        &lt;/if&gt;
        &lt;if test=&quot;sal != null&quot;&gt;
            and sal =#&#123;sal&#125;
        &lt;/if&gt;
        &lt;if test=&quot;comm != null&quot;&gt;
            and comm =#&#123;comm&#125;
        &lt;/if&gt;
        &lt;if test=&quot;deptno != null&quot;&gt;
            and deptno =#&#123;deptno&#125;
        &lt;/if&gt;
    &lt;/trim&gt;
&lt;/select&gt;
</code></pre>
<h2 id="9-foreach标签"><a href="#9-foreach标签" class="headerlink" title="9_foreach标签"></a>9_foreach标签</h2><pre><code class="xml"> &lt;!--List&lt;Emp&gt; findByEmpnos1(int[] empnos);
 collection=&quot;&quot;  遍历的集合或者是数组
                 参数是数组,collection中名字指定为array
                 参数是List集合,collection中名字指定为list
 separator=&quot;&quot;   多个元素取出的时候 用什么文字分隔
 open=&quot;&quot;        以什么开头
 close=&quot;&quot;       以什么结尾
 item=&quot;&quot;        中间变量名
 for(Person per:PersonList)
 --&gt;
 &lt;select id=&quot;findByEmpnos1&quot; resultType=&quot;emp&quot;&gt;
     select * from emp  where empno in
     &lt;foreach collection=&quot;array&quot; separator=&quot;,&quot; open=&quot;(&quot; close=&quot;)&quot; item=&quot;deptno&quot;&gt;
         #&#123;deptno&#125;
     &lt;/foreach&gt;
 &lt;/select&gt;
&lt;!-- List&lt;Emp&gt; findByEmpnos2(List&lt;Integer&gt; empnos);--&gt;
 &lt;select id=&quot;findByEmpnos2&quot; resultType=&quot;emp&quot;&gt;
     select * from emp  where empno in
     &lt;foreach collection=&quot;list&quot; separator=&quot;,&quot; open=&quot;(&quot; close=&quot;)&quot; item=&quot;deptno&quot;&gt;
         #&#123;deptno&#125;
     &lt;/foreach&gt;
 &lt;/select&gt;
</code></pre>
<h1 id="8-MyBatis实现多表查询"><a href="#8-MyBatis实现多表查询" class="headerlink" title="8 MyBatis实现多表查询"></a>8 MyBatis实现多表查询</h1><p>前面已经使用MyBatis完成了对Emp表的CRUD操作，不管是使用SqlSession直接操作，还是使用Mapper代理方式，都只是完成了对单个数据库表的操作。这肯定是远远不够的。</p>
<p>在实际开发中，经常会将来自多张表的数据在一个位置显示。比如查询并显示的员工信息中会有来自部门表、岗位表的数据，而后台一般是定义一个方法</p>
<h2 id="1-关联查询"><a href="#1-关联查询" class="headerlink" title="1 关联查询"></a>1 关联查询</h2><h3 id="1-手动处理映射关系"><a href="#1-手动处理映射关系" class="headerlink" title="1 手动处理映射关系"></a>1 手动处理映射关系</h3><p>实体类</p>
<pre><code class="java">public class Emp  implements Serializable &#123;
    private Integer empno;
    private String name;
    private String job;
    private Integer mgr;
    private Date hiredate;
    private Double sal;
    private Double comm;
    private Integer deptno;
&#125;
</code></pre>
<p>映射文件</p>
<pre><code class="xml">&lt;mapper namespace=&quot;com.msb.mapper.EmpMapper&quot;&gt;
    &lt;!--手动处理数据库查询字段和封装实体类属性之间的映射关系
    1 主键一般使用id属性
    2 当属性名和查询出的数据表字段名相同 可以不写映射关系
    --&gt;
    &lt;resultMap id=&quot;empMap&quot; type=&quot;emp&quot;&gt;
        &lt;!--&lt;id property=&quot;empno&quot; column=&quot;empno&quot;&gt;&lt;/id&gt;--&gt;
        &lt;result property=&quot;name&quot; column=&quot;ename&quot;&gt;&lt;/result&gt;
        &lt;!--&lt;result property=&quot;job&quot; column=&quot;job&quot;&gt;&lt;/result&gt;
        &lt;result property=&quot;sal&quot; column=&quot;sal&quot;&gt;&lt;/result&gt;
        &lt;result property=&quot;hiredate&quot; column=&quot;hiredate&quot;&gt;&lt;/result&gt;
        &lt;result property=&quot;mgr&quot; column=&quot;mgr&quot;&gt;&lt;/result&gt;
        &lt;result property=&quot;comm&quot; column=&quot;comm&quot;&gt;&lt;/result&gt;
        &lt;result property=&quot;deptno&quot; column=&quot;deptno&quot;&gt;&lt;/result&gt;--&gt;
    &lt;/resultMap&gt;
    &lt;select id=&quot;findByEmpno&quot; resultMap=&quot;empMap&quot; &gt;
        select * from emp where empno =#&#123;empno&#125;
    &lt;/select&gt;
&lt;/mapper&gt;
</code></pre>
<h3 id="2-一对一关联查询"><a href="#2-一对一关联查询" class="headerlink" title="2 一对一关联查询"></a>2 一对一关联查询</h3><p>数据准备: 创建项目表和项目记录表</p>
<img data-src="/2022/10/07/ORM/Mybatis/image-20220617200808312.png" class="" title="image-20220617200808312">



<pre><code class="sql">CREATE TABLE `projects`  (
  `pid` int(2) NOT NULL AUTO_INCREMENT,
  `pname` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL,
  `money` int(11) NULL DEFAULT NULL,
  PRIMARY KEY (`pid`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = Dynamic;
INSERT INTO `projects` VALUES (1, &#39; ***大学OA&#39;, 500000);
INSERT INTO `projects` VALUES (2, &#39;学生选课系统&#39;, 100000);
INSERT INTO `projects` VALUES (3, &#39;讲师测评系统&#39;, 20000);
INSERT INTO `projects` VALUES (4, &#39;线上问答系统 &#39;, 20000);
CREATE TABLE `projectrecord`  (
  `empno` int(4) NOT NULL,
  `pid` int(2) NOT NULL,
  PRIMARY KEY (`empno`, `pid`) USING BTREE,
  INDEX `fk_project_pro`(`pid`) USING BTREE,
  CONSTRAINT `fk_emp_pro` FOREIGN KEY (`empno`) REFERENCES `emp` (`EMPNO`) ON DELETE CASCADE ON UPDATE CASCADE,
  CONSTRAINT `fk_project_pro` FOREIGN KEY (`pid`) REFERENCES `projects` (`pid`) ON DELETE CASCADE ON UPDATE CASCADE
) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = Dynamic;
INSERT INTO `projectrecord` VALUES (7369, 1);
INSERT INTO `projectrecord` VALUES (7521, 1);
INSERT INTO `projectrecord` VALUES (7369, 2);
INSERT INTO `projectrecord` VALUES (7499, 2);
INSERT INTO `projectrecord` VALUES (7521, 2);
INSERT INTO `projectrecord` VALUES (7369, 3);
INSERT INTO `projectrecord` VALUES (7499, 3);
INSERT INTO `projectrecord` VALUES (7521, 3);
INSERT INTO `projectrecord` VALUES (7369, 4);
INSERT INTO `projectrecord` VALUES (7499, 4);
</code></pre>
<p>需求:根据编号查询员工信息及所在的部门信息</p>
<p>实体类添加一个部门作为属性</p>
<p>实体类</p>
<pre><code class="java">@AllArgsConstructor
@NoArgsConstructor
@Data
public class Emp implements Serializable &#123;
    private Integer empno;
    private String ename;
    private String job;
    private Integer mgr;
    private Date hiredate;
    private Double sal;
    private Double comm;
    private Integer deptno;
    // 组合一个Dept对象作为自己的属性
    private Dept dept;
&#125;
</code></pre>
<p>接口</p>
<pre><code class="java">public interface EmpMapper &#123;
    /**
     * 根据员工编号查询员工的所有信息并携带所在的部门信息
     * @param empno 要查询的员工编号
     * @return Emp对象,组合了Dept对象作为属性,对部门信息进行存储
     */
    Emp findEmpJoinDeptByEmpno(int empno);
&#125;
</code></pre>
<p>映射文件</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper
        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;com.msb.mapper.EmpMapper&quot;&gt;
    &lt;!--Emp findEmpJoinDeptByEmpno(int empno);--&gt;
    &lt;resultMap id=&quot;empJoinDept&quot; type=&quot;emp&quot;&gt;
        &lt;!--设置emp本身的八个属性的映射关系--&gt;
        &lt;id property=&quot;empno&quot; column=&quot;empno&quot;&gt;&lt;/id&gt;
        &lt;result property=&quot;ename&quot; column=&quot;ename&quot;&gt;&lt;/result&gt;
        &lt;result property=&quot;job&quot; column=&quot;job&quot;&gt;&lt;/result&gt;
        &lt;result property=&quot;sal&quot; column=&quot;sal&quot;&gt;&lt;/result&gt;
        &lt;result property=&quot;hiredate&quot; column=&quot;hiredate&quot;&gt;&lt;/result&gt;
        &lt;result property=&quot;mgr&quot; column=&quot;mgr&quot;&gt;&lt;/result&gt;
        &lt;result property=&quot;comm&quot; column=&quot;comm&quot;&gt;&lt;/result&gt;
        &lt;result property=&quot;deptno&quot; column=&quot;deptno&quot;&gt;&lt;/result&gt;
        &lt;!--
        association 处理一对一
        封装一对一信息关系的标签
        property  emp类的属性名
        javaType  用哪个类的对象给属性赋值
        --&gt;
        &lt;association property=&quot;dept&quot; javaType=&quot;dept&quot;&gt;
            &lt;id column=&quot;deptno&quot; property=&quot;deptno&quot;&gt;&lt;/id&gt;
            &lt;result column=&quot;dname&quot; property=&quot;dname&quot;&gt;&lt;/result&gt;
            &lt;result column=&quot;loc&quot; property=&quot;loc&quot;&gt;&lt;/result&gt;
        &lt;/association&gt;
    &lt;/resultMap&gt;
    &lt;select id=&quot;findEmpJoinDeptByEmpno&quot; resultMap=&quot;empJoinDept&quot; &gt;
        select * from
        emp e
        left join dept  d
        on e.deptno =d.deptno
        where empno = #&#123;empno&#125;
    &lt;/select&gt;
&lt;/mapper&gt;
</code></pre>
<p>测试代码</p>
<pre><code class="java">@Test
public void testOneToOne() throws ParseException &#123;
    EmpMapper mapper = sqlSession.getMapper(EmpMapper.class);
    Emp emp = mapper.findEmpJoinDeptByEmpno(7499);
    System.out.println(emp);
&#125;
</code></pre>
<p>3 一对多关联查询</p>
<p>根据部门号查询部门信息及该部门的所有员工信息</p>
<p>实体类</p>
<pre><code class="java">@Data
@AllArgsConstructor
@NoArgsConstructor
public class Dept implements Serializable &#123;
    private Integer deptno;
    private String dname;
    private String loc;
    // 组合一个Emp的List集合作为属性
    private List&lt;Emp&gt; empList;
&#125;
</code></pre>
<p>接口</p>
<pre><code class="java">package com.msb.mapper;
import com.msb.pojo.Dept;
/**
 * @Author: Ma HaiYang
 * @Description: MircoMessage:Mark_7001
 */
public interface DeptMapper &#123;
    /**
     * 根据部门编号查询部门信息及该部分的所有员工信息
     * @param deptno 要查询的部门编号
     * @return Dept对象,内部组合了一个Emp的List属性用于封装部门的所有员工信息
     */
    Dept findDeptJoinEmpsByDeptno(int deptno);
&#125;
</code></pre>
<p>映射文件</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper
        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;com.msb.mapper.DeptMapper&quot;&gt;
    &lt;!--Dept findDeptJoinEmpsByDeptno(int deptno);--&gt;
    &lt;resultMap id=&quot;deptJoinEmps&quot; type=&quot;dept&quot;&gt;
        &lt;id column=&quot;deptno&quot; property=&quot;deptno&quot;&gt;&lt;/id&gt;
        &lt;result column=&quot;dname&quot; property=&quot;dname&quot;&gt;&lt;/result&gt;
        &lt;result column=&quot;loc&quot; property=&quot;loc&quot;&gt;&lt;/result&gt;
        &lt;!--处理一对多关系的标签--&gt;
        &lt;collection property=&quot;empList&quot; ofType=&quot;emp&quot; &gt;
            &lt;!--设置emp本身的八个属性的映射关系--&gt;
            &lt;id property=&quot;empno&quot; column=&quot;empno&quot;&gt;&lt;/id&gt;
            &lt;result property=&quot;ename&quot; column=&quot;ename&quot;&gt;&lt;/result&gt;
            &lt;result property=&quot;job&quot; column=&quot;job&quot;&gt;&lt;/result&gt;
            &lt;result property=&quot;sal&quot; column=&quot;sal&quot;&gt;&lt;/result&gt;
            &lt;result property=&quot;hiredate&quot; column=&quot;hiredate&quot;&gt;&lt;/result&gt;
            &lt;result property=&quot;mgr&quot; column=&quot;mgr&quot;&gt;&lt;/result&gt;
            &lt;result property=&quot;comm&quot; column=&quot;comm&quot;&gt;&lt;/result&gt;
            &lt;result property=&quot;deptno&quot; column=&quot;deptno&quot;&gt;&lt;/result&gt;
        &lt;/collection&gt;
    &lt;/resultMap&gt;
    &lt;select id=&quot;findDeptJoinEmpsByDeptno&quot; resultMap=&quot;deptJoinEmps&quot;&gt;
        select * from dept d left join emp e on d.deptno =e.deptno where d.deptno =#&#123;deptno&#125;
    &lt;/select&gt;
&lt;/mapper&gt;
</code></pre>
<p>测试代码</p>
<pre><code class="java">@Test
public void testOneToMany() throws ParseException &#123;
    DeptMapper mapper = sqlSession.getMapper(DeptMapper.class);
    Dept dept = mapper.findDeptJoinEmpsByDeptno(20);
    System.out.println(dept);
    System.out.println(&quot;---------&quot;);
    List&lt;Emp&gt; empList = dept.getEmpList();
    empList.forEach(System.out::println);
&#125;
</code></pre>
<p>4 多对多关联查询</p>
<p>根据项目编号查询项目信息,以及参与到该项目之中的所有的员工信息</p>
<p>实体类</p>
<pre><code class="java">@NoArgsConstructor
@AllArgsConstructor
@Data
public class Project  implements Serializable &#123;
    private Integer pid;
    private String pname;
    private Integer money;
    // 组合一个ProjectRecord对象集合作为属性
    private List&lt;ProjectRecord&gt; projectRecords;
&#125;
@Data
@AllArgsConstructor
@NoArgsConstructor
public class ProjectRecord implements Serializable &#123;
    private Integer empno;
    private Integer pid;
    // 组合一个Emp对象作为属性
    private Emp emp;
&#125;
</code></pre>
<p>接口</p>
<pre><code class="java">package com.msb.mapper;
import com.msb.pojo.Emp;
import com.msb.pojo.Project;
/**
 * @Author: Ma HaiYang
 * @Description: MircoMessage:Mark_7001
 */
public interface ProjectMapper &#123;
    /**
     * 根据项目编号查询一个项目信息及参与该项目的所有员工信息
     * @param pid 项目编号
     * @return 所有信息封装的Project对象
     */
    Project findProjectJoinEmpsByPid(int pid);
&#125;
</code></pre>
<p>映射文件</p>
<pre><code class="xml">&lt;!DOCTYPE mapper
        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;com.msb.mapper.ProjectMapper&quot;&gt;
    &lt;!--Project findProjectJoinEmpsByPid(int pid);--&gt;
    &lt;resultMap id=&quot;projectJoinEmps&quot; type=&quot;project&quot;&gt;
        &lt;id column=&quot;pid&quot; property=&quot;pid&quot;&gt;&lt;/id&gt;
        &lt;result column=&quot;pname&quot; property=&quot;pname&quot;&gt;&lt;/result&gt;
        &lt;result column=&quot;money&quot; property=&quot;money&quot;&gt;&lt;/result&gt;
        &lt;!--一对多 集合属性 collection--&gt;
        &lt;collection property=&quot;projectRecords&quot; ofType=&quot;projectRecord&quot;&gt;
            &lt;id column=&quot;empno&quot; property=&quot;empno&quot;&gt;&lt;/id&gt;
            &lt;id column=&quot;pid&quot; property=&quot;pid&quot;&gt;&lt;/id&gt;
            &lt;!--一对一 --&gt;
            &lt;association property=&quot;emp&quot; javaType=&quot;emp&quot;&gt;
                &lt;id property=&quot;empno&quot; column=&quot;empno&quot;&gt;&lt;/id&gt;
                &lt;result property=&quot;ename&quot; column=&quot;ename&quot;&gt;&lt;/result&gt;
                &lt;result property=&quot;job&quot; column=&quot;job&quot;&gt;&lt;/result&gt;
                &lt;result property=&quot;sal&quot; column=&quot;sal&quot;&gt;&lt;/result&gt;
                &lt;result property=&quot;hiredate&quot; column=&quot;hiredate&quot;&gt;&lt;/result&gt;
                &lt;result property=&quot;mgr&quot; column=&quot;mgr&quot;&gt;&lt;/result&gt;
                &lt;result property=&quot;comm&quot; column=&quot;comm&quot;&gt;&lt;/result&gt;
                &lt;result property=&quot;deptno&quot; column=&quot;deptno&quot;&gt;&lt;/result&gt;
            &lt;/association&gt;
        &lt;/collection&gt;
    &lt;/resultMap&gt;
    &lt;select id=&quot;findProjectJoinEmpsByPid&quot;  resultMap=&quot;projectJoinEmps&quot;&gt;
        select * from
        project p
        left join projectrecord pr
        on p.pid = pr.pid
        left join emp e
        on e.empno = pr.empno
        where p.pid= #&#123;pid&#125;
    &lt;/select&gt;
&lt;/mapper&gt;
</code></pre>
<p>测试代码</p>
<pre><code class="java">@Test
public void testManyToMany() throws ParseException &#123;
    ProjectMapper mapper = sqlSession.getMapper(ProjectMapper.class);
    Project project = mapper.findProjectJoinEmpsByPid(2);
    System.out.println(project.getPid());
    System.out.println(project.getPname());
    System.out.println(project.getMoney());
    List&lt;ProjectRecord&gt; projectRecords = project.getProjectRecords();
    for (ProjectRecord projectRecord : projectRecords) &#123;
        Emp emp = projectRecord.getEmp();
        System.out.println(emp);
    &#125;
&#125;
</code></pre>
<h2 id="2-级联查询"><a href="#2-级联查询" class="headerlink" title="2 级联查询"></a>2 级联查询</h2><p>级联查询，顾名思义，就是利于数据库表间的外键关联关系进行自动的级联查询操作。使用MyBatis实现级联查询，除了实体类增加关联属性外，还需要在映射文件中进行配置。</p>
<h3 id="1-立即加载"><a href="#1-立即加载" class="headerlink" title="1 立即加载"></a>1 立即加载</h3><h3 id="2-延迟加载"><a href="#2-延迟加载" class="headerlink" title="2 延迟加载"></a>2 延迟加载</h3><p><strong>延迟加载，又称按需加载</strong>。延迟加载的内容等到真正使用时才去进行加载（查询）。多用在关联对象或集合中。</p>
<p>延迟加载的好处：先从单表查询、需要时再从关联表去关联查询，大大降低数据库在单位时间内的查询工作量,将工作在时间上的分配更加均匀，而且单表要比关联查询多张表速度要快。</p>
<p>延迟加载的设置</p>
<p>第一步：全局开关：在sqlMapConfig.xml中打开延迟加载的开关。配置完成后所有的association和collection元素都生效</p>
<pre><code class="xml">  &lt;settings&gt;
      &lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot;/&gt;
      &lt;setting name=&quot;aggressiveLazyLoading&quot; value=&quot;true&quot;/&gt;
  &lt;/settings&gt;
</code></pre>
<p><font color=#008000>lazyLoadingEnabled</font>:是否开启延迟加载。是Mybatis是否启用懒加载的全局开关。当开启时，所有关联对象都会延迟加载。特定关联关系中可通过设置fetchType属性来覆盖该项的开关状态</p>
<p><font color=#008000 >aggressiveLazyLoading</font>：当开启时，任何方法的调用都会懒加载对象的所有属性。否则，每个属性会按需加载,</p>
<p>第二步：分开关：指定的association和collection元素中配置<font color=#0000FF>fetchType</font>属性。eager：表示立刻加载；lazy：表示延迟加载。<strong>将覆盖全局延迟设置。</strong></p>
<h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3 总结"></a>3 总结</h2><h4 id="resultMap中的常见属性"><a href="#resultMap中的常见属性" class="headerlink" title="resultMap中的常见属性"></a>resultMap中的常见属性</h4><table style="text-align: center;" cellpadding="30" >
    <tr style="background-color:#E2EFD9 ;">
            <td>property</td>
            <td>需要映射到JavaBean 的属性名称</td>
        </tr>
        <tr>
            <td >javaType</td>
            <td>property的类型，一个完整的类名，或者是一个类型别名。如果你匹配的是一个JavaBean，那MyBatis 通常会自行检测到</td>
        </tr>
        <tr style="background-color:#E2EFD9 ;">
            <td>column</td>
            <td>数据表的列名或者列别名</td>
        </tr>
        <tr>
            <td>jdbcType</td>
            <td>column在数据库表中的类型。这个属性只在insert,update   或delete 的时候针对允许空的列有用。JDBC 需要这项，但MyBatis 不需要</td>
        </tr>
        <tr style="background-color:#E2EFD9 ;">
            <td>typeHandler</td>
            <td>使用这个属性可以覆写类型处理器，实现javaType、jdbcType之间的相互转换。一般可以省略，会探测到使用的什么类型的typeHandler进行处理</td>
        </tr>
        <tr>
            <td>fetchType</td>
            <td>自动延迟加载</td>
        </tr>
        <tr style="background-color:#E2EFD9 ;">
            <td>select</td>
            <td>association、collection的属性，使用哪个查询查询属性的值，要求指定namespace+id的全名称</td>
        </tr>
        <tr>
            <td>ofType</td>
            <td>collection的属性，指明集合中元素的类型（即泛型类型）</td>
        </tr>
    </table>




<h4 id="级联查询和多表查询的比较及其选择"><a href="#级联查询和多表查询的比较及其选择" class="headerlink" title="级联查询和多表查询的比较及其选择"></a>级联查询和多表查询的比较及其选择</h4><table style="text-align: center;" cellpadding="30" >
    <tr style="background-color:#E2EFD9 ;">
            <td>SQL语句数量</td>
        <td>多条</td>
        <td>一条</td>
    </tr>
    <tr>
        <td >性能</td>
        <td>性能低</td>
        <td>性能高</td>
    </tr>
    <tr style="background-color:#E2EFD9 ;">
        <td>延迟加载</td>
        <td>立即加载、延迟加载</td>
        <td>只有立即加载</td>
    </tr>
    <tr>
        <td>灵活性</td>
        <td>更灵活</td>
        <td>不灵活</td>
    </tr>
    <tr style="background-color:#E2EFD9 ;">
        <td>SQL难易度</td>
        <td>简单</td>
        <td>复杂</td>
    </tr>
    <tr>
        <td>选择依据</td>
        <td>简单、灵活</td>
        <td>高性能</td>
    </tr>
</table>




<p><strong>ResultType和ResultMap使用场景</strong></p>
<ol>
<li><pre><code>如果你做的是单表的查询并且封装的实体和数据库的字段一一对应   resultType
</code></pre>
</li>
<li><pre><code>如果实体封装的属性和数据库的字段不一致  resultMap
</code></pre>
</li>
<li><pre><code> 使用N+1级联查询的时候  resultMap
</code></pre>
</li>
<li><pre><code>使用的是多表的连接查询  resultMap
</code></pre>
</li>
</ol>
<p><strong>一对一关联映射的实现</strong></p>
<ol>
<li><pre><code>实例：学生和学生证、雇员和工牌
</code></pre>
</li>
<li><pre><code>数据库层次：主键关联或者外键关联（参看之前内容）
</code></pre>
</li>
<li><pre><code> MyBatis层次：在映射文件的设置双方均使用association即可，用法相同
</code></pre>
</li>
</ol>
<p><strong>多对多映射的实现</strong></p>
<ol>
<li><pre><code>实例：学生和课程、用户和角色
</code></pre>
</li>
<li><pre><code> 数据库层次：引入一个中间表将一个多对多转为两个一对多
</code></pre>
</li>
<li><pre><code> MyBatis层次
</code></pre>
</li>
</ol>
<p>方法1：在映射文件的设置双方均使用collection即可，不用引入中间类</p>
<p>方法2：引入中间类和中间类的映射文件，按照两个一对多处理</p>
<p><strong>自关联映射</strong></p>
<ol>
<li><pre><code>实例：Emp表中的员工和上级。一般是一对多关联
</code></pre>
</li>
<li><pre><code>数据库层次：外键参考当前表的主键（比如mgr参考empno）
</code></pre>
</li>
<li><p>MyBatis层次：按照一对多处理，但是增加的属性都写到一个实体类中，增加的映射也都写到一个映射文件中</p>
</li>
</ol>
<h1 id="9-MyBatis注解开发"><a href="#9-MyBatis注解开发" class="headerlink" title="9 MyBatis注解开发"></a>9 MyBatis注解开发</h1><pre><code class="java">public interface DeptMapper &#123;
    Dept findDeptByDeptno(int deptno);
    @Select(&quot;select * from dept where deptno =#&#123;deptno&#125;&quot;)
    Dept findByDeptno(int deptno);
    int updateDept(Dept dept);
    int addDept(Dept dept);
    @Delete(&quot;delete from dept where deptno =#&#123;deptno&#125;&quot;)
    int removeDept(int deptno);
&#125;
</code></pre>
<p>1.使用注解没有实现Java代码和SQL语句的解耦</p>
<p>2.无法实现SQL语句的动态拼接</p>
<p>3.进行多表的查询时定制ResultMap比较麻烦</p>
<p><strong>注解和XML的优缺点</strong></p>
<table style="text-align: center;" cellpadding="30" >
    <tr style="background-color:#E2EFD9 ;">
            <td>优点</td>
        <td>类和类之间的解耦</td>
        <td>简化配置</td>
    </tr>
    <tr>
        <td > </td>
        <td>利于修改。直接修改XML文件，无需到源代码中修改。</td>
        <td>使用起来直观且容易，提升开发效率</td>
    </tr>
    <tr style="background-color:#E2EFD9 ;">
        <td></td>
        <td>配置集中在XML中，对象间关系一目了然，利于快速了解项目和维护</td>
        <td>类型安全，编译器进行校验，不用等到运行期才会发现错误</td>
    </tr>
    <tr>
        <td></td>
        <td>容易和其他系统进行数据交交换</td>
        <td>注解的解析可以不依赖于第三方库，可以直接使用Java自带的反射</td>
    </tr>
</table>






<h1 id="10-缓存"><a href="#10-缓存" class="headerlink" title="10 缓存"></a>10 缓存</h1><img data-src="/2022/10/07/ORM/Mybatis/image-20220617211853352.png" class="" title="image-20220617211853352">

<blockquote>
<p>​	是一种临时存储少量数据至内存或者是磁盘的一种技术.减少数据的加载次数,可以降低工作量,提高程序响应速度</p>
<p>​	缓存的重要性是不言而喻的。mybatis的缓存将相同查询条件的SQL语句执行一遍后所得到的结果存在内存或者某种缓存介质当中，当下次遇到一模一样的查询SQL时候不在执行SQL与数据库交互，而是直接从缓存中获取结果，减少服务器的压力；尤其是在查询越多、缓存命中率越高的情况下，使用缓存对性能的提高更明显。</p>
<p>​	MyBatis允许使用缓存，缓存一般放置在高速读&#x2F;写的存储器上，比如服务器的内存，能够有效的提供系统性能。MyBatis分为<font color=#FF0000>一级缓存和二级缓存</font>，同时也可配置关于缓存设置。</p>
<p>​	一级存储是SqlSession上的缓存，二级缓存是在SqlSessionFactory(namespace)上的缓存。默认情况下，MyBatis开启一级缓存，没有开启二级缓存。当数据量大的时候可以借助一些第三方缓存框架或Redis缓存来协助保存Mybatis的二级缓存数据。</p>
</blockquote>
<img data-src="/2022/10/07/ORM/Mybatis/image-20220617211938471.png" class="" title="image-20220617211938471">



<h2 id="1-一级缓存"><a href="#1-一级缓存" class="headerlink" title="1 一级缓存"></a>1 一级缓存</h2><p>一级存储是SqlSession上的缓存，默认开启，是一种内存型缓存,不要求实体类对象实现Serializable接口。</p>
<p>缓存中的数据使用键值对形式存储数据</p>
<p>&#x3D;&#x3D;namespace + sqlid + args + offset     &gt;&gt;&gt;   hash 值作为键,查询出的结果作为值&#x3D;&#x3D;</p>
<img data-src="/2022/10/07/ORM/Mybatis/image-20220617212008075.png" class="" title="image-20220617212008075">

<p>测试 代码</p>
<pre><code class="java">@Test
public void testFindDeptByDetpno()   &#123;
    EmpMapper mapper = sqlSession.getMapper(EmpMapper.class);
    Emp emp = mapper.findByEmpno(7521);
    System.out.println(emp);
    // 中间发生了增删改或者是调用了SqlSession调用了commit,会自动清空缓存
    sqlSession.commit();// 增删改的时候调用
    EmpMapper mapper2 = sqlSession.getMapper(EmpMapper.class);
    Emp emp2 = mapper2.findByEmpno(7521);
    System.out.println(emp2); 
    
    System.out.println(emp==emp2);// 没有commit之前为True
    System.out.println(mapper==mapper2);// false 表示确实产生了两个代理对象
&#125;
</code></pre>
<h2 id="2-二级缓存"><a href="#2-二级缓存" class="headerlink" title="2 二级缓存"></a>2 二级缓存</h2><p>二级缓存是以namespace为标记的缓存，可以是由一个SqlSessionFactory创建的SqlSession之间共享缓存数据。默认并不开启。下面的代码中创建了两个SqlSession，执行相同的SQL语句，尝试让第二个SqlSession使用第一个SqlSession查询后缓存的数据。要求实体类必须实现序列化接口</p>
<img data-src="/2022/10/07/ORM/Mybatis/image-20220617212052512.png" class="" title="image-20220617212052512">



<p>接口</p>
<pre><code class="java">public interface EmpMapper &#123;
    Emp findByEmpno(int empno);
&#125;
</code></pre>
<p>映射文件</p>
<pre><code class="xml">&lt;mapper namespace=&quot;com.msb.mapper.EmpMapper&quot;&gt;
    &lt;cache/&gt;
    &lt;select id=&quot;findByEmpno&quot; resultType=&quot;emp&quot; useCache=&quot;true&quot; flushCache=&quot;false&quot;&gt;
        select * from emp where empno =#&#123;empno&#125;
    &lt;/select&gt;
&lt;/mapper&gt;
</code></pre>
<p>测试 代码</p>
<pre><code class="java">package com.msb.test;
import com.msb.mapper.EmpMapper;
import com.msb.pojo.Emp;
import org.apache.ibatis.io.Resources;
import org.apache.ibatis.session.SqlSession;
import org.apache.ibatis.session.SqlSessionFactory;
import org.apache.ibatis.session.SqlSessionFactoryBuilder;
import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import java.io.IOException;
import java.io.InputStream;
/**
 * @Author: Ma HaiYang
 * @Description: MircoMessage:Mark_7001
 */
public class Test3 &#123;
    private SqlSession sqlSession;
    private SqlSession sqlSession2;
    @Before
    public void init()&#123;
        SqlSessionFactoryBuilder ssfb =new SqlSessionFactoryBuilder();
        InputStream resourceAsStream = null;
        try &#123;
            resourceAsStream = Resources.getResourceAsStream(&quot;sqlMapConfig.xml&quot;);
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125;
        SqlSessionFactory factory=ssfb.build(resourceAsStream) ;
        sqlSession=factory.openSession();
        sqlSession2=factory.openSession();
    &#125;
    @Test
    public void testFindDeptByDetpno()   &#123;
        EmpMapper mapper = sqlSession.getMapper(EmpMapper.class);
        Emp emp = mapper.findByEmpno(7521);
        System.out.println(emp);
        // SqlSession提交之后,才会将查询的结果放入二级缓存
        sqlSession.commit();
        EmpMapper mapper2 = sqlSession2.getMapper(EmpMapper.class);
        Emp emp2 = mapper2.findByEmpno(7521);
        System.out.println(emp2);
    &#125;
    @After
    public void release()&#123;
        // 关闭SQLSession
        sqlSession.close();
        sqlSession2.close();
    &#125;
&#125;
</code></pre>
<p><strong>注意：</strong></p>
<p>​	其中的commit()，执行该命令后才会将该SqlSession的查询结果从一级缓存中放入二级缓存，供其他SqlSession使用。另外执行SqlSession的close()也会将该SqlSession的查询结果从一级缓存中放入二级缓存。两种方式区别在当前SqlSession是否关闭了。</p>
<p>执行结果显示进行了两次对数据库的SQL查询，说明二级缓存并没有开启。需要进行如下步骤完成开启。</p>
<ol>
<li>全局开关：在sqlMapConfig.xml文件中的<font color=blue><settings></font>标签配置开启二级缓存</li>
</ol>
<pre><code class="xml">&lt;settings&gt;
    &lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt;
&lt;/settings&gt;
</code></pre>
<p>cacheEnabled的默认值就是true，所以这步的设置可以省略。</p>
<ol start="2">
<li>分开关：在要开启二级缓存的mapper文件中开启缓存：</li>
</ol>
<pre><code class="xml">&lt;mapper namespace=&quot;com.msb.mapper.EmployeeMapper&quot;&gt;
    &lt;cache/&gt;
&lt;/mapper&gt;
</code></pre>
<ol start="3">
<li>二级缓存未必完全使用内存,有可能占用硬盘存储,缓存中存储的JavaBean对象必须实现序列化接口,</li>
</ol>
<pre><code class="java">public class Emp implements  Serializable &#123;  &#125;
</code></pre>
<p>经过设置后，查询结果如图所示。发现第一个SqlSession会首先去二级缓存中查找，如果不存在，就查询数据库，<font color=#FF0000>在commit()或者close()的时候将数据放入到二级缓存</font>。第二个SqlSession执行相同SQL语句查询时就直接从二级缓存中获取了。</p>
<p><strong>注意：</strong></p>
<p>​	1)    MyBatis的二级缓存的缓存介质有多种多样，而并不一定是在内存中，所以需要对JavaBean对象实现序列化接口。</p>
<ol start="2">
<li>二级缓存是以 namespace 为单位的，不同 namespace 下的操作互不影响</li>
</ol>
<p>​	3)    加入Cache元素后，会对相应命名空间所有的select元素查询结果进行缓存，而其中的insert、update、delete在操作是会清空整个namespace的缓存。</p>
<p>​	4)    cache 有一些可选的属性 type, eviction, flushInterval, size, readOnly, blocking。</p>
<pre><code class="xml">&lt;cache type=&quot;&quot; readOnly=&quot;&quot; eviction=&quot;&quot;flushInterval=&quot;&quot;size=&quot;&quot;blocking=&quot;&quot;/&gt;
</code></pre>
<p>&lt;cache type&#x3D;”” readOnly&#x3D;”” eviction&#x3D;””flushInterval&#x3D;””size&#x3D;””blocking&#x3D;””&#x2F;&gt;</p>
<table style="text-align: center;" cellpadding="30" >
    <style>
        td {
            text-align:center;
        }
        p {
          text-align:center;
        }
    </style>
    <tr style="background-color:#E2EFD9 ;">
            <td>type</td>
         <td><p>自定义缓存类，要求实现org.apache.ibatis.cache.Cache接口</p></td>
            <td>null</td>
        </tr>
        <tr>
            <td>readOnly</td>
            <td ><p>是否只读</p>
                <p> true:给所有调用者返回缓存对象的相同实例。因此这些对象不能被修改。 </p>
                <span> 这提供了很重要的性能优势。</span>
                <p>false:会返回缓存对象的拷贝(通过序列化)。</p>
                <p> 这会慢一些,但是安全</p>
            </td>
            <td>false</td>
        </tr>
        <tr style="background-color:#E2EFD9 ;">
            <td>eviction</td>
            <td>	 
                <p>缓存策略<br>LRU（默认） – 最近最少使用：移除最长时间不被使用的对象。</p>
                <p>FIFO – 先进先出：按对象进入缓存的顺序来移除它们。</p>
                <p>SOFT – 软引用：基于垃圾回收器状态和软引用规则移除对象。</p>
                <p>WEAK – 弱引用：更积极地基于垃圾收集器状态和弱引用规则移除对象。</p>
            </td>
            <td>LRU</td>
        </tr>
        <tr>
            <td>flushInterval</td>
            <td><p>
                    刷新间隔，毫秒为单位。默认为null，也就是没有刷新间隔，
                </p>
                <p>
                    只有执行update、insert、delete语句才会刷新
                </p>
            </td>
            <td>null</td>
        </tr>
        <tr style="background-color:#E2EFD9 ;">
             <td>size</td>
            <td><p>缓存对象个数<p></td>
            <td>1024</td>
        </tr>
        <tr>
            <td>blocking</td>
            <td>
                <p>是否使用阻塞性缓存BlockingCache</p>
                <p>true：在查询缓存时锁住对应的Key，如果缓存命中了则会释放对应的锁，</p>
                <span>否则会在查询数据库以后再释放锁，</span>
                <p>保证只有一个线程到数据库中查找指定key对应的数据</p>
                <p>false：不使用阻塞性缓存，性能更好</p>
            </td>
            <td>false</td>
        </tr>
</table>





<ol start="5">
<li>如果在加入Cache元素的前提下让个别select 元素不使用缓存，可以使用useCache属性，设置为false。useCache控制当前sql语句是否启用缓存  flushCache控制当前sql执行一次后是否刷新缓存</li>
</ol>
<pre><code class="xml">&lt;select id=&quot;findByEmpno&quot; resultType=&quot;emp&quot; useCache=&quot;true&quot; flushCache=&quot;false&quot;&gt;
</code></pre>
<h2 id="3-三方缓存"><a href="#3-三方缓存" class="headerlink" title="3 三方缓存"></a>3 三方缓存</h2><blockquote>
<p>分布式缓存框架：我们系统为了提高系统并发和性能，一般对系统进行分布式部署（集群部署方式）不适用分布缓存， 缓存的数据在各个服务单独存储，不方便系统开发。所以要使用分布式缓存对缓存数据进行集中管理.ehcache,redis ,memcache缓存框架。</p>
</blockquote>
<p>Ehcache：是一种广泛使用的开源java分布式缓存。主要面向通用缓存，javaEE 和 轻量级容器。它具有内存和磁盘存储功能。被用于大型复杂分布式web application的</p>
<p>这里的三方缓存是作为二级缓存使用的</p>
<p>导入依赖的jar文件</p>
<pre><code class="xml"> &lt;dependency&gt;
    &lt;groupId&gt;org.mybatis.caches&lt;/groupId&gt;
    &lt;artifactId&gt;mybatis-ehcache&lt;/artifactId&gt;
    &lt;version&gt;1.0.2&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;net.sf.ehcache&lt;/groupId&gt;
    &lt;artifactId&gt;ehcache&lt;/artifactId&gt;
    &lt;version&gt;2.10.1&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
    &lt;artifactId&gt;slf4j-nop&lt;/artifactId&gt;
    &lt;version&gt;1.7.2&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>去各自的sql映射文件里,开启二级缓存,并把缓存类型指定为EhcacheCache</p>
<pre><code class="xml"> &lt;cache type=&quot;org.mybatis.caches.ehcache.EhcacheCache&quot;/&gt;
</code></pre>
<p>在资源目录下放置一个缓存配置文件,文件名为: ehcache.xml 内容如下</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;ehcache xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:noNamespaceSchemaLocation=&quot;ehcache.xsd&quot;
         updateCheck=&quot;true&quot; monitoring=&quot;autodetect&quot;
         dynamicConfig=&quot;true&quot;&gt;
    &lt;diskStore path=&quot;D:\msb\ehcache&quot; /&gt;
    &lt;defaultCache
            maxElementsInMemory=&quot;1000&quot;
            maxElementsOnDisk=&quot;10000000&quot;
            eternal=&quot;false&quot;
            overflowToDisk=&quot;true&quot;
            timeToIdleSeconds=&quot;120&quot;
            timeToLiveSeconds=&quot;120&quot;
            diskExpiryThreadIntervalSeconds=&quot;120&quot;
            memoryStoreEvictionPolicy=&quot;LRU&quot;&gt;
    &lt;/defaultCache&gt;
&lt;/ehcache&gt;
        &lt;!--  Cache配置
        ·           name：Cache的唯一标识
        ·           maxElementsInMemory：内存中最大缓存对象数。
        ·           maxElementsOnDisk：磁盘中最大缓存对象数，若是0表示无穷大。
        ·           eternal：Element是否永久有效，一但设置了，timeout将不起作用。
        ·           overflowToDisk：配置此属性，当内存中Element数量达到maxElementsInMemory时，Ehcache将会Element写到磁盘中。
        ·           timeToIdleSeconds：设置Element在失效前的允许闲置时间。仅当element不是永久有效时使用，可选属性，默认值是0，也就是可闲置时间无穷大。
        ·           timeToLiveSeconds：设置Element在失效前允许存活时间。最大时间介于创建时间和失效时间之间。仅当element不是永久有效时使用，默认是0.，也就是element存活时间无穷大。
        ·           diskExpiryThreadIntervalSeconds：磁盘失效线程运行时间间隔，默认是120秒。
        ·           diskSpoolBufferSizeMB：这个参数设置DiskStore（磁盘缓存）的缓存区大小。默认是30MB。每个Cache都应该有自己的一个缓冲区。
        ·           memoryStoreEvictionPolicy：当达到maxElementsInMemory限制时，Ehcache将会根据指定的策略去清理内存。默认策略是LRU（最近最少使用）。你可以设置为FIFO（先进先出）或是LFU（较少使用）。     --&gt;
</code></pre>
<h1 id="11-逆向工程"><a href="#11-逆向工程" class="headerlink" title="11 逆向工程"></a>11 逆向工程</h1><blockquote>
<p>MyBatisPlus 内容，简略分析，可以参考后面具体内容</p>
</blockquote>
<p>MyBatis的一个主要的特点就是需要程序员自己编写SQL，那么如果表太多的话，难免会很麻烦，所以MyBatis官方提供了一个逆向工程，可以针对单表自动生成MyBatis执行所需要的代码（包括mapper.xml，mapper.java，pojo）。一般在开发中，常用的逆向工程方式是通过数据库的表生成代码。</p>
<p>创建maven项目导入逆向工程依赖</p>
<img data-src="/2022/10/07/ORM/Mybatis/image-20220617221042957.png" class="" title="image-20220617221042957">

<pre><code class="xml">&lt;dependencies&gt;
  
    &lt;!-- mysql驱动包 --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;mysql&lt;/groupId&gt;
        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
        &lt;version&gt;8.0.16&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;!-- 日志包，方便查看执行信息--&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
        &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;
        &lt;version&gt;1.6.1&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;!-- 代码生成工具jar --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt;
        &lt;artifactId&gt;mybatis-generator-core&lt;/artifactId&gt;
        &lt;version&gt;1.3.2&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
<p>配置逆向工程配置文件 在resources目录下放置一个名为generatorConfig.xml的配置文件,文件内容如下</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE generatorConfiguration
  PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;
  &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt;
&lt;generatorConfiguration&gt;
   &lt;context id=&quot;testTables&quot; targetRuntime=&quot;MyBatis3&quot;&gt;
      &lt;commentGenerator&gt;
         &lt;!-- 是否去除自动生成的注释 true：是 ： false:否 --&gt;
         &lt;property name=&quot;suppressAllComments&quot; value=&quot;true&quot; /&gt;
      &lt;/commentGenerator&gt;
      &lt;!--数据库连接的信息：驱动类、连接地址、用户名、密码 --&gt;
      &lt;!-- &lt;jdbcConnection driverClass=&quot;com.mysql.jdbc.Driver&quot;
         connectionURL=&quot;jdbc:mysql://localhost:3306/mybatis&quot; userId=&quot;root&quot;
         password=&quot;123&quot;&gt;
      &lt;/jdbcConnection&gt; --&gt;
       &lt;jdbcConnection driverClass=&quot;com.mysql.cj.jdbc.Driver&quot;
         connectionURL=&quot;jdbc:mysql://127.0.0.1:3306/mydb?useSSL=false&amp;amp;useUnicode=true&amp;amp;characterEncoding=UTF-8&amp;amp;serverTimezone=Asia/Shanghai&amp;amp;allowPublicKeyRetrieval=true&quot;
         userId=&quot;root&quot;
         password=&quot;root&quot;&gt;
      &lt;/jdbcConnection&gt; 
      &lt;!-- 默认false，把JDBC DECIMAL 和 NUMERIC 类型解析为 Integer，为 true时把JDBC DECIMAL 和 
         NUMERIC 类型解析为java.math.BigDecimal --&gt;
      &lt;javaTypeResolver&gt;
         &lt;property name=&quot;forceBigDecimals&quot; value=&quot;false&quot; /&gt;
      &lt;/javaTypeResolver&gt;
      &lt;!-- targetProject:生成PO类的位置 --&gt;
      &lt;javaModelGenerator targetPackage=&quot;com.msb.pojo&quot;
         targetProject=&quot;.\src&quot;&gt;
         &lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt;
         &lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot; /&gt;
         &lt;!-- 从数据库返回的值被清理前后的空格 --&gt;
         &lt;property name=&quot;trimStrings&quot; value=&quot;true&quot; /&gt;
      &lt;/javaModelGenerator&gt;
        &lt;!-- targetProject:mapper映射文件生成的位置 --&gt;
      &lt;sqlMapGenerator targetPackage=&quot;com.msb.mapper&quot;
         targetProject=&quot;.\src&quot;&gt;
         &lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt;
         &lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot; /&gt;
      &lt;/sqlMapGenerator&gt;
      &lt;!-- targetPackage：mapper接口生成的位置 --&gt;
      &lt;javaClientGenerator type=&quot;XMLMAPPER&quot;
         targetPackage=&quot;com.msb.mapper&quot;
         targetProject=&quot;.\src&quot;&gt;
         &lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt;
         &lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot; /&gt;
      &lt;/javaClientGenerator&gt;
      &lt;!-- 指定数据库表 --&gt;
      
      &lt;table tableName=&quot;dept&quot; domainObjectName=&quot;Dept&quot;
       enableCountByExample=&quot;false&quot; enableUpdateByExample=&quot;false&quot; enableDeleteByExample=&quot;false&quot;    
               enableSelectByExample=&quot;false&quot; selectByExampleQueryId=&quot;false&quot; &gt;
               &lt;columnOverride column=&quot;id&quot; javaType=&quot;Integer&quot; /&gt;
         &lt;/table&gt;
      
   &lt;/context&gt;
&lt;/generatorConfiguration&gt;
</code></pre>
<p>在resources目录下放置一个名为log4j.properties的配置文件,文件内容如下</p>
<pre><code class="properties">log4j.rootLogger=debug,stdout
log4j.appender.stdout=org.apache.log4j.ConsoleAppender
log4j.appender.stdout.Target=System.err
log4j.appender.stdout.layout=org.apache.log4j.SimpleLayout
log4j.appender.logfile=org.apache.log4j.FileAppender
log4j.appender.logfile.File=d:/msb.log
log4j.appender.logfile.layout=org.apache.log4j.PatternLayout
log4j.appender.logfile.layout.ConversionPattern=%d&#123;yyyy-MM-dd HH:mm:ss&#125; %l %F %p %m%n
</code></pre>
<p>运行逆向工程代码</p>
<pre><code class="java">package com.msb.gennerator;
import org.mybatis.generator.api.MyBatisGenerator;
import org.mybatis.generator.config.Configuration;
import org.mybatis.generator.config.xml.ConfigurationParser;
import org.mybatis.generator.internal.DefaultShellCallback;
import java.io.File;
import java.util.ArrayList;
import java.util.List;
/**
 *
 */
public class GeneratorSqlmap &#123;
    public void generator() throws Exception&#123;
        List&lt;String&gt; warnings = new ArrayList&lt;String&gt;();
        boolean overwrite = true;
        File configFile = new File(&quot;D:\\ideaProjects\\reverse\\target\\classes\\generatorConfig.xml&quot;);
        ConfigurationParser cp = new ConfigurationParser(warnings);
        Configuration config = cp.parseConfiguration(configFile);
        DefaultShellCallback callback = new DefaultShellCallback(overwrite);
        MyBatisGenerator myBatisGenerator = new MyBatisGenerator(config,
                callback, warnings);
        myBatisGenerator.generate(null);
    &#125;
    public static void main(String[] args) throws Exception &#123;
        try &#123;
            GeneratorSqlmap generatorSqlmap = new GeneratorSqlmap();
            generatorSqlmap.generator();
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;
</code></pre>
<p>生成的实体类和Mapper接口和Mapper映射文件,包含了基本的CURD功能,哪里需要文件就放哪里</p>
<img data-src="/2022/10/07/ORM/Mybatis/image-20220617221208040-1665157666426.png" class="" title="image-20220617221208040">

<h1 id="12-main目录下配置文件打包问题"><a href="#12-main目录下配置文件打包问题" class="headerlink" title="12 main目录下配置文件打包问题"></a>12 main目录下配置文件打包问题</h1><pre><code class="xml">&lt;build&gt;
    &lt;!--告诉maven将项目源码中的xml文件也进行编译，并放到编译目录中--&gt;
    &lt;resources&gt;
        &lt;resource&gt;
            &lt;directory&gt;src/main/java&lt;/directory&gt;
            &lt;includes&gt;
                &lt;include&gt;**/*.xml&lt;/include&gt;
            &lt;/includes&gt;
            &lt;filtering&gt;true&lt;/filtering&gt;
        &lt;/resource&gt;
        &lt;resource&gt;
            &lt;directory&gt;src/main/resources&lt;/directory&gt;
            &lt;filtering&gt;true&lt;/filtering&gt;
        &lt;/resource&gt;
    &lt;/resources&gt;
&lt;/build&gt;
</code></pre>
]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>框架</tag>
        <tag>ORM</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL基础</title>
    <url>/2022/10/14/bkBasic/Docsify/</url>
    <content><![CDATA[<h1 id="Docsify搭建"><a href="#Docsify搭建" class="headerlink" title="Docsify搭建"></a>Docsify搭建</h1><p>官网：<span class="exturl" data-url="aHR0cHM6Ly9kb2NzaWZ5LmpzLm9yZy8jL3poLWNuLw==">https://docsify.js.org/#/zh-cn/</span></p>
<p>前提</p>
<blockquote>
<p>要配置好 <code>nodeJs</code> 、<code>npm</code></p>
</blockquote>
<h2 id="安装-Docsify-插件"><a href="#安装-Docsify-插件" class="headerlink" title="安装 Docsify 插件"></a>安装 Docsify 插件</h2><blockquote>
<p>自己创建一个要下载到本地的文件夹，然后在这里直接利用命令下载</p>
</blockquote>
<p>推荐全局安装 <code>docsify-cli</code> 工具，可以方便地创建及在本地预览生成的文档。</p>
<pre><code class="sh">npm i docsify-cli -g
</code></pre>
<p>​	下载完成之后，进入 <code>./node_modules/.bin</code> 使用终端查看安装是否成功 </p>
<pre><code class="sh">docsify -v
</code></pre>
<p><img data-src="https://cdn.jsdelivr.net/gh/onlymarryu/typora-ims-test@master/img/image-20220507180321976.png" alt="image-20220507180321976"></p>
<p>出现版本号，表明安装成功，自己再将该路径定义为 <strong>系统环境变量</strong></p>
<h2 id="初始化项目"><a href="#初始化项目" class="headerlink" title="初始化项目"></a><span class="exturl" data-url="aHR0cHM6Ly9kb2NzaWZ5LmpzLm9yZy8jL3poLWNuL3F1aWNrc3RhcnQ/aWQ9JUU1JTg4JTlEJUU1JUE3JThCJUU1JThDJTk2JUU5JUExJUI5JUU3JTlCJUFF">初始化项目</span></h2><p>如果想在项目的 <code>./docs</code> 目录里写文档，直接通过 <code>init</code> 初始化项目。</p>
<pre><code class="bash"># init 初始化 + 初始化文件
docsify init ./docs
</code></pre>
<p>初始化成功：</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/onlymarryu/typora-ims-test@master/img/image-20220507180556746.png" alt="image-20220507180556746"></p>
<p><img data-src="https://cdn.jsdelivr.net/gh/onlymarryu/typora-ims-test@master/img/image-20220507180639225.png" alt="image-20220507180639225"></p>
<h2 id="开始写文档"><a href="#开始写文档" class="headerlink" title="开始写文档"></a><span class="exturl" data-url="aHR0cHM6Ly9kb2NzaWZ5LmpzLm9yZy8jL3poLWNuL3F1aWNrc3RhcnQ/aWQ9JUU1JUJDJTgwJUU1JUE3JThCJUU1JTg2JTk5JUU2JTk2JTg3JUU2JUExJUEz">开始写文档</span></h2><p>初始化成功后，可以看到 <code>./docs</code> 目录下创建的几个文件</p>
<ul>
<li><code>index.html</code> 入口文件</li>
<li><code>README.md</code> 会做为主页内容渲染</li>
<li><code>.nojekyll</code> 用于阻止 GitHub Pages 忽略掉下划线开头的文件</li>
</ul>
<p>直接编辑 <code>docs/README.md</code> 就能更新文档内容，当然也可以<span class="exturl" data-url="aHR0cHM6Ly9kb2NzaWZ5LmpzLm9yZy8jL3poLWNuL21vcmUtcGFnZXM=">添加更多页面</span>。</p>
<h2 id="本地预览"><a href="#本地预览" class="headerlink" title="本地预览"></a><span class="exturl" data-url="aHR0cHM6Ly9kb2NzaWZ5LmpzLm9yZy8jL3poLWNuL3F1aWNrc3RhcnQ/aWQ9JUU2JTlDJUFDJUU1JTlDJUIwJUU5JUEyJTg0JUU4JUE3JTg4">本地预览</span></h2><p>​	通过运行 <code>docsify serve</code> 启动一个本地服务器，可以方便地实时预览效果。</p>
<pre><code class="bash">docsify serve docs
</code></pre>
<p>​	</p>
<p>​	<strong>默认访问地址：</strong>   <span class="exturl" data-url="aHR0cDovL2xvY2FsaG9zdDozMDAwLw==">http://localhost:3000</span> 。</p>
<p>用 <code>IDE</code> 有可能遇到的问题。</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/onlymarryu/typora-ims-test@master/img/image-20220507182733021.png" alt="image-20220507182733021"></p>
<p>解决办法：</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JraG9sZS9hcnRpY2xlL2RldGFpbHMvMTI0NjM2OTE2">https://blog.csdn.net/Bkhole/article/details/124636916</span></p>
<p>访问结果：</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/onlymarryu/typora-ims-test@master/img/image-20220507183235754.png" alt="image-20220507183235754"></p>
<p>和 <code>README.md</code> 文件内容一致。</p>
<blockquote>
<p>我们在开发的时候 所有内容都是动态更新的</p>
</blockquote>
<h2 id="功能开发"><a href="#功能开发" class="headerlink" title="功能开发"></a>功能开发</h2><blockquote>
<p>主要内容还是参考 <span class="exturl" data-url="aHR0cHM6Ly9kb2NzaWZ5LmpzLm9yZy8jL3poLWNuLw==">官网 </span>，这里只做简单描述。</p>
</blockquote>
<h3 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h3><p>​	如果需要创建多个页面，或者需要多级路由的网站，在 docsify 里也能很容易的实现。例如创建一个 <code>guide.md</code> 文件，那么对应的路由就是 <code>/#/guide</code>。</p>
<p>假设你的目录结构如下：</p>
<pre><code class="text">.
└── docs
    ├── README.md
    ├── guide.md
    └── zh-cn
        ├── README.md
        └── guide.md
</code></pre>
<p>那么对应的访问页面将是</p>
<pre><code class="text">docs/README.md        =&gt; http://domain.com
docs/guide.md         =&gt; http://domain.com/guide
docs/zh-cn/README.md  =&gt; http://domain.com/zh-cn/
docs/zh-cn/guide.md   =&gt; http://domain.com/zh-cn/guide
</code></pre>
<h3 id="定制侧边栏"><a href="#定制侧边栏" class="headerlink" title="定制侧边栏"></a><span class="exturl" data-url="aHR0cHM6Ly9kb2NzaWZ5LmpzLm9yZy8jL3poLWNuL21vcmUtcGFnZXM/aWQ9JUU1JUFFJTlBJUU1JTg4JUI2JUU0JUJFJUE3JUU4JUJFJUI5JUU2JUEwJThG">定制侧边栏</span></h3><p>为了获得侧边栏，您需要创建自己的 <code>_sidebar.md</code>，你也可以自定义加载的文件名。默认情况下侧边栏会通过 Markdown 文件自动生成，效果如当前的文档的侧边栏。</p>
<p>首先配置 <code>loadSidebar</code> 选项，具体配置规则见<span class="exturl" data-url="aHR0cHM6Ly9kb2NzaWZ5LmpzLm9yZy8jL3poLWNuL2NvbmZpZ3VyYXRpb24/aWQ9bG9hZHNpZGViYXI=">配置项#loadSidebar</span>。</p>
<pre><code class="html">&lt;!-- index.html --&gt;

&lt;script&gt;
  window.$docsify = &#123;
      &lt;!-- 打开配置 --&gt;
    loadSidebar: true
  &#125;
&lt;/script&gt;
&lt;script src=&quot;//cdn.jsdelivr.net/npm/docsify/lib/docsify.min.js&quot;&gt;&lt;/script&gt;
</code></pre>
<p>接着创建 <code>_sidebar.md</code> 文件，内容如下</p>
<pre><code class="markdown">&lt;!-- docs/_sidebar.md --&gt;

* [首页](zh-cn/)
* [指南](zh-cn/guide)
</code></pre>
<p>注：</p>
<blockquote>
<p>需要在 <code>./docs</code> 目录创建 <code>.nojekyll</code> 命名的空文件，阻止 GitHub Pages 忽略命名是下划线开头的文件。</p>
</blockquote>
<p>###<span class="exturl" data-url="aHR0cHM6Ly9kb2NzaWZ5LmpzLm9yZy8jL3poLWNuL21vcmUtcGFnZXM/aWQ9JUU2JTk4JUJFJUU3JUE0JUJBJUU3JTlCJUFFJUU1JUJEJTk1">显示目录</span></p>
<p>自定义侧边栏同时也可以开启目录功能。设置 <code>subMaxLevel</code> 配置项，具体介绍见 <span class="exturl" data-url="aHR0cHM6Ly9kb2NzaWZ5LmpzLm9yZy8jL3poLWNuL2NvbmZpZ3VyYXRpb24/aWQ9c3VibWF4bGV2ZWw=">配置项#subMaxLevel</span>。</p>
<pre><code class="html">&lt;!-- index.html --&gt;

&lt;script&gt;
  window.$docsify = &#123;
    loadSidebar: true,
    subMaxLevel: 2
  &#125;
&lt;/script&gt;
&lt;script src=&quot;//cdn.jsdelivr.net/npm/docsify/lib/docsify.min.js&quot;&gt;&lt;/script&gt;
</code></pre>
<h3 id="自定义导航栏"><a href="#自定义导航栏" class="headerlink" title="自定义导航栏"></a><span class="exturl" data-url="aHR0cHM6Ly9kb2NzaWZ5LmpzLm9yZy8jL3poLWNuL2N1c3RvbS1uYXZiYXI/aWQ9JUU4JTg3JUFBJUU1JUFFJTlBJUU0JUI5JTg5JUU1JUFGJUJDJUU4JTg4JUFBJUU2JUEwJThG">自定义导航栏</span></h3><h4 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a><span class="exturl" data-url="aHR0cHM6Ly9kb2NzaWZ5LmpzLm9yZy8jL3poLWNuL2N1c3RvbS1uYXZiYXI/aWQ9aHRtbA==">HTML</span></h4><p>如果你需要定制导航栏，可以用 HTML 创建一个导航栏。</p>
<p>注意：文档的链接都要以 <code>#/</code> 开头。</p>
<pre><code class="html">&lt;!-- index.html --&gt;

&lt;body&gt;
  &lt;nav&gt;
    &lt;a href=&quot;#/&quot;&gt;EN&lt;/a&gt;
    &lt;a href=&quot;#/zh-cn/&quot;&gt;中文&lt;/a&gt;
  &lt;/nav&gt;
  &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;
&lt;/body&gt;
</code></pre>
<h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a><span class="exturl" data-url="aHR0cHM6Ly9kb2NzaWZ5LmpzLm9yZy8jL3poLWNuL2N1c3RvbS1uYXZiYXI/aWQ9JUU5JTg1JThEJUU3JUJEJUFFJUU2JTk2JTg3JUU0JUJCJUI2">配置文件</span></h3><p>那我们可以通过 Markdown 文件来配置导航。首先配置 <code>loadNavbar</code>，默认加载的文件为 <code>_navbar.md</code>。具体配置规则见<span class="exturl" data-url="aHR0cHM6Ly9kb2NzaWZ5LmpzLm9yZy8jL2NvbmZpZ3VyYXRpb24/aWQ9bG9hZG5hdmJhcg==">配置项#loadNavbar</span>。</p>
<pre><code class="html">&lt;!-- index.html --&gt;

&lt;script&gt;
  window.$docsify = &#123;
    loadNavbar: true
  &#125;
&lt;/script&gt;
&lt;script src=&quot;//cdn.jsdelivr.net/npm/docsify/lib/docsify.min.js&quot;&gt;&lt;/script&gt;
&lt;!-- _navbar.md --&gt;

* [En](/)
* [中文](/zh-cn/)
</code></pre>
<p><strong>注：</strong></p>
<blockquote>
<p>你需要在 <code>./docs</code> 目录下创建一个 <code>.nojekyll</code> 文件，以防止 GitHub Pages 忽略下划线开头的文件。</p>
</blockquote>
<p><code>_navbar.md</code> 加载逻辑和 <code>sidebar</code> 文件一致，从每层目录下获取。例如当前路由为 <code>/zh-cn/custom-navbar</code> 那么是从 <code>/zh-cn/_navbar.md</code> 获取导航栏。</p>
<h3 id="封面"><a href="#封面" class="headerlink" title="封面"></a><span class="exturl" data-url="aHR0cHM6Ly9kb2NzaWZ5LmpzLm9yZy8jL3poLWNuL2NvdmVyP2lkPSVFNSVCMCU4MSVFOSU5RCVBMg==">封面</span></h3><p>通过设置 <code>coverpage</code> 参数，可以开启渲染封面的功能。具体用法见<span class="exturl" data-url="aHR0cHM6Ly9kb2NzaWZ5LmpzLm9yZy8jL2NvbmZpZ3VyYXRpb24/aWQ9Y292ZXJwYWdl">配置项#coverpage</span>。</p>
<h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a><span class="exturl" data-url="aHR0cHM6Ly9kb2NzaWZ5LmpzLm9yZy8jL3poLWNuL2NvdmVyP2lkPSVFNSU5RiVCQSVFNiU5QyVBQyVFNyU5NCVBOCVFNiVCMyU5NQ==">基本用法</span></h4><p>封面的生成同样是从 markdown 文件渲染来的。开启渲染封面功能后在文档根目录创建 <code>_coverpage.md</code> 文件。渲染效果如本文档。</p>
<p><em>index.html</em></p>
<pre><code class="html">&lt;!-- index.html --&gt;

&lt;script&gt;
  window.$docsify = &#123;
    coverpage: true
  &#125;
&lt;/script&gt;
&lt;script src=&quot;//cdn.jsdelivr.net/npm/docsify/lib/docsify.min.js&quot;&gt;&lt;/script&gt;
&lt;!-- techPage.md --&gt;

&#123;% asset_img icon.svg logo %&#125;

# docsify &lt;small&gt;3.5&lt;/small&gt;

&gt; 一个神奇的文档网站生成器。

- 简单、轻便 (压缩后 ~21kB)
- 无需生成 html 文件
- 众多主题

[GitHub](https://github.com/docsifyjs/docsify/)
[Get Started](#docsify)
</code></pre>
<h4 id="自定义背景"><a href="#自定义背景" class="headerlink" title="自定义背景"></a><span class="exturl" data-url="aHR0cHM6Ly9kb2NzaWZ5LmpzLm9yZy8jL3poLWNuL2NvdmVyP2lkPSVFOCU4NyVBQSVFNSVBRSU5QSVFNCVCOSU4OSVFOCU4MyU4QyVFNiU5OSVBRg==">自定义背景</span></h4><p>目前的背景是随机生成的渐变色，我们自定义背景色或者背景图。在文档末尾用添加图片的 Markdown 语法设置背景。</p>
<pre><code>_coverpage.md
&lt;!-- _coverpage.md --&gt;

# docsify &lt;small&gt;3.5&lt;/small&gt;

[GitHub](https://github.com/docsifyjs/docsify/)
[Get Started](#quick-start)

&lt;!-- 背景图片 --&gt;

&#123;% asset_img bg.png  %&#125;

&lt;!-- 背景色 --&gt;

![color](#f0f0f0)
</code></pre>
<h4 id="封面作为首页"><a href="#封面作为首页" class="headerlink" title="封面作为首页"></a><span class="exturl" data-url="aHR0cHM6Ly9kb2NzaWZ5LmpzLm9yZy8jL3poLWNuL2NvdmVyP2lkPSVFNSVCMCU4MSVFOSU5RCVBMiVFNCVCRCU5QyVFNCVCOCVCQSVFOSVBNiU5NiVFOSVBMSVCNQ==">封面作为首页</span></h4><p>通常封面和首页是同时出现的，当然你也是当封面独立出来通过设置<span class="exturl" data-url="aHR0cHM6Ly9kb2NzaWZ5LmpzLm9yZy8jL3poLWNuL2NvbmZpZ3VyYXRpb24/aWQ9b25seWNvdmVy">onlyCover 选项</span>。</p>
<h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><p>和 GitBook 生成的文档一样，我们可以直接把文档网站部署到 GitHub Pages 或者 VPS 上。</p>
<h4 id="GitHub-Pages"><a href="#GitHub-Pages" class="headerlink" title="GitHub Pages"></a><span class="exturl" data-url="aHR0cHM6Ly9kb2NzaWZ5LmpzLm9yZy8jL3poLWNuL2RlcGxveT9pZD1naXRodWItcGFnZXM=">GitHub Pages</span></h4><p>GitHub Pages 支持从三个地方读取文件</p>
<ul>
<li><code>docs/</code> 目录</li>
<li>master 分支</li>
<li>gh-pages 分支</li>
</ul>
<p>我们推荐直接将文档放在 <code>docs/</code> 目录下，在设置页面开启 <strong>GitHub Pages</strong> 功能并选择 <code>master branch /docs folder</code> 选项。</p>
<h4 id="配置过程"><a href="#配置过程" class="headerlink" title="配置过程"></a>配置过程</h4><p>1、创建一个GitHub仓库</p>
<blockquote>
<p>要求：</p>
<p>1、仓库名格式必须符合：github_username.github.io</p>
</blockquote>
<p>2、配置 GithubPage</p>
<blockquote>
<p>随便选一个主题，毕竟我们也不用</p>
</blockquote>
<p><img data-src="https://cdn.jsdelivr.net/gh/onlymarryu/typora-ims-test@master/img/image-20220507185116977.png" alt="image-20220507185116977"></p>
<p><img data-src="https://cdn.jsdelivr.net/gh/onlymarryu/typora-ims-test@master/img/image-20220507185152734.png" alt="image-20220507185152734"></p>
<p><img data-src="https://cdn.jsdelivr.net/gh/onlymarryu/typora-ims-test@master/img/image-20220507185320819.png" alt="image-20220507185320819"></p>
<p><img data-src="https://cdn.jsdelivr.net/gh/onlymarryu/typora-ims-test@master/img/image-20220507185336250.png" alt="image-20220507185336250"></p>
<p>3、上传项目</p>
<blockquote>
<p>直接将我们的项目上传到这个库中即可。</p>
</blockquote>
<p>–考虑到是保姆级教程我们将上传步骤也写一下</p>
<p>（1）首先我们将仓库中的信息拉取下来</p>
<p>​	这是第二步配置结束之后会产生<code>GitHubPage</code>的配置文件</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/onlymarryu/typora-ims-test@master/img/image-20220507185418951.png" alt="image-20220507185418951"></p>
<p>（2）将配置文件与我们的docs文件一起重新提交到仓库中</p>
<pre><code class="git">git add xx

git commit xx -m&quot;注释&quot;

git push xx 仓库地址 分支
</code></pre>
<p>我这里直接使用工具 <code>Sourcetree</code> 提交。</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/onlymarryu/typora-ims-test@master/img/image-20220507190045839.png" alt="image-20220507190045839"></p>
<p>4、上传成功，部署成功</p>
<p>直接访问：</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9vbmx5bWFycnl1LmdpdGh1Yi5pby8jLw==">https://onlymarryu.github.io/#/</span></p>
<p><img data-src="https://cdn.jsdelivr.net/gh/onlymarryu/typora-ims-test@master/img/image-20220507184626485.png" alt="image-20220507184626485"></p>
<blockquote>
<p>​	如果刷新不是想要的结果，只要确认之前所有本地测试结果正取，只是部署之后结果不对，这就是部署时间的问题，我们等一会刷新即可。</p>
</blockquote>
]]></content>
      <categories>
        <category>基础使用</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>环境搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo</title>
    <url>/2022/10/06/bkBasic/hexo/</url>
    <content><![CDATA[<hr>
<p>title: hexo<br>date: 2022-10-06 14:53:52<br>categories:<br>    - 基础使用<br>tags:<br>    - 环境搭建<br>    - 博客</p>
<hr>
<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p><code>hexo</code>是一个基于nodejs的静态博客网站生成器，作者是来自台湾的<code>Tommy Chen</code>，为许多技术博客的博主所青睐，主要有如下的一些优点：</p>
<ul>
<li><p>支持Markdown语法，编辑简单，排版优美；</p>
</li>
<li><p>能够快速生成静态html文件；</p>
</li>
<li><p>部署容易，接口简单； 兼容于各大主流操作系统；</p>
</li>
<li><p>社区主题、插件很多，遇到问题的时候能查到的参考材料也很多。</p>
</li>
</ul>
<p>Hexo官方文档：<span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL3poLWNuL2RvY3Mv">https://hexo.io/zh-cn/docs/</span></p>
<p>Gitee Pages：<span class="exturl" data-url="aHR0cHM6Ly9naXRlZS5jb20vaGVscC9hcnRpY2xlcy80MTM2I2FydGljbGUtaGVhZGVyMA==">https://gitee.com/help/articles/4136#article-header0</span></p>
<h1 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h1><p>搭建hexo首先需要有nodejs的环境，可以从官网直接下载。</p>
<img data-src="/2022/10/06/bkBasic/hexo/2xKvaPTDoyZcFbp.png" class="" title="nodejs">

<h1 id="生成博客"><a href="#生成博客" class="headerlink" title="生成博客"></a>生成博客</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>有了npm包管理软件，安装hexo就很方便了，只需要一行命令：</p>
<pre><code class="shell">npm install node # homebrew安装nodejs
</code></pre>
<p>其中-g参数表示全局安装，没有这个参数就只在当前目录下安装，建议全局安装。</p>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>运行命令：</p>
<pre><code class="shell">hexo init
</code></pre>
<pre><code class="shell">INFO  Cloning hexo-starter https://github.com/hexojs/hexo-starter.git
INFO  Install dependencies
# 一些可能的中间信息
INFO  Start blogging with Hexo!
</code></pre>
<p>然后进入博客目录：</p>
<blockquote>
<p> cd “博客目录”</p>
</blockquote>
<p>安装博客需要的其他支持：</p>
<pre><code class="sh">npm install # 安装的依赖项在package.json文件的dependencies字段中可以看到
</code></pre>
<h2 id="博客项目目录结构介绍"><a href="#博客项目目录结构介绍" class="headerlink" title="博客项目目录结构介绍"></a>博客项目目录结构介绍</h2><p>查看目录结构：</p>
<pre><code class="sh">tree -L 1 
</code></pre>
<p>结果如下：</p>
<blockquote>
<p>.<br>├── _config.landscape.yml<br>├── _config.yml<br>├── node_modules<br>├── package-lock.json<br>├── package.json<br>├── scaffolds<br>├── source<br>└── themes</p>
</blockquote>
<p>各部分的含义：</p>
<ul>
<li>`_config.yml &#96;<ul>
<li>为全局配置文件，网站的很多信息都在这里配置，比如说网站名称，副标题，描述，作者，语言，主题等等。具体可以参考官方文档：<span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL3poLWNuL2RvY3MvY29uZmlndXJhdGlvbi5odG1sJUUzJTgwJTgy">https://hexo.io/zh-cn/docs/configuration.html。</span></li>
</ul>
</li>
<li><code>_scaffolds</code><ul>
<li>骨架文件，是生成新页面或者新博客的模版。可以根据需求编辑，当<code>hexo</code>生成新博客的时候，会用这里面的模版进行初始化。</li>
</ul>
</li>
<li><code>_source</code><ul>
<li>这个文件夹下面存放的是网站的<code>markdown</code>源文件，里面有一个<code>_post</code>文件夹，所有的<code>.md</code>博客文件都会存放在这个文件夹下。现在，你应该能看到里面有一个<code>hello-world.md</code>文件。_</li>
</ul>
</li>
<li><code>_themes</code><ul>
<li>网站主题目录，<code>hexo</code>有非常丰富的主题支持，主题目录会存放在这个目录下面。</li>
<li>我们后续会以默认主题来演示，更多的主题参见：<span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL3RoZW1lcy8=">https://hexo.io/themes/</span></li>
</ul>
</li>
</ul>
<h2 id="生成新文章"><a href="#生成新文章" class="headerlink" title="生成新文章"></a>生成新文章</h2><pre><code class="sh">hexo new post &quot;test&quot; # 会在 source/_posts/ 目录下生成文件 ‘test.md’，打开编辑
hexo generate        # 生成静态HTML文件到 /public 文件夹中
hexo server          # 本地运行server服务预览，打开 http://localhost:4000 即可预览你的博客
</code></pre>
<p><strong>本地预览效果：</strong></p>
<img data-src="/2022/10/06/bkBasic/hexo/image-20221006120456734.png" class="" title="image-20221006120456734">

<p>这是hexo的默认主题，更多的主题可以从官网下载。</p>
<p>更详细的hexo命令可以查看文档：<span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL3poLWNuL2RvY3MvY29tbWFuZHM=">https://hexo.io/zh-cn/docs/commands</span></p>
<h1 id="Hexo配置并部署"><a href="#Hexo配置并部署" class="headerlink" title="Hexo配置并部署"></a>Hexo配置并部署</h1><blockquote>
<p>提前对要提交的仓库配置ssh</p>
</blockquote>
<h2 id="1-安装部署工具"><a href="#1-安装部署工具" class="headerlink" title="1.安装部署工具"></a>1.安装部署工具</h2><pre><code class="sh">npm install hexo-deployer-git --save
</code></pre>
<h2 id="2-配置部署信息"><a href="#2-配置部署信息" class="headerlink" title="2.配置部署信息"></a>2.配置部署信息</h2><p>站点配置文件_config.yml</p>
<pre><code class="yml">deploy:
  type: git
  repo: &lt;repository url&gt; # 输入你的仓库地址
  branch: [branch] # 输入分支
  token:   #token
</code></pre>
<blockquote>
<p>deploy:</p>
<p> type: git</p>
<p> repo: <span class="exturl" data-url="bWFpbHRvOiYjeDY3OyYjMTA1OyYjeDc0OyYjeDQwOyYjeDY3OyYjeDY5OyYjMTE2OyYjeDY1OyYjMTAxOyYjNDY7JiN4NjM7JiMxMTE7JiN4NmQ7">&#x67;&#105;&#x74;&#x40;&#x67;&#x69;&#116;&#x65;&#101;&#46;&#x63;&#111;&#x6d;</span>:cysheng&#x2F;cysheng.git # 输入你的仓库地址</p>
<p> branch: master # 输入分支</p>
</blockquote>
<h2 id="3-部署"><a href="#3-部署" class="headerlink" title="3.部署"></a>3.部署</h2><pre><code class="sh"> hexo clean  
 hexo g  
 hexo d 
</code></pre>
<ul>
<li><p>hexo clean</p>
<p>清除缓存文件 (db.json) 和已生成的静态文件 (public)。</p>
</li>
<li><p>hexo g</p>
<p>hexo解析站点文件夹，生成一个public文件夹（只包含浏览器可以解析的html、css、js），也就是我们需要部署的文件夹。</p>
</li>
<li><p>hexo d</p>
<p>部署，即将我们的public文件夹推送到我们配置的仓库</p>
</li>
</ul>
<h2 id="4-开启Gitee-Pages服务"><a href="#4-开启Gitee-Pages服务" class="headerlink" title="4.开启Gitee Pages服务"></a>4.开启Gitee Pages服务</h2><p>找到新创建的仓库-&gt;【服务】-&gt;【Gitee Pages】  <img data-src="/2022/10/06/bkBasic/hexo/image-20221006120734926.png" class="" title="hexo&#x2F;image-20221006120734926"></p>
<p>如图，选择部署分支，部署目录</p>
<ul>
<li><p>部署分支，与本地hexo配置一致</p>
</li>
<li><p>部署目录，不填即整个仓库</p>
</li>
<li><p>强制使用https</p>
<p>一个是进行加密，还有一个是我在用next主题时使用http访问会有跨域问题导致图标显示不出来</p>
</li>
<li><p>点击启动</p>
</li>
<li><p>访问给出的网站地址（以我的为例：<span class="exturl" data-url="aHR0cHM6Ly9jeXNoZW5nLmdpdGVlLmlvKS8=">https://cysheng.gitee.io）</span></p>
</li>
</ul>
<h1 id="hexo-框架常用的指令："><a href="#hexo-框架常用的指令：" class="headerlink" title="hexo 框架常用的指令："></a>hexo 框架常用的指令：</h1><table>
<thead>
<tr>
<th align="left">指令</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>hexo clean &amp;&amp; hexo g</code></td>
<td align="left">清除本地项目并重新生成 （重新部署时使用）</td>
</tr>
<tr>
<td align="left"><code>hexo g</code></td>
<td align="left">重新生成</td>
</tr>
<tr>
<td align="left"><code>Hexo s</code></td>
<td align="left">开启本地预览</td>
</tr>
<tr>
<td align="left"><code>Hexo d</code></td>
<td align="left">推送到github</td>
</tr>
</tbody></table>
<h1 id="功能设置"><a href="#功能设置" class="headerlink" title="功能设置"></a>功能设置</h1><h2 id="标题和分类"><a href="#标题和分类" class="headerlink" title="标题和分类"></a>标题和分类</h2><p>在文章开头我们可以设置 FontMatter，例如</p>
<pre><code class="yml">---
title: jQuery对表单的操作及更多应用 # 标题
date: 2022-01-07 22:53:43 # 创建时间
categories: # 分类，级别递减
- web前端 # 一级分类
- web前端2 # 二级分类
tags: # 标签，没有级别
    - a1
    - a2
---
</code></pre>
<p>​	为了简化我们的操作，所以我们可以以设置模板，在 <code>/scaffolds</code> 下的 <code>draft.md</code> 、<code>page.md</code> 、 <code>post.md</code>  我们用来设置模板，例如我们最常使用的<code>post</code> 目录下的文件，所以我们配置一下<code>post.md</code></p>
<pre><code class="yaml">---
title: &#123;&#123; title &#125;&#125;
date: &#123;&#123; date &#125;&#125;
comments:
tags:
---
</code></pre>
<p><strong>问题</strong></p>
<p>如果我们在没有找到 tags 、categories 、link 、about文件时，我们手动创建</p>
<pre><code class="sh">hexo new page tags
hexo new page categories 
hexo new page link 
hexo new page about
</code></pre>
<p>成功后，提示</p>
<pre><code class="sh">INFO  Created: ~/Documents/blog/source/xxx/index.md
</code></pre>
<p>根据上面的路径，找到<code>index.md</code>这个文件，打开后默认内容是这样的：</p>
<pre><code class="yaml">---
title: 文章分类
date: 2022-01-07 22:53:43
type: &quot;categories&quot; # 哪个文件就是那个类型
layout: &quot;categories&quot; # 哪个文件就是那个类型
---
</code></pre>
<p>最后清除缓存，重新启动就行了 </p>
<pre><code class="sh">hexo cl &amp;&amp; hexo g &amp;&amp; hexo s
</code></pre>
<h2 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h2><h3 id="1、注册账号"><a href="#1、注册账号" class="headerlink" title="1、注册账号"></a>1、注册账号</h3><p>官网：<span class="exturl" data-url="aHR0cHM6Ly93d3cuYWxnb2xpYS5jb20vdXNlcnMvc2lnbl9pbg==">https://www.algolia.com/users/sign_in</span></p>
<h3 id="2、之后在左侧导航栏中找到Search"><a href="#2、之后在左侧导航栏中找到Search" class="headerlink" title="2、之后在左侧导航栏中找到Search"></a>2、之后在左侧导航栏中找到Search</h3><img data-src="/2022/10/06/bkBasic/hexo/image-20221007104401652.png" class="" title="image-20221007104401652">

<h3 id="3、创建Index"><a href="#3、创建Index" class="headerlink" title="3、创建Index"></a>3、创建Index</h3><img data-src="/2022/10/06/bkBasic/hexo/image-20221007104429043.png" class="" title="image-20221007104429043">

<img data-src="/2022/10/06/bkBasic/hexo/image-20221007104449209.png" class="" title="image-20221007104449209">

<p><strong>随便写</strong></p>
<h3 id="4、创建APPID"><a href="#4、创建APPID" class="headerlink" title="4、创建APPID"></a>4、创建APPID</h3><img data-src="/2022/10/06/bkBasic/hexo/image-20221007105625601.png" class="" title="image-20221007105625601">

<img data-src="/2022/10/06/bkBasic/hexo/image-20221007105704120.png" class="" title="image-20221007105704120">

<p>这两个后面有用</p>
<img data-src="/2022/10/06/bkBasic/hexo/image-20221007105750168.png" class="" title="image-20221007105750168">

<blockquote>
<p>Indices 是我们上面创建 index </p>
</blockquote>
<img data-src="/2022/10/06/bkBasic/hexo/20210516112405506.png" class="" title="在这里插入图片描述">



<h3 id="5、到博客根目录下安装hexo-algolia"><a href="#5、到博客根目录下安装hexo-algolia" class="headerlink" title="5、到博客根目录下安装hexo-algolia"></a>5、到博客根目录下安装hexo-algolia</h3><pre><code class="sh">npm install hexo-algolia --save
</code></pre>
<h3 id="6、前往站点根目录打开-config-yml添加以下代码"><a href="#6、前往站点根目录打开-config-yml添加以下代码" class="headerlink" title="6、前往站点根目录打开_config.yml添加以下代码"></a>6、前往站点根目录打开_config.yml添加以下代码</h3><blockquote>
<p><strong>注意：</strong>这是对全局的配置，所以是根目录的配置</p>
</blockquote>
<pre><code class="sh">algolia:
  appId:  &quot;***&quot;  #上面的application ID
  apiKey:  &quot;****&quot;  # 上面的 Search-Only API Key
  adminApiKey:  &quot;***&quot;  #上面的 Admin API Keys
  chunkSize:  5000
  indexName:  &quot;test001&quot; # Indices的index
  fields: # 要搜索的词条范围
    - title #必须配置
    - path #必须配置
    - categories #推荐配置
    - content:strip:truncate,0,2000
    - tags
</code></pre>
<p>例如：</p>
<pre><code class="yml">algolia:
  appId: &quot;Z7A3XW4R2I&quot;
  apiKey: &quot;12db1ad54372045549ef465881c17e743&quot;
  adminApiKey: &quot;40321c7c207e7f73b63a19aa24c4761b&quot;
  chunkSize: 5000
  indexName: &quot;my-hexo-blog&quot;
  fields:
    - content:strip:truncate,0,500
    - excerpt:strip
    - gallery
    - permalink
    - photos
    - slug
    - tags
    - title
</code></pre>
<h3 id="7、设置HEXO-ALGOLIA-INDEXING-KEY"><a href="#7、设置HEXO-ALGOLIA-INDEXING-KEY" class="headerlink" title="7、设置HEXO_ALGOLIA_INDEXING_KEY"></a>7、设置HEXO_ALGOLIA_INDEXING_KEY</h3><p>在博客根目录右击git bash</p>
<pre><code class="sh"># export HEXO_ALGOLIA_INDEXING_KEY=&quot;你刚才新创建的 APPKEY、appId、adminApiKey &quot;一个试一下 
export HEXO_ALGOLIA_INDEXING_KEY=&quot;******&quot; 
# 将我们的信息上川岛algolia
hexo algolia
</code></pre>
<h3 id="8、修改主题内的-config-yml"><a href="#8、修改主题内的-config-yml" class="headerlink" title="8、修改主题内的_config.yml"></a>8、修改主题内的_config.yml</h3><blockquote>
<p><strong>注意：</strong> 这是是对主题的配置</p>
</blockquote>
<pre><code class="yml">#Algolia Search
algolia_search:
  enable: true
  hits:
    per_page: 6
  labels:
    input_placeholder: Search for Posts !
    hits_empty: &#39;我们没有找到任何搜索结果：$&#123;query&#125;&#39;
    hits_stats: &#39;找到约$&#123;hits&#125;条结果 (用时$&#123;time&#125;ms)&#39;

# local searach
local_sreach:
  enable : false
</code></pre>
<h3 id="9、启动即可"><a href="#9、启动即可" class="headerlink" title="9、启动即可"></a>9、启动即可</h3><pre><code class="sh">hexo s
</code></pre>
<h3 id="10、测试"><a href="#10、测试" class="headerlink" title="10、测试"></a>10、测试</h3><img data-src="/2022/10/06/bkBasic/hexo/image-20221007123724497.png" class="" title="image-20221007123724497">

<p>参考：<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1MTczNDA0L2FydGljbGUvZGV0YWlscy8xMjI4NjEzMjE=">https://blog.csdn.net/qq_45173404/article/details/122861321</span></p>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p>&#x3D;&#x3D;toc 插件是：添加生成文章目录的一个插件&#x3D;&#x3D;</p>
<p>一、安装(这里是hexo的路径下，也就是博客根目录下)</p>
<pre><code class="shell">npm install hexo-toc --save
</code></pre>
<p>二、配置博客根目录下的_config.yml文件：</p>
<pre><code class="yml">toc:  
  maxdepth: 3 
</code></pre>
<p>在最后的空白处添加</p>
<p>三、在markdown里使用</p>
<p>在Markdown中需要显示文章目录的地方添加</p>
<pre><code class="shell">&lt;!-- toc --&gt;
</code></pre>
<p>然后就会将他&#x3D;&#x3D;后面&#x3D;&#x3D;的内容按照标题级别分层</p>
<h2 id="图片显示"><a href="#图片显示" class="headerlink" title="图片显示"></a>图片显示</h2><h3 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h3><p><strong>typroa设置</strong></p>
<p>打开typora，选择：偏好设置 - 图像 - 插入图片时，做如下更改：</p>
<blockquote>
<p>复制到指定路径</p>
<p>.&#x2F;${filename}</p>
</blockquote>
<p>当插入图片时，会生成一个和文件名相同的文件夹，并将图片存入这个文件夹内。</p>
<p><strong>Hexo 设置</strong></p>
<ol>
<li>安装 <code>hexo-renderer-marked</code></li>
</ol>
<pre><code class="sh">npm install hexo-renderer-marked --save
</code></pre>
<ol start="2">
<li>之后更改 _config.yml 配置</li>
</ol>
<pre><code class="yml">post_asset_folder: true 
</code></pre>
<p>安装插件<code>hexo-image-link </code></p>
<pre><code class="shell">npm install hexo-image-link --save
</code></pre>
<p>此时，在typora 文件中正常显示的图片，在hexo发布后依旧能正常显示。</p>
<p><strong>NOTE：</strong></p>
<ol>
<li>如果想用插件 <code>Hexo-renderer-markdown-it </code>（推荐）代替 <code>Hexo-renderer-marked </code></li>
</ol>
<pre><code class="sh">npm uninstall hexo-renderer-marker --save  #卸载 marked 

npm install hexo-renderer-markdown-it --save  #安装markdown-it
</code></pre>
<ol start="2">
<li>路径转换的解释</li>
</ol>
<p>假设：<br>文件名: .&#x2F;test.md</p>
<p>图片路径: .&#x2F;test&#x2F;image.jpg</p>
<pre><code>当插入图片 image.jpg 到 test.md 中时，typora 的引用路径为
 &#123;% asset_img image.jpg  %&#125; 

Hexo 发布后的引用路径为
![](image.jpg) 
</code></pre>
<p>因此，typora的md文件引入hexo时，应转换路径。即删掉图片路径中的 “test&#x2F;“部分；（此时md文件已不能正常显示图片，而 hexo server 可正常显示）</p>
<p>插件hexo-image-link帮助实现了这种路径转换。</p>
<p>安装后，typora 文件中正常显示的图片，在hexo发布后依旧能正常显示。</p>
<h3 id="方法2："><a href="#方法2：" class="headerlink" title="方法2："></a>方法2：</h3><blockquote>
<p>同样的思路，相对路径，</p>
</blockquote>
<p>下载插件</p>
<pre><code class="shell">npm install hexo-asset-img --save
</code></pre>
<blockquote>
<p>文件要求：</p>
<p>​	图片必须在 xx.md 同一级目录下的同名文件中存储，也就是在xx 文件夹下，所以md文档的图片路径就是	&#x3D;&#x3D;![图片注释](xx&#x2F;图片名)&#x3D;&#x3D;</p>
</blockquote>
<h2 id="每篇文章的log设置"><a href="#每篇文章的log设置" class="headerlink" title="每篇文章的log设置"></a>每篇文章的log设置</h2><pre><code>---
***
cover: 图床链接/图片路径
---
</code></pre>
<h1 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h1><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9hdXJvcmEudHJpZGlhbW9uZC50ZWNoL3poL2d1aWRlL2dldHRpbmctc3RhcnRlZC5odG1sIyVFNCVCRSU5RCVFOCVCNSU5NiVFNyU4RSVBRiVFNSVBMiU4Mw==">aurora</span>    	（最推荐）</li>
<li><span class="exturl" data-url="aHR0cHM6Ly9zaG9rYS5sb3N0eXUubWUvY29tcHV0ZXItc2NpZW5jZS9ub3RlL3RoZW1lLXNob2thLWRvYy8=">shoka</span>        （好看，但是少东西，好多要自己配）</li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL25leHQtdGhlbWUvaGV4by10aGVtZS1uZXh0">next</span>           （中等，但是好多人用，配东西好查的一批）</li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2plcnJ5YzEyNy9oZXhvLXRoZW1lLWJ1dHRlcmZseQ==">butterfly  </span>（中等，要自己配一些）</li>
</ul>
<blockquote>
<p>shoka</p>
</blockquote>
<pre><code class="shell">npm i  hexo-renderer-multi-markdown-it --save #markdown解析的
npm i  hexo-autoprefixer --save		#css\html文件压缩的
npm i  hexo-algoliasearch --save	#全文搜索的
npm i  hexo-symbols-count-time --save # 文字/时间统计
npm i  hexo-feed --save # 可选
npm un hexo-renderer-marked --save      #删除多余的库

git clone https://github.com/amehime/hexo-theme-shoka.git ./themes/shoka
</code></pre>
<p>_config.yml</p>
<pre><code class="yaml"># markdown渲染
markdown:
  render: # 渲染器设置
    html: false # 过滤 HTML 标签
    xhtmlOut: true # 使用 &#39;/&#39; 来闭合单标签 （比如 &lt;br /&gt;）。
    breaks: true # 转换段落里的 &#39;\n&#39; 到 &lt;br&gt;。
    linkify: true # 将类似 URL 的文本自动转换为链接。
    typographer: 
    quotes: &#39;“”‘’&#39;
  plugins: # markdown-it 插件设置
    - plugin:
        name: markdown-it-toc-and-anchor
        enable: true
        options: # 文章目录以及锚点应用的 class 名称，shoka 主题必须设置成这样
          tocClassName: &#39;toc&#39;
          anchorClassName: &#39;anchor&#39;
    - plugin:
        name: markdown-it-multimd-table
        enable: true
        options:
          multiline: true
          rowspan: true
          headerless: true
    - plugin:
        name: ./markdown-it-furigana
        enable: true
        options:
          fallbackParens: &quot;()&quot;
    - plugin:
        name: ./markdown-it-spoiler
        enable: true
        options:
          title: &quot;你知道得太多了&quot;

# 压缩CSS/hTML
minify:
  html:
    enable: true
    exclude: # 排除 hexo-feed 用到的模板文件
      - &#39;**/json.ejs&#39;
      - &#39;**/atom.ejs&#39;
      - &#39;**/rss.ejs&#39;
  css:
    enable: true
    exclude:
      - &#39;**/*.min.css&#39;
  js:
    enable: true
    mangle:
      toplevel: true
    output:
    compress:
    exclude:
      - &#39;**/*.min.js&#39;

#css文件后缀
autoprefixer:
  exclude:
    - &#39;*.min.css&#39;

# 全文搜索
algolia:
  appId: #Your appId
  apiKey: #Your apiKey
  adminApiKey: #Your adminApiKey
  chunkSize: 5000
  indexName: #&quot;shoka&quot;
  fields:
    - title #必须配置
    - path #必须配置
    - categories #推荐配置
    - content:strip:truncate,0,2000
    - gallery
    - photos
    - tags
    
</code></pre>
<h2 id="未完成"><a href="#未完成" class="headerlink" title="未完成"></a>未完成</h2><h1 id="Netlify部署"><a href="#Netlify部署" class="headerlink" title="Netlify部署"></a>Netlify部署</h1><blockquote>
<p><strong>前提</strong>：</p>
<pre><code>在github上建立一个仓库，权限无所谓
上传也只需要传编译后的public文件就行了
</code></pre>
</blockquote>
<ul>
<li><p><span class="exturl" data-url="aHR0cHM6Ly93d3cubmV0bGlmeS5jb20v">Netlify</span> 账号注册</p>
</li>
<li><p>添加新的站点</p>
  <img data-src="/2022/10/06/bkBasic/hexo/image-20221013222215469.png" class="" title="image-20221013222215469">

  <img data-src="/2022/10/06/bkBasic/hexo/oSa6BOtIQ8WkZX1.png" class="" title="connect-github">
</li>
<li><p>选取一个仓库，作为我们的资源地址</p>
  <img data-src="/2022/10/06/bkBasic/hexo/image-20221013222447157.png" class="" title="image-20221013222447157">
</li>
<li><p>一切默认，除了构建命令改成我们之前设置的<code>npm run netlify</code> ，当然也可以不设置</p>
<p>  前提要在<code>package.json</code> 里面添加一个 <code>netlify</code> 命令 ，例如我们的：</p>
<pre><code class="json">&quot;scripts&quot;: &#123;
        &quot;build&quot;: &quot;hexo generate&quot;,
        &quot;clean&quot;: &quot;hexo clean&quot;,
        &quot;deploy&quot;: &quot;hexo deploy&quot;,
        &quot;server&quot;: &quot;hexo server&quot;,
        // 每次提交会清除内容，然后重新建立项目，不要在项目中写这个注释，报错
        &quot;netlify&quot;: &quot;npm run clean &amp;&amp; npm run build&quot; 
  &#125;,
</code></pre>
<p>  还要有将你的全部文件上传到github，才可以使用<code>npm</code></p>
  <img data-src="/2022/10/06/bkBasic/hexo/p3P2NJaQzuIZnYs.png" class="" title="site-config"></li>
</ul>
<blockquote>
<p>这里BaseDirectory为空表示项目目录是仓库目录的根目录。</p>
</blockquote>
<ul>
<li>构建完成后我们就能够看到一个URL，打开网址就是我们的个人博客了</li>
</ul>
<img data-src="/2022/10/06/bkBasic/hexo/image-20221013223348730.png" class="" title="image-20221013223348730">

<ul>
<li><p>修改地址前缀（<strong>因为后缀不能改</strong>）</p>
<p>  网站设置—》常规—》更改站点名，完成后缀是固定的 <code> *.netlify.app</code> ，要想改变就要买域名，然后配置域名的映射。</p>
</li>
<li><p>配置域名映射</p>
  <img data-src="/2022/10/06/bkBasic/hexo/image-20221013223414819.png" class="" title="image-20221013223414819">

<ul>
<li>配置域名的前提自然是要购买域名了，从任意域名服务商处购买一个域名。</li>
</ul>
  <img data-src="/2022/10/06/bkBasic/hexo/DFHYzywifpJTxqj.png" class="" title="domian-purchase">

<ul>
<li>然后设置域名解析，类型为CNAME（DNS知识点参见计算机网络相关教程），内容为xxxxx.netlify.app，其中xxxxx为你自己设置的个性二级域名。</li>
</ul>
  <img data-src="/2022/10/06/bkBasic/hexo/5OVcw9ypvRKQePJ.png" class="" title="domain-resolve">

<ul>
<li><p>设置完毕之后需要等待一段时间，因为DNS服务器需要一段时间来进行同步。</p>
<p>  然后，我们还需要回到netlify中配置一下自己的用户域名，这样的话可以在国外获得netlify本身的CDN支持。</p>
<ul>
<li><p>在netlify设置用户域名。</p>
  <img data-src="/2022/10/06/bkBasic/hexo/MDjxbIcWBEoLURA.png" class="" title="set-custom-domain">

<ul>
<li><p>进行相关的配置，由于我们的域名本身已经配置了解析，这里会显示出来，不用再额外添加记录，只需要一路默认即可。</p>
  <img data-src="/2022/10/06/bkBasic/hexo/cqwL9xF8Eov6yVa.png" class="" title="add-record">

  <img data-src="/2022/10/06/bkBasic/hexo/RTLcjynQYXbW9vI.png" class="" title="activate-dns">
</li>
<li><p>设置一下netlify本身的对于国外CDN的支持。</p>
  <img data-src="/2022/10/06/bkBasic/hexo/8v3ROjQc2WY9q7T.png" class="" title="netlify-cdn">

<p>  之后，我们就可以通过自己配置的域名访问自己的个人博客。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>这里<code>https</code>访问需要在<code>netlify</code>中配置，否则应该只能<code>http</code>访问。<br><a href="https://s2.loli.net/2022/09/05/f3q8hPbG5vsImeY.png"><img data-src="/2022/10/06/bkBasic/hexo/f3q8hPbG5vsImeY.png" class="" title="https-config"></a><br>需要注意一下的是，此刻的https配置过程中的dns验证已经可以通过，但是证书检查会失败，等到后面clouldflare加速配置完成之后，这个问题 就可以解决了。所以暂时应该只能http访问。</p>
</blockquote>
<p>  <strong>但是，此刻我们的博客访问依然需要科学上网，因为我们还没有国内的CDN的支持，下面，我们来解决这个问题。</strong></p>
</li>
</ul>
<h1 id="ClouldFlare加速"><a href="#ClouldFlare加速" class="headerlink" title="ClouldFlare加速"></a>ClouldFlare加速</h1><h2 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h2><p>Netlify 虽然已经提供了 CDN 加速，但在使用过程中发现国内访问还是比较慢，Cloudflare 相对于国内的七牛云、阿里云等云服务商的 CDN 速度会慢一些，但是它有免费版本，而且最重要的是域名不用备案。</p>
<h2 id="加速步骤"><a href="#加速步骤" class="headerlink" title="加速步骤"></a>加速步骤</h2><ol>
<li><p>注册<span class="exturl" data-url="aHR0cHM6Ly93d3cuY2xvdWRmbGFyZS5jb20vemgtY24v">Clouldflare</span>并登陆</p>
</li>
<li><p>添加站点</p>
<ul>
<li><a href="https://s2.loli.net/2022/09/05/rqNObP5dzE6GY83.png"><img data-src="/2022/10/06/bkBasic/hexo/rqNObP5dzE6GY83.png" class="" title="add-site"></a></li>
<li><a href="https://s2.loli.net/2022/09/05/Dk3Y4BrltQeCOHI.png"><img data-src="/2022/10/06/bkBasic/hexo/Dk3Y4BrltQeCOHI.png" class="" title="config-site"></a></li>
</ul>
</li>
<li><p>选择免费套餐</p>
<ul>
<li><a href="https://s2.loli.net/2022/09/05/SrhEAvmGZeqn8Co.png"><img data-src="/2022/10/06/bkBasic/hexo/SrhEAvmGZeqn8Co.png" class="" title="choose-project"></a></li>
</ul>
</li>
<li><p>添加 DNS 记录</p>
<ul>
<li><p>一般情况下 Cloudflare 会检测出来几条 DNS 记录，类型大多数是A，或者AAAA，由于我们是转发，所以应该是 CNAME 类型才对。有必要的话可能得手动配置一下。</p>
<p>  <a href="https://s2.loli.net/2022/09/05/fSsAGV5JCeZuF1w.png"><br>  <img data-src="/2022/10/06/bkBasic/hexo/fSsAGV5JCeZuF1w.png" class="" title="update-record"></a></p>
</li>
<li><p>更改名称服务器</p>
<ul>
<li>这个步骤Cloudflare会提供一个在线的教程，主要步骤是在你的域名服务商那里修改 dns 解析服务器为 cloudflare 提供的地址，修改完成后点击完成。</li>
<li><a href="https://s2.loli.net/2022/09/05/vd2WxXGbJHmgAey.png"><img data-src="/2022/10/06/bkBasic/hexo/vd2WxXGbJHmgAey.png" class="" title="modify-server"></a></li>
<li>以阿里云为例，设置的步骤如下:<ol>
<li>进入域名的配置界面<ul>
<li><a href="https://s2.loli.net/2022/09/05/ZfLiNUejRsCyhG3.png"><img data-src="/2022/10/06/bkBasic/hexo/ZfLiNUejRsCyhG3.png" class="" title="dns-manage"></a></li>
</ul>
</li>
<li>将域名服务器从阿里云的默认服务器改成clouldflare的服务器<ul>
<li><a href="https://s2.loli.net/2022/09/05/juxWl7i9QaeLTGK.png"><img data-src="/2022/10/06/bkBasic/hexo/juxWl7i9QaeLTGK.png" class="" title="change-server"></a></li>
</ul>
</li>
</ol>
</li>
<li>配置完成后，clouldflare会有邮件通知(一般不会等太久)<br>  <a href="https://s2.loli.net/2022/09/05/JbBvp18Trne37kC.png"><img data-src="/2022/10/06/bkBasic/hexo/JbBvp18Trne37kC.png" class="" title="mail-notice"></a></li>
</ul>
</li>
</ul>
<h2 id="配置https"><a href="#配置https" class="headerlink" title="配置https"></a>配置https</h2><p> 在clouldflare配置完成之后，我们可以回到netlify去配置一下https访问。</p>
<ol>
<li>先确认一下dns解析</li>
<li>:<ul>
<li><a href="https://s2.loli.net/2022/09/05/r6iHKWLktnRap1j.png"><img data-src="/2022/10/06/bkBasic/hexo/r6iHKWLktnRap1j.png" class="" title="verify-dns"></a></li>
</ul>
</li>
<li>然后自动安装证书:<ul>
<li><a href="https://s2.loli.net/2022/09/05/KvDupBFh8b9CScN.png"><img data-src="/2022/10/06/bkBasic/hexo/KvDupBFh8b9CScN.png" class="" title="certify"></a></li>
</ul>
</li>
<li>最后看到如下的界面，就说明https配置完成了<ul>
<li><a href="https://s2.loli.net/2022/09/05/f3q8hPbG5vsImeY.png"><img data-src="/2022/10/06/bkBasic/hexo/f3q8hPbG5vsImeY.png" class="" title="https-config"></a></li>
</ul>
</li>
</ol>
<h1 id="测试站点"><a href="#测试站点" class="headerlink" title="测试站点"></a>测试站点</h1><p> 等待一段时间之后，我们可以试着用自己的浏览器去访问自己配置的域名地址，如果在不科学上网的情况下能够正常看到如下的默认页面，则我们的个人博客就配置成功了。</p>
<p> <a href="https://s2.loli.net/2022/09/05/HESMpeXbUFT3rsR.png"><img data-src="/2022/10/06/bkBasic/hexo/HESMpeXbUFT3rsR.png" class="" title="default-page"></a></p>
<p> 本机能够正常访问之后，我们可以用<span class="exturl" data-url="aHR0cHM6Ly93d3cuYm9jZS5jb20v">拨测</span>来检测一下域名解析与访问的速度。</p>
<p> <a href="https://s2.loli.net/2022/09/05/7C496Ruof1rBknM.png"><img data-src="/2022/10/06/bkBasic/hexo/7C496Ruof1rBknM.png" class="" title="speed"></a></p>
<p> 到此为止，我们的个人博客就彻底搭建完成啦。后续我们只需要修改博客的配置文件和博客本身的markdown源文件，然后push到github上，netlify会自动帮我们运行当初配置的建站脚本，然后将生成在public文件夹中的静态网页部署出去。</p>
<p> 关于hexo博客的<span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL3poLWNuL2RvY3Mvd3JpdGluZw==">写作方法</span>与各种好看的<span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL3RoZW1lcy8=">主题的配置</span>可以查看官方的文档，多尝试多摸索，配置自己的个性页面吧。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>基础使用</category>
      </categories>
      <tags>
        <tag>框架</tag>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring</title>
    <url>/2022/10/07/Spring_Family/Spring/</url>
    <content><![CDATA[<h1 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h1><ul>
<li><p>Spring是**一个轻量级 **Java开发框架，目的是为了解决企业级应用开发的业务逻辑层和其他各层的耦合问题。它是一个分层的JavaSE&#x2F;JavaEE full-stack（一站式）轻量级开源框架，为开发Java应用程序提供全面的基础架构支持。Spring负责基础架构，因此Java开发者可以专注于应用程序的开发。</p>
</li>
<li><p>Spring最根本的使命是<strong>解决企业级应用开发的复杂性，</strong>即简化<em>Java</em>开发。</p>
</li>
<li><p>Spring可以做很多事情，它为企业级开发提供给了丰富的功能，但是这些功能的底层都依赖于它的</p>
</li>
</ul>
<p>两个核心特性，也就是<strong>依赖注入（dependency injection，DI</strong>）和<strong>面向切面编程</strong>（<strong>aspect-</strong></p>
<p><strong>oriented programming，AOP）</strong>。</p>
<p>为了降低Java开发的复杂性，Spring采取了以下4种关键策略</p>
<ul>
<li><p>基于POJO的轻量级和最小侵入性编程；</p>
</li>
<li><p>通过依赖注入和面向接口实现松耦合；</p>
</li>
<li><p>基于切面和惯例进行声明式编程；</p>
</li>
<li><p>通过切面和模板减少样板式代码。</p>
</li>
</ul>
<h1 id="Spring的俩大核心概念"><a href="#Spring的俩大核心概念" class="headerlink" title="Spring的俩大核心概念"></a>Spring的俩大核心概念</h1><h2 id="IOC（控制翻转）："><a href="#IOC（控制翻转）：" class="headerlink" title="IOC（控制翻转）："></a>IOC（控制翻转）：</h2><p>控制翻转，也叫依赖注入，他就是不会直接创建对象，只是把对象声明出来，在代码 中不直</p>
<p>接与对象和服务进行连接，但是在配置文件中描述了哪一项组件需要哪一项服 务，容器将他</p>
<p>们组件起来。在一般的IOC场景中容器创建了所有的对象，并设置了必 要的属性将他们联系</p>
<p>在一起，等到需要使用的时候才把他们声明出来，使用注解就跟 方便了，容器会自动根据注</p>
<p>解把对象组合起来</p>
<h2 id="其中还有一个点DI-依赖注入"><a href="#其中还有一个点DI-依赖注入" class="headerlink" title="其中还有一个点DI(依赖注入)"></a>其中还有一个点DI(依赖注入)</h2><h2 id="AOP（面对切面编程）"><a href="#AOP（面对切面编程）" class="headerlink" title="AOP（面对切面编程）"></a>AOP（面对切面编程）</h2><p>面对切面编程，这是一种编程模式，他允许程序员通过自定义的横切点进行模块 化，将那些</p>
<p>影响多个类的行为封装到课重用的模块中。 例子：比如日志输出，不使用AOP的话就需要把</p>
<p>日志的输出语句放在所有类中，方法 中，但是有了AOP就可以把日志输出语句封装一个可重</p>
<p>用模块，在以声明的方式将他 们放在类中，每次使用类就自动完成了日志输出。</p>
<h1 id="Bean的生命周期"><a href="#Bean的生命周期" class="headerlink" title="Bean的生命周期"></a>Bean的生命周期</h1><p>1 通过构造器创建bean实例           执行构造器<br>2 为bean属性赋值                         执行set方法<br>3 初始化bean                                调用bean的初始化方法,需要配置指定调用的方法<br>4 bean的获取                                容器对象 getBean方法<br>5 容器关闭销毁bean                      调用销毁方法,需要配置指定调用的方法</p>
<pre><code class="java">public class User &#123;
    private Integer userid;
    private String username;
    private String password;
    public void initUser()&#123;
        System.out.println(&quot;第三步:User初始化&quot;);
    &#125;
    public User() &#123;
        System.out.println(&quot;第一步:User构造&quot;);
    &#125;
    public void destoryUser()&#123;
        System.out.println(&quot;第五步:User销毁&quot;);
    &#125;
    @Override
    public String toString() &#123;
        return &quot;User&#123;&quot; +
                &quot;userid=&quot; + userid +
                &quot;, username=&#39;&quot; + username + &#39;\&#39;&#39; +
                &quot;, password=&#39;&quot; + password + &#39;\&#39;&#39; +
                &#39;&#125;&#39;;
    &#125;
    public User(Integer userid, String username, String password) &#123;
        this.userid = userid;
        this.username = username;
        this.password = password;
    &#125;
    public void setUserid(Integer userid) &#123;
        System.out.println(&quot;setUserid&quot;);
        this.userid = userid;
    &#125;
    public void setUsername(String username) &#123;
        System.out.println(&quot;第二步:User属性赋值&quot;);
        this.username = username;
    &#125;
    public void setPassword(String password) &#123;
        this.password = password;
    &#125;
&#125;
</code></pre>
<p>配置Bean</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:p=&quot;http://www.springframework.org/schema/p&quot;
       xmlns:c=&quot;http://www.springframework.org/schema/c&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;
    &lt;!--  --&gt;
    &lt;bean id=&quot;user&quot; class=&quot;com.msb.bean.User&quot; init-method=&quot;initUser&quot; destroy-method=&quot;destoryUser&quot;&gt;
        &lt;property name=&quot;username&quot; value=&quot;xiaoming&quot;&gt;&lt;/property&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<p>根据 Class、property 通过反射去找构造器创建实例，然后对property属性根据 set 方法注入依赖也叫赋值，</p>
<p>通过指定 init-method(初始化方法) 来对我们的对象再次进行操作，第四步获取 Bean 对象，第五步项目结束Context销毁，调用销毁方法销毁Bean</p>
<p>&#x3D;&#x3D;以上我们是对一般的过程其实在这个基础上我们还可以再次增加两步，这个叫后置处理器，处理后的顺序：&#x3D;&#x3D;</p>
<p>1 通过构造器创建bean实例           执行构造器<br>2 为bean属性赋值                         执行set方法<br><font color=red>3 把bean实例传递给bean的后置处理器的方法</font><br>4 初始化bean                                调用bean的初始化方法,需要配置指定调用的方法<br><font color=red>5 把bean实例传递给bean的后置处理器的方法</font><br>6 bean的获取                                容器对象 getBean方法<br>7 容器关闭销毁bean                      调用销毁方法,需要配置指定调用的方法</p>
<p>&#x3D;&#x3D;添加后置处理器&#x3D;&#x3D;</p>
<p><strong>1 创建后置处理器 实现 BeanPostProcesser  重写两个方法</strong></p>
<pre><code class="java">
import org.springframework.beans.BeansException;
import org.springframework.beans.factory.config.BeanPostProcessor;
// 1 创建后置处理器 实现 BeanPostProcesser  重写两个方法
public class MyBeanProcesser implements BeanPostProcessor &#123;
    @Override
    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException &#123;
        //Object bean      实例化的bean
        //String beanName  bean的id
        System.out.println(&quot;bean:初始化方法之前&quot;);
        return bean;// 这里必须return bean
    &#125;
    @Override
    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123;
        System.out.println(&quot;bean:初始化方法之后&quot;);
        return bean;// 这里必须returnbean
    &#125;
&#125;
</code></pre>
<p><strong>2 配置后置处理器,对容器中的所有bean添加后置处理器的生命周期</strong></p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:p=&quot;http://www.springframework.org/schema/p&quot;
       xmlns:c=&quot;http://www.springframework.org/schema/c&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;
    &lt;bean id=&quot;user&quot; class=&quot;com.msb.bean.User&quot; init-method=&quot;initUser&quot; destroy-method=&quot;destoryUser&quot;&gt;
        &lt;property name=&quot;username&quot; value=&quot;xiaoming&quot;&gt;&lt;/property&gt;
    &lt;/bean&gt;
    
    &lt;bean id=&quot;myBeanProcesser&quot; class=&quot;com.msb.beanProcesser.MyBeanProcesser&quot;&gt;&lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<p><strong>BeanPostProcessor接口作用：</strong></p>
<blockquote>
<p>如果我们想在Spring容器中完成bean实例化、配置以及其他初始化方法前后要添加一些自己逻辑处理。我们需要定义一个或多个BeanPostProcessor接口实现类，然后注册到Spring IoC容器中。</p>
</blockquote>
<p>1、接口中的两个方法都要将传入的bean返回，而不能返回null，如果返回的是null那么我们通过getBean方法将得不到目标。<br>2、ApplicationContext会自动检测在配置文件中实现了BeanPostProcessor接口的所有bean，并把它们注册为后置处理器，然后在容器创建bean的适当时候调用它，因此部署一个后置处理器同部署其他的bean并没有什么区别。而使用BeanFactory实现的时候，bean 后置处理器必须通过代码显式地去注册，在IoC容器继承体系中的ConfigurableBeanFactory接口中定义了注册方法</p>
<p><strong>总结</strong></p>
<p>完整的过程：</p>
<blockquote>
<p>创建实例 –&gt; set赋值 –&gt; 再次初始化对象–&gt; 获取Bean对象–&gt; 销毁Bean对象</p>
<p>创建实例 –&gt; set赋值 –&gt;把bean实例传递给bean的后置处理器的方法 –&gt; 再次初始化对象 –&gt; 把bean实例传递给bean的后置处理器的方法 —&gt; 获取Bean对象–&gt; 销毁Bean对象</p>
</blockquote>
<h1 id="Bean自动装配"><a href="#Bean自动装配" class="headerlink" title="Bean自动装配"></a>Bean自动装配</h1><p>通过property标签可以手动指定给属性进行注入<br>我们也可以通过自动转配,完成&#x3D;&#x3D;属性的自动注入&#x3D;&#x3D;,就是自动装配,可以简化DI的配置</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:p=&quot;http://www.springframework.org/schema/p&quot;
       xmlns:c=&quot;http://www.springframework.org/schema/c&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;
    &lt;bean id=&quot;dept&quot; class=&quot;com.msb.bean.Dept&quot;&gt;&lt;/bean&gt;
    &lt;!--
    autowire 属性控制自动将容器中的对象注入到当前对象的属性上
    byName 根据目标id值和属性值注入,要保证当前对象的属性值和目标对象的id值一致
    byType 根据类型注入,要保证相同类型的目标对象在容器中只有一个实例
    --&gt;
    &lt;bean id=&quot;emp&quot; class=&quot;com.msb.bean.Emp&quot; autowire=&quot;byName&quot;&gt;&lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<h1 id="Spring注解管理Bean"><a href="#Spring注解管理Bean" class="headerlink" title="Spring注解管理Bean"></a>Spring注解管理Bean</h1><h2 id="1注解方式创建对象IOC"><a href="#1注解方式创建对象IOC" class="headerlink" title="1注解方式创建对象IOC"></a>1注解方式创建对象IOC</h2><p>导入依赖 aop</p>
<p>@Component    放在类上,用于标记,告诉spring当前类需要由容器实例化bean并放入容器中<br>  该注解有三个子注解<br>  @Controller   用于实例化controller层bean<br>        @Service        用于实例化service层bean<br>        @Repository  用于实例化持久层bean<br>  当不确定是哪一层,就用Component<br>这几个注解互相混用其实也可以,但是不推荐</p>
<h2 id="2注解方式依赖注入DI"><a href="#2注解方式依赖注入DI" class="headerlink" title="2注解方式依赖注入DI"></a>2注解方式依赖注入DI</h2><p>@Autowired   根据属性数据类型自动装配<br>@Qualifier      根据属性名称注入依赖<br>@Resources   可以根据类型,也可以根据名称注入<br>@Value           注入普通数据类型(8+String)</p>
<pre><code class="java">// 详解 
/*
    * @Autowired
    * 根据类型到容器中去寻找对应的对象,找到后给当前属性赋值
    * 不需要依赖 set方法
    * 属性类型可以是接口,会自动匹配对应的实现类对象
    * @Autowired配合 @Qualifier,可以通过名称指定注入的对象
    *
    * @Resource 如果不配置name 那么就是根据类型注入
    * @Resource(name=&quot;userDaoImplB&quot;) 配置name,就是根据名称注入
    *
    *
    * @Resource  是JDK中javax包的注解
    * @Autowired 和 @Qualifier 是spring中的注解
    *
    * @Value 可以个普通属性赋值
    * @Value 可以使用$&#123;&#125;这种表达式获取系统的变量值
    *        或者是.properties属性配置文件中的值
    *
    * */
</code></pre>
<h1 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h1><p><em>概念</em>：在使用对象的时候，不直接使用用一个代理对象代理他，这样可以在目标<strong>对象基础上增强额外的功能</strong>。</p>
<p><em>分类</em>：静态代理，动态代理</p>
<h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h2><blockquote>
<p>​	静态代理中<strong>代理类</strong>与<strong>被代理类</strong>都<strong>需要实现同一个接口</strong>，这就说明我们的<strong>一个静态代理类只能代理一个类</strong>，并且还要事先知道我们<strong>要代理哪个类才能写代理类</strong>，如果我们<strong>有其他类还想使用代理那就必须再写一个代理类</strong>。</p>
</blockquote>
<p>​	然而在实际开发中我们是可能是有非常多的类是需要被代理的，并且事先我们可能并不知道我们要代理哪个类。所以如果继续使用静态代理反而会增加许多的工作量，并且<strong>效率低下</strong>，<strong>代码复用率也不好</strong>。</p>
<pre><code class="java">public class Test1 &#123;
    public static void main(String[] args) &#123;
        /**
        lawyer律师代替Person张三打官司，不用张三直接打，可以更加清楚
        */
        Person person =new Person(&quot;张三&quot;);
        Court court=new Lawyer(person);
        court.doCourt();
    &#125;
&#125;
// 接口
interface Court&#123;
    void doCourt();
&#125;
// 代理类
class Lawyer implements Court&#123;
    private Person person;
    public Lawyer(Person person) &#123;
        this.person = person;
    &#125;
    @Override
    public void doCourt() &#123;
        System.out.println(&quot;律师取证:视频证明张三当时正在旅游,不在案发现场&quot;);
        System.out.println(&quot;律师总结:张三不可能去杀人&quot;);
        person.doCourt();
    &#125;
&#125;
// 被代理的类
class Person implements Court&#123;
    private String name;
    public Person(String name) &#123;
        this.name = name;
    &#125;
    @Override
    public void doCourt() &#123;
        System.out.println(name+&quot;说:我没有杀人&quot;);
    &#125;
&#125;
</code></pre>
<h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p><em>概念</em>：动态代理可以<strong>针对</strong>于一些<strong>不特定的类</strong>或者一些<strong>不特定的方法</strong>进行代理,我们可以在程序运行时动态的变化代理的规则，<strong>代理类在程序运行时才创建的代理模式成为动态代理</strong>。这种情况下，代理类并不是在Java代码中定义好的，而是在程序运行时根据我们的在Java代码中的“指示”动态生成的</p>
<p>实现方法：JDK自带的Proxy、CJlib</p>
<table>
<thead>
<tr>
<th align="center"><strong>Proxy</strong></th>
<th align="center"><strong>JDK动态代理</strong></th>
<th align="center"><strong>面向接口</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><em><strong>cglib</strong></em></td>
<td align="center"><em><strong>第三方动态代理</strong></em></td>
<td align="center"><em><strong>面向父类</strong></em></td>
</tr>
</tbody></table>
<p>实现案例：</p>
<p>Proxy:</p>
<pre><code class="java">public class ProxyTest1 &#123;

    public static void main(String[] args) &#123;
        Dinner dinner = new Person(&quot;张三&quot;);
        ClassLoader loader = dinner.getClass().getClassLoader();
        Class&lt;?&gt;[] interfaces = dinner.getClass().getInterfaces();
        /*
           Object proxy, 代理对象
           Method method,被代理的方法
           Object[] args,被代理方法运行时的实参
         */
        /*InvocationHandler invocationHandler = (proxy,
                                              method,
                                              params)-&gt;&#123;
            System.out.println(&quot;invoked 方法执行&quot;);

            return null;
        &#125;;*/
        InvocationHandler invocationHandler = new InvocationHandler() &#123;
            @Override
            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;
                Object res = new Object();

                if (method.getName().equals(&quot;eat&quot;)) &#123;
                    System.out.println(&quot;饭前洗手&quot;);
                    // 让原有的eat的方法去运行
                    res =method.invoke(dinner, args);
                    System.out.println(&quot;饭后刷碗&quot;);
                &#125;
                else&#123;
                    // 如果是其他方法,那么正常执行就可以了
                    res =method.invoke(dinner, args);
                &#125;
                return res;
            &#125;
        &#125;;

        /**
         * 动态代理
         * 需要三次个参数 loader代理类，增强的对象，
         *              interfaces 实现的接口，
         *              增强方法 invoke()
         */
        Dinner dinner1 = (Dinner) Proxy.newProxyInstance(loader,interfaces,invocationHandler);
        dinner1.eat(&quot;包子&quot;);
    &#125;
&#125;
interface Dinner&#123;
    void eat(String foodName);
    void drink();
&#125;

class Person implements Dinner&#123;
    private String name;
    public Person(String name) &#123;
        this.name = name;
    &#125;
    @Override
    public void eat(String foodName) &#123;
        System.out.println(name+&quot;正在吃&quot;+foodName);
    &#125;
    @Override
    public void drink( ) &#123;
        System.out.println(name+&quot;正在喝茶&quot;);
    &#125;
&#125;
class Student implements Dinner&#123;
    private String name;
    public Student(String name) &#123;
        this.name = name;
    &#125;
    @Override
    public void eat(String foodName) &#123;
        System.out.println(name+&quot;正在食堂吃&quot;+foodName);
    &#125;
    @Override
    public void drink( ) &#123;
        System.out.println(name+&quot;正在喝可乐&quot;);
    &#125;
&#125;
</code></pre>
<p>Cglib</p>
<pre><code class="java">public class ProxyTest2 &#123;

    public static void main(String[] args) &#123;
        // 获取一个Person的代理对象
        Person person = new Person();
        // 1 获得一个Enhancer对象
        Enhancer enhancer = new Enhancer();
        // 2 设置父类字节码
        enhancer.setSuperclass(Person.class);
        // 3 获取MethodIntercepter对象 用于定义增强规则
        MethodInterceptor methodInterceptor = new MethodInterceptor() &#123;
            /*
            * Object o 生成之后的代理对象 personProxy
            * Method method 父类中原本要执行的方法  Person&gt;&gt;&gt; eat()要增强的方法（还没有被增强，父类方法）
            * Object[] objects 实际传入的参数
            * MethodProxy methodProxy 子类中重写父类的方法 personProxy &gt;&gt;&gt; eat()代理对象增强的方法（增强的方法，子类对象）
            * */
            @Override
            public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable &#123;
                Object res = null;

                if (method.getName().equals(&quot;eat&quot;)) &#123;
                    System.out.println(&quot;饭前洗手&quot;);
                    res=methodProxy.invokeSuper(o,objects);
                    System.out.println(&quot;饭后刷碗&quot;);
                &#125;else&#123;
                    // 如果是其他方法 不增强运行
                    res=methodProxy.invokeSuper(o,objects); // 子类对象方法在执行,默认会调用父类对应被重写的方法
                &#125;
                return res;
            &#125;
        &#125;;
        // 4 设置methodInterceptor
        enhancer.setCallback(methodInterceptor);
        // 5 获得代理对象
        Person personProxy = (Person)enhancer.create();
        // 6 使用代理对象完成功能
        personProxy.eat(&quot;包子&quot;);
    &#125;
&#125;

class Person  &#123;
    public Person( ) &#123;
    &#125;
    public void eat(String foodName) &#123;
        System.out.println(&quot;张三正在吃&quot;+foodName);
    &#125;
&#125;
</code></pre>
<blockquote>
<p>总结</p>
</blockquote>
<ul>
<li>在<strong>不修改原有代码</strong>的 或者没有办法修改原有代码的情况下  <strong>增强对象功能</strong>  <strong>使用代理对象</strong> 代替原来的对象去完成功能进而达到拓展功能的目的</li>
<li><strong>JDK Proxy 动态代理面向接口的动态代理</strong>  一定<strong>要有接口</strong>和<strong>实现类</strong>的存在 代理对象<strong>增强的是实现类</strong> 在实现接口的方法重写的方法   生成的代理对象只能转换成 接口的不能转换成 被代理类代理对象只能增强接口中定义的方法  <strong>实现类中其他和接口无关的方法是无法增强的代理对象只能读取到接口中方法上的注解 不能读取到实现类方法上的注解</strong></li>
</ul>
<h1 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h1><p>全名：Aspect Oriented Programmings，面向切面编程，通过<strong>预编译</strong>和<strong>运行时生成动态代理</strong>实现程序功能的统一维护的一种技术。AOP是OOP的延续，是Spring框架的一个重要内容，是函数式编程的一种衍生范式。利用AOP可以对业务逻辑的各个部分进行隔离，从而使各个部分的耦合性降低，提高程序的可重用行，提高开发效率。</p>
<hr>
<p>AOP切面编程一般可以帮助我们在不修改现有代码的情况下,对程序的功能进行拓展,往往用于实现 日志处理,权限控制,性能检测,事务控制等<br>AOP实现的原理就是动态代理,在有接口的情况下,使用JDK动态代理,在没有接口的情况下使用cglib动态代理</p>
<img data-src="/2022/10/07/Spring_Family/Spring/image-20220716162550876.png" class="">




<p>AOP中的术语辨析</p>
<p>1 连接点 Joint point：类里面那些可以被增强的方法</p>
<p>2 切入点 Pointcu：实际被增强的方法,称之为切入点</p>
<p>3 通知 Advice:：实际增强的逻辑部分称为通知 (增加的功能)</p>
<p>4 目标对象 Target：被增强功能的对象(被代理的对象)</p>
<p>5 切面Aspect： 表现为功能相关的一些advice方法放在一起声明成的一个Java类</p>
<p>6 织入 Weaving：创建代理对象并实现功能增强的声明并运行过程</p>
<p>具体操作</p>
<pre><code class="java">/*
事先准备 dao 以及他的实现类
我们直接编写 Aspect 层的代码
*/

@Component
@Aspect
public class DaoAspect &#123;
    /*
    切入点表达式: 通过一个表达式来确定AOP要增强的是哪个或者那些方法
    语法结构:execution([权限修饰符][返回值类型][类的全路径名][方法名](参数 列表) )
    execution(* com.msb.dao.UserDaoImpl.add(..))   //指定切点为UserDaoImpl.add方法
    execution(* com.msb.dao.UserDaoImpl.*(..))     //指定切点为UserDaoImpl.所有的方法
    execution(* com.msb.dao.*.*(..))               //指定切点为dao包下所有的类中的所有的方法
    execution(* com.msb.dao.*.add(..))             // 指定切点为dao包下所有的类中的add的方法
    execution(* com.msb.dao.*.add*(..))            // 指定切点为dao包下所有的类中的add开头的方法
    *  */
    //定义公共切点
    @Pointcut(&quot;execution( * com.zjj.aop.dao.*.add*(..) )&quot;)
    public void addPointCut()&#123;

    &#125;

    /*
     * 前置通知: 切点方法执行之前先执行的功能
     * 参数列表可以用JoinPoint接收切点对象
     * 可以获取方法执行的参数
     * */
    @Before(&quot;addPointCut()&quot;) // 这里用了公共切点，不然又要写一次公共切点上的 @PointCut()
    public void methodBefore(JoinPoint joinPoint) &#123;
        System.out.println(&quot;Before invoked&quot;);
    &#125;


    /*
     * 后置通知:方法执行之后要增强的功能
     * 无论切点方法是否出现异常都会执行的方法
     * 参数列表可以用JoinPoint接收切点对象
     * */
    @After(&quot;addPointCut()&quot;)
    public void methodAfter(JoinPoint joinPoint)&#123;
        System.out.println(&quot;After invoked&quot;);
    &#125;

    /*
     * 返回通知:切点方法正常运行结束后增强的功能
     * 如果方法运行过程中出现异常,则该功能不运行
     * 参数列表可以用 JoinPoint joinPoint接收切点对象
     * 可以用Object res接收方法返回值,需要用returning指定返回值名称
     * */
    @AfterReturning( value = &quot;addPointCut()&quot;,returning = &quot;res&quot;)
    public void methodAfterReturning(JoinPoint joinPoint,Object res)&#123;
        System.out.println(&quot;AfterReturning invoked&quot;);
    &#125;
    /*
     * 异常通知:切点方法出现异常时运行的增强功能
     * 如果方法运行没有出现异常,则该功能不运行
     * 参数列表可以用Exception ex接收异常对象 需要通过throwing指定异常名称
     * */
    @AfterThrowing( value = &quot;addPointCut()&quot;,throwing = &quot;ex&quot;)
    public void methodAfterThrowing(Exception ex)&#123;
        System.out.println(&quot;AfterThrowing invoked&quot;);
    &#125;

    /*环绕通知:在切点方法之前和之后都进行功能的增强
     * 需要在通知中定义方法执行的位置,并在执行位置之前和之后自定义增强的功能
     * 方法列表可以通过ProceedingJoinPoint获取执行的切点
     * 通过proceedingJoinPoint.proceed()方法控制切点方法的执行位置
     * proceedingJoinPoint.proceed()方法会将切点方法的返回值获取到,并交给我们,可以做后续处理
     * 我们在环绕通知的最后需要将切点方法的返回值继续向上返回,否则切点方法在执行时接收不到返回值
     * */
    @Around(&quot;addPointCut()&quot;)
    public Object methodAround(ProceedingJoinPoint proceedingJoinPoint) throws Throwable &#123;
        System.out.println(&quot;aroundA invoked&quot;);
        Object proceed = proceedingJoinPoint.proceed();
        System.out.println(&quot;aroundB invoked&quot;);
        return proceed;
    &#125;

&#125;
</code></pre>
<p>测试</p>
<pre><code class="java">@SpringBootTest(classes = MyAOPSpringApplication.class)
public class SpringAOPTests &#123;
    @Resource
    ApplicationContext context;
    @Test
    public void t1() &#123;
        UserService userService = context.getBean(UserService.class);
        userService.addUser(10, &quot;小明&quot;);
    &#125;
&#125;
</code></pre>
<p>结果：</p>
<blockquote>
<p>aroundA invoked</p>
<p>Before invoked</p>
<p>userDao add … …</p>
<p>AfterReturning invoked</p>
<p>After invoked</p>
<p>aroundB invoked</p>
</blockquote>
<p>面试题</p>
<p>如果在不使用框架的前提下你要做权限的校验你会怎么做?</p>
<blockquote>
<p>我会在要鉴权的方法加入环绕通知，在请求到方法前先进行一次查找，一般这些数据我们会在redis中也会存储一个，第一次查过来我们去redis中找，找到直接让他操作并且在之后提交事务，但是没找到的时候我们先让他去操作，但是不提交事务，同时去数据库中查找他的信息，找到后添加redis，提交事务，没找到就回滚事务即可。</p>
</blockquote>
<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><h2 id="事务的概念"><a href="#事务的概念" class="headerlink" title="事务的概念"></a>事务的概念</h2><p>事务（Transaction）指的是一个操作序列，该操作序列中的多个操作要么都做，要么都不做，是一个不可分割的工作单位，是数据库环境中的逻辑工作单位，由DBMS中的事务管理子系统负责事务的处理。</p>
<p>目前常用的存储引擎有InnoDB（MySQL5.5以后默认的存储引擎）和MyISAM（MySQL5.5之前默认的存储引擎），其中InnoDB支持事务处理机制，而MyISAM不支持。</p>
<h2 id="事务的特性"><a href="#事务的特性" class="headerlink" title="事务的特性"></a>事务的特性</h2><p>事务处理可以确保除非事务性序列内的所有操作都成功完成，否则不会永久更新面向数据的资源。通过将一组相关操作组合为一个要么全部成功要么全部失败的序列，可以简化错误恢复并使应用程序更加可靠。</p>
<p>但并不是所有的操作序列都可以称为事务，这是因为一个操作序列要成为事务，必须满足事务的原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）和持久性（Durability）。这四个特性简称为ACID特性。</p>
<img data-src="/2022/10/07/Spring_Family/Spring/image-20220716210341261.png" class="">


<ol>
<li><pre><code>原子性
</code></pre>
</li>
</ol>
<p>原子是自然界最小的颗粒，具有不可再分的特性。事务中的所有操作可以看做一个原子，事务是应用中不可再分的最小的逻辑执行体。</p>
<p>使用事务对数据进行修改的操作序列，要么全部执行，要么全不执行。通常，某个事务中的操作都具有共同的目标，并且是相互依赖的。如果数据库系统只执行这些操作中的一部分，则可能会破坏事务的总体目标，而原子性消除了系统只处理部分操作的可能性。</p>
<ol start="2">
<li><pre><code> 一致性
</code></pre>
</li>
</ol>
<p>一致性是指事务执行的结果必须使数据库从一个一致性状态，变到另一个一致性状态。当数据库中只包含事务成功提交的结果时，数据库处于一致性状态。一致性是通过原子性来保证的。</p>
<p>例如：在转账时，只有保证转出和转入的金额一致才能构成事务。也就是说事务发生前和发生后，数据的总额依然匹配。</p>
<ol start="3">
<li><pre><code> 隔离性
</code></pre>
</li>
</ol>
<p>隔离性是指各个事务的执行互不干扰，任意一个事务的内部操作对其他并发的事务，都是隔离的。也就是说：并发执行的事务之间既不能看到对方的中间状态，也不能相互影响。</p>
<p>例如：在转账时，只有当A账户中的转出和B账户中转入操作都执行成功后才能看到A账户中的金额减少以及B账户中的金额增多。并且其他的事务对于转账操作的事务是不能产生任何影响的。</p>
<ol start="4">
<li><pre><code>持久性
</code></pre>
</li>
</ol>
<p>持久性指事务一旦提交，对数据所做的任何改变，都要记录到永久存储器中，通常是保存进物理数据库，即使数据库出现故障，提交的数据也应该能够恢复。但如果是由于外部原因导致的数据库故障，如硬盘被损坏，那么之前提交的数据则有可能会丢失。</p>
<h2 id="事务的并发问题"><a href="#事务的并发问题" class="headerlink" title="事务的并发问题"></a>事务的并发问题</h2><p>脏读（Dirty read）</p>
<p>当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。</p>
<img data-src="/2022/10/07/Spring_Family/Spring/image-20220716210633569.png" class="">


<p>不可重复读</p>
<p>（Unrepeatableread）: 指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。</p>
<img data-src="/2022/10/07/Spring_Family/Spring/image-20220716210640447.png" class="">


<p>幻读</p>
<p>（Phantom read）: 幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。</p>
<img data-src="/2022/10/07/Spring_Family/Spring/image-20220716210646452.png" class="">


<p><strong>不可重复度和幻读区别：</strong></p>
<p>不可重复读的重点是修改，幻读的重点在于新增或者删除。</p>
<p><strong>解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表</strong></p>
<p>例1（同样的条件, 你读取过的数据, 再次读取出来发现值不一样了 ）：事务1中的A先生读取自己的工资为 1000的操作还没完成，事务2中的B先生就修改了A的工资为2000，导 致A再读自己的工资时工资变为 2000；这就是不可重复读。</p>
<p>例2（同样的条件, 第1次和第2次读出来的记录数不一样 ）：假某工资单表中工资大于3000的有4人，事务1读取了所有工资大于3000的人，共查到4条记录，这时事务2又插入了一条工资大于3000的记录，事务1再次读取时查到的记录就变为了5条，这样就导致了幻读</p>
<h2 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h2><p>事务的隔离级别用于决定如何控制并发用户读写数据的操作。数据库是允许多用户并发访问的，如果多个用户同时开启事务并对同一数据进行读写操作的话，有可能会出现脏读、不可重复读和幻读问题，所以MySQL中提供了四种隔离级别来解决上述问题。</p>
<p>事务的隔离级别从低到高依次为READ UNCOMMITTED、READ COMMITTED、REPEATABLE READ以及SERIALIZABLE，隔离级别越低，越能支持高并发的数据库操作。</p>
<p>​                                   </p>
<h2 id="spring中可以使用如下方式实现事务的控制"><a href="#spring中可以使用如下方式实现事务的控制" class="headerlink" title="spring中可以使用如下方式实现事务的控制"></a>spring中可以使用如下方式实现事务的控制</h2><p>1 编程式(不推荐)</p>
<p>2 声明式(掌握)</p>
<p>​	1) 注解(简单,必会)</p>
<p>​	2) XML配置(繁琐,了解)</p>
<p>  <strong>Spring声明式事务的实现方式,底层就是AOP,AOP的底层就是动态代理</strong></p>
<p>Spring事务管理相关的API</p>
<p>事务管理器接口: PlatformTransactionManager  针对不同的框架,提供了不同的实现类</p>
<img data-src="/2022/10/07/Spring_Family/Spring/image-20220716210813110.png" class="">


<p>注解方式实现事务控制<br>在applicationContext.xml配置事务相关的配置</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:p=&quot;http://www.springframework.org/schema/p&quot;
       xmlns:c=&quot;http://www.springframework.org/schema/c&quot;
       xmlns:util=&quot;http://www.springframework.org/schema/util&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
       xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;
       xsi:schemaLocation=&quot;
       http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/util
       http://www.springframework.org/schema/util/spring-util.xsd
       http://www.springframework.org/schema/context
       http://www.springframework.org/schema/context/spring-context.xsd
       http://www.springframework.org/schema/aop
       http://www.springframework.org/schema/aop/spring-aop.xsd
       http://www.springframework.org/schema/tx
       http://www.springframework.org/schema/tx/spring-tx.xsd
&quot;&gt;
    &lt;!--spring 注解扫描--&gt;
    &lt;context:component-scan base-package=&quot;com.msb&quot;/&gt;
    &lt;!--读取jdbc配置文件--&gt;
    &lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot;/&gt;
    &lt;!--配置德鲁伊连接池--&gt;
    &lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt;
        &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc_username&#125;&quot;&gt;&lt;/property&gt;
        &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc_password&#125;&quot;&gt;&lt;/property&gt;
        &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc_url&#125;&quot;&gt;&lt;/property&gt;
        &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;jdbc_driver&#125;&quot;&gt;&lt;/property&gt;
    &lt;/bean&gt;
    &lt;!--配置JDBCTemplate对象,并向里面注入DataSource--&gt;
    &lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt;
        &lt;!--通过set方法注入连接池--&gt;
        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;
    &lt;/bean&gt;
    &lt;!--配置一个事务管理器--&gt;
    &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;
        &lt;!--将数据源注入事务管理器--&gt;
        &lt;property name=&quot;dataSource&quot;  ref=&quot;dataSource&quot;&gt;&lt;/property&gt;
    &lt;/bean&gt;
    &lt;!--开启事务注解--&gt;
    &lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot;/&gt;
&lt;/beans&gt;
</code></pre>
<pre><code class="java">@Service
//@Transactional //加在类上,代表类中的所有方法都添加了事务控制
public class AccountServiceImpl implements AccountService &#123;
    @Autowired
    private AccountDao accountDao;
    @Override
    @Transactional// 放在方法上,就是仅仅对当前方法增加了事务控制
    public int transMoney(int from, int to, int money) &#123;
        int rows=0;
        rows+=accountDao.transMoney(from, 0 - money);
        int i =1/0;
        rows+=accountDao.transMoney(to, money);
        return rows;
    &#125;
&#125;
</code></pre>
<p>再次测试,就算是service方法运行出现异常,自动会回滚,如果没有,那么自动提交</p>
<p>@Transactional 注解的一些参数和参数的含义<br>@Transactional(propagation &#x3D; Propagation.REQUIRED,isolation &#x3D; Isolation.READ_UNCOMMITTED,readOnly &#x3D; true,rollbackFor &#x3D; ClassCastException.class,noRollbackFor &#x3D; NullPointerException.class,timeout &#x3D; 10)</p>
<pre><code class="java">@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)
@Retention(RetentionPolicy.RUNTIME)
@Inherited
@Documented
public @interface Transactional &#123;
    @AliasFor(&quot;transactionManager&quot;)
    String value() default &quot;&quot;;
    @AliasFor(&quot;value&quot;)
    String transactionManager() default &quot;&quot;;
    String[] label() default &#123;&#125;;
    Propagation propagation() default Propagation.REQUIRED;
    Isolation isolation() default Isolation.DEFAULT;
    int timeout() default -1;
    String timeoutString() default &quot;&quot;;
    boolean readOnly() default false;
    Class&lt;? extends Throwable&gt;[] rollbackFor() default &#123;&#125;;
    String[] rollbackForClassName() default &#123;&#125;;
    Class&lt;? extends Throwable&gt;[] noRollbackFor() default &#123;&#125;;
    String[] noRollbackForClassName() default &#123;&#125;;
&#125;
</code></pre>
<h2 id="propagation-事务的传播行为-面试"><a href="#propagation-事务的传播行为-面试" class="headerlink" title="propagation  事务的传播行为(面试)"></a>propagation  事务的传播行为(面试)</h2><p>多事务方法之间调用,事务是如何管理的</p>
<table>
<thead>
<tr>
<th align="center">事务传播行为类型</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">PROPAGATION_REQUIRED</td>
<td align="center">如果当前没有事务，就新建一个事务，如果已经存在一个事务中，加入到这个事务中。这是最常见的选择(默认)。</td>
</tr>
<tr>
<td align="center">PROPAGATION_SUPPORTS</td>
<td align="center">支持当前事务，如果当前没有事务，就以非事务方式执行。</td>
</tr>
<tr>
<td align="center">PROPAGATION_MANDATORY</td>
<td align="center">使用当前的事务，如果当前没有事务，就抛出异常。</td>
</tr>
<tr>
<td align="center">PROPAGATION_REQUIRES_NEW</td>
<td align="center">新建事务，如果当前存在事务，把当前事务挂起。</td>
</tr>
<tr>
<td align="center">PROPAGATION_NOT_SUPPORTED</td>
<td align="center">以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。</td>
</tr>
<tr>
<td align="center">PROPAGATION_NEVER</td>
<td align="center">以非事务方式执行，如果当前存在事务，则抛出异常。</td>
</tr>
<tr>
<td align="center">PROPAGATION_NESTED</td>
<td align="center">如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与PROPAGATION_REQUIRED类似的操作。</td>
</tr>
</tbody></table>
<p>如果service层  add方法调用了 addDept和addEmp两个方法</p>
<p>&#x3D;&#x3D;<em><strong>PROPAGATION_REQUIRED</strong></em>&#x3D;&#x3D;<br>如果add方法有事务,那么addDept和addEmp就加入到add方法里的事务<br>如果add方法没有事务,那么就新建一个事务,将addDept和addEmp加入到这个新的事务中</p>
<p>&#x3D;&#x3D;<em><strong>PROPAGATION_REQUIRES_NEW</strong></em>&#x3D;&#x3D;<br>无论add是否有事务,都建立一个新的事务,所有的方法都加入到新的事务中,add原来的事务就不用了</p>
<p><strong>isolation 事务的隔离级别</strong></p>
<ol>
<li><p>DEFAULT （默认）<br>这是一个PlatfromTransactionManager默认的隔离级别，使用数据库默认的事务隔离级别。另外四个与JDBC的隔离级别相对应。<br>MySQL默认REPEATABLE_READ<br>Oracle默认READ_COMMITTED</p>
</li>
<li><p>READ_UNCOMMITTED （读未提交）<br>这是事务最低的隔离级别，它允许另外一个事务可以看到这个事务未提交的数据。这种隔离级别会产生脏读，不可重复读和幻像读。 </p>
</li>
<li><p>READ_COMMITTED （读已提交）<br>保证一个事务修改的数据提交后才能被另外一个事务读取，另外一个事务不能读取该事务未提交的数据。这种事务隔离级别可以避免脏读出现，但是可能会出现不可重复读和幻像读。 </p>
</li>
<li><p>REPEATABLE_READ （可重复读）<br>这种事务隔离级别可以防止脏读、不可重复读，但是可能出现幻像读。它除了保证一个事务不能读取另一个事务未提交的数据外，还保证了不可重复读。</p>
</li>
<li><p>SERIALIZABLE（串行化）<br>这是花费最高代价但是最可靠的事务隔离级别，事务被处理为顺序执行。除了防止脏读、不可重复读外，还避免了幻像读。</p>
</li>
</ol>
<p><em>timeout 超时时间</em><br>事务一定要在多长时间之内提交,如果不提交就会回滚</p>
<p><em>readOnly 只读事务</em><br>事务是否只能读取数据库的数据,如果为true,则不允许进行增删改</p>
<p><em>rollbackFor 指定发生回滚的异常</em><br>当方法发生哪些异常时才会回滚</p>
<p><em>noRollbackFor 指定不发生回滚的异常</em><br>当方法发生哪些异常时,不会回滚</p>
<h1 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h1><h2 id="spring的循环依赖是什么？怎么解决"><a href="#spring的循环依赖是什么？怎么解决" class="headerlink" title="spring的循环依赖是什么？怎么解决?"></a>spring的循环依赖是什么？怎么解决?</h2><p>循环依赖：</p>
<p>​	指循环引用，是两个或多个Bean之间相互持有对方的引用</p>
<p>三种依赖方式：</p>
<p>​	1、A依赖B ,B依赖A 	   					——&gt; 直接依赖</p>
<p>​	2、A依赖C，C依赖B，B依赖A	   ——&gt; 间接依赖</p>
<p>​	3、A依赖A 											——&gt; 自我依赖</p>
<p>为什么会产生这个问题呢？</p>
<p>​	因为我们的 Spring 其中一大特点就是Spring IOC 、DI，Spring会自动帮我们创建对象和对对象赋值，而一旦产生循环依赖问题就会导致我们初始化的时候陷入阻塞状态，最终导致Spring容器都无法启动</p>
<p>解决办法</p>
<blockquote>
<p>​	使用缓存，缓存就是将所有缓存好的Bean，全部放在一个容器中缓存起来，并且呢，将已经完全实例化，但是没有完成赋值的Bean标记起来。然后呢，再Bean第一次实例化完成后，在扫描一次容器将没有完成赋值的Bean的属性完成赋值就可以了。(@Autowriter的对象)</p>
<p>目前循环依赖只在属性&#x3D;&#x3D;set注入&#x3D;&#x3D;且&#x3D;&#x3D;单例&#x3D;&#x3D;的情况下才能解决</p>
</blockquote>
<h2 id="解决循环依赖问题一定要使用二级缓存吗？"><a href="#解决循环依赖问题一定要使用二级缓存吗？" class="headerlink" title="解决循环依赖问题一定要使用二级缓存吗？"></a>解决循环依赖问题一定要使用二级缓存吗？</h2><p>不一定，但是为什么又要设计二级缓存？假设我们只有一个缓存容器，并且缓存是直接开放给用户可以调用的，未完成赋值的Bean和已完成赋值的Bean全部放入一个容器的话，调用者就有可能会拿到未赋值的Bean，这对于用户来说是没有意义的，可能会造成空指针异常。所以基于这样的考虑，Spring将能够直接提供给用户使用的Bean放在了一级缓存中，这样的Bean称之为终态Bean；将已经完成初始化，但还不能提供给用户使用的Bean放在了二级缓存，称之为临时Bean。</p>
<h2 id="为什么在二级缓存的基础上还要创建三级缓存"><a href="#为什么在二级缓存的基础上还要创建三级缓存" class="headerlink" title="为什么在二级缓存的基础上还要创建三级缓存"></a>为什么在二级缓存的基础上还要创建三级缓存</h2><p>Spring中的有很多的注入的Bean需要去创建代理的Bean，但是不是所有的Bean都需要去实例化之后就立马要创建代理Bean，是要等到Bean初始化之后，完成之后才能够去创建代理Bean，因此的循环依赖呢Spring又不得不去提前的创建代理Bean，如果不创建代理Bean，注入原始的Bean就会产生错误。所以Spring设计三级缓存专门存储这些代理Bean，但是每个代理Bean的Bean的创建规则他又不一样，因此呢，Spring的三级缓存中并不是直接去保存代理Bean的引用，而是保存了创建代理Bean的Factory</p>
<h2 id="什么是-Spring-三级缓存？"><a href="#什么是-Spring-三级缓存？" class="headerlink" title="什么是 Spring 三级缓存？"></a>什么是 Spring 三级缓存？</h2><p>singletonObjects   		 		&lt;ConCurrentHashMap&lt;&gt; 	  ——&gt;   	 一级缓存</p>
<p>earlySingletonObjects	 	&lt;HashMap&lt;&gt;				  			——&gt;   	 二级缓存</p>
<p>singletonFactories				&lt;HashMap&lt;&gt;						 	 ——&gt;   	 三级缓存</p>
<p>一级缓存就是终态缓存；二级缓存就是临时缓存；三级缓存就是代理工厂的缓存</p>
<img data-src="/2022/10/07/Spring_Family/Spring/image-20220821162504894.png" class="">




<h2 id="什么情况下循环依赖无法解决？"><a href="#什么情况下循环依赖无法解决？" class="headerlink" title="什么情况下循环依赖无法解决？"></a>什么情况下循环依赖无法解决？</h2><p>1、多实例Bean 通过 set注入无法解决</p>
<p>2、构造器注入注入的Bean无法解决</p>
<p>3、单里的代理Bean通过 set注入无法解决</p>
<p>4、设置@DependsOn注解的Bean注入无法解决</p>
<h2 id="后序补充……"><a href="#后序补充……" class="headerlink" title="后序补充……."></a>后序补充…….</h2>]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>框架</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot</title>
    <url>/2022/10/07/Spring_Family/SpringBoot/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><h2 id="原有Spring优缺点分析"><a href="#原有Spring优缺点分析" class="headerlink" title="原有Spring优缺点分析"></a>原有Spring优缺点分析</h2><p>优点：</p>
<blockquote>
<p>Spring是Java企业版（JAVAEE)开发的一种相对简单的方法，通过依赖注入和面向切面编程，用简单 的Java对象实现了EJB&#x3D;&#x3D;(Enterprise Java Beans技术的简称, 又被称为企业Java Beans)&#x3D;&#x3D;的功能</p>
</blockquote>
<p>缺点：</p>
<ul>
<li>虽然Spring的组件<strong>代码是轻量级</strong>的，但它的<strong>配置却是重量级</strong>的</li>
<li><strong>依赖管理</strong>也是一件耗时耗力的事情，会产生版本不兼容的问题</li>
</ul>
<h2 id="SpringBoot概念简介"><a href="#SpringBoot概念简介" class="headerlink" title="SpringBoot概念简介"></a>SpringBoot概念简介</h2><blockquote>
<p>Spring Boot是Spring公司的一个顶级项目，和Spring Framework是一个级别的。<br>Spring Boot实际上是利用Spring Framework 4 自动配置特性完成。编写项目时不需要编写xml文件。发展到现在，Spring Boot已经具有很很大的生态圈，各种主流技术已经都提供了Spring Boot的启动器。</p>
</blockquote>
<h2 id="什么是启动器"><a href="#什么是启动器" class="headerlink" title="什么是启动器"></a>什么是启动器</h2><blockquote>
<p>Spring框架在项目中作用是Spring整合各种其他技术，让其他技术使用更加方便。Spring Boot的启动器<strong>实际上就是一个依赖</strong>。这个依赖中包含了整个这个技术的相关jar包，还包含了这个技术的自动配置，以前绝大多数XML配置都不需要配置了。当然了，启动器中自动配置无法实现所有内容的自动配置，在使用Spring Boot时还需要进行少量的配置（这个配置不是在xml中了，而是在properties或yml中即可）。如果是<strong>Spring自己封装的启动器</strong>的artifact id<strong>名字满足：spring-boot-starter-<em>xxxx</em></strong>，如果是<strong>第三方公司提供的启动</strong>满足：<strong><em>xxxx</em>-spring-boot-starter</strong>。以后每次使用Spring Boot整合其他技术时首先需要考虑导入启动器。</p>
</blockquote>
<h1 id="Spring-Boot优点"><a href="#Spring-Boot优点" class="headerlink" title="Spring Boot优点"></a>Spring Boot优点</h1><p>①　使用Spring Boot可以创建独立的Spring应用程序<br>②　在Spring Boot中<strong>直接嵌入了Tomcat</strong>、Jetty、Undertow等Web  容器，在使用SpringBoot做Web开发时<strong>不需要部署WAR文件</strong><br>③　通过提供自己的启动器(Starter)依赖，简化项目构建配置<br>④　尽量的自动配置Spring和第三方库<br>⑤　绝对没有代码生成，也不需要XML配置文件</p>
<h1 id="Spring-Boot的核心"><a href="#Spring-Boot的核心" class="headerlink" title="Spring Boot的核心"></a>Spring Boot的核心</h1><p><strong>起步依赖</strong>：起步依赖本质上是一个Maven项目对象模型（Project Object Model，POM），定义了对其他库的传递依赖，这些东西加在一起即支持某项功能。 简单的说，起步依赖就是将具备某种功能的坐标打包到一起，并提供一些默认的功能。</p>
<p><strong>自动配置</strong> ：Spring Boot的自动配置是一个运行时（更准确地说，是应用程序启动时）的过程，考虑了众多因素，才决定 Spring配置应该用哪个，不该用哪个。该过程是Spring自动完成的。</p>
<h1 id="启动原理分析"><a href="#启动原理分析" class="headerlink" title="启动原理分析"></a>启动原理分析</h1><img data-src="/2022/10/07/Spring_Family/SpringBoot/%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE.jpg" class="">




<pre><code class="java">static class Registrar implements ImportBeanDefinitionRegistrar, DeterminableImports &#123;
    @Override
    public void registerBeanDefinitions(AnnotationMetadata metadata, BeanDefinitionRegistry registry) &#123;
        register(registry, new PackageImports(metadata).getPackageNames().toArray(new String[0]));
    &#125;
    @Override
    public Set&lt;Object&gt; determineImports(AnnotationMetadata metadata) &#123;
        return Collections.singleton(new PackageImports(metadata));
    &#125;
&#125;
</code></pre>
<p>将配置类@SpringBootApplication标注的类所在包及下面所有子包里的所有组件扫描到spring容器</p>
<pre><code class="java">protected List&lt;String&gt; getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes) &#123;
        List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(getSpringFactoriesLoaderFactoryClass(),
                getBeanClassLoader());
        Assert.notEmpty(configurations, &quot;No auto configuration classes found in META-INF/spring.factories. If you &quot;
                + &quot;are using a custom packaging, make sure that file is correct.&quot;);
        return configurations;
    &#125;
</code></pre>
<p><strong>通过 getCandidateConfigurations读取自带的配置文件，得到他们的全路径名，通过反射创建他们</strong></p>
<h1 id="异常处理和拦截器"><a href="#异常处理和拦截器" class="headerlink" title="异常处理和拦截器"></a>异常处理和拦截器</h1><p><strong>均与SpringMVC中处理一致</strong></p>
<h1 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h1><p>主要参数：</p>
<p>当前页 、一页n个(每页的数量)、 总条数</p>
<h2 id="属性介绍"><a href="#属性介绍" class="headerlink" title="属性介绍"></a>属性介绍</h2><table>
<thead>
<tr>
<th align="center">属性名</th>
<th align="center">类型</th>
<th align="center">默认值</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">overflow</td>
<td align="center">boolean</td>
<td align="center">false</td>
<td align="center">溢出总页数后是否进行处理<br/>(默认不处理,参见 <code>插件#continuePage</code> 方法)</td>
</tr>
<tr>
<td align="center">maxLimit</td>
<td align="center">Long</td>
<td align="center"></td>
<td align="center">单页分页条数限制<br/>(默认无限制,参见 <code>插件#handlerLimit</code> 方法)</td>
</tr>
<tr>
<td align="center">dbType</td>
<td align="center">DbType</td>
<td align="center"></td>
<td align="center">数据库类型<br/>(根据类型获取应使用的分页方言,参见 <code>插件#findIDialect</code> 方法)</td>
</tr>
<tr>
<td align="center">dialect</td>
<td align="center">IDialect</td>
<td align="center"></td>
<td align="center">方言实现类<br/>(参见 <code>插件#findIDialect</code> 方法)</td>
</tr>
</tbody></table>
<blockquote>
<p>建议单一数据库类型的均设置 dbType</p>
</blockquote>
<pre><code class="java">    @GetMapping(&quot;/test&quot;)
    public Response test()&#123;
        Page&lt;Produce&gt; producePage = new Page&lt;&gt;(1,1);
        Page&lt;Produce&gt; page = produceService.page(producePage);
        System.out.println(producePage == page);
        List&lt;Produce&gt; records = page.getRecords();
        for (Produce record : records) &#123;
            System.out.println(record);
        &#125;
        return new Response&lt;&gt;(records, ResultEnum.SUCCESS);
    &#125;
</code></pre>
<img data-src="/2022/10/07/Spring_Family/SpringBoot/656c18aaaf9ed11fee9b9f1576cc840f.png" class="">


<p>默认是会查询总条数，都有get、set方法，可以根据自己的需求设置（点开Page类看看）</p>
<img data-src="/2022/10/07/Spring_Family/SpringBoot/d0e0280ca8a9d46a4a41c4a1de89ab3c.png" class="">










<h1 id="项目打包和部署"><a href="#项目打包和部署" class="headerlink" title="项目打包和部署"></a>项目打包和部署</h1><h2 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h2><p>SpringBoot项目打包在linux服务器中运行:<br>    ①jar类型项目会打成jar包:<br>    jar类型项目使用SpringBoot打包插件打包时，会在打成的jar中内置一个tomcat的jar。所以我们可以使用jdk直接运行该jar项目可，jar项目中有一个功能，将功能代码放到其内置的tomcat中运行。我们直接使用浏览器访问即可。<br>    ②war类型项目会打成war包:<br>    在打包时需要将内置的tomcat插件排除，配置servlet的依赖。将war正常的放到tomcat服务器中运行即可。</p>
<img data-src="/2022/10/07/Spring_Family/SpringBoot/image-20220718170542347.png" class="">


<h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p><strong>注：这里是部署到Tomcat（war），jar直接编译启动</strong></p>
<h3 id="第一步："><a href="#第一步：" class="headerlink" title="第一步："></a>第一步：</h3><pre><code>在部署到Tomcat 之前我们要将我们项目中的Tomcat(==它在Web中==)去掉，但是我们在项目中又有可能要使用他提供的jar包 HttpServlet 之类的，所以我们还需要再将它手动导入，但是他不需要他打包。
</code></pre>
<pre><code class="xml">&lt;!--配置SpringBoot的web启动器--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
    &lt;!--排除web启动中自动依赖的tomcat插件--&gt;
    &lt;exclusions&gt;
        &lt;exclusion&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;
        &lt;/exclusion&gt;
    &lt;/exclusions&gt;
&lt;/dependency&gt;

&lt;!--
    手动依赖tomcat插件，但是表明项目打包时该依赖不会被打进去，目的主要是保证开发阶段本地SpringBoot
    项目可以正常运行
--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;
    &lt;!--打包的时候可以不用包进去，别的设施会提供。事实上该依赖理论上可以参与编译，测试，运行等周期。
        相当于compile，但是打包阶段做了exclude操作--&gt;
    &lt;scope&gt;provided&lt;/scope&gt;
&lt;/dependency&gt;
</code></pre>
<h3 id="第二步："><a href="#第二步：" class="headerlink" title="第二步："></a>第二步：</h3><p>SpringBoot的<strong>启动类继承SpringBootServletInitializer</strong>，并<strong>重写configure</strong></p>
<pre><code class="java">@SpringBootApplication
public class MyApplication extends SpringBootServletInitializer &#123;
    //重写配置方法
    @Override
    protected SpringApplicationBuilder configure(SpringApplicationBuilder application) &#123;
        return application.sources(MyApplication.class);
    &#125;
    public static void main(String[] args) &#123;
        //启动SpringBoot
        SpringApplication.run(MyApplication.class,args);
    &#125;
&#125;
</code></pre>
<p>使用package命令打包项目，并将war包放到tomcat下的webapps下，启动tomcat即可。</p>
<h3 id="注："><a href="#注：" class="headerlink" title="注："></a>注：</h3><ul>
<li>部署到tomcat之后我们的URL就会变化，tomcat会自动编译war包，我们的<strong>项目名和war包同名</strong>，所以不想改变提前修改</li>
<li><strong>端口号也是tomcat的端口号</strong>（tomcat&#x2F;conf&#x2F;server.xml）</li>
</ul>
<h1 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h1><h2 id="SpringBoot约定大于配置理解"><a href="#SpringBoot约定大于配置理解" class="headerlink" title="SpringBoot约定大于配置理解"></a>SpringBoot约定大于配置理解</h2><p>约定大于配置是一种开发原则，就是减少人为的配置，直接用默认的配置就能获得我们想要的结果。<br>　　SpringBoot的约定大于配置，按我的理解是：对比SpringMVC，需要在web.xml里面配置前端控制器，还需要在核心配置文件（*-servlet.xml）中配置视图解析器啥的，更要配置第三方的Tomcat服务器。而SpringBoot就不需要我们配置这些，他内嵌了Tomcat服务器，我们只需要在Maven配置文件（Pom.xml）里面导入SpringMVC所需要的依赖就可以了。<br>　　这就是SpringBoot的优势，在传统所需要配置的地方，SpringBoot都进行了约定（配置好了），开发人员能配置得更少，更直接地开发项目，写业务逻辑代码。<br>spring boot和maven的约定大于配置体现 点：<br>　　1.maven的目录文件结构<br>　　1）默认有resources文件夹,存放资源配置文件。src-main-resources,src-main-java<br>默认的编译生成的类都在targetwen。<br>　　2）默认有target文件夹，将生成class文件盒编程生成的jar存放在target文件夹下</p>
<p>2.spring boot默认的配置文件必须是，也只能是application.命名的yml文件或者properties文件，且唯一</p>
<p>1）spring boot默认只会去src-main-resources文件夹下去找application配置文件</p>
<p>这个问题呢，我从四个方面来回答。</p>
<p>首先，约定优于配置是一种软件设计的范式，它的核心思想，是减少软件开发人员对于配置项的。从而让开发人员更加聚焦在业务逻辑上</p>
<p>第二个呢，Spring boot就是约定优于配置这一理念下的产物，它类似于spring框架下的一个脚手架，通过spring boot，我们可以快速开发基于spring生态下的应用程序。基于传统的spring框架开发web应用的时候，我们需要做很多和业务无关，并且只需要做一次的配置项，比如</p>
<ol>
<li><p>管理架包的依赖</p>
</li>
<li><p>web.xml的维护</p>
</li>
<li><p>spring MVC中的一个叫 Dispatch-Servlet.x ml 配置项的一个维护</p>
</li>
<li><p>应用需要自己手动去部署到web容器</p>
</li>
<li><p>第三方组件集成到spring IOC容器中，我们需要做配置项的维护</p>
</li>
</ol>
<p>而在SpringBoot中，我们不再需要去做这些繁琐的配置，因为SpringBoot已经帮我们自动完成了，而完成这样一个动作的前提就是基于&#x3D;&#x3D;约定优于配置&#x3D;&#x3D;这样一个思想。</p>
<p>最后呢，Spring boot约定优于配置的体现有很多，</p>
<p>比如第一个spring boat start启动依赖，它能够帮助我们管理所有的jar包版本。</p>
<p>第二个，如果当前的应用依赖了web这样一个 jar 包，那么spring boot会自动内置Tomcat，他们看着容器来去运行web应用，我们不再需要去单独进行应用部署。</p>
<p>第三，Spring boot的自动装配机制的实现中，通过扫描约定路径下的spring.factory文件去进行识别配置类，从而去实现类的自动装载</p>
<p>第四，Spring boot？默认会加载resource目录下的application.property文件。总的来说啊，约定优于配置呢，是一个比较常见的软件设计思想，它的核心本质都是为了去更加高效，以及更加便捷的去实现软件系统的开发和维护。</p>
<p><strong>自我总结：</strong></p>
<p>​	约定大于配置，不是说我们要设定啥，原来规定的是什么就不能改变，不是这个意思。他真正的意思是说当我们配置某个选项时，springboot会自动帮我们加载可能会与其相关的配置，就好比我们应用依赖了 web，那么spring boot会自动内置Tomcat，他们看着容器来去运行web应用，我们不再需要去单独进行应用部署。</p>
<p>​	总的来说啊，约定优于配置呢，是一个比较常见的软件设计思想，它的核心本质都是为了去更加高效，以及更加便捷的去实现软件系统的开发和维护。</p>
]]></content>
      <categories>
        <category>Spring</category>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>框架</tag>
        <tag>Spring</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringMVC</title>
    <url>/2022/10/07/Spring_Family/SpringMVC/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><img data-src="/2022/10/07/Spring_Family/SpringMVC/image-20220716212203883.png" class="">


<p>M   model      模型层   DAO封装        &gt;&gt;&gt; Mybatis<br>V    view         视图层   html css js  jsp<br>C    controller 控制层   Servlet封装    &gt;&gt;&gt; springMVC </p>
<p>SpringMVC是spring为展现层提供的基于MVC设计理念的优秀WEB框架,是目前最主流的MVC框架之一<br>SpringMVC通过一套注解,可以让普通的JAVA类成为contrllor控制器,无需继承Servlet,实现了控制层和Servlet之间的解耦<br>SpringMVC支持Rest风格的URL写法<br>SpringMVC采用了松耦合,可热插的主键结构,比其他的框架更具扩展性和灵活性</p>
<h1 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h1><img data-src="/2022/10/07/Spring_Family/SpringMVC/image-20220717190437596.png" class="">


<img data-src="/2022/10/07/Spring_Family/SpringMVC/image-20220717190445738.png" class="">


<p>1DispatcherServlet：前端控制器<br>用户请求到达前端控制器，它就相当于 mvc 模式中的 c，dispatcherServlet 是整个流程控制的中心，由 它调用其它组件处理用户的请求，dispatcherServlet 的存在降低了组件之间的耦合性。</p>
<p><strong>2 HandlerMapping：处理器映射器</strong><br>HandlerMapping 负责根据用户请求找到 Handler 即处理器，SpringMVC 提供了不同的映射器实现不同的 映射方式，例如：配置文件方式，实现接口方式，注解方式等。</p>
<p>3 Handler：处理器 (自己定义的Controller处理单元)<br>它就是我们开发中要编写的具体业务控制器。由 DispatcherServlet 把用户请求转发到 Handler。由 Handler 对具体的用户请求进行处理。</p>
<p><strong>4 HandlAdapter：处理器适配器</strong><br>通过 HandlerAdapter 对处理器进行执行，这是适配器模式的应用，通过扩展适配器可以对更多类型的处理器进行执行</p>
<p>5 View Resolver：视图解析器<br>View Resolver 负责将处理结果生成 View 视图，View Resolver 首先根据逻辑视图名解析成物理视图名 即具体的页面地址，再生成 View 视图对象，最后对 View 进行渲染将处理结果通过页面展示给用户。</p>
<p>6 View：视图<br>SpringMVC 框架提供了很多的 View 视图类型的支持，包括：jstlView、freemarkerView、pdfView等。我们最常用的视图就是 jsp。 一般情况下需要通过页面标签或页面模版技术将模型数据通过页面展示给用户，需要由程序员根据业务需求开 发具体的页面。</p>
<p>7 <span class="exturl" data-url="bXZjOmFubm90YXRpb24tZHJpdmVu">mvc:annotation-driven</span>说明<br>在 SpringMVC 的各个组件中，处理器映射器、处理器适配器、视图解析器称为 SpringMVC 的三大组件。<br>使 用 <span class="exturl" data-url="bXZjOmFubm90YXRpb24tZHJpdmVu">mvc:annotation-driven</span> 自动加载 RequestMappingHandlerMapping （处理映射器） 和 RequestMappingHandlerAdapter （ 处 理 适 配 器 ） ， 可 用 在 SpringMVC.xml 配 置 文 件 中 使 用 <span class="exturl" data-url="bXZjOmFubm90YXRpb24tZHJpdmVu">mvc:annotation-driven</span>替代注解处理器和适配器的配置。</p>
<p>HandlerMapping的实现类的作用<br>实现类RequestMappingHandlerMapping，它会处理@RequestMapping 注解，并将其注册到请求映射表中。</p>
<p>HandlerAdapter的实现类的作用<br>实现类RequestMappingHandlerAdapter，则是处理请求的适配器，确定调用哪个类的哪个方法，并且构造方法参数，返回值。</p>
<p>当配置了mvc:annotation-driven&#x2F;后，Spring就知道了我们启用注解驱动。然后Spring通过context:component-scan&#x2F;标签的配置，会自动为我们将扫描到的@Component，@Controller，@Service，@Repository等注解标记的组件注册到工厂中，来处理我们的请求,这个时候接收返回json数据、参数验证、统一异常等功能。</p>
<h1 id="重要注解"><a href="#重要注解" class="headerlink" title="重要注解"></a>重要注解</h1><h2 id="1、RequestMapping"><a href="#1、RequestMapping" class="headerlink" title="1、RequestMapping"></a>1、RequestMapping</h2><p>紧耦合方式(了解)<br>DispatcherServlet中的service方法直接将此次请求的request对象传递给调用的单元方法即可。同时在单元方法上声明形参HttpServletRequest来接收request实参即可。<br><strong>解耦合方式(熟练)</strong><br>DispatcherServlet在其service方法中将请求数据根据需求从request对象中获取出来后，将数据直接传递给对应的单元方法使用。同时在单元方法上直接声明对应的形参接收请求数据即可。在单元方法上声明形参来接收请求数据时，形参名必须和请求数据的键名一致，DispatcherServlet会将调用单元方法的形参名作为请求数据的键名获取请求数据，然后传递给单元方法。</p>
<pre><code class="java">@RestController
public class TestDataController &#123;
    /*紧耦合方式参数注入
    * 使用传统的HttpServletRequest对象获取参数  javax.servlet
    * */
    @RequestMapping(&quot;/getParamByRequest.do&quot;)
    public String getParam1(HttpServletRequest req, HttpServletResponse resp)&#123;
        String username = req.getParameter(&quot;username&quot;);
        String password = req.getParameter(&quot;password&quot;);
        System.out.println(&quot;username:&quot;+username+&quot;   password:&quot;+password);
        return &quot;getParamSuccess&quot;;
    &#125;
    /*解耦合方式参数注入
    * HttpServletRequest对象获取参数 通过SpringMVC框架功能,自动转换参数
    * 处理单元参数列表中参数名必须和请求中的参数名一致
                                        * 如不一致,可以通过@RequestParma注解进行转换
    * */
    @RequestMapping(&quot;/getParamByArgName.do&quot;)
    public String getParam2(String username,@RequestParam(&quot;pwd&quot;) int password)&#123;
        System.out.println(&quot;username:&quot;+username+&quot;   password:&quot;+password);
        return &quot;getParamSuccess&quot;;
    &#125;
&#125;
</code></pre>
<h2 id="2、PathVariable注解和RESTful风格的支持"><a href="#2、PathVariable注解和RESTful风格的支持" class="headerlink" title="2、PathVariable注解和RESTful风格的支持"></a>2、PathVariable注解和RESTful风格的支持</h2><p><strong>普通形式的url</strong></p>
<pre><code class="java">*/contextPath/aaa.do
*/contextPath/aaa.jsp
*/contextPath/aaa.html
*/contextPath/css/aaa.css
*/contextPath/js/aaa.js
*/contextPath/aaa.do?id=10&amp;username=root
</code></pre>
<p><strong>restFul风格的url</strong></p>
<pre><code class="java">*/contextPath/aaa/10/root
*/contextPath/aaa
</code></pre>
<pre><code class="java">@Controller
public class PathController &#123;
    @RequestMapping(&quot;/testPathVariable/&#123;id&#125;/&#123;username&#125;&quot;)
    public String testPathVariable(@PathVariable(&quot;id&quot;) Integer id, @PathVariable(&quot;username&quot;) String username)&#123;
        System.out.println(&quot;id:&quot;+id);
        System.out.println(&quot;username:&quot;+username);
        System.out.println(&quot;testPathVariable1&quot;);
        return &quot;success&quot;;
    &#125;
&#125;
</code></pre>
<img data-src="/2022/10/07/Spring_Family/SpringMVC/image-20220717191056216.png" class="">


<img data-src="/2022/10/07/Spring_Family/SpringMVC/image-20220717191104583-1661419340091.png" class="">






<h1 id="响应处理"><a href="#响应处理" class="headerlink" title="响应处理"></a>响应处理</h1><img data-src="/2022/10/07/Spring_Family/SpringMVC/image-20220717191212189-1661419342477.png" class="">




<p>1、单元方法返回值为void</p>
<img data-src="/2022/10/07/Spring_Family/SpringMVC/image-20220717191318663-1661419344199.png" class="">


<blockquote>
<p>在SpringMVC中如果对于当前的控制单元，没有写对应的返回值，这个时候<strong>SpringMVC就会找和自己控制单元名称一致的页面展示</strong>，<strong>如果没有配置视图解析器的前缀和后缀是没有产生404</strong>,需要注意控制单元仍然可以进。</p>
</blockquote>
<p>2、转发和重定向ServletAPI 实现</p>
<pre><code class="java">@RequestMapping(&quot;demo1&quot;)
    public void testDemo1(HttpServletRequest request, HttpServletResponse response) throws Exception &#123;
        // 请求转发
        //request.getRequestDispatcher(&quot;/forward.jsp&quot;).forward(request,response);
        // 响应重定向
        response.sendRedirect(request.getContextPath()+&quot;/redirect.jsp&quot;);
    &#125;
</code></pre>
<blockquote>
<p>单元方法的返回值类型设置void。因为使用response对象在单元方法中直接对此次请求进行了响应，不再通过DispatcherServlet了，既然已经响应了，就不需要再给DispatcherServlet返回值了。在单元方法上声明HttpServletResponse形参，来接收此次请求的response对象。</p>
</blockquote>
<p>3、使用forward关键字完成响应</p>
<pre><code class="java"> /*
    * 返回字符串告诉DispatcherServlet跳转的路径
    * 在路径之前放上一个forward: 关键字,就是请求转发
    * 如果路径前的关键字是forward,那么可以省略不写
    * */
    @RequestMapping(&quot;demo2&quot;)
    public String testDemo2() throws Exception &#123;
        //return &quot;forward:/forwardPage.jsp&quot;;
        return &quot;/forwardPage.jsp&quot;;
    &#125;
</code></pre>
<p>使用通过单元方法的返回值来告诉DispatcherServlet请求转发指定的资源,如果是请求转发，<strong>forward关键字可以<em>省略不写</em>的</strong></p>
<p>4、使用redirect关键字完成响应</p>
<pre><code class="java">/*
     * 返回字符串告诉DispatcherServlet跳转的路径
     * 在路径之前放上一个redirect: 关键字,就是重定向
     * 如果路径前的关键字是redirect,那么不可以省略
     * /表示当前项目下.这里不需要项目的上下文路径
     * */
    @RequestMapping(&quot;demo3&quot;)
    public String testDemo3() throws Exception &#123;
        return &quot;redirect:/redirectPage.jsp&quot;;
    &#125;
</code></pre>
<p>使用通过单元方法的返回值来告诉DispatcherServlet重定向指定的资源，注意这个<strong>redirect关键字<em>不可以省去</em></strong></p>
<p>5、使用View视图转发和重定向</p>
<pre><code class="java"> @RequestMapping(&quot;demo4&quot;)
    public View testDemo4(HttpServletRequest req)   &#123;
        View  view =null;
        // 请求转发
        //view =new InternalResourceView(&quot;/forwardPage.jsp&quot;);
        // 重定向
        view=new RedirectView(req.getContextPath()+&quot;/redirectPage.jsp&quot;);
        return view;
    &#125;
</code></pre>
<blockquote>
<p>RedirectView中所做的操作，最终的实现是在renderMergedOutputModel中完成实现的，简单来说RedirectView实现了链接的重定向，并且将数据保存到FlashMap中，这样在跳转后的链接中可以获取一些数据.</p>
</blockquote>
<p>6、使用ModelAndView转发重定向</p>
<pre><code class="java">@RequestMapping(&quot;demo5&quot;)
    public ModelAndView testDemo5(HttpServletRequest req)   &#123;
        ModelAndView mv=new ModelAndView();
        // 请求转发
        //mv.setViewName(&quot;forward:/forwardPage.jsp&quot;);
        //mv.setView(new InternalResourceView(&quot;/forwardPage.jsp&quot;));
        // 重定向
        //mv.setViewName(&quot;redirect:/redirectPage.jsp&quot;);
        mv.setView(new RedirectView(req.getContextPath()+&quot;/redirectPage.jsp&quot;));
        return mv;
    &#125;
</code></pre>
<p>​	ModelAndView中的Model代表模型，View代表视图，这个名字就很好地解释了该类的作用。业务处理器调用模型层处理完用户请求后，把结果数据存储在该类的model属性中，把要返回的视图信息存储在该类的view属性中，然后让该ModelAndView返回该Spring MVC框架。</p>
<h1 id="作用域传参"><a href="#作用域传参" class="headerlink" title="作用域传参"></a>作用域传参</h1><img data-src="/2022/10/07/Spring_Family/SpringMVC/image-20220717191751516-1661419352934.png" class="">


<blockquote>
<p>PageContext对象</p>
</blockquote>
<p>作用域范围:当前jsp页面内有效</p>
<blockquote>
<p>request对象</p>
</blockquote>
<p>作用域范围:一次请求内。</p>
<p>作用: 解决了一次请求内的资源的数据共享问题</p>
<blockquote>
<p>session对象</p>
</blockquote>
<p>作用域范围:一次会话内有效。</p>
<p>说明:浏览器不关闭,并且后台的session不失效，在任意请求中都可以获取到同一个session对象。</p>
<p>作用:解决了一个用户不同请求的数据共享问题。</p>
<blockquote>
<p>application(ServletContext)对象</p>
</blockquote>
<p>作用域范围:整个项目内有效。</p>
<p>特点:一个项目只有一个，在服务器启动的时候即完成初始化创建无论如何获取都是同一个项目。</p>
<p>作用:解决了不同用户的数据共享问题。</p>
<h1 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h1><h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><blockquote>
<p>&#x3D;&#x3D;过滤器的作用是保护请求的服务器资源，在请求资源被执行之前&#x3D;&#x3D;，如果请求地址符合拦截范围，则会先执行过滤器。&#x3D;&#x3D;过滤器的执行时机，是在Servlet之前执行的&#x3D;&#x3D;。但是在使用了SpringMVC后，Servlet只有一个了，也就是DisptcherServlet。那么，如果我们仍然使用过滤器来完成请求的拦截，因为过滤器是在Servlet之前执行的，就会造成，&#x3D;&#x3D;过滤器会拦截DispatcherServlet所有的请求&#x3D;&#x3D;。那么，如果我们有&#x3D;&#x3D;部分请求不想被拦截&#x3D;&#x3D;，怎么办？</p>
</blockquote>
<h2 id="拦截器使用"><a href="#拦截器使用" class="headerlink" title="拦截器使用"></a>拦截器使用</h2><img data-src="/2022/10/07/Spring_Family/SpringMVC/image-20220717191927439-1661419356594.png" class="">


<p>Spring MVC中的拦截器（Interceptor）类似于Servlet中的过滤器（Filter），它主要用于拦截用户请求并作相应的处理。例如通过拦截器可以进行权限验证、记录请求信息的日志、判断用户是否登录等。<br>    要使用Spring MVC中的拦截器，就需要对拦截器类进行定义和配置。通常拦截器类可以通过两种方式来定义。<br>    1.通过实现HandlerInterceptor接口，或继承HandlerInterceptor接口的实现类（如HandlerInterceptorAdapter）来定义。<br>    2.通过实现WebRequestInterceptor接口，或继承WebRequestInterceptor接口的实现类来定义。</p>
<h2 id="拦截器和过滤器的区别"><a href="#拦截器和过滤器的区别" class="headerlink" title="拦截器和过滤器的区别"></a>拦截器和过滤器的区别</h2><ol>
<li><p>拦截器SpringMVC的，而过滤器是servlet的。	</p>
</li>
<li><p>拦截器不依赖与servlet容器,由spring容器初始化，过滤器依赖与servlet容器,由servlet容器初始化。. </p>
</li>
<li><p>拦截器只能对action请求起作用，而过滤器则可以对几乎所有的请求起作用。</p>
</li>
<li><p>拦截器可以访问action上下文、值栈里的对象，而过滤器不能访问。</p>
</li>
<li><p>在action的生命周期中，拦截器可以多次被调用，而过滤器只能在容器初始化时被调用一次。</p>
</li>
<li><p>拦截器可以获取IOC容器中的各个bean，而过滤器就不太方便，这点很重要，在拦截器里注入一个service，可以调用业务逻辑。</p>
</li>
</ol>
<pre><code class="java">public class MyInterceptor implements HandlerInterceptor &#123;
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;
        /*在请求到达我们定义的handler之前工作的*/
        System.out.println(&quot;MyInterceptor preHandle&quot;);
        /*返回的是true,代表放行,可以继续到达handler*/
        return true;
    &#125;
    @Override
    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123;
        System.out.println(&quot;MyInterceptor postHandle&quot;);
        /*handler 处理单元返回ModelAndView 时候进行 拦截*/
    &#125;
    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123;
        /*
        页面渲染完毕,但是还没有给浏览器响应数据的时候
         */
        System.out.println(&quot;MyInterceptor afterCompletion&quot;);
    &#125;
&#125;
</code></pre>
<h2 id="多个拦截器执行顺序"><a href="#多个拦截器执行顺序" class="headerlink" title="多个拦截器执行顺序"></a>多个拦截器执行顺序</h2><p>多个拦截器同时存在时,执行的顺序由配置顺序决定. 先配置谁, 谁就先执行.多个拦截器可以理解为拦截器栈, 先进后出(后进先出), 如图所示:</p>
<img data-src="/2022/10/07/Spring_Family/SpringMVC/image-20220717192103889-1661419360360.png" class="">




<h1 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h1><h2 id="SpringMVC异常简介"><a href="#SpringMVC异常简介" class="headerlink" title="SpringMVC异常简介"></a>SpringMVC异常简介</h2><p>​	系统中异常包括两类：预期异常(检查型异常)和运行时异常 RuntimeException，前者通过捕获异常从而获取异常信息， 后者主要通过规范代码开发、测试通过手段减少运行时异常的发生</p>
<h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><h3 id="1使用-ExceptionHandler注解处理异常"><a href="#1使用-ExceptionHandler注解处理异常" class="headerlink" title="1使用@ExceptionHandler注解处理异常"></a>1使用@ExceptionHandler注解处理异常</h3><p>缺点：只能处理当前Controller中的异常。</p>
<pre><code class="java"> @ExceptionHandler(value =&#123;ArithmeticException.class,NullPointerException.class&#125; )
    public ModelAndView handelException()&#123;
        ModelAndView mv =new ModelAndView();
        mv.setViewName(&quot;error1.jsp&quot;);
        return mv;
    &#125;
</code></pre>
<h3 id="2使用：-ControllerAdvice-ExceptionHandler"><a href="#2使用：-ControllerAdvice-ExceptionHandler" class="headerlink" title="2使用：@ControllerAdvice+@ExceptionHandler"></a>2使用：@ControllerAdvice+@ExceptionHandler</h3><p>此处优先级低于局部异常处理器</p>
<pre><code class="java">@ControllerAdvice
public class GloableExceptionHandler1 &#123;
    @ExceptionHandler(value =&#123;ArithmeticException.class,NullPointerException.class&#125; )
    public ModelAndView handelException()&#123;
        ModelAndView mv =new ModelAndView();
        mv.setViewName(&quot;error1.jsp&quot;);
        return mv;
    &#125;
&#125;
</code></pre>
<h3 id="3使用：SimpleMappingExceptionResolver"><a href="#3使用：SimpleMappingExceptionResolver" class="headerlink" title="3使用：SimpleMappingExceptionResolver"></a>3使用：SimpleMappingExceptionResolver</h3><pre><code class="java">/**
 * 全局异常
 */
  @Configuration
  public class GloableException2 &#123;
    @Bean
    public SimpleMappingExceptionResolver getSimpleMappingExceptionResolver()&#123;
        SimpleMappingExceptionResolver resolver = new SimpleMappingExceptionResolver();
        Properties prop = new Properties();
        prop.put(&quot;java.lang.NullPointerException&quot;,&quot;error1.jsp&quot;);
        prop.put(&quot;java.lang.ArithmeticException&quot;,&quot;error2.jsp&quot;);
        resolver.setExceptionMappings(prop);
        return resolver;
    &#125;
&#125;
</code></pre>
<h3 id="4自定义的HandlerExceptionResolver"><a href="#4自定义的HandlerExceptionResolver" class="headerlink" title="4自定义的HandlerExceptionResolver"></a>4自定义的HandlerExceptionResolver</h3><pre><code class="java">/**
 * 全局异常
 * HandlerExceptionResolve
 */
  @Configuration
  public class GloableException3 implements HandlerExceptionResolver &#123;
    @Override
    public ModelAndView resolveException(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e) &#123;
        ModelAndView mv = new ModelAndView();
        if(e instanceof NullPointerException)&#123;
                mv.setViewName(&quot;error1&quot;);
        &#125;
        if(e instanceof ArithmeticException)&#123;
                mv.setViewName(&quot;error2&quot;);
        &#125;
        mv.addObject(&quot;msg&quot;,e);
        return mv;
    &#125;&#125;
</code></pre>
<h1 id="其他注解"><a href="#其他注解" class="headerlink" title="其他注解"></a>其他注解</h1><h2 id="RequestBody"><a href="#RequestBody" class="headerlink" title="@RequestBody"></a>@RequestBody</h2><p>作用：</p>
<p>​	用于获取请求体json格式的字符串内容。直接使用得到是 key&#x3D;value&amp;key&#x3D;value…结构的数据，get 请求方式不适用。</p>
<p>属性：</p>
<p>​	required：是否必须有请求体。默认值是:true。当取值为 true 时,get 请求方式会报错。如果取值 为 false，get 请求得到是null。</p>
<h2 id="CrossOrigin"><a href="#CrossOrigin" class="headerlink" title="@CrossOrigin"></a>@CrossOrigin</h2><p>作用：</p>
<p>​	解决ajax请求之间的跨域问题</p>
<p>属性:</p>
<p>origins  ： 允许可访问的域列表IP</p>
<p>maxAge：准备响应前的缓存持续的最大时间（以秒为单位）。</p>
]]></content>
      <categories>
        <category>Spring</category>
        <category>SpringMVC</category>
      </categories>
      <tags>
        <tag>框架</tag>
        <tag>Spring</tag>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS-7安装</title>
    <url>/2022/10/15/tools/CentOS-7-tool/</url>
    <content><![CDATA[<p><strong>1.下载镜像文件</strong></p>
<p>  <span class="exturl" data-url="aHR0cHM6Ly9taXJyb3JzLnR1bmEudHNpbmdodWEuZWR1LmNuLw=="> 清华大学开源软件镜像站</span>  </p>
<p><strong>2.开始安装</strong></p>
<p><img data-src="https://cdn.jsdelivr.net/gh/onlymarryu/typora-ims-test@master/img/1646489101763.png" alt="1646489101763"></p>
<p><img data-src="https://cdn.jsdelivr.net/gh/onlymarryu/typora-ims-test@master/img/1646489187835.png" alt="1646489187835"></p>
<p><img data-src="https://cdn.jsdelivr.net/gh/onlymarryu/typora-ims-test@master/img/1646489210450.png" alt="1646489210450"></p>
<p><img data-src="https://cdn.jsdelivr.net/gh/onlymarryu/typora-ims-test@master/img/1646489375149.png" alt="1646489375149"></p>
<p><img data-src="https://cdn.jsdelivr.net/gh/onlymarryu/typora-ims-test@master/img/1646489450527.png" alt="1646489450527"></p>
<p><strong>3.开始进去虚拟机配置我们的软件</strong></p>
<p><strong>3.1语言</strong></p>
<p><img data-src="https://cdn.jsdelivr.net/gh/onlymarryu/typora-ims-test@master/img/1646489591914.png" alt="1646489591914"></p>
<p><strong>3.2时区、软件选择</strong></p>
<p>软件选择：按照自己的需求选，第一次多选也不要少选</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/onlymarryu/typora-ims-test@master/img/1646489600666.png" alt="1646489600666"></p>
<p>4.硬、软配置完成，开始安装，同时要创建管理员Root 和 基础用户</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/onlymarryu/typora-ims-test@master/img/1646489605373.png" alt="1646489605373"></p>
<p><img data-src="https://cdn.jsdelivr.net/gh/onlymarryu/typora-ims-test@master/img/1646489621243.png" alt="1646489621243"></p>
<p>5.安装成功</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/onlymarryu/typora-ims-test@master/img/1646489626446.png" alt="1646489626446"></p>
<p><strong>系统配置</strong></p>
<div name="Linux_install_centos7">进入系统后~</div>

<p>1、首先配置网络</p>
<p>要先切换到 root 用户上去，不然没权限。</p>
<pre><code class="shell">方式一
sudo -i
password:当前普通用户密码

方式二
su -
password：root用户密码
</code></pre>
<p> 将  **ONBOOT ** 改为 yes ： </p>
<pre><code class="shell"> vim /etc/sysconfig/network-scripts/ifcfg-ens33
</code></pre>
<p><img data-src="https://cdn.jsdelivr.net/gh/onlymarryu/typora-ims-test@master/img/1646490152508.png" alt="1646490152508"></p>
<p>重启网络</p>
<pre><code class="shell">service network restart

### 检查是否通畅
ping 114.114.114.114
</code></pre>
<p>2、 安装net-tools 和 vim（<strong>有的话可直接跳过</strong>）</p>
<pre><code class="shell">yum install -y net-tools vim
</code></pre>
<p>检查自己的ip</p>
<pre><code class="shell">ifconfig
</code></pre>
<p><img data-src="https://cdn.jsdelivr.net/gh/onlymarryu/typora-ims-test@master/img/1646490384192.png" alt="1646490384192"></p>
<p>3 启动sshd服务</p>
<pre><code class="shell">service sshd start
</code></pre>
<div name="Linux_minInstall_4"></div >

<p>4、修改登录，让Root用户直接登录</p>
<p>#<a href="#problem-6">具体步骤</a>   		</p>
<div name="Linux_minInstall_5"></div >

<p>5、修改DNS连接,让xshell访问快一点</p>
<p>#<a href="#problem-5">具体步骤</a></p>
<p>6、 <strong>关闭指定端口防火墙：</strong> </p>
<pre><code class="shell">systemctl status firewalld  

###开启80端口

firewall-cmd --zone=public --add-port=80/tcp --permanent  

###开启3306端口

firewall-cmd --zone=public --add-port=3306/tcp --permanent  

###重启防火墙：

firewall-cmd --reload

关闭防火墙 ，重启失效(Linux系统一重启Linux中的防火墙又会被开起)
service firewalld stop
禁用防火墙，永久有效
systemctl disable firewalld 或者  systemctl disable firewalld.service
启动防火墙 (对禁用的防火墙进行启动)
systemctl enable firewalld
</code></pre>
]]></content>
      <categories>
        <category>工具软件安装</category>
      </categories>
  </entry>
  <entry>
    <title>SpringSecurity</title>
    <url>/2022/10/07/Spring_Family/SpringSecurity/</url>
    <content><![CDATA[<hr/>
<p style="font-size:70px; color:red;background-color:66FF66">Spring Security</p><br/><hr/>

<h1 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h1><p>​		<strong>Spring Security</strong> 是 Spring 家族中的一个安全管理框架。相比与另外一个安全框架<strong>Shiro</strong>，它提供了更丰富的功能，社区资源也比Shiro丰富。</p>
<p>​	一般来说中大型的项目都是使用<strong>SpringSecurity</strong> 来做安全框架。小项目有Shiro的比较多，因为相比与SpringSecurity，Shiro的上手更加的简单。</p>
<p>​	 一般Web应用的需要进行<strong>认证</strong>和<strong>授权</strong>。</p>
<p>​		<strong>认证：验证当前访问系统的是不是本系统的用户，并且要确认具体是哪个用户</strong></p>
<p>​		<strong>授权：经过认证后判断当前用户是否有权限进行某个操作</strong></p>
<p>​	而<strong>认证</strong>和<strong>授权</strong>也是SpringSecurity作为安全框架的<strong>核心功能</strong>。</p>
<h1 id="二、第一个Spring-Security项目"><a href="#二、第一个Spring-Security项目" class="headerlink" title="二、第一个Spring Security项目"></a>二、第一个Spring Security项目</h1><h2 id="1-导入依赖"><a href="#1-导入依赖" class="headerlink" title="1.导入依赖"></a>1.导入依赖</h2><p>​	Spring Security已经被Spring boot进行集成，使用时直接引入启动器即可。</p>
<pre><code class="xml">    &lt;properties&gt;
        &lt;java.version&gt;1.8&lt;/java.version&gt;
        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
        &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;
        &lt;spring-boot.version&gt;2.3.7.RELEASE&lt;/spring-boot.version&gt;
    &lt;/properties&gt;	

    &lt;dependencies&gt;
        &lt;!--thymeleaf--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;!--druid--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
            &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt;
            &lt;version&gt;1.2.8&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!--mysql--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;mysql&lt;/groupId&gt;
            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;!--mybatis-plus--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.baomidou&lt;/groupId&gt;
            &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;
            &lt;version&gt;3.4.2&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!--redis依赖--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;!--fastjson依赖--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
            &lt;artifactId&gt;fastjson&lt;/artifactId&gt;
            &lt;version&gt;1.2.33&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!--jwt依赖--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt;
            &lt;artifactId&gt;jjwt&lt;/artifactId&gt;
            &lt;version&gt;0.9.0&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!--spring-security--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;!--lombok--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
            &lt;artifactId&gt;lombok&lt;/artifactId&gt;
            &lt;optional&gt;true&lt;/optional&gt;
        &lt;/dependency&gt;
        &lt;!--spring-web--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;!--Spring test--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
            &lt;scope&gt;test&lt;/scope&gt;
            &lt;exclusions&gt;
                &lt;exclusion&gt;
                    &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt;
                    &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt;
                &lt;/exclusion&gt;
            &lt;/exclusions&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
</code></pre>
<h2 id="2-写一个控制器"><a href="#2-写一个控制器" class="headerlink" title="2.写一个控制器"></a>2.写一个控制器</h2><pre><code class="java">
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class HelloController &#123;

    @RequestMapping(&quot;/hello&quot;)
    public String hello()&#123;
        return &quot;hello&quot;;
    &#125;
&#125;
</code></pre>
<h2 id="3-访问页面"><a href="#3-访问页面" class="headerlink" title="3.访问页面"></a>3.访问页面</h2><p>​	导入spring-boot-starter-security启动器后，Spring Security已经生效，默认拦截全部请求，如果用户没有登录，跳转到内置登录页面。</p>
<p>​	在项目中新建login.html页面后</p>
<p>​	在浏览器输入：<span class="exturl" data-url="aHR0cDovL2xvY2FsaG9zdDo4MDgwL2xvZ2luLmh0bWwlRTUlOTAlOEUlRTQlQkMlOUElRTYlOTglQkUlRTclQTQlQkElRTQlQjglOEIlRTklOUQlQTIlRTklQTElQjUlRTklOUQlQTI=">http://localhost:8080/login.html后会显示下面页面</span></p>
<img data-src="/2022/10/07/Spring_Family/SpringSecurity/springSecurity-01.jpg" class="">


<p>​	默认的username为user，password打印在控制台中。当然了，每个人的显示的肯定和我的不一样。</p>
<p>​		在浏览器中输入账号和密码后会显示login.html页面内容。</p>
<h1 id="三、用户认证"><a href="#三、用户认证" class="headerlink" title="三、用户认证"></a>三、用户认证</h1><h2 id="3-1-登陆校验流程"><a href="#3-1-登陆校验流程" class="headerlink" title="3.1 登陆校验流程"></a>3.1 登陆校验流程</h2><img data-src="/2022/10/07/Spring_Family/SpringSecurity/image-20211215094003288.png" class="">


<h2 id="3-2-原理初探"><a href="#3-2-原理初探" class="headerlink" title="3.2 原理初探"></a>3.2 原理初探</h2><p>​	想要知道如何实现自己的登陆流程就必须要先知道入门案例中SpringSecurity的流程。</p>
<h3 id="3-2-1-SpringSecurity完整流程"><a href="#3-2-1-SpringSecurity完整流程" class="headerlink" title="3.2.1 SpringSecurity完整流程"></a>3.2.1 SpringSecurity完整流程</h3><p>​	SpringSecurity的原理其实就是一个过滤器链，内部包含了提供各种功能的过滤器。这里我们可以看看入门案例中的过滤器。</p>
<img data-src="/2022/10/07/Spring_Family/SpringSecurity/image-20211214144425527.png" class="">


<p>​	图中只展示了核心过滤器，其它的非核心过滤器并没有在图中展示。</p>
<p><strong>UsernamePasswordAuthenticationFilter</strong>:负责处理我们在登陆页面填写了用户名密码后的登陆请求。入门案例的认证工作主要有它负责。</p>
<p><strong>ExceptionTranslationFilter：</strong>处理过滤器链中抛出的任何AccessDeniedException和AuthenticationException 。</p>
<p><strong>FilterSecurityInterceptor：</strong>负责权限校验的过滤器。</p>
<p>​	</p>
<p>​	我们可以通过Debug查看当前系统中SpringSecurity过滤器链中有哪些过滤器及它们的顺序。</p>
<img data-src="/2022/10/07/Spring_Family/SpringSecurity/image-20211214145824903.png" class="">




<h3 id="3-2-2-认证流程详解"><a href="#3-2-2-认证流程详解" class="headerlink" title="3.2.2 认证流程详解"></a>3.2.2 认证流程详解</h3><img data-src="/2022/10/07/Spring_Family/SpringSecurity/image-20211214151515385.png" class="">


<p>概念速查:</p>
<p>Authentication接口: 它的实现类，表示当前访问系统的用户，封装了用户相关信息。</p>
<p>AuthenticationManager接口：定义了认证Authentication的方法 </p>
<p>UserDetailsService接口：加载用户特定数据的核心接口。里面定义了一个根据用户名查询用户信息的方法。</p>
<p>UserDetails接口：提供核心用户信息。通过UserDetailsService根据用户名获取处理的用户信息要封装成UserDetails对象返回。然后将这些信息封装到Authentication对象中。</p>
<h2 id="3-3-实现方式"><a href="#3-3-实现方式" class="headerlink" title="3.3 实现方式"></a>3.3 实现方式</h2><ul>
<li>前后端不分离，登录页面由自己提供——3.1(不推荐)</li>
<li>前后端分离，登录页面由前端提供     ——3.2(推荐，后序我们其他授权和别的操作，均以这个为主)</li>
</ul>
<p>在第二部分的基础上，进行操作</p>
<h3 id="3-3-1-前后端不分离"><a href="#3-3-1-前后端不分离" class="headerlink" title="3.3.1 前后端不分离"></a>3.3.1 前后端不分离</h3><h4 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1 准备工作"></a>1 准备工作</h4><h5 id="application-yml"><a href="#application-yml" class="headerlink" title="application.yml"></a>application.yml</h5><pre><code class="yaml">spring:
  application:
    name: msb-spring-security
  datasource:
    druid:
      url: jdbc:mysql://localhost:3306/mydb?characterEncoding=utf-8&amp;serverTimezone=UTC
      username: root
      password: root
      driver-class-name: com.mysql.cj.jdbc.Driver

mybatis-plus:
  mapper-locations: classpath:mapper/*.xml
logging:
  level:
    com:
      zjj:
        mapper: debug
server:
  port: 8081
</code></pre>
<h5 id="数据库准备"><a href="#数据库准备" class="headerlink" title="数据库准备"></a>数据库准备</h5><pre><code class="sql">
SET NAMES utf8mb4;
SET FOREIGN_KEY_CHECKS = 0;

-- ----------------------------
-- Table structure for sys_menu
-- ----------------------------
DROP TABLE IF EXISTS `sys_menu`;
CREATE TABLE `sys_menu`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `menu_name` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL DEFAULT &#39;NULL&#39; COMMENT &#39;菜单名&#39;,
  `path` varchar(200) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT &#39;路由地址&#39;,
  `component` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT &#39;组件路径&#39;,
  `visible` char(1) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT &#39;0&#39; COMMENT &#39;菜单状态（0显示 1隐藏）&#39;,
  `status` char(1) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT &#39;0&#39; COMMENT &#39;菜单状态（0正常 1停用）&#39;,
  `perms` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT &#39;权限标识&#39;,
  `icon` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT &#39;#&#39; COMMENT &#39;菜单图标&#39;,
  `create_by` bigint(20) NULL DEFAULT NULL,
  `create_time` datetime NULL DEFAULT NULL,
  `update_by` bigint(20) NULL DEFAULT NULL,
  `update_time` datetime NULL DEFAULT NULL,
  `del_flag` int(11) NULL DEFAULT 0 COMMENT &#39;是否删除（0未删除 1已删除）&#39;,
  `remark` varchar(500) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT &#39;备注&#39;,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 6 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci COMMENT = &#39;菜单表&#39; ROW_FORMAT = Dynamic;

DROP TABLE IF EXISTS `sys_role`;
CREATE TABLE `sys_role`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `name` varchar(128) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  `role_key` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT &#39;角色权限字符串&#39;,
  `status` char(1) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT &#39;0&#39; COMMENT &#39;角色状态（0正常 1停用）&#39;,
  `del_flag` int(1) NULL DEFAULT 0 COMMENT &#39;del_flag&#39;,
  `create_by` bigint(200) NULL DEFAULT NULL,
  `create_time` datetime NULL DEFAULT NULL,
  `update_by` bigint(200) NULL DEFAULT NULL,
  `update_time` datetime NULL DEFAULT NULL,
  `remark` varchar(500) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT &#39;备注&#39;,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 6 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci COMMENT = &#39;角色表&#39; ROW_FORMAT = Dynamic;

DROP TABLE IF EXISTS `sys_role_menu`;
CREATE TABLE `sys_role_menu`  (
  `role_id` bigint(200) NOT NULL AUTO_INCREMENT COMMENT &#39;角色ID&#39;,
  `menu_id` bigint(200) NOT NULL DEFAULT 0 COMMENT &#39;菜单id&#39;,
  PRIMARY KEY (`role_id`, `menu_id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 4 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Dynamic;

DROP TABLE IF EXISTS `sys_user`;
CREATE TABLE `sys_user`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT &#39;主键&#39;,
  `user_name` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL DEFAULT &#39;NULL&#39; COMMENT &#39;用户名&#39;,
  `nick_name` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL DEFAULT &#39;NULL&#39; COMMENT &#39;昵称&#39;,
  `password` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL DEFAULT &#39;NULL&#39; COMMENT &#39;密码&#39;,
  `status` char(1) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT &#39;0&#39; COMMENT &#39;账号状态（0正常 1停用）&#39;,
  `email` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT &#39;邮箱&#39;,
  `phonenumber` varchar(32) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT &#39;手机号&#39;,
  `sex` char(1) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT &#39;用户性别（0男，1女，2未知）&#39;,
  `avatar` varchar(128) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT &#39;头像&#39;,
  `user_type` char(1) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL DEFAULT &#39;1&#39; COMMENT &#39;用户类型（0管理员，1普通用户）&#39;,
  `create_by` bigint(20) NULL DEFAULT NULL COMMENT &#39;创建人的用户id&#39;,
  `create_time` datetime NULL DEFAULT NULL COMMENT &#39;创建时间&#39;,
  `update_by` bigint(20) NULL DEFAULT NULL COMMENT &#39;更新人&#39;,
  `update_time` datetime NULL DEFAULT NULL COMMENT &#39;更新时间&#39;,
  `del_flag` int(11) NULL DEFAULT 0 COMMENT &#39;删除标志（0代表未删除，1代表已删除）&#39;,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 4 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci COMMENT = &#39;用户表&#39; ROW_FORMAT = Dynamic;


DROP TABLE IF EXISTS `sys_user_role`;
CREATE TABLE `sys_user_role`  (
  `user_id` bigint(200) NOT NULL AUTO_INCREMENT COMMENT &#39;用户id&#39;,
  `role_id` bigint(200) NOT NULL DEFAULT 0 COMMENT &#39;角色id&#39;,
  PRIMARY KEY (`user_id`, `role_id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 4 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Dynamic;



INSERT INTO `sys_menu` VALUES (2, &#39;demo:select&#39;, NULL, NULL, &#39;0&#39;, &#39;0&#39;, NULL, &#39;#&#39;, NULL, NULL, NULL, NULL, 0, NULL);
INSERT INTO `sys_menu` VALUES (3, &#39;demo:update&#39;, NULL, NULL, &#39;0&#39;, &#39;0&#39;, NULL, &#39;#&#39;, NULL, NULL, NULL, NULL, 0, NULL);
INSERT INTO `sys_menu` VALUES (4, &#39;demo:insert&#39;, NULL, NULL, &#39;0&#39;, &#39;0&#39;, NULL, &#39;#&#39;, NULL, NULL, NULL, NULL, 0, NULL);
INSERT INTO `sys_menu` VALUES (5, &#39;demo:delete&#39;, NULL, NULL, &#39;0&#39;, &#39;0&#39;, NULL, &#39;#&#39;, NULL, NULL, NULL, NULL, 0, NULL);

INSERT INTO `sys_role` VALUES (3, &#39;管理员&#39;, NULL, &#39;0&#39;, 0, NULL, NULL, NULL, NULL, NULL);
INSERT INTO `sys_role` VALUES (4, &#39;员工&#39;, NULL, &#39;0&#39;, 0, NULL, NULL, NULL, NULL, NULL);
INSERT INTO `sys_role` VALUES (5, &#39;普通用户&#39;, NULL, &#39;0&#39;, 0, NULL, NULL, NULL, NULL, NULL);

INSERT INTO `sys_role_menu` VALUES (1, 1);
INSERT INTO `sys_role_menu` VALUES (1, 2);
INSERT INTO `sys_role_menu` VALUES (1, 3);
INSERT INTO `sys_role_menu` VALUES (1, 4);
INSERT INTO `sys_role_menu` VALUES (2, 1);
INSERT INTO `sys_role_menu` VALUES (2, 4);
INSERT INTO `sys_role_menu` VALUES (3, 1);

INSERT INTO `sys_user` VALUES (1, &#39;zhangsan&#39;, &#39;zhangsan&#39;, &#39;$2a$10$CFr1dsdBA3XDNrNRtsfX3ezUj/pUVsEhkg6cpKa9QG0oraGBMOZ5u&#39;, &#39;0&#39;, &#39;12@qq.com&#39;, &#39;123&#39;, &#39;1&#39;, NULL, &#39;0&#39;, NULL, &#39;2022-08-03 08:51:48&#39;, NULL, &#39;2022-08-27 08:51:54&#39;, 0);
INSERT INTO `sys_user` VALUES (2, &#39;lisi&#39;, &#39;lisi&#39;, &#39;$2a$10$GRjbaR73zd9c9tCnj0BnnexqGSbQzXCVrXTPVEiOJqaypwCijbe4O&#39;, &#39;0&#39;, &#39;65.@126.com&#39;, &#39;456&#39;, &#39;0&#39;, NULL, &#39;0&#39;, NULL, &#39;2022-08-19 08:51:51&#39;, NULL, &#39;2022-08-27 08:51:59&#39;, 0);
INSERT INTO `sys_user` VALUES (3, &#39;wangwu&#39;, &#39;wangwu&#39;, &#39;$2a$10$PsFb4a4bn0A.5pf4Rq5kheKaOkrhJOaz6hlu2WmBnkE8H9wZOoNXS&#39;, &#39;0&#39;, NULL, NULL, NULL, NULL, &#39;1&#39;, NULL, NULL, NULL, NULL, 0);

INSERT INTO `sys_user_role` VALUES (1, 1);
INSERT INTO `sys_user_role` VALUES (2, 2);
INSERT INTO `sys_user_role` VALUES (3, 3);
</code></pre>
<h5 id="实体类1"><a href="#实体类1" class="headerlink" title="实体类1"></a>实体类1</h5><p>​	这里目前只提供了登录所需要的User对象，以及我们自己封装的 USerDetails 对象，其余对象自己后续生成。（easycode 、 mybatisX、….都行）</p>
<pre><code class="java">package com.zjj.pojo;

import java.util.Date;
import com.baomidou.mybatisplus.extension.activerecord.Model;
import java.io.Serializable;
import lombok.*;
import com.baomidou.mybatisplus.annotation.TableName;
import com.baomidou.mybatisplus.annotation.TableField;

/**
 * 用户表(User)表实体类
 *
 * @author makejava
 * @since 2022-08-24 21:09:13
 */

@AllArgsConstructor
@NoArgsConstructor
@Data
@ToString
@TableName(value = &quot;sys_user&quot;)
public class User implements Serializable &#123;
    /**
    * 主键    
    */ 
    @TableField(&quot;id&quot;)
    private Long id;
    
    /**
    * 用户名    
    */ 
    @TableField(&quot;user_name&quot;)
    private String username;
    
    /**
    * 昵称    
    */ 
    @TableField(&quot;nick_name&quot;)
    private String nickName;
    
    /**
    * 密码    
    */ 
    @TableField(&quot;password&quot;)
    private String password;
    
    /**
    * 账号状态（0正常 1停用）    
    */ 
    @TableField(&quot;status&quot;)
    private String status;
    
    /**
    * 邮箱    
    */ 
    @TableField(&quot;email&quot;)
    private String email;
    
    /**
    * 手机号    
    */ 
    @TableField(&quot;phonenumber&quot;)
    private String phonenumber;
    
    /**
    * 用户性别（0男，1女，2未知）    
    */ 
    @TableField(&quot;sex&quot;)
    private String sex;
    
    /**
    * 头像    
    */ 
    @TableField(&quot;avatar&quot;)
    private String avatar;
    
    /**
    * 用户类型（0管理员，1普通用户）    
    */ 
    @TableField(&quot;user_type&quot;)
    private String userType;
    
    /**
    * 创建人的用户id    
    */ 
    @TableField(&quot;create_by&quot;)
    private Long createBy;
    
    /**
    * 创建时间    
    */ 
    @TableField(&quot;create_time&quot;)
    private Date createTime;
    
    /**
    * 更新人    
    */ 
    @TableField(&quot;update_by&quot;)
    private Long updateBy;
    
    /**
    * 更新时间    
    */ 
    @TableField(&quot;update_time&quot;)
    private Date updateTime;
    
    /**
    * 删除标志（0代表未删除，1代表已删除）    
    */ 
    @TableField(&quot;del_flag&quot;)
    private Integer delFlag;
    

&#125;
</code></pre>
<h5 id="实体类2"><a href="#实体类2" class="headerlink" title="实体类2"></a>实体类2</h5><pre><code class="java">import com.alibaba.fastjson.annotation.JSONField;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.ToString;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.userdetails.UserDetails;

import java.util.Collection;
import java.util.List;
import java.util.stream.Collectors;

@AllArgsConstructor
@NoArgsConstructor
@Data
@ToString
public class LoginUser implements UserDetails &#123;
    private User user;

    private List&lt;String&gt; permission;

    public LoginUser(User user, List&lt;String&gt; permission) &#123;
        this.user = user;
        this.permission = permission;
    &#125;

    @JSONField(serialize = false) //redis存储的话会出现问题，不让他序列化，主要为了安全
    List&lt;SimpleGrantedAuthority&gt; authorities ;
    @Override
    public Collection&lt;? extends GrantedAuthority&gt; getAuthorities() &#123;
        // 把permission中的String类型的权限信息封装成 SimpleGrantedAuthority 对象
        if (null != authorities) return authorities;//要是有信息就不用再授权了
        authorities = permission.stream()
                .map(SimpleGrantedAuthority::new)
                .collect(Collectors.toList());
        return authorities;
    &#125;

    @Override
    public String getPassword() &#123;
        return user.getPassword();
    &#125;

    @Override
    public String getUsername() &#123;
        return user.getUsername();
    &#125;

    @Override
    public boolean isAccountNonExpired() &#123;
        return true;
    &#125;

    @Override
    public boolean isAccountNonLocked() &#123;
        return true;
    &#125;

    @Override
    public boolean isCredentialsNonExpired() &#123;
        return true;
    &#125;

    @Override
    public boolean isEnabled() &#123;
        return true;
    &#125;
&#125;
</code></pre>
<h4 id="2-重写一个登录服务-ServiceImpl"><a href="#2-重写一个登录服务-ServiceImpl" class="headerlink" title="2 重写一个登录服务(ServiceImpl)"></a>2 重写一个登录服务(ServiceImpl)</h4><p>​	这里要实现一个实现 UserDetailsService ，重写loadUserByUsername，因为这里是我们认证的地方，在下一个章节我们会具体说明</p>
<pre><code class="java">package com.zjj.service.impl;

import com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;
import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;
import com.zjj.mapper.UserMapper;
import com.zjj.pojo.LoginUser;
import com.zjj.pojo.User;
import com.zjj.service.UserService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;

import java.util.ArrayList;
import java.util.List;
import java.util.Objects;

/**
 * 用户表(User)表服务实现类
 * @author makejava
 * @since 2022-08-24 21:09:13
 */
@Service(&quot;userService&quot;)
public class UserServiceImpl extends ServiceImpl&lt;UserMapper, User&gt;
        implements UserService, UserDetailsService &#123;
    @Autowired
    private UserMapper userMapper;

    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException &#123;
        LambdaQueryWrapper&lt;User&gt; qw = new LambdaQueryWrapper&lt;&gt;();
        qw.eq(User::getUsername, username);
        User user = userMapper.selectOne(qw);
        if (Objects.isNull(user)) &#123;
            throw new UsernameNotFoundException(&quot;没有该用户&quot;);
        &#125;

        // TODO 权限信息后序添加
        List&lt;String&gt; menus = userMapper.findMenuByUserId(user.getId());
        List&lt;String&gt; roles = userMapper.findRoleByUserId(user.getId());
        List&lt;String&gt; res = new ArrayList&lt;&gt;();

        for (String menu : menus) &#123;
            res.add(menu);
        &#125;
        for (String role : roles) &#123;
            res.add(&quot;ROLE_&quot;+role);
        &#125;
        // 用户的权限和角色直接赋值 的话 要注意写法
        /*
        1、我们没有user对象直接往回 new UserDetails(username,password,Authorities) 对象时，
            要注意Authorities手动String转化可以用 AuthorityUtils.commaSeparatedStringToAuthorityList(String str)
                但是里面的 str里面包含了权限以及角色，每个要用 “,” 间隔，而且角色开头要要拼接 ROLE_

        2、我们自定义了user 实现了 UserDetails 对象 我们重写了 getAuthorities属性，具体看这个类的注释
            他在初始化值的时候我们传参传递的是一个list对象，这个时候我们不需要用 “，” 间隔，但是角色前要加 ROLE_
         */
        return new LoginUser(user,res);
    &#125;
&#125;
</code></pre>
<h4 id="3-重写mapper层和对应的映射文件"><a href="#3-重写mapper层和对应的映射文件" class="headerlink" title="3 重写mapper层和对应的映射文件"></a>3 重写mapper层和对应的映射文件</h4><pre><code class="java">import com.baomidou.mybatisplus.core.mapper.BaseMapper;
import com.zjj.pojo.User;
import org.apache.ibatis.annotations.Mapper;

import java.util.List;

/**
 * 用户表(User)表数据库访问层
 *
 * @author makejava
 * @since 2022-08-24 21:09:13
 */

@Mapper
public interface UserMapper extends BaseMapper&lt;User&gt; &#123;
    public List&lt;String&gt; findMenuByUserId(Long id);
    public List&lt;String&gt; findRoleByUserId(Long id);

&#125;
</code></pre>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;com.zjj.mapper.UserMapper&quot;&gt;

    &lt;sql id=&quot;AllUserColumn&quot;&gt;id , user_name , nick_name , password , status , email , phonenumber , sex , avatar , user_type , create_by , create_time , update_by , update_time , del_flag &lt;/sql&gt;   
    &lt;resultMap type=&quot;com.zjj.pojo.User&quot; id=&quot;UserMap&quot;&gt;
        &lt;result property=&quot;id&quot; column=&quot;id&quot; /&gt;
        &lt;result property=&quot;userName&quot; column=&quot;user_name&quot; /&gt;
        &lt;result property=&quot;nickName&quot; column=&quot;nick_name&quot; /&gt;
        &lt;result property=&quot;password&quot; column=&quot;password&quot; /&gt;
        &lt;result property=&quot;status&quot; column=&quot;status&quot; /&gt;
        &lt;result property=&quot;email&quot; column=&quot;email&quot; /&gt;
        &lt;result property=&quot;phonenumber&quot; column=&quot;phonenumber&quot; /&gt;
        &lt;result property=&quot;sex&quot; column=&quot;sex&quot; /&gt;
        &lt;result property=&quot;avatar&quot; column=&quot;avatar&quot; /&gt;
        &lt;result property=&quot;userType&quot; column=&quot;user_type&quot; /&gt;
        &lt;result property=&quot;createBy&quot; column=&quot;create_by&quot; /&gt;
        &lt;result property=&quot;createTime&quot; column=&quot;create_time&quot; /&gt;
        &lt;result property=&quot;updateBy&quot; column=&quot;update_by&quot; /&gt;
        &lt;result property=&quot;updateTime&quot; column=&quot;update_time&quot; /&gt;
        &lt;result property=&quot;delFlag&quot; column=&quot;del_flag&quot; /&gt;
    &lt;/resultMap&gt;
    &lt;select id=&quot;findMenuByUserId&quot; resultType=&quot;java.lang.String&quot;&gt;
        SELECT
            distinct(m.menu_name)
        FROM
            sys_user_role ur
                LEFT JOIN sys_user u on u.id = ur.user_id
                LEFT JOIN sys_role r ON ur.role_id = r.id
                LEFT JOIN sys_role_menu rm ON ur.role_id = rm.role_id
                LEFT JOIN sys_menu m ON m.id = rm.menu_id
        WHERE
            u.id = #&#123;args1&#125;
          AND r.status = 0
          AND m.status = 0
    &lt;/select&gt;
    &lt;select id=&quot;findRoleByUserId&quot; resultType=&quot;java.lang.String&quot;&gt;
        SELECT
            distinct(r.name)
        FROM
            sys_user_role ur
                LEFT JOIN sys_user u on u.id = ur.user_id
                LEFT JOIN sys_role r ON ur.role_id = r.id
                LEFT JOIN sys_role_menu rm ON ur.role_id = rm.role_id
                LEFT JOIN sys_menu m ON m.id = rm.menu_id
        WHERE
            u.id = #&#123;args1&#125;
          AND r.status = 0
          AND m.status = 0
    &lt;/select&gt;
    

&lt;/mapper&gt;
</code></pre>
<h4 id="4-导入我们的登录页面"><a href="#4-导入我们的登录页面" class="headerlink" title="4 导入我们的登录页面"></a>4 导入我们的登录页面</h4><pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
    &lt;head&gt;
        &lt;meta charset=&quot;UTF-8&quot;&gt;
        &lt;title&gt;内容&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;form action=&quot;/login&quot; method=&quot;post&quot;&gt;
            username:&lt;input type=&quot;text&quot; name=&quot;username&quot;/&gt;&lt;br/&gt;
            password:&lt;input type=&quot;password&quot; name=&quot;password&quot;/&gt;&lt;br/&gt;
            &lt;input type=&quot;submit&quot; value=&quot;提交&quot;/&gt;
        &lt;/form&gt;

    &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h4 id="5-提供登录接口"><a href="#5-提供登录接口" class="headerlink" title="5 提供登录接口"></a>5 提供登录接口</h4><p>​	就是一个页面的跳转指定我们的登录页面(&#x3D;&#x3D;要配置的&#x3D;&#x3D;)</p>
<pre><code class="java">import com.zjj.pojo.User;
import com.zjj.service.UserService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;
@Controller
public class LoginController &#123;
    @Autowired
    private UserService userService;

    @RequestMapping(&quot;/demo&quot;)
    @ResponseBody
    public String demo() &#123;
        return &quot;demo&quot;;
    &#125;

    // 登录页面
    @RequestMapping(&quot;/showLogin&quot;)
    public String logint() &#123;
        System.out.println(&quot;logint invoked&quot;);
        return &quot;login&quot;;
    &#125;
&#125;
</code></pre>
<h4 id="6-修改配置类"><a href="#6-修改配置类" class="headerlink" title="6 修改配置类"></a>6 修改配置类</h4><p>​	主要内容和细节，在formLogin里面，一定仔细查看注释，小细节很多</p>
<pre><code class="java">import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;

@Configuration
public class MySecurityCore extends WebSecurityConfigurerAdapter &#123;
    @Bean
    public PasswordEncoder getPasswordEncoder()&#123;
        return new BCryptPasswordEncoder();
    &#125;

    @Override
    protected void configure(HttpSecurity http) throws Exception &#123;

        // http.formLogin() 所有和表单有关系的
        http.formLogin()
                // 登录页面，走一个controller
                // 注意要和，LoginProcessingUrl 配合使用，不然在表单中的action中 url 失效
                // 因为只配置loginPage()， 会导致在初始化的时候将loginProcessingUrl的配置相同化，可以自己debug 在AbstractAuthenticationFilterConfigurer 的 updateAuthenticationDefaults 方法
                // 也就是说loginPage(&quot;/login&quot;)  loginProcessingUrl(&quot;/login&quot;),导致提交信息失败最终导致认证失败
                .loginPage(&quot;/showLogin&quot;)
                // 当发现什么URL时，把请求转发给自定义登录逻辑
                // 表单提交的地址 action ,他就会直接去认证进入到 UserDetailsServiceImpl
                // 去这里进行用户的验证 和 用户权限信息的集体封装
                .loginProcessingUrl(&quot;/login&quot;)
                // 登录成功的操作
                // 下面两种方法都可以，推荐第二种，两种同时写第一个直接失效
                // 第一种写法，要注意在写映射的时候要注意请求的方法 get/post
                .successForwardUrl(&quot;/showMain&quot;)
                .successHandler((request, response, authentication) -&gt; &#123;
                    System.out.println(&quot;successHandler invoked&quot;);
                    // 我们在每次请求同一个页面尽量使用重定向，要是请求转发
                    // 因为请求转发是浏览器的行为，每次都要请求服务器并且重复提交表单，不好
                    // response.sendRedirect(&quot;/fail&quot;);
                    LoginUser loginUser = (LoginUser) authentication.getPrincipal();
                    for (String s : loginUser.getPermission()) &#123;
                        System.out.println(s);
                    &#125;
                &#125;)
                // 登录失败的操作
                // 内容和上述情况相同，只是一个成功的一个失败的
                .failureForwardUrl(&quot;/fail&quot;)
                // 当前端表单传递过来的用户名参数、密码参数名和后端不对应，可以利用下列方法
                // 指定前端传递过来的用户名参数名称，默认 username
                //.usernameParameter(&quot;MyuserName&quot;)
                // 指定前端传递过来的密码参数名称，默认 password
                //.passwordParameter(&quot;MypassWord&quot;)
        ;

        // http.authorizeRequests() 所有和授权相关
        http.authorizeRequests()
                // 这里面支持 正则 和 ant表达式
                .antMatchers(&quot;/showLogin&quot;).anonymous()
                .antMatchers(&quot;/js/**&quot;).permitAll()
                .anyRequest().authenticated();


        // http.csrf
        http.csrf().disable()
                // 不通过Session获取SecurityContext
                // 因为我们使用了前后端分离的思想，在session中不存在参数，要用让东西存在它里面，所以不让他生成
                .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS);

    &#125;
&#125;
</code></pre>
<h4 id="7-启动测试"><a href="#7-启动测试" class="headerlink" title="7 启动测试"></a>7 启动测试</h4><p>这个时候我们的用户名、密码都是我们在数据库中存储的（&#x3D;&#x3D;密码必须使我们提供的加密方式加密之后的&#x3D;&#x3D;）</p>
<img data-src="/2022/10/07/Spring_Family/SpringSecurity/image-20220825114004014.png" class="">


<p>登录是否成功，一方面看是否请求被阻拦</p>
<img data-src="/2022/10/07/Spring_Family/SpringSecurity/image-20220825114855873.png" class="">


<p>另一方面，我在配置中设置了认证成功之后的操作 successHandler(request,response.authentication) 我在里面将我们获得认证的用户权限信息全部打印在了控制台，如果错误了也可同样配置一些信息，具体配置将在后序章节详细总结我们的配置类中的配置，现在主要目的是理清逻辑即可</p>
<img data-src="/2022/10/07/Spring_Family/SpringSecurity/image-20220825114558928.png" class="">


<h4 id="8-补充——密码加密"><a href="#8-补充——密码加密" class="headerlink" title="8 补充——密码加密"></a>8 补充——密码加密</h4><p>实际项目中我们不会把密码明文存储在数据库中。</p>
<p>​	默认使用的PasswordEncoder要求数据库中的密码格式为：{id}password 。它会根据id去判断密码的加密方式。但是我们一般不会采用这种方式。所以就需要替换PasswordEncoder。</p>
<p>​	我们一般使用SpringSecurity为我们提供的BCryptPasswordEncoder。</p>
<p>​	我们只需要使用把BCryptPasswordEncoder对象注入Spring容器中，SpringSecurity就会使用该PasswordEncoder来进行密码校验。</p>
<p>​	我们可以定义一个SpringSecurity的配置类，SpringSecurity要求这个配置类要继承WebSecurityConfigurerAdapter。</p>
<pre><code class="java">@Configuration
public class SecurityConfig extends WebSecurityConfigurerAdapter &#123;
    
    @Bean
    public PasswordEncoder passwordEncoder()&#123;
        return new BCryptPasswordEncoder();
    &#125;
&#125;
</code></pre>
<h3 id="3-3-2-前后端分离"><a href="#3-3-2-前后端分离" class="headerlink" title="3.3.2  前后端分离"></a>3.3.2  前后端分离</h3><h4 id="1-准备工作-1"><a href="#1-准备工作-1" class="headerlink" title="1 准备工作"></a>1 准备工作</h4><p>数据库、实体类均和3.3.1中相同</p>
<p>application.yml</p>
<pre><code class="yaml">spring:
  application:
    name: spring-security
  datasource:
    druid:
      url: jdbc:mysql://localhost:3306/mydb?characterEncoding=utf-8&amp;serverTimezone=UTC
      username: root
      password: root
      driver-class-name: com.mysql.cj.jdbc.Driver
  redis:
    host: localhost
    port: 6379
mybatis-plus:
  mapper-locations: classpath:mapper/*.xml
logging:
  level:
    com:
      zjj:
        mapper: debug
</code></pre>
<p>统一返回类</p>
<pre><code class="java">package com.zjj.common;

import com.fasterxml.jackson.annotation.JsonInclude;

@JsonInclude(JsonInclude.Include.NON_NULL)
public class ResponseResult&lt;T&gt; &#123;
    /**
     * 状态码
     */
    private Integer code;
    /**
     * 提示信息，如果有错误时，前端可以获取该字段进行提示
     */
    private String msg;
    /**
     * 查询到的结果数据，
     */
    private T data;

    public ResponseResult(Integer code, String msg) &#123;
        this.code = code;
        this.msg = msg;
    &#125;

    public ResponseResult(Integer code, T data) &#123;
        this.code = code;
        this.data = data;
    &#125;

    public Integer getCode() &#123;
        return code;
    &#125;

    public void setCode(Integer code) &#123;
        this.code = code;
    &#125;

    public String getMsg() &#123;
        return msg;
    &#125;

    public void setMsg(String msg) &#123;
        this.msg = msg;
    &#125;

    public T getData() &#123;
        return data;
    &#125;

    public void setData(T data) &#123;
        this.data = data;
    &#125;

    public ResponseResult(Integer code, String msg, T data) &#123;
        this.code = code;
        this.msg = msg;
        this.data = data;
    &#125;
&#125;
</code></pre>
<p>工具类</p>
<pre><code class="java">import com.alibaba.fastjson.JSON;
import com.alibaba.fastjson.serializer.SerializerFeature;
import com.fasterxml.jackson.databind.JavaType;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.type.TypeFactory;
import org.springframework.data.redis.serializer.RedisSerializer;
import org.springframework.data.redis.serializer.SerializationException;
import com.alibaba.fastjson.parser.ParserConfig;
import org.springframework.util.Assert;
import java.nio.charset.Charset;

/**
 * Redis使用FastJson序列化
 * 
 * @author sg
 */
public class FastJsonRedisSerializer&lt;T&gt; implements RedisSerializer&lt;T&gt;
&#123;

    public static final Charset DEFAULT_CHARSET = Charset.forName(&quot;UTF-8&quot;);

    private Class&lt;T&gt; clazz;

    static
    &#123;
        ParserConfig.getGlobalInstance().setAutoTypeSupport(true);
    &#125;

    public FastJsonRedisSerializer(Class&lt;T&gt; clazz)
    &#123;
        super();
        this.clazz = clazz;
    &#125;

    @Override
    public byte[] serialize(T t) throws SerializationException
    &#123;
        if (t == null)
        &#123;
            return new byte[0];
        &#125;
        return JSON.toJSONString(t, SerializerFeature.WriteClassName).getBytes(DEFAULT_CHARSET);
    &#125;

    @Override
    public T deserialize(byte[] bytes) throws SerializationException
    &#123;
        if (bytes == null || bytes.length &lt;= 0)
        &#123;
            return null;
        &#125;
        String str = new String(bytes, DEFAULT_CHARSET);

        return JSON.parseObject(str, clazz);
    &#125;


    protected JavaType getJavaType(Class&lt;?&gt; clazz)
    &#123;
        return TypeFactory.defaultInstance().constructType(clazz);
    &#125;
&#125;
</code></pre>
<pre><code class="java">package com.zjj.util;

import io.jsonwebtoken.Claims;
import io.jsonwebtoken.JwtBuilder;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.SignatureAlgorithm;

import javax.crypto.SecretKey;
import javax.crypto.spec.SecretKeySpec;
import java.util.Base64;
import java.util.Date;
import java.util.UUID;

/**
 * JWT工具类
 */
public class JwtUtil &#123;

    //有效期为
    public static final Long JWT_TTL = 60 * 60 *1000L;// 60 * 60 *1000  一个小时
    //设置秘钥明文
    public static final String JWT_KEY = &quot;sangeng&quot;;

    public static String getUUID()&#123;
        String token = UUID.randomUUID().toString().replaceAll(&quot;-&quot;, &quot;&quot;);
        return token;
    &#125;
    
    /**
     * 生成jtw
     * @param subject token中要存放的数据（json格式）
     * @return
     */
    public static String createJWT(String subject) &#123;
        JwtBuilder builder = getJwtBuilder(subject, null, getUUID());// 设置过期时间
        return builder.compact();
    &#125;

    /**
     * 生成jtw
     * @param subject token中要存放的数据（json格式）
     * @param ttlMillis token超时时间
     * @return
     */
    public static String createJWT(String subject, Long ttlMillis) &#123;
        JwtBuilder builder = getJwtBuilder(subject, ttlMillis, getUUID());// 设置过期时间
        return builder.compact();
    &#125;

    private static JwtBuilder getJwtBuilder(String subject, Long ttlMillis, String uuid) &#123;
        SignatureAlgorithm signatureAlgorithm = SignatureAlgorithm.HS256;
        SecretKey secretKey = generalKey();
        long nowMillis = System.currentTimeMillis();
        Date now = new Date(nowMillis);
        if(ttlMillis==null)&#123;
            ttlMillis=JwtUtil.JWT_TTL;
        &#125;
        long expMillis = nowMillis + ttlMillis;
        Date expDate = new Date(expMillis);
        return Jwts.builder()
                .setId(uuid)              //唯一的ID
                .setSubject(subject)   // 主题  可以是JSON数据
                .setIssuer(&quot;sg&quot;)     // 签发者
                .setIssuedAt(now)      // 签发时间
                .signWith(signatureAlgorithm, secretKey) //使用HS256对称加密算法签名, 第二个参数为秘钥
                .setExpiration(expDate);
    &#125;

    /**
     * 创建token
     * @param id
     * @param subject
     * @param ttlMillis
     * @return
     */
    public static String createJWT(String id, String subject, Long ttlMillis) &#123;
        JwtBuilder builder = getJwtBuilder(subject, ttlMillis, id);// 设置过期时间
        return builder.compact();
    &#125;

    public static void main(String[] args) throws Exception &#123;
        String token = &quot;eyJhbGciOiJIUzI1NiJ9.eyJqdGkiOiJjYWM2ZDVhZi1mNjVlLTQ0MDAtYjcxMi0zYWEwOGIyOTIwYjQiLCJzdWIiOiJzZyIsImlzcyI6InNnIiwiaWF0IjoxNjM4MTA2NzEyLCJleHAiOjE2MzgxMTAzMTJ9.JVsSbkP94wuczb4QryQbAke3ysBDIL5ou8fWsbt_ebg&quot;;
        Claims claims = parseJWT(token);
        System.out.println(claims);
    &#125;

    /**
     * 生成加密后的秘钥 secretKey
     * @return
     */
    public static SecretKey generalKey() &#123;
        byte[] encodedKey = Base64.getDecoder().decode(JwtUtil.JWT_KEY);
        SecretKey key = new SecretKeySpec(encodedKey, 0, encodedKey.length, &quot;AES&quot;);
        return key;
    &#125;
    
    /**
     * 解析
     *
     * @param jwt
     * @return
     * @throws Exception
     */
    public static Claims parseJWT(String jwt) throws Exception &#123;
        SecretKey secretKey = generalKey();
        return Jwts.parser()
                .setSigningKey(secretKey)
                .parseClaimsJws(jwt)
                .getBody();
    &#125;


&#125;
</code></pre>
<pre><code class="java">package com.zjj.util;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.redis.core.BoundSetOperations;
import org.springframework.data.redis.core.HashOperations;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.data.redis.core.ValueOperations;
import org.springframework.stereotype.Component;

import java.util.*;
import java.util.concurrent.TimeUnit;

@SuppressWarnings(value = &#123; &quot;unchecked&quot;, &quot;rawtypes&quot; &#125;)
@Component
public class RedisCache
&#123;
    @Autowired
    public RedisTemplate redisTemplate;

    /**
     * 缓存基本的对象，Integer、String、实体类等
     *
     * @param key 缓存的键值
     * @param value 缓存的值
     */
    public &lt;T&gt; void setCacheObject(final String key, final T value)
    &#123;
        redisTemplate.opsForValue().set(key, value);
    &#125;

    /**
     * 缓存基本的对象，Integer、String、实体类等
     *
     * @param key 缓存的键值
     * @param value 缓存的值
     * @param timeout 时间
     * @param timeUnit 时间颗粒度
     */
    public &lt;T&gt; void setCacheObject(final String key, final T value, final Integer timeout, final TimeUnit timeUnit)
    &#123;
        redisTemplate.opsForValue().set(key, value, timeout, timeUnit);
    &#125;

    /**
     * 设置有效时间
     *
     * @param key Redis键
     * @param timeout 超时时间
     * @return true=设置成功；false=设置失败
     */
    public boolean expire(final String key, final long timeout)
    &#123;
        return expire(key, timeout, TimeUnit.SECONDS);
    &#125;

    /**
     * 设置有效时间
     *
     * @param key Redis键
     * @param timeout 超时时间
     * @param unit 时间单位
     * @return true=设置成功；false=设置失败
     */
    public boolean expire(final String key, final long timeout, final TimeUnit unit)
    &#123;
        return redisTemplate.expire(key, timeout, unit);
    &#125;

    /**
     * 获得缓存的基本对象。
     *
     * @param key 缓存键值
     * @return 缓存键值对应的数据
     */
    public &lt;T&gt; T getCacheObject(final String key)
    &#123;
        ValueOperations&lt;String, T&gt; operation = redisTemplate.opsForValue();
        return operation.get(key);
    &#125;

    /**
     * 删除单个对象
     *
     * @param key
     */
    public boolean deleteObject(final String key)
    &#123;
        return redisTemplate.delete(key);
    &#125;

    /**
     * 删除集合对象
     *
     * @param collection 多个对象
     * @return
     */
    public long deleteObject(final Collection collection)
    &#123;
        return redisTemplate.delete(collection);
    &#125;

    /**
     * 缓存List数据
     *
     * @param key 缓存的键值
     * @param dataList 待缓存的List数据
     * @return 缓存的对象
     */
    public &lt;T&gt; long setCacheList(final String key, final List&lt;T&gt; dataList)
    &#123;
        Long count = redisTemplate.opsForList().rightPushAll(key, dataList);
        return count == null ? 0 : count;
    &#125;

    /**
     * 获得缓存的list对象
     *
     * @param key 缓存的键值
     * @return 缓存键值对应的数据
     */
    public &lt;T&gt; List&lt;T&gt; getCacheList(final String key)
    &#123;
        return redisTemplate.opsForList().range(key, 0, -1);
    &#125;

    /**
     * 缓存Set
     *
     * @param key 缓存键值
     * @param dataSet 缓存的数据
     * @return 缓存数据的对象
     */
    public &lt;T&gt; BoundSetOperations&lt;String, T&gt; setCacheSet(final String key, final Set&lt;T&gt; dataSet)
    &#123;
        BoundSetOperations&lt;String, T&gt; setOperation = redisTemplate.boundSetOps(key);
        Iterator&lt;T&gt; it = dataSet.iterator();
        while (it.hasNext())
        &#123;
            setOperation.add(it.next());
        &#125;
        return setOperation;
    &#125;

    /**
     * 获得缓存的set
     *
     * @param key
     * @return
     */
    public &lt;T&gt; Set&lt;T&gt; getCacheSet(final String key)
    &#123;
        return redisTemplate.opsForSet().members(key);
    &#125;

    /**
     * 缓存Map
     *
     * @param key
     * @param dataMap
     */
    public &lt;T&gt; void setCacheMap(final String key, final Map&lt;String, T&gt; dataMap)
    &#123;
        if (dataMap != null) &#123;
            redisTemplate.opsForHash().putAll(key, dataMap);
        &#125;
    &#125;

    /**
     * 获得缓存的Map
     *
     * @param key
     * @return
     */
    public &lt;T&gt; Map&lt;String, T&gt; getCacheMap(final String key)
    &#123;
        return redisTemplate.opsForHash().entries(key);
    &#125;

    /**
     * 往Hash中存入数据
     *
     * @param key Redis键
     * @param hKey Hash键
     * @param value 值
     */
    public &lt;T&gt; void setCacheMapValue(final String key, final String hKey, final T value)
    &#123;
        redisTemplate.opsForHash().put(key, hKey, value);
    &#125;

    /**
     * 获取Hash中的数据
     *
     * @param key Redis键
     * @param hKey Hash键
     * @return Hash中的对象
     */
    public &lt;T&gt; T getCacheMapValue(final String key, final String hKey)
    &#123;
        HashOperations&lt;String, String, T&gt; opsForHash = redisTemplate.opsForHash();
        return opsForHash.get(key, hKey);
    &#125;

    /**
     * 删除Hash中的数据
     * 
     * @param key
     * @param hkey
     */
    public void delCacheMapValue(final String key, final String hkey)
    &#123;
        HashOperations hashOperations = redisTemplate.opsForHash();
        hashOperations.delete(key, hkey);
    &#125;

    /**
     * 获取多个Hash中的数据
     *
     * @param key Redis键
     * @param hKeys Hash键集合
     * @return Hash对象集合
     */
    public &lt;T&gt; List&lt;T&gt; getMultiCacheMapValue(final String key, final Collection&lt;Object&gt; hKeys)
    &#123;
        return redisTemplate.opsForHash().multiGet(key, hKeys);
    &#125;

    /**
     * 获得缓存的基本对象列表
     *
     * @param pattern 字符串前缀
     * @return 对象列表
     */
    public Collection&lt;String&gt; keys(final String pattern)
    &#123;
        return redisTemplate.keys(pattern);
    &#125;
&#125;
</code></pre>
<pre><code class="java">package com.zjj.util;

import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

public class WebUtils
&#123;
    /**
     * 将字符串渲染到客户端
     * 
     * @param response 渲染对象
     * @param string 待渲染的字符串
     * @return null
     */
    public static String renderString(HttpServletResponse response, String string) &#123;
        try
        &#123;
            response.setStatus(200);
            response.setContentType(&quot;application/json&quot;);
            response.setCharacterEncoding(&quot;utf-8&quot;);
            response.getWriter().print(string);
        &#125;
        catch (IOException e)
        &#123;
            e.printStackTrace();
        &#125;
        return null;
    &#125;
&#125;
</code></pre>
<pre><code class="java">package com.zjj.config;

import com.zjj.util.FastJsonRedisSerializer;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.redis.connection.RedisConnectionFactory;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.data.redis.serializer.StringRedisSerializer;

@Configuration
public class RedisConfig &#123;

    @Bean
    @SuppressWarnings(value = &#123; &quot;unchecked&quot;, &quot;rawtypes&quot; &#125;)
    public RedisTemplate&lt;Object, Object&gt; redisTemplate(RedisConnectionFactory connectionFactory)
    &#123;
        RedisTemplate&lt;Object, Object&gt; template = new RedisTemplate&lt;&gt;();
        template.setConnectionFactory(connectionFactory);

        FastJsonRedisSerializer serializer = new FastJsonRedisSerializer(Object.class);

        // 使用StringRedisSerializer来序列化和反序列化redis的key值
        template.setKeySerializer(new StringRedisSerializer());
        template.setValueSerializer(serializer);

        // Hash的key也采用StringRedisSerializer的序列化方式
        template.setHashKeySerializer(new StringRedisSerializer());
        template.setHashValueSerializer(serializer);

        template.afterPropertiesSet();
        return template;
    &#125;
&#125;
</code></pre>
<h4 id="2-重写登录服务-ServiceImpl"><a href="#2-重写登录服务-ServiceImpl" class="headerlink" title="2  重写登录服务(ServiceImpl)"></a>2  重写登录服务(ServiceImpl)</h4><p>​	这里我们需要写一个LoginService 、LoginServiceImpl 以及&#x3D;&#x3D;认证服务&#x3D;&#x3D;  UserDetailServiceImpl (后续会详细解释)</p>
<pre><code class="java">package com.zjj.service.impl;

import com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;
import com.zjj.mapper.UserMapper;
import com.zjj.pojo.LoginUser;
import com.zjj.pojo.User;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Objects;

@Service
public class UserDetailServiceImpl implements UserDetailsService &#123;
    @Autowired
    private UserMapper userMapper;

    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException &#123;
        LambdaQueryWrapper&lt;User&gt; qw = new LambdaQueryWrapper&lt;&gt;();
        qw.eq(User::getUserName, username);
        User user = userMapper.selectOne(qw);
        if (Objects.isNull(user)) &#123;
            throw new UsernameNotFoundException(&quot;没有该用户&quot;);
        &#125;

        // TODO 权限信息后序添加
        List&lt;String&gt; menus = userMapper.findMenuByUserId(user.getId());
        List&lt;String&gt; roles = userMapper.findRoleByUserId(user.getId());
        List&lt;String&gt; res = new ArrayList&lt;&gt;();

        
        for (String menu : menus) &#123;
            res.add(menu);
        &#125;
        for (String role : roles) &#123;
            res.add(&quot;ROLE_&quot;+role);
        &#125;
        // 用户的权限和角色直接赋值 的话 要注意写法
        /*
        1、我们没有user对象直接往回 new UserDetails(username,password,Authorities) 对象时，
            要注意Authorities手动String转化可以用 AuthorityUtils.commaSeparatedStringToAuthorityList(String str)
                但是里面的 str里面包含了权限以及角色，每个要用 “,” 间隔，而且角色开头要要拼接 ROLE_

        2、我们自定义了user 实现了 UserDetails 对象 我们重写了 getAuthorities属性，具体看这个类的注释
            他在初始化值的时候我们传参传递的是一个list对象，这个时候我们不需要用 “，” 间隔，但是角色前要加 ROLE_
         */
        return new LoginUser(user,res);
    &#125;
&#125;
</code></pre>
<pre><code class="java">public interface LoginService &#123;
    public ResponseResult login(User user);

    ResponseResult logout();
&#125;
</code></pre>
<pre><code class="java">import com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;
import com.zjj.mapper.UserMapper;
import com.zjj.pojo.LoginUser;
import com.zjj.pojo.User;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;

import java.util.ArrayList;
import java.util.List;
import java.util.Objects;

@Service
public class UserDetailServiceImpl implements UserDetailsService &#123;
    @Autowired
    private UserMapper userMapper;

    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException &#123;
        LambdaQueryWrapper&lt;User&gt; qw = new LambdaQueryWrapper&lt;&gt;();
        qw.eq(User::getUserName, username);
        User user = userMapper.selectOne(qw);
        if (Objects.isNull(user)) &#123;
            throw new UsernameNotFoundException(&quot;没有该用户&quot;);
        &#125;

        // TODO 权限信息后序添加
        List&lt;String&gt; menus = userMapper.findMenuByUserId(user.getId());
        List&lt;String&gt; roles = userMapper.findRoleByUserId(user.getId());
        List&lt;String&gt; res = new ArrayList&lt;&gt;();

        for (String menu : menus) &#123;
            res.add(menu);
        &#125;
        for (String role : roles) &#123;
            res.add(&quot;ROLE_&quot;+role);
        &#125;
        // 用户的权限和角色直接赋值 的话 要注意写法
        /*
        1、我们没有user对象直接往回 new UserDetails(username,password,Authorities) 对象时，
            要注意Authorities手动String转化可以用 AuthorityUtils.commaSeparatedStringToAuthorityList(String str)
                但是里面的 str里面包含了权限以及角色，每个要用 “,” 间隔，而且角色开头要要拼接 ROLE_

        2、我们自定义了user 实现了 UserDetails 对象 我们重写了 getAuthorities属性，具体看这个类的注释
            他在初始化值的时候我们传参传递的是一个list对象，这个时候我们不需要用 “，” 间隔，但是角色前要加 ROLE_
         */
        return new LoginUser(user,res);
    &#125;
&#125;
</code></pre>
<h4 id="3-重写mapper层和对应的映射文件-1"><a href="#3-重写mapper层和对应的映射文件-1" class="headerlink" title="3 重写mapper层和对应的映射文件"></a>3 重写mapper层和对应的映射文件</h4><p>和3.3.1的准备相同</p>
<h4 id="4-配置类配置"><a href="#4-配置类配置" class="headerlink" title="4 配置类配置"></a>4 配置类配置</h4><pre><code class="java">@Configuration
public class SecurityConfig extends WebSecurityConfigurerAdapter &#123;


    @Bean
    public PasswordEncoder passwordEncoder()&#123;
        return new BCryptPasswordEncoder();
    &#125;

    @Override
    protected void configure(HttpSecurity http) throws Exception &#123;
        http
                //关闭csrf
                .csrf().disable()
                //不通过Session获取SecurityContext
                .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)
                .and()
                .authorizeRequests()
                // 对于登录接口 允许匿名访问
                .antMatchers(&quot;/user/login&quot;).anonymous()
                // 除上面外的所有请求全部需要鉴权认证
                .anyRequest().authenticated();
    &#125;

    @Bean
    @Override
    public AuthenticationManager authenticationManagerBean() throws Exception &#123;
        return super.authenticationManagerBean();
    &#125;
&#125;
</code></pre>
<h4 id="5-对接登录接口"><a href="#5-对接登录接口" class="headerlink" title="5 对接登录接口"></a>5 对接登录接口</h4><p>假定登录接口为	“&#x2F;user&#x2F;login”</p>
<pre><code class="java">@Controller
public class LoginController &#123;

    @Autowired
    private LoginService loginService;

    @RequestMapping(&quot;/user/login&quot;)
    @ResponseBody
    public ResponseResult login(@RequestBody User user)&#123;
        return loginService.login(user);
    &#125;
    @RequestMapping(&quot;/user/logout&quot;)
    @ResponseBody
    public ResponseResult logout() &#123;
        return loginService.logout();
    &#125;
&#125;
</code></pre>
<p>5 测试接口</p>
<p>这里用接口测试工具即可，我们没有登录页面，页面是前端提供的，所以我们只需要确保接口测试正确即可</p>
<p><span class="exturl" data-url="aHR0cDovL2xvY2FsaG9zdDo4MDgwL3VzZXIvbG9naW4=">http://localhost:8080/user/login</span></p>
<pre><code class="json">&#123;
    &quot;userName&quot;:&quot;zhangsan&quot;,
    &quot;password&quot;:&quot;zhangsan&quot;
    // &quot;userName&quot;:&quot;lisi&quot;,
    // &quot;password&quot;:&quot;lisi&quot;
    // &quot;userName&quot;:&quot;wangwu&quot;,
    // &quot;password&quot;:&quot;wangwu&quot;
&#125;
</code></pre>
<img data-src="/2022/10/07/Spring_Family/SpringSecurity/image-20220825120818298.png" class="">


<h4 id="6-优化认证——引入Redis"><a href="#6-优化认证——引入Redis" class="headerlink" title="6 优化认证——引入Redis"></a>6 优化认证——引入Redis</h4><p>​	我们在项目中，不可能每次这种常用数据都去数据库访问，这样会给数据库造成极大的负担，导致我们的数据库宕机。因此我们引入的NoSQL数据库、缓存数据库 Redis 用来存储我们短期常用数据。但是问题又来了。怎么存储呢？</p>
<p>​	引入 3.2.1SpringSecurity完整流程 </p>
<img data-src="/2022/10/07/Spring_Family/SpringSecurity/image-20211214144425527.png" class="">


<p>​	我们每次的登录验证都需要经过 UsernamePasswordAuthenticationFilter ，在这个过滤器下我们必须得到一个认证的用户，所以我们在这里为了得到用户的认证信息我们老办法就是去数据库中查找，但是我们现在不想让他老去数据库中找，在他之前我们要是直接能得到这个认证过的用户岂不皆大欢喜，所以我们在他之前也加上一个过滤器用来查找每次请求是否有这个认证用户有的话我们就可以省略掉去数据库中查找他的信息的过程。</p>
<p>​	那么问题又来了我们如何存储一个用户的信息呢？</p>
<p>这里我们可以利用JWT根据我们的用户ID生成一个Token，以他为键值存储到redis中</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA3MDE3NS9hcnRpY2xlL2RldGFpbHMvMTE4NTU5Mjcy">JWT详解</span> ：除了讲解JWT，还很好的帮忙回顾了Token的优势</p>
<pre><code class="java">package com.zjj.filter;

import com.zjj.pojo.LoginUser;
import com.zjj.util.JwtUtil;
import com.zjj.util.RedisCache;
import io.jsonwebtoken.Claims;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Component;
import org.springframework.util.StringUtils;
import org.springframework.web.filter.OncePerRequestFilter;

import javax.servlet.FilterChain;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.util.Objects;

@Component
public class JwtAuthenticationTokenFilter extends OncePerRequestFilter &#123;

    @Autowired
    private RedisCache redisCache;

    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException &#123;
        //获取token
        String token = request.getHeader(&quot;token&quot;);
        if (!StringUtils.hasText(token)) &#123;
            //放行
            /*
            * 解释一下，为什么没有Token还放行，因为没有token可以但是可能他是登录请求
            * 我们还是要放行的，不然所有人都登录不了，但是问题是如果不是为什么还要放行
            * 这里不用担心，如果不是登录请求他就可能会存在User对象的账户和密码，就无法完成第一步的认证工作，跟别说后面的鉴权了，所以他会直接被挡住
            * 其次我们倒数第二个过滤器就是为我们处理我们出现的问题的过滤器，出了问题让他解决就行了，这里的问题其实大多数都是token错误，需要重新认证
            * */
            filterChain.doFilter(request, response);
            return;
        &#125;
        //解析token
        String userid;
        try &#123;
            Claims claims = JwtUtil.parseJWT(token);
            userid = claims.getSubject();
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
            throw new RuntimeException(&quot;token非法&quot;);
        &#125;
        //从redis中获取用户信息
        String redisKey = &quot;login:&quot; + userid;
        LoginUser loginUser = redisCache.getCacheObject(redisKey);
        if(Objects.isNull(loginUser))&#123;
            throw new RuntimeException(&quot;用户未登录&quot;);
        &#125;
        //存入SecurityContextHolder ——&gt; 认证成功的对象都在这
        //TODO 获取权限信息封装到Authentication中
        /*
        * 三参构造可以获取该对象是否是以认证状态
        *  */
        UsernamePasswordAuthenticationToken authenticationToken =
                new UsernamePasswordAuthenticationToken(loginUser,null,loginUser.getAuthorities());
        SecurityContextHolder.getContext().setAuthentication(authenticationToken);
        //放行
        filterChain.doFilter(request, response);
    &#125;
&#125;
</code></pre>
<h4 id="7-修改配置类"><a href="#7-修改配置类" class="headerlink" title="7 修改配置类"></a>7 修改配置类</h4><pre><code class="java">package com.zjj.config;

import com.zjj.filter.JwtAuthenticationTokenFilter;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.AuthenticationEntryPoint;
import org.springframework.security.web.access.AccessDeniedHandler;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;


@Configuration
public class SpringSecurityConfig extends WebSecurityConfigurerAdapter &#123;

    @Autowired
    private JwtAuthenticationTokenFilter jwtAuthenticationTokenFilter;
    @Autowired
    private AuthenticationEntryPoint authenticationEntryPoint;
    @Autowired
    private AccessDeniedHandler accessDeniedHandler;

    @Override
    protected void configure(HttpSecurity http) throws Exception &#123;

        // 认证、授权错误处理
        http.exceptionHandling()
                .authenticationEntryPoint(authenticationEntryPoint)
                .accessDeniedHandler(accessDeniedHandler);
        // 认证过滤器添加
        http.addFilterBefore(jwtAuthenticationTokenFilter, UsernamePasswordAuthenticationFilter.class);

        // url拦截
        http.authorizeRequests()
                // anonymous 匿名 没有认证的才可以访问，permitALL 谁都能访问，不需要认证
                .antMatchers(&quot;/user/login&quot;,&quot;/login&quot;,&quot;/loginPage&quot;).anonymous()
                .antMatchers(&quot;/login.html&quot;,&quot;/fail.html&quot;).permitAll()
                // authenticated 认证了才能访问
                .anyRequest().authenticated();

        //关闭CSRF
        http.csrf().disable()
                // 不通过Session获取SecurityContext
                .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS);
        // Cors
        http.cors();
    &#125;

    @Bean
    @Override
    public AuthenticationManager authenticationManagerBean() throws Exception &#123;
        return super.authenticationManagerBean();
    &#125;


    @Bean
    public PasswordEncoder getPasswordEncoder()&#123;
        return new BCryptPasswordEncoder();
    &#125;
&#125;
</code></pre>
<h4 id="8-测试"><a href="#8-测试" class="headerlink" title="8 测试"></a>8 测试</h4><p>这里要打开你的 redis服务端 ，如果不是本地的，你要去配置中添加配置</p>
<p>最后根据 步骤5 再次测试，成功后你的redis 中会多出一组数据，这就是我们的Token，具体步骤不再演示！</p>
<h1 id="四、UserDetailsService详解"><a href="#四、UserDetailsService详解" class="headerlink" title="四、UserDetailsService详解"></a>四、UserDetailsService详解</h1><p>​	当什么也没有配置的时候，账号和密码是由Spring Security定义生成的。而在实际项目中账号和密码都是从数据库中查询出来的。 所以我们要通过自定义逻辑控制**&#x3D;&#x3D;认证逻辑&#x3D;&#x3D;**。</p>
<img data-src="/2022/10/07/Spring_Family/SpringSecurity/image-20211214151515385.png" class="">


<p>​	如果需要自定义逻辑时，只需要实现UserDetailsService接口即可。接口定义如下：</p>
<img data-src="/2022/10/07/Spring_Family/SpringSecurity/springSecurity-03.jpg" class="">


<h2 id="1-返回值"><a href="#1-返回值" class="headerlink" title="1.返回值"></a>1.返回值</h2><p>​	返回值UserDetails是一个接口，定义如下</p>
<img data-src="/2022/10/07/Spring_Family/SpringSecurity/springSecurity-04.jpg" class="">


<p>​	要想返回UserDetails的实例就只能返回接口的实现类。Spring Security中提供了如下的实例。对于我们只需要使用里面的User类即可。注意User的全限定路径是：</p>
<p>​	org.springframework.security.core.userdetails.User</p>
<p>​	此处经常和系统中自己开发的User类弄混。</p>
<img data-src="/2022/10/07/Spring_Family/SpringSecurity/springSecurity-05.jpg" class="">


<p>​	在User类中提供了很多方法和属性。</p>
<img data-src="/2022/10/07/Spring_Family/SpringSecurity/springSecurity-06.jpg" class="">


<p>​	其中构造方法有两个，调用其中任何一个都可以实例化UserDetails实现类User类的实例。而三个参数的构造方法实际上也是调用7个参数的构造方法。</p>
<p>​	username:用户名</p>
<p>​	password:密码</p>
<p>​	authorities：用户具有的权限。此处不允许为null</p>
<img data-src="/2022/10/07/Spring_Family/SpringSecurity/springSecurity-07.jpg" class="">


<p>​	此处的用户名应该是客户端传递过来的用户名。而密码应该是从数据库中查询出来的密码。Spring Security会根据User中的password和客户端传递过来的password进行比较。如果相同则表示认证通过，如果不相同表示认证失败。</p>
<p>​	authorities里面的权限对于后面学习授权是很有必要的，包含的所有内容为此用户具有的权限，如有里面没有包含某个权限，而在做某个事情时必须包含某个权限则会出现403。&#x3D;&#x3D;通常都是通过AuthorityUtils.commaSeparatedStringToAuthorityList(“”)来创建authorities集合对象的&#x3D;&#x3D;。参数是一个字符串，&#x3D;&#x3D;多个权限使用逗号分隔，角色信息前要加<font color=blue>  ROLE_  </font>来标识不然会当成权限信息处理&#x3D;&#x3D;。</p>
<p><strong>建议</strong></p>
<blockquote>
<p>​	我们的项目中对于用户信息的表，肯定是不同的，我们可以利用这个类，对于用来认证的UserDetails对象进行进一步封装，自定义我们的认证对象。例如：</p>
<pre><code class="java">package com.zjj.pojo;

import com.alibaba.fastjson.annotation.JSONField;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.ToString;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.userdetails.UserDetails;

import java.util.Collection;
import java.util.List;
import java.util.stream.Collectors;

@AllArgsConstructor
@NoArgsConstructor
@Data
@ToString
public class LoginUser implements UserDetails &#123;
    private User user;

    private List&lt;String&gt; permission;

    public LoginUser(User user, List&lt;String&gt; permission) &#123;
        this.user = user;
        this.permission = permission;
    &#125;

    @JSONField(serialize = false) //redis存储的话会出现问题，不让他序列化，主要为了安全
    List&lt;SimpleGrantedAuthority&gt; authorities ;
    @Override
    public Collection&lt;? extends GrantedAuthority&gt; getAuthorities() &#123;
        // 把permission中的String类型的权限信息封装成 SimpleGrantedAuthority 对象
        if (null != authorities) return authorities;//要是有信息就不用再授权了
        authorities = permission.stream()
                .map(SimpleGrantedAuthority::new)
                .collect(Collectors.toList());
        return authorities;
    &#125;

    @Override
    public String getPassword() &#123;
        return user.getPassword();
    &#125;

    @Override
    public String getUsername() &#123;
        return user.getUsername();
    &#125;

    @Override
    public boolean isAccountNonExpired() &#123;
        return true;
    &#125;

    @Override
    public boolean isAccountNonLocked() &#123;
        return true;
    &#125;

    @Override
    public boolean isCredentialsNonExpired() &#123;
        return true;
    &#125;

    @Override
    public boolean isEnabled() &#123;
        return true;
    &#125;
&#125;
</code></pre>
<p>​	这里只是一个例子，我重写了getAuthorities() ，其他的信息我们可以根据我们自己的数据库的User信息进行初始化，这里我为了测试方便其余都事 TRUE 打开了他们的权限</p>
<p>​	这里我自定义个 permission 用来存储我们查询到的权限信息，用它来对authorities来初始化 以及对getAuthorities() 的重写，authorities 是我们根据SpringSecurity 要求封装的权限集合 ，但是要注意，不要让他存储到redis中，redis存储的话会出现问题，不要让他序列化，主要为了安全。</p>
<p>​	这样我们每次认证的时候就直接可以利用这个认证对象，而我们的原生User还可以进行别的操作，这样做更加灵活。&#x3D;&#x3D;推荐********&#x3D;&#x3D;</p>
</blockquote>
<h2 id="2-方法参数"><a href="#2-方法参数" class="headerlink" title="2.方法参数"></a>2.方法参数</h2><p>​	方法参数表示用户名。此值是客户端表单传递过来的数据。默认情况下必须叫username，否则无法接收。</p>
<h2 id="3-异常"><a href="#3-异常" class="headerlink" title="3.异常"></a>3.异常</h2><p>​	UsernameNotFoundException 用户名没有发现异常。在loadUserByUsername中是需要通过自己的逻辑从数据库中取值的。如果通过用户名没有查询到对应的数据，应该抛出UsernameNotFoundException，系统就知道用户名没有查询到。</p>
<h1 id="五、配置类说明-1-—-认证配置"><a href="#五、配置类说明-1-—-认证配置" class="headerlink" title="五、配置类说明 1 — 认证配置"></a>五、配置类说明 1 — 认证配置</h1><h2 id="1-失败跳转"><a href="#1-失败跳转" class="headerlink" title="1.失败跳转"></a>1.失败跳转</h2><p>​	表单处理中成功会跳转到一个地址，失败也可以跳转到一个地址中。</p>
<h3 id="1-1编写页面"><a href="#1-1编写页面" class="headerlink" title="1.1编写页面"></a>1.1编写页面</h3><p>​	在src&#x2F;main&#x2F;resources&#x2F;static下新建fail.html并编写如下内容</p>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
    &lt;head&gt;
        &lt;meta charset=&quot;UTF-8&quot;&gt;
        &lt;title&gt;Title&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        操作失败，请重新登录. &lt;a href=&quot;/login.html&quot;&gt;跳转&lt;/a&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="1-2修改表单配置"><a href="#1-2修改表单配置" class="headerlink" title="1.2修改表单配置"></a>1.2修改表单配置</h3><p>​	在配置方法中表单认证部分添加failureForwardUrl()方法，表示登录失败跳转的url。此处依然是POST请求，所以跳转到可以接收POST请求的控制器&#x2F;fail中。</p>
<pre><code class="java">// 表单认证
http.formLogin()
    .loginProcessingUrl(&quot;/login&quot;)   //当发现/login时认为是登录，需要执行UserDetailsServiceImpl
    .successForwardUrl(&quot;/toMain&quot;)   //此处是post请求
    .failureForwardUrl(&quot;/fail&quot;)     //登录失败跳转地址
    .loginPage(&quot;/login.html&quot;);
</code></pre>
<h3 id="1-3添加控制器方法"><a href="#1-3添加控制器方法" class="headerlink" title="1.3添加控制器方法"></a>1.3添加控制器方法</h3><p>​	在控制器类中添加控制器方法，方法映射路径&#x2F;fail。此处要注意：由于是POST请求访问&#x2F;fail。所以如果返回值直接转发到fail.html中，及时有效果，控制台也会报警告，提示fail.html不支持POST访问方式。</p>
<pre><code class="java">@PostMapping(&quot;/fail&quot;)
public String fail()&#123;
    return &quot;redirect:/fail.html&quot;;
&#125;
</code></pre>
<h3 id="1-4设置fail-html不需要认证"><a href="#1-4设置fail-html不需要认证" class="headerlink" title="1.4设置fail.html不需要认证"></a>1.4设置fail.html不需要认证</h3><p>​	认证失败跳转到fail.html页面中，所以必须配置fail.html不需要被认证。需要修改配置类中内容</p>
<pre><code class="java">// url 拦截
http.authorizeRequests()
        .antMatchers(&quot;/login.html&quot;).permitAll() //login.html不需要被认证
        .antMatchers(&quot;/fail.html&quot;).permitAll()  //fail.html不需要被认证
        .anyRequest().authenticated();//所有的请求都必须被认证。必须登录后才能访问。
</code></pre>
<h2 id="2-设置请求账户和密码的参数名"><a href="#2-设置请求账户和密码的参数名" class="headerlink" title="2.设置请求账户和密码的参数名"></a>2.设置请求账户和密码的参数名</h2><h3 id="2-1源码简介"><a href="#2-1源码简介" class="headerlink" title="2.1源码简介"></a>2.1源码简介</h3><p>​	当进行登录时会执行UsernamePasswordAuthenticationFilter过滤器。</p>
<p>​	usernamePasrameter:账户参数名</p>
<p>​	passwordParameter:密码参数名</p>
<p>​	postOnly&#x3D;true:默认情况下只允许POST请求。</p>
<img data-src="/2022/10/07/Spring_Family/SpringSecurity/springSecurity-10-1661413396371.jpg" class="">


<h3 id="2-2修改配置"><a href="#2-2修改配置" class="headerlink" title="2.2修改配置"></a>2.2修改配置</h3><pre><code class="java">// 表单认证
http.formLogin()
        .loginProcessingUrl(&quot;/login&quot;)   //当发现/login时认为是登录，需要执行UserDetailsServiceImpl
        .successForwardUrl(&quot;/toMain&quot;)   //此处是post请求
        .failureForwardUrl(&quot;/fail&quot;)     //登录失败跳转地址
        .loginPage(&quot;/login.html&quot;)
        .usernameParameter(&quot;myusername&quot;)
        .passwordParameter(&quot;mypassword&quot;);
</code></pre>
<h3 id="2-3修改页面"><a href="#2-3修改页面" class="headerlink" title="2.3修改页面"></a>2.3修改页面</h3><p>​	修改login.html</p>
<pre><code class="html">&lt;form action = &quot;/login&quot; method=&quot;post&quot;&gt;
    用户名：&lt;input type=&quot;text&quot; name=&quot;myusername&quot;/&gt;&lt;br/&gt;
    密码:&lt;input type=&quot;password&quot; name=&quot;mypassword&quot;/&gt;&lt;br/&gt;
    &lt;input type=&quot;submit&quot; value=&quot;登录&quot;/&gt;
&lt;/form&gt;
</code></pre>
<h2 id="3-自定义登录成功处理器"><a href="#3-自定义登录成功处理器" class="headerlink" title="3.自定义登录成功处理器"></a>3.自定义登录成功处理器</h2><h3 id="3-1源码分析"><a href="#3-1源码分析" class="headerlink" title="3.1源码分析"></a>3.1源码分析</h3><p>​	使用successForwardUrl()时表示成功后转发请求到地址。内部是通过successHandler（）方法进行控制成功后交给哪个类进行处理</p>
<img data-src="/2022/10/07/Spring_Family/SpringSecurity/springSecurity-11-1661413396370.jpg" class="">


<p>​	ForwardAuthenticationSuccessHandler内部就是最简单的请求转发。由于是请求转发，当遇到需要跳转到站外或在前后端分离的项目中就无法使用了。</p>
<img data-src="/2022/10/07/Spring_Family/SpringSecurity/springSecurity-12-1661413396371.jpg" class="">


<p>​	当需要控制登录成功后去做一些事情时，可以进行自定义认证成功控制器。</p>
<h3 id="3-2代码实现"><a href="#3-2代码实现" class="headerlink" title="3.2代码实现"></a>3.2代码实现</h3><h4 id="3-2-1自定义类"><a href="#3-2-1自定义类" class="headerlink" title="3.2.1自定义类"></a>3.2.1自定义类</h4><p>​	新建类MyAuthenticationSuccessHandler 实现 AuthenticationSuccessHandler ，编写如下：</p>
<pre><code class="java">public class MyAuthenticationSuccessHandler implements AuthenticationSuccessHandler &#123;
    @Override
    public void onAuthenticationSuccess(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Authentication authentication) throws IOException, ServletException &#123;
        //Principal 主体，存放了登录用户的信息
        User user = (User)authentication.getPrincipal();
        System.out.println(user.getUsername());
        System.out.println(user.getPassword());//密码输出为null
        System.out.println(user.getAuthorities());
        //重定向到百度。这只是一个示例，具体需要看项目业务需求
        httpServletResponse.sendRedirect(&quot;http://www.baidu.com&quot;);
    &#125;
&#125;
</code></pre>
<h4 id="3-2-2修改配置项"><a href="#3-2-2修改配置项" class="headerlink" title="3.2.2修改配置项"></a>3.2.2修改配置项</h4><p>使用successHandler()方法设置成功后交给哪个对象进行处理</p>
<pre><code class="java">// 表单认证
http.formLogin()
        .loginProcessingUrl(&quot;/login&quot;)   //当发现/login时认为是登录，需要执行UserDetailsServiceImpl
        .successHandler(new MyAuthenticationSuccessHandler())
        //.successForwardUrl(&quot;/toMain&quot;)   //此处是post请求
        .failureForwardUrl(&quot;/fail&quot;)     //登录失败跳转地址
        .loginPage(&quot;/login.html&quot;);
</code></pre>
<h2 id="4-自定义登录失败处理器"><a href="#4-自定义登录失败处理器" class="headerlink" title="4.自定义登录失败处理器"></a>4.自定义登录失败处理器</h2><h3 id="4-1源码分析"><a href="#4-1源码分析" class="headerlink" title="4.1源码分析"></a>4.1源码分析</h3><p>​	failureForwardUrl()内部调用的是failureHandler()方法</p>
<p>​	<strong>ForwardAuthenticationFailureHandler</strong>中也是一个请求转发，并在request作用域中设置			 SPRING_SECURITY_LAST_EXCEPTION的key，内容为异常对象。</p>
<img data-src="/2022/10/07/Spring_Family/SpringSecurity/springSecurity-14.jpg" class="">


<h3 id="4-2代码实现"><a href="#4-2代码实现" class="headerlink" title="4.2代码实现"></a>4.2代码实现</h3><h4 id="4-2-1新建控制器"><a href="#4-2-1新建控制器" class="headerlink" title="4.2.1新建控制器"></a>4.2.1新建控制器</h4><p>​	新建MyForwardAuthenticationFailureHandler实现 AuthenticationFailureHandler 。在方法中添加重定向语句</p>
<pre><code class="java">public class MyForwardAuthenticationFailureHandler implements AuthenticationFailureHandler &#123;
    @Override
    public void onAuthenticationFailure(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, AuthenticationException e) throws IOException, ServletException &#123;
        httpServletResponse.sendRedirect(&quot;/fail.html&quot;);
    &#125;
&#125;
</code></pre>
<h4 id="4-2-2修改配置类"><a href="#4-2-2修改配置类" class="headerlink" title="4.2.2修改配置类"></a>4.2.2修改配置类</h4><p>​	修改配置类中表单登录部分。设置失败时交给失败处理器进行操作。failureForwardUrl和failureHandler不可共存。</p>
<pre><code class="java">        // 表单认证
        http.formLogin()
                .loginProcessingUrl(&quot;/login&quot;)   //当发现/login时认为是登录，需要执行UserDetailsServiceImpl
                .successHandler(new MyAuthenticationSuccessHandler())
                //.successForwardUrl(&quot;/toMain&quot;)   //此处是post请求
                .failureHandler(new MyForwardAuthenticationFailureHandler())
//                .failureForwardUrl(&quot;/fail&quot;)     //登录失败跳转地址
                .loginPage(&quot;/login.html&quot;);
</code></pre>
<h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5 总结"></a>5 总结</h2><pre><code class="java">        // http.formLogin() 所有和表单有关系的
        http.formLogin()
                // 登录页面，走一个controller
                // 注意要和，LoginProcessingUrl 配合使用，不然在表单中的action中 url 失效
                // 因为只配置loginPage()， 会导致在初始化的时候将loginProcessingUrl的配置相同化，可以自己debug 在AbstractAuthenticationFilterConfigurer 的 updateAuthenticationDefaults 方法
                // 也就是说loginPage(&quot;/login&quot;)  loginProcessingUrl(&quot;/login&quot;),导致提交信息失败最终导致认证失败
                .loginPage(&quot;/showLogin&quot;)
                // 当发现什么URL时，把请求转发给自定义登录逻辑
                // 表单提交的地址 action ,他就会直接去认证进入到 UserDetailsServiceImpl
                // 去这里进行用户的验证 和 用户权限信息的集体封装
                .loginProcessingUrl(&quot;/login&quot;)
            
                // 登录成功的操作
                // 下面两种方法都可以，推荐第二种，两种同时写第一个直接失效
                // 第一种写法，要注意在写映射的时候要注意请求的方法 get/post
                .successForwardUrl(&quot;/showMain&quot;)
                .successHandler((request, response, authentication) -&gt; &#123;
                    System.out.println(&quot;successHandler invoked&quot;);
                    // 我们在每次请求同一个页面尽量使用重定向，要是请求转发
                    // 因为请求转发是浏览器的行为，每次都要请求服务器并且重复提交表单，不好
                    // response.sendRedirect(&quot;/fail&quot;);
                    LoginUser loginUser = (LoginUser) authentication.getPrincipal();
                    for (String s : loginUser.getPermission()) &#123;
                        System.out.println(s);
                    &#125;
                &#125;)
                // 登录失败的操作
                // 内容和上述情况相同，只是一个成功的一个失败的
                .failureForwardUrl(&quot;/fail&quot;)
                // 当前端表单传递过来的用户名参数、密码参数名和后端不对应，可以利用下列方法
                // 指定前端传递过来的用户名参数名称
                //.usernameParameter(&quot;MyuserName&quot;)
                // 指定前端传递过来的密码参数名称
                // .passwordParameter(&quot;MypassWord&quot;)
        ;
</code></pre>
<h1 id="六、用户授权"><a href="#六、用户授权" class="headerlink" title="六、用户授权"></a>六、用户授权</h1><h2 id="1-权限系统的作用"><a href="#1-权限系统的作用" class="headerlink" title="1 权限系统的作用"></a>1 权限系统的作用</h2><p>​	例如一个学校图书馆的管理系统，如果是普通学生登录就能看到借书还书相关的功能，不可能让他看到并且去使用添加书籍信息，删除书籍信息等功能。但是如果是一个图书馆管理员的账号登录了，应该就能看到并使用添加书籍信息，删除书籍信息等功能。</p>
<p>​	总结起来就是<a><strong>不同的用户可以使用不同的功能</strong></a>。这就是权限系统要去实现的效果。</p>
<h2 id="2-授权基本流程"><a href="#2-授权基本流程" class="headerlink" title="2 授权基本流程"></a>2 授权基本流程</h2><p>​	在SpringSecurity中，会使用默认的<strong>FilterSecurityInterceptor</strong>来进行权限校验。在 <strong>FilterSecurityInterceptor</strong>中会从<strong>SecurityContextHolder</strong>获取其<strong>Authentication</strong>，然后获取其中的权限信息。当前用户是否拥有访问当前资源所需的权限。</p>
<p>​	<a>所以我们在项目中只需要把当前登录用户的权限信息也存入Authentication。</a>然后设置我们的资源所需要的权限即可。</p>
<h2 id="3-RBAC权限模型"><a href="#3-RBAC权限模型" class="headerlink" title="3 RBAC权限模型"></a>3 RBAC权限模型</h2><p>参考博客：<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3F6dzc1Mjg5MDkxMy9hcnRpY2xlL2RldGFpbHMvMTI0NDYxOTUy">https://blog.csdn.net/qzw752890913/article/details/124461952</span></p>
<p>​	RBAC（Role Based Access Control，基于角色的访问控制），就是用户通过角色与权限进行关联，而不是直接将权限赋予用户。</p>
<p>​	一个用户拥有若干个角色，每个角色拥有若干个权限，这样就构成了“用户-角色-权限”的授权模型。这种授权模型的好处在于，不必每次创建用户时都进行权限分配的操作，只要分配用户相应的角色即可，而且角色的权限变更比用户的权限变更要少得多，减少频繁设置。</p>
<p>RBAC模型中，用户与角色之间、角色与权限之间，一般是多对多的关系。</p>
<p>所谓“多对多”，就是双向的一对多。</p>
<img data-src="/2022/10/07/Spring_Family/SpringSecurity/image-20220825151716381.png" class="">


<p>​	</p>
<h2 id="4-授权实现"><a href="#4-授权实现" class="headerlink" title="4 授权实现"></a>4 授权实现</h2><ul>
<li>基于配置——在SpringSecurity的配置类中和登录页一样进行权限配置(<font color=red>不推荐，过程繁琐，开发麻烦</font>)</li>
<li>基于注解——直接可以对我们次处理，也就是对我们的控制层进行权限的设置(<font color=red>强烈推荐</font>)</li>
</ul>
<h3 id="4-1-基于配置授权"><a href="#4-1-基于配置授权" class="headerlink" title="4.1 基于配置授权"></a>4.1 基于配置授权</h3><p>这里没什么好说的，从刚开始我们就开始写了权限的认证，就是我们重写的配置类</p>
<pre><code class="java">// http.authorizeRequests() 所有和授权相关
http.authorizeRequests()
    // 这里面支持 正则 和 ant表达式	
    // anonymous 匿名 没有认证的才可以访问，permitALL 谁都能访问，不需要认证
    .antMatchers(&quot;/user/login&quot;,&quot;/login&quot;,&quot;/loginPage&quot;).anonymous()
    .antMatchers(&quot;/js/**&quot;).permitAll()
    // authenticated 认证了才能访问
    .anyRequest().authenticated();
</code></pre>
<p>这样写，除了静态资源权限需要这么写，其余请求折磨写太麻烦，我们的业务众多，这样写极大的增加了业务开发的负担，再加上静态资源我们都已经前后端分离也就涉及不到他的权限问题，所以这种方式了解就好。主要重点放在注解学习上。</p>
<h3 id="4-2-基于注解授权"><a href="#4-2-基于注解授权" class="headerlink" title="4.2 基于注解授权"></a>4.2 基于注解授权</h3><h4 id="准备阶段"><a href="#准备阶段" class="headerlink" title="准备阶段"></a>准备阶段</h4><p>​	SpringSecurity为我们提供了基于注解的权限控制方案，这也是我们项目中主要采用的方式。我们可以使用注解去指定访问对应的资源所需的权限。</p>
<p>​	&#x3D;&#x3D;但是要使用它我们需要先开启相关配置。&#x3D;&#x3D;，&#x3D;&#x3D;不打开直接用会 500&#x3D;&#x3D;</p>
<pre><code class="java">@EnableGlobalMethodSecurity(prePostEnabled = true)//启动类上添加注解
</code></pre>
<h4 id="找到对应的接口"><a href="#找到对应的接口" class="headerlink" title="找到对应的接口"></a>找到对应的接口</h4><p>这里我们找到需要授权的接口，对他们进行授权，主要有3个主要注解 </p>
<ul>
<li>@Secured</li>
<li>@PerAuthorize() 、@PostAuthorize</li>
</ul>
<p>只要对我们的接口上添加相对应的注解即可，例如</p>
<pre><code class="java">@Controller
public class loginController&#123;
    @Secured(&quot;ROLE_abc&quot;) //专门用于判断是否具有角色的。能写在方法或类上。参数要以ROLE_开头。
    @RequestMapping(&quot;/toMain&quot;)
    public String toMain()&#123;
        return &quot;redirect:/main.html&quot;;
    &#125;
    
    @RequestMapping(&quot;/hello3&quot;)
    @ResponseBody
    // 是方法或类级别注解。
    @PreAuthorize(&quot;hasAnyAuthority(&#39;demo:delete&#39;)&quot;)
    public String testThree()&#123;
        return &quot;success!&quot;;
    &#125;

    @RequestMapping(&quot;/hello4&quot;)
    @ResponseBody
    //  是方法或类级别注解。
    @PostAuthorize(&quot;hasAnyRole(&#39;ROLE_管理员&#39;)&quot;)
    public String testFour()&#123;
        return &quot;success!&quot;;
    &#125;
&#125;
</code></pre>
<h1 id="七、配置类说明-2-—访问控制"><a href="#七、配置类说明-2-—访问控制" class="headerlink" title="七、配置类说明 2 —访问控制"></a>七、配置类说明 2 —访问控制</h1><p>在前面讲解了认证中所有常用配置，主要是对http.formLogin()进行操作。而在配置类中		http.authorizeRequests()主要是对url进行控制，也就是我们所说的授权（访问控制）。http.authorizeRequests()也支持连缀写法，总体公式为：</p>
<p>​	url匹配规则.权限控制方法</p>
<p>通过上面的公式可以有很多url匹配规则和很多权限控制方法。这些内容进行各种组合就形成了Spring Security中的授权。</p>
<p>​	在所有匹配规则中取所有规则的交集。配置顺序影响了之后授权效果，越是具体的应该放在前面，越是笼统的应该放到后面。	</p>
<h2 id="1-anyRequest"><a href="#1-anyRequest" class="headerlink" title="1.anyRequest()"></a>1.anyRequest()</h2><p>​	在之前认证过程中我们就已经使用过anyRequest()，表示匹配所有的请求。一般情况下此方法都会使用，设置全部内容都需要进行认证。</p>
<p>​	代码示例:</p>
<pre><code class="java">anyRequest().authenticated();
</code></pre>
<h2 id="2-antMatcher"><a href="#2-antMatcher" class="headerlink" title="2.antMatcher()"></a>2.antMatcher()</h2><p>​	方法定义如下：</p>
<pre><code class="java">public C antMatchers(String... antPatterns)
</code></pre>
<p>​	参数是不定向参数，每个参数是一个 正则&#x2F;ant表达式，用于匹配URL规则。</p>
<p>​	规则如下：</p>
<p>​	? 匹配一个字符</p>
<p>​	* 匹配0个或多个字符</p>
<p>​	** 匹配0个或多个目录</p>
<p>​	在实际项目中经常需要放行所有静态资源，下面演示放行js文件夹下所有脚本文件。</p>
<pre><code class="java">.antMatchers(&quot;/js/**&quot;).permitAll()
</code></pre>
<p>还有一种配置方式是只要是.js文件都放行</p>
<pre><code class="java">antMatchers(&quot;/**/*.js&quot;).permitAll()
</code></pre>
<h2 id="3-regexMatchers"><a href="#3-regexMatchers" class="headerlink" title="3.regexMatchers()"></a>3.regexMatchers()</h2><h3 id="3-1介绍"><a href="#3-1介绍" class="headerlink" title="3.1介绍"></a>3.1介绍</h3><p>使用正则表达式进行匹配。和antMatchers()主要的区别就是参数，antMatchers()参数是ant表达式，regexMatchers()参数是正则表达式。</p>
<p>演示所有以.js结尾的文件都被放行。</p>
<pre><code class="java">.regexMatchers(&quot;.+[.]js&quot;).permitAll()
</code></pre>
<h3 id="3-2两个参数时使用方式"><a href="#3-2两个参数时使用方式" class="headerlink" title="3.2两个参数时使用方式"></a>3.2两个参数时使用方式</h3><p>无论是antMatchers()还是regexMatchers()都具有两个参数的方法，其中第一个参数都是HttpMethod，表示请求方式，当设置了HttpMethod后表示只有设定的特定的请求方式才执行对应的权限设置。</p>
<p>枚举类型HttpMethod内置属性如下：</p>
<img data-src="/2022/10/07/Spring_Family/SpringSecurity/springSecurity-15.jpg" class="">


<h2 id="4-内置访问控制方法介绍"><a href="#4-内置访问控制方法介绍" class="headerlink" title="4 内置访问控制方法介绍"></a>4 内置访问控制方法介绍</h2><p>​	Spring Security匹配了URL后调用了permitAll()表示不需要认证，随意访问。在Spring Security中提供了多种内置控制。</p>
<h3 id="1-permitAll"><a href="#1-permitAll" class="headerlink" title="1.permitAll()"></a>1.permitAll()</h3><p>​	<strong>permitAll()表示所匹配的URL任何人都允许访问。</strong></p>
<h3 id="2-authenticated"><a href="#2-authenticated" class="headerlink" title="2.authenticated()"></a>2.authenticated()</h3><p>​	<strong>authenticated()表示所匹配的URL都需要被认证才能访问。</strong></p>
<h3 id="3-anonymous"><a href="#3-anonymous" class="headerlink" title="3.anonymous()"></a>3.anonymous()</h3><p>​	<strong>anonymous()表示可以匿名访问匹配的URL。和permitAll()效果类似，只是设置为anonymous()的url会执行filter 链中</strong></p>
<p>​	官方源码定义如下：</p>
<img data-src="/2022/10/07/Spring_Family/SpringSecurity/springSecurity-18.jpg" class="">


<h3 id="4-denyAll"><a href="#4-denyAll" class="headerlink" title="4.denyAll()"></a>4.denyAll()</h3><p>​	<strong>denyAll()表示所匹配的URL都不允许被访问。</strong></p>
<img data-src="/2022/10/07/Spring_Family/SpringSecurity/springSecurity-19.jpg" class="">


<h3 id="5-rememberMe"><a href="#5-rememberMe" class="headerlink" title="5.rememberMe()"></a>5.rememberMe()</h3><p>​	<strong>被“remember me”的用户允许访问</strong></p>
<img data-src="/2022/10/07/Spring_Family/SpringSecurity/springSecurity-20.jpg" class="">


<h3 id="6-fullyAuthenticated"><a href="#6-fullyAuthenticated" class="headerlink" title="6.fullyAuthenticated()"></a>6.fullyAuthenticated()</h3><p>​	<strong>如果用户不是被remember me的，才可以访问</strong>。</p>
<img data-src="/2022/10/07/Spring_Family/SpringSecurity/springSecurity-21.jpg" class="">


<h3 id="7-hasIpAddress-String"><a href="#7-hasIpAddress-String" class="headerlink" title="7.hasIpAddress(String)"></a>7.hasIpAddress(String)</h3><p>如果请求是指定的IP就运行访问。</p>
<p>​	可以通过request.getRemoteAddr()获取ip地址。</p>
<p>​	需要注意的是在本机进行测试时localhost和127.0.0.1输出的ip地址是不一样的。</p>
<p>​	当浏览器中通过localhost进行访问时控制台打印的内容：</p>
<img data-src="/2022/10/07/Spring_Family/SpringSecurity/springSecurity-25-1661415211434.jpg" class="">


<p>​	当浏览器中通过127.0.0.1访问时控制台打印的内容：</p>
<img data-src="/2022/10/07/Spring_Family/SpringSecurity/springSecurity-26-1661415211434.jpg" class="">


<p>​	当浏览器中通过具体ip进行访问时控制台打印内容：</p>
<img data-src="/2022/10/07/Spring_Family/SpringSecurity/springSecurity-27-1606734864126-1661415211434.jpg" class="">


<p>​	使用Spring Security时经常会看见403（无权限），默认情况下显示的效果如下：</p>
<img data-src="/2022/10/07/Spring_Family/SpringSecurity/springSecurity-28-1661415211434.jpg" class="">


<p>​	而在实际项目中可能都是一个异步请求，显示上述效果对于用户就不是特别友好了。Spring Security支持自定义权限受限。</p>
<h4 id="1-新建类"><a href="#1-新建类" class="headerlink" title="1.新建类"></a>1.新建类</h4><p>​	新建类实现<strong>AccessDeniedHandler</strong></p>
<pre><code class="java">@Component
public class MyAccessDeniedHandler implements AccessDeniedHandler &#123;
    @Override
    public void handle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, AccessDeniedException e) throws IOException, ServletException &#123;
        httpServletResponse.setStatus(HttpServletResponse.SC_FORBIDDEN);
        httpServletResponse.setHeader(&quot;Content-Type&quot;,&quot;application/json;charset=utf-8&quot;);
        PrintWriter out = httpServletResponse.getWriter();
        out.write(&quot;&#123;\&quot;status\&quot;:\&quot;error\&quot;,\&quot;msg\&quot;:\&quot;权限不足，请联系管理员!\&quot;&#125;&quot;);
        out.flush();
        out.close();
    &#125;
&#125;
</code></pre>
<h4 id="2-修改配置类"><a href="#2-修改配置类" class="headerlink" title="2.修改配置类"></a>2.修改配置类</h4><p>​	配置类中重点添加异常处理器。设置访问受限后交给哪个对象进行处理。</p>
<p>​	myAccessDeniedHandler是在配置类中进行自动注入的。</p>
<pre><code class="java">//异常处理
http.exceptionHandling()
        .accessDeniedHandler(myAccessDeniedHandler);
</code></pre>
<h2 id="5-总结-1"><a href="#5-总结-1" class="headerlink" title="5 总结"></a>5 总结</h2><p>在选择特定请求时 2&#x2F;3 任选其一 效果相同，主要注意内置访问控制方法的选择</p>
<h1 id="八、配置类说明-3-—基于表达式的访问控制"><a href="#八、配置类说明-3-—基于表达式的访问控制" class="headerlink" title="八、配置类说明 3 —基于表达式的访问控制"></a>八、配置类说明 3 —基于表达式的访问控制</h1><h2 id="1-access-方法使用"><a href="#1-access-方法使用" class="headerlink" title="1.access()方法使用"></a>1.access()方法使用</h2><p>​	之前学习的登录用户权限判断实际上底层实现都是调用access(表达式)</p>
<img data-src="/2022/10/07/Spring_Family/SpringSecurity/springSecurity-29.jpg" class="">


<p>​	可以通过access()实现和之前学习的权限控制完成相同的功能。</p>
<h3 id="1-1以hasRole和permitAll举例"><a href="#1-1以hasRole和permitAll举例" class="headerlink" title="1.1以hasRole和permitAll举例"></a>1.1以hasRole和permitAll举例</h3><p>​	下面代码和直接使用permitAll()和hasRole()是等效的。</p>
<img data-src="/2022/10/07/Spring_Family/SpringSecurity/springSecurity-30.jpg" class="">


<h2 id="2-自定义权限验证方法"><a href="#2-自定义权限验证方法" class="headerlink" title="2.自定义权限验证方法"></a>2.自定义权限验证方法</h2><p>​	虽然这里面已经包含了很多的表达式(方法)但是在实际项目中很有可能出现需要自己自定义逻辑的情况。</p>
<p>​	判断登录用户是否具有访问当前URL权限。</p>
<h3 id="2-1新建接口及实现类"><a href="#2-1新建接口及实现类" class="headerlink" title="2.1新建接口及实现类"></a>2.1新建接口及实现类</h3><p>​	新建接口com.msb.service.MyService后新建实现类。</p>
<pre><code class="java">public interface MyService &#123;
    boolean hasPermission(HttpServletRequest request, Authentication authentication);
&#125;
</code></pre>
<pre><code class="java">@Component
public class MyServiceImpl implements MyService &#123;
    @Override
    public boolean hasPermission(HttpServletRequest request, Authentication authentication) &#123;
        Object obj = authentication.getPrincipal();
        if(obj instanceof UserDetails)&#123;
            UserDetails user = (UserDetails) obj;
            Collection&lt;? extends GrantedAuthority&gt; authorities = user.getAuthorities();
            return authorities.contains(new SimpleGrantedAuthority(request.getRequestURI()));
        &#125;
        return false;
    &#125;
&#125;
</code></pre>
<h3 id="2-2修改配置类"><a href="#2-2修改配置类" class="headerlink" title="2.2修改配置类"></a>2.2修改配置类</h3><p>​	在access中通过@bean的id名.方法(参数)的形式进行调用</p>
<p>​	配置类中修改如下：</p>
<pre><code class="java"> // url 拦截 (授权)
http.authorizeRequests()
        .antMatchers(&quot;/login.html&quot;).access(&quot;permitAll&quot;)
        .antMatchers(&quot;/fail.html&quot;).permitAll()
        // @Bean的名字，表示引入某个Bean，我们的Bean在主动命名的情况下，都是以首字母小写命名
        .anyRequest().access(&quot;@myServiceImpl.hasPermission(request,authentication)&quot;);
</code></pre>
<h1 id="九、基于注解的访问控制"><a href="#九、基于注解的访问控制" class="headerlink" title="九、基于注解的访问控制"></a>九、基于注解的访问控制</h1><p>​	在Spring Security中提供了一些访问控制的注解。这些注解都是默认是都不可用的，需要通过@EnableGlobalMethodSecurity进行开启后使用。</p>
<p>​	&#x3D;&#x3D;如果设置的条件允许，程序正常执行。如果不允许会报500&#x3D;&#x3D;</p>
<p>​	这些注解可以写到Service接口或方法上上也可以写到Controller或Controller的方法上。通常情况下都是写在控制器方法上的，控制接口URL是否允许被访问。</p>
<h2 id="1-Secured"><a href="#1-Secured" class="headerlink" title="1.@Secured"></a>1.@Secured</h2><p>​	@Secured是&#x3D;&#x3D;专门用于判断是否具有角色的&#x3D;&#x3D;。能写在&#x3D;&#x3D;方法或类&#x3D;&#x3D;上。&#x3D;&#x3D;参数要以ROLE_开头&#x3D;&#x3D;。</p>
<img data-src="/2022/10/07/Spring_Family/SpringSecurity/springSecurity-32-1661416083118.jpg" class="">


<h3 id="1-1实现步骤"><a href="#1-1实现步骤" class="headerlink" title="1.1实现步骤"></a>1.1实现步骤</h3><h4 id="1-1-1-开启注解"><a href="#1-1-1-开启注解" class="headerlink" title="1.1.1 开启注解"></a>1.1.1 开启注解</h4><p>​	在启动类(也可以在配置类等能够扫描的类上)上添加@EnableGlobalMethodSecurity(securedEnabled &#x3D; true)</p>
<pre><code class="java">@SpringBootApplication
@EnableGlobalMethodSecurity(securedEnabled = true)
public class MyApp &#123;
    public static void main(String [] args)&#123;
        SpringApplication.run(MyApp.class,args);
    &#125;
&#125;
</code></pre>
<h4 id="1-1-2在控制器方法上添加-Secured注解"><a href="#1-1-2在控制器方法上添加-Secured注解" class="headerlink" title="1.1.2在控制器方法上添加@Secured注解"></a>1.1.2在控制器方法上添加@Secured注解</h4><p>​	在LoginController中方法上添加注解</p>
<pre><code class="java">@Secured(&quot;ROLE_abc&quot;)
@RequestMapping(&quot;/toMain&quot;)
public String toMain()&#123;
    return &quot;redirect:/main.html&quot;;
&#125;
</code></pre>
<h4 id="1-1-3配置类"><a href="#1-1-3配置类" class="headerlink" title="1.1.3配置类"></a>1.1.3配置类</h4><p>​	配置类中方法配置保留最基本的配置即可。</p>
<pre><code class="java">protected void configure(HttpSecurity http) throws Exception &#123;
    // 表单认证
    http.formLogin()
            .loginProcessingUrl(&quot;/login&quot;)   //当发现/login时认为是登录，需要执行UserDetailsServiceImpl
            .successForwardUrl(&quot;/toMain&quot;)   //此处是post请求
            .loginPage(&quot;/login.html&quot;);

    // url 拦截
    http.authorizeRequests()
            .antMatchers(&quot;/login.html&quot;).permitAll() //login.html不需要被认证
            .anyRequest().authenticated();//所有的请求都必须被认证。必须登录后才能访问。

    //关闭csrf防护
    http.csrf().disable();

&#125;
</code></pre>
<h2 id="2-PreAuthorize-x2F-PostAuthorize"><a href="#2-PreAuthorize-x2F-PostAuthorize" class="headerlink" title="2.@PreAuthorize&#x2F;@PostAuthorize"></a>2.@PreAuthorize&#x2F;@PostAuthorize</h2><p>​	@PreAuthorize和@PostAuthorize都是方法或类级别注解。</p>
<p>​	**@PreAuthorize ** 表示访问方法或类在&#x3D;&#x3D;执行之前先判断权限&#x3D;&#x3D;，大多情况下都是使用这个注解，注解的参数和access()方法参数取值相同，都是权限表达式。</p>
<p>​	@<strong>PostAuthorize</strong> 表示&#x3D;&#x3D;方法或类执行结束后判断权限&#x3D;&#x3D;，此注解很少被使用到。</p>
<img data-src="/2022/10/07/Spring_Family/SpringSecurity/image-20220825155542682.png" class="">


<h3 id="2-1实现步骤"><a href="#2-1实现步骤" class="headerlink" title="2.1实现步骤"></a>2.1实现步骤</h3><h4 id="2-1-1开启注解"><a href="#2-1-1开启注解" class="headerlink" title="2.1.1开启注解"></a>2.1.1开启注解</h4><p>​	在启动类中开启@PreAuthorize注解。</p>
<pre><code class="java">@SpringBootApplication
@EnableGlobalMethodSecurity(prePostEnabled = true)
public class MyApp &#123;
    public static void main(String [] args)&#123;
        SpringApplication.run(MyApp.class,args);
    &#125;
&#125;
</code></pre>
<h4 id="2-1-2添加-PreAuthorize"><a href="#2-1-2添加-PreAuthorize" class="headerlink" title="2.1.2添加@PreAuthorize"></a>2.1.2添加@PreAuthorize</h4><p>​	在控制器方法上添加@PreAuthorize，参数可以是任何access()支持的表达式</p>
<pre><code class="java">@PreAuthorize(&quot;hasRole(&#39;abc&#39;)&quot;)
@RequestMapping(&quot;/toMain&quot;)
public String toMain()&#123;
    return &quot;redirect:/main.html&quot;;
&#125;
</code></pre>
<h2 id="3-自定义权限校验方法-针对Pre注解"><a href="#3-自定义权限校验方法-针对Pre注解" class="headerlink" title="3.自定义权限校验方法(针对Pre注解)"></a>3.自定义权限校验方法(针对Pre注解)</h2><p>我们如果觉得单纯验证不合适，或者说不符合我们的业务我们也可以自定义方法</p>
<h3 id="其它权限校验方法"><a href="#其它权限校验方法" class="headerlink" title="其它权限校验方法"></a>其它权限校验方法</h3><p>​	我们前面都是使用@PreAuthorize注解，然后在在其中使用的是hasAuthority方法进行校验。SpringSecurity还为我们提供了其它方法例如：hasAnyAuthority，hasRole，hasAnyRole等。</p>
<p>​	这里我们先不急着去介绍这些方法，我们先去理解hasAuthority的原理，然后再去学习其他方法你就更容易理解，而不是死记硬背区别。并且我们也可以选择定义校验方法，实现我们自己的校验逻辑。</p>
<p>​	<strong>hasAuthority</strong>方法实际是执行到了<strong>SecurityExpressionRoot</strong>的<strong>hasAuthority</strong>，大家只要断点调试既可知道它内部的校验原理。</p>
<p>​	它内部其实是调用<strong>authentication</strong>的<strong>getAuthorities</strong>方法获取用户的权限列表。然后判断我们存入的方法参数数据在权限列表中。</p>
<p>​	<strong>hasAnyAuthority</strong>方法可以传入多个权限，只有用户有其中任意一个权限都可以访问对应资源。</p>
<pre><code class="java">    @PreAuthorize(&quot;hasAnyAuthority(&#39;admin&#39;,&#39;test&#39;,&#39;system:dept:list&#39;)&quot;)
    public String hello()&#123;
        return &quot;hello&quot;;
    &#125;
</code></pre>
<p>​	<strong>hasRole</strong>要求有对应的角色才可以访问，但是它内部会把我们传入的参数拼接上 <strong>ROLE_</strong> 后再去比较。所以这种情况下要用用户对应的权限也要有 <strong>ROLE_</strong> 这个前缀才可以。</p>
<pre><code class="java">    @PreAuthorize(&quot;hasRole(&#39;system:dept:list&#39;)&quot;)
    public String hello()&#123;
        return &quot;hello&quot;;
    &#125;
</code></pre>
<p>​	<strong>hasAnyRole</strong> 有任意的角色就可以访问。它内部也会把我们传入的参数拼接上 <strong>ROLE_</strong> 后再去比较。所以这种情况下要用用户对应的权限也要有 <strong>ROLE_</strong> 这个前缀才可以。</p>
<pre><code class="java">    @PreAuthorize(&quot;hasAnyRole(&#39;admin&#39;,&#39;system:dept:list&#39;)&quot;)
    public String hello()&#123;
        return &quot;hello&quot;;
    &#125;
</code></pre>
<h3 id="自定义权限校验方法"><a href="#自定义权限校验方法" class="headerlink" title="自定义权限校验方法"></a>自定义权限校验方法</h3><p>​	我们也可以定义自己的权限校验方法，在@PreAuthorize注解中使用我们的方法。</p>
<pre><code class="java">@Component(&quot;ex&quot;)
public class MyExpressionRoot &#123;
    // 一定要返回一个Bool值
    public boolean hasAuthority(String authority)&#123;
        //获取当前用户的权限
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        LoginUser loginUser = (LoginUser) authentication.getPrincipal();
        List&lt;String&gt; permissions = loginUser.getPermissions();
        //判断用户权限集合中是否存在authority
        return permissions.contains(authority);
    &#125;
&#125;
</code></pre>
<p>​	 <strong>在SPEL表达式中使用 @ex相当于获取容器中bean的名字为ex的对象。然后再调用这个对象的hasAuthority方法</strong></p>
<pre><code class="java">    @RequestMapping(&quot;/hello&quot;)
    @PreAuthorize(&quot;@ex.hasAuthority(&#39;system:dept:list&#39;)&quot;)
    public String hello()&#123;
        return &quot;hello&quot;;
    &#125;
</code></pre>
<h1 id="十、自定义失败处理"><a href="#十、自定义失败处理" class="headerlink" title="十、自定义失败处理"></a>十、自定义失败处理</h1><p>​	我们还希望在认证失败或者是授权失败的情况下也能和我们的接口一样返回相同结构的json，这样可以让前端能对响应进行统一的处理。要实现这个功能我们需要知道SpringSecurity的异常处理机制。</p>
<p>​	在SpringSecurity中，如果我们在认证或者授权的过程中出现了异常会被ExceptionTranslationFilter捕获到。在ExceptionTranslationFilter中会去判断是认证失败还是授权失败出现的异常。</p>
<p>​	如果是&#x3D;&#x3D;认证过程中出现的异常&#x3D;&#x3D;会被封装成<strong>AuthenticationException</strong>然后调用<strong>AuthenticationEntryPoint</strong>对象的方法去进行异常处理。</p>
<p>​	如果是&#x3D;&#x3D;授权过程中出现的异常&#x3D;&#x3D;会被封装成<strong>AccessDeniedException</strong>然后调用<strong>AccessDeniedHandler</strong>对象的方法去进行异常处理。</p>
<p>​	所以如果我们&#x3D;&#x3D;需要自定义异常处理&#x3D;&#x3D;，我们只需要&#x3D;&#x3D;自定义AuthenticationEntryPoint和AccessDeniedHandler然后配置给SpringSecurity即可&#x3D;&#x3D;。</p>
<h2 id="①自定义实现类"><a href="#①自定义实现类" class="headerlink" title="①自定义实现类"></a>①自定义实现类</h2><pre><code class="java">@Component
public class AccessDeniedHandlerImpl implements AccessDeniedHandler &#123;
    @Override
    public void handle(HttpServletRequest request, HttpServletResponse response, AccessDeniedException accessDeniedException) throws IOException, ServletException &#123;
        ResponseResult result = new ResponseResult(HttpStatus.FORBIDDEN.value(), &quot;权限不足&quot;);
        String json = JSON.toJSONString(result);
        WebUtils.renderString(response,json);
    &#125;
&#125;
</code></pre>
<pre><code class="java">@Component
public class AuthenticationEntryPointImpl implements AuthenticationEntryPoint &#123;
    @Override
    public void commence(HttpServletRequest request, HttpServletResponse response, AuthenticationException authException) throws IOException, ServletException &#123;
        ResponseResult result = new ResponseResult(HttpStatus.UNAUTHORIZED.value(), &quot;认证失败请重新登录&quot;);
        String json = JSON.toJSONString(result);
        WebUtils.renderString(response,json);
    &#125;
&#125;
</code></pre>
<h2 id="②配置给SpringSecurity"><a href="#②配置给SpringSecurity" class="headerlink" title="②配置给SpringSecurity"></a>②配置给SpringSecurity</h2><p>​	先注入对应的处理器</p>
<pre><code class="java">    @Autowired
    private AuthenticationEntryPoint authenticationEntryPoint;

    @Autowired
    private AccessDeniedHandler accessDeniedHandler;
</code></pre>
<p>​	然后我们可以使用HttpSecurity对象的方法去配置。</p>
<pre><code class="java">        http.exceptionHandling()
            .authenticationEntryPoint(authenticationEntryPoint)
            .accessDeniedHandler(accessDeniedHandler);
</code></pre>
<h1 id="十一、Remember-Me功能实现"><a href="#十一、Remember-Me功能实现" class="headerlink" title="十一、Remember Me功能实现"></a>十一、Remember Me功能实现</h1><p>​	Spring Security 中Remember Me为“记住我”功能，用户只需要在登录时添加remember-me复选框，取值为true。Spring Security会自动把用户信息存储到数据源中，以后就可以不登录进行访问。</p>
<h2 id="1-添加依赖"><a href="#1-添加依赖" class="headerlink" title="1.添加依赖"></a>1.添加依赖</h2><p>​	Spring Security实现Remember Me 功能时底层实现依赖Spring-JDBC，所以需要导入Spring-JDBC。以后多使用MyBatis框架而很少直接导入spring-jdbc，所以此处导入mybatis启动器</p>
<p>同时还需要添加MySQL驱动</p>
<pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;
    &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;
    &lt;version&gt;2.1.1&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;mysql&lt;/groupId&gt;
    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
    &lt;version&gt;5.1.6&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<h2 id="2-配置数据源"><a href="#2-配置数据源" class="headerlink" title="2.配置数据源"></a>2.配置数据源</h2><p>​	在application.properties中配置数据源。请确保数据库中已经存在security数据库</p>
<pre><code class="properties">spring.datasource.driver-class-name=com.mysql.jdbc.Driver
spring.datasource.url=jdbc:mysql://127.0.0.1:3306/mashibing
spring.datasource.username=root
spring.datasource.password=root
</code></pre>
<h2 id="3-编写配置"><a href="#3-编写配置" class="headerlink" title="3.编写配置"></a>3.编写配置</h2><p>​	新建com.msb.config.RememberMeConfig类，并创建Bean对象</p>
<pre><code class="java">@Configuration
public class RememberMeConfig &#123;
    @Autowired
    private DataSource dataSource;
    @Bean
    public PersistentTokenRepository getPersistentTokenRepository() &#123;
        JdbcTokenRepositoryImpl jdbcTokenRepositoryImpl=new JdbcTokenRepositoryImpl();
        jdbcTokenRepositoryImpl.setDataSource(dataSource);
        //自动建表，第一次启动时需要，第二次启动时注释掉
//        jdbcTokenRepositoryImpl.setCreateTableOnStartup(true);
        return jdbcTokenRepositoryImpl;
    &#125;
&#125;
</code></pre>
<h2 id="4-修改SecurityConfig"><a href="#4-修改SecurityConfig" class="headerlink" title="4.修改SecurityConfig"></a>4.修改SecurityConfig</h2><p>​	在SecurityConfig中添加RememberMeConfig和UserDetailsService实现类对象，并自动注入。</p>
<p>​	在configure中添加下面配置内容。</p>
<pre><code class="java">http.rememberMe()
    .userDetailsService(userDetailsService) //登录逻辑交给哪个对象
    .tokenRepository(repository);   //持久层对象
</code></pre>
<h2 id="5-在客户端页面中添加复选框"><a href="#5-在客户端页面中添加复选框" class="headerlink" title="5.在客户端页面中添加复选框"></a>5.在客户端页面中添加复选框</h2><p>​	在客户端登录页面中添加remember-me的复选框，只要用户勾选了复选框下次就不需要进行登录了。</p>
<pre><code class="html">&lt;form action = &quot;/login&quot; method=&quot;post&quot;&gt;
    用户名：&lt;input type=&quot;text&quot; name=&quot;username&quot;/&gt;&lt;br/&gt;
    密码:&lt;input type=&quot;text&quot; name=&quot;password&quot;/&gt;&lt;br/&gt;
    &lt;input type=&quot;checkbox&quot; name=&quot;remember-me&quot; value=&quot;true&quot;/&gt; &lt;br/&gt;
    &lt;input type=&quot;submit&quot; value=&quot;登录&quot;/&gt;
&lt;/form&gt;
</code></pre>
<h2 id="6-有效时间"><a href="#6-有效时间" class="headerlink" title="6.有效时间"></a>6.有效时间</h2><p>​	默认情况下重启项目后登录状态失效了。但是可以通过设置状态有效时间，即使项目重新启动下次也可以正常登录。</p>
<pre><code class="java">//remember Me
http.rememberMe()
        .tokenValiditySeconds(120)//单位：秒
        .tokenRepository(repository)
        .userDetailsService(userDetailsServiceImpl);
</code></pre>
<h1 id="十二、Thymeleaf中Spring-Security的使用"><a href="#十二、Thymeleaf中Spring-Security的使用" class="headerlink" title="十二、Thymeleaf中Spring Security的使用"></a>十二、Thymeleaf中Spring Security的使用</h1><p>​	Spring Security可以在一些视图技术中进行控制显示效果。例如：JSP或Thymeleaf。在非前后端分离且使用Spring Boot的项目中多使用Thymeleaf作为视图展示技术。</p>
<p>​	Thymeleaf对Spring Security的支持都放在thymeleaf-extras-springsecurityX中，目前最新版本为5。所以需要在项目中添加此jar包的依赖和thymeleaf的依赖。</p>
<pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.thymeleaf.extras&lt;/groupId&gt;
    &lt;artifactId&gt;thymeleaf-extras-springsecurity5&lt;/artifactId&gt;
    &lt;version&gt;3.0.4.RELEASE&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<p>​	在html页面中引入thymeleaf命名空间和security命名空间</p>
<pre><code class="html">&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;
      xmlns:th=&quot;http://www.thymeleaf.org&quot;
xmlns:sec=&quot;http://www.thymeleaf.org/thymeleaf-extras-springsecurity5&quot;&gt;
</code></pre>
<h2 id="1-获取属性"><a href="#1-获取属性" class="headerlink" title="1.获取属性"></a>1.获取属性</h2><p>​	可以在html页面中通过 sec:authentication&#x3D;””获取UsernamePasswordAuthenticationToken中所有getXXX的内容，包含父类中的getXXX的内容。</p>
<p>​	根据源码得出下面属性：</p>
<p>​	l name：登录账号名称</p>
<p>​	l principal：登录主体，在自定义登录逻辑中是UserDet ails</p>
<p>​	l credentials：凭证</p>
<p>​	l authorities：权限和角色</p>
<p>​	l details：实际上是WebAuthenticationDetails的实例。可以获取remoteAddress(客户端ip)和sessionId(当	前sessionId)</p>
<h3 id="1-1实现步骤："><a href="#1-1实现步骤：" class="headerlink" title="1.1实现步骤："></a>1.1实现步骤：</h3><h4 id="1-1-1新建demo-html"><a href="#1-1-1新建demo-html" class="headerlink" title="1.1.1新建demo.html"></a>1.1.1新建demo.html</h4><p>​	在项目resources中新建templates文件夹，在templates中新建demo.html页面</p>
<img data-src="/2022/10/07/Spring_Family/SpringSecurity/springSecurity-34.jpg" class="">


<h4 id="1-1-2编写demo-html"><a href="#1-1-2编写demo-html" class="headerlink" title="1.1.2编写demo.html"></a>1.1.2编写demo.html</h4><p>​	在demo.html中编写下面内容，测试获取到的值</p>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;
      xmlns:th=&quot;http://www.thymeleaf.org&quot;
      xmlns:sec=&quot;http://www.thymeleaf.org/thymeleaf-extras-springsecurity5&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    登录账号:&lt;span sec:authentication=&quot;name&quot;&gt;&lt;/span&gt;&lt;br/&gt;
    登录账号:&lt;span sec:authentication=&quot;principal.username&quot;&gt;&lt;/span&gt;&lt;br/&gt;
    凭证：&lt;span sec:authentication=&quot;credentials&quot;&gt;&lt;/span&gt;&lt;br/&gt;
    权限和角色：&lt;span sec:authentication=&quot;authorities&quot;&gt;&lt;/span&gt;&lt;br/&gt;
    客户端地址：&lt;span sec:authentication=&quot;details.remoteAddress&quot;&gt;&lt;/span&gt;&lt;br/&gt;
    sessionId：&lt;span sec:authentication=&quot;details.sessionId&quot;&gt;&lt;/span&gt;&lt;br/&gt;
&lt;/body&gt;
&lt;/html&gt;  
</code></pre>
<h4 id="1-1-3编写控制器"><a href="#1-1-3编写控制器" class="headerlink" title="1.1.3编写控制器"></a>1.1.3编写控制器</h4><p>​	thymeleaf页面需要控制转发，在控制器类中编写下面方法</p>
<pre><code class="java">@RequestMapping(&quot;/demo&quot;)
public String demo()&#123;
    return &quot;demo&quot;;
&#125;
</code></pre>
<h2 id="2-权限判断"><a href="#2-权限判断" class="headerlink" title="2.权限判断"></a>2.权限判断</h2><p>​	在html页面中可以使用sec:authorize&#x3D;”表达式”进行权限控制，判断是否显示某些内容。表达式的内容和access(表达式)的用法相同。如果用户具有指定的权限，则显示对应的内容；如果表达式不成立，则不显示对应的元素。</p>
<h3 id="2-1不同权限的用户显示不同的按钮"><a href="#2-1不同权限的用户显示不同的按钮" class="headerlink" title="2.1不同权限的用户显示不同的按钮"></a>2.1不同权限的用户显示不同的按钮</h3><h4 id="2-1-1设置用户角色和权限"><a href="#2-1-1设置用户角色和权限" class="headerlink" title="2.1.1设置用户角色和权限"></a>2.1.1设置用户角色和权限</h4><p>​	设定用户具有admin，&#x2F;insert，&#x2F;delete权限ROLE_abc角色。</p>
<pre><code class="java">return new User(username,password, 
                AuthorityUtils.commaSeparatedStringToAuthorityList(&quot;admin,ROLE_abc,/insert,/delete&quot;));
</code></pre>
<h4 id="2-1-2控制页面显示效果"><a href="#2-1-2控制页面显示效果" class="headerlink" title="2.1.2控制页面显示效果"></a>2.1.2控制页面显示效果</h4><p>在页面中根据用户权限和角色判断页面中显示的内容</p>
<pre><code class="html">通过权限判断：
&lt;button sec:authorize=&quot;hasAuthority(&#39;/insert&#39;)&quot;&gt;新增&lt;/button&gt;
&lt;button sec:authorize=&quot;hasAuthority(&#39;/delete&#39;)&quot;&gt;删除&lt;/button&gt;
&lt;button sec:authorize=&quot;hasAuthority(&#39;/update&#39;)&quot;&gt;修改&lt;/button&gt;
&lt;button sec:authorize=&quot;hasAuthority(&#39;/select&#39;)&quot;&gt;查看&lt;/button&gt;
&lt;br/&gt;
通过角色判断：
&lt;button sec:authorize=&quot;hasRole(&#39;abc&#39;)&quot;&gt;新增&lt;/button&gt;
&lt;button sec:authorize=&quot;hasRole(&#39;abc&#39;)&quot;&gt;删除&lt;/button&gt;
&lt;button sec:authorize=&quot;hasRole(&#39;abc&#39;)&quot;&gt;修改&lt;/button&gt;
&lt;button sec:authorize=&quot;hasRole(&#39;abc&#39;)&quot;&gt;查看&lt;/button&gt;
</code></pre>
<h1 id="十三、SpringSecurity-的”跨域”问题"><a href="#十三、SpringSecurity-的”跨域”问题" class="headerlink" title="十三、SpringSecurity 的”跨域”问题"></a>十三、SpringSecurity 的”跨域”问题</h1><p>​	浏览器出于安全的考虑，使用 XMLHttpRequest对象发起 HTTP请求时必须遵守同源策略，否则就是跨域的HTTP请求，默认情况下是被禁止的。 同源策略要求源相同才能正常进行通信，即协议、域名、端口号都完全一致。 </p>
<p>​	前后端分离项目，前端项目和后端项目一般都不是同源的，所以肯定会存在跨域请求的问题。</p>
<p>​	所以我们就要处理一下，让前端能进行跨域请求。</p>
<h2 id="①先对SpringBoot配置，运行跨域请求"><a href="#①先对SpringBoot配置，运行跨域请求" class="headerlink" title="①先对SpringBoot配置，运行跨域请求"></a>①先对SpringBoot配置，运行跨域请求</h2><p>这里的方式多种多想可以 配置类，也可以对跨域的请求直接加注解 ，自己视情况而定</p>
<pre><code class="java">@Configuration
public class CorsConfig implements WebMvcConfigurer &#123;

    @Override
    public void addCorsMappings(CorsRegistry registry) &#123;
      // 设置允许跨域的路径
        registry.addMapping(&quot;/**&quot;)
                // 设置允许跨域请求的域名
                .allowedOriginPatterns(&quot;*&quot;)
                // 是否允许cookie
                .allowCredentials(true)
                // 设置允许的请求方式
                .allowedMethods(&quot;GET&quot;, &quot;POST&quot;, &quot;DELETE&quot;, &quot;PUT&quot;)
                // 设置允许的header属性
                .allowedHeaders(&quot;*&quot;)
                // 跨域允许时间
                .maxAge(3600);
    &#125;
&#125;
</code></pre>
<h2 id="②开启SpringSecurity的跨域访问"><a href="#②开启SpringSecurity的跨域访问" class="headerlink" title="②开启SpringSecurity的跨域访问"></a>②开启SpringSecurity的跨域访问</h2><p>由于我们的资源都会收到SpringSecurity的保护，所以想要跨域访问还要让SpringSecurity运行跨域访问。</p>
<pre><code class="java">    @Override
    protected void configure(HttpSecurity http) throws Exception &#123;
        http
                //关闭csrf
                .csrf().disable()
                //不通过Session获取SecurityContext
                .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)
                .and()
                .authorizeRequests()
                // 对于登录接口 允许匿名访问
                .antMatchers(&quot;/user/login&quot;).anonymous()
                // 除上面外的所有请求全部需要鉴权认证
                .anyRequest().authenticated();

        //添加过滤器
        http.addFilterBefore(jwtAuthenticationTokenFilter, UsernamePasswordAuthenticationFilter.class);

        //配置异常处理器
        http.exceptionHandling()
                //配置认证失败处理器
                .authenticationEntryPoint(authenticationEntryPoint)
                .accessDeniedHandler(accessDeniedHandler);

        //允许跨域
        http.cors();
    &#125;
</code></pre>
<h1 id="十三、退出登录"><a href="#十三、退出登录" class="headerlink" title="十三、退出登录"></a>十三、退出登录</h1><p>​	用户只需要向Spring Security项目中发送&#x2F;logout退出请求即可。</p>
<h2 id="1-退出实现"><a href="#1-退出实现" class="headerlink" title="1.退出实现"></a>1.退出实现</h2><p>实现退出非常简单，只要在页面中添加&#x2F;logout的超链接即可。</p>
<pre><code class="html">&lt;a href=&quot;/logout&quot;&gt;退出登录&lt;/a&gt;
</code></pre>
<p>​	为了实现更好的效果，通常添加退出的配置。默认的退出url为&#x2F;logout，退出成功后跳转到&#x2F;login?logout</p>
<p>​	如果不希望使用默认值，可以通过下面的方法进行修改。</p>
<pre><code class="java">http.logout()     
    .logoutUrl(**&quot;/logout&quot;**)     
    .logoutSuccessUrl(**&quot;/login.html&quot;**);
</code></pre>
<h2 id="2-logout其他常用配置源码解读"><a href="#2-logout其他常用配置源码解读" class="headerlink" title="2.logout其他常用配置源码解读"></a>2.logout其他常用配置源码解读</h2><h3 id="2-1-addLogoutHandler-LogoutHandler"><a href="#2-1-addLogoutHandler-LogoutHandler" class="headerlink" title="2.1.addLogoutHandler(LogoutHandler)"></a>2.1.addLogoutHandler(LogoutHandler)</h3><p>​	默认是contextLogoutHandler</p>
<p>​	默认实例内容</p>
<img data-src="/2022/10/07/Spring_Family/SpringSecurity/springSecurity-37.jpg" class="">


<h3 id="2-2clearAuthentication-boolean"><a href="#2-2clearAuthentication-boolean" class="headerlink" title="2.2clearAuthentication(boolean)"></a>2.2clearAuthentication(boolean)</h3><p>​	是否清除认证状态，默认为true</p>
<h5 id="2-3invalidateHttpSession-boolean"><a href="#2-3invalidateHttpSession-boolean" class="headerlink" title="2.3invalidateHttpSession(boolean)"></a>2.3invalidateHttpSession(boolean)</h5><p>​	是否销毁HttpSession对象，默认为true</p>
<h3 id="2-4logoutSuccessHandler-LogoutSuccessHandler"><a href="#2-4logoutSuccessHandler-LogoutSuccessHandler" class="headerlink" title="2.4logoutSuccessHandler(LogoutSuccessHandler)"></a>2.4logoutSuccessHandler(LogoutSuccessHandler)</h3><p>​	退出成功处理器。</p>
<p>​	也可以自己进行定义退出成功处理器。只要实现了LogoutSuccessHandler接口。与之前讲解的登录成功处理器和登录失败处理器极其类似。</p>
<h1 id="十四、Spring-Security-中-CSRF"><a href="#十四、Spring-Security-中-CSRF" class="headerlink" title="十四、Spring Security 中 CSRF"></a>十四、Spring Security 中 CSRF</h1><p>​	从刚开始学习Spring Security时，在配置类中一直存在这样一行代码：http.csrf().disable();如果没有这行代码导致用户无法被认证。这行代码的含义是：关闭csrf防护。</p>
<h2 id="1-什么是CSRF"><a href="#1-什么是CSRF" class="headerlink" title="1.什么是CSRF"></a>1.什么是CSRF</h2><p>​	CSRF（Cross-site request forgery）跨站请求伪造，也被称为“One Click Attack” 或者Session Riding。通过伪造用户请求访问受信任站点的非法请求访问。</p>
<p>​	跨域：只要网络协议，ip地址，端口中任何一个不相同就是跨域请求。</p>
<p>​	客户端与服务进行交互时，由于http协议本身是无状态协议，所以引入了cookie进行记录客户端身份。在cookie中会存放session id用来识别客户端身份的。在跨域的情况下，session id可能被第三方恶意劫持，通过这个session id向服务端发起请求时，服务端会认为这个请求是合法的，可能发生很多意想不到的事情。</p>
<h2 id="2-Spring-Security中CSRF"><a href="#2-Spring-Security中CSRF" class="headerlink" title="2.Spring Security中CSRF"></a>2.Spring Security中CSRF</h2><p>​	从Spring Security4开始CSRF防护默认开启。默认会拦截请求。进行CSRF处理。CSRF为了保证不是其他第三方网站访问，要求访问时携带参数名为_csrf值为token(token在服务端产生)的内容，如果token和服务端的token匹配成功，则正常访问。 </p>
<h3 id="2-1实现步骤-1"><a href="#2-1实现步骤-1" class="headerlink" title="2.1实现步骤"></a>2.1实现步骤</h3><h4 id="2-1-1-编写控制器方法"><a href="#2-1-1-编写控制器方法" class="headerlink" title="2.1.1 编写控制器方法"></a>2.1.1 编写控制器方法</h4><p>​	编写控制器方法，跳转到templates中login.html页面。</p>
<pre><code class="java">@GetMapping(&quot;/showLogin&quot;)
public String showLogin() &#123;
    return &quot;login&quot;;
&#125;
</code></pre>
<h4 id="2-1-2新建login-html"><a href="#2-1-2新建login-html" class="headerlink" title="2.1.2新建login.html"></a>2.1.2新建login.html</h4><p>在项目resources下新建templates文件夹，并在文件夹中新建login.html页面。红色部分是必须存在的否则无法正常登录。</p>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;
      xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;form action = &quot;/login&quot; method=&quot;post&quot;&gt;
    &lt;input type=&quot;hidden&quot; th:value=&quot;$&#123;_csrf.token&#125;&quot; name=&quot;_csrf&quot; th:if=&quot;$&#123;_csrf&#125;&quot;/&gt;
    用户名：&lt;input type=&quot;text&quot; name=&quot;username&quot;/&gt;&lt;br/&gt;
    密码:&lt;input type=&quot;password&quot; name=&quot;password&quot;/&gt;&lt;br/&gt;
    &lt;input type=&quot;submit&quot; value=&quot;登录&quot;/&gt;
&lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;     
</code></pre>
<h4 id="2-1-3修改配置类"><a href="#2-1-3修改配置类" class="headerlink" title="2.1.3修改配置类"></a>2.1.3修改配置类</h4><p>在配置类中注释掉CSRF防护失效</p>
<pre><code class="java">//关闭csrf防护
//http.csrf().disable();
</code></pre>
]]></content>
      <categories>
        <category>Spring</category>
        <category>SpringSecurity</category>
      </categories>
      <tags>
        <tag>框架</tag>
        <tag>Spring</tag>
        <tag>SpringSecurity</tag>
      </tags>
  </entry>
  <entry>
    <title>HAProxy安装</title>
    <url>/2022/10/15/tools/HAProxy-tool/</url>
    <content><![CDATA[<h4 id="HAProxy安装"><a href="#HAProxy安装" class="headerlink" title="HAProxy安装"></a>HAProxy安装</h4><h5 id="——1"><a href="#——1" class="headerlink" title="——1"></a>——1</h5><h6 id="1、准备好HAProxy的安装包"><a href="#1、准备好HAProxy的安装包" class="headerlink" title="1、准备好HAProxy的安装包"></a>1、准备好HAProxy的安装包</h6><p><span class="exturl" data-url="aHR0cHM6Ly9zcmMuZmVkb3JhcHJvamVjdC5vcmcvcmVwby9wa2dzL2hhcHJveHkv">https://src.fedoraproject.org/repo/pkgs/haproxy/</span></p>
<h6 id="2、解压到-x2F-usr-x2F-local目录"><a href="#2、解压到-x2F-usr-x2F-local目录" class="headerlink" title="2、解压到&#x2F;usr&#x2F;local目录"></a>2、解压到&#x2F;usr&#x2F;local目录</h6><h6 id="3、进入到解压后的目录，查看内核版本，进行编译"><a href="#3、进入到解压后的目录，查看内核版本，进行编译" class="headerlink" title="3、进入到解压后的目录，查看内核版本，进行编译"></a>3、进入到解压后的目录，查看内核版本，进行编译</h6><pre><code class="shell">cd cd /usr/local/haproxy-1.8.25/

### 查看内核版本3.10=31
uname -r

make TARGET=linux31
</code></pre>
<h6 id="4、编译完成之后，开始进行安装"><a href="#4、编译完成之后，开始进行安装" class="headerlink" title="4、编译完成之后，开始进行安装"></a>4、编译完成之后，开始进行安装</h6><pre><code class="shell">make install PREFIX=/usr/local/haproxy
</code></pre>
<h6 id="5、安装完成之后，创建目录，创建HAProxy配置文件"><a href="#5、安装完成之后，创建目录，创建HAProxy配置文件" class="headerlink" title="5、安装完成之后，创建目录，创建HAProxy配置文件"></a>5、安装完成之后，创建目录，创建HAProxy配置文件</h6><pre><code class="shell">mkdir -p /usr/data/haproxy
mkdir /usr/local/haproxy/conf
vi /usr/local/haproxy/conf、haproxy.conf
</code></pre>
<p>6、向配置文件中添加配置信息</p>
<pre><code class="shell">    global
        log 127.0.0.1 local0
##		#log 127.0.0.1 local1 notice
##		#log loghost local0 info
        maxconn 4096
        chroot /usr/local/haproxy
        pidfile /usr/data/haproxy/haproxy.pid
        uid 99
        gid 99
        daemon
##		#debug
##		#quiet
defaults
        log global
        mode tcp
        option abortonclose
        option redispatch
        retries 3
        maxconn 2000
        timeout connect 5000
        timeout client 50000
        timeout server 50000
listen proxy_status
    bind :48066
        mode tcp
        balance roundrobin
        server mycat_1 192.168.85.111:8066 check inter 10s
        server mycat_2 192.168.85.112:8066 check inter 10s
frontend admin_stats
    bind :7777
        mode http
        stats enable
        option httplog
        maxconn 10
        stats refresh 30s
        stats uri /admin
        stats auth admin:123123
        stats hide-version
        stats admin if TRUE
</code></pre>
<ul>
<li>stats uri &#x2F;admin                   		   <strong>账号</strong></li>
<li>stats auth admin:123123       	   <strong>密码</strong></li>
</ul>
<h6 id="7、启动haproxy服务"><a href="#7、启动haproxy服务" class="headerlink" title="7、启动haproxy服务"></a>7、启动haproxy服务</h6><pre><code class="shell">    /usr/local/haproxy/sbin/haproxy -f /usr/local/haproxy/conf/haproxy.conf
</code></pre>
<h6 id="8、查看haproxy的进程，如果存在则说明没有问题"><a href="#8、查看haproxy的进程，如果存在则说明没有问题" class="headerlink" title="8、查看haproxy的进程，如果存在则说明没有问题"></a>8、查看haproxy的进程，如果存在则说明没有问题</h6><pre><code class="shell">    ps -ef | grep haproxy
</code></pre>
<h6 id="9、打开浏览器访问-用户名为admin，密码为123123"><a href="#9、打开浏览器访问-用户名为admin，密码为123123" class="headerlink" title="9、打开浏览器访问,用户名为admin，密码为123123"></a>9、打开浏览器访问,用户名为admin，密码为123123</h6><p>​	<span class="exturl" data-url="aHR0cDovLzE5Mi4xNjguMS4xNjQ6Nzc3Ny9hZG1pbg==">http://192.168.1.164:7777/admin</span></p>
]]></content>
      <categories>
        <category>工具软件安装</category>
      </categories>
  </entry>
  <entry>
    <title>Erlang</title>
    <url>/2022/10/15/tools/Erlang-tool/</url>
    <content><![CDATA[<h3 id="Erlang安装"><a href="#Erlang安装" class="headerlink" title="Erlang安装"></a><strong>Erlang安装</strong></h3><h4 id="——1"><a href="#——1" class="headerlink" title="——1"></a>——1</h4><p>​	RabbitMQ是使用Erlang语言编写的，所以需要先配置Erlang</p>
<h5 id="1-修改主机名"><a href="#1-修改主机名" class="headerlink" title="1 修改主机名"></a>1 <strong>修改主机名</strong></h5><p>​	RabbitMQ是通过主机名进行访问的，必须指定能访问的主机名。</p>
<pre><code>  vim /etc/sysconfig/network
  
  添加
  NETWORKING=yes
#  HOSTNAME=node-1 #名字可以随意
</code></pre>
<p><img data-src="https://cdn.jsdelivr.net/gh/onlymarryu/typora-ims-test@master/RabbitMQ-06.jpg"></p>
<pre><code>    vim /etc/hosts
  
    ip network_hostname
eg: 192.168.1.195 node-1  
</code></pre>
<p>​	新添加了一行，前面为服务器ip，空格后面添加计算机主机名</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/onlymarryu/typora-ims-test@master/RabbitMQ-07.jpg"></p>
<h5 id="2-安装依赖"><a href="#2-安装依赖" class="headerlink" title="2 安装依赖"></a>2 <strong>安装依赖</strong></h5><pre><code>  yum -y install make gcc gcc-c++ kernel-devel m4 ncurses-devel openssl-devel unixODBC unixODBC-devel
</code></pre>
<h5 id="3-上传并解压"><a href="#3-上传并解压" class="headerlink" title="3 上传并解压"></a>3 <strong>上传并解压</strong></h5><p>​	上传otp_src_22.0.tar.gz到&#x2F;usr&#x2F;local&#x2F;tmp目录中，进入目录并解压。</p>
<pre><code> 解压时注意，此压缩包不具有gzip属性，解压参数没有z，只有xf
</code></pre>
<pre><code>  cd /usr/local/tmp
  tar xf otp_src_22.0.tar.gz -C /usr/local/tmp
</code></pre>
<h5 id="4-配置参数"><a href="#4-配置参数" class="headerlink" title="4 配置参数"></a>4 <strong>配置参数</strong></h5><p>​	先新建&#x2F;usr&#x2F;local&#x2F;erlang文件夹，作为安装文件夹</p>
<pre><code>  mkdir -p /usr/local/erlang
</code></pre>
<p>​	 进入文件夹</p>
<pre><code>  cd otp_src_22.0
</code></pre>
<p>​	 配置参数</p>
<pre><code>  ./configure --prefix=/usr/local/erlang --with-ssl --enable-threads --enable-smp-support --enable-kernel-poll --enable-hipe --without-javac
</code></pre>
<h5 id="5-编译并安装"><a href="#5-编译并安装" class="headerlink" title="5 编译并安装"></a>5 <strong>编译并安装</strong></h5><p>​	编译 </p>
<pre><code>  make
</code></pre>
<p>​	 安装</p>
<pre><code>  make install
</code></pre>
<h5 id="6-修改环境变量"><a href="#6-修改环境变量" class="headerlink" title="6 修改环境变量"></a>6 <strong>修改环境变量</strong></h5><p>​	修改&#x2F;etc&#x2F;profile文件</p>
<pre><code> vim /etc/profile
</code></pre>
<p>​	 在文件中添加下面代码 </p>
<pre><code>export PATH=$PATH:/usr/local/erlang/bin
</code></pre>
<p>​	运行文件，让修改内容生效</p>
<pre><code>  source /etc/profile
</code></pre>
<h5 id="7-查看配置是否成功"><a href="#7-查看配置是否成功" class="headerlink" title="7 查看配置是否成功"></a>7 <strong>查看配置是否成功</strong></h5><pre><code>  erl -version
</code></pre>
<p><img data-src="https://cdn.jsdelivr.net/gh/onlymarryu/typora-ims-test@master/RabbitMQ-08.jpg"></p>
]]></content>
      <categories>
        <category>工具软件安装</category>
      </categories>
  </entry>
  <entry>
    <title>HDFS安装</title>
    <url>/2022/10/15/tools/HDFS-tool/</url>
    <content><![CDATA[<h3 id="HDFS安装"><a href="#HDFS安装" class="headerlink" title="HDFS安装"></a>HDFS安装</h3><h4 id="——1"><a href="#——1" class="headerlink" title="——1"></a>——1</h4><h4 id="——2"><a href="#——2" class="headerlink" title="——2"></a>——2</h4><p>1.拉取Hadoop镜像（可以在docker hub上找合适的镜像）：</p>
<pre><code class="shell">docker pull singularities/hadoop
</code></pre>
<p>2.创建docker-compose.yml文件（可以在文本编辑器中写好后，复制），内容如下：</p>
<pre><code class="yml">version: &quot;2&quot;

services:
  namenode:
    image: singularities/hadoop
    command: start-hadoop namenode
    environment:
      HDFS_USER: hdfsuser
    ports:
      - &quot;8020:8020&quot;
      - &quot;14000:14000&quot;
      - &quot;50070:50070&quot;
      - &quot;10020:10020&quot;
      - &quot;13562:13562&quot;
      - &quot;19888:19888&quot;
  datanode:
    image: singularities/hadoop
    command: start-hadoop datanode namenode
    environment:
      HDFS_USER: hdfsuser
    links:
      - namenode
</code></pre>
<p>3.创建hadoop，执行如下命令</p>
<pre><code class="shell">docker-compose up -d
docker ps
</code></pre>
<p>4.开启多个datanode</p>
<pre><code class="shell">docker-compose scale datanode=3
docker ps
</code></pre>
<p>5.查看hadoop控制面板。由于服务刚初始化，可能需要等一会。访问类似如下url：</p>
<pre><code class="ruby">#http://192.168.1.195:50070/dfshealth.html#tab-datanode
</code></pre>
<p>6.进入任意hadoop相关容器，<strong>直接进行hdfs基础操作</strong><br>在任意datanode的容器中操作hdfs，会自动同步到其他的datanode容器中。</p>
<pre><code class="bash">### 查看所有命令
hadoop fs
### 创建目录
#hadoop fs -mkdir /hdfs #在根目录下创建hdfs文件夹
### 查看目录
#hadoop fs -ls  /   #列出根目录下的文件列表
### 创建多级目录
hadoop fs -mkdir -p /hdfs/d1/d2
### 上传文件到HDFS
#echo &quot;hello world&quot; &gt;&gt; local.txt   #创建文件
#hadoop fs -put local.txt /hdfs/   #上传文件到hdfs
### 下载hdfs文件
hadoop fs -get /hdfs/local.txt
### 删除hdfs中的文件
hadoop fs -rm /hdfs/local.txt
### 删除hdfs中的目录
hadoop fs -rmdir /hdfs/d1/d2
</code></pre>
]]></content>
      <categories>
        <category>工具软件安装</category>
      </categories>
  </entry>
  <entry>
    <title>JRebel安装</title>
    <url>/2022/10/15/tools/JRebel-tool/</url>
    <content><![CDATA[<h3 id="资料在网盘里面"><a href="#资料在网盘里面" class="headerlink" title="资料在网盘里面"></a>资料在网盘里面</h3>]]></content>
      <categories>
        <category>工具软件安装</category>
      </categories>
  </entry>
  <entry>
    <title>IDEA-tool</title>
    <url>/2022/10/15/tools/IDEA-tool/</url>
    <content><![CDATA[<h2 id="常用插件"><a href="#常用插件" class="headerlink" title="常用插件"></a>常用插件</h2><h4 id="皮肤"><a href="#皮肤" class="headerlink" title="皮肤"></a>皮肤</h4><blockquote>
<p>所有Jetbrains全家桶都适用</p>
</blockquote>
<h5 id="Cyan-Light-Theme"><a href="#Cyan-Light-Theme" class="headerlink" title="Cyan Light Theme"></a>Cyan Light Theme</h5><img data-src="/2022/10/15/tools/IDEA-tool/image-20220721202846958-1665745616515.png" class="">


<h5 id="Vuesion-Theme"><a href="#Vuesion-Theme" class="headerlink" title="Vuesion Theme"></a>Vuesion Theme</h5><img data-src="/2022/10/15/tools/IDEA-tool/image-20220721203729737-1665745616515.png" class="">


<h5 id="One-Dark-Theme"><a href="#One-Dark-Theme" class="headerlink" title="One Dark Theme"></a>One Dark Theme</h5><img data-src="/2022/10/15/tools/IDEA-tool/img-1665745616515.png" class="">


<h4 id="Atom-Material-ICons"><a href="#Atom-Material-ICons" class="headerlink" title="Atom Material ICons"></a>Atom Material ICons</h4><blockquote>
<p>文件夹图标修改</p>
</blockquote>
<img data-src="/2022/10/15/tools/IDEA-tool/image-20220721202830248-1665745616515.png" class="">




<h4 id="Maven-Helper"><a href="#Maven-Helper" class="headerlink" title="Maven Helper ******"></a>Maven Helper ******</h4><blockquote>
<p>查看Maven依赖，如果存在依赖冲突会直接爆红，很方便。</p>
</blockquote>
<img data-src="/2022/10/15/tools/IDEA-tool/image-20220721203551163-1665745616515.png" class="">


<h4 id="MybatisX"><a href="#MybatisX" class="headerlink" title="MybatisX"></a>MybatisX</h4><blockquote>
<p>这个不用多说懂的都懂</p>
</blockquote>
<h4 id="Lombok"><a href="#Lombok" class="headerlink" title="Lombok"></a>Lombok</h4><blockquote>
<p>这个不用多说懂的都懂</p>
</blockquote>
<h4 id="JRebel-and-XRebel"><a href="#JRebel-and-XRebel" class="headerlink" title="JRebel and XRebel"></a>JRebel and XRebel</h4><blockquote>
<p>热部署工具</p>
</blockquote>
<h4 id="RestfulToolkits"><a href="#RestfulToolkits" class="headerlink" title="RestfulToolkits"></a>RestfulToolkits</h4><blockquote>
<p>可以直接根据URL查看本地的对应Controller，也可以当做Postman用</p>
</blockquote>
<img data-src="/2022/10/15/tools/IDEA-tool/image-20220721203331392-1665745616515.png" class="">


<h4 id="GsonFormat"><a href="#GsonFormat" class="headerlink" title="GsonFormat"></a>GsonFormat</h4><blockquote>
<p>可以帮助我们快速的将JSON对象转换为Bean</p>
</blockquote>
<h4 id="Rainbow-Brakets"><a href="#Rainbow-Brakets" class="headerlink" title="Rainbow Brakets"></a>Rainbow Brakets</h4><blockquote>
<p>彩虹括号</p>
</blockquote>
<h4 id="arthas-idea"><a href="#arthas-idea" class="headerlink" title="arthas idea"></a>arthas idea</h4><blockquote>
<p>Arthas阿里开源的一款强大的JAVA在线诊断工具</p>
<p>缺点：需要输入一段很长的命令，如果有遗忘的话就去查看文档<br>这款插件就直接解决了这些问题。</p>
</blockquote>
<h4 id="VisualGC"><a href="#VisualGC" class="headerlink" title="VisualGC"></a>VisualGC</h4><blockquote>
<p>诊断JVM堆栈工具</p>
</blockquote>
<h4 id="Zoolytic"><a href="#Zoolytic" class="headerlink" title="Zoolytic"></a>Zoolytic</h4><blockquote>
<p>一款Zookeeper结点查看分析插件。其实第三方也有一些工具。</p>
</blockquote>
<h4 id="SequenceDiagram"><a href="#SequenceDiagram" class="headerlink" title="SequenceDiagram"></a>SequenceDiagram</h4><blockquote>
<p>作用：快速查看某个方法的时序图，作用就是在我们查看项目源码时，查看方法的流程</p>
<p>注：只能查看我们自己写的源码，不能查看JDK的源码运行流程</p>
</blockquote>
<h5 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h5><p>1、点击<strong>方法名</strong> ，然后右键点击 <code>SequenceDiagram</code></p>
<img data-src="/2022/10/15/tools/IDEA-tool/image-20220727211446055-1665745616515.png" class="">


<p>2、配置我们的生成策略</p>
<img data-src="/2022/10/15/tools/IDEA-tool/image-20220727212313180-1665745616515.png" class="">


<img data-src="/2022/10/15/tools/IDEA-tool/image-20220727211659767-1665745616515.png" class="">


<p>除了策略配置我们最常用的就还是最后一个保存为 .plantUML 文件，配合 <code>PlantUML Integration</code> 删除或者添加一下注解 更加完善我们的流程图</p>
<h4 id="PlantUML-Integration"><a href="#PlantUML-Integration" class="headerlink" title="PlantUML Integration"></a>PlantUML Integration</h4><blockquote>
<p>作用：通过代码形式来写时序图，主要还是配合 SquenceDiagram</p>
</blockquote>
<p>插件下载成功之后我们可以右键直接new出来 .PlantUML文件，自己直接写时序图，但是效率低不推荐还是配合Sequence吧</p>
<img data-src="/2022/10/15/tools/IDEA-tool/image-20220727212819103-1665745616515.png" class="">


<p>推荐一个 Sequence 和 PlantUML 二合一的应用：Sourcetrail ，有点难用，关键是英文，但是真的好用，等我死磕！！！</p>
<p>具体操作百度一下就行了</p>
<h4 id="Easy-Code"><a href="#Easy-Code" class="headerlink" title="Easy Code"></a>Easy Code</h4><p> 自动生成作为为我自己常用的架构层次以及命名规则，在快速生产中没有他人硬性标准的情况下，不用额外配置，由于MybatisPlus的逆向工程(这老哥还要写那一套重复代码麻烦，我就鼠标点点！！！)</p>
<p>&#x3D;&#x3D;下载完成之后，修改一下原来的配置模板文档(无脑粘贴没毛病)&#x3D;&#x3D;</p>
<img data-src="/2022/10/15/tools/IDEA-tool/image-20220821181239253-1665745616515.png" class="">


<h5 id="controller"><a href="#controller" class="headerlink" title="controller"></a>controller</h5><pre><code class="java">####导入宏定义
$!&#123;define.vm&#125;

####设置表后缀（宏定义）
####setTableSuffix(&quot;Controller&quot;)

####保存文件（宏定义）
####save(&quot;/controller&quot;, &quot;Controller.java&quot;)

####包路径（宏定义）
####setPackageSuffix(&quot;controller&quot;)

####定义服务名
####set($serviceName = $!tool.append($!tool.firstLowerCase($!tableInfo.name), &quot;Service&quot;))

####定义实体对象名
####set($entityName = $!tool.firstLowerCase($!tableInfo.name))

import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;
import com.baomidou.mybatisplus.extension.api.ApiController;
import com.baomidou.mybatisplus.extension.api.R;
import org.springframework.beans.factory.annotation.Autowired;
import com.baomidou.mybatisplus.extension.plugins.pagination.Page;
import $!&#123;tableInfo.savePackageName&#125;.pojo.$!tableInfo.name;
import $!&#123;tableInfo.savePackageName&#125;.service.$!&#123;tableInfo.name&#125;Service;
import org.springframework.web.bind.annotation.*;

import java.io.Serializable;
import java.util.List;

####表注释（宏定义）
####tableComment(&quot;表控制层&quot;)
@RestController
@RequestMapping(&quot;/$!tool.firstLowerCase($!tableInfo.name)&quot;)
public class $!&#123;tableName&#125; &#123;
    /**
     * 服务对象
     */
    @Autowired
    private $!&#123;tableInfo.name&#125;Service $!&#123;serviceName&#125;;

    
&#125;
</code></pre>
<h5 id="entity"><a href="#entity" class="headerlink" title="entity"></a>entity</h5><p>我的实体类一般都叫pojo， 其中要整合MybatisPlus因为我在模板里面加了一个他的注解@TableName</p>
<pre><code class="xml">   &lt;!--MybatisPlus--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.baomidou&lt;/groupId&gt;
            &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;
            &lt;version&gt;3.4.2&lt;/version&gt;
        &lt;/dependency&gt;
</code></pre>
<pre><code class="java">####导入宏定义
$!&#123;define.vm&#125;

####保存文件（宏定义）
####save(&quot;/pojo&quot;, &quot;.java&quot;)

####包路径（宏定义）
####setPackageSuffix(&quot;pojo&quot;)

####自动导入包（全局变量）
$!&#123;autoImport.vm&#125;
import com.baomidou.mybatisplus.extension.activerecord.Model;
import java.io.Serializable;
import lombok.*;
import com.baomidou.mybatisplus.annotation.TableName;
import com.baomidou.mybatisplus.annotation.TableField;

####表注释（宏定义）
####tableComment(&quot;表实体类&quot;)

@AllArgsConstructor
@NoArgsConstructor
@Date
@ToString
@TableName(value = &quot;$!&#123;tableInfo.name&#125;&quot;)
public class $!&#123;tableInfo.name&#125; implements Serializable &#123;
####foreach($column in $tableInfo.fullColumn)
    /**
    * ##if($&#123;column.comment&#125;)$&#123;column.comment&#125;##end
    
    */ 
    @TableField($tool.hump2Underline($!&#123;column.name&#125;))
    private $!&#123;tool.getClsNameByFullName($column.type)&#125; $!&#123;column.name&#125;;
    
####end

&#125;
</code></pre>
<h5 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h5><pre><code class="java">####导入宏定义
$!&#123;define.vm&#125;

####设置表后缀（宏定义）
####setTableSuffix(&quot;Service&quot;)

####保存文件（宏定义）
####save(&quot;/service&quot;, &quot;Service.java&quot;)

####包路径（宏定义）
####setPackageSuffix(&quot;service&quot;)

import com.baomidou.mybatisplus.extension.service.IService;
import $!&#123;tableInfo.savePackageName&#125;.pojo.$!tableInfo.name;

####表注释（宏定义）
####tableComment(&quot;表服务接口&quot;)
public interface $!&#123;tableName&#125; extends IService&lt;$!tableInfo.name&gt; &#123;

&#125;
</code></pre>
<h5 id="ServiceImpl"><a href="#ServiceImpl" class="headerlink" title="ServiceImpl"></a>ServiceImpl</h5><pre><code class="java">####导入宏定义
$!&#123;define.vm&#125;

####设置表后缀（宏定义）
####setTableSuffix(&quot;ServiceImpl&quot;)

####保存文件（宏定义）
####save(&quot;/service/impl&quot;, &quot;ServiceImpl.java&quot;)

####包路径（宏定义）
####setPackageSuffix(&quot;service.impl&quot;)

import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;
import $!&#123;tableInfo.savePackageName&#125;.mapper.$!&#123;tableInfo.name&#125;Mapper;
import $!&#123;tableInfo.savePackageName&#125;.pojo.$!&#123;tableInfo.name&#125;;
import $!&#123;tableInfo.savePackageName&#125;.service.$!&#123;tableInfo.name&#125;Service;
import org.springframework.stereotype.Service;

####表注释（宏定义）
####tableComment(&quot;表服务实现类&quot;)
@Service(&quot;$!tool.firstLowerCase($tableInfo.name)Service&quot;)
public class $!&#123;tableName&#125; extends ServiceImpl&lt;$!&#123;tableInfo.name&#125;Mapper, $!&#123;tableInfo.name&#125;&gt; implements $!&#123;tableInfo.name&#125;Service &#123;
    @Autowired
    private $!&#123;tableInfo.name&#125;Mapper $tool.firstLowerCase($!&#123;tableInfo.name&#125;)Mapper;
    
    
    
&#125;
</code></pre>
<h5 id="Dao-x2F-Mapper-java"><a href="#Dao-x2F-Mapper-java" class="headerlink" title="Dao  &#x2F;  Mapper.java"></a>Dao  &#x2F;  Mapper.java</h5><p>我习惯叫mapper层，文件也是以 *Mapper 结尾</p>
<pre><code class="java">####导入宏定义
$!&#123;define.vm&#125;

####设置表后缀（宏定义）
####setTableSuffix(&quot;Mapper&quot;)

####保存文件（宏定义）
####save(&quot;/mapper&quot;, &quot;Mapper.java&quot;)

####包路径（宏定义）
####setPackageSuffix(&quot;mapper&quot;)

import com.baomidou.mybatisplus.core.mapper.BaseMapper;
import $!&#123;tableInfo.savePackageName&#125;.pojo.$!tableInfo.name;
import org.apache.ibatis.annotations.Mapper;

####表注释（宏定义）
####tableComment(&quot;表数据库访问层&quot;)

@Mapper
public interface $!&#123;tableName&#125; extends BaseMapper&lt;$!tableInfo.name&gt; &#123;

&#125;
</code></pre>
<h5 id="Mapper-xml-映射文件，自己创建一下"><a href="#Mapper-xml-映射文件，自己创建一下" class="headerlink" title="Mapper.xml(映射文件，自己创建一下)"></a>Mapper.xml(映射文件，自己创建一下)</h5><pre><code class="xml">####引入mybatis支持
$!&#123;mybatisSupport.vm&#125;

####设置保存名称与保存位置
$!callback.setFileName($tool.append($!&#123;tableInfo.name&#125;, &quot;Mapper.xml&quot;))
$!callback.setSavePath($tool.append($modulePath, &quot;/src/main/resources/mapper&quot;))

####拿到主键
####if(!$tableInfo.pkColumn.isEmpty())
#    ##set($pk = $tableInfo.pkColumn.get(0))
####end
#### 拿到全索引列，用‘，’间隔
##set($sqlCloumn=&quot;##foreach($column in $tableInfo.fullColumn)$!column.name##if($!foreach.hasNext) ,##end ##end&quot;)

&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;$&#123;tableInfo.savePackageName&#125;.mapper.$!&#123;tableInfo.name&#125;Mapper&quot;&gt;

    &lt;sql id=&quot;All$!&#123;tableInfo.name&#125;Column&quot;&gt;$sqlCloumn&lt;/sql&gt;   
    &lt;resultMap type=&quot;$&#123;tableInfo.savePackageName&#125;.pojo.$!&#123;tableInfo.name&#125;&quot; id=&quot;$!&#123;tableInfo.name&#125;Map&quot;&gt;
####foreach($column in $tableInfo.fullColumn)
        &lt;result property=&quot;$!column.name&quot; column=&quot;$!column.obj.name&quot; /&gt;
####end
    &lt;/resultMap&gt;
    
    

&lt;/mapper&gt;
</code></pre>
<h5 id="设置快捷操作"><a href="#设置快捷操作" class="headerlink" title="设置快捷操作***"></a>设置快捷操作***</h5><p>直接导入我的JSON文件即可，将以下内容保存为.json文件并进行导入</p>
<img data-src="/2022/10/15/tools/IDEA-tool/image-20220823220304489-1665745616515.png" class="">


<pre><code class="json">&#123;
  &quot;author&quot; : &quot;makejava&quot;,
  &quot;version&quot; : &quot;1.2.6&quot;,
  &quot;userSecure&quot; : &quot;&quot;,
  &quot;currTypeMapperGroupName&quot; : &quot;Default&quot;,
  &quot;currTemplateGroupName&quot; : &quot;MybatisPlus&quot;,
  &quot;currColumnConfigGroupName&quot; : &quot;Default&quot;,
  &quot;currGlobalConfigGroupName&quot; : &quot;Default&quot;,
  &quot;typeMapper&quot; : &#123; &#125;,
  &quot;template&quot; : &#123;
    &quot;MybatisPlus&quot; : &#123;
      &quot;name&quot; : &quot;MybatisPlus&quot;,
      &quot;elementList&quot; : [ &#123;
        &quot;name&quot; : &quot;controller.java.vm&quot;,
        &quot;code&quot; : &quot;##导入宏定义\n$!&#123;define.vm&#125;\n\n##设置表后缀（宏定义）\n##setTableSuffix(\&quot;Controller\&quot;)\n\n##保存文件（宏定义）\n##save(\&quot;/controller\&quot;, \&quot;Controller.java\&quot;)\n\n##包路径（宏定义）\n##setPackageSuffix(\&quot;controller\&quot;)\n\n##定义服务名\n##set($serviceName = $!tool.append($!tool.firstLowerCase($!tableInfo.name), \&quot;Service\&quot;))\n\n##定义实体对象名\n##set($entityName = $!tool.firstLowerCase($!tableInfo.name))\n\nimport com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;\nimport com.baomidou.mybatisplus.extension.api.ApiController;\nimport com.baomidou.mybatisplus.extension.api.R;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport com.baomidou.mybatisplus.extension.plugins.pagination.Page;\nimport $!&#123;tableInfo.savePackageName&#125;.pojo.$!tableInfo.name;\nimport $!&#123;tableInfo.savePackageName&#125;.service.$!&#123;tableInfo.name&#125;Service;\nimport org.springframework.web.bind.annotation.*;\n\nimport java.io.Serializable;\nimport java.util.List;\n\n##表注释（宏定义）\n##tableComment(\&quot;表控制层\&quot;)\n@RestController\n@RequestMapping(\&quot;/$!tool.firstLowerCase($!tableInfo.name)\&quot;)\npublic class $!&#123;tableName&#125; &#123;\n    /**\n     * 服务对象\n     */\n    @Autowired\n    private $!&#123;tableInfo.name&#125;Service $!&#123;serviceName&#125;;\n\n    \n&#125;\n&quot;
      &#125;, &#123;
        &quot;name&quot; : &quot;entity.java.vm&quot;,
        &quot;code&quot; : &quot;##导入宏定义\n$!&#123;define.vm&#125;\n\n##保存文件（宏定义）\n##save(\&quot;/pojo\&quot;, \&quot;.java\&quot;)\n\n##包路径（宏定义）\n##setPackageSuffix(\&quot;pojo\&quot;)\n\n##自动导入包（全局变量）\n$!&#123;autoImport.vm&#125;\nimport com.baomidou.mybatisplus.extension.activerecord.Model;\nimport java.io.Serializable;\nimport lombok.*;\nimport com.baomidou.mybatisplus.annotation.TableName;\nimport com.baomidou.mybatisplus.annotation.TableField;\n\n##表注释（宏定义）\n##tableComment(\&quot;表实体类\&quot;)\n\n@AllArgsConstructor\n@NoArgsConstructor\n@Data\n@ToString\n@TableName(value = \&quot;$tool.hump2Underline($!&#123;tableInfo.name&#125;)\&quot;)\npublic class $!&#123;tableInfo.name&#125; implements Serializable &#123;\n##foreach($column in $tableInfo.fullColumn)\n    /**\n    * ##if($&#123;column.comment&#125;)$&#123;column.comment&#125;##end\n    \n    */ \n    @TableField(\&quot;$tool.hump2Underline($!&#123;column.name&#125;)\&quot;)\n    private $!&#123;tool.getClsNameByFullName($column.type)&#125; $!&#123;column.name&#125;;\n    \n##end\n\n&#125;\n&quot;
      &#125;, &#123;
        &quot;name&quot; : &quot;service.java.vm&quot;,
        &quot;code&quot; : &quot;##导入宏定义\n$!&#123;define.vm&#125;\n\n##设置表后缀（宏定义）\n##setTableSuffix(\&quot;Service\&quot;)\n\n##保存文件（宏定义）\n##save(\&quot;/service\&quot;, \&quot;Service.java\&quot;)\n\n##包路径（宏定义）\n##setPackageSuffix(\&quot;service\&quot;)\n\nimport com.baomidou.mybatisplus.extension.service.IService;\nimport $!&#123;tableInfo.savePackageName&#125;.pojo.$!tableInfo.name;\n\n##表注释（宏定义）\n##tableComment(\&quot;表服务接口\&quot;)\npublic interface $!&#123;tableName&#125; extends IService&lt;$!tableInfo.name&gt; &#123;\n\n&#125;\n&quot;
      &#125;, &#123;
        &quot;name&quot; : &quot;serviceImpl.java.vm&quot;,
        &quot;code&quot; : &quot;##导入宏定义\n$!&#123;define.vm&#125;\n\n##设置表后缀（宏定义）\n##setTableSuffix(\&quot;ServiceImpl\&quot;)\n\n##保存文件（宏定义）\n##save(\&quot;/service/impl\&quot;, \&quot;ServiceImpl.java\&quot;)\n\n##包路径（宏定义）\n##setPackageSuffix(\&quot;service.impl\&quot;)\n\nimport com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;\nimport $!&#123;tableInfo.savePackageName&#125;.mapper.$!&#123;tableInfo.name&#125;Mapper;\nimport $!&#123;tableInfo.savePackageName&#125;.pojo.$!&#123;tableInfo.name&#125;;\nimport $!&#123;tableInfo.savePackageName&#125;.service.$!&#123;tableInfo.name&#125;Service;\nimport org.springframework.stereotype.Service;\n\n##表注释（宏定义）\n##tableComment(\&quot;表服务实现类\&quot;)\n@Service(\&quot;$!tool.firstLowerCase($tableInfo.name)Service\&quot;)\npublic class $!&#123;tableName&#125; extends ServiceImpl&lt;$!&#123;tableInfo.name&#125;Mapper, $!&#123;tableInfo.name&#125;&gt; implements $!&#123;tableInfo.name&#125;Service &#123;\n    @Autowired\n    private $!&#123;tableInfo.name&#125;Mapper $tool.firstLowerCase($!&#123;tableInfo.name&#125;)Mapper;\n    \n    \n    \n&#125;\n&quot;
      &#125;, &#123;
        &quot;name&quot; : &quot;mapper.java.vm&quot;,
        &quot;code&quot; : &quot;##导入宏定义\n$!&#123;define.vm&#125;\n\n##设置表后缀（宏定义）\n##setTableSuffix(\&quot;Mapper\&quot;)\n\n##保存文件（宏定义）\n##save(\&quot;/mapper\&quot;, \&quot;Mapper.java\&quot;)\n\n##包路径（宏定义）\n##setPackageSuffix(\&quot;mapper\&quot;)\n\nimport com.baomidou.mybatisplus.core.mapper.BaseMapper;\nimport $!&#123;tableInfo.savePackageName&#125;.pojo.$!tableInfo.name;\nimport org.apache.ibatis.annotations.Mapper;\n\n##表注释（宏定义）\n##tableComment(\&quot;表数据库访问层\&quot;)\n\n@Mapper\npublic interface $!&#123;tableName&#125; extends BaseMapper&lt;$!tableInfo.name&gt; &#123;\n\n&#125;\n&quot;
      &#125;, &#123;
        &quot;name&quot; : &quot;mapper.xml.vm&quot;,
        &quot;code&quot; : &quot;##引入mybatis支持\n$!&#123;mybatisSupport.vm&#125;\n\n##设置保存名称与保存位置\n$!callback.setFileName($tool.append($!&#123;tableInfo.name&#125;, \&quot;Mapper.xml\&quot;))\n$!callback.setSavePath($tool.append($modulePath, \&quot;/src/main/resources/mapper\&quot;))\n\n##拿到主键\n##if(!$tableInfo.pkColumn.isEmpty())\n    ##set($pk = $tableInfo.pkColumn.get(0))\n##end\n## 拿到全索引列，用‘，’间隔\n##set($sqlCloumn=\&quot;##foreach($column in $tableInfo.fullColumn)$tool.hump2Underline($!column.name)##if($!foreach.hasNext) ,##end ##end\&quot;)\n\n&lt;?xml version=\&quot;1.0\&quot; encoding=\&quot;UTF-8\&quot;?&gt;\n&lt;!DOCTYPE mapper PUBLIC \&quot;-//mybatis.org//DTD Mapper 3.0//EN\&quot; \&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd\&quot;&gt;\n&lt;mapper namespace=\&quot;$&#123;tableInfo.savePackageName&#125;.mapper.$!&#123;tableInfo.name&#125;Mapper\&quot;&gt;\n\n    &lt;sql id=\&quot;All$!&#123;tableInfo.name&#125;Column\&quot;&gt;$sqlCloumn&lt;/sql&gt;   \n    &lt;resultMap type=\&quot;$&#123;tableInfo.savePackageName&#125;.pojo.$!&#123;tableInfo.name&#125;\&quot; id=\&quot;$!&#123;tableInfo.name&#125;Map\&quot;&gt;\n##foreach($column in $tableInfo.fullColumn)\n        &lt;result property=\&quot;$!column.name\&quot; column=\&quot;$!column.obj.name\&quot; /&gt;\n##end\n    &lt;/resultMap&gt;\n    \n    \n\n&lt;/mapper&gt;\n&quot;
      &#125; ]
    &#125;
  &#125;,
  &quot;columnConfig&quot; : &#123; &#125;,
  &quot;globalConfig&quot; : &#123; &#125;
&#125;
</code></pre>
<h5 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h5><p>一定要选择你的Module、包路径、Path，因为它们分别对应的是你模板中的三个参数modulePath、tableInfo.savePackageName、我们所有的Save都是以Path的路径为根路径</p>
<img data-src="/2022/10/15/tools/IDEA-tool/image-20220823215323871-1665745616515.png" class="">


<h4 id="未完成"><a href="#未完成" class="headerlink" title="未完成"></a>未完成</h4><h2 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h2><h4 id="Service窗口"><a href="#Service窗口" class="headerlink" title="Service窗口"></a>Service窗口</h4><blockquote>
<p>在微服务项目中，我们在创建多个模块后，想要启动特定的几个寻找起来非常麻烦我们这个时候就可以通过Service窗口快速找到我们的启动类</p>
<img data-src="/2022/10/15/tools/IDEA-tool/image-20220724161332641.png" class="" title="image-20220724161332641">
</blockquote>
<h5 id="具体步骤-1"><a href="#具体步骤-1" class="headerlink" title="具体步骤"></a>具体步骤</h5><p>1：开启idea，右下角会显示下图</p>
<img data-src="/2022/10/15/tools/IDEA-tool/726e3c50b51442839ca357fa23bef649.png" class="">


<p>2、点击Show run configurations in Services</p>
<img data-src="/2022/10/15/tools/IDEA-tool/f90f6ac3965943209d1761bc12e3bd03.png" class="">


<p>最终效果图如下：</p>
<img data-src="/2022/10/15/tools/IDEA-tool/5649373054b74c3da30cc18febb3a01c.png" class="">


<h4 id="未完成-1"><a href="#未完成-1" class="headerlink" title="未完成"></a>未完成</h4>]]></content>
      <categories>
        <category>[object Object]</category>
      </categories>
  </entry>
  <entry>
    <title>Kafka</title>
    <url>/2022/10/15/tools/Kafka-tool/</url>
    <content><![CDATA[<h3 id="Kafka-安装"><a href="#Kafka-安装" class="headerlink" title="Kafka 安装"></a>Kafka 安装</h3><blockquote>
<p>安装前提，kafka安装运行最低支持jdk7；本篇演示版本是基于jdk1.8；</p>
</blockquote>
<p>官方下载地址：<span class="exturl" data-url="aHR0cHM6Ly9saW5rLnpoaWh1LmNvbS8/dGFyZ2V0PWh0dHA6Ly9rYWZrYS5hcGFjaGUub3JnL2Rvd25sb2Fkcw==">Apache Kafka</span></p>
<p>kafka 是由scala语言编写，下载稳定版本，即前一个版本</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/onlymarryu/typora-ims-test@master/img/v2-9f6503ade62cfa48df87cc9da984e87d_720w.jpg" alt="img"></p>
<p>点击进入后，按如下方式点击下载</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/onlymarryu/typora-ims-test@master/img/v2-bd19bea83d1cb978fbeed614ee126da6_720w.jpg" alt="img"></p>
<p>下载完成后进行解压缩</p>
<pre><code class="sh">tar -zxvf kafka_2.12-2.8.0.tgz 
mv kafka_2.12-2.8.0 /usr/local/kafka
</code></pre>
<p>解压完成后进入kafka目录</p>
<pre><code class="sh">cd /usr/local/kafka
</code></pre>
<p><img data-src="https://cdn.jsdelivr.net/gh/onlymarryu/typora-ims-test@master/v2-dfe360dfc7561953761f8ce69f782f4d_720w.png" alt="img"></p>
<p>kafka 是基于 Zookeeper 的消息管理系统，所以启动的时候是需要使用到 Zookeeper ，但其内置了Zookeeper ，所以只需要根据bin目录下的文件进行启动即可</p>
<p>启动Zookeeper 服务端命令</p>
<pre><code class="text">./bin/zookeeper-server-start.sh ./config/zookeeper.properties 
</code></pre>
<p>Zookeeper 启动成功后会出现 <code>binding to port 0.0.0.0/0.0.0.0:2181</code> 所示结果表示启动成功；</p>
<p><img data-src="https://pic1.zhimg.com/80/v2-6be2f91cd4ec47d589d3c5b58584c4b8_720w.png" alt="img"></p>
<p>启动kafka服务端命令</p>
<pre><code class="text"> ./bin/kafka-server-start.sh  ./config/server.properties
</code></pre>
]]></content>
      <categories>
        <category>工具软件安装</category>
      </categories>
  </entry>
  <entry>
    <title>Keepalived</title>
    <url>/2022/10/15/tools/Keepalived-tool/</url>
    <content><![CDATA[<h3 id="Keepalived安装"><a href="#Keepalived安装" class="headerlink" title="Keepalived安装"></a>Keepalived安装</h3><h4 id="——1"><a href="#——1" class="headerlink" title="——1"></a>——1</h4><h5 id="1、准备好Keepalived安装包"><a href="#1、准备好Keepalived安装包" class="headerlink" title="1、准备好Keepalived安装包"></a>1、准备好Keepalived安装包</h5><h5 id="2、解压到-x2F-usr-x2F-local目录"><a href="#2、解压到-x2F-usr-x2F-local目录" class="headerlink" title="2、解压到&#x2F;usr&#x2F;local目录"></a>2、解压到&#x2F;usr&#x2F;local目录</h5><pre><code class="shell">tar -zxvf /usr/local/tmp/keepalived-1.4.5.tar.gz -C /usr/local/
</code></pre>
<h5 id="3、安装需要依赖的环境组件"><a href="#3、安装需要依赖的环境组件" class="headerlink" title="3、安装需要依赖的环境组件"></a>3、安装需要依赖的环境组件</h5><pre><code class="shell">yum install gcc openssl-devel popt-devel -y
</code></pre>
<h5 id="4、进入到解压目录，进行编译"><a href="#4、进入到解压目录，进行编译" class="headerlink" title="4、进入到解压目录，进行编译"></a>4、进入到解压目录，进行编译</h5><pre><code>cd /usr/local/keepalived-1.4.5
./configure --prefix=/usr/local/keepalived	
</code></pre>
<h5 id="5、编译完成之后，进行安装"><a href="#5、编译完成之后，进行安装" class="headerlink" title="5、编译完成之后，进行安装"></a>5、编译完成之后，进行安装</h5><pre><code class="shell">make &amp;&amp; make install
</code></pre>
<h5 id="6、将keepalived的服务注册为系统服务"><a href="#6、将keepalived的服务注册为系统服务" class="headerlink" title="6、将keepalived的服务注册为系统服务"></a>6、将keepalived的服务注册为系统服务</h5><pre><code class="shell">cp  -rf   /usr/local/keepalived-1.4.5/keepalived/etc/init.d/keepalived /etc/init.d/
mkdir /etc/keepalived
cp   -rf  /usr/local/keepalived/etc/keepalived/keepalived.conf /etc/keepalived/
cp   -rf  /usr/local/keepalived-1.4.5/keepalived/etc/sysconfig/keepalived /etc/sysconfig/
cp   -rf  /usr/local/keepalived/sbin/keepalived /usr/sbin/
</code></pre>
<h5 id="7、修改配置文件"><a href="#7、修改配置文件" class="headerlink" title="7、修改配置文件"></a>7、修改配置文件</h5><pre><code class="shell">vim  /etc/keepalived/keepalived.conf
</code></pre>
<p><strong>CentOS-6   下的配置文件</strong></p>
<pre><code class="shell">! Configuration File for keepalived
global_defs &#123;
   notification_email &#123;
     acassen@firewall.loc
     failover@firewall.loc
     sysadmin@firewall.loc
   &#125;
   notification_email_from Alexandre.Cassen@firewall.loc
   smtp_server 127.0.0.1
   smtp_connect_timeout 30
   router_id LVS_DEVEL
   vrrp_skip_check_adv_addr
   vrrp_garp_interval 0
   vrrp_gna_interval 0
&#125;

vrrp_instance VI_1 &#123;
##	# 配置为主
    state MASTER
#    # 设置网卡
    interface eth0
#     # 虚拟路由ID，全局唯一
    virtual_router_id 51
#    # 优先级，权重值
    priority 100
    advert_int 1
    authentication &#123;
        auth_type PASS
        auth_pass 1111
    &#125;
    virtual_ipaddress &#123;
         192.168.1.100/24  dev eth0 label eth0:3:
    &#125;
&#125;
</code></pre>
<p><strong>CentOS-7   下的配置文件</strong></p>
<pre><code class="conf">! Configuration File for keepalived
global_defs &#123;
   notification_email &#123;
     acassen@firewall.loc
     failover@firewall.loc
     sysadmin@firewall.loc
   &#125;
   notification_email_from Alexandre.Cassen@firewall.loc
   smtp_server 127.0.0.1
   smtp_connect_timeout 30
   router_id LVS_DEVEL
   vrrp_skip_check_adv_addr
   vrrp_garp_interval 0
   vrrp_gna_interval 0
&#125;

vrrp_instance VI_1 &#123;
##	# 配置为主
    state MASTER
#    # 设置网卡
    interface ens33
#     # 虚拟路由ID，全局唯一
    virtual_router_id 51
#    # 优先级，权重值
    priority 100
    advert_int 1
    authentication &#123;
        auth_type PASS
        auth_pass 1111
    &#125;
    virtual_ipaddress &#123;
        192.168.1.100/24 
    &#125;
&#125;
</code></pre>
<h6 id="8、启动keepalived"><a href="#8、启动keepalived" class="headerlink" title="8、启动keepalived"></a>8、启动keepalived</h6><pre><code class="shell">service keepalived start
###或者
systemctl start keepalived.service
</code></pre>
<h6 id="9、登录验证"><a href="#9、登录验证" class="headerlink" title="9、登录验证"></a>9、登录验证</h6><pre><code class="shell">mysql -uroot -p123456 -h 192.168.1.100 -P 48066
</code></pre>
]]></content>
      <categories>
        <category>工具软件安装</category>
      </categories>
  </entry>
  <entry>
    <title>Maven-tool</title>
    <url>/2022/10/15/tools/Maven-tool/</url>
    <content><![CDATA[<h3 id="Maven-安装"><a href="#Maven-安装" class="headerlink" title="Maven 安装"></a>Maven 安装</h3><blockquote>
<p>要是新版本 <code>IDEA</code> 则不需要修改 <code>Maven</code> , <code>IDEA</code>中默认整合了 <code>Maven</code>，只不过是版本问题</p>
</blockquote>
<img data-src="/2022/10/15/tools/Maven-tool/image-20220513150641401.png" class="">




<h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>下载地址： <span class="exturl" data-url="aHR0cDovL21hdmVuLmFwYWNoZS5vcmcv">http://maven.apache.org/</span></p>
<img data-src="/2022/10/15/tools/Maven-tool/image-20220513150648442.png" class="">


<img data-src="/2022/10/15/tools/Maven-tool/image-20220513150655417.png" class="">




<p>目录结构：</p>
<img data-src="/2022/10/15/tools/Maven-tool/image-20220513150703248.png" class="">



<p>bin：存放的是执行文件，命令<br>在IDEA中可以直接集成Maven:</p>
<img data-src="/2022/10/15/tools/Maven-tool/image-20220513150710943.png" class="">



<p>conf目录：下面有一个非常重要的配置文件–》settings.xml—》maven的核心配置文件&#x2F;全局配置文件。</p>
<div name=".m2_create">

<blockquote>
<p><strong>注：</strong>如果没有 <code>.m2</code> 目录 ，自己手动执行mvn命令：</p>
</blockquote>
<pre><code>mvn help:system
</code></pre>
<h4 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h4><p>默认的远程仓库使用的Apache提供的中央仓库：<br><span class="exturl" data-url="aHR0cHM6Ly9tdm5yZXBvc2l0b3J5LmNvbS8=">https://mvnrepository.com/</span></p>
<h4 id="仓库配置"><a href="#仓库配置" class="headerlink" title="仓库配置"></a>仓库配置</h4><p>#修改 <a href="#.m2_create">.m2&#x2F;settings.xm（没有就戳我！！！！）</a></p>
<blockquote>
<p>一般都在本地：C:\Users\Lenovo\.m2\settings.xml</p>
</blockquote>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;

&lt;!--
Licensed to the Apache Software Foundation (ASF) under one
or more contributor license agreements.  See the NOTICE file
distributed with this work for additional information
regarding copyright ownership.  The ASF licenses this file
to you under the Apache License, Version 2.0 (the
&quot;License&quot;); you may not use this file except in compliance
with the License.  You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing,
software distributed under the License is distributed on an
&quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, either express or implied.  See the License for the
specific language governing permissions and limitations
under the License.
--&gt;

&lt;!--
 | This is the configuration file for Maven. It can be specified at two levels:
 |
 |  1. User Level. This settings.xml file provides configuration for a single user,
 |                 and is normally provided in $&#123;user.home&#125;/.m2/settings.xml.
 |
 |                 NOTE: This location can be overridden with the CLI option:
 |
 |                 -s /path/to/user/settings.xml
 |
 |  2. Global Level. This settings.xml file provides configuration for all Maven
 |                 users on a machine (assuming they&#39;re all using the same Maven
 |                 installation). It&#39;s normally provided in
 |                 $&#123;maven.home&#125;/conf/settings.xml.
 |
 |                 NOTE: This location can be overridden with the CLI option:
 |
 |                 -gs /path/to/global/settings.xml
 |
 | The sections in this sample file are intended to give you a running start at
 | getting the most out of your Maven installation. Where appropriate, the default
 | values (values used when the setting is not specified) are provided.
 |
 |--&gt;
&lt;settings xmlns=&quot;http://maven.apache.org/SETTINGS/1.0.0&quot; 
          xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; 
          xsi:schemaLocation=&quot;http://maven.apache.org/SETTINGS/1.0.0 http://maven.apache.org/xsd/settings-1.0.0.xsd&quot;
          
          &gt;
  &lt;!-- localRepository
   | The path to the local repository maven will use to store artifacts.
   |
   | Default: $&#123;user.home&#125;/.m2/repository
  &lt;localRepository&gt;/path/to/local/repo&lt;/localRepository&gt;
  --&gt;
   &lt;!--Maven 本地仓库--&gt;
  &lt;localRepository&gt;D:\_Porgram_IT\maven-repository&lt;/localRepository&gt;
  
  &lt;!-- interactiveMode
   | This will determine whether maven prompts you when it needs input. If set to false,
   | maven will use a sensible default value, perhaps based on some other setting, for
   | the parameter in question.
   |
   | Default: true
  &lt;interactiveMode&gt;true&lt;/interactiveMode&gt;
  --&gt;

  &lt;!-- offline
   | Determines whether maven should attempt to connect to the network when executing a build.
   | This will have an effect on artifact downloads, artifact deployment, and others.
   |
   | Default: false
  &lt;offline&gt;false&lt;/offline&gt;
  --&gt;

  &lt;!-- pluginGroups
   | This is a list of additional group identifiers that will be searched when resolving plugins by their prefix, i.e.
   | when invoking a command line like &quot;mvn prefix:goal&quot;. Maven will automatically add the group identifiers
   | &quot;org.apache.maven.plugins&quot; and &quot;org.codehaus.mojo&quot; if these are not already contained in the list.
   |--&gt;
  &lt;pluginGroups&gt;
    &lt;!-- pluginGroup
     | Specifies a further group identifier to use for plugin lookup.
    &lt;pluginGroup&gt;com.your.plugins&lt;/pluginGroup&gt;
    --&gt;
  &lt;/pluginGroups&gt;

  &lt;!-- proxies
   | This is a list of proxies which can be used on this machine to connect to the network.
   | Unless otherwise specified (by system property or command-line switch), the first proxy
   | specification in this list marked as active will be used.
   |--&gt;
  &lt;proxies&gt;
    &lt;!-- proxy
     | Specification for one proxy, to be used in connecting to the network.
     |
    &lt;proxy&gt;
      &lt;id&gt;optional&lt;/id&gt;
      &lt;active&gt;true&lt;/active&gt;
      &lt;protocol&gt;http&lt;/protocol&gt;
      &lt;username&gt;proxyuser&lt;/username&gt;
      &lt;password&gt;proxypass&lt;/password&gt;
      &lt;host&gt;proxy.host.net&lt;/host&gt;
      &lt;port&gt;80&lt;/port&gt;
      &lt;nonProxyHosts&gt;local.net|some.host.com&lt;/nonProxyHosts&gt;
    &lt;/proxy&gt;
    --&gt;
  &lt;/proxies&gt;

  &lt;!-- servers
   | This is a list of authentication profiles, keyed by the server-id used within the system.
   | Authentication profiles can be used whenever maven must make a connection to a remote server.
   |--&gt;
   &lt;servers&gt;
    &lt;!-- server
     | Specifies the authentication information to use when connecting to a particular server, identified by
     | a unique name within the system (referred to by the &#39;id&#39; attribute below).
     |
     | NOTE: You should either specify username/password OR privateKey/passphrase, since these pairings are
     |       used together.
     |
    &lt;server&gt;
      &lt;id&gt;deploymentRepo&lt;/id&gt;
      &lt;username&gt;repouser&lt;/username&gt;
      &lt;password&gt;repopwd&lt;/password&gt;
    &lt;/server&gt;
    --&gt;

    &lt;!-- Another sample, using keys to authenticate.
    &lt;server&gt;
      &lt;id&gt;siteServer&lt;/id&gt;
      &lt;privateKey&gt;/path/to/private/key&lt;/privateKey&gt;
      &lt;passphrase&gt;optional; leave empty if not used.&lt;/passphrase&gt;
    &lt;/server&gt;
    --&gt;
  &lt;/servers&gt;

  &lt;!-- mirrors
   | This is a list of mirrors to be used in downloading artifacts from remote repositories.
   |
   | It works like this: a POM may declare a repository to use in resolving certain artifacts.
   | However, this repository may have problems with heavy traffic at times, so people have mirrored
   | it to several places.
   |
   | That repository definition will have a unique id, so we can create a mirror reference for that
   | repository, to be used as an alternate download site. The mirror site will be the preferred
   | server for that repository.
   |--&gt;
  &lt;mirrors&gt;
    &lt;mirror&gt; 
        &lt;!-- 指定镜像ID（可自己改名） --&gt;
        &lt;id&gt;nexus-aliyun&lt;/id&gt; 
        &lt;!-- 匹配中央仓库（阿里云的仓库名称，不可以自己起名，必须这么写）--&gt;
        &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;
        &lt;!-- 指定镜像名称（可自己改名）  --&gt;   
        &lt;name&gt;Nexus aliyun&lt;/name&gt; 
        &lt;!-- 指定镜像路径（镜像地址） --&gt;
        &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public&lt;/url&gt; 
    &lt;/mirror&gt;
    
    &lt;mirror&gt;  
      &lt;id&gt;alimaven&lt;/id&gt;  
      &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;  
      &lt;name&gt;aliyun maven&lt;/name&gt;  
      &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt;  
    &lt;/mirror&gt;
    &lt;!-- mirror
     | Specifies a repository mirror site to use instead of a given repository. The repository that
     | this mirror serves has an ID that matches the mirrorOf element of this mirror. IDs are used
     | for inheritance and direct lookup purposes, and must be unique across the set of mirrors.
     |
    &lt;mirror&gt;
      &lt;id&gt;mirrorId&lt;/id&gt;
      &lt;mirrorOf&gt;repositoryId&lt;/mirrorOf&gt;
      &lt;name&gt;Human Readable Name for this Mirror.&lt;/name&gt;
      &lt;url&gt;http://my.repository.com/repo/path&lt;/url&gt;
    &lt;/mirror&gt;
     --&gt;
     
  &lt;/mirrors&gt;

  &lt;!-- profiles
   | This is a list of profiles which can be activated in a variety of ways, and which can modify
   | the build process. Profiles provided in the settings.xml are intended to provide local machine-
   | specific paths and repository locations which allow the build to work in the local environment.
   |
   | For example, if you have an integration testing plugin - like cactus - that needs to know where
   | your Tomcat instance is installed, you can provide a variable here such that the variable is
   | dereferenced during the build process to configure the cactus plugin.
   |
   | As noted above, profiles can be activated in a variety of ways. One way - the activeProfiles
   | section of this document (settings.xml) - will be discussed later. Another way essentially
   | relies on the detection of a system property, either matching a particular value for the property,
   | or merely testing its existence. Profiles can also be activated by JDK version prefix, where a
   | value of &#39;1.4&#39; might activate a profile when the build is executed on a JDK version of &#39;1.4.2_07&#39;.
   | Finally, the list of active profiles can be specified directly from the command line.
   |
   | NOTE: For profiles defined in the settings.xml, you are restricted to specifying only artifact
   |       repositories, plugin repositories, and free-form properties to be used as configuration
   |       variables for plugins in the POM.
   |
   |--&gt;
  &lt;profiles&gt;
    &lt;profile&gt;
      &lt;id&gt;jdk-1.8&lt;/id&gt;
      &lt;activation&gt;
        &lt;activeByDefault&gt;true&lt;/activeByDefault&gt;
        &lt;jdk&gt;1.8&lt;/jdk&gt;
      &lt;/activation&gt;
      &lt;properties&gt;
        &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt;
        &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt;
        &lt;maven.compiler.compilerVersion&gt;1.8&lt;/maven.compiler.compilerVersion&gt;
      &lt;/properties&gt;
    &lt;/profile&gt;

    &lt;!-- profile
     | Specifies a set of introductions to the build process, to be activated using one or more of the
     | mechanisms described above. For inheritance purposes, and to activate profiles via &lt;activatedProfiles/&gt;
     | or the command line, profiles have to have an ID that is unique.
     |
     | An encouraged best practice for profile identification is to use a consistent naming convention
     | for profiles, such as &#39;env-dev&#39;, &#39;env-test&#39;, &#39;env-production&#39;, &#39;user-jdcasey&#39;, &#39;user-brett&#39;, etc.
     | This will make it more intuitive to understand what the set of introduced profiles is attempting
     | to accomplish, particularly when you only have a list of profile id&#39;s for debug.
     |
     | This profile example uses the JDK version to trigger activation, and provides a JDK-specific repo.
    &lt;profile&gt;
      &lt;id&gt;jdk-1.4&lt;/id&gt;

      &lt;activation&gt;
        &lt;jdk&gt;1.4&lt;/jdk&gt;
      &lt;/activation&gt;

      &lt;repositories&gt;
        &lt;repository&gt;
          &lt;id&gt;jdk14&lt;/id&gt;
          &lt;name&gt;Repository for JDK 1.4 builds&lt;/name&gt;
          &lt;url&gt;http://www.myhost.com/maven/jdk14&lt;/url&gt;
          &lt;layout&gt;default&lt;/layout&gt;
          &lt;snapshotPolicy&gt;always&lt;/snapshotPolicy&gt;
        &lt;/repository&gt;
      &lt;/repositories&gt;
    &lt;/profile&gt;
    --&gt;

    &lt;!--
     | Here is another profile, activated by the system property &#39;target-env&#39; with a value of &#39;dev&#39;,
     | which provides a specific path to the Tomcat instance. To use this, your plugin configuration
     | might hypothetically look like:
     |
     | ...
     | &lt;plugin&gt;
     |   &lt;groupId&gt;org.myco.myplugins&lt;/groupId&gt;
     |   &lt;artifactId&gt;myplugin&lt;/artifactId&gt;
     |
     |   &lt;configuration&gt;
     |     &lt;tomcatLocation&gt;$&#123;tomcatPath&#125;&lt;/tomcatLocation&gt;
     |   &lt;/configuration&gt;
     | &lt;/plugin&gt;
     | ...
     |
     | NOTE: If you just wanted to inject this configuration whenever someone set &#39;target-env&#39; to
     |       anything, you could just leave off the &lt;value/&gt; inside the activation-property.
     |
    &lt;profile&gt;
      &lt;id&gt;env-dev&lt;/id&gt;

      &lt;activation&gt;
        &lt;property&gt;
          &lt;name&gt;target-env&lt;/name&gt;
          &lt;value&gt;dev&lt;/value&gt;
        &lt;/property&gt;
      &lt;/activation&gt;

      &lt;properties&gt;
        &lt;tomcatPath&gt;/path/to/tomcat/instance&lt;/tomcatPath&gt;
      &lt;/properties&gt;
    &lt;/profile&gt;
    --&gt;
  &lt;/profiles&gt;

  &lt;!-- activeProfiles
   | List of profiles that are active for all builds.
   |
  &lt;activeProfiles&gt;
    &lt;activeProfile&gt;alwaysActiveProfile&lt;/activeProfile&gt;
    &lt;activeProfile&gt;anotherAlwaysActiveProfile&lt;/activeProfile&gt;
  &lt;/activeProfiles&gt;
  --&gt;
&lt;/settings&gt;
</code></pre>
]]></content>
      <categories>
        <category>工具软件安装</category>
      </categories>
  </entry>
  <entry>
    <title>MyCat</title>
    <url>/2022/10/15/tools/MyCat-tool/</url>
    <content><![CDATA[<h2 id="MyCat（Linux）"><a href="#MyCat（Linux）" class="headerlink" title="MyCat（Linux）"></a>MyCat（Linux）</h2><h3 id="Server安装"><a href="#Server安装" class="headerlink" title="(Server安装)"></a>(Server安装)</h3><ul>
<li>前提：</li>
</ul>
<p>#* 1、<a href="#jdk_install">jdk安装</a></p>
<p>#* 2、<a href="#mysql_install">mysql安装</a></p>
<ul>
<li><p>官网：<span class="exturl" data-url="aHR0cDovL3d3dy5teWNhdC5vcmcuY24v">http://www.mycat.org.cn/</span></p>
</li>
<li><p>首先准备四台虚拟机，安装好mysql，方便后续做读写分离和主从复制。**(3.3内容)**</p>
<pre><code class="shell">192.168.85.45 node01
192.168.85.46 node02
192.168.85.47 node03
192.168.85.48 node04
</code></pre>
</li>
</ul>
<h4 id="1、下载MyCat"><a href="#1、下载MyCat" class="headerlink" title="1、下载MyCat"></a>1、下载MyCat</h4><p><span class="exturl" data-url="aHR0cDovL2RsLm15Y2F0Lm9yZy5jbi8xLjYuNy42LzIwMjEwOTMwMjEzMDQ5L015Y2F0LXNlcnZlci0xLjYuNy42LXJlbGVhc2UtMjAyMTA5MzAyMTMwNDktbGludXgudGFyLmd6">http://dl.mycat.org.cn/1.6.7.6/20210930213049/Mycat-server-1.6.7.6-release-20210930213049-linux.tar.gz</span></p>
<pre><code class="shell">windows下载安装包
</code></pre>
<h4 id="2、上传并解压压缩文件"><a href="#2、上传并解压压缩文件" class="headerlink" title="2、上传并解压压缩文件"></a>2、上传并解压压缩文件</h4><pre><code class="shell"> tar -zxvf Mycat-server-1.6.7.5-release-20200422133810-linux.tar.gz -C /usr/local/ 
</code></pre>
<h4 id="3、修改配置"><a href="#3、修改配置" class="headerlink" title="3、修改配置"></a>3、修改配置</h4><p>0、配置环境变量（可选）</p>
<pre><code class="shell">vim /etc/profile
### 添加如下配置信息：
export MYCAT_HOME=/usr/local/mycat
export PATH=$MYCAT_HOME/bin:$PATH:$JAVA_HOME/bin

### 生效
source /etc/profile
</code></pre>
<p><strong>修改server.xml schema.xml之前先备份</strong></p>
<pre><code class="shell">cd /usr/local/mycat

cd conf

cp server.xml server.xml.list
cp schema.xml schema.xml.list
</code></pre>
<p>1、修改完成后的  <strong>server.xml</strong></p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!-- - - Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); 
        - you may not use this file except in compliance with the License. - You 
        may obtain a copy of the License at - - http://www.apache.org/licenses/LICENSE-2.0 
        - - Unless required by applicable law or agreed to in writing, software - 
        distributed under the License is distributed on an &quot;AS IS&quot; BASIS, - WITHOUT 
        WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. - See the 
        License for the specific language governing permissions and - limitations 
        under the License. --&gt;
&lt;!DOCTYPE mycat:server SYSTEM &quot;server.dtd&quot;&gt;
&lt;mycat:server xmlns:mycat=&quot;http://io.mycat/&quot;&gt;
        &lt;user name=&quot;root&quot; defaultAccount=&quot;true&quot;&gt;
                &lt;property name=&quot;password&quot;&gt;root&lt;/property&gt;
                &lt;property name=&quot;schemas&quot;&gt;TESTDB&lt;/property&gt;
                &lt;property name=&quot;defaultSchema&quot;&gt;TESTDB&lt;/property&gt;
        &lt;/user&gt;
&lt;/mycat:server&gt;
</code></pre>
<p>2、修改完成后的 schema.xml</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;!DOCTYPE mycat:schema SYSTEM &quot;schema.dtd&quot;&gt;
&lt;mycat:schema xmlns:mycat=&quot;http://io.mycat/&quot;&gt;
        &lt;schema name=&quot;TESTDB&quot; checkSQLschema=&quot;false&quot; sqlMaxLimit=&quot;100&quot; dataNode=&quot;dn1&quot;&gt;
        &lt;/schema&gt;
        &lt;dataNode name=&quot;dn1&quot; dataHost=&quot;host1&quot; database=&quot;msb&quot; /&gt;
        &lt;dataHost name=&quot;host1&quot; maxCon=&quot;1000&quot; minCon=&quot;10&quot; balance=&quot;0&quot;
                          writeType=&quot;0&quot; dbType=&quot;mysql&quot; dbDriver=&quot;native&quot; switchType=&quot;1&quot;  slaveThreshold=&quot;100&quot;&gt;
                &lt;heartbeat&gt;select user()&lt;/heartbeat&gt;
                &lt;writeHost host=&quot;hostM1&quot; url=&quot;192.168.1.45:3306&quot; user=&quot;root&quot;
                                   password=&quot;root&quot;&gt;
                         &lt;readHost host=&quot;hostS1&quot; url=&quot;192.168.1.46:3306&quot; user=&quot;root&quot; password=&quot;root&quot;&gt;&lt;/readHost&gt;
                &lt;/writeHost&gt;
        &lt;/dataHost&gt;
&lt;/mycat:schema&gt;
</code></pre>
<p>3、修改 <strong>hosts</strong>  文件</p>
<pre><code class="shell">vim /etc/hosts

###添加
###ip name
192.168.1.164 node01
</code></pre>
<h4 id="4、启动mycat"><a href="#4、启动mycat" class="headerlink" title="4、启动mycat"></a>4、启动mycat</h4><p>​		mycat的启动有两种方式，一种是控制台启动，一种是后台启动，在初学的时候建议大家使用控制台启动的方式，当配置文件写错之后，可以方便的看到错误，及时修改，但是在生产环境中，使用后台启动的方式比较稳妥。</p>
<p>​		<strong>控制台启动：</strong></p>
<pre><code class="shell">cd /usrlocal/mycat/bin
./mycat console

###加入环境变量后可直接启动
mycat console
</code></pre>
<p>​		<strong>后台启动：</strong></p>
<pre><code class="shell">cd /usrlocal/mycat/bin
./mycat start

###加入环境变量后可直接启动
mycat start
</code></pre>
<p>​		按照如上配置在安装的时候应该不会报错，如果出现错误，根据错误的提示解决即可。</p>
<h4 id="5、登录验证"><a href="#5、登录验证" class="headerlink" title="5、登录验证"></a>5、登录验证</h4><p>​		<strong>管理窗口的登录</strong></p>
<p>​		从另外的虚拟机去登录访问当前mycat，输入如下命令即可</p>
<pre><code>mysql -uroot -proot -P 9066 -h ip
</code></pre>
<p>​		此时访问的是mycat的管理窗口，可以通过show @@help查看可以执行的命令</p>
<p>​		<strong>数据窗口的登录</strong></p>
<p>​		从另外的虚拟机去登录访问mycat，输入命令如下：【用户设置】</p>
<pre><code>mysql -uroot -proot -P8066 -h ip
</code></pre>
<p>​		当都能够成功的时候以为着mycat已经搭建完成。</p>
<h3 id="mycat-web"><a href="#mycat-web" class="headerlink" title="mycat-web"></a>mycat-web</h3><h4 id="——1"><a href="#——1" class="headerlink" title="——1"></a>——1</h4><h5 id="1、下载mycat-web安装包"><a href="#1、下载mycat-web安装包" class="headerlink" title="1、下载mycat-web安装包"></a>1、下载mycat-web安装包</h5><p>​	官方地址：<span class="exturl" data-url="aHR0cDovL2RsLm15Y2F0Lm9yZy5jbi8=">http://dl.mycat.org.cn/</span></p>
<h5 id="2、解压安装包到-x2F-usr-x2F-local目录"><a href="#2、解压安装包到-x2F-usr-x2F-local目录" class="headerlink" title="2、解压安装包到&#x2F;usr&#x2F;local目录"></a>2、解压安装包到&#x2F;usr&#x2F;local目录</h5><pre><code class="shell">tar -zxvf Mycat-web-1.0-SNAPSHOT-20170102153329-linux.tar.gz -C /usr/local/
</code></pre>
<h4 id="3、进入mycat-web的目录运行启动命令"><a href="#3、进入mycat-web的目录运行启动命令" class="headerlink" title="3、进入mycat-web的目录运行启动命令"></a>3、进入mycat-web的目录运行启动命令</h4><pre><code class="shell">    ./start.sh &amp;
</code></pre>
<h4 id="4、mycat-web的服务端口是8082，查看服务是否启动"><a href="#4、mycat-web的服务端口是8082，查看服务是否启动" class="headerlink" title="4、mycat-web的服务端口是8082，查看服务是否启动"></a>4、mycat-web的服务端口是8082，查看服务是否启动</h4><pre><code class="shell">    netstat -nlpt | grep 8082
</code></pre>
<h4 id="5、通过地址访问服务"><a href="#5、通过地址访问服务" class="headerlink" title="5、通过地址访问服务"></a>5、通过地址访问服务</h4><pre><code class="shell">    192.168.1.164:8082/mycat/
</code></pre>
<h4 id="6、mycat-web配置"><a href="#6、mycat-web配置" class="headerlink" title="6、mycat-web配置"></a>6、mycat-web配置</h4><h5 id="6-1、配置zookeeper-可选"><a href="#6-1、配置zookeeper-可选" class="headerlink" title="6.1、配置zookeeper(可选)"></a>6.1、配置zookeeper(可选)</h5><pre><code class="shell">cd /usr/local/mycat-web/mycat-web/WEB-INF/classes

###修改mycat.properties文件，可以修改zookeeper的地址
vim mycat.properties
</code></pre>
<h5 id="6-2、添加mycat实例"><a href="#6-2、添加mycat实例" class="headerlink" title="6.2、添加mycat实例"></a>6.2、添加mycat实例</h5><pre><code>* 在页面的mycat配置

* mycat服务管理中添加mycat实例，需要填写相关的参数
</code></pre>
]]></content>
      <categories>
        <category>工具软件安装</category>
      </categories>
  </entry>
  <entry>
    <title>MySQL</title>
    <url>/2022/10/15/tools/MySQL-tool/</url>
    <content><![CDATA[<h3 id="MySQL安装（Windows）"><a href="#MySQL安装（Windows）" class="headerlink" title="MySQL安装（Windows）"></a>MySQL安装（Windows）</h3><h4 id="【1】MySQL的版本："><a href="#【1】MySQL的版本：" class="headerlink" title="【1】MySQL的版本："></a>【1】MySQL的版本：</h4><p>近期主要历史版本有5.0&#x2F;5.1&#x2F;5.5&#x2F;5.6&#x2F;5.7，目前最新版本是MySQL8。6.0曾经是个内部试验版本，已取消了。</p>
<p>MySQL8.0的版本历史</p>
<ol>
<li>2016-09-12第一个DM(development milestone)版本8.0.0发布</li>
<li>2018-04-19第一个GA(General Availability)版本开始，8.0.11发布</li>
<li>2018-07-27 8.0.12GA发布</li>
<li>2018-10-22 8.0.13GA发布</li>
<li>2019-01-21 8.0.14GA发布</li>
<li>2019-02-01 8.0.15GA发布</li>
<li>最新的版本是8.0.18,2019年10月14日正式发布</li>
<li>….后续更新</li>
</ol>
<h4 id="【2】官方下载地址："><a href="#【2】官方下载地址：" class="headerlink" title="【2】官方下载地址："></a>【2】官方下载地址：</h4><p><span class="exturl" data-url="aHR0cHM6Ly9kZXYubXlzcWwuY29tL2Rvd25sb2Fkcy93aW5kb3dzL2luc3RhbGxlci84LjAuaHRtbA==">https://dev.mysql.com/downloads/windows/installer/8.0.html</span></p>
<img data-src="/2022/10/15/tools/MySQL-tool/1646193598821.png" class="">




<h4 id="【3】安装过程："><a href="#【3】安装过程：" class="headerlink" title="【3】安装过程："></a>【3】安装过程：</h4><p><strong>1.双击MySQL安装文件mysql-installer-community-8.0.18.0.msi，出现安装类型选项。</strong></p>
<ul>
<li><p>Developer Default：开发者默认</p>
</li>
<li><p>Server only：只安装服务器端 </p>
</li>
<li><p>Client only：只安装客户端</p>
</li>
<li><p>Full：安装全部选项</p>
</li>
<li><p>Custom：自定义安装</p>
</li>
</ul>
<img data-src="/2022/10/15/tools/MySQL-tool/1646193860553.png" class="">


<p><strong>2.选择，然后继续：</strong></p>
<img data-src="/2022/10/15/tools/MySQL-tool/1646193913998.png" class="">


<p><strong>3.进入产品配置向导，配置多个安装细节，点击Next按钮即可。</strong></p>
<img data-src="/2022/10/15/tools/MySQL-tool/1646193920702.png" class="">


<p><strong>4.高可靠性High Availability，采用默认选项即可。</strong></p>
<ul>
<li><p>Standalone MySQL Server&#x2F;Classic MySQL Replication:独立MySQL服务器&#x2F;经典MySQL复制</p>
</li>
<li><p>InnoDB Cluster:InnoDB集群</p>
</li>
</ul>
<img data-src="/2022/10/15/tools/MySQL-tool/1646193926612.png" class="">


<p><strong>5.类型和网络 Type and Networking，采用默认选项即可。记住MySQL的监听端口默认是3306。</strong></p>
<img data-src="/2022/10/15/tools/MySQL-tool/1646193950590.png" class="">


<p><strong>6.身份验证方法Authentication Method，采用默认选项即可。</strong></p>
 <img data-src="/2022/10/15/tools/MySQL-tool/1646193956569.png" class="" width="1646193956569">

<p><strong>7.账户和角色 Accounts and Roles。MySQL管理员账户名称是root，在此处指定root用户的密码。还可以在此处通过Add User按钮添加其他新账户，此处省略该操作。</strong></p>
<img data-src="/2022/10/15/tools/MySQL-tool/1646193968510.png" class="">


<p><strong>8.Windows服务：Windows Service。</strong></p>
<ul>
<li><p>Configure MySQL Server as a Windows Service:给MySQL服务器配置一个服务项。</p>
</li>
<li><p>Windows Service Name:服务名称，采用默认名称MySQL80即可。</p>
</li>
<li><p>Start the MySQL at System Startup：系统启动时开启MySQL服务</p>
</li>
</ul>
<img data-src="/2022/10/15/tools/MySQL-tool/1646193985805.png" class="">






<p><strong>9.Apply Configuration：点击Execute按钮执行开始应用这些配置项。</strong></p>
<ul>
<li><p>Writing configuration file: 写配置文件。</p>
</li>
<li><p>Updating Windows Firewall rules：更新Windows防火墙规则</p>
</li>
<li><p>Adjusting Windows services：调整Windows服务</p>
</li>
<li><p>Initializing database：初始化数据库</p>
</li>
<li><p>Starting the server： 启动服务器</p>
</li>
<li><p>Applying security setting：应用安全设置</p>
</li>
<li><p>Updating the Start menu link：更新开始菜单快捷方式链接</p>
</li>
</ul>
<img data-src="/2022/10/15/tools/MySQL-tool/1646194015388.png" class="">


<p><strong>PS：如果配置出错，查看右侧的log，查看对应错误信息。</strong><br><strong>执行完成后，如下图所示。单击Finish完成安装，进入产品配置环节。</strong></p>
<img data-src="/2022/10/15/tools/MySQL-tool/1646194023800.png" class="">


<p><strong>10.产品配置Product Configuration到此结束：点击Next按钮。</strong></p>
<img data-src="/2022/10/15/tools/MySQL-tool/1646194031356.png" class="">


<p><strong>11.安装完成 Installation Complete。点击Finish按钮完成安装。</strong></p>
<img data-src="/2022/10/15/tools/MySQL-tool/1646194038230.png" class="">




<h4 id="【4】MySQL配置、登录"><a href="#【4】MySQL配置、登录" class="headerlink" title="【4】MySQL配置、登录"></a>【4】MySQL配置、登录</h4><p><strong>【1】登录：</strong><br>访问MySQL服务器对应的命令：mysql.exe ,位置：C:\Program Files\MySQL\MySQL Server 8.0\bin</p>
<img data-src="/2022/10/15/tools/MySQL-tool/1646194179663.png" class="">




<p>（mysql.exe需要带参数执行，所以直接在图形界面下执行该命令会自动结束）</p>
<p>打开控制命令台：win+r:</p>
<img data-src="/2022/10/15/tools/MySQL-tool/1646194204312.png" class="">


<p>执行mysql.exe命令的时候出现错误：</p>
<img data-src="/2022/10/15/tools/MySQL-tool/1646194212295.png" class="">


<p>需要配置环境变量path:</p>
<img data-src="/2022/10/15/tools/MySQL-tool/1646194221073.png" class="">


<p><strong>注意：控制命令台必须重启才会生效：</strong></p>
<p><strong>登录的命令：mysql  -hlocalhost -uroot –p</strong></p>
<ul>
<li><p>mysql：bin目录下的文件mysql.exe。mysql是MySQL的命令行工具，是一个客户端软件，可以对任何主机的mysql服务（即后台运行的mysqld）发起连接。</p>
</li>
<li><p>-h：host主机名。后面跟要访问的数据库服务器的地址；<strong>如果是登录本机，可以省略</strong></p>
</li>
<li><p>-u：user 用户名。后面跟登录数据的用户名，第一次安装后以root用户来登录，是MySQL的管理员用户</p>
</li>
<li><p>-p:   password 密码。一般不直接输入，而是回车后以保密方式输入。 </p>
  <img data-src="/2022/10/15/tools/MySQL-tool/1646194262329.png" class="" width="1646194262329"></li>
</ul>
<p><strong>【2】访问数据库</strong></p>
<p>显示MySQL中的数据库列表：</p>
<pre><code class="shell">show databases;
</code></pre>
<p> 默认有四个自带的数据库，每个数据库中可以有多个数据库表、视图等对象。</p>
<p>切换当前数据库的命令：</p>
<pre><code class="shell">use mysql;
</code></pre>
<ul>
<li><p>MySQL下可以有多个数据库，如果要访问哪个数据库，需要将其置为当前数据库。</p>
</li>
<li><p>该命令的作用就是将数据库mysql（默认提供的四个数据库之一的名字）置为当前数据库</p>
</li>
</ul>
<p>显示当前数据库的所有数据库表：</p>
<pre><code class="shell">show tables;
</code></pre>
<p>MySQL 层次：不同项目对应不同的数据库组成 - 每个数据库中有很多表  - 每个表中有很多数据</p>
<p><strong>【3】退出数据库</strong></p>
<p>退出数据库可以使用quit或者exit命令完成，也可以用\q;  完成退出操作</p>
<img data-src="/2022/10/15/tools/MySQL-tool/1646194349092.png" class="">






<h4 id="【5】卸载"><a href="#【5】卸载" class="headerlink" title="【5】卸载"></a>【5】卸载</h4><p><strong>1)停止MySQL服务：在命令行模式下执行net stop mysql或者在Windows服务窗口下停止服务</strong></p>
<img data-src="/2022/10/15/tools/MySQL-tool/1646194422719.png" class="">


<p><strong>2)在控制面板中删除MySQL软件</strong></p>
<img data-src="/2022/10/15/tools/MySQL-tool/1646194431091.png" class="">


<p><strong>3)删除软件文件夹：直接删除安装文件夹C:\Program Files\MySQL，其实此时该文件夹已经被删除或者剩下一个空文件夹。</strong></p>
<p><strong>4)删除数据文件夹：直接删除文件夹C:\ProgramData\MySQL。此步不要忘记，否则会影响MySQL的再次安装。</strong><br><strong>（ProgramData文件夹可能是隐藏的，显示出来即可）</strong><br><strong>（MySQL文件下的内容才是真正的MySQL中数据）</strong></p>
<p><strong>5)删除path环境变量中关于MySQL安装路径的配置</strong> </p>
<h3 id="MySQL-安装（Linux）"><a href="#MySQL-安装（Linux）" class="headerlink" title="MySQL 安装（Linux）"></a>MySQL 安装（Linux）</h3><h4 id="——1-1"><a href="#——1-1" class="headerlink" title="——1.1"></a>——1.1</h4><p>MySQL安装</p>
<h5 id="1、卸载原来的版本"><a href="#1、卸载原来的版本" class="headerlink" title="1、卸载原来的版本"></a>1、卸载原来的版本</h5><h6 id="1、查看mysql的安装情况"><a href="#1、查看mysql的安装情况" class="headerlink" title="1、查看mysql的安装情况"></a>1、查看mysql的安装情况</h6><pre><code class="sh">rpm -qa | grep -i mysql
</code></pre>
<img data-src="/2022/10/15/tools/MySQL-tool/1570605325400.png" class="">


<h6 id="2、删除上图安装的软件"><a href="#2、删除上图安装的软件" class="headerlink" title="2、删除上图安装的软件"></a>2、删除上图安装的软件</h6><pre><code class="sh">rpm -ev --nodeps mysql57-community-release-el5-7.noarch
rpm -ev --nodeps mysql-community-server-5.7.18-1.el5.x86_64
rpm -ev --nodeps mysql-community-client-5.7.18-1.el5.x86_64
rpm -ev --nodeps mysql-community-libs-5.7.18-1.el5.x86_64
rpm -ev --nodeps mysql-community-common-5.7.18-1.el5.x86_64
rpm -ev --nodeps mysql-5.7.18-1.el5.x86_64
rpm -ev --nodeps mysql-community-libs-compat-5.7.18-1.el5.x86_64
</code></pre>
<h6 id="3、都删除成功之后，查找相关的mysql的文件"><a href="#3、都删除成功之后，查找相关的mysql的文件" class="headerlink" title="3、都删除成功之后，查找相关的mysql的文件"></a>3、都删除成功之后，查找相关的mysql的文件</h6><pre><code class="sh">find / -name mysql
</code></pre>
<img data-src="/2022/10/15/tools/MySQL-tool/1570605553095.png" class="">


<h6 id="4、删除全部文件"><a href="#4、删除全部文件" class="headerlink" title="4、删除全部文件"></a>4、删除全部文件</h6><pre><code class="sh">rm -rf /etc/selinux/targeted/active/modules/100/mysql
rm -rf /root/mysql
rm -rf /root/mysql/data/mysql
rm -rf /var/lib/mysql
rm -rf /var/lib/mysql/mysql
rm -rf /usr/share/mysql
</code></pre>
<h6 id="5、再次执行命令"><a href="#5、再次执行命令" class="headerlink" title="5、再次执行命令"></a>5、再次执行命令</h6><pre><code class="shell">rpm -qa | grep -i mysql
###如果没有显式则表示卸载完成
</code></pre>
<h5 id="2、删除mariadb-libs-不可省略"><a href="#2、删除mariadb-libs-不可省略" class="headerlink" title="2、删除mariadb-libs(不可省略)"></a>2、删除mariadb-libs(不可省略)</h5><pre><code class="sh">### 检查mariadb-libs
rpm -qa|grep mariadb
### 卸载mariadb-libs
yum remove mariadb-libs
</code></pre>
<h5 id="3、安装MySQL"><a href="#3、安装MySQL" class="headerlink" title="3、安装MySQL"></a>3、安装MySQL</h5><h6 id="1，输入"><a href="#1，输入" class="headerlink" title="1，输入"></a>1，输入</h6><p>wegt <span class="exturl" data-url="aHR0cHM6Ly9kZXYubXlzcWwuY29tL2dldC9teXNxbCVFNyU4OSU4OCVFNiU5QyVBQyVFNSU4RiVCNy1jb21tdW5pdHktcmVsZWFzZS1lbCVFNSVBNCVBNyVFNyU4OSU4OCVFNiU5QyVBQy0lRTUlQjAlOEYlRTclODklODglRTYlOUMlQUMubm9hcmNoLnJwbQ==">https://dev.mysql.com/get/mysql版本号-community-release-el大版本-小版本.noarch.rpm</span></p>
<pre><code class="sh">wget https://dev.mysql.com/get/mysql57-community-release-el5-7.noarch.rpm
</code></pre>
<h6 id="2、安装数据源"><a href="#2、安装数据源" class="headerlink" title="2、安装数据源"></a>2、安装数据源</h6><pre><code class="sh">yum install mysql57-community-release-el5-7.noarch.rpm
</code></pre>
<h6 id="3、查看mysql源是否安装成功"><a href="#3、查看mysql源是否安装成功" class="headerlink" title="3、查看mysql源是否安装成功"></a>3、查看mysql源是否安装成功</h6><pre><code class="sh">yum repolist enabled | grep &quot;mysql.*-community.*&quot;
</code></pre>
<h6 id="4、安装数据库"><a href="#4、安装数据库" class="headerlink" title="4、安装数据库"></a>4、安装数据库</h6><pre><code class="sh">yum install mysql-community-server



### 如果过期可以在运行安装程序之前导入密钥
rpm --import https://repo.mysql.com/RPM-GPG-KEY-mysql-2022
</code></pre>
<h6 id="5、启动mysql"><a href="#5、启动mysql" class="headerlink" title="5、启动mysql"></a>5、启动mysql</h6><pre><code class="sh">### centos7
systemctl restart mysqld
systemctl status mysqld


### centos6
service mysqld start

service mysqld status
</code></pre>
<h6 id="6、显示mysql的随机密码"><a href="#6、显示mysql的随机密码" class="headerlink" title="6、显示mysql的随机密码"></a>6、显示mysql的随机密码</h6><pre><code class="sh">grep &#39;temporary password&#39; /var/log/mysqld.log
</code></pre>
<img data-src="/2022/10/15/tools/MySQL-tool/image-20220827193405451.png" class="">


<h6 id="7、登录并修改mysql密码"><a href="#7、登录并修改mysql密码" class="headerlink" title="7、登录并修改mysql密码"></a>7、登录并修改mysql密码</h6><p>登录：mysql -u root -p   		然后输入上面生成的密码</p>
<p><strong><em>修改自定义密码，设置自己想要的密码</em></strong></p>
<pre><code class="sql">-- ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;密码&#39;;

ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;root&#39;;
</code></pre>
<p><strong><em>失败了的话就修改策略，将策略降低一下就可以了</em></strong></p>
<p>查看密码策略：</p>
<pre><code class="sql">SHOW VARIABLES LIKE &#39;validate_password%&#39;;
</code></pre>
<p>修改密码策略</p>
<pre><code class="sql">-- 修改密码长度：（长度）
set global validate_password.length=1;
-- 修改密码等级：（等级）
set global validate_password.policy=0;
</code></pre>
<h5 id="4、其他配置"><a href="#4、其他配置" class="headerlink" title="4、其他配置"></a>4、其他配置</h5><h6 id="1-开机自启"><a href="#1-开机自启" class="headerlink" title="1.开机自启"></a>1.开机自启</h6><pre><code class="sh">### 开机启动
systemctl enable mysql
### 关闭自动启动
systemctl disable mysqld
</code></pre>
<h6 id="2-远程连接"><a href="#2-远程连接" class="headerlink" title="2.远程连接"></a>2.远程连接</h6><h6 id="方法一、创建一个用户-支持远程连接"><a href="#方法一、创建一个用户-支持远程连接" class="headerlink" title="方法一、创建一个用户 支持远程连接"></a>方法一、创建一个用户 支持远程连接</h6><p>①登录 ：mysql -u root -p</p>
<p>②创建用户： create user ‘aaa‘@’%’ identified by ‘123456’;</p>
<p>③授权所有权限给user这个新用户 ：grant all on <em>.</em> to ‘aaa‘@’%’;</p>
<p>④退出mysql：quit;</p>
<h6 id="方法二、设置root用户支持远程连接"><a href="#方法二、设置root用户支持远程连接" class="headerlink" title="方法二、设置root用户支持远程连接"></a>方法二、设置root用户支持远程连接</h6><p>①登录：mysql -u root -p （ 注：系统提示输入数据库root用户的密码，输入完成后即进入mysql控制台，这个命令的第一个mysql是执行命令，第二个mysql是系统数据名称，不一样的。）</p>
<p>②设置权限：</p>
<p>赋予权限格式： grant 权限 on 数据库对象 to 用户@IP(或者相应正则)</p>
<pre><code class="sql">-- 新建用户规则或者直接修改root用户的规则 ，2 选一
use mysql;

-- 这里表示赋予该用户所有数据库所有表（*.*表示所有表），%表示所有IP地址。
GRANT ALL PRIVILEGES ON *.* TO &#39;root&#39;@&#39;%&#39; IDENTIFIED BY &#39;123456&#39; WITH GRANT OPTION;
-- 使root能再任何host访问
update user set host = &#39;%&#39; where user = &#39;root&#39;;      

-- 刷新
FLUSH PRIVILEGES;
</code></pre>
<p>③查看：</p>
<pre><code class="sql">use mysql;
SELECT HOST,USER FROM USER;
</code></pre>
<img data-src="/2022/10/15/tools/MySQL-tool/920952e9041b4af1a8a49eb64e0f4430.jpeg" class="">


<p> ④退出mysql：quit;</p>
<h4 id="——2"><a href="#——2" class="headerlink" title="——2"></a>——2</h4><h5 id="1、查询镜像"><a href="#1、查询镜像" class="headerlink" title="1、查询镜像"></a>1、查询镜像</h5><pre><code class="shell">docker search mysql
</code></pre>
<h5 id="2、拉取镜像"><a href="#2、拉取镜像" class="headerlink" title="2、拉取镜像"></a>2、拉取镜像</h5><pre><code class="shell">docker pull mysql:5.7
</code></pre>
<h5 id="3、构建容器"><a href="#3、构建容器" class="headerlink" title="3、构建容器"></a>3、构建容器</h5><p>先自己创建配置文件基础模板（<strong>要是后期要修改配置文件必须加入 模板中的两个元素，不然容器启动会出错</strong>）</p>
<pre><code class="shell">mkdir -p /root/mysql/conf
vim  /root/mysql/conf/my.cnf
</code></pre>
<p><strong>模板内容：</strong></p>
<pre><code class="shell">### Copyright (c) 2016, 2021, Oracle and/or its affiliates.
###
### This program is free software; you can redistribute it and/or modify
### it under the terms of the GNU General Public License, version 2.0,
### as published by the Free Software Foundation.
###
### This program is also distributed with certain software (including
### but not limited to OpenSSL) that is licensed under separate terms,
### as designated in a particular file or component or in included license
### documentation.  The authors of MySQL hereby grant you an additional
### permission to link the program and your derivative works with the
### separately licensed software that they have included with MySQL.
###
### This program is distributed in the hope that it will be useful,
### but WITHOUT ANY WARRANTY; without even the implied warranty of
### MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
### GNU General Public License, version 2.0, for more details.
###
### You should have received a copy of the GNU General Public License
### along with this program; if not, write to the Free Software
### Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA


!includedir /etc/mysql/conf.d/
!includedir /etc/mysql/mysql.conf.d/

[mysql]
default-character-set=utf8
[mysqld]
character_set_server=utf8
init_connect=&#39;SET NAMES utf8&#39;
lower_case_table_names = 1
</code></pre>
<p><strong>构建容器</strong></p>
<pre><code class="shell">docker run \
-p 3306:3306 \
-v /root/mysql/data:/var/lib/mysql \
-v /root/mysql/logs:/logs \
-v /root/.bashrc:/root/.bashrc \
-v /root/mysql/conf/my.cnf:/etc/mysql/my.cnf \
-e MYSQL_ROOT_PASSWORD=root \
--name mysql \
--hostname node1 \
--restart=always \
-d mysql:5.7
</code></pre>
<p><strong>注</strong>：出错时将本地映射文件检查一下，要是不需要配置，只需映射直接删掉就可，以后再改配置文件</p>
<h5 id="4、进入容器"><a href="#4、进入容器" class="headerlink" title="4、进入容器"></a>4、进入容器</h5><pre><code class="shell">docker exec -it mysql /bin/bash
或者
docker exec -it mysql mysql -uroot -p
</code></pre>
<h5 id="5、查看远程连接"><a href="#5、查看远程连接" class="headerlink" title="5、查看远程连接"></a>5、查看远程连接</h5><p>还有一些方法也可以试一下</p>
<pre><code class="shell">1.赋予权限格式：grant 权限 on 数据库对象 to 用户@IP(或者相应正则)

　　　　注：可以赋予select,delete,update,insert,index等权限精确到某一个数据库某一个表。

　　　　GRANT ALL PRIVILEGES ON *.* TO &#39;用户名&#39;@&#39;%&#39; IDENTIFIED BY &#39;密码&#39; WITH GRANT OPTION;
      GRANT ALL PRIVILEGES ON *.* TO &#39;root&#39;@&#39;%&#39; IDENTIFIED BY &#39;123456&#39; WITH GRANT OPTION;

　　　　这里表示赋予该用户所有数据库所有表（*.*表示所有表），%表示所有IP地址。

2.刷新权限：FLUSH PRIVILEGES;

3.查看权限：select user,host from mysql.user;

二.意外
　　1.配置文件种指定了blind-address：
#　　　　查看Mysql配置文件种（一般是/etc/my.cnf种）是否指定了blind-address，这表示只能是某个或某几个ip能连接。如果有就将它注释了，前面加#号注释。然后从启mysql。
    　重启mysql：service mysqld restart,如果安装的是Mariadb（我的就是）,则需要使用systemctl restart mariadb.service
    　
    2.防火墙的原因：
　　　　可能会报：ERROR 2003 (HY000): Can&#39;t connect to MySQL server on &#39;你要连接的IP&#39; (111)。

　　　　原因：1.可能是Mysql端口不对（默认是3306），只需加参数 -P 你的端口指定就行；
　　　　
　　　2.还有可能是有防火墙阻止，可以通过telnet来测试（可以直接关闭防火墙）。
　　　　　　　　　　防火墙相关命令：

　　　　　　　　　　　　（1）查看防火墙状态：service  iptables status或者systemctl status firewalld或者firewall-cmd --state

　　　　　　　　　　　　（2）暂时关闭防火墙：systemctl stop firewalld或者service  iptables stop或者systemctl stop firewalld.service

　　　　　　　　　　　　（3）永久关闭防火墙：systemctl disable firewalld或者chkconfig iptables off或者systemctl disable firewalld.service

　　　　　　　　　　　　（4）重启防火墙：systemctl enable firewalld或者service iptables restart  或者systemctl restart firewalld.service

 　　　　　　　　　　　　 (5)永久关闭后重启：chkconfig iptables on

　　

　　3.端口未开启：（我遇到的就是这个原因）
　　　　　　Mysql：ERROR 2003 (HY000) 110（连接超时）

　　　　　　查看你的服务器是否把对应端口打开，未打开启动就行了。　
　　　　　　
   4.Navicat连接MySQL，出现2059 - authentication plugin &#39;caching_sha2_password&#39;的解决方案
      
      0先进入容器，
      docker exec -it mysql mysql -uroot -p
      
#  	1#修改加密规则password是自己的密码，root也是登陆账户，下同。
      use mysql;
    ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;root&#39; PASSWORD EXPIRE NEVER; 
    
##	2 #更新一下用户的密码 
    ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED WITH mysql_native_password BY &#39;root&#39;;
    
##	3#刷新权限 
    FLUSH PRIVILEGES; 
    
##	4#更新一下用户的密码
    ALTER USER &#39;root&#39;@&#39;%&#39; IDENTIFIED WITH mysql_native_password BY &#39;root&#39;; 
</code></pre>
]]></content>
      <categories>
        <category>工具软件安装</category>
      </categories>
  </entry>
  <entry>
    <title>Nginx</title>
    <url>/2022/10/15/tools/Nginx-tool/</url>
    <content><![CDATA[<h3 id="nginx安装"><a href="#nginx安装" class="headerlink" title="nginx安装"></a>nginx安装</h3><h4 id="——1"><a href="#——1" class="headerlink" title="——1"></a>——1</h4><h5 id="安装：yum"><a href="#安装：yum" class="headerlink" title="安装：yum"></a>安装：yum</h5><pre><code class="sh"> yum install yum-utils
</code></pre>
<h5 id="切换目录："><a href="#切换目录：" class="headerlink" title="切换目录："></a>切换目录：</h5><pre><code class="sh">cd /etc/yum.repos.d/
</code></pre>
<h5 id="创建文件："><a href="#创建文件：" class="headerlink" title="创建文件："></a>创建文件：</h5><pre><code class="sh">vim nginx.repo
</code></pre>
<p><em>修改文件内容：</em></p>
<pre><code class="sh">[nginx-stable]

name=nginx stable repo

baseurl=http://nginx.org/packages/centos/$releasever/$basearch/

gpgcheck=1

enabled=1

gpgkey=https://nginx.org/keys/nginx_signing.key

module_hotfixes=true

[nginx-mainline]

name=nginx mainline repo

baseurl=http://nginx.org/packages/mainline/centos/$releasever/$basearch/

gpgcheck=1

enabled=0

gpgkey=https://nginx.org/keys/nginx_signing.key

module_hotfixes=true
</code></pre>
<h5 id="Nginx的安装："><a href="#Nginx的安装：" class="headerlink" title="Nginx的安装："></a>Nginx的安装：</h5><pre><code class="sh">yum install nginx
</code></pre>
<p>安装完成：我们的版本：nginx.x86_64 1:1.20.2-1.el7.ngx</p>
<div name="nginx_install_2">

<h4 id="——2"><a href="#——2" class="headerlink" title="——2"></a>——2</h4><h5 id="1、拉取镜像"><a href="#1、拉取镜像" class="headerlink" title="1、拉取镜像"></a>1、拉取镜像</h5><pre><code class="shell">docker pull nginx:1.16.1
</code></pre>
<h5 id="2、创建挂载数据卷"><a href="#2、创建挂载数据卷" class="headerlink" title="2、创建挂载数据卷"></a>2、创建挂载数据卷</h5><pre><code class="shell">mkdir -p /root/nginx/conf
vim /root/nginx/conf/nginx.conf
</code></pre>
<p><code>nginx.conf内容：</code></p>
<pre><code class="shell">user  root;
worker_processes  1;
 
error_log  /var/log/nginx/error.log warn;
pid        /var/run/nginx.pid;
 
 
events &#123;
    worker_connections  1024;
&#125;
 
 
http &#123;
    include       /etc/nginx/mime.types;
    default_type  application/octet-stream;
 
    log_format  main  &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39;
                      &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39;
                      &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;;
 
    access_log  /var/log/nginx/access.log  main;
 
    sendfile        on;
#    #tcp_nopush     on;
 
    keepalive_timeout  65;
 
#    #gzip  on;
    
    
    server &#123;
        listen       80;
        server_name  localhost;

#    	#charset koi8-r;
#    	#access_log  /var/log/nginx/host.access.log  main;

        location / &#123;
            root   /usr/share/nginx/html;
            index  index.html index.htm;
        &#125;

#    	#error_page  404              /404.html;

#    	# redirect server error pages to the static page /50x.html

        error_page   500 502 503 504  /50x.html;
        location = /50x.html &#123;
            root   /usr/share/nginx/html;
        &#125;
   
    &#125;
&#125;

</code></pre>
<h5 id="3、创建容器"><a href="#3、创建容器" class="headerlink" title="3、创建容器"></a>3、创建容器</h5><pre><code class="shell">### 注意ip一定要与检测ip相同
docker run \
-p 80:80 \
--name nginx  \
-v /root/nginx/conf/nginx.conf:/etc/nginx/nginx.conf \
-d nginx:1.16.1 
</code></pre>
<h5 id="4、查看"><a href="#4、查看" class="headerlink" title="4、查看"></a>4、查看</h5><pre><code class="shell">docker ps 
</code></pre>
]]></content>
      <categories>
        <category>工具软件安装</category>
      </categories>
  </entry>
  <entry>
    <title>Nacos</title>
    <url>/2022/10/15/tools/Nacos-tool/</url>
    <content><![CDATA[<h3 id="Nacos安装"><a href="#Nacos安装" class="headerlink" title="Nacos安装"></a>Nacos安装</h3><p><strong>注：</strong></p>
<ul>
<li><p>安装之前必须 配置  <a href="#jdk_install">jdk</a></p>
</li>
<li><p>安装之前必须 配置  <a href="#mysql_install">mysql5.6.+</a></p>
</li>
</ul>
<div name="nacos_install_1">

<h4 id="——1"><a href="#——1" class="headerlink" title="——1"></a>——1</h4><h5 id="1、准备安装包"><a href="#1、准备安装包" class="headerlink" title="1、准备安装包"></a>1、准备安装包</h5><p>官网：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FsaWJhYmEvbmFjb3MvcmVsZWFzZXM=">https://github.com/alibaba/nacos/releases</span></p>
<p>本篇我们选择version：2.0.3</p>
<h5 id="2、上传并解压"><a href="#2、上传并解压" class="headerlink" title="2、上传并解压"></a>2、上传并解压</h5><pre><code class="shell">tar -zxvf nacos-server-2.0.3 .tar.gz -C /usr/local/
</code></pre>
<h5 id="3、修改配置"><a href="#3、修改配置" class="headerlink" title="3、修改配置"></a>3、修改配置</h5><blockquote>
<p>1、使用nacos-mysql.sql</p>
<p>​		为我们储存数据建立数据库、表</p>
<p>2、<code>application.properties里面修改数据储存位置为mysql</code></p>
</blockquote>
<pre><code class="shell">cd /usr/local/nacos/conf
</code></pre>
<pre><code class="sql">-- 1 建立数据库
create  database nacos_config;
use nacos_config;

CREATE TABLE `config_info` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT &#39;id&#39;,
  `data_id` varchar(255) NOT NULL COMMENT &#39;data_id&#39;,
  `group_id` varchar(255) DEFAULT NULL,
  `content` longtext NOT NULL COMMENT &#39;content&#39;,
  `md5` varchar(32) DEFAULT NULL COMMENT &#39;md5&#39;,
  `gmt_create` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#39;创建时间&#39;,
  `gmt_modified` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#39;修改时间&#39;,
  `src_user` text COMMENT &#39;source user&#39;,
  `src_ip` varchar(50) DEFAULT NULL COMMENT &#39;source ip&#39;,
  `app_name` varchar(128) DEFAULT NULL,
  `tenant_id` varchar(128) DEFAULT &#39;&#39; COMMENT &#39;租户字段&#39;,
  `c_desc` varchar(256) DEFAULT NULL,
  `c_use` varchar(64) DEFAULT NULL,
  `effect` varchar(64) DEFAULT NULL,
  `type` varchar(64) DEFAULT NULL,
  `c_schema` text,
  PRIMARY KEY (`id`),
  UNIQUE KEY `uk_configinfo_datagrouptenant` (`data_id`,`group_id`,`tenant_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT=&#39;config_info&#39;;


CREATE TABLE `config_info_aggr` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT &#39;id&#39;,
  `data_id` varchar(255) NOT NULL COMMENT &#39;data_id&#39;,
  `group_id` varchar(255) NOT NULL COMMENT &#39;group_id&#39;,
  `datum_id` varchar(255) NOT NULL COMMENT &#39;datum_id&#39;,
  `content` longtext NOT NULL COMMENT &#39;内容&#39;,
  `gmt_modified` datetime NOT NULL COMMENT &#39;修改时间&#39;,
  `app_name` varchar(128) DEFAULT NULL,
  `tenant_id` varchar(128) DEFAULT &#39;&#39; COMMENT &#39;租户字段&#39;,
  PRIMARY KEY (`id`),
  UNIQUE KEY `uk_configinfoaggr_datagrouptenantdatum` (`data_id`,`group_id`,`tenant_id`,`datum_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT=&#39;增加租户字段&#39;;



CREATE TABLE `config_info_beta` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT &#39;id&#39;,
  `data_id` varchar(255) NOT NULL COMMENT &#39;data_id&#39;,
  `group_id` varchar(128) NOT NULL COMMENT &#39;group_id&#39;,
  `app_name` varchar(128) DEFAULT NULL COMMENT &#39;app_name&#39;,
  `content` longtext NOT NULL COMMENT &#39;content&#39;,
  `beta_ips` varchar(1024) DEFAULT NULL COMMENT &#39;betaIps&#39;,
  `md5` varchar(32) DEFAULT NULL COMMENT &#39;md5&#39;,
  `gmt_create` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#39;创建时间&#39;,
  `gmt_modified` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#39;修改时间&#39;,
  `src_user` text COMMENT &#39;source user&#39;,
  `src_ip` varchar(50) DEFAULT NULL COMMENT &#39;source ip&#39;,
  `tenant_id` varchar(128) DEFAULT &#39;&#39; COMMENT &#39;租户字段&#39;,
  PRIMARY KEY (`id`),
  UNIQUE KEY `uk_configinfobeta_datagrouptenant` (`data_id`,`group_id`,`tenant_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT=&#39;config_info_beta&#39;;


CREATE TABLE `config_info_tag` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT &#39;id&#39;,
  `data_id` varchar(255) NOT NULL COMMENT &#39;data_id&#39;,
  `group_id` varchar(128) NOT NULL COMMENT &#39;group_id&#39;,
  `tenant_id` varchar(128) DEFAULT &#39;&#39; COMMENT &#39;tenant_id&#39;,
  `tag_id` varchar(128) NOT NULL COMMENT &#39;tag_id&#39;,
  `app_name` varchar(128) DEFAULT NULL COMMENT &#39;app_name&#39;,
  `content` longtext NOT NULL COMMENT &#39;content&#39;,
  `md5` varchar(32) DEFAULT NULL COMMENT &#39;md5&#39;,
  `gmt_create` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#39;创建时间&#39;,
  `gmt_modified` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#39;修改时间&#39;,
  `src_user` text COMMENT &#39;source user&#39;,
  `src_ip` varchar(50) DEFAULT NULL COMMENT &#39;source ip&#39;,
  PRIMARY KEY (`id`),
  UNIQUE KEY `uk_configinfotag_datagrouptenanttag` (`data_id`,`group_id`,`tenant_id`,`tag_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT=&#39;config_info_tag&#39;;


CREATE TABLE `config_tags_relation` (
  `id` bigint(20) NOT NULL COMMENT &#39;id&#39;,
  `tag_name` varchar(128) NOT NULL COMMENT &#39;tag_name&#39;,
  `tag_type` varchar(64) DEFAULT NULL COMMENT &#39;tag_type&#39;,
  `data_id` varchar(255) NOT NULL COMMENT &#39;data_id&#39;,
  `group_id` varchar(128) NOT NULL COMMENT &#39;group_id&#39;,
  `tenant_id` varchar(128) DEFAULT &#39;&#39; COMMENT &#39;tenant_id&#39;,
  `nid` bigint(20) NOT NULL AUTO_INCREMENT,
  PRIMARY KEY (`nid`),
  UNIQUE KEY `uk_configtagrelation_configidtag` (`id`,`tag_name`,`tag_type`),
  KEY `idx_tenant_id` (`tenant_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT=&#39;config_tag_relation&#39;;


CREATE TABLE `group_capacity` (
  `id` bigint(20) unsigned NOT NULL AUTO_INCREMENT COMMENT &#39;主键ID&#39;,
  `group_id` varchar(128) NOT NULL DEFAULT &#39;&#39; COMMENT &#39;Group ID，空字符表示整个集群&#39;,
  `quota` int(10) unsigned NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;配额，0表示使用默认值&#39;,
  `usage` int(10) unsigned NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;使用量&#39;,
  `max_size` int(10) unsigned NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;单个配置大小上限，单位为字节，0表示使用默认值&#39;,
  `max_aggr_count` int(10) unsigned NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;聚合子配置最大个数，，0表示使用默认值&#39;,
  `max_aggr_size` int(10) unsigned NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;单个聚合数据的子配置大小上限，单位为字节，0表示使用默认值&#39;,
  `max_history_count` int(10) unsigned NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;最大变更历史数量&#39;,
  `gmt_create` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#39;创建时间&#39;,
  `gmt_modified` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#39;修改时间&#39;,
  PRIMARY KEY (`id`),
  UNIQUE KEY `uk_group_id` (`group_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT=&#39;集群、各Group容量信息表&#39;;


CREATE TABLE `his_config_info` (
  `id` bigint(64) unsigned NOT NULL,
  `nid` bigint(20) unsigned NOT NULL AUTO_INCREMENT,
  `data_id` varchar(255) NOT NULL,
  `group_id` varchar(128) NOT NULL,
  `app_name` varchar(128) DEFAULT NULL COMMENT &#39;app_name&#39;,
  `content` longtext NOT NULL,
  `md5` varchar(32) DEFAULT NULL,
  `gmt_create` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP,
  `gmt_modified` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP,
  `src_user` text,
  `src_ip` varchar(50) DEFAULT NULL,
  `op_type` char(10) DEFAULT NULL,
  `tenant_id` varchar(128) DEFAULT &#39;&#39; COMMENT &#39;租户字段&#39;,
  PRIMARY KEY (`nid`),
  KEY `idx_gmt_create` (`gmt_create`),
  KEY `idx_gmt_modified` (`gmt_modified`),
  KEY `idx_did` (`data_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT=&#39;多租户改造&#39;;


CREATE TABLE `tenant_capacity` (
  `id` bigint(20) unsigned NOT NULL AUTO_INCREMENT COMMENT &#39;主键ID&#39;,
  `tenant_id` varchar(128) NOT NULL DEFAULT &#39;&#39; COMMENT &#39;Tenant ID&#39;,
  `quota` int(10) unsigned NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;配额，0表示使用默认值&#39;,
  `usage` int(10) unsigned NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;使用量&#39;,
  `max_size` int(10) unsigned NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;单个配置大小上限，单位为字节，0表示使用默认值&#39;,
  `max_aggr_count` int(10) unsigned NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;聚合子配置最大个数&#39;,
  `max_aggr_size` int(10) unsigned NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;单个聚合数据的子配置大小上限，单位为字节，0表示使用默认值&#39;,
  `max_history_count` int(10) unsigned NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;最大变更历史数量&#39;,
  `gmt_create` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#39;创建时间&#39;,
  `gmt_modified` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#39;修改时间&#39;,
  PRIMARY KEY (`id`),
  UNIQUE KEY `uk_tenant_id` (`tenant_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT=&#39;租户容量信息表&#39;;


CREATE TABLE `tenant_info` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT &#39;id&#39;,
  `kp` varchar(128) NOT NULL COMMENT &#39;kp&#39;,
  `tenant_id` varchar(128) default &#39;&#39; COMMENT &#39;tenant_id&#39;,
  `tenant_name` varchar(128) default &#39;&#39; COMMENT &#39;tenant_name&#39;,
  `tenant_desc` varchar(256) DEFAULT NULL COMMENT &#39;tenant_desc&#39;,
  `create_source` varchar(32) DEFAULT NULL COMMENT &#39;create_source&#39;,
  `gmt_create` bigint(20) NOT NULL COMMENT &#39;创建时间&#39;,
  `gmt_modified` bigint(20) NOT NULL COMMENT &#39;修改时间&#39;,
  PRIMARY KEY (`id`),
  UNIQUE KEY `uk_tenant_info_kptenantid` (`kp`,`tenant_id`),
  KEY `idx_tenant_id` (`tenant_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT=&#39;tenant_info&#39;;

CREATE TABLE `users` (
    `username` varchar(50) NOT NULL PRIMARY KEY,
    `password` varchar(500) NOT NULL,
    `enabled` boolean NOT NULL
);

CREATE TABLE `roles` (
    `username` varchar(50) NOT NULL,
    `role` varchar(50) NOT NULL,
    UNIQUE INDEX `idx_user_role` (`username` ASC, `role` ASC) USING BTREE
);

CREATE TABLE `permissions` (
    `role` varchar(50) NOT NULL,
    `resource` varchar(255) NOT NULL,
    `action` varchar(8) NOT NULL,
    UNIQUE INDEX `uk_role_permission` (`role`,`resource`,`action`) USING BTREE
);

INSERT INTO users (username, password, enabled) VALUES (&#39;nacos&#39;, &#39;$2a$10$EuWPZHzz32dJN7jexM34MOeYirDdFAZm2kuWj7VEOJhhZkDrxfvUu&#39;, TRUE);

INSERT INTO roles (username, role) VALUES (&#39;nacos&#39;, &#39;ROLE_ADMIN&#39;);
</code></pre>
<pre><code class="shell">###2 先留取备份
cp application.properties application.properties.bk

vim application.properties

### 在application.properties最后添加以下内容
spring.datasource.platform=mysql

db.num=1
db.url.0=jdbc:mysql://127.0.0.1:3306/nacos_config?characterEncoding=utf8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=true&amp;serverTimezone=UTC
db.user=root
db.password=root
</code></pre>
<h5 id="4、开启nacos"><a href="#4、开启nacos" class="headerlink" title="4、开启nacos"></a>4、开启nacos</h5><pre><code class="shell">/usr/local/nacos/bin/startup.sh
</code></pre>
<h5 id="5、查看"><a href="#5、查看" class="headerlink" title="5、查看"></a>5、查看</h5><ul>
<li>测试之前先关闭防火墙</li>
</ul>
<p><span class="exturl" data-url="aHR0cDovLzE5Mi4xNjguMS41Mjo4ODQ4L25hY29z">http://192.168.1.52:8848/nacos</span></p>
<h3 id="Nacos集群配置"><a href="#Nacos集群配置" class="headerlink" title="Nacos集群配置"></a>Nacos集群配置</h3><ul>
<li>前提</li>
</ul>
<p>#&gt; 1、安装  <a href="#jdk_install">jdk</a></p>
<blockquote>
</blockquote>
<p>#&gt; 2、安装之前必须 配置  <a href="#mysql_install">mysql5.6.+</a></p>
<blockquote>
</blockquote>
<p>#&gt; 3、配置 <a href="#nginx_install_1">nginx</a></p>
<blockquote>
</blockquote>
<p>#&gt; 4、配置 <a href="#nacos_install_1">Nacos（单机版-1）</a></p>
<ul>
<li>懒加载</li>
</ul>
<blockquote>
<p>我们启动nginx之后可能不会立即开始代理，打开日志等一会，没有结果的时候重配一下</p>
</blockquote>
<h4 id="——1-1"><a href="#——1-1" class="headerlink" title="——1"></a>——1</h4><p>#​	* 此例中  <code>nginx:1.16</code> 安装教程为： <a href="#nacos_install_1">Nacos（单机版-1）</a></p>
<h5 id="1、修改集群配置文件"><a href="#1、修改集群配置文件" class="headerlink" title="1、修改集群配置文件"></a>1、修改集群配置文件</h5><p>​	这里开始正式配置集群，首先我们要更改   <strong>cluter.conf</strong>   这个配置文件，当然我们也需要备份，但是这里它的<strong>原始名称</strong>为：<strong>cluster.conf.example</strong> ，我们需要把它保留同时复制出一个cluster.conf来进行更改</p>
<p><strong>注：对于要集群启动的所有nacos都要做这步操作</strong></p>
<pre><code class="shell">cd /usr/local/nacos/conf

### 先备份
cp cluster.conf.example cluster.conf
</code></pre>
<p>修改<code>cluster.conf</code></p>
<pre><code class="shell">### 格式： ip地址:端口号
###
### Copyright 1999-2018 Alibaba Group Holding Ltd.
###
### Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
### you may not use this file except in compliance with the License.
### You may obtain a copy of the License at
###
###      http://www.apache.org/licenses/LICENSE-2.0
###
### Unless required by applicable law or agreed to in writing, software
### distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
### WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
### See the License for the specific language governing permissions and
### limitations under the License.
###

###it is ip
###example
###192.168.16.101:8847
###192.168.16.102
###192.168.16.10

###ip:port
192.168.124.133:3333
192.168.124.133:4444
192.168.124.133:5555
</code></pre>
<h5 id="2、编辑Nacos的启动脚本startup-sh"><a href="#2、编辑Nacos的启动脚本startup-sh" class="headerlink" title="2、编辑Nacos的启动脚本startup.sh"></a>2、编辑Nacos的启动脚本startup.sh</h5><pre><code class="shell">cd /usr/local/nacos/bin

### 先备份
cp startup.sh starup.sh.bk
vim  startup.sh 
</code></pre>
<pre><code class="shell">###1  在while 的变量中添加 o 并且在case 中添加对应处理
        o)
            PORT=$OPTARG;;
        
###2  在nohup 和&quot;$JAVA_OPT_EXT_FIX&quot;之前配置这个
     $JAVA -Dserver.port=$&#123;PORT&#125;  
 
</code></pre>
<img data-src="/2022/10/15/tools/Nacos-tool/1648643016965.png" class="">


<img data-src="/2022/10/15/tools/Nacos-tool/1648643157451.png" class="">






<h5 id="3、配置nginx"><a href="#3、配置nginx" class="headerlink" title="3、配置nginx"></a>3、配置nginx</h5><p>下图是http的转发，但是还是TCP 的更好</p>
<pre><code class="shell">    
    upstream  cluster&#123;
    server 192.168.1.52:3333;
    server 192.168.1.52:4444;
    server 192.168.1.52:5555;
    &#125;

    proxy_pass  http://cluter;
</code></pre>
<p><strong>图片中 <code>cluster</code>写错了 少了一个<code>s</code> ，其实问题也不大，但是要专业~~</strong></p>
<img data-src="/2022/10/15/tools/Nacos-tool/1648643539716.png" class="">


<p>TCP格式：</p>
<pre><code class="sh">worker_processes  1;

events &#123;
    worker_connections  1024;
&#125;

stream &#123;
      upstream nacos &#123;
        server 192.168.1.52:8848;
        server 192.168.1.52:8868;
        server 192.168.1.52:8888;
      &#125;


     server &#123;
        listen  81;
        proxy_pass nacos;
     &#125;
&#125;
</code></pre>
<h5 id="4、启动Nginx"><a href="#4、启动Nginx" class="headerlink" title="4、启动Nginx"></a>4、启动Nginx</h5><pre><code class="shell">
</code></pre>
<h5 id="5、查看测试"><a href="#5、查看测试" class="headerlink" title="5、查看测试"></a>5、查看测试</h5><p><span class="exturl" data-url="aHR0cDovLzE5Mi4xNjguMS41Mi9uYWNvcw==">http://192.168.1.52:80/nacos</span></p>
<h5 id="6、Nacos持久化"><a href="#6、Nacos持久化" class="headerlink" title="6、Nacos持久化"></a>6、Nacos持久化</h5><p>我们在配置的时候没有修改他的数据库，用的是自带的deery，如果是真的要部署要修改成mysql。这个熟悉</p>
<ol>
<li>在Linux系统上执行SQL脚本，具体位置在nacos目录下的conf中，这里的操作和之前是一样的，我们可以直接打开这个文件然后拷贝到数据库中执行，当然也是要创建数据库使用数据库然后在复制脚本内容，执行即可</li>
</ol>
<pre><code class="java">create database nacos_config;
use nacos_config;
</code></pre>
<img data-src="/2022/10/15/tools/Nacos-tool/image-20210929175710498.png" class="">


<ol start="2">
<li>修改application.properties配置文件，但是修改之前我们最好做一个备份。</li>
</ol>
<pre><code class="java">cp application.properties application.properties.init
</code></pre>
<ol start="3">
<li>这里的修改和我们之间的在win上的修改是完全一样的，所以我们只要打开这个文件，加上对应的内容即可</li>
</ol>
<pre><code class="java">spring.datasource.platform=mysql

db.num=1
db.url.0=jdbc:mysql://127.0.0.1:3306/nacos_config?characterEncoding=utf8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=true&amp;serverTimezone=UTC
db.user=root
db.password=123456
</code></pre>
<ol start="4">
<li>还要注意一点，如果是一台机子上部署要修改服务端口</li>
</ol>
<pre><code class="java">#*************** Spring Boot Related Configurations ***************#
##### Default web context path:
server.servlet.contextPath=/nacos
##### Default web server port:
###f服务端口
server.port=8888/8868
</code></pre>
]]></content>
      <categories>
        <category>工具软件安装</category>
      </categories>
  </entry>
  <entry>
    <title>OpenSSL</title>
    <url>/2022/10/15/tools/OpenSSL-tool/</url>
    <content><![CDATA[<h3 id="OpenSSL安装教程（Windows）"><a href="#OpenSSL安装教程（Windows）" class="headerlink" title="OpenSSL安装教程（Windows）"></a>OpenSSL安装教程（Windows）</h3><p>openssl官网下载地址：<span class="exturl" data-url="aHR0cDovL3NscHJvd2ViLmNvbS9wcm9kdWN0cy9XaW4zMk9wZW5TU0wuaHRtbA==">http://slproweb.com/products/Win32OpenSSL.html</span></p>
<h4 id="安装环境"><a href="#安装环境" class="headerlink" title="安装环境:"></a>安装环境:</h4><blockquote>
<p>windows 10<br>Win64 OpenSSL v1.1.1i</p>
</blockquote>
<h4 id="一-下载openssl安装版"><a href="#一-下载openssl安装版" class="headerlink" title="一.下载openssl安装版"></a>一.下载openssl安装版</h4><p>​	我这里是win10 64位,所以选的中间那个</p>
<img data-src="/2022/10/15/tools/OpenSSL-tool/20201222101342278.png" class="" title="按照操作系统选择"> 



<h4 id="二-安装过程"><a href="#二-安装过程" class="headerlink" title="二.安装过程"></a>二.安装过程</h4><p>​	也没啥特殊的 ，一直next，只有两点注意：</p>
<p>1、修改安装地址</p>
<p>2、最后一步，不要勾选，会掏钱。</p>
 <img data-src="/2022/10/15/tools/OpenSSL-tool/20201222102601218.png" class="" title="在这里插入图片描述"> 

 <img data-src="/2022/10/15/tools/OpenSSL-tool/20201222102703276.png" class="" title="在这里插入图片描述"> 

 <img data-src="/2022/10/15/tools/OpenSSL-tool/20201222102703268.png" class="" title="在这里插入图片描述"> 

 <img data-src="/2022/10/15/tools/OpenSSL-tool/20201222102721958.png" class="" title="在这里插入图片描述"> 

<img data-src="/2022/10/15/tools/OpenSSL-tool/1650347562395.png" class="">


<h4 id="三-配置环境变量"><a href="#三-配置环境变量" class="headerlink" title="三.配置环境变量"></a>三.配置环境变量</h4><img data-src="/2022/10/15/tools/OpenSSL-tool/1650351119292.png" class="">


 <img data-src="/2022/10/15/tools/OpenSSL-tool/1650351138506.png" class="" width="1650351138506">



<h4 id="四-测试"><a href="#四-测试" class="headerlink" title="四.测试"></a>四.测试</h4><pre><code class="sh">openssl -version
</code></pre>
<img data-src="/2022/10/15/tools/OpenSSL-tool/1650351011263.png" class="">




<h3 id="OpenSSL安装（Linux）"><a href="#OpenSSL安装（Linux）" class="headerlink" title="OpenSSL安装（Linux）"></a>OpenSSL安装（Linux）</h3><h4 id="——1"><a href="#——1" class="headerlink" title="——1"></a>——1</h4><p>参考链接：<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZlY3Rvcl9kYXRhL2FydGljbGUvZGV0YWlscy8xMDc1NTc5NDE=">https://blog.csdn.net/vector_data/article/details/107557941</span></p>
<h5 id="1-安装依赖C语言依赖"><a href="#1-安装依赖C语言依赖" class="headerlink" title="1.安装依赖C语言依赖"></a>1.安装依赖C语言依赖</h5><p>​	redis使用C语言编写，所以需要安装C语言库</p>
<pre><code class="sh">yum install -y gcc zlib 
</code></pre>
<p>​	</p>
<h5 id="2-上传并解压"><a href="#2-上传并解压" class="headerlink" title="2.上传并解压"></a>2.上传并解压</h5><p>​	把 <code>openssl-1.1.1j.tar.gz</code> 上传到&#x2F;usr&#x2F;local&#x2F;tmp中，解压文件</p>
<pre><code> cd /usr/local/tmp

 tar zxf openssl-1.1.1j.tar.gz 
 mv openssl-1.1.1j ../openssl
 
</code></pre>
<h5 id="3-编译并安装"><a href="#3-编译并安装" class="headerlink" title="3.编译并安装"></a>3.编译并安装</h5><p>​	进入解压文件夹</p>
<pre><code class="sh">  cd /usr/local/openssl
</code></pre>
<p>​	 配置编译 </p>
<pre><code class="sh">./config
</code></pre>
<p>​	编译安装	</p>
<pre><code>make clean &amp;&amp; make install
</code></pre>
<p>​	测试</p>
<pre><code>openssl version -a
</code></pre>
]]></content>
      <categories>
        <category>工具软件安装</category>
      </categories>
  </entry>
  <entry>
    <title>RabbitMQ</title>
    <url>/2022/10/15/tools/RabbitMQ-tool/</url>
    <content><![CDATA[<h3 id="RabbitMQ安装"><a href="#RabbitMQ安装" class="headerlink" title="RabbitMQ安装"></a>RabbitMQ<strong>安装</strong></h3><h4 id="1-上传并解压"><a href="#1-上传并解压" class="headerlink" title="1 上传并解压"></a>1 <strong>上传并解压</strong></h4><p>​	上传rabbitmq-server-generic-unix-3.7.18.tar.xz到&#x2F;usr&#x2F;loca&#x2F;tmp中</p>
<pre><code>  cd /usr/local/tmp
  
  tar xf rabbitmq-server-generic-unix-3.7.18.tar.xz -C /usr/local/tmp
</code></pre>
<h4 id="2-复制到local下"><a href="#2-复制到local下" class="headerlink" title="2 复制到local下"></a>2 <strong>复制到local下</strong></h4><p>​	复制解压文件到&#x2F;usr&#x2F;local下，命名为rabbitmq</p>
<pre><code>  cp -r rabbitmq_server-3.7.18 /usr/local/rabbitmq
</code></pre>
<h4 id="3-配置环境变量"><a href="#3-配置环境变量" class="headerlink" title="3 配置环境变量"></a>3 <strong>配置环境变量</strong></h4><pre><code>  vim /etc/profile
</code></pre>
<p>​	在文件中添加 </p>
<pre><code>export PATH=$PATH:/usr/local/rabbitmq/sbin
</code></pre>
<p>​	解析文件</p>
<pre><code> source /etc/profile
</code></pre>
<h4 id="4-开启web管理插件"><a href="#4-开启web管理插件" class="headerlink" title="4 开启web管理插件"></a>4 <strong>开启web管理插件</strong></h4><p>​	进入rabbitmq&#x2F;sbin目录</p>
<pre><code> cd /usr/local/rabbitmq/sbin
</code></pre>
<pre><code> 查看插件列表
</code></pre>
<pre><code>  ./rabbitmq-plugins list
</code></pre>
<pre><code> 生效管理插件
</code></pre>
<pre><code>  ./rabbitmq-plugins enable rabbitmq_management
</code></pre>
<h4 id="5-后台运行"><a href="#5-后台运行" class="headerlink" title="5 后台运行"></a>5 <strong>后台运行</strong></h4><p>​	启动rabbitmq。</p>
<pre><code>  ./rabbitmq-server -detached
</code></pre>
<p>​	停止命令，如果无法停止，使用kill -9 进程号进行关闭</p>
<pre><code> ./rabbitmqctl stop_app
</code></pre>
<h4 id="6-查看web管理界面"><a href="#6-查看web管理界面" class="headerlink" title="6 查看web管理界面"></a>6 <strong>查看web管理界面</strong></h4><p>​	默认可以在安装rabbitmq的电脑上通过用户名：guest密码guest进行访问web管理界面</p>
<p>​	端口号：15672（放行端口，或关闭防火墙）</p>
<p>​	在虚拟机浏览器中输入：</p>
<p>​	<span class="exturl" data-url="aHR0cDovL2xvY2FsaG9zdDoxNTY3Mi8=">http://localhost:15672</span></p>
<h3 id="RabbitMq账户管理"><a href="#RabbitMq账户管理" class="headerlink" title="* RabbitMq账户管理"></a>* RabbitMq账户管理</h3><h4 id="1-创建账户"><a href="#1-创建账户" class="headerlink" title="1 创建账户"></a>1 <strong>创建账户</strong></h4><p>​	语法：.&#x2F;rabbitmqctl add_user username password</p>
<pre><code> cd /usr/local/rabbitmq/sbin
 
 ./rabbitmqctl add_user mashibing mashibing
</code></pre>
<h4 id="2-给用户授予管理员角色"><a href="#2-给用户授予管理员角色" class="headerlink" title="2 给用户授予管理员角色"></a>2 <strong>给用户授予管理员角色</strong></h4><p>​	其中smallming为新建用户的用户名</p>
<pre><code> ./rabbitmqctl set_user_tags mashibing administrator
</code></pre>
<h4 id="3-给用户授权"><a href="#3-给用户授权" class="headerlink" title="3 给用户授权"></a>3 <strong>给用户授权</strong></h4><p>​	“&#x2F;” 表示虚拟机</p>
<p>​	mashibing 表示用户名</p>
<p>​	“.<em>“ “.</em>“ “.*” 表示完整权限</p>
<pre><code> ./rabbitmqctl set_permissions -p &quot;/&quot; mashibing &quot;.*&quot; &quot;.*&quot; &quot;.*&quot;
</code></pre>
<h4 id="4-登录"><a href="#4-登录" class="headerlink" title="4 登录"></a>4 <strong>登录</strong></h4><p>​	使用新建账户和密码在windows中访问rabbitmq并登录 </p>
<p>​	在浏览器地址栏输入：</p>
<p>​	<span class="exturl" data-url="aHR0cDovL2lwOjE1NjcyLw==">http://ip:15672/</span></p>
<pre><code> 用户名：mashibing
</code></pre>
<p>​	密码：mashibing</p>
]]></content>
      <categories>
        <category>工具软件安装</category>
      </categories>
  </entry>
  <entry>
    <title>Solr</title>
    <url>/2022/10/15/tools/Solr-tool/</url>
    <content><![CDATA[<h2 id="Solr安装"><a href="#Solr安装" class="headerlink" title="Solr安装"></a>Solr安装</h2><h3 id="——1"><a href="#——1" class="headerlink" title="——1"></a>——1</h3><p>​	Solr是使用Java编写，所以必选先安装JDK。</p>
<h4 id="1-上传并解压"><a href="#1-上传并解压" class="headerlink" title="1.上传并解压"></a>1.上传并解压</h4><p>​	上传压缩包solr-7.7.2.tgz到&#x2F;usr&#x2F;local&#x2F;tmp中。</p>
<p>​	解压</p>
<pre><code> cd /usr/local/tmp
 tar zxf solr-7.7.2.tgz -C /usr/local/tmp
</code></pre>
<h4 id="2-复制到-x2F-usr-x2F-local中"><a href="#2-复制到-x2F-usr-x2F-local中" class="headerlink" title="2.复制到&#x2F;usr&#x2F;local中"></a>2.复制到&#x2F;usr&#x2F;local中</h4><pre><code> cp -r solr-7.7.2 ../solr
</code></pre>
<h4 id="3-修改启动参数"><a href="#3-修改启动参数" class="headerlink" title="3.修改启动参数"></a>3.修改启动参数</h4><p>​	修改启动参数，否则启动时报警告。提示设置SOLR_ULIMIT_CHECKS&#x3D;false</p>
<pre><code> cd /usr/local/solr/bin
 vim solr.in.sh
</code></pre>
<img data-src="/2022/10/15/tools/Solr-tool/solr-02.jpg" class="">

<h4 id="4-启动Solr"><a href="#4-启动Solr" class="headerlink" title="4.启动Solr"></a>4.启动Solr</h4><p>​	Solr内嵌Jetty，直接启动即可。监听8983端口。</p>
<p>​	solr默认不推荐root账户启动，如果是root账户启动需要添加-force参数。</p>
<pre><code>## ./solr start -force
</code></pre>
<h4 id="5、可视化管理界面"><a href="#5、可视化管理界面" class="headerlink" title="5、可视化管理界面"></a>5、可视化管理界面</h4><p>​	在关闭防火墙的前提下，可以在windows的浏览器中访问Solr。</p>
<p>​	输入: <span class="exturl" data-url="aHR0cDovLzE5Mi4xNjguOTMuMTA6ODk4My8=">http://192.168.93.10:8983</span> 就可以访问Solr的可视化管理界面。</p>
<p>​	左侧有5个菜单。分别是：</p>
<p>​	（1）Dashboard：面板显示Solr的总体信息。</p>
<p>​	（2）Logging：日志</p>
<p>​	（3）Core Admin：Solr的核心。类似于数据的Database</p>
<p>​	（4）Java Perperties：所有Java相关属性。</p>
<p>​	（5）Thread Dump：线程相关信息。</p>
<p>​	（6）如果有Core，将显示在此处。</p>
<img data-src="/2022/10/15/tools/Solr-tool/solr-03.JPG" class="">

<h4 id="6、新建核心"><a href="#6、新建核心" class="headerlink" title="6、新建核心"></a>6、新建核心</h4><p>​	Solr安装完成后默认是没有核心的。需要手动配置。</p>
<p>​	需要在solr&#x2F;server&#x2F;solr下新建文件夹，并给定配置文件，否则无法建立。</p>
<img data-src="/2022/10/15/tools/Solr-tool/solr-04.JPG" class="">

<h5 id="6-1-新建目录"><a href="#6-1-新建目录" class="headerlink" title="6.1.新建目录"></a>6.1.新建目录</h5><p>​	在&#x2F;usr&#x2F;local&#x2F;solr&#x2F;server&#x2F;solr中新建自定义名称目录。此处示例名称为testcore。</p>
<pre><code> cd /usr/local/solr/server/solr
 mkdir testcore
</code></pre>
<h5 id="6-2-复制配置文件"><a href="#6-2-复制配置文件" class="headerlink" title="6.2.复制配置文件"></a>6.2.复制配置文件</h5><p>​	在configsets里面包含了_default和sample_techproducts_configs。里面都是配置文件示例。_default属于默认配置，较纯净。sample_techproducts_configs是带有了一些配置示例。</p>
<pre><code>## cp -r configsets/_default/conf/ testcore/
</code></pre>
<h5 id="6-3-填写Core信息"><a href="#6-3-填写Core信息" class="headerlink" title="6.3.填写Core信息"></a>6.3.填写Core信息</h5><p>​	在可视化管理界面中Core Admin中编写信息后点击Add Core后，短暂延迟后testcore就会创建成功。schema处不用更改。</p>
<img data-src="/2022/10/15/tools/Solr-tool/solr-05.JPG" class="">

<h6 id="6-4-出现testcore"><a href="#6-4-出现testcore" class="headerlink" title="6.4.出现testcore"></a>6.4.出现testcore</h6><p>​	在客户端管理界面中，选择新建的Core后，就可以按照自己项目的需求进行操作了。</p>
<img data-src="/2022/10/15/tools/Solr-tool/solr-06.jpg" class="">

<h4 id="7、分词Analysis"><a href="#7、分词Analysis" class="headerlink" title="7、分词Analysis"></a>7、分词Analysis</h4><p>​	在Solr可视化管理界面中，Core的管理菜单项中都会有Analysis。表示根据Scheme.xml(managed-schema)中配置要求进行解析。</p>
<p>​	对英文解析就比较简单了，只要按照空格把英文语句拆分成英文单词即可。</p>
<img data-src="/2022/10/15/tools/Solr-tool/solr-07.jpg" class="">

<p>​	但是如果条件是中文时，把一句话按照字进行拆分就不是很合理了。正确的方式是按照合理的词组进行拆分。<img data-src="/2022/10/15/tools/Solr-tool/solr-08.jpg" class=""></p>
<h6 id="7-1-配置步骤"><a href="#7-1-配置步骤" class="headerlink" title="7.1.配置步骤"></a>7.1.配置步骤</h6><p>​	上传ik-analyzer.jar到webapps中。</p>
<p>​	去<span class="exturl" data-url="aHR0cHM6Ly9zZWFyY2gubWF2ZW4ub3JnL3NlYXJjaD9xPWNvbS5naXRodWIubWFnZXNlJUU0JUI4JThCJUU4JUJEJUJEJUU1JUFGJUI5JUU1JUJBJTk0JUU3JTg5JTg4JUU2JTlDJUFDJUU3JTlBJTg0aWstYW5hbHl6ZXIlRTMlODAlODIlRTUlOEYlQUYlRTQlQkIlQTUlRTUlOUMlQTglRTglQjUlODQlRTYlOTYlOTklRTQlQjglQUQlRTclOUIlQjQlRTYlOEUlQTUlRTglOEUlQjclRTUlOEYlOTYlRTMlODAlODI=">https://search.maven.org/search?q=com.github.magese下载对应版本的ik-analyzer。可以在资料中直接获取。</span></p>
<h6 id="7-1-1上传jar到指定目录"><a href="#7-1-1上传jar到指定目录" class="headerlink" title="7.1.1上传jar到指定目录"></a>7.1.1上传jar到指定目录</h6><p>​	上传ik-analyzer-7.7.0.jar到</p>
<p>​	&#x2F;usr&#x2F;local&#x2F;solr&#x2F;server&#x2F;solr-webapp&#x2F;webapp&#x2F;WEB-INF&#x2F;lib目录中</p>
<h6 id="7-1-2修改配置文件"><a href="#7-1-2修改配置文件" class="headerlink" title="7.1.2修改配置文件"></a>7.1.2修改配置文件</h6><p>​	修改&#x2F;usr&#x2F;local&#x2F;solr&#x2F;server&#x2F;solr&#x2F;testcore&#x2F;conf&#x2F;managed-schema</p>
<pre><code>## vim /usr/local/solr/server/solr/testcore/conf/managed-schema
</code></pre>
<p>​	添加下面内容。</p>
<p>​	排版：Esc 退出编辑状态下：gg&#x3D;G</p>
<pre><code>&lt;field name=&quot;myfield&quot; type=&quot;text_ik&quot; indexed=&quot;true&quot; stored=&quot;true&quot; /&gt;
    &lt;fieldType name=&quot;text_ik&quot; class=&quot;solr.TextField&quot;&gt;
            &lt;analyzer type=&quot;index&quot;&gt;
                    &lt;tokenizer class=&quot;org.wltea.analyzer.lucene.IKTokenizerFactory&quot; useSmart=&quot;false&quot; conf=&quot;ik.conf&quot;/&gt;
                    &lt;filter class=&quot;solr.LowerCaseFilterFactory&quot;/&gt;
            &lt;/analyzer&gt;
            &lt;analyzer type=&quot;query&quot;&gt;
                    &lt;tokenizer class=&quot;org.wltea.analyzer.lucene.IKTokenizerFactory&quot; useSmart=&quot;true&quot; conf=&quot;ik.conf&quot;/&gt;
                    &lt;filter class=&quot;solr.LowerCaseFilterFactory&quot;/&gt;
            &lt;/analyzer&gt;
    &lt;/fieldType&gt;
</code></pre>
<h6 id="7-1-3重启"><a href="#7-1-3重启" class="headerlink" title="7.1.3重启"></a>7.1.3重启</h6><pre><code>## cd /usr/local/solr/bin
## ./solr stop -all
## ./solr start -force
</code></pre>
<h6 id="7-1-4验证"><a href="#7-1-4验证" class="headerlink" title="7.1.4验证"></a>7.1.4验证</h6><p>​	可以在可视化管理界面中找到myfield属性进行验证。</p>
<img data-src="/2022/10/15/tools/Solr-tool/solr-09.jpg" class="">

<h6 id="7-2-managed-schema配置说明"><a href="#7-2-managed-schema配置说明" class="headerlink" title="7.2.managed-schema配置说明"></a>7.2.managed-schema配置说明</h6><h6 id="7-2-1-lt-fieldType-x2F-gt"><a href="#7-2-1-lt-fieldType-x2F-gt" class="headerlink" title="7.2.1&lt; fieldType&#x2F;&gt;"></a>7.2.1&lt; fieldType&#x2F;&gt;</h6><p>​	表示定义一个属性类型。在Solr中属性类型都是自定义的。在上面配置中name&#x3D;”text_ik”为自定义类型。当某个属性取值为text_ik时IK Analyzer才能生效。</p>
<h6 id="7-2-2-lt-field-x2F-gt"><a href="#7-2-2-lt-field-x2F-gt" class="headerlink" title="7.2.2&lt; field&#x2F;&gt;"></a>7.2.2&lt; field&#x2F;&gt;</h6><p>​	表示向Document中添加一个属性。</p>
<p>​	常用属性：</p>
<p>​		name: 属性名</p>
<p>​		type:属性类型。所有类型都是solr使用<fieldType>配置的</p>
<p>​		indexed: 是否建立索引</p>
<p>​		stored: solr是否把该属性值响应给搜索用户。</p>
<p>​		required：该属性是否是必须的。默认id是必须的。</p>
<p>​		multiValued：如果为true，表示该属性为复合属性，此属性中包含了多个其他的属性。常用在多个列作为搜索条件时，把这些列定义定义成一个新的复合属性，通过搜索一个复合属性就可以实现搜索多个列。当设置为true时与&lt; copyField source&#x3D;”” dest&#x3D;””&#x2F;&gt;结合使用</p>
<h6 id="7-2-3-lt-uniqueKey-gt"><a href="#7-2-3-lt-uniqueKey-gt" class="headerlink" title="7.2.3&lt; uniqueKey&gt;"></a>7.2.3&lt; uniqueKey&gt;</h6><p>​	唯一主键，Solr中默认定义id属性为唯一主键。ID的值是不允许重复的。</p>
<h6 id="7-2-4-lt-dynamicField-gt"><a href="#7-2-4-lt-dynamicField-gt" class="headerlink" title="7.2.4&lt; dynamicField&gt;"></a>7.2.4&lt; dynamicField&gt;</h6><p>​	名称中允许*进行通配。代表满足特定名称要求的一组属性。</p>
<pre><code> msb_java    
</code></pre>
<p>​	msb_bigdata</p>
<p>​	msb_UI</p>
<p>​        msb_*</p>
<h4 id="8、Dataimport"><a href="#8、Dataimport" class="headerlink" title="8、Dataimport"></a>8、Dataimport</h4><p>​	可以使用Solr自带的Dataimport功能把数据库中数据快速导入到solr中.</p>
<p>​	<strong>必须保证managed-schema和数据库中表的列对应。，添加配置</strong></p>
<h6 id="8-1-修改配置文件"><a href="#8-1-修改配置文件" class="headerlink" title="8.1.修改配置文件"></a>8.1.修改配置文件</h6><p>​	修改solrconfig.xml，添加下面内容</p>
<pre><code> &lt;!-- 配置数据导入的处理器 --&gt;
  &lt;requestHandler name=&quot;/dataimport&quot; class=&quot;org.apache.solr.handler.dataimport.DataImportHandler&quot;&gt;
    &lt;lst name=&quot;defaults&quot;&gt;
      &lt;!--  加载data-config.xml  --&gt;
      &lt;str name=&quot;config&quot;&gt;data-config.xml&lt;/str&gt;
     &lt;/lst&gt;
  &lt;/requestHandler&gt;
</code></pre>
<h6 id="8-2-新建data-config-xml"><a href="#8-2-新建data-config-xml" class="headerlink" title="8.2.新建data-config.xml"></a>8.2.新建data-config.xml</h6><p>​	和solrconfig.xml同一目录下新建data-config.xml</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;dataConfig&gt;
        &lt;dataSource type=&quot;JdbcDataSource&quot;   
                driver=&quot;com.mysql.jdbc.Driver&quot;   
                url=&quot;jdbc:mysql://192.168.1.135:3306/mytest&quot;   
                user=&quot;root&quot;   
                password=&quot;root&quot;/&gt;
        &lt;document&gt;
            &lt;entity name=&quot;product&quot; query=&quot;SELECT id,name,price from t_product&quot;&gt;
                &lt;!-- 
                 实现数据库的列和索引库的字段的映射
                 column 指定数据库的列表
                 name  指定索引库的字段名字，必须和schema.xml中定义的一样
                 --&gt;
                 &lt;field column=&quot;id&quot; name=&quot;id&quot;/&gt;
                 &lt;field column=&quot;name&quot; name=&quot;name&quot;/&gt;
                 &lt;field column=&quot;price&quot; name=&quot;price&quot;/&gt;
            &lt;/entity&gt;
         &lt;/document&gt;
&lt;/dataConfig&gt;
</code></pre>
<h6 id="8-3-添加jar"><a href="#8-3-添加jar" class="headerlink" title="8.3.添加jar"></a>8.3.添加jar</h6><p>​	向solr-webapp中添加<strong>三个jar</strong>。在<strong>dist中两个还有一个数据库驱动。（自己去maven-repository里面找一个 mysql-connector-java ）</strong></p>
<img data-src="/2022/10/15/tools/Solr-tool/solr-10.jpg" class="">

<h6 id="8-4-操作"><a href="#8-4-操作" class="headerlink" title="8.4.操作"></a>8.4.操作</h6><p>​	重启solr后，在可视化管理页面中进行数据导入。</p>
<p>​	注意：</p>
<p>​	点击导入按钮后，要记得点击刷新按钮。</p>
]]></content>
      <categories>
        <category>工具软件安装</category>
      </categories>
  </entry>
  <entry>
    <title>XShell</title>
    <url>/2022/10/15/tools/XShell-tool/</url>
    <content><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h2 id="配色"><a href="#配色" class="headerlink" title="配色"></a>配色</h2><blockquote>
<p>所有资源都在网盘和仓库里面</p>
</blockquote>
<h4 id="zk1"><a href="#zk1" class="headerlink" title="zk1"></a>zk1</h4><img data-src="/2022/10/15/tools/XShell-tool/image-20220801173236598.png" class="">


<h4 id="Solarized-Dark"><a href="#Solarized-Dark" class="headerlink" title="Solarized Dark"></a>Solarized Dark</h4><img data-src="/2022/10/15/tools/XShell-tool/image-20220801173040826.png" class="">


<h4 id="SolarizedDarkModify"><a href="#SolarizedDarkModify" class="headerlink" title="SolarizedDarkModify"></a>SolarizedDarkModify</h4><img data-src="/2022/10/15/tools/XShell-tool/image-20220801173129171.png" class="">




<h4 id="isayme"><a href="#isayme" class="headerlink" title="isayme"></a>isayme</h4><img data-src="/2022/10/15/tools/XShell-tool/image-20220801172922893.png" class="">




<h4 id="ubuntu"><a href="#ubuntu" class="headerlink" title="ubuntu"></a>ubuntu</h4><img data-src="/2022/10/15/tools/XShell-tool/image-20220801173207482.png" class="">


















]]></content>
      <categories>
        <category>工具软件安装</category>
      </categories>
  </entry>
  <entry>
    <title>Tomcat</title>
    <url>/2022/10/15/tools/Tomcat-tool/</url>
    <content><![CDATA[<h3 id="Tomcat安装"><a href="#Tomcat安装" class="headerlink" title="Tomcat安装"></a>Tomcat安装</h3><p>下载</p>
<p>下载地址：<span class="exturl" data-url="aHR0cDovL3RvbWNhdC5hcGFjaGUub3JnLw==">http://tomcat.apache.org/</span></p>
<img data-src="/2022/10/15/tools/Tomcat-tool/1646193444708.png" class="">


<h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>tomcat由apache开源组织使用java开发的一款web容器,在使用之前需要安装JDK及配置JAVA_HOME.Tomcat是绿色软解，<strong>解压就可使用</strong>。如果之前已经安装了其他tomcat并且还配置了CATALINA_HOME 不要忘记修改CATALINA_HOME指向我们现在使用的这个tomcat</p>
<h4 id="Tomcat启动"><a href="#Tomcat启动" class="headerlink" title="Tomcat启动"></a>Tomcat启动</h4><p>运行startup.bat文件。</p>
<p>一定要配置JAVA_HOME   C:\Program Files\Java\jdk1.8.0_161<br>部分电脑需要配置CATALINA_HOME   D:&#x2F;<em><strong>&#x2F;</strong></em>&#x2F;apache-tomcat-9.0.41<br>记住一个习惯:以后我们装任何一个软件路径都应该避免中文,空格和特殊符号,可以使用_</p>
<h4 id="Tomcat关闭"><a href="#Tomcat关闭" class="headerlink" title="Tomcat关闭"></a>Tomcat关闭</h4><p>  运行shutdown.bat文件或者直接关闭掉启动窗口。</p>
<h4 id="访问Tomcat"><a href="#访问Tomcat" class="headerlink" title="访问Tomcat"></a>访问Tomcat</h4><p>访问Tomcat的URL格式：<span class="exturl" data-url="aHR0cDovL2lwOnBvcnQ=">http://ip:port</span></p>
<p>访问本机Tomcat的URL格式：<span class="exturl" data-url="aHR0cDovL2xvY2FsaG9zdDo4MDgwLw==">http://localhost:8080</span></p>
<h3 id="Tomcat安装-1"><a href="#Tomcat安装-1" class="headerlink" title="Tomcat安装"></a>Tomcat安装</h3><h4 id="——1"><a href="#——1" class="headerlink" title="——1"></a>——1</h4><h5 id="1、下载Linux对应版本的Tomcat"><a href="#1、下载Linux对应版本的Tomcat" class="headerlink" title="1、下载Linux对应版本的Tomcat"></a>1、下载Linux对应版本的Tomcat</h5><p>​	  下载压缩文件     apache-tomcat-7.0.68.tar.gz         </p>
<h5 id="2、解压压缩文件"><a href="#2、解压压缩文件" class="headerlink" title="2、解压压缩文件"></a>2、解压压缩文件</h5><pre><code class="shell">#tar -xvf   apache-tomcat-7.0.68.tar.gz -C /usr/local/  #解压到的路径 
</code></pre>
<h5 id="3、配置环境变量"><a href="#3、配置环境变量" class="headerlink" title="3、配置环境变量"></a>3、配置环境变量</h5><pre><code class="shell">vim  /etc/profile

###自己定义为位置
export CATALINA_BASE=/usr/local/apache-tomcat-7.0.68
export PATH=$CATALINA_BASE/bin:$PATH
</code></pre>
<h5 id="4、使用环境变量生效"><a href="#4、使用环境变量生效" class="headerlink" title="4、使用环境变量生效"></a>4、使用环境变量生效</h5><pre><code class="shell">source /etc/profile
</code></pre>
<h5 id="5、启动Tomcat服务"><a href="#5、启动Tomcat服务" class="headerlink" title="5、启动Tomcat服务"></a>5、启动Tomcat服务</h5><ul>
<li>注：要是远程访问你关注防火墙问题</li>
</ul>
<p>启动Tomcat服务：</p>
<pre><code class="shell">./startup.sh
</code></pre>
<p>启动Tomcat并输出启动日志 :</p>
<pre><code class="shell">  ./startup.sh &amp; tail -f  ../logs/catalina.out
</code></pre>
]]></content>
      <categories>
        <category>工具软件安装</category>
      </categories>
  </entry>
  <entry>
    <title>Zookeeper</title>
    <url>/2022/10/15/tools/Zookeeper-tool/</url>
    <content><![CDATA[<h3 id="Zookeeper-linux安装"><a href="#Zookeeper-linux安装" class="headerlink" title="Zookeeper-linux安装"></a>Zookeeper-linux安装</h3><h4 id="——1"><a href="#——1" class="headerlink" title="——1"></a>——1</h4><h5 id="1-Zookeeper简介"><a href="#1-Zookeeper简介" class="headerlink" title="1     Zookeeper简介"></a>1     Zookeeper简介</h5><p>​	zookeeper分布式管理软件。常用它做注册中心（依赖zookeeper的发布&#x2F;订阅功能）、配置文件中心、分布式锁配置、集群管理等。</p>
<p>​	zookeeper一共就有两个版本。主要使用的是java语言写的。</p>
<h5 id="2-安装"><a href="#2-安装" class="headerlink" title="2     安装"></a>2     安装</h5><h6 id="2-1-上传压缩文件"><a href="#2-1-上传压缩文件" class="headerlink" title="2.1   上传压缩文件"></a>2.1   上传压缩文件</h6><p>​	上传到 &#x2F;usr&#x2F;local&#x2F;tmp中</p>
<h5 id="2-2-解压"><a href="#2-2-解压" class="headerlink" title="2.2   解压"></a>2.2   解压</h5><pre><code> tar zxf apache-zookeeper-3.5.5-bin.tar.gz
 cp -r apache-zookeeper-3.5.5-bin ../zookeeper
</code></pre>
<h5 id="2-3-新建data目录"><a href="#2-3-新建data目录" class="headerlink" title="2.3   新建data目录"></a>2.3   新建data目录</h5><p>进入到zookeeper中</p>
<pre><code> cd /usr/local/zookeeper
 mkdir data
</code></pre>
<h5 id="2-4-修改配置文件"><a href="#2-4-修改配置文件" class="headerlink" title="2.4   修改配置文件"></a>2.4   修改配置文件</h5><p>进入conf中</p>
<pre><code> cd conf
 cp zoo_sample.cfg zoo.cfg
 vim zoo.cfg
</code></pre>
<p>修改dataDir为data文件夹路径</p>
<pre><code>dataDir=/usr/local/zookeeper/data
</code></pre>
<h5 id="2-5-启动zookeeper"><a href="#2-5-启动zookeeper" class="headerlink" title="2.5   启动zookeeper"></a>2.5   启动zookeeper</h5><p>进入bin文件夹</p>
<pre><code> cd /usr/local/zookeeper/bin
 ./zkServer.sh start
</code></pre>
<p>通过status查看启动状态。稍微有个等待时间</p>
<pre><code class="shell">  ./zkServer.sh status
</code></pre>
<h4 id="——2"><a href="#——2" class="headerlink" title="——2"></a>——2</h4><p><strong>资料：</strong></p>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20va2luZ2tvby9wLzg3MzI0NDguaHRtbA==">https://www.cnblogs.com/kingkoo/p/8732448.html</span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL2F2ODA4NzQ2NjY/ZnJvbT1zZWFyY2gmYW1wO3NlaWQ9MTYyOTE0NTAyNTIxMTk5OTEwNCZhbXA7c3BtX2lkX2Zyb209MzMzLjMzNy4wLjA=">https://www.bilibili.com/video/av80874666?from=search&amp;seid=1629145025211999104&amp;spm_id_from=333.337.0.0</span></p>
<h5 id="1-Zookeeper简介-1"><a href="#1-Zookeeper简介-1" class="headerlink" title="1     Zookeeper简介"></a>1     Zookeeper简介</h5><p>​	zookeeper分布式管理软件。常用它做注册中心（依赖zookeeper的发布&#x2F;订阅功能）、配置文件中心、分布式锁配置、集群管理等。</p>
<p>​	zookeeper一共就有两个版本。主要使用的是java语言写的。</p>
<h5 id="2-安装-1"><a href="#2-安装-1" class="headerlink" title="2     安装"></a>2     安装</h5><h6 id="2-1-拉取镜像"><a href="#2-1-拉取镜像" class="headerlink" title="2.1   拉取镜像"></a>2.1   拉取镜像</h6><ul>
<li><p>自定义zookeeper目录</p>
<pre><code class="shell">mkdir /root/zookeeper
</code></pre>
</li>
</ul>
<p>#mkdir &#x2F;root&#x2F;zookeeper&#x2F;data #原因参照上面 -在docker中data其实也不用在宿主机行自己生成(目前如此)</p>
<p>仓库官网查看版本或者用命令直接查</p>
<pre><code>docker search zookeeper
</code></pre>
<p>拉取特定版本（3.5）</p>
<pre><code>docker pull zookeeper:3.5

```
</code></pre>
<h6 id="2-2-创建并启动容器"><a href="#2-2-创建并启动容器" class="headerlink" title="2.2 创建并启动容器"></a>2.2 创建并启动容器</h6><p>​	<strong>注：就目前而且 好像直接在docker中使用 zookeeper 不需要过多的配置，直接用命令创建吧，下面的解释先不看，具体原因后面补充</strong></p>
<p>命令：</p>
<pre><code class="shell">docker run -d --name zookeeper -v /root/zookeeper/data:/data -p 2181:2181 --restart always zookeeper:3.5
</code></pre>
<ul>
<li><code>--restart always</code>：始终重启</li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vYWdlb3ZiL3AvMTUzMjg3OTYuaHRtbA==">https://www.cnblogs.com/ageovb/p/15328796.html</span></li>
</ul>
<p><strong>解释</strong></p>
<ul>
<li><p>1、这里为啥只挂载了 data 目录–》因为当我们 没有直接的安装压缩包时，我们的就没有配置文件，所以我们直接生成，容器中就回自动生成conf文件，其中就有我们需要的 一系列配置文件，我们第一次创建的时候就可以如此，我们在进<strong>行配置文件的修改完成</strong>后，要将所有配置文件放到我们  bash 目录中的 conf 文件中去。</p>
</li>
<li><p>2、第一次进入容器</p>
<ul>
<li><p>在bash目录下进入bin 目录然后输入开启客户端命令</p>
<pre><code class="shell">./zkCli.sh
</code></pre>
</li>
</ul>
</li>
<li><p>3、第二次进入容器</p>
<pre><code class="shell">docker exec -it zookeeper /bin/bash  -p    端口号
或
docker exec -it zookeeper zkCli.sh
</code></pre>
</li>
</ul>
<p><strong>只看到这就可*，容器创建成功就可以直接用了，还没有出现问题。有待补充</strong></p>
<h6 id="2-3-修改配置文件"><a href="#2-3-修改配置文件" class="headerlink" title="2.3   修改配置文件"></a>2.3   修改配置文件</h6><ul>
<li>配置文件来源<ul>
<li>1、可以去我们的资料中直接解压出<strong>conf</strong>目录粘贴到我们的 zookeeper 目录中去</li>
<li>2、可以直接进行第 3 步，完事之后直接会在容器中生成。找到conf文件，修改其中的 zoo.cfg文件，</li>
</ul>
</li>
</ul>
<p>进入容器后，找到conf中的 **zoo.cfg文件，接下来就是修改 <strong>dataDir</strong> 路径为容器中的 data文件目录。</p>
<p>前提是要下载 vim ，因为容器中没有，命令是：</p>
<pre><code>apt-get update

apt-get install -y vim

cd conf
### 没有zoo.cfg 就先拷贝 zoo_sample.cfg 两个其实是一个文件，内容相同
###cp zoo_sample.cfg zoo.cfg
vim zoo.cfg
</code></pre>
<p>修改dataDir为data文件夹路径</p>
<pre><code>dataDir=/usr/local/zookeeper/data
</code></pre>
<h3 id="Zookeeper集群搭建"><a href="#Zookeeper集群搭建" class="headerlink" title="Zookeeper集群搭建"></a>Zookeeper集群搭建</h3><h4 id="——1-1"><a href="#——1-1" class="headerlink" title="——1"></a>——1</h4><p>1.上传压缩包到&#x2F;usr&#x2F;local&#x2F;tmp 下 并解压。</p>
<p>2.在 &#x2F;usr&#x2F;local下新建文件夹 zookeeper</p>
<pre><code>### mkdir /usr/local/zookeeper
</code></pre>
<p>3.把解压的所有文件复制到zookeeper下， 并命名为zk1</p>
<pre><code>### cp -r /usr/local/temp/zookeeper-3.4.8 /usr/local/zookeeper/zk1
</code></pre>
<p>4.在zk1下新建文件夹 data</p>
<p>5.在data下新建文件 myid, 里面写上 1</p>
<pre><code>### vim myid
</code></pre>
<p>6.进入到zk1&#x2F;conf 下 把 zoo_sample.cfg 复制一份叫做 zoo.cfg</p>
<p>7.编辑 zoo.cfg 内容，设置 dataDIR为 data文件夹， 并在文件最下面添加下面内容</p>
<pre><code>server.1=192.168.93.10:2688:3888
server.2=192.168.93.10:2689:3889
server.3=192.168.93.10:2690:3890
</code></pre>
<p> 7.1 server.1中的1是myid的内容</p>
<p> 7.2 2688 2689 2690 是 zookeeper内部端口</p>
<p> 7.3 3888 3889 3890 是 leader端口</p>
<p>8.把zk1复制两份，分部叫做 zk2  zk3  并修改 myid 的值为 2，3 修改zoo.cfg中 dataDIR和clientPort</p>
<p>9.启动三个zookeeper</p>
<pre><code>### ./zkServer.sh start
</code></pre>
<p>10.查看状态</p>
<pre><code>### ./zkServer.sh status
</code></pre>
<h4 id="——2-1"><a href="#——2-1" class="headerlink" title="——2"></a>——2</h4><p><strong>1、准备</strong>docker-compose.yml<strong>文件</strong></p>
<pre><code class="shell">version: &#39;2&#39;
services:
  zoo1:
    image: zookeeper:3.5
    restart: always
    container_name: zoo1
    ports:
      - &quot;2182:2181&quot;
    environment:
      ZOO_MY_ID: 1
      ZOO_SERVERS: server.1=0.0.0.0:2688:3888 server.2=zoo2:2689:3888 server.3=zoo3:2690:3888

  zoo2:
    image: zookeeper:3.5
    restart: always
    container_name: zoo2
    ports:
      - &quot;2183:2181&quot;
    environment:
      ZOO_MY_ID: 2
      ZOO_SERVERS: server.1=zoo1:2688:3888 server.2=0.0.0.0:2689:3888 server.3=zoo3:2690:3888

  zoo3:
    image: zookeeper:3.5
    restart: always
    container_name: zoo3
    ports:
      - &quot;2184:2181&quot;
    environment:
      ZOO_MY_ID: 3
      ZOO_SERVERS: server.1=zoo1:2688:3888 server.2=zoo2:2689:3888 server.3=0.0.0.0:2690:3888

</code></pre>
<p><strong>2、创建镜像</strong></p>
<ul>
<li>要在创建的docker-compose.yml文件中使用命令</li>
</ul>
<pre><code class="shell">docker-compose up -d
</code></pre>
<p><strong>3、进入容器</strong></p>
<pre><code class="shell">docker exec -it zoo1 /bin/bash

###查看zoo1 的状态
cd bin
./zkServer.sh status
</code></pre>
<ul>
<li>如果出现，以下情况：</li>
</ul>
<pre><code>ZooKeeper JMX enabled by default
Using config: /conf/zoo.cfg
Client port not found in static config file. Looking in dynamic config file.
grep: : No such file or directory
Client port not found in the server configs
Client port not found. Looking for secureClientPort in the static config.
Unable to find either secure or unsecure client port in any configs. Terminating.
</code></pre>
<p>​	通过阅读我们知道他在conf中的zoo.cfg文件中缺少 **clientPort **我们只需要自行添加即可</p>
<pre><code class="shell">###修改之前我们先装一下 vim
apt-get update

apt-get install -y vim 

###修改zoo.fcg文件
vim /conf/zoo.fcg

clientPort=2181
</code></pre>
<ul>
<li><p>完事之后<strong>重启</strong>zoo1</p>
  <img data-src="/2022/10/15/tools/Zookeeper-tool/1645780920291.png" class="" width="1645780920291">

<p>  成功！！</p>
</li>
</ul>
<h6 id="4、查看所有zookeeper的状态"><a href="#4、查看所有zookeeper的状态" class="headerlink" title="4、查看所有zookeeper的状态"></a>4、查看所有zookeeper的状态</h6><pre><code class="shell">docker exec -it zoo3 bash ./bin/zkServer.sh status
</code></pre>
<h6 id="5、进去客户端"><a href="#5、进去客户端" class="headerlink" title="5、进去客户端"></a>5、进去客户端</h6><pre><code class="shell">docker exec -it zoo3 zkCli.sh
</code></pre>
]]></content>
      <categories>
        <category>工具软件安装</category>
      </categories>
  </entry>
  <entry>
    <title>docker安装</title>
    <url>/2022/10/15/tools/docker-tool/</url>
    <content><![CDATA[<h3 id="Docker安装（Linux）"><a href="#Docker安装（Linux）" class="headerlink" title="Docker安装（Linux）"></a>Docker安装（Linux）</h3><p>docker官网，自己选定自己的Linux版本，按照官方文档配置即可，以下CentOS7的</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmRvY2tlci5jb20vZW5naW5lL2luc3RhbGwvY2VudG9zLw==">https://docs.docker.com/engine/install/centos/</span></p>
<h4 id="1、卸载原有的环境："><a href="#1、卸载原有的环境：" class="headerlink" title="1、卸载原有的环境："></a>1、卸载原有的环境：</h4><pre><code class="shell">sudo yum remove docker \
                  docker-client \
                  docker-client-latest \
                  docker-common \
                  docker-latest \
                  docker-latest-logrotate \
                  docker-logrotate \
                  docker-selinux \
                  docker-engine-selinux \
                  docker-engine
</code></pre>
<h4 id="2、安装对应的依赖环境和镜像地址"><a href="#2、安装对应的依赖环境和镜像地址" class="headerlink" title="2、安装对应的依赖环境和镜像地址"></a>2、安装对应的依赖环境和镜像地址</h4><pre><code class="shell">sudo yum install -y yum-utils 
</code></pre>
<p>官方安装(慢)</p>
<pre><code class="shell">sudo yum-config-manager \ --add-repo \ https://download.docker.com/linux/centos/docker-ce.repo
</code></pre>
<p>安装过慢设置镜像 </p>
<pre><code class="shell">sudo yum-config-manager \ --add-repo \ http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo
</code></pre>
<h4 id="3、直接安装docker-CE"><a href="#3、直接安装docker-CE" class="headerlink" title="3、直接安装docker CE"></a>3、直接安装docker CE</h4><pre><code class="shell">sudo yum install -y docker-ce docker-ce-cli containerd.io
</code></pre>
<p>报错时，大概率为<strong>镜像仓库问题</strong> ，直接执行 <strong>步骤五</strong> 的补充，再安装</p>
<h4 id="4、启动docker服务"><a href="#4、启动docker服务" class="headerlink" title="4、启动docker服务"></a>4、启动docker服务</h4><pre><code class="shell">sudo systemctl start docker 
</code></pre>
<h4 id="5、查看docker的版本"><a href="#5、查看docker的版本" class="headerlink" title="5、查看docker的版本"></a>5、查看docker的版本</h4><pre><code class="shell">sudo docker version 
</code></pre>
<p>**补充：通过官方的镜像地址下载docker会比较慢， **</p>
<ul>
<li>配置阿里云的镜像地址： <strong>经历过3的镜像库问题也就是配置阿里云镜像地址</strong></li>
</ul>
<pre><code class="shell">yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo
</code></pre>
<ul>
<li>yum更新下即可：</li>
</ul>
<pre><code class="shell">yum makecache fast 
</code></pre>
<h4 id="6、开机启动docker"><a href="#6、开机启动docker" class="headerlink" title="6、开机启动docker"></a>6、开机启动docker</h4><pre><code class="shell">sudo systemctl enable docker
</code></pre>
<ul>
<li>补充：docker pull 下载镜像太慢，更换源进行网络加速的解决方案</li>
</ul>
<pre><code class="shell">步骤1：
sudo mkdir -p /etc/docker

步骤2：
sudo tee /etc/docker/daemon.json &lt;&lt;-&#39;EOF&#39;
&#123;
  &quot;registry-mirrors&quot;: [&quot;https://glhlrb75.mirror.aliyuncs.com&quot;]
&#125;
EOF
或者（老师的）
sudo tee /etc/docker/daemon.json &lt;&lt;-&#39;EOF&#39;
&#123; 
    &quot;registry-mirrors&quot;: [&quot;https://v9j5rufo.mirror.aliyuncs.com&quot;] 
&#125;
EOF

步骤3：
sudo systemctl daemon-reload

步骤4：
sudo systemctl restart docker
</code></pre>
<h4 id="7、使用"><a href="#7、使用" class="headerlink" title="7、使用"></a>7、使用</h4><p><a href="https://blog.csdn.net/qq_25760623/article/details/88657491"><strong>阿里云安装docker：</strong></a></p>
<p> <span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI1NzYwNjIzL2FydGljbGUvZGV0YWlscy84ODY1NzQ5MQ==">https://blog.csdn.net/qq_25760623/article/details/88657491</span> </p>
<h3 id="Docker-Compose安装（Linux）"><a href="#Docker-Compose安装（Linux）" class="headerlink" title="Docker-Compose安装（Linux）"></a>Docker-Compose安装（Linux）</h3><h4 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h4><p>官网地址：<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmRvY2tlci5jb20vY29tcG9zZQ==">https://docs.docker.com/compose</span> </p>
<p>#<strong>推荐</strong>： 国内地址：<span class="exturl" data-url="aHR0cDovL2dldC5kYW9jbG91ZC5pby8jaW5zdGFsbC1jb21wb3Nl">http://get.daocloud.io/#install-compose</span></p>
<pre><code class="shell">sudo curl -L &quot;https://github.com/docker/compose/releases/download/1.29.2/docker- compose-$(uname -s)-$(uname -m)&quot; -o /usr/local/bin/docker-compose
</code></pre>
<p>速度比较慢的话使用下面的地址： </p>
<pre><code class="shell">curl -L https://get.daocloud.io/docker/compose/releases/download/1.25.0/docker- compose-`uname -s`-`uname -m` &gt; /usr/local/bin/docker-compose
</code></pre>
<p>修改文件夹权限 </p>
<pre><code class="shell">chmod +x /usr/local/bin/docker-compose
</code></pre>
<p>建立软连接 </p>
<pre><code class="shell">ln -s /usr/local/bin/docker-compose /usr/bin/docker-compose
</code></pre>
<p>校验是否安装成功</p>
<pre><code class="shell">docker-compose --version
</code></pre>
<h4 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h4><p><strong>手动下载 docker-compose 到本地，然后上传到 linux 服务器的 &#x2F;usr&#x2F;local&#x2F;bin 路径下</strong></p>
<p>（1）百度网盘：链接: <span class="exturl" data-url="aHR0cHM6Ly9wYW4uYmFpZHUuY29tL3MvMW9fMlhzSUxmd2NBN21Sbi1mN0Exd0E=">https://pan.baidu.com/s/1o_2XsILfwcA7mRn-f7A1wA</span> 提取码: qiue  —— 网盘中 docker-compose 版本：2.2.2</p>
<p>（2）也可以去GitHub上下：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2RvY2tlci9jb21wb3NlL3JlbGVhc2Vz">https://github.com/docker/compose/releases</span></p>
<img data-src="/2022/10/15/tools/docker-tool/1376119-20211222005944642-1364547608.png" class="">




<ol start="5">
<li>重命名：</li>
</ol>
<p>mv docker-compose-linux-x86_64 docker-compose</p>
<ol start="6">
<li>授权：</li>
</ol>
<p> chmod +x .&#x2F;docker-compose </p>
<ol start="7">
<li>查看版本：</li>
</ol>
<p>docker-compose –version</p>
<img data-src="/2022/10/15/tools/docker-tool/1376119-20211222005757511-1189151957.png" class="">










<h4 id="升级（方式三）"><a href="#升级（方式三）" class="headerlink" title="升级（方式三）"></a>升级（方式三）</h4><ul>
<li>下载，命令如下👇：</li>
</ul>
<pre><code class="shell">sudo curl -L https://get.daocloud.io/docker/compose/releases/download/1.26.2/docker-compose-`uname -s`-`uname -m` &gt; /usr/local/bin/docker-compose
</code></pre>
<p>#&gt; 因Github国内访问不太稳定所以使用DaoCloud提供加速：<span class="exturl" data-url="aHR0cDovL2dldC5kYW9jbG91ZC5pby8jaW5zdGFsbC1jb21wb3Nl">链接</span>，你<strong>可以通过URL中的版本号，自定义下载你所需要的版本文件。</strong></p>
<ul>
<li>对命令进行一个授权</li>
</ul>
<pre><code class="shell">sudo chmod +x /usr/local/bin/docker-compose
</code></pre>
<ul>
<li>查看compose版本命令</li>
</ul>
<pre><code class="shell">docker-compose --version
</code></pre>
<ul>
<li>卸载</li>
</ul>
<pre><code class="shell">sudo rm /usr/local/bin/docker-compose
</code></pre>
]]></content>
      <categories>
        <category>工具软件安装</category>
      </categories>
  </entry>
  <entry>
    <title>python</title>
    <url>/2022/10/15/tools/python-tool/</url>
    <content><![CDATA[<h3 id="Python升级"><a href="#Python升级" class="headerlink" title="Python升级"></a>Python升级</h3><h4 id="一、查看当前python版本"><a href="#一、查看当前python版本" class="headerlink" title="一、查看当前python版本"></a>一、<strong>查看当前python版本</strong></h4><pre><code>#[root@ansible ~]# python -V
Python 2.7.5
</code></pre>
<h4 id="二、下载新的python包并安装"><a href="#二、下载新的python包并安装" class="headerlink" title="二、下载新的python包并安装"></a>二、<strong>下载新的python包并安装</strong></h4><p>​	进入python官网（<span class="exturl" data-url="aHR0cHM6Ly93d3cucHl0aG9uLm9yZyks6YCJ5oup6ZyA6KaB55qE54mI5pysLuatpOWkhOaIkemAieaLqeW9k+WJjeacgOaWsOeJiOacrHB5dGhvbjMuNi4xLw==">https://www.python.org），选择需要的版本。此处我选择当前最新版本Python3.6.1</span></p>
<pre><code>yum install gcc gcc-c++ -y

wget https://www.python.org/ftp/python/3.7.3/Python-3.7.3.tar.xz

tar xvf Python-3.7.3.tar.xz 

cd Python-3.7.3/

 ./configure
 
make

make install
</code></pre>
<h4 id="三、验证"><a href="#三、验证" class="headerlink" title="三、验证"></a>三、<strong>验证</strong></h4><pre><code>#python -V     #一个是旧版本，一个是新版本
Python 2.7.5
### python3 -V
Python 3.7.3
</code></pre>
<h4 id="四、设置3-X为默认版本"><a href="#四、设置3-X为默认版本" class="headerlink" title="四、设置3.X为默认版本"></a>四、<strong>设置3.X为默认版本</strong></h4><p>​	查看 Python 的路径，在 &#x2F;usr&#x2F;bin 下面。可以看到 python 链接的是 python 2.7，所以，执行 python 就相当于执行 python 2.7。</p>
<pre><code>#[root@ansible ~]# ls -al /usr/bin | grep python
-rwxr-xr-x.   1 root root       11232 Dec  2  2016 abrt-action-analyze-python
lrwxrwxrwx.   1 root root           7 May 26  2017 python -&gt; python2
lrwxrwxrwx.   1 root root           9 May 26  2017 python2 -&gt; python2.7
-rwxr-xr-x.   1 root root        7136 Nov  6  2016 python2.7
</code></pre>
<p>将原来 python 的软链接重命名：</p>
<pre><code>  mv /usr/bin/python /usr/bin/python.bak
</code></pre>
<p>将 python 链接至 python3：</p>
<pre><code>  ln -s /usr/local/bin/python3 /usr/bin/python
</code></pre>
<h4 id="五、配置yum"><a href="#五、配置yum" class="headerlink" title="五、配置yum"></a>五、<strong>配置yum</strong></h4><p>​	升级 Python 之后，由于将默认的 python 指向了 python3，yum 不能正常使用，需要编辑 yum 的配置文件，此时：</p>
<pre><code>#[root@ansible-admin Python-3.7.3]# yum list
  File &quot;/usr/bin/yum&quot;, line 30
    except KeyboardInterrupt, e:

SyntaxError: invalid syntax
</code></pre>
<p>​	修改&#x2F;usr&#x2F;bin&#x2F;yum和&#x2F;usr&#x2F;libexec&#x2F;urlgrabber-ext-down，将 #!&#x2F;usr&#x2F;bin&#x2F;python 改为 #!&#x2F;usr&#x2F;bin&#x2F;python2.7，保存退出即可。</p>
<blockquote>
<p>vim &#x2F;usr&#x2F;bin&#x2F;yum</p>
<p>vim &#x2F;usr&#x2F;libexec&#x2F;urlgrabber-ext-down</p>
</blockquote>
]]></content>
      <categories>
        <category>工具软件安装</category>
      </categories>
  </entry>
  <entry>
    <title>redis</title>
    <url>/2022/10/15/tools/redis-tool/</url>
    <content><![CDATA[<h3 id="redis安装"><a href="#redis安装" class="headerlink" title="redis安装"></a>redis安装</h3><h4 id="——1"><a href="#——1" class="headerlink" title="——1"></a>——1</h4><h5 id="1-安装依赖C语言依赖"><a href="#1-安装依赖C语言依赖" class="headerlink" title="1.安装依赖C语言依赖"></a>1.安装依赖C语言依赖</h5><p>​	redis使用C语言编写，所以需要安装C语言库</p>
<pre><code> yum install -y gcc-c++ automake autoconf libtool make tcl 
</code></pre>
<p>​	</p>
<h5 id="2-上传并解压"><a href="#2-上传并解压" class="headerlink" title="2.上传并解压"></a>2.上传并解压</h5><p>​	把redis-5.0.5.tar.gz上传到&#x2F;usr&#x2F;local&#x2F;tmp中，解压文件</p>
<pre><code> cd /usr/local/tmp

 tar zxf redis-5.0.5.tar.gz
</code></pre>
<h5 id="3-编译并安装"><a href="#3-编译并安装" class="headerlink" title="3.编译并安装"></a>3.编译并安装</h5><p>​	进入解压文件夹</p>
<pre><code>  cd /usr/local/tmp/redis-5.0.5/
</code></pre>
<p>​	编译</p>
<pre><code> make
</code></pre>
<p>​	安装	</p>
<pre><code> make install PREFIX=/usr/local/redis
</code></pre>
<h5 id="4-开启守护进程"><a href="#4-开启守护进程" class="headerlink" title="4.开启守护进程"></a>4.开启守护进程</h5><p>​	复制cd &#x2F;usr&#x2F;local&#x2F;tmp&#x2F;redis-5.0.5&#x2F;中redis.conf配置文件	</p>
<pre><code> cp redis.conf /usr/local/redis/bin/
</code></pre>
<p> <strong>修改配置文件</strong>	</p>
<pre><code> cd /usr/local/redis/bin/

 vim redis.conf
</code></pre>
<p>​	把daemonize的值由no修改为yes</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/onlymarryu/typora-ims-test@master/Redis-01.jpg"></p>
<h5 id="5-修改外部访问"><a href="#5-修改外部访问" class="headerlink" title="5.修改外部访问"></a>5.修改外部访问</h5><p>​	在redis5中需要修改配置文件redis.conf允许外部访问。需要修改两处。</p>
<p>​	注释掉下面</p>
<p>​	bind 127.0.0.1</p>
<pre><code> bind 127.0.0.1
</code></pre>
<p>​	protected-mode yes 改成 no</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/onlymarryu/typora-ims-test@master/Redis-02.jpg"></p>
<h5 id="6-启动并测试"><a href="#6-启动并测试" class="headerlink" title="6.启动并测试"></a>6.启动并测试</h5><p>​	启动redis</p>
<pre><code class="shell">./redis-server redis.conf
</code></pre>
<p>​	重启redis</p>
<pre><code>./redis-cli shutdown
./redis-server redis.conf
</code></pre>
<p>​	启动客户端工具</p>
<p>​	在redis5中客户端工具对命令会有提供功能。</p>
<pre><code class="shell">./redis-cli 
</code></pre>
<h4 id="——2"><a href="#——2" class="headerlink" title="——2"></a>——2</h4><h5 id="1、拉取镜像文件"><a href="#1、拉取镜像文件" class="headerlink" title="1、拉取镜像文件"></a>1、拉取镜像文件</h5><pre><code class="shell">docker pull redis[:(版本号)]
</code></pre>
<h5 id="2、去gitee库中下载redis配置文件（docker不自带配置文件）【也可不进行此步骤】"><a href="#2、去gitee库中下载redis配置文件（docker不自带配置文件）【也可不进行此步骤】" class="headerlink" title="2、去gitee库中下载redis配置文件（docker不自带配置文件）【也可不进行此步骤】"></a>2、去gitee库中下载redis配置文件（docker不自带配置文件）【也可不进行此步骤】</h5><p><strong>建议看完，先别操作，再看三，看完三之后再决定如何操作</strong></p>
<p>然后按照文章内容进行，忽略下载。</p>
<p>文章地址： <span class="exturl" data-url="aHR0cHM6Ly93d3cuamI1MS5uZXQvYXJ0aWNsZS8yMDMyNzQuaHRt">https://www.jb51.net/article/203274.htm</span> </p>
<p>、</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/onlymarryu/typora-ims-test@master/1645177895314.png" alt="1645177895314"></p>
<p> <strong>docker 镜像中没有redis.conf文件，要自己配置</strong> </p>
<pre><code class="undefined">git pull --rebase https://gitee.com/zjj3366/mydemo.git master
</code></pre>
<h5 id="3、创建一个redis-服务容器"><a href="#3、创建一个redis-服务容器" class="headerlink" title="3、创建一个redis 服务容器"></a>3、创建一个redis 服务容器</h5><p><strong>第二步进行了的</strong></p>
<pre><code class="shell">docker run -p 6379:6379 \
--name myredis  \
-v /usr/local/docker/redis.conf:/etc/redis/redis.conf   \
-v /usr/local/docker/data:/data  \
-d redis  \
redis-server  /etc/redis/redis.conf  \
--appendonly yes
</code></pre>
<p><strong>第二步没有进行的</strong></p>
<pre><code class="shell">docker run -p 6379:6379  \
--name myredis  \
-v /root/myredis/data:/data \
-v /root/myredis/conf/redis.conf:/etc/redis/redis.conf  \
-d redis:4.0  \
redis-server /etc/redis/redis.conf  \
--appendonly yes
</code></pre>
<p><strong>区别：</strong></p>
<p>​	其实也没有什么区别，只是映射的文件不同，也可以将第二步的文件直接创建到第二种创建服务容器的配置文件地址中去，这样也可使用第二个创建方式。</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/onlymarryu/typora-ims-test@master/1645177877202.png" alt="1645177877202"></p>
<p><img data-src="https://cdn.jsdelivr.net/gh/onlymarryu/typora-ims-test@master/1645177918077.png" alt="1645177918077"></p>
]]></content>
      <categories>
        <category>工具软件安装</category>
      </categories>
  </entry>
  <entry>
    <title>所有工具安装合集</title>
    <url>/2022/10/15/tools/tools-All/</url>
    <content><![CDATA[<div align='center' ><font size='70'>工具安装</font></div>
# 目录

<p>[TOC]</p>
<h1 id="注解："><a href="#注解：" class="headerlink" title="注解："></a>注解：</h1><ul>
<li><p>——1 .x：单机安装</p>
</li>
<li><p>——2 .x：Docker安装</p>
</li>
<li><p>X ：方式 X  ,default&#x3D;1 不写</p>
</li>
<li><p><strong>注所有所需文件均可在gitee上找到</strong></p>
</li>
</ul>
<h1 id="———————————————"><a href="#———————————————" class="headerlink" title="———————————————"></a>———————————————</h1><h1 id="PATH———Linux"><a href="#PATH———Linux" class="headerlink" title="PATH———Linux"></a>PATH———Linux</h1><h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><h3 id="CentOS–7"><a href="#CentOS–7" class="headerlink" title="CentOS–7"></a>CentOS–7</h3><p><strong>1.下载镜像文件</strong></p>
<p>  <span class="exturl" data-url="aHR0cHM6Ly9taXJyb3JzLnR1bmEudHNpbmdodWEuZWR1LmNuLw=="> 清华大学开源软件镜像站</span>  </p>
<p><strong>2.开始安装</strong></p>
<img data-src="/2022/10/15/tools/tools-All/1646489101763.png" class="">








<img data-src="/2022/10/15/tools/tools-All/1646489187835.png" class="">






<img data-src="/2022/10/15/tools/tools-All/1646489210450.png" class="">








<img data-src="/2022/10/15/tools/tools-All/1646489375149.png" class="">








<img data-src="/2022/10/15/tools/tools-All/1646489450527.png" class="">






<p><strong>3.开始进去虚拟机配置我们的软件</strong></p>
<p><strong>3.1语言</strong></p>
<img data-src="/2022/10/15/tools/tools-All/1646489591914.png" class="">




<p><strong>3.2时区、软件选择</strong></p>
<p>软件选择：按照自己的需求选，第一次多选也不要少选</p>
<img data-src="/2022/10/15/tools/tools-All/1646489600666.png" class="">




<p>4.硬、软配置完成，开始安装，同时要创建管理员Root 和 基础用户</p>












<p>5.安装成功</p>









<p><strong>系统配置</strong></p>
<div name="Linux_install_centos7">进入系统后~</div>
1、首先配置网络

<p>要先切换到 root 用户上去，不然没权限。</p>
<pre><code class="shell">方式一
sudo -i
password:当前普通用户密码

方式二
su -
password：root用户密码
</code></pre>
<p> 将  **ONBOOT ** 改为 yes ： </p>
<pre><code class="shell"> vim /etc/sysconfig/network-scripts/ifcfg-ens33
</code></pre>







<p>重启网络</p>
<pre><code class="shell"># CentOS6
service network restart
#CentOS7
systemlctl restart network 

# 检查是否通畅
ping 114.114.114.114
</code></pre>
<p>2、 安装net-tools 和 vim（<strong>有的话可直接跳过</strong>）</p>
<pre><code class="shell">yum install -y net-tools vim
</code></pre>
<p>检查自己的ip</p>
<pre><code class="shell">ifconfig
</code></pre>







<p>3 启动sshd服务</p>
<pre><code class="shell">service sshd start
</code></pre>
<div name="Linux_minInstall_4"></div >
4、修改登录，让Root用户直接登录

<p><a href="#problem-6">具体步骤</a>   		</p>
<div name="Linux_minInstall_5"></div >
5、修改DNS连接,让xshell访问快一点

<p><a href="#problem-5">具体步骤</a></p>
<p>6、 <strong>关闭指定端口防火墙：</strong> </p>
<pre><code class="shell">systemctl status firewalld  

#开启80端口

firewall-cmd --zone=public --add-port=80/tcp --permanent  

#开启3306端口

firewall-cmd --zone=public --add-port=3306/tcp --permanent  

#重启防火墙：

firewall-cmd --reload

关闭防火墙 ，重启失效(Linux系统一重启Linux中的防火墙又会被开起)
service firewalld stop
禁用防火墙，永久有效
systemctl disable firewalld 或者  systemctl disable firewalld.service
启动防火墙 (对禁用的防火墙进行启动)
systemctl enable firewalld
</code></pre>
<h2 id="Docker安装"><a href="#Docker安装" class="headerlink" title="Docker安装"></a>Docker安装</h2><p>docker官网，自己选定自己的Linux版本，按照官方文档配置即可，以下CentOS7的</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmRvY2tlci5jb20vZW5naW5lL2luc3RhbGwvY2VudG9zLw==">https://docs.docker.com/engine/install/centos/</span></p>
<h4 id="1、卸载原有的环境："><a href="#1、卸载原有的环境：" class="headerlink" title="1、卸载原有的环境："></a>1、卸载原有的环境：</h4><pre><code class="shell">sudo yum remove docker \
                  docker-client \
                  docker-client-latest \
                  docker-common \
                  docker-latest \
                  docker-latest-logrotate \
                  docker-logrotate \
                  docker-selinux \
                  docker-engine-selinux \
                  docker-engine
</code></pre>
<h4 id="2、安装对应的依赖环境和镜像地址"><a href="#2、安装对应的依赖环境和镜像地址" class="headerlink" title="2、安装对应的依赖环境和镜像地址"></a>2、安装对应的依赖环境和镜像地址</h4><pre><code class="shell">sudo yum install -y yum-utils 
</code></pre>
<p>官方安装(慢)</p>
<pre><code class="shell">sudo yum-config-manager \ --add-repo \ https://download.docker.com/linux/centos/docker-ce.repo
</code></pre>
<p>安装过慢设置镜像 </p>
<pre><code class="shell">sudo yum-config-manager \ --add-repo \ http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo
</code></pre>
<h4 id="3、直接安装docker-CE"><a href="#3、直接安装docker-CE" class="headerlink" title="3、直接安装docker CE"></a>3、直接安装docker CE</h4><pre><code class="shell">sudo yum install -y docker-ce docker-ce-cli containerd.io
</code></pre>
<p>报错时，大概率为<strong>镜像仓库问题</strong> ，直接执行 <strong>步骤五</strong> 的补充，再安装</p>
<h4 id="4、启动docker服务"><a href="#4、启动docker服务" class="headerlink" title="4、启动docker服务"></a>4、启动docker服务</h4><pre><code class="shell">systemctl start docker 
</code></pre>
<h4 id="5、查看docker的版本"><a href="#5、查看docker的版本" class="headerlink" title="5、查看docker的版本"></a>5、查看docker的版本</h4><pre><code class="shell">docker version 
</code></pre>
<p>**补充：通过官方的镜像地址下载docker会比较慢， **</p>
<ul>
<li>配置阿里云的镜像地址： <strong>经历过3的镜像库问题也就是配置阿里云镜像地址</strong></li>
</ul>
<pre><code class="shell">yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo
</code></pre>
<ul>
<li>yum更新下即可：</li>
</ul>
<pre><code class="shell">yum makecache fast 
</code></pre>
<h4 id="6、开机启动docker"><a href="#6、开机启动docker" class="headerlink" title="6、开机启动docker"></a>6、开机启动docker</h4><pre><code class="shell">sudo systemctl enable docker
</code></pre>
<ul>
<li>补充：docker pull 下载镜像太慢，更换源进行网络加速的解决方案</li>
</ul>
<pre><code class="shell">步骤1：
sudo mkdir -p /etc/docker

步骤2：
sudo tee /etc/docker/daemon.json &lt;&lt;-&#39;EOF&#39;
&#123;
  &quot;registry-mirrors&quot;: [&quot;https://glhlrb75.mirror.aliyuncs.com&quot;]
&#125;
EOF
或者（老师的）
sudo tee /etc/docker/daemon.json &lt;&lt;-&#39;EOF&#39;
&#123; 
    &quot;registry-mirrors&quot;: [&quot;https://v9j5rufo.mirror.aliyuncs.com&quot;] 
&#125;
EOF

步骤3：
sudo systemctl daemon-reload

步骤4：
sudo systemctl restart docker
</code></pre>
<h4 id="7、使用"><a href="#7、使用" class="headerlink" title="7、使用"></a>7、使用</h4><p><a href="https://blog.csdn.net/qq_25760623/article/details/88657491"><strong>阿里云安装docker：</strong></a></p>
<p> <span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI1NzYwNjIzL2FydGljbGUvZGV0YWlscy84ODY1NzQ5MQ==">https://blog.csdn.net/qq_25760623/article/details/88657491</span> </p>
<h2 id="Docker-Compose安装"><a href="#Docker-Compose安装" class="headerlink" title="Docker-Compose安装"></a>Docker-Compose安装</h2><h3 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h3><p>官网地址：<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmRvY2tlci5jb20vY29tcG9zZQ==">https://docs.docker.com/compose</span> </p>
<p><strong>推荐</strong>： 国内地址：<span class="exturl" data-url="aHR0cDovL2dldC5kYW9jbG91ZC5pby8jaW5zdGFsbC1jb21wb3Nl">http://get.daocloud.io/#install-compose</span></p>
<pre><code class="shell">sudo curl -L &quot;https://github.com/docker/compose/releases/download/1.29.2/docker- compose-$(uname -s)-$(uname -m)&quot; -o /usr/local/bin/docker-compose
</code></pre>
<p>速度比较慢的话使用下面的地址： </p>
<pre><code class="shell">curl -L https://get.daocloud.io/docker/compose/releases/download/1.25.0/docker- compose-`uname -s`-`uname -m` &gt; /usr/local/bin/docker-compose
</code></pre>
<p>修改文件夹权限 </p>
<pre><code class="shell">chmod +x /usr/local/bin/docker-compose
</code></pre>
<p>建立软连接 </p>
<pre><code class="shell">ln -s /usr/local/bin/docker-compose /usr/bin/docker-compose
</code></pre>
<p>校验是否安装成功</p>
<pre><code class="shell">docker-compose --version
</code></pre>
<h3 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h3><p><strong>手动下载 docker-compose 到本地，然后上传到 linux 服务器的 &#x2F;usr&#x2F;local&#x2F;bin 路径下</strong></p>
<p>（1）百度网盘：链接: <span class="exturl" data-url="aHR0cHM6Ly9wYW4uYmFpZHUuY29tL3MvMW9fMlhzSUxmd2NBN21Sbi1mN0Exd0E=">https://pan.baidu.com/s/1o_2XsILfwcA7mRn-f7A1wA</span> 提取码: qiue  —— 网盘中 docker-compose 版本：2.2.2</p>
<p>（2）也可以去GitHub上下：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2RvY2tlci9jb21wb3NlL3JlbGVhc2Vz">https://github.com/docker/compose/releases</span></p>
<p><img data-src="https://tools-all2020.cnblogs.com/blog/1376119/202112/1376119-20211222005944642-1364547608.png" alt="img"></p>
<ol start="5">
<li>重命名：</li>
</ol>
<p>mv docker-compose-linux-x86_64 docker-compose</p>
<ol start="6">
<li>授权：</li>
</ol>
<p> chmod +x .&#x2F;docker-compose </p>
<ol start="7">
<li>查看版本：</li>
</ol>
<p>docker-compose –version</p>
<p><img data-src="https://tools-all2020.cnblogs.com/blog/1376119/202112/1376119-20211222005757511-1189151957.png" alt="img"></p>
<h3 id="升级（方式三）"><a href="#升级（方式三）" class="headerlink" title="升级（方式三）"></a>升级（方式三）</h3><ul>
<li>下载，命令如下👇：</li>
</ul>
<pre><code class="shell">sudo curl -L https://get.daocloud.io/docker/compose/releases/download/1.26.2/docker-compose-`uname -s`-`uname -m` &gt; /usr/local/bin/docker-compose
</code></pre>
<blockquote>
<p>因Github国内访问不太稳定所以使用DaoCloud提供加速：<span class="exturl" data-url="aHR0cDovL2dldC5kYW9jbG91ZC5pby8jaW5zdGFsbC1jb21wb3Nl">链接</span>，你<strong>可以通过URL中的版本号，自定义下载你所需要的版本文件。</strong></p>
</blockquote>
<ul>
<li>对命令进行一个授权</li>
</ul>
<pre><code class="shell">sudo chmod +x /usr/local/bin/docker-compose
</code></pre>
<ul>
<li>查看compose版本命令</li>
</ul>
<pre><code class="shell">docker-compose --version
</code></pre>
<ul>
<li>卸载</li>
</ul>
<pre><code class="shell">sudo rm /usr/local/bin/docker-compose
</code></pre>
<h2 id="Python升级"><a href="#Python升级" class="headerlink" title="Python升级"></a>Python升级</h2><h4 id="一、查看当前python版本"><a href="#一、查看当前python版本" class="headerlink" title="一、查看当前python版本"></a>一、<strong>查看当前python版本</strong></h4><pre><code>[root@ansible ~]# python -V
Python 2.7.5
</code></pre>
<h4 id="二、下载新的python包并安装"><a href="#二、下载新的python包并安装" class="headerlink" title="二、下载新的python包并安装"></a>二、<strong>下载新的python包并安装</strong></h4><p>​	进入python官网（<span class="exturl" data-url="aHR0cHM6Ly93d3cucHl0aG9uLm9yZyks6YCJ5oup6ZyA6KaB55qE54mI5pysLuatpOWkhOaIkemAieaLqeW9k+WJjeacgOaWsOeJiOacrHB5dGhvbjMuNi4xLw==">https://www.python.org），选择需要的版本。此处我选择当前最新版本Python3.6.1</span></p>
<pre><code>yum install gcc gcc-c++ -y

wget https://www.python.org/ftp/python/3.7.3/Python-3.7.3.tar.xz

tar xvf Python-3.7.3.tar.xz 

cd Python-3.7.3/

 ./configure
 
make

make install
</code></pre>
<h4 id="三、验证"><a href="#三、验证" class="headerlink" title="三、验证"></a>三、<strong>验证</strong></h4><pre><code>#python -V     #一个是旧版本，一个是新版本
Python 2.7.5
# python3 -V
Python 3.7.3
</code></pre>
<h4 id="四、设置3-X为默认版本"><a href="#四、设置3-X为默认版本" class="headerlink" title="四、设置3.X为默认版本"></a>四、<strong>设置3.X为默认版本</strong></h4><p>​	查看 Python 的路径，在 &#x2F;usr&#x2F;bin 下面。可以看到 python 链接的是 python 2.7，所以，执行 python 就相当于执行 python 2.7。</p>
<pre><code>[root@ansible ~]# ls -al /usr/bin | grep python
-rwxr-xr-x.   1 root root       11232 Dec  2  2016 abrt-action-analyze-python
lrwxrwxrwx.   1 root root           7 May 26  2017 python -&gt; python2
lrwxrwxrwx.   1 root root           9 May 26  2017 python2 -&gt; python2.7
-rwxr-xr-x.   1 root root        7136 Nov  6  2016 python2.7
</code></pre>
<p>将原来 python 的软链接重命名：</p>
<pre><code>  mv /usr/bin/python /usr/bin/python.bak
</code></pre>
<p>将 python 链接至 python3：</p>
<pre><code>  ln -s /usr/local/bin/python3 /usr/bin/python
</code></pre>
<h4 id="五、配置yum"><a href="#五、配置yum" class="headerlink" title="五、配置yum"></a>五、<strong>配置yum</strong></h4><p>​	升级 Python 之后，由于将默认的 python 指向了 python3，yum 不能正常使用，需要编辑 yum 的配置文件，此时：</p>
<pre><code>[root@ansible-admin Python-3.7.3]# yum list
  File &quot;/usr/bin/yum&quot;, line 30
    except KeyboardInterrupt, e:

SyntaxError: invalid syntax
</code></pre>
<p>​	修改&#x2F;usr&#x2F;bin&#x2F;yum和&#x2F;usr&#x2F;libexec&#x2F;urlgrabber-ext-down，将 #!&#x2F;usr&#x2F;bin&#x2F;python 改为 #!&#x2F;usr&#x2F;bin&#x2F;python2.7，保存退出即可。</p>
<blockquote>
<p>vim &#x2F;usr&#x2F;bin&#x2F;yum</p>
<p>vim &#x2F;usr&#x2F;libexec&#x2F;urlgrabber-ext-down</p>
</blockquote>
<div name="jdk_install"></div>
## jdk安装

<h4 id="1、下载对应的版本"><a href="#1、下载对应的版本" class="headerlink" title="1、下载对应的版本"></a>1、下载对应的版本</h4><p><strong>1.1下载Linux对应版本的JDK</strong></p>
<pre><code class="shell">getconf  LONG_BIT
</code></pre>
<p><strong>1.2下载压缩文件</strong>   </p>
<blockquote>
<p>jdk-8u261-linux-x64.tar.gz         </p>
</blockquote>
<h4 id="2、解压压缩文件"><a href="#2、解压压缩文件" class="headerlink" title="2、解压压缩文件"></a>2、解压压缩文件</h4><pre><code class="shell">tar -xvf   jdk-8u261-linux-x64.tar.gz  -C  /usr/local/  
</code></pre>
<h4 id="3、配置环境变量"><a href="#3、配置环境变量" class="headerlink" title="3、配置环境变量"></a>3、配置环境变量</h4><pre><code class="shell">vim  /etc/profile

#自己选定的目录
export JAVA_HOME=/usr/local/jdk1.8.0_261
export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar
export PATH=$PATH:$JAVA_HOME/bin
</code></pre>
<h4 id="4、使用环境变量生效"><a href="#4、使用环境变量生效" class="headerlink" title="4、使用环境变量生效"></a>4、使用环境变量生效</h4><pre><code class="shell">source /etc/profile
</code></pre>
<p><a href="#perblem-1">长久生效</a></p>
<h4 id="5、测试JDK是否安装成功"><a href="#5、测试JDK是否安装成功" class="headerlink" title="5、测试JDK是否安装成功"></a>5、测试JDK是否安装成功</h4><pre><code class="shell">java -version
</code></pre>
<h2 id="Tomcat安装"><a href="#Tomcat安装" class="headerlink" title="Tomcat安装"></a>Tomcat安装</h2><h3 id="——1"><a href="#——1" class="headerlink" title="——1"></a>——1</h3><h4 id="1、下载Linux对应版本的Tomcat"><a href="#1、下载Linux对应版本的Tomcat" class="headerlink" title="1、下载Linux对应版本的Tomcat"></a>1、下载Linux对应版本的Tomcat</h4><p>​	  下载压缩文件     apache-tomcat-7.0.68.tar.gz         </p>
<h4 id="2、解压压缩文件-1"><a href="#2、解压压缩文件-1" class="headerlink" title="2、解压压缩文件"></a>2、解压压缩文件</h4><pre><code class="shell">tar -xvf   apache-tomcat-7.0.68.tar.gz -C /usr/local/  #解压到的路径 
</code></pre>
<h4 id="3、配置环境变量-1"><a href="#3、配置环境变量-1" class="headerlink" title="3、配置环境变量"></a>3、配置环境变量</h4><pre><code class="shell">vim  /etc/profile

#自己定义为位置
export CATALINA_BASE=/usr/local/apache-tomcat-7.0.68
export PATH=$CATALINA_BASE/bin:$PATH
</code></pre>
<h4 id="4、使用环境变量生效-1"><a href="#4、使用环境变量生效-1" class="headerlink" title="4、使用环境变量生效"></a>4、使用环境变量生效</h4><pre><code class="shell">source /etc/profile
</code></pre>
<h4 id="5、启动Tomcat服务"><a href="#5、启动Tomcat服务" class="headerlink" title="5、启动Tomcat服务"></a>5、启动Tomcat服务</h4><ul>
<li>注：要是远程访问你关注防火墙问题</li>
</ul>
<p>启动Tomcat服务：</p>
<pre><code class="shell">/usr/local/apache-tomcat-7.0.68/bin./startup.sh
</code></pre>
<p>启动Tomcat并输出启动日志 :</p>
<pre><code class="shell">/usr/local/apache-tomcat-7.0.68/bin/startup.sh &amp; tail -f  /usr/local/apache-tomcat-7.0.68/logs/catalina.out
</code></pre>
<div name="mysql_install">

<h2 id="MySQL-安装"><a href="#MySQL-安装" class="headerlink" title="MySQL 安装"></a>MySQL 安装</h2><h3 id="——1-1"><a href="#——1-1" class="headerlink" title="——1"></a>——1</h3><h4 id="1、卸载原来的版本"><a href="#1、卸载原来的版本" class="headerlink" title="1、卸载原来的版本"></a>1、卸载原来的版本</h4><h5 id="1、查看mysql的安装情况"><a href="#1、查看mysql的安装情况" class="headerlink" title="1、查看mysql的安装情况"></a>1、查看mysql的安装情况</h5><pre><code class="sh">rpm -qa | grep -i mysql
</code></pre>
<img data-src="/2022/10/15/tools/tools-All/1570605325400.png" class="">




<h5 id="2、删除上图安装的软件"><a href="#2、删除上图安装的软件" class="headerlink" title="2、删除上图安装的软件"></a>2、删除上图安装的软件</h5><pre><code class="sh">rpm -ev --nodeps mysql57-community-release-el5-7.noarch
rpm -ev --nodeps mysql-community-server-5.7.18-1.el5.x86_64
rpm -ev --nodeps mysql-community-client-5.7.18-1.el5.x86_64
rpm -ev --nodeps mysql-community-libs-5.7.18-1.el5.x86_64
rpm -ev --nodeps mysql-community-common-5.7.18-1.el5.x86_64
rpm -ev --nodeps mysql-5.7.18-1.el5.x86_64
rpm -ev --nodeps mysql-community-libs-compat-5.7.18-1.el5.x86_64
</code></pre>
<h5 id="3、都删除成功之后，查找相关的mysql的文件"><a href="#3、都删除成功之后，查找相关的mysql的文件" class="headerlink" title="3、都删除成功之后，查找相关的mysql的文件"></a>3、都删除成功之后，查找相关的mysql的文件</h5><pre><code class="sh">find / -name mysql
</code></pre>
<img data-src="/2022/10/15/tools/tools-All/1570605553095.png" class="">




<h5 id="4、删除全部文件"><a href="#4、删除全部文件" class="headerlink" title="4、删除全部文件"></a>4、删除全部文件</h5><pre><code class="sh">rm -rf /etc/selinux/targeted/active/modules/100/mysql
rm -rf /root/mysql
rm -rf /root/mysql/data/mysql
rm -rf /var/lib/mysql
rm -rf /var/lib/mysql/mysql
rm -rf /usr/share/mysql
</code></pre>
<h5 id="5、再次执行命令"><a href="#5、再次执行命令" class="headerlink" title="5、再次执行命令"></a>5、再次执行命令</h5><pre><code class="shell">rpm -qa | grep -i mysql
#如果没有显式则表示卸载完成
</code></pre>
<h4 id="2、删除mariadb-libs-不可省略"><a href="#2、删除mariadb-libs-不可省略" class="headerlink" title="2、删除mariadb-libs(不可省略)"></a>2、删除mariadb-libs(不可省略)</h4><pre><code class="sh"># 检查mariadb-libs
rpm -qa|grep mariadb
# 卸载mariadb-libs
yum remove mariadb-libs
</code></pre>
<h4 id="3、安装MySQL"><a href="#3、安装MySQL" class="headerlink" title="3、安装MySQL"></a>3、安装MySQL</h4><h5 id="1，输入："><a href="#1，输入：" class="headerlink" title="1，输入："></a>1，输入：</h5><p>wegt <span class="exturl" data-url="aHR0cHM6Ly9kZXYubXlzcWwuY29tL2dldC9teXNxbCVFNyU4OSU4OCVFNiU5QyVBQyVFNSU4RiVCNy1jb21tdW5pdHktcmVsZWFzZS1lbCVFNSVBNCVBNyVFNyU4OSU4OCVFNiU5QyVBQy0lRTUlQjAlOEYlRTclODklODglRTYlOUMlQUMubm9hcmNoLnJwbQ==">https://dev.mysql.com/get/mysql版本号-community-release-el大版本-小版本.noarch.rpm</span></p>
<pre><code class="sh">wget https://dev.mysql.com/get/mysql57-community-release-el5-7.noarch.rpm
</code></pre>
<h5 id="2、安装数据源"><a href="#2、安装数据源" class="headerlink" title="2、安装数据源"></a>2、安装数据源</h5><pre><code class="sh">yum install -y mysql57-community-release-el5-7.noarch.rpm
</code></pre>
<h5 id="3、查看mysql源是否安装成功"><a href="#3、查看mysql源是否安装成功" class="headerlink" title="3、查看mysql源是否安装成功"></a>3、查看mysql源是否安装成功</h5><pre><code class="sh">yum repolist enabled | grep &quot;mysql.*-community.*&quot;
</code></pre>
<h5 id="4、安装数据库"><a href="#4、安装数据库" class="headerlink" title="4、安装数据库"></a>4、安装数据库</h5><pre><code class="sh">yum install -y  mysql-community-server

# 如果过期可以在运行安装程序之前导入密钥，有了就不用了
rpm --import https://repo.mysql.com/RPM-GPG-KEY-mysql-2022
</code></pre>
<h5 id="5、启动mysql"><a href="#5、启动mysql" class="headerlink" title="5、启动mysql"></a>5、启动mysql</h5><pre><code class="sh"># centos7
systemctl restart mysqld
systemctl status mysqld


# centos6
service mysqld start
service mysqld status
</code></pre>
<h5 id="6、显示mysql的随机密码"><a href="#6、显示mysql的随机密码" class="headerlink" title="6、显示mysql的随机密码"></a>6、显示mysql的随机密码</h5><pre><code class="sh">grep &#39;temporary password&#39; /var/log/mysqld.log
</code></pre>
<img data-src="/2022/10/15/tools/tools-All/image-20220827193405451.png" class="">




<h5 id="7、登录并修改mysql密码"><a href="#7、登录并修改mysql密码" class="headerlink" title="7、登录并修改mysql密码"></a>7、登录并修改mysql密码</h5><p>登录：mysql -u root -p   		然后输入上面生成的密码</p>
<p><strong><em>修改自定义密码，设置新的密码，进入操作页面，修改密码策略可以修改成你想要的</em></strong></p>
<pre><code class="sql">-- ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;密码&#39;;

ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;Root_21root&#39;;

ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;root&#39;;
</code></pre>
<p><strong><em>失败了的话就修改策略，将策略降低一下就可以了</em></strong></p>
<p>查看密码策略：</p>
<pre><code class="sql">SHOW VARIABLES LIKE &#39;%password%&#39;;
</code></pre>
<p>修改密码策略</p>
<pre><code class="sql">-- 修改密码长度：（长度）
set global validate_password_length=1;
-- 修改密码等级：（等级）
set global validate_password_policy=0;
</code></pre>
<h4 id="4、其他配置"><a href="#4、其他配置" class="headerlink" title="4、其他配置"></a>4、其他配置</h4><h5 id="1-远程连接"><a href="#1-远程连接" class="headerlink" title="1.远程连接"></a>1.远程连接</h5><h6 id="方法一、创建一个用户-支持远程连接"><a href="#方法一、创建一个用户-支持远程连接" class="headerlink" title="方法一、创建一个用户 支持远程连接"></a>方法一、创建一个用户 支持远程连接</h6><p>①登录 ：mysql -u root -p</p>
<p>②创建用户： create user ‘aaa‘@’%’ identified by ‘123456’;</p>
<p>③授权所有权限给user这个新用户 ：grant all on <em>.</em> to ‘aaa‘@’%’;</p>
<p>④退出mysql：quit;</p>
<h6 id="方法二、设置root用户支持远程连接"><a href="#方法二、设置root用户支持远程连接" class="headerlink" title="方法二、设置root用户支持远程连接"></a>方法二、设置root用户支持远程连接</h6><p>①登录：mysql -u root -p （ 注：系统提示输入数据库root用户的密码，输入完成后即进入mysql控制台，这个命令的第一个mysql是执行命令，第二个mysql是系统数据名称，不一样的。）</p>
<p>②设置权限：</p>
<p>赋予权限格式： grant 权限 on 数据库对象 to 用户@IP(或者相应正则)</p>
<pre><code class="sql">-- 新建用户规则或者直接修改root用户的规则 ，2 选一
use mysql;

-- 这里表示赋予该用户所有数据库所有表（*.*表示所有表），%表示所有IP地址。
GRANT ALL PRIVILEGES ON *.* TO &#39;root&#39;@&#39;%&#39; IDENTIFIED BY &#39;123456&#39; WITH GRANT OPTION;
-- 使root能再任何host访问
update user set host = &#39;%&#39; where user = &#39;root&#39;;      

-- 刷新
FLUSH PRIVILEGES;
</code></pre>
<p>③查看：</p>
<pre><code class="sql">use mysql;
SELECT HOST,USER FROM USER;
</code></pre>
<img data-src="/2022/10/15/tools/tools-All/920952e9041b4af1a8a49eb64e0f4430.jpeg" class="">




<p> ④退出mysql：quit;</p>
<h5 id="2-开机自启"><a href="#2-开机自启" class="headerlink" title="2.开机自启"></a>2.开机自启</h5><pre><code class="sh"># 开机启动
systemctl enable mysql
# 关闭自动启动
systemctl disable mysqld
</code></pre>
<h3 id="——2"><a href="#——2" class="headerlink" title="——2"></a>——2</h3><h4 id="1、查询镜像"><a href="#1、查询镜像" class="headerlink" title="1、查询镜像"></a>1、查询镜像</h4><pre><code class="shell">docker search mysql
</code></pre>
<h4 id="2、拉取镜像"><a href="#2、拉取镜像" class="headerlink" title="2、拉取镜像"></a>2、拉取镜像</h4><pre><code class="shell">docker pull mysql:5.7
</code></pre>
<h4 id="3、构建容器"><a href="#3、构建容器" class="headerlink" title="3、构建容器"></a>3、构建容器</h4><p>先自己创建配置文件基础模板（<strong>要是后期要修改配置文件必须加入 模板中的两个元素，不然容器启动会出错</strong>）</p>
<pre><code class="shell">mkdir -p /root/mysql/conf
vim  /root/mysql/conf/my.cnf
</code></pre>
<p><strong>模板内容：</strong></p>
<pre><code class="shell">
# Copyright (c) 2016, 2021, Oracle and/or its affiliates.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License, version 2.0,
# as published by the Free Software Foundation.
#
# This program is also distributed with certain software (including
# but not limited to OpenSSL) that is licensed under separate terms,
# as designated in a particular file or component or in included license
# documentation.  The authors of MySQL hereby grant you an additional
# permission to link the program and your derivative works with the
# separately licensed software that they have included with MySQL.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License, version 2.0, for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA


!includedir /etc/mysql/conf.d/
!includedir /etc/mysql/mysql.conf.d/

[mysql]
default-character-set=utf8
[mysqld]
character_set_server=utf8
init_connect=&#39;SET NAMES utf8&#39;
lower_case_table_names = 1
</code></pre>
<p><strong>构建容器</strong></p>
<pre><code class="shell">docker run \
-p 3306:3306 \
-v /root/mysql/data:/var/lib/mysql \
-v /root/mysql/logs:/logs \
-v /root/mysql/conf/my.cnf:/etc/mysql/my.cnf \
-e MYSQL_ROOT_PASSWORD=root \
--name mysql \
--hostname node1 \
--restart=always \
-d mysql:5.7
</code></pre>
<p><strong>注</strong>：出错时将本地映射文件检查一下，要是不需要配置，只需映射直接删掉就可，以后再改配置文件</p>
<h4 id="4、进入容器"><a href="#4、进入容器" class="headerlink" title="4、进入容器"></a>4、进入容器</h4><pre><code class="shell">docker exec -it mysql /bin/bash
或者
docker exec -it mysql mysql -uroot -p
</code></pre>
<h4 id="5、查看远程连接"><a href="#5、查看远程连接" class="headerlink" title="5、查看远程连接"></a>5、查看远程连接</h4><p>还有一些方法也可以试一下</p>
<pre><code class="shell">1.赋予权限格式：grant 权限 on 数据库对象 to 用户@IP(或者相应正则)

　　　　注：可以赋予select,delete,update,insert,index等权限精确到某一个数据库某一个表。

　　　　GRANT ALL PRIVILEGES ON *.* TO &#39;用户名&#39;@&#39;%&#39; IDENTIFIED BY &#39;密码&#39; WITH GRANT OPTION;
      GRANT ALL PRIVILEGES ON *.* TO &#39;root&#39;@&#39;%&#39; IDENTIFIED BY &#39;123456&#39; WITH GRANT OPTION;

　　　　这里表示赋予该用户所有数据库所有表（*.*表示所有表），%表示所有IP地址。

2.刷新权限：FLUSH PRIVILEGES;

3.查看权限：select user,host from mysql.user;

二.意外
　　1.配置文件种指定了blind-address：
　　　　查看Mysql配置文件种（一般是/etc/my.cnf种）是否指定了blind-address，这表示只能是某个或某几个ip能连接。如果有就将它注释了，前面加#号注释。然后从启mysql。
    　重启mysql：service mysqld restart,如果安装的是Mariadb（我的就是）,则需要使用systemctl restart mariadb.service
    　
    2.防火墙的原因：
　　　　可能会报：ERROR 2003 (HY000): Can&#39;t connect to MySQL server on &#39;你要连接的IP&#39; (111)。

　　　　原因：1.可能是Mysql端口不对（默认是3306），只需加参数 -P 你的端口指定就行；
　　　　
　　　2.还有可能是有防火墙阻止，可以通过telnet来测试（可以直接关闭防火墙）。
　　　　　　　　　　防火墙相关命令：

　　　　　　　　　　　　（1）查看防火墙状态：service  iptables status或者systemctl status firewalld或者firewall-cmd --state

　　　　　　　　　　　　（2）暂时关闭防火墙：systemctl stop firewalld或者service  iptables stop或者systemctl stop firewalld.service

　　　　　　　　　　　　（3）永久关闭防火墙：systemctl disable firewalld或者chkconfig iptables off或者systemctl disable firewalld.service

　　　　　　　　　　　　（4）重启防火墙：systemctl enable firewalld或者service iptables restart  或者systemctl restart firewalld.service

 　　　　　　　　　　　　 (5)永久关闭后重启：chkconfig iptables on

　　

　　3.端口未开启：（我遇到的就是这个原因）
　　　　　　Mysql：ERROR 2003 (HY000) 110（连接超时）

　　　　　　查看你的服务器是否把对应端口打开，未打开启动就行了。　
　　　　　　
   4.Navicat连接MySQL，出现2059 - authentication plugin &#39;caching_sha2_password&#39;的解决方案
      
      0先进入容器，
      docker exec -it mysql mysql -uroot -p
      
      1#修改加密规则password是自己的密码，root也是登陆账户，下同。
      use mysql;
    ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;root&#39; PASSWORD EXPIRE NEVER; 
    
    2 #更新一下用户的密码 
    ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED WITH mysql_native_password BY &#39;root&#39;;
    
    3#刷新权限 
    FLUSH PRIVILEGES; 
    
    4#更新一下用户的密码
    ALTER USER &#39;root&#39;@&#39;%&#39; IDENTIFIED WITH mysql_native_password BY &#39;root&#39;; 
</code></pre>
<h3 id="——2-1"><a href="#——2-1" class="headerlink" title="——2.1"></a>——2.1</h3><p>前提安装了 docker-compose，配置  docker-comose.yml 文件</p>
<p>5.7：</p>
<pre><code class="yml">version: &quot;3.0&quot;
services:
  mysql8:
    image: mysql:5.7.32
    container_name: my_db57
    restart: always
    volumes:
      - ./db:/var/lib/mysql
      - ./conf/my.cnf:/etc/my.cnf
      # 数据库初始化脚本，当Mysql容器首次启动时，会在 /docker-entrypoint-initdb.d目录下扫描 .sh，.sql，.sql.gz类型的文件。如果这些类型的文件存在，将执行它们来初始化一个数据库；
      - ./init/:/docker-entrypoint-initdb.d/
    environment:
      - MYSQL_ROOT_PASSWORD=123456
      # 指定初始化sql文件的数据库，简单来书就是新建一个数据库
      - MYSQL_DATABASE=my_db
      - TZ=Asia/Shanghai
    ports:
      - 3311:3306
</code></pre>
<p>8.0</p>
<pre><code class="yml">version: &quot;3.0&quot;
services:
  mysql8:
    image: mysql:8.0.25
    container_name: my_db8
    restart: always
    volumes:
      - ./db:/var/lib/mysql
      - ./conf/my.cnf:/etc/my.cnf
      # 数据库初始化脚本，当Mysql容器首次启动时，会在 /docker-entrypoint-initdb.d目录下扫描 .sh，.sql，.sql.gz类型的文件。如果这些类型的文件存在，将执行它们来初始化一个数据库；
      - ./init/:/docker-entrypoint-initdb.d/
    environment:
      - MYSQL_ROOT_PASSWORD=123456
      # 指定初始化sql文件的数据库，简单来书就是新建一个数据库
      - MYSQL_DATABASE=my_db
      - TZ=Asia/Shanghai
    ports:
      - 3301:3306
</code></pre>
<p>配置文件 my.cnf </p>
<p>5.7：</p>
<pre><code class="shell">[mysql]
# 设置mysql客户端默认字符集
default-character-set=utf8mb4

[mysqld]
datadir=/var/lib/mysql
socket=/var/lib/mysql/mysql.sock

symbolic-links=0

log-error=/var/log/mysqld.log
pid-file=/var/run/mysqld/mysqld.pid
# 服务端使用的字符集默认为8比特编码的latin1字符集
character-set-server=utf8mb4

# 创建新表时将使用的默认存储引擎
default-storage-engine=INNODB
</code></pre>
<p>8.0：</p>
<pre><code class="shell">[mysql]
# 设置mysql客户端默认字符集
default-character-set=utf8mb4
[mysqld]
# 允许最大连接数
max_connections=200

# 服务端使用的字符集默认为8比特编码的latin1字符集
character-set-server=utf8mb4

# 创建新表时将使用的默认存储引擎
default-storage-engine=INNODB
</code></pre>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>1、Can’t create&#x2F;write to file ‘&#x2F;var&#x2F;run&#x2F;mysqld&#x2F;mysqld.pid</p>
<p>去配置文件中找到 errorlog的地址，查看错误日志</p>
<img data-src="/2022/10/15/tools/tools-All/20190602012200812.png" class="">




<p>错误原因为：&#x2F;var&#x2F;run&#x2F;mysqld&#x2F;目录的拥有者为root，mysql不能在其中创建文件</p>
<p>使用如下命令修改目录使用者</p>
<pre><code class="shell"># 先查看目录是否存在
ls -ld /var/run/mysqld/
# 权限
chown mysql.mysql /var/run/mysqld/
# 修改后重启mysql服务
/etc/init.d/mysqld start
</code></pre>
<h2 id="FastDFS安装"><a href="#FastDFS安装" class="headerlink" title="FastDFS安装"></a>FastDFS安装</h2><h3 id="——1-2"><a href="#——1-2" class="headerlink" title="——1"></a>——1</h3><h4 id="1-安装FastDFS依赖"><a href="#1-安装FastDFS依赖" class="headerlink" title="1.安装FastDFS依赖"></a>1.安装FastDFS依赖</h4><p>FastDFS是C语言开发的应用。安装必须使用 make , cmake 和 gcc编译器。</p>
<pre><code class="sh">  yum install -y make cmake gcc gcc-c++
</code></pre>
<h4 id="2-上传并解压libfastcommon-master"><a href="#2-上传并解压libfastcommon-master" class="headerlink" title="2 上传并解压libfastcommon-master"></a>2 上传并解压libfastcommon-master</h4><p>​	上传libfastcommon-master 到 &#x2F;usr&#x2F;local&#x2F;tmp下。 libfastcommon是从FastDFS和FastDHT中提取出来的公共C函数库</p>
<p>​	解压 libfastcommon-master.zip 由于是zip文件所以要使用 unzip命令</p>
<pre><code class="sh">  cd /usr/local/tmp
  unzip libfastcommon-master.zip
</code></pre>
<h4 id="3-编译并安装"><a href="#3-编译并安装" class="headerlink" title="3 编译并安装"></a>3 编译并安装</h4><p>​	libfastcommon没有提供make命令安装文件。使用的是shell脚本执行编译和安装。shell脚本为 make.sh</p>
<p>​	进入解压后的文件</p>
<pre><code class="sh"> cd libfastcommon-master
</code></pre>
<p>​	编译</p>
<pre><code class="sh"> ./make.sh
</code></pre>
<p>​	安装	</p>
<pre><code class="sh"> ./make.sh install
</code></pre>
<p>​	有固定的默认安装位置。在&#x2F;usr&#x2F;lib64 和  &#x2F;usr&#x2F;include&#x2F;fastcommon两个目录中</p>
<h4 id="4-创建软连接"><a href="#4-创建软连接" class="headerlink" title="4 创建软连接"></a>4 创建软连接</h4><p>​	 因为FastDFS 主程序设置的lib目录是 &#x2F;usr&#x2F;local&#x2F;lib， 所以需要创建软连接</p>
<pre><code class="sh"> ln -s /user/lib64/libfastcommon.so /usr/local/lib/libfastcommon.so
 ln -s /usr/local/lib64/libfdfsclient.so /usr/local/lib/libfdfsclient.so
</code></pre>
<h4 id="5-上传并解压FastDFS主程序"><a href="#5-上传并解压FastDFS主程序" class="headerlink" title="5 上传并解压FastDFS主程序"></a>5 上传并解压FastDFS主程序</h4><p>​	 上传 FastDFS_v5.08.tar.gz 到 &#x2F;usr&#x2F;local&#x2F;tmp下后解压</p>
<pre><code class="sh"> cd /usr/local/tmp
 tar zxf FastDFS_v5.08.tar.gz
</code></pre>
<h4 id="6-编译并安装FastDFS"><a href="#6-编译并安装FastDFS" class="headerlink" title="6 编译并安装FastDFS"></a>6 编译并安装FastDFS</h4><p>​	进入到解压后的FastDFS文件中</p>
<pre><code class="sh"> cd FastDFS
</code></pre>
<p>​	编译</p>
<pre><code class="sh"> ./make.sh
</code></pre>
<p>​	安装</p>
<pre><code class="sh"> ./make.sh install
</code></pre>
<p>​	安装后 FastDFS主程序所在的位置是</p>
<p>​	&#x2F;usr&#x2F;bin  可执行文件所在的位置</p>
<p>​	&#x2F;etc&#x2F;fdfs  配置文件所在的位置</p>
<p>​	&#x2F;usr&#x2F;bin  主程序代码所在位置</p>
<p>​	&#x2F;usr&#x2F;include&#x2F;fastdfs 包含一些插件组所在的位置</p>
<h4 id="7-配置tracker"><a href="#7-配置tracker" class="headerlink" title="7 配置tracker"></a>7 配置tracker</h4><h5 id="7-1-复制配置文件"><a href="#7-1-复制配置文件" class="headerlink" title="7.1 复制配置文件"></a>7.1 复制配置文件</h5><p>​	进入到 &#x2F;etc&#x2F;fdfs 中 ， 把tracker配置文件复制一份</p>
<pre><code class="sh">  cd /etc/fdfs
  cp tracker.conf.sample tracker.conf
</code></pre>
<h5 id="7-2-创建数据目录"><a href="#7-2-创建数据目录" class="headerlink" title="7.2 创建数据目录"></a>7.2 创建数据目录</h5><p>​	创建放置 tracker数据的目录</p>
<pre><code class="sh">  mkdir -p /usr/local/fastdfs/tracker
</code></pre>
<h5 id="7-3-修改配置文件"><a href="#7-3-修改配置文件" class="headerlink" title="7.3 修改配置文件"></a>7.3 修改配置文件</h5><p>​	修改 tracker.conf 设置 tracker 内容存储目录</p>
<pre><code class="sh">base_path=/usr/local/fastdfs/tracker
 vim tracker.conf
</code></pre>
<p> 默认端口 22122   不需要修改</p>
<h5 id="7-4-启动服务"><a href="#7-4-启动服务" class="headerlink" title="7.4 启动服务"></a>7.4 启动服务</h5><pre><code class="sh">  service fdfs_trackerd start
</code></pre>
<p>​	启动成功后， 配置文件中 base_path 指向的目录出现 FastDFS服务相关数据目录(data目录， logs 目录)</p>
<h5 id="7-5-查看服务运行状态"><a href="#7-5-查看服务运行状态" class="headerlink" title="7.5 查看服务运行状态"></a>7.5 查看服务运行状态</h5><pre><code>  service fdfs_trackerd status
</code></pre>
<p>​	如果显示 is running 表示正常运行。</p>
<h5 id="7-6-关闭防火墙"><a href="#7-6-关闭防火墙" class="headerlink" title="7.6 关闭防火墙"></a>7.6 关闭防火墙</h5><pre><code class="sh"> service iptables stop
  chkconfig iptables off
</code></pre>
<h4 id="8-配置storage"><a href="#8-配置storage" class="headerlink" title="8 配置storage"></a>8 配置storage</h4><p>  storage可以和tracker不在同一台服务器上。示例中把storage和tracker安装在同一台服务器上了。</p>
<h5 id="8-1-复制配置文件"><a href="#8-1-复制配置文件" class="headerlink" title="8.1 复制配置文件"></a>8.1 复制配置文件</h5><p>​	进入到 &#x2F;etc&#x2F;fdfs, 把 storage 配置文件复制一份</p>
<pre><code> cd /etc/fdfs
 cp storage.conf.sample storage.conf
</code></pre>
<h5 id="8-2-创建目录"><a href="#8-2-创建目录" class="headerlink" title="8.2 创建目录"></a>8.2 创建目录</h5><p>​	 创建两个目录， 把base用于存储基础数据和日志，store用于存储上传数据。</p>
<pre><code class="sh">  mkdir -p /usr/local/fastdfs/storage/base
 mkdir -p /usr/local/fastdfs/storage/store
</code></pre>
<h5 id="8-3-修改配置文件"><a href="#8-3-修改配置文件" class="headerlink" title="8.3 修改配置文件"></a>8.3 修改配置文件</h5><p>​	storage.conf配置文件用于描述存储服务的行为，需要进行下述修改</p>
<pre><code class="sh"> vim /etc/fdfs/storage.conf
</code></pre>
<p>​	配置内容如下：</p>
<pre><code class="sh">base_path=/usr/local/fastdfs/storage/base
store_path0=/usr/local/fastdfs/storage/store
tracker_server=tracker 服务IP：22122
</code></pre>
<p>​	base_path - 基础路径。用于保存storage server 基础数据内容和日志内容的目录。</p>
<p>​	store_path0 - 存储路径。是用于保存FastDFS中存储文件的目录，就是要创建256*256个子目录的位置。</p>
<p>​	base_path 和 store_path0 可以使用同一个目录。</p>
<p>​	tracker_server - 跟踪服务器位置。就是跟踪服务器的IP和端口。</p>
<p>​	启动服务</p>
<pre><code class="sh"> service fdfs_storaged start
</code></pre>
<p>​	启动成功后，配置文件中base_path 指向的目录中出现FastDFS服务相关数据目录（data目录、logs目录）配置文件中的store_path0指向的目录中同样出现FastDFS存储相关数据录（data目录）。其中$store_path0&#x2F;data&#x2F;目录中默认创建若干子孙目录（两级目录层级总计256*256个目录），是用于存储具体文件数据的。</p>
<p>​	Storage 服务器启动比较慢，因为第一次启动的时候，需要创建256*256个目录。</p>
<p>​	查看启动状态</p>
<pre><code class="sh"> service fdfs_storaged status
</code></pre>
<h3 id="——2-1"><a href="#——2-1" class="headerlink" title="——2"></a>——2</h3><img data-src="/2022/10/15/tools/tools-All/b60ca697c06d4425b7cd228b98dc3d19.png" class="">




<p>&amp;emsp;&amp;emsp;FastDFS的安装我们还是通过Docker来安装实现吧，直接在Linux上还装还是比较繁琐的，但就学习而言Docker安装还是非常高效的。Docker环境请自行安装哦，不清楚的可以看看我的Docker专题的内容。<a href="Docker%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99" title="Docker学习资料">https://blog.csdn.net/qq_38526573&#x2F;category_9619681.html</a></p>
<h4 id="1-拉取镜像文件"><a href="#1-拉取镜像文件" class="headerlink" title="1.拉取镜像文件"></a>1.拉取镜像文件</h4><p>&amp;emsp;&amp;emsp;首先我们可以通过 <code>docker search fastdfs</code> 来查询下有哪些镜像文件。</p>
<img data-src="/2022/10/15/tools/tools-All/5a06a59eb24d4f9e847a4badeef871ac.png" class="">




<p>&amp;emsp;&amp;emsp;我们看到搜索到的镜像还是蛮多的，这里我们使用 <code>delron/fastdfs</code> 你也可以尝试使用其他的镜像来安装，你也可以制作自己的镜像来给别人使用哦，只是不同的镜像在使用的时候配置会有一些不一样，有些镜像没有提供Nginx的相关配置，使用的时候会繁琐一点。接下来通过 <code>docker pull delron/fastdfs</code>命令把镜像拉取下来。</p>
<pre><code class="shell">docker pull delron/fastdfs
</code></pre>
<img data-src="/2022/10/15/tools/tools-All/5e5b85b3dc9a432abf615b27868fc7bf.png" class="">




<h4 id="2-构建Tracker服务"><a href="#2-构建Tracker服务" class="headerlink" title="2.构建Tracker服务"></a>2.构建Tracker服务</h4><p>&amp;emsp;&amp;emsp;首先我们需要通过Docker命令来创建Tracker服务。命令为</p>
<pre><code class="shell">docker run -d --name tracker --network=host -v /mydata/fastdfs/tracker:/var/fdfs delron/fastdfs tracker
</code></pre>
<p>&amp;emsp;&amp;emsp;tracker服务默认的端口为22122，-v 实现了容器和本地目录的挂载操作。</p>
<img data-src="/2022/10/15/tools/tools-All/694d42632bf6410a806df9aa43e836c0.png" class="">




<h4 id="3-构建Storage服务"><a href="#3-构建Storage服务" class="headerlink" title="3.构建Storage服务"></a>3.构建Storage服务</h4><p>&amp;emsp;&amp;emsp;接下来创建Storage服务，具体的执行命令如下</p>
<pre><code class="shell">docker run -d --name storage --network=host  -e TRACKER_SERVER=192.168.1.195:22122 -v /mydata/fastdfs/storage:/var/fdfs -e GROUP_NAME=group1 delron/fastdfs storage
</code></pre>
<p>&amp;emsp;&amp;emsp;在执行上面命令的时候要注意对应的修改下，其中TRACKER_SERVER中的ip要修改为你的Tracker服务所在的服务IP地址。</p>
<img data-src="/2022/10/15/tools/tools-All/dc2bdf85d0f24fe18a32efbe4caa2d27.png" class="">




<p>&amp;emsp;&amp;emsp;默认情况下在Storage服务中是帮我们安装了Nginx服务的，相关的端口为</p>
<table>
<thead>
<tr>
<th>服务</th>
<th>默认端口</th>
</tr>
</thead>
<tbody><tr>
<td>tracker</td>
<td>22122</td>
</tr>
<tr>
<td>storage</td>
<td>23000</td>
</tr>
<tr>
<td>Nginx</td>
<td>8888</td>
</tr>
</tbody></table>
<p>&amp;emsp;&amp;emsp;当然如果你发现这些相关的端口被占用了，或者想要对应的修改端口信息也可以的。要修改你可以先进入容器中查看下相关的配置文件信息。</p>
<img data-src="/2022/10/15/tools/tools-All/da5cc21445e840baa85580ba420db94d.png" class="">




<p>&amp;emsp;&amp;emsp;然后查看storage.conf文件</p>
<img data-src="/2022/10/15/tools/tools-All/63862499980b408195291de047048566.png" class="">




<p>&amp;emsp;&amp;emsp;这个是storage监听的Nginx的端口8888，如果要修改那么我们还需要修改Nginx中的服务配置，这块的配置在 <code>/usr/local/nginx/conf</code>目录下</p>
<img data-src="/2022/10/15/tools/tools-All/f866c08177be4fd48bfd9a582ec78779.png" class="">




<p>&amp;emsp;&amp;emsp;查看下文件</p>
<img data-src="/2022/10/15/tools/tools-All/dc7c5888363a400b9308f3ba64cca9ac.png" class="">




<p>所以要修改端口号的话，这两个位置都得修改了。当然本文我们就使用默认的端口号来使用了。</p>
<h4 id="4-测试图片上传"><a href="#4-测试图片上传" class="headerlink" title="4.测试图片上传"></a>4.测试图片上传</h4><p>&amp;emsp;&amp;emsp;好了，安装我们已经完成了，那么到底是否可以使用呢？我们来测试下。首先在虚拟机的&#x2F;mydata&#x2F;fastdfs&#x2F;storage下保存一张图片。</p>
<img data-src="/2022/10/15/tools/tools-All/ff2ea2626bb34acd810fbb8d9438129a.png" class="">




<p>&amp;emsp;&amp;emsp;然后我们再进入到storage容器中。并且进入到 <code>/var/fdfs</code>目录下,可以看到我们挂载的文件了</p>
<img data-src="/2022/10/15/tools/tools-All/cb8a96fb9bb644328880ca70378a7fc2.png" class="">




<p>&amp;emsp;&amp;emsp;然后执行如下命令即可完成图片的上传操作</p>
<pre><code class="shell">/usr/bin/fdfs_upload_file /etc/fdfs/client.conf 1.jpg
</code></pre>
<img data-src="/2022/10/15/tools/tools-All/0fd0e82898bb45178eca4eef9a412745.png" class="">




<p>&amp;emsp;&amp;emsp;通过上面的提示我们看到文件上传成功了，而且返回了文件在storage中存储的信息。这时我们就可以通过这个信息来拼接访问的地址在浏览器中访问了：<span class="exturl" data-url="aHR0cDovLzE5Mi4xNjguNTYuMTAwOjg4ODgvZ3JvdXAxL00wMC8wMC8wMC93S2c0WkdIY0tMU0FYaWJhQUFlek11VXJsUzgyMzUuanBn">http://192.168.56.100:8888/group1/M00/00/00/wKg4ZGHcKLSAXibaAAezMuUrlS8235.jpg</span></p>
<img data-src="/2022/10/15/tools/tools-All/b34e823e956f410297bfd1218ebc0231.png" class="">




<p>&amp;emsp;&amp;emsp;好了到这儿FastDFS的服务安装成功了。</p>
<div name="nginx_install_1" ></div>
## nginx安装



<div name="nginx_install_2">

<h3 id="——2-2"><a href="#——2-2" class="headerlink" title="——2"></a>——2</h3><h4 id="1、拉取镜像"><a href="#1、拉取镜像" class="headerlink" title="1、拉取镜像"></a>1、拉取镜像</h4><pre><code class="shell">docker pull nginx:1.16.1
</code></pre>
<h4 id="2、创建挂载数据卷"><a href="#2、创建挂载数据卷" class="headerlink" title="2、创建挂载数据卷"></a>2、创建挂载数据卷</h4><pre><code class="shell">mkdir -p /root/nginx/conf
vim /root/nginx/conf/nginx.conf
</code></pre>
<p><code>nginx.conf内容：</code></p>
<pre><code class="shell">user  root;
worker_processes  auto;
 
error_log  /var/log/nginx/error.log warn;
pid        /var/run/nginx.pid;
 
 
events &#123;
    worker_connections  1024;
&#125;
 
 
http &#123;
    include       /etc/nginx/mime.types;
    default_type  application/octet-stream;
 
    log_format  main  &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39;
                      &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39;
                      &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;;
 
    access_log  /var/log/nginx/access.log  main;
 
    sendfile        on;
    #tcp_nopush     on;
 
    keepalive_timeout  65;
 
    #gzip  on;
    
    
    server &#123;
        listen       80;
        server_name  localhost;

        #charset koi8-r;
        #access_log  /var/log/nginx/host.access.log  main;

        location / &#123;
            root   /usr/share/nginx/html;
            index  index.html index.htm;
        &#125;

        #error_page  404              /404.html;

        # redirect server error pages to the static page /50x.html

        error_page   500 502 503 504  /50x.html;
        location = /50x.html &#123;
            root   /usr/share/nginx/html;
        &#125;
   
    &#125;
&#125;

</code></pre>
<h4 id="3、创建容器"><a href="#3、创建容器" class="headerlink" title="3、创建容器"></a>3、创建容器</h4><pre><code class="shell"># 注意ip一定要与检测ip相同
docker run \
-p 80:80 \
--name nginx  \
-v /root/nginx/conf/nginx.conf:/etc/nginx/nginx.conf \
-d nginx:1.16.1 
</code></pre>
<h4 id="4、查看"><a href="#4、查看" class="headerlink" title="4、查看"></a>4、查看</h4><pre><code class="shell">docker ps 
</code></pre>
<h2 id="Zookeeper安装"><a href="#Zookeeper安装" class="headerlink" title="Zookeeper安装"></a>Zookeeper安装</h2><h3 id="——1-3"><a href="#——1-3" class="headerlink" title="——1"></a>——1</h3><h4 id="1-Zookeeper简介"><a href="#1-Zookeeper简介" class="headerlink" title="1     Zookeeper简介"></a>1     Zookeeper简介</h4><p>​	zookeeper分布式管理软件。常用它做注册中心（依赖zookeeper的发布&#x2F;订阅功能）、配置文件中心、分布式锁配置、集群管理等。</p>
<p>​	zookeeper一共就有两个版本。主要使用的是java语言写的。</p>
<h4 id="2-安装"><a href="#2-安装" class="headerlink" title="2     安装"></a>2     安装</h4><h5 id="2-1-上传压缩文件"><a href="#2-1-上传压缩文件" class="headerlink" title="2.1   上传压缩文件"></a>2.1   上传压缩文件</h5><p>​	上传到 &#x2F;usr&#x2F;local&#x2F;tmp中</p>
<h4 id="2-2-解压"><a href="#2-2-解压" class="headerlink" title="2.2   解压"></a>2.2   解压</h4><pre><code> tar zxf apache-zookeeper-3.5.5-bin.tar.gz
 cp -r apache-zookeeper-3.5.5-bin ../zookeeper
</code></pre>
<h4 id="2-3-新建data目录"><a href="#2-3-新建data目录" class="headerlink" title="2.3   新建data目录"></a>2.3   新建data目录</h4><p>进入到zookeeper中</p>
<pre><code> cd /usr/local/zookeeper
 mkdir data
</code></pre>
<h4 id="2-4-修改配置文件"><a href="#2-4-修改配置文件" class="headerlink" title="2.4   修改配置文件"></a>2.4   修改配置文件</h4><p>进入conf中</p>
<pre><code> cd conf
 cp zoo_sample.cfg zoo.cfg
 vim zoo.cfg
</code></pre>
<p>修改dataDir为data文件夹路径</p>
<pre><code>dataDir=/usr/local/zookeeper/data
</code></pre>
<h4 id="2-5-启动zookeeper"><a href="#2-5-启动zookeeper" class="headerlink" title="2.5   启动zookeeper"></a>2.5   启动zookeeper</h4><p>进入bin文件夹</p>
<pre><code> cd /usr/local/zookeeper/bin
 ./zkServer.sh start
</code></pre>
<p>通过status查看启动状态。稍微有个等待时间</p>
<pre><code class="shell">  ./zkServer.sh status
</code></pre>
<h3 id="——2-3"><a href="#——2-3" class="headerlink" title="——2"></a>——2</h3><p><strong>资料：</strong></p>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20va2luZ2tvby9wLzg3MzI0NDguaHRtbA==">https://www.cnblogs.com/kingkoo/p/8732448.html</span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL2F2ODA4NzQ2NjY/ZnJvbT1zZWFyY2gmYW1wO3NlaWQ9MTYyOTE0NTAyNTIxMTk5OTEwNCZhbXA7c3BtX2lkX2Zyb209MzMzLjMzNy4wLjA=">https://www.bilibili.com/video/av80874666?from=search&amp;seid=1629145025211999104&amp;spm_id_from=333.337.0.0</span></p>
<h4 id="1-Zookeeper简介-1"><a href="#1-Zookeeper简介-1" class="headerlink" title="1     Zookeeper简介"></a>1     Zookeeper简介</h4><p>​	zookeeper分布式管理软件。常用它做注册中心（依赖zookeeper的发布&#x2F;订阅功能）、配置文件中心、分布式锁配置、集群管理等。</p>
<p>​	zookeeper一共就有两个版本。主要使用的是java语言写的。</p>
<h4 id="2-安装-1"><a href="#2-安装-1" class="headerlink" title="2     安装"></a>2     安装</h4><h5 id="2-1-拉取镜像"><a href="#2-1-拉取镜像" class="headerlink" title="2.1   拉取镜像"></a>2.1   拉取镜像</h5><ul>
<li><p>自定义zookeeper目录</p>
<pre><code class="shell">mkdir /root/zookeeper

mkdir /root/zookeeper/data #原因参照上面 -在docker中data其实也不用在宿主机行自己生成(目前如此)

#仓库官网查看版本或者用命令直接查
docker search zookeeper

#拉取特定版本（3.5）
docker pull zookeeper:3.5
</code></pre>
</li>
</ul>
<h5 id="2-2-创建并启动容器"><a href="#2-2-创建并启动容器" class="headerlink" title="2.2 创建并启动容器"></a>2.2 创建并启动容器</h5><p>​	<strong>注：就目前而且 好像直接在docker中使用 zookeeper 不需要过多的配置，直接用命令创建吧，下面的解释先不看，具体原因后面补充</strong></p>
<p>命令：</p>
<pre><code class="shell">docker run -d --name zookeeper -v /root/zookeeper/data:/data -p 2181:2181 --restart always zookeeper:3.5
</code></pre>
<ul>
<li><code>--restart always</code>：始终重启</li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vYWdlb3ZiL3AvMTUzMjg3OTYuaHRtbA==">https://www.cnblogs.com/ageovb/p/15328796.html</span></li>
</ul>
<p><strong>解释</strong></p>
<ul>
<li><p>1、这里为啥只挂载了 data 目录–》因为当我们 没有直接的安装压缩包时，我们的就没有配置文件，所以我们直接生成，容器中就回自动生成conf文件，其中就有我们需要的 一系列配置文件，我们第一次创建的时候就可以如此，我们在进<strong>行配置文件的修改完成</strong>后，要将所有配置文件放到我们  bash 目录中的 conf 文件中去。</p>
</li>
<li><p>2、第一次进入容器</p>
<ul>
<li><p>在bash目录下进入bin 目录然后输入开启客户端命令</p>
<pre><code class="shell">./zkCli.sh
</code></pre>
</li>
</ul>
</li>
<li><p>3、第二次进入容器</p>
<pre><code class="shell">docker exec -it zookeeper /bin/bash  -p    端口号
或
docker exec -it zookeeper zkCli.sh
</code></pre>
</li>
</ul>
<p><strong>只看到这就可*，容器创建成功就可以直接用了，还没有出现问题。有待补充</strong></p>
<h5 id="2-3-修改配置文件"><a href="#2-3-修改配置文件" class="headerlink" title="2.3   修改配置文件"></a>2.3   修改配置文件</h5><ul>
<li>配置文件来源<ul>
<li>1、可以去我们的资料中直接解压出<strong>conf</strong>目录粘贴到我们的 zookeeper 目录中去</li>
<li>2、可以直接进行第 3 步，完事之后直接会在容器中生成。找到conf文件，修改其中的 zoo.cfg文件，</li>
</ul>
</li>
</ul>
<p>进入容器后，找到conf中的 **zoo.cfg文件，接下来就是修改 <strong>dataDir</strong> 路径为容器中的 data文件目录。</p>
<p>前提是要下载 vim ，因为容器中没有，命令是：</p>
<pre><code>apt-get update

apt-get install -y vim

cd conf
# 没有zoo.cfg 就先拷贝 zoo_sample.cfg 两个其实是一个文件，内容相同
#cp zoo_sample.cfg zoo.cfg
vim zoo.cfg
</code></pre>
<p>修改dataDir为data文件夹路径</p>
<pre><code>dataDir=/usr/local/zookeeper/data
</code></pre>
<h2 id="Zookeeper集群搭建"><a href="#Zookeeper集群搭建" class="headerlink" title="Zookeeper集群搭建"></a>Zookeeper集群搭建</h2><h3 id="——1-4"><a href="#——1-4" class="headerlink" title="——1"></a>——1</h3><p>1.上传压缩包到&#x2F;usr&#x2F;local&#x2F;tmp 下 并解压。</p>
<p>2.在 &#x2F;usr&#x2F;local下新建文件夹 zookeeper</p>
<pre><code># mkdir /usr/local/zookeeper
</code></pre>
<p>3.把解压的所有文件复制到zookeeper下， 并命名为zk1</p>
<pre><code># cp -r /usr/local/temp/zookeeper-3.4.8 /usr/local/zookeeper/zk1
</code></pre>
<p>4.在zk1下新建文件夹 data</p>
<p>5.在data下新建文件 myid, 里面写上 1</p>
<pre><code># vim myid
</code></pre>
<p>6.进入到zk1&#x2F;conf 下 把 zoo_sample.cfg 复制一份叫做 zoo.cfg</p>
<p>7.编辑 zoo.cfg 内容，设置 dataDIR为 data文件夹， 并在文件最下面添加下面内容</p>
<pre><code>server.1=192.168.93.10:2688:3888
server.2=192.168.93.10:2689:3889
server.3=192.168.93.10:2690:3890
</code></pre>
<p> 7.1 server.1中的1是myid的内容</p>
<p> 7.2 2688 2689 2690 是 zookeeper内部端口</p>
<p> 7.3 3888 3889 3890 是 leader端口</p>
<p>8.把zk1复制两份，分部叫做 zk2  zk3  并修改 myid 的值为 2，3 修改zoo.cfg中 dataDIR和clientPort</p>
<p>9.启动三个zookeeper</p>
<pre><code># ./zkServer.sh start
</code></pre>
<p>10.查看状态</p>
<pre><code># ./zkServer.sh status
</code></pre>
<h3 id="——2-4"><a href="#——2-4" class="headerlink" title="——2"></a>——2</h3><h4 id="1、准备docker-compose-yml文件"><a href="#1、准备docker-compose-yml文件" class="headerlink" title="1、准备docker-compose.yml文件"></a><strong>1、准备</strong>docker-compose.yml<strong>文件</strong></h4><pre><code class="shell">version: &#39;2&#39;
services:
  zoo1:
    image: zookeeper:3.5
    restart: always
    container_name: zoo1
    ports:
      - &quot;2182:2181&quot;
    environment:
      ZOO_MY_ID: 1
      ZOO_SERVERS: server.1=0.0.0.0:2688:3888 server.2=zoo2:2689:3888 server.3=zoo3:2690:3888

  zoo2:
    image: zookeeper:3.5
    restart: always
    container_name: zoo2
    ports:
      - &quot;2183:2181&quot;
    environment:
      ZOO_MY_ID: 2
      ZOO_SERVERS: server.1=zoo1:2688:3888 server.2=0.0.0.0:2689:3888 server.3=zoo3:2690:3888

  zoo3:
    image: zookeeper:3.5
    restart: always
    container_name: zoo3
    ports:
      - &quot;2184:2181&quot;
    environment:
      ZOO_MY_ID: 3
      ZOO_SERVERS: server.1=zoo1:2688:3888 server.2=zoo2:2689:3888 server.3=0.0.0.0:2690:3888

</code></pre>
<h4 id="2、创建镜像"><a href="#2、创建镜像" class="headerlink" title="2、创建镜像"></a><strong>2、创建镜像</strong></h4><ul>
<li>要在创建的docker-compose.yml文件中使用命令</li>
</ul>
<pre><code class="shell">docker-compose up -d
</code></pre>
<h4 id="3、进入容器"><a href="#3、进入容器" class="headerlink" title="3、进入容器"></a><strong>3、进入容器</strong></h4><pre><code class="shell">docker exec -it zoo1 /bin/bash

#查看zoo1 的状态
cd bin
./zkServer.sh status
</code></pre>
<ul>
<li>如果出现，以下情况：</li>
</ul>
<pre><code>ZooKeeper JMX enabled by default
Using config: /conf/zoo.cfg
Client port not found in static config file. Looking in dynamic config file.
grep: : No such file or directory
Client port not found in the server configs
Client port not found. Looking for secureClientPort in the static config.
Unable to find either secure or unsecure client port in any configs. Terminating.
</code></pre>
<p>​	通过阅读我们知道他在conf中的zoo.cfg文件中缺少 **clientPort **我们只需要自行添加即可</p>
<pre><code class="shell">#修改之前我们先装一下 vim
apt-get update

apt-get install -y vim 

#修改zoo.fcg文件
vim /conf/zoo.fcg

clientPort=2181
</code></pre>
<ul>
<li><p>完事之后<strong>重启</strong>zoo1</p>
<p><img data-src="/tools-All%5C1645780920291.png" alt="1645780920291"></p>
<p>成功！！</p>
</li>
</ul>
<h4 id="4、查看所有zookeeper的状态"><a href="#4、查看所有zookeeper的状态" class="headerlink" title="4、查看所有zookeeper的状态"></a>4、查看所有zookeeper的状态</h4><pre><code class="shell">docker exec -it zoo3 bash ./bin/zkServer.sh status
</code></pre>
<h4 id="5、进去客户端"><a href="#5、进去客户端" class="headerlink" title="5、进去客户端"></a>5、进去客户端</h4><pre><code class="shell">docker exec -it zoo3 zkCli.sh
</code></pre>
<h2 id="redis安装"><a href="#redis安装" class="headerlink" title="redis安装"></a>redis安装</h2><h3 id="——1-5"><a href="#——1-5" class="headerlink" title="——1"></a>——1</h3><h4 id="1-安装依赖C语言依赖"><a href="#1-安装依赖C语言依赖" class="headerlink" title="1.安装依赖C语言依赖"></a>1.安装依赖C语言依赖</h4><p>​	redis使用C语言编写，所以需要安装C语言库</p>
<pre><code> yum install -y gcc-c++ automake autoconf libtool make tcl 
</code></pre>
<p>​	</p>
<h4 id="2-上传并解压"><a href="#2-上传并解压" class="headerlink" title="2.上传并解压"></a>2.上传并解压</h4><p>​	把redis-5.0.5.tar.gz上传到&#x2F;usr&#x2F;local&#x2F;tmp中，解压文件</p>
<pre><code> cd /usr/local/tmp

 tar zxf redis-5.0.5.tar.gz
</code></pre>
<h4 id="3-编译并安装-1"><a href="#3-编译并安装-1" class="headerlink" title="3.编译并安装"></a>3.编译并安装</h4><p>​	进入解压文件夹</p>
<pre><code>  cd /usr/local/tmp/redis-5.0.5/
</code></pre>
<p>​	编译</p>
<pre><code> make
</code></pre>
<p>​	安装	（一定要干）</p>
<pre><code> make install PREFIX=/usr/local/redis
</code></pre>
<h4 id="4-开启守护进程"><a href="#4-开启守护进程" class="headerlink" title="4.开启守护进程"></a>4.开启守护进程</h4><p>​	复制cd &#x2F;usr&#x2F;local&#x2F;tmp&#x2F;redis-5.0.5&#x2F;中redis.conf配置文件	</p>
<pre><code> cp redis.conf /usr/local/redis/bin/
</code></pre>
<p> <strong>修改配置文件</strong>	</p>
<pre><code> cd /usr/local/redis/bin/

 vim redis.conf
</code></pre>
<p>​	把daemonize的值由no修改为yes</p>





<h4 id="5-修改外部访问"><a href="#5-修改外部访问" class="headerlink" title="5.修改外部访问"></a>5.修改外部访问</h4><p>​	在redis5中需要修改配置文件redis.conf允许外部访问。需要修改两处。</p>
<p>​	注释掉下面</p>
<p>​	bind 127.0.0.1</p>
<pre><code> bind 127.0.0.1
</code></pre>
<p>​	protected-mode yes 改成 no</p>





<h4 id="6-启动并测试"><a href="#6-启动并测试" class="headerlink" title="6.启动并测试"></a>6.启动并测试</h4><p>​	启动redis</p>
<pre><code class="shell">./redis-server redis.conf
</code></pre>
<p>​	重启redis</p>
<pre><code>./redis-cli shutdown
./redis-server redis.conf
</code></pre>
<p>​	启动客户端工具</p>
<p>​	在redis5中客户端工具对命令会有提供功能。</p>
<pre><code class="shell">./redis-cli 
</code></pre>
<h4 id="7-增加自定义日志文件"><a href="#7-增加自定义日志文件" class="headerlink" title="7.增加自定义日志文件"></a>7.增加自定义日志文件</h4><p>​	打开redis.conf , 找到 logfile “” ，在引号中写入我们的日志文件目录，要写到文件，只写到日志目录是不行的，他无法打开， 而且这个文件你要先自己创建才能用，最好就是把文件的权限全部打开了</p>
<pre><code class="sh"># 日志文件输出目录/文件
touch /usr/local/redis/log/run.log
# 修改redis.conf
logfile &quot;/usr/local/redis/log/run.log&quot;
# 修改日志文件的权限
chmod 777 /usr/local/redis/log/run.log
# 启动服务
./redis-server redis.conf

# 即使没有报错，也要手动看一下日志文件是否采集到了日志信息
tail -f /usr/local/redis/log/run.log
</code></pre>
<h3 id="——2-5"><a href="#——2-5" class="headerlink" title="——2"></a>——2</h3><h4 id="1、拉取镜像文件"><a href="#1、拉取镜像文件" class="headerlink" title="1、拉取镜像文件"></a>1、拉取镜像文件</h4><pre><code class="shell">docker pull redis[:(版本号)]
</code></pre>
<h4 id="2、去gitee库中下载redis配置文件（docker不自带配置文件）【也可不进行此步骤】"><a href="#2、去gitee库中下载redis配置文件（docker不自带配置文件）【也可不进行此步骤】" class="headerlink" title="2、去gitee库中下载redis配置文件（docker不自带配置文件）【也可不进行此步骤】"></a>2、去gitee库中下载redis配置文件（docker不自带配置文件）【也可不进行此步骤】</h4><p><strong>建议看完，先别操作，再看三，看完三之后再决定如何操作</strong></p>
<p>然后按照文章内容进行，忽略下载。</p>
<p>文章地址： <span class="exturl" data-url="aHR0cHM6Ly93d3cuamI1MS5uZXQvYXJ0aWNsZS8yMDMyNzQuaHRt">https://www.jb51.net/article/203274.htm</span> </p>
<p>、</p>









<p> <strong>docker 镜像中没有redis.conf文件，要自己配置</strong> </p>
<pre><code class="undefined">git pull --rebase https://gitee.com/zjj3366/mydemo.git master
</code></pre>
<h4 id="3、创建一个redis-服务容器"><a href="#3、创建一个redis-服务容器" class="headerlink" title="3、创建一个redis 服务容器"></a>3、创建一个redis 服务容器</h4><p><strong>第二步进行了的</strong></p>
<pre><code class="shell">docker run -p 6379:6379 \
--name myredis  \
-v /usr/local/docker/redis.conf:/etc/redis/redis.conf   \
-v /usr/local/docker/data:/data  \
-d redis  \
redis-server  /etc/redis/redis.conf  \
--appendonly yes
</code></pre>
<p><strong>第二步没有进行的</strong></p>
<pre><code class="shell">docker run -p 6379:6379  \
--name myredis  \
-v /root/myredis/data:/data \
-v /root/myredis/conf/redis.conf:/etc/redis/redis.conf  \
-d redis:4.0  \
redis-server /etc/redis/redis.conf  \
--appendonly yes
</code></pre>
<p><strong>区别：</strong></p>
<p>​	其实也没有什么区别，只是映射的文件不同，也可以将第二步的文件直接创建到第二种创建服务容器的配置文件地址中去，这样也可使用第二个创建方式。</p>


















<h2 id="redis集群-Cluster-搭建"><a href="#redis集群-Cluster-搭建" class="headerlink" title="redis集群(Cluster)搭建"></a>redis集群(Cluster)搭建</h2><h3 id="——1-6"><a href="#——1-6" class="headerlink" title="——1"></a>——1</h3><p>​	前提：已经安装好redis单机版。</p>
<p>​	当集群中超过或等于1&#x2F;2节点不可用时，整个集群不可用。为了搭建稳定集群，都采用奇数节点。</p>
<h4 id="1-复制redis配置文件"><a href="#1-复制redis配置文件" class="headerlink" title="1 .复制redis配置文件"></a>1 .<strong>复制redis配置文件</strong></h4><p>​	从&#x2F;usr&#x2F;local&#x2F;redis&#x2F;bin下把redis.conf复制到当前目录中，命名为redis-7001.conf</p>
<pre><code># cp /usr/local/redis/bin/redis.conf /usr/local/redis/bin/redis-7001.conf
</code></pre>
<h4 id="2-修改redis-7001-conf"><a href="#2-修改redis-7001-conf" class="headerlink" title="2. 修改redis-7001.conf"></a>2. <strong>修改redis-7001.conf</strong></h4><pre><code># cd /usr/local/redis/bin
# vim redis-7001.conf
</code></pre>
<p>​	需要修改如下</p>
<pre><code>port 7001
cluster-enabled yes
cluster-config-file nodes-7001.conf
cluster-node-timeout 15000
# appendonly yes 如果开启aof默认，需要修改为yes。如果使用rdb，此处不需要修改
daemonize yes
protected-mode no
pidfile /var/run/redis_7001.pid
</code></pre>
<h4 id="3-复制配置文件，并修改内容"><a href="#3-复制配置文件，并修改内容" class="headerlink" title="3 .复制配置文件，并修改内容"></a>3 .<strong>复制配置文件，并修改内容</strong></h4><p>​	把redis-7001.conf 复制5份，分别叫做redis-7002.conf、redis-7003.conf、redis-7004.conf、redis-7005.conf、redis-7006.conf </p>
<pre><code># cp redis-7001.conf redis-7002.conf
# cp redis-7001.conf redis-7003.conf
# cp redis-7001.conf redis-7004.conf
# cp redis-7001.conf redis-7005.conf
# cp redis-7001.conf redis-7006.conf
</code></pre>
<pre><code> 新复制的5个配置文件都需要需改三处。
</code></pre>
<p>​	例如nodes-7002.conf中需要把所有7001都换成7002。</p>
<p>​	可以使用 :%s&#x2F;7001&#x2F;7002&#x2F;g 进行全局修改。 </p>
<pre><code>port 7002
cluster-config-file nodes-7002.conf
pidfile /var/run/redis_7002.pid
</code></pre>
<h4 id="4-启动6个redis"><a href="#4-启动6个redis" class="headerlink" title="4 .启动6个redis"></a>4 .<strong>启动6个redis</strong></h4><p>​	可以使用redis-server结合6个配置文件进行启动6个实例。</p>
<p>​	执行之前一定要先删除dump.rdb</p>
<pre><code># rm -f dump.rdb
# vim startup.sh

./redis-server redis-7001.conf
./redis-server redis-7002.conf
./redis-server redis-7003.conf
./redis-server redis-7004.conf
./redis-server redis-7005.conf
./redis-server redis-7006.conf


# chmod a+x startup.sh
# ./startup.sh
</code></pre>
<h4 id="5-查看启动状态"><a href="#5-查看启动状态" class="headerlink" title="5. 查看启动状态"></a>5. <strong>查看启动状态</strong></h4>




<h4 id="6-建立集群"><a href="#6-建立集群" class="headerlink" title="6. 建立集群"></a>6. <strong>建立集群</strong></h4><p>​	在redis3的时候需要借助ruby脚本实现集群。在redis5中可以使用自带的redis-cli实现集群功能，比redis3的时候更加方便了。</p>
<p>​	建议配置静态ip，ip改变集群失效</p>
<pre><code>./redis-cli --cluster create 192.168.93.10:7001 192.168.93.10:7002 192.168.93.10:7003 192.168.93.10:7004 192.168.93.10:7005 192.168.93.10:7006 --cluster-replicas 1
</code></pre>
<h4 id="7-测试"><a href="#7-测试" class="headerlink" title="7. 测试"></a>7. <strong>测试</strong></h4><p>​	集群测试时，千万不要忘记最后一个-c参数。</p>
<pre><code># ./redis-cli -p 7001 -c
# set age 18
</code></pre>
<h4 id="8-编写关闭脚本"><a href="#8-编写关闭脚本" class="headerlink" title="8 .编写关闭脚本"></a>8 .<strong>编写关闭脚本</strong></h4><pre><code># vim stop.sh
# chmod a+x stop.sh

./redis-cli -p 7001 shutdown
./redis-cli -p 7002 shutdown
./redis-cli -p 7003 shutdown
./redis-cli -p 7004 shutdown
./redis-cli -p 7005 shutdown
./redis-cli -p 7006 shutdown
</code></pre>
<h3 id="——2-6"><a href="#——2-6" class="headerlink" title="——2"></a>——2</h3><p>​	<strong>注：</strong>1.如果是配置修改之前<strong>已经创建过的集群时</strong>，要先进行第七步操作。</p>
<p>​			2.要是想重启集群可以省略第一步，但是得<strong>先删除已经创建的容器</strong>，重新进行2、3（合并也行）</p>
<h4 id="0、创建网络"><a href="#0、创建网络" class="headerlink" title="0、创建网络"></a>0、创建网络</h4><p><strong>目的：</strong>让宿主机可以访问到自身</p>
<pre><code class="shell">docker network create net-redis --subnet 172.38.0.0/16
</code></pre>
<p>补充：关于虚拟机的三种网路连接方式区别</p>
<p> <span class="exturl" data-url="aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYmlmZW5nbWlhb3podWFuL2FydGljbGUvZGV0YWlscy83OTg4NzY5Mj9zcG09MTAwMS4yMTAxLjMwMDEuNjY2MS4xJmFtcDt1dG1fbWVkaXVtPWRpc3RyaWJ1dGUucGNfcmVsZXZhbnRfdDAubm9uZS10YXNrLWJsb2ctMn5kZWZhdWx0fkNUUkxJU1R+UmF0ZS0xLnBjX3JlbGV2YW50X2RlZmF1bHQmYW1wO2RlcHRoXzEtdXRtX3NvdXJjZT1kaXN0cmlidXRlLnBjX3JlbGV2YW50X3QwLm5vbmUtdGFzay1ibG9nLTJ+ZGVmYXVsdH5DVFJMSVNUflJhdGUtMS5wY19yZWxldmFudF9kZWZhdWx0JmFtcDt1dG1fcmVsZXZhbnRfaW5kZXg9MQ==">http://blog.csdn.net/bifengmiaozhuan/article/details/79887692?spm=1001.2101.3001.6661.1&amp;utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1.pc_relevant_default&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1.pc_relevant_default&amp;utm_relevant_index=1</span> </p>







<h4 id="1、创建并修改配置文件"><a href="#1、创建并修改配置文件" class="headerlink" title="1、创建并修改配置文件"></a>1、创建并修改配置文件</h4><p><strong>注：</strong></p>
<pre><code>In certain deployments, Redis Cluster nodes address discovery fails, because addresses are NAT-ted or because ports are forwarded (the typical case is Docker and other containers).

在某些部署中，Redis群集节点地址发现失败，因为地址是NAT，或者端口是转发的（典型情况是Docker和其他容器）。

In order to make Redis Cluster working in such environments, a static configuration where each node knows its public address is needed. The following two options are used for this scope, and are:

为了让Redis集群在这样的环境中工作，需要一种静态配置，其中每个节点都知道自己的公共地址。以下两个选项用于此范围，分别是：

cluster-announce-ip

cluster-announce-port
---------------------------------------------------------------------------------------
你的docker内网是172，你宿主的IP是192网段

根据redis的配置文件中的解释

要在你的配置文件上加上上面的2个配置
</code></pre>
<p><strong>方法一：</strong>参考上面的方法一样行。</p>
<p><strong>方法二：</strong>使用脚本</p>
<pre><code class="shell">#cat &lt;&lt;EOF EOF在这里没有特殊的含义，你可以使用FOE或000等;
#表示以cat &lt;&lt;EOF 开始输入以 EOF 结束结束输入
#cat&gt;创建文件，并把标准输入输出到后面的filename文件


# * cluster-announce-ip					192.168.1.195	#*群集ip
# * cluster-announce-port				700$&#123;port&#125;		#*群集总线端口
# * cluster-announce-bus-port#*群集ip    1700$&#123;port&#125;	   #*群集公布端口
# 集群 ip 是固定+10000

# 可以使用 :  %s/7001/7002/g     进行全局修改。 ---将全局的7001修改成7002

for port in $(seq 1 6); \ 
do \
mkdir  -p  /root/myredis/conf700$&#123;port&#125;
touch  /root/myredis/conf700$&#123;port&#125;/redis.conf
cat &lt;&lt;TTT &gt; /root/myredis/conf700$&#123;port&#125;/redis.conf port 6379
bind 0.0.0.0
port 700$&#123;port&#125;
cluster-enabled yes
cluster-config-file nodes-700$&#123;port&#125;.conf
cluster-node-timeout 15000
protected-mode no
pidfile /var/run/redis_ 700$&#123;port&#125;.pid
cluster-announce-ip  192.168.1.195 
cluster-announce-port  700$&#123;port) 
cluster-announce-bus-port 1700$&#123;port) 
appendonly yes 
TTT 
done
</code></pre>
<h4 id="2、创建容器"><a href="#2、创建容器" class="headerlink" title="2、创建容器"></a>2、创建容器</h4><p><strong>方法一：</strong>手动创建容器，并启动</p>
<pre><code class="shell">docker run -p 7001:7001   -p 17001:17001  --name redis7001  -v /root/myredis/conf7001/redis.conf:/etc/redis/redis.conf -v /root/myredis/data7001:/data -d redis redis-server /etc/redis/redis.conf --appendonly yes
</code></pre>
<p>​	7002 ~~~7006同上，自行修改参数</p>
<p><strong>方法二：</strong>脚本一键启动，效果同上</p>
<p>​	<strong>注意：</strong></p>
<ul>
<li>其中要指定两个端口号**-p 1700${port}:1700${port}**不要忘记，否则会在创建几群的时候出现  **Waiting for the cluster to join   ** 。【具体原因，我还没查出来，后面补充】</li>
<li>在docker创建集群容器的时候，<strong>一定要</strong> 指定  ip</li>
</ul>
<p><strong>补充：</strong></p>
<ul>
<li>那肯定是你端口没有开启，不要质疑，这里的端口不是7000-7005，而是17000-17005，因为redis设置集群的端口号是”redis端口+10000“，这个非常重要。并且7001:7006也是必须打开的。</li>
</ul>
<pre><code class="shell">for port in $(seq 1 6);  \
do \
docker run -p 700$&#123;port&#125;:700$&#123;port&#125;   -p 1700$&#123;port&#125;:1700$&#123;port&#125;  --name redis700$&#123;port&#125;  \
-v /root/redis/redis700$&#123;port&#125;.conf:/etc/redis/redis.conf \
-v /root/redis/data700$&#123;port&#125;:/data \
-d --ip 192.168.1.195 redis redis-server /etc/redis/redis.conf 
done
</code></pre>
<h4 id="3、进入容器-1"><a href="#3、进入容器-1" class="headerlink" title="3、进入容器"></a>3、进入容器</h4><pre><code class="shell">docker exec -it redis7001 /bin/bash
</code></pre>
<h4 id="4、创建集群"><a href="#4、创建集群" class="headerlink" title="4、创建集群"></a>4、创建集群</h4><p>​	<strong>注：</strong>有一步操作，要自行进行确认，一定要输入 <strong>yes</strong> 而不是 <strong>y</strong> 或者其他之类的，除了 yes一律视为 <strong>no</strong> 。</p>
<pre><code class="shell">redis-cli --cluster create 192.168.1.195:7001 192.168.1.195:7002 192.168.1.195:7003 192.168.1.195:7004 192.168.1.195:7005 192.168.1.195:7006 --cluster-replicas 1
</code></pre>
<h4 id="5、测试"><a href="#5、测试" class="headerlink" title="5、测试"></a>5、测试</h4><p>​	集群测试时，千万不要忘记最后一个-c参数。</p>
<pre><code class="shel">redis-cli -p 7001 -c
</code></pre>
<h4 id="6、关闭集群"><a href="#6、关闭集群" class="headerlink" title="6、关闭集群"></a>6、关闭集群</h4><p><strong>方法一：</strong></p>
<p>​	自行手动一个一个停止，并且删除容器</p>
<pre><code class="shell">docker stop redis7001 #7002 ~~~7006

docker rm -f redis7001
</code></pre>
<p><strong>方法二：</strong></p>
<p>​	脚本程序，一劳永逸</p>
<pre><code class="shell">for port in $(seq 1 6);  \
do \
docker stop redis700$&#123;port&#125;
docker rm -f redis700$&#123;port&#125;
done
</code></pre>
<h4 id="7、清空集群文件"><a href="#7、清空集群文件" class="headerlink" title="7、清空集群文件"></a>7、清空集群文件</h4><pre><code class="shell">for port in $(seq 1 6);  \
do \
rm  -rf  ./data700$&#123;port&#125;/* 
done
</code></pre>
<h2 id="Solr安装"><a href="#Solr安装" class="headerlink" title="Solr安装"></a>Solr安装</h2><h3 id="——1-7"><a href="#——1-7" class="headerlink" title="——1"></a>——1</h3><p>​	Solr是使用Java编写，所以必选先安装JDK。</p>
<h4 id="1-上传并解压"><a href="#1-上传并解压" class="headerlink" title="1.上传并解压"></a>1.上传并解压</h4><p>​	上传压缩包solr-7.7.2.tgz到&#x2F;usr&#x2F;local&#x2F;tmp中。</p>
<p>​	解压</p>
<pre><code> cd /usr/local/tmp
 tar zxf solr-7.7.2.tgz -C /usr/local/tmp
</code></pre>
<h4 id="2-复制到-x2F-usr-x2F-local中"><a href="#2-复制到-x2F-usr-x2F-local中" class="headerlink" title="2.复制到&#x2F;usr&#x2F;local中"></a>2.复制到&#x2F;usr&#x2F;local中</h4><pre><code> cp -r solr-7.7.2 ../solr
</code></pre>
<h4 id="3-修改启动参数"><a href="#3-修改启动参数" class="headerlink" title="3.修改启动参数"></a>3.修改启动参数</h4><p>​	修改启动参数，否则启动时报警告。提示设置SOLR_ULIMIT_CHECKS&#x3D;false</p>
<pre><code> cd /usr/local/solr/bin
 vim solr.in.sh
</code></pre>





<h4 id="4-启动Solr"><a href="#4-启动Solr" class="headerlink" title="4.启动Solr"></a>4.启动Solr</h4><p>​	Solr内嵌Jetty，直接启动即可。监听8983端口。</p>
<p>​	solr默认不推荐root账户启动，如果是root账户启动需要添加-force参数。</p>
<pre><code># ./solr start -force
</code></pre>
<h4 id="5、可视化管理界面"><a href="#5、可视化管理界面" class="headerlink" title="5、可视化管理界面"></a>5、可视化管理界面</h4><p>​	在关闭防火墙的前提下，可以在windows的浏览器中访问Solr。</p>
<p>​	输入: <span class="exturl" data-url="aHR0cDovLzE5Mi4xNjguOTMuMTA6ODk4My8=">http://192.168.93.10:8983</span> 就可以访问Solr的可视化管理界面。</p>
<p>​	左侧有5个菜单。分别是：</p>
<p>​	（1）Dashboard：面板显示Solr的总体信息。</p>
<p>​	（2）Logging：日志</p>
<p>​	（3）Core Admin：Solr的核心。类似于数据的Database</p>
<p>​	（4）Java Perperties：所有Java相关属性。</p>
<p>​	（5）Thread Dump：线程相关信息。</p>
<p>​	（6）如果有Core，将显示在此处。</p>





<h4 id="6、新建核心"><a href="#6、新建核心" class="headerlink" title="6、新建核心"></a>6、新建核心</h4><p>​	Solr安装完成后默认是没有核心的。需要手动配置。</p>
<p>​	需要在solr&#x2F;server&#x2F;solr下新建文件夹，并给定配置文件，否则无法建立。</p>





<h5 id="6-1-新建目录"><a href="#6-1-新建目录" class="headerlink" title="6.1.新建目录"></a>6.1.新建目录</h5><p>​	在&#x2F;usr&#x2F;local&#x2F;solr&#x2F;server&#x2F;solr中新建自定义名称目录。此处示例名称为testcore。</p>
<pre><code> cd /usr/local/solr/server/solr
 mkdir testcore
</code></pre>
<h5 id="6-2-复制配置文件"><a href="#6-2-复制配置文件" class="headerlink" title="6.2.复制配置文件"></a>6.2.复制配置文件</h5><p>​	在configsets里面包含了_default和sample_techproducts_configs。里面都是配置文件示例。_default属于默认配置，较纯净。sample_techproducts_configs是带有了一些配置示例。</p>
<pre><code># cp -r configsets/_default/conf/ testcore/
</code></pre>
<h5 id="6-3-填写Core信息"><a href="#6-3-填写Core信息" class="headerlink" title="6.3.填写Core信息"></a>6.3.填写Core信息</h5><p>​	在可视化管理界面中Core Admin中编写信息后点击Add Core后，短暂延迟后testcore就会创建成功。schema处不用更改。</p>





<h5 id="6-4-出现testcore"><a href="#6-4-出现testcore" class="headerlink" title="6.4.出现testcore"></a>6.4.出现testcore</h5><p>​	在客户端管理界面中，选择新建的Core后，就可以按照自己项目的需求进行操作了。</p>





<h4 id="7、分词Analysis"><a href="#7、分词Analysis" class="headerlink" title="7、分词Analysis"></a>7、分词Analysis</h4><p>​	在Solr可视化管理界面中，Core的管理菜单项中都会有Analysis。表示根据Scheme.xml(managed-schema)中配置要求进行解析。</p>
<p>​	对英文解析就比较简单了，只要按照空格把英文语句拆分成英文单词即可。</p>





<p>​	但是如果条件是中文时，把一句话按照字进行拆分就不是很合理了。正确的方式是按照合理的词组进行拆分。![](D:&#x2F;马士兵&#x2F;Java 课程&#x2F;13_分布式资料&#x2F;5_Solr&#x2F;文档&#x2F;Solr.assets&#x2F;solr-08.jpg)</p>
<h5 id="7-1-配置步骤"><a href="#7-1-配置步骤" class="headerlink" title="7.1.配置步骤"></a>7.1.配置步骤</h5><p>​	上传ik-analyzer.jar到webapps中。</p>
<p>​	去<span class="exturl" data-url="aHR0cHM6Ly9zZWFyY2gubWF2ZW4ub3JnL3NlYXJjaD9xPWNvbS5naXRodWIubWFnZXNlJUU0JUI4JThCJUU4JUJEJUJEJUU1JUFGJUI5JUU1JUJBJTk0JUU3JTg5JTg4JUU2JTlDJUFDJUU3JTlBJTg0aWstYW5hbHl6ZXIlRTMlODAlODIlRTUlOEYlQUYlRTQlQkIlQTUlRTUlOUMlQTglRTglQjUlODQlRTYlOTYlOTklRTQlQjglQUQlRTclOUIlQjQlRTYlOEUlQTUlRTglOEUlQjclRTUlOEYlOTYlRTMlODAlODI=">https://search.maven.org/search?q=com.github.magese下载对应版本的ik-analyzer。可以在资料中直接获取。</span></p>
<h5 id="7-1-1上传jar到指定目录"><a href="#7-1-1上传jar到指定目录" class="headerlink" title="7.1.1上传jar到指定目录"></a>7.1.1上传jar到指定目录</h5><p>​	上传ik-analyzer-7.7.0.jar到</p>
<p>​	&#x2F;usr&#x2F;local&#x2F;solr&#x2F;server&#x2F;solr-webapp&#x2F;webapp&#x2F;WEB-INF&#x2F;lib目录中</p>
<h5 id="7-1-2修改配置文件"><a href="#7-1-2修改配置文件" class="headerlink" title="7.1.2修改配置文件"></a>7.1.2修改配置文件</h5><p>​	修改&#x2F;usr&#x2F;local&#x2F;solr&#x2F;server&#x2F;solr&#x2F;testcore&#x2F;conf&#x2F;managed-schema</p>
<pre><code># vim /usr/local/solr/server/solr/testcore/conf/managed-schema
</code></pre>
<p>​	添加下面内容。</p>
<p>​	排版：Esc 退出编辑状态下：gg&#x3D;G</p>
<pre><code>&lt;field name=&quot;myfield&quot; type=&quot;text_ik&quot; indexed=&quot;true&quot; stored=&quot;true&quot; /&gt;
    &lt;fieldType name=&quot;text_ik&quot; class=&quot;solr.TextField&quot;&gt;
            &lt;analyzer type=&quot;index&quot;&gt;
                    &lt;tokenizer class=&quot;org.wltea.analyzer.lucene.IKTokenizerFactory&quot; useSmart=&quot;false&quot; conf=&quot;ik.conf&quot;/&gt;
                    &lt;filter class=&quot;solr.LowerCaseFilterFactory&quot;/&gt;
            &lt;/analyzer&gt;
            &lt;analyzer type=&quot;query&quot;&gt;
                    &lt;tokenizer class=&quot;org.wltea.analyzer.lucene.IKTokenizerFactory&quot; useSmart=&quot;true&quot; conf=&quot;ik.conf&quot;/&gt;
                    &lt;filter class=&quot;solr.LowerCaseFilterFactory&quot;/&gt;
            &lt;/analyzer&gt;
    &lt;/fieldType&gt;
</code></pre>
<h5 id="7-1-3重启"><a href="#7-1-3重启" class="headerlink" title="7.1.3重启"></a>7.1.3重启</h5><pre><code># cd /usr/local/solr/bin
# ./solr stop -all
# ./solr start -force
</code></pre>
<h5 id="7-1-4验证"><a href="#7-1-4验证" class="headerlink" title="7.1.4验证"></a>7.1.4验证</h5><p>​	可以在可视化管理界面中找到myfield属性进行验证。</p>





<h5 id="7-2-managed-schema配置说明"><a href="#7-2-managed-schema配置说明" class="headerlink" title="7.2.managed-schema配置说明"></a>7.2.managed-schema配置说明</h5><h5 id="7-2-1-lt-fieldType-x2F-gt"><a href="#7-2-1-lt-fieldType-x2F-gt" class="headerlink" title="7.2.1&lt; fieldType&#x2F;&gt;"></a>7.2.1&lt; fieldType&#x2F;&gt;</h5><p>​	表示定义一个属性类型。在Solr中属性类型都是自定义的。在上面配置中name&#x3D;”text_ik”为自定义类型。当某个属性取值为text_ik时IK Analyzer才能生效。</p>
<h5 id="7-2-2-lt-field-x2F-gt"><a href="#7-2-2-lt-field-x2F-gt" class="headerlink" title="7.2.2&lt; field&#x2F;&gt;"></a>7.2.2&lt; field&#x2F;&gt;</h5><p>​	表示向Document中添加一个属性。</p>
<p>​	常用属性：</p>
<p>​		name: 属性名</p>
<p>​		type:属性类型。所有类型都是solr使用<fieldType>配置的</p>
<p>​		indexed: 是否建立索引</p>
<p>​		stored: solr是否把该属性值响应给搜索用户。</p>
<p>​		required：该属性是否是必须的。默认id是必须的。</p>
<p>​		multiValued：如果为true，表示该属性为复合属性，此属性中包含了多个其他的属性。常用在多个列作为搜索条件时，把这些列定义定义成一个新的复合属性，通过搜索一个复合属性就可以实现搜索多个列。当设置为true时与&lt; copyField source&#x3D;”” dest&#x3D;””&#x2F;&gt;结合使用</p>
<h5 id="7-2-3-lt-uniqueKey-gt"><a href="#7-2-3-lt-uniqueKey-gt" class="headerlink" title="7.2.3&lt; uniqueKey&gt;"></a>7.2.3&lt; uniqueKey&gt;</h5><p>​	唯一主键，Solr中默认定义id属性为唯一主键。ID的值是不允许重复的。</p>
<h5 id="7-2-4-lt-dynamicField-gt"><a href="#7-2-4-lt-dynamicField-gt" class="headerlink" title="7.2.4&lt; dynamicField&gt;"></a>7.2.4&lt; dynamicField&gt;</h5><p>​	名称中允许*进行通配。代表满足特定名称要求的一组属性。</p>
<pre><code> msb_java    
</code></pre>
<p>​	msb_bigdata</p>
<p>​	msb_UI</p>
<p>​        msb_*</p>
<h4 id="8、Dataimport"><a href="#8、Dataimport" class="headerlink" title="8、Dataimport"></a>8、Dataimport</h4><p>​	可以使用Solr自带的Dataimport功能把数据库中数据快速导入到solr中.</p>
<p>​	<strong>必须保证managed-schema和数据库中表的列对应。，添加配置</strong></p>
<h5 id="8-1-修改配置文件"><a href="#8-1-修改配置文件" class="headerlink" title="8.1.修改配置文件"></a>8.1.修改配置文件</h5><p>​	修改solrconfig.xml，添加下面内容</p>
<pre><code> &lt;!-- 配置数据导入的处理器 --&gt;
  &lt;requestHandler name=&quot;/dataimport&quot; class=&quot;org.apache.solr.handler.dataimport.DataImportHandler&quot;&gt;
    &lt;lst name=&quot;defaults&quot;&gt;
      &lt;!--  加载data-config.xml  --&gt;
      &lt;str name=&quot;config&quot;&gt;data-config.xml&lt;/str&gt;
     &lt;/lst&gt;
  &lt;/requestHandler&gt;
</code></pre>
<h5 id="8-2-新建data-config-xml"><a href="#8-2-新建data-config-xml" class="headerlink" title="8.2.新建data-config.xml"></a>8.2.新建data-config.xml</h5><p>​	和solrconfig.xml同一目录下新建data-config.xml</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;dataConfig&gt;
        &lt;dataSource type=&quot;JdbcDataSource&quot;   
                driver=&quot;com.mysql.jdbc.Driver&quot;   
                url=&quot;jdbc:mysql://192.168.1.135:3306/mytest&quot;   
                user=&quot;root&quot;   
                password=&quot;root&quot;/&gt;
        &lt;document&gt;
            &lt;entity name=&quot;product&quot; query=&quot;SELECT id,name,price from t_product&quot;&gt;
                &lt;!-- 
                 实现数据库的列和索引库的字段的映射
                 column 指定数据库的列表
                 name  指定索引库的字段名字，必须和schema.xml中定义的一样
                 --&gt;
                 &lt;field column=&quot;id&quot; name=&quot;id&quot;/&gt;
                 &lt;field column=&quot;name&quot; name=&quot;name&quot;/&gt;
                 &lt;field column=&quot;price&quot; name=&quot;price&quot;/&gt;
            &lt;/entity&gt;
         &lt;/document&gt;
&lt;/dataConfig&gt;
</code></pre>
<h5 id="8-3-添加jar"><a href="#8-3-添加jar" class="headerlink" title="8.3.添加jar"></a>8.3.添加jar</h5><p>​	向solr-webapp中添加<strong>三个jar</strong>。在<strong>dist中两个还有一个数据库驱动。（自己去maven-repository里面找一个 mysql-connector-java ）</strong></p>





<h5 id="8-4-操作"><a href="#8-4-操作" class="headerlink" title="8.4.操作"></a>8.4.操作</h5><p>​	重启solr后，在可视化管理页面中进行数据导入。</p>
<p>​	注意：</p>
<p>​	点击导入按钮后，要记得点击刷新按钮。</p>
<h2 id="Erlang安装"><a href="#Erlang安装" class="headerlink" title="Erlang安装"></a><strong>Erlang安装</strong></h2><h3 id="——1-8"><a href="#——1-8" class="headerlink" title="——1"></a>——1</h3><p>​	RabbitMQ是使用Erlang语言编写的，所以需要先配置Erlang</p>
<h4 id="1-修改主机名"><a href="#1-修改主机名" class="headerlink" title="1 修改主机名"></a>1 <strong>修改主机名</strong></h4><p>​	RabbitMQ是通过主机名进行访问的，必须指定能访问的主机名。</p>
<pre><code>  vim /etc/sysconfig/network
  
  添加
  NETWORKING=yes
  HOSTNAME=node-1 #名字可以随意
</code></pre>





<pre><code>    vim /etc/hosts
  
    ip network_hostname
eg: 192.168.1.195 node-1  
</code></pre>
<p>​	新添加了一行，前面为服务器ip，空格后面添加计算机主机名</p>





<h4 id="2-安装依赖"><a href="#2-安装依赖" class="headerlink" title="2 安装依赖"></a>2 <strong>安装依赖</strong></h4><pre><code>  yum -y install make gcc gcc-c++ kernel-devel m4 ncurses-devel openssl-devel unixODBC unixODBC-devel
</code></pre>
<h4 id="3-上传并解压"><a href="#3-上传并解压" class="headerlink" title="3 上传并解压"></a>3 <strong>上传并解压</strong></h4><p>​	上传otp_src_22.0.tar.gz到&#x2F;usr&#x2F;local&#x2F;tmp目录中，进入目录并解压。</p>
<pre><code> 解压时注意，此压缩包不具有gzip属性，解压参数没有z，只有xf
</code></pre>
<pre><code>  cd /usr/local/tmp
  tar xf otp_src_22.0.tar.gz -C /usr/local/tmp
</code></pre>
<h4 id="4-配置参数"><a href="#4-配置参数" class="headerlink" title="4 配置参数"></a>4 <strong>配置参数</strong></h4><p>​	先新建&#x2F;usr&#x2F;local&#x2F;erlang文件夹，作为安装文件夹</p>
<pre><code>  mkdir -p /usr/local/erlang
</code></pre>
<p>​	 进入文件夹</p>
<pre><code>  cd otp_src_22.0
</code></pre>
<p>​	 配置参数</p>
<pre><code>  ./configure --prefix=/usr/local/erlang --with-ssl --enable-threads --enable-smp-support --enable-kernel-poll --enable-hipe --without-javac
</code></pre>
<h4 id="5-编译并安装"><a href="#5-编译并安装" class="headerlink" title="5 编译并安装"></a>5 <strong>编译并安装</strong></h4><p>​	编译 </p>
<pre><code>  make
</code></pre>
<p>​	 安装</p>
<pre><code>  make install
</code></pre>
<h4 id="6-修改环境变量"><a href="#6-修改环境变量" class="headerlink" title="6 修改环境变量"></a>6 <strong>修改环境变量</strong></h4><p>​	修改&#x2F;etc&#x2F;profile文件</p>
<pre><code> vim /etc/profile
</code></pre>
<p>​	 在文件中添加下面代码 </p>
<pre><code>export PATH=$PATH:/usr/local/erlang/bin
</code></pre>
<p>​	运行文件，让修改内容生效</p>
<pre><code>  source /etc/profile
</code></pre>
<h4 id="7-查看配置是否成功"><a href="#7-查看配置是否成功" class="headerlink" title="7 查看配置是否成功"></a>7 <strong>查看配置是否成功</strong></h4><pre><code>  erl -version
</code></pre>











<h2 id="RabbitMQ安装"><a href="#RabbitMQ安装" class="headerlink" title="RabbitMQ安装"></a>RabbitMQ<strong>安装</strong></h2><h4 id="1-上传并解压-1"><a href="#1-上传并解压-1" class="headerlink" title="1 上传并解压"></a>1 <strong>上传并解压</strong></h4><p>​	上传rabbitmq-server-generic-unix-3.7.18.tar.xz到&#x2F;usr&#x2F;loca&#x2F;tmp中</p>
<pre><code>  cd /usr/local/tmp
  
  tar xf rabbitmq-server-generic-unix-3.7.18.tar.xz -C /usr/local/tmp
</code></pre>
<h4 id="2-复制到local下"><a href="#2-复制到local下" class="headerlink" title="2 复制到local下"></a>2 <strong>复制到local下</strong></h4><p>​	复制解压文件到&#x2F;usr&#x2F;local下，命名为rabbitmq</p>
<pre><code>  cp -r rabbitmq_server-3.7.18 /usr/local/rabbitmq
</code></pre>
<h4 id="3-配置环境变量"><a href="#3-配置环境变量" class="headerlink" title="3 配置环境变量"></a>3 <strong>配置环境变量</strong></h4><pre><code>  vim /etc/profile
</code></pre>
<p>​	在文件中添加 </p>
<pre><code>export PATH=$PATH:/usr/local/rabbitmq/sbin
</code></pre>
<p>​	解析文件</p>
<pre><code> source /etc/profile
</code></pre>
<h4 id="4-开启web管理插件"><a href="#4-开启web管理插件" class="headerlink" title="4 开启web管理插件"></a>4 <strong>开启web管理插件</strong></h4><p>​	进入rabbitmq&#x2F;sbin目录</p>
<pre><code> cd /usr/local/rabbitmq/sbin
</code></pre>
<pre><code> 查看插件列表
</code></pre>
<pre><code>  ./rabbitmq-plugins list
</code></pre>
<pre><code> 生效管理插件
</code></pre>
<pre><code>  ./rabbitmq-plugins enable rabbitmq_management
</code></pre>
<h4 id="5-后台运行"><a href="#5-后台运行" class="headerlink" title="5 后台运行"></a>5 <strong>后台运行</strong></h4><p>​	启动rabbitmq。</p>
<pre><code>  ./rabbitmq-server -detached
</code></pre>
<p>​	停止命令，如果无法停止，使用kill -9 进程号进行关闭</p>
<pre><code> ./rabbitmqctl stop_app
</code></pre>
<h4 id="6-查看web管理界面"><a href="#6-查看web管理界面" class="headerlink" title="6 查看web管理界面"></a>6 <strong>查看web管理界面</strong></h4><p>​	默认可以在安装rabbitmq的电脑上通过用户名：guest密码guest进行访问web管理界面</p>
<p>​	端口号：15672（放行端口，或关闭防火墙）</p>
<p>​	在虚拟机浏览器中输入：</p>
<p>​	<span class="exturl" data-url="aHR0cDovL2xvY2FsaG9zdDoxNTY3Mi8=">http://localhost:15672</span></p>
<h3 id="RabbitMq账户管理"><a href="#RabbitMq账户管理" class="headerlink" title="* RabbitMq账户管理"></a>* RabbitMq账户管理</h3><h4 id="1-创建账户"><a href="#1-创建账户" class="headerlink" title="1 创建账户"></a>1 <strong>创建账户</strong></h4><p>​	语法：.&#x2F;rabbitmqctl add_user username password</p>
<pre><code> cd /usr/local/rabbitmq/sbin
 
 ./rabbitmqctl add_user mashibing mashibing
</code></pre>
<h4 id="2-给用户授予管理员角色"><a href="#2-给用户授予管理员角色" class="headerlink" title="2 给用户授予管理员角色"></a>2 <strong>给用户授予管理员角色</strong></h4><p>​	其中smallming为新建用户的用户名</p>
<pre><code> ./rabbitmqctl set_user_tags mashibing administrator
</code></pre>
<h4 id="3-给用户授权"><a href="#3-给用户授权" class="headerlink" title="3 给用户授权"></a>3 <strong>给用户授权</strong></h4><p>​	“&#x2F;” 表示虚拟机</p>
<p>​	mashibing 表示用户名</p>
<p>​	“.<em>“ “.</em>“ “.*” 表示完整权限</p>
<pre><code> ./rabbitmqctl set_permissions -p &quot;/&quot; mashibing &quot;.*&quot; &quot;.*&quot; &quot;.*&quot;
</code></pre>
<h4 id="4-登录"><a href="#4-登录" class="headerlink" title="4 登录"></a>4 <strong>登录</strong></h4><p>​	使用新建账户和密码在windows中访问rabbitmq并登录 </p>
<p>​	在浏览器地址栏输入：</p>
<p>​	<span class="exturl" data-url="aHR0cDovL2lwOjE1NjcyLw==">http://ip:15672/</span></p>
<pre><code> 用户名：mashibing
</code></pre>
<p>​	密码：mashibing</p>
<h2 id="SolrCloud"><a href="#SolrCloud" class="headerlink" title="SolrCloud"></a>SolrCloud</h2><p>​	Solr可以搭建具备容错能力和高可用的Solr集群。集群中集群配置、自动负载均衡和查询故障转移、			Zookeeper集群实现集群协调管理，这些全部功能统称为SolrCloud。</p>
<p>​	SolrCloud是基于Zookeeper进行管理的。在Solr中已经内置了Zookeeper相关内容，当执行集群创建命令会自动创建Zookeeper相关内容。这个使用的是Zookeeper的集群管理功能实现的。</p>
<h4 id="1-搭建"><a href="#1-搭建" class="headerlink" title="1.搭建"></a>1.搭建</h4><h5 id="1-1创建"><a href="#1-1创建" class="headerlink" title="1.1创建"></a>1.1创建</h5><p>​	SolrCloud已经包含在了Solr中，可以直接启动Solr集群。</p>
<pre><code> ./solr -e cloud -noprompt -force
</code></pre>
<p>​	此命令等同于# .&#x2F;solr -e cloud -force全部参数为默认值。</p>
<p>​	运行成功后会在example文件夹多出cloud文件夹。</p>
<h5 id="1-2停止"><a href="#1-2停止" class="headerlink" title="1.2停止"></a>1.2停止</h5><pre><code> ./solr stop -all
</code></pre>
<h5 id="1-3重新运行"><a href="#1-3重新运行" class="headerlink" title="1.3重新运行"></a>1.3重新运行</h5><pre><code> ./solr start -c -p 8983 -s ../example/cloud/node1/solr/ -force
 ./solr start -c -p 7574 -z localhost:9983 -s ../example/cloud/node2/solr/ -force
</code></pre>
<h2 id="HDFS安装"><a href="#HDFS安装" class="headerlink" title="HDFS安装"></a>HDFS安装</h2><h3 id="——1-9"><a href="#——1-9" class="headerlink" title="——1"></a>——1</h3><h3 id="——2-7"><a href="#——2-7" class="headerlink" title="——2"></a>——2</h3><p>1.拉取Hadoop镜像（可以在docker hub上找合适的镜像）：</p>
<pre><code class="shell">docker pull singularities/hadoop
</code></pre>
<p>2.创建docker-compose.yml文件（可以在文本编辑器中写好后，复制），内容如下：</p>
<pre><code class="yml">
version: &quot;2&quot;

services:
  namenode:
    image: singularities/hadoop
    command: start-hadoop namenode
    environment:
      HDFS_USER: hdfsuser
    ports:
      - &quot;8020:8020&quot;
      - &quot;14000:14000&quot;
      - &quot;50070:50070&quot;
      - &quot;10020:10020&quot;
      - &quot;13562:13562&quot;
      - &quot;19888:19888&quot;
  datanode:
    image: singularities/hadoop
    command: start-hadoop datanode namenode
    environment:
      HDFS_USER: hdfsuser
    links:
      - namenode
</code></pre>
<p>3.创建hadoop，执行如下命令</p>
<pre><code class="shell">docker-compose up -d
docker ps
</code></pre>
<p>4.开启多个datanode</p>
<pre><code class="shell">docker-compose scale datanode=3
docker ps
</code></pre>
<p>5.查看hadoop控制面板。由于服务刚初始化，可能需要等一会。访问类似如下url：</p>
<pre><code class="ruby">http://192.168.1.195:50070/dfshealth.html#tab-datanode
</code></pre>
<p>6.进入任意hadoop相关容器，<strong>直接进行hdfs基础操作</strong><br>在任意datanode的容器中操作hdfs，会自动同步到其他的datanode容器中。</p>
<pre><code class="bash"># 查看所有命令
hadoop fs
# 创建目录
hadoop fs -mkdir /hdfs #在根目录下创建hdfs文件夹
# 查看目录
hadoop fs -ls  /   #列出根目录下的文件列表
# 创建多级目录
hadoop fs -mkdir -p /hdfs/d1/d2
# 上传文件到HDFS
echo &quot;hello world&quot; &gt;&gt; local.txt   #创建文件
hadoop fs -put local.txt /hdfs/   #上传文件到hdfs
# 下载hdfs文件
hadoop fs -get /hdfs/local.txt
# 删除hdfs中的文件
hadoop fs -rm /hdfs/local.txt
# 删除hdfs中的目录
hadoop fs -rmdir /hdfs/d1/d2
</code></pre>
<h2 id="Kafka-安装"><a href="#Kafka-安装" class="headerlink" title="Kafka 安装"></a>Kafka 安装</h2><blockquote>
<p>安装前提，kafka安装运行最低支持jdk7；本篇演示版本是基于jdk1.8；</p>
</blockquote>
<p>官方下载地址：<span class="exturl" data-url="aHR0cHM6Ly9saW5rLnpoaWh1LmNvbS8/dGFyZ2V0PWh0dHA6Ly9rYWZrYS5hcGFjaGUub3JnL2Rvd25sb2Fkcw==">Apache Kafka</span></p>
<p>kafka 是由scala语言编写，下载稳定版本，即前一个版本</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/onlymarryu/typora-ims-test@master/tools-All/v2-9f6503ade62cfa48df87cc9da984e87d_720w.jpg" alt="img"></p>
<p>点击进入后，按如下方式点击下载</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/onlymarryu/typora-ims-test@master/tools-All/v2-bd19bea83d1cb978fbeed614ee126da6_720w.jpg" alt="img"></p>
<p>下载完成后进行解压缩</p>
<pre><code class="sh">tar -zxvf kafka_2.12-2.8.0.tgz 
mv kafka_2.12-2.8.0 /usr/local/kafka
</code></pre>
<p>解压完成后进入kafka目录</p>
<pre><code class="sh">cd /usr/local/kafka
</code></pre>
<p><img data-src="https://cdn.jsdelivr.net/gh/onlymarryu/typora-ims-test@master/tools-All/v2-dfe360dfc7561953761f8ce69f782f4d_720w.png" alt="img"></p>
<p>kafka 是基于 Zookeeper 的消息管理系统，所以启动的时候是需要使用到 Zookeeper ，但其内置了Zookeeper ，所以只需要根据bin目录下的文件进行启动即可</p>
<p>启动Zookeeper 服务端命令</p>
<pre><code class="text">./bin/zookeeper-server-start.sh ./config/zookeeper.properties 
</code></pre>
<p>Zookeeper 启动成功后会出现 <code>binding to port 0.0.0.0/0.0.0.0:2181</code> 所示结果表示启动成功；</p>
<p><img data-src="https://pic1.zhimg.com/80/v2-6be2f91cd4ec47d589d3c5b58584c4b8_720w.png" alt="img"></p>
<p>启动kafka服务端命令</p>
<pre><code class="text"> ./bin/kafka-server-start.sh  ./config/server.properties
</code></pre>
<h2 id="MyCat-Server安装"><a href="#MyCat-Server安装" class="headerlink" title="MyCat(Server安装)"></a>MyCat(Server安装)</h2><ul>
<li><p>前提：</p>
<ul>
<li>1、<a href="#jdk_install">jdk安装</a></li>
<li>2、<a href="#mysql_install">mysql安装</a></li>
</ul>
</li>
<li><p>官网：<span class="exturl" data-url="aHR0cDovL3d3dy5teWNhdC5vcmcuY24v">http://www.mycat.org.cn/</span></p>
</li>
<li><p>首先准备四台虚拟机，安装好mysql，方便后续做读写分离和主从复制。**(3.3内容)**</p>
<pre><code class="shell">192.168.85.45 node01
192.168.85.46 node02
192.168.85.47 node03
192.168.85.48 node04
</code></pre>
</li>
</ul>
<h4 id="1、下载MyCat"><a href="#1、下载MyCat" class="headerlink" title="1、下载MyCat"></a>1、下载MyCat</h4><p><span class="exturl" data-url="aHR0cDovL2RsLm15Y2F0Lm9yZy5jbi8xLjYuNy42LzIwMjEwOTMwMjEzMDQ5L015Y2F0LXNlcnZlci0xLjYuNy42LXJlbGVhc2UtMjAyMTA5MzAyMTMwNDktbGludXgudGFyLmd6">http://dl.mycat.org.cn/1.6.7.6/20210930213049/Mycat-server-1.6.7.6-release-20210930213049-linux.tar.gz</span></p>
<pre><code class="shell">windows下载安装包
</code></pre>
<h4 id="2、上传并解压压缩文件"><a href="#2、上传并解压压缩文件" class="headerlink" title="2、上传并解压压缩文件"></a>2、上传并解压压缩文件</h4><pre><code class="shell"> tar -zxvf Mycat-server-1.6.7.5-release-20200422133810-linux.tar.gz -C /usr/local/ 
</code></pre>
<h4 id="3、修改配置"><a href="#3、修改配置" class="headerlink" title="3、修改配置"></a>3、修改配置</h4><p>0、配置环境变量（可选）</p>
<pre><code class="shell">vim /etc/profile
# 添加如下配置信息：
export MYCAT_HOME=/usr/local/mycat
export PATH=$MYCAT_HOME/bin:$PATH:$JAVA_HOME/bin

# 生效
source /etc/profile
</code></pre>
<p><strong>修改server.xml schema.xml之前先备份</strong></p>
<pre><code class="shell">cd /usr/local/mycat

cd conf

cp server.xml server.xml.list
cp schema.xml schema.xml.list
</code></pre>
<p>1、修改完成后的  <strong>server.xml</strong></p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!-- - - Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); 
        - you may not use this file except in compliance with the License. - You 
        may obtain a copy of the License at - - http://www.apache.org/licenses/LICENSE-2.0 
        - - Unless required by applicable law or agreed to in writing, software - 
        distributed under the License is distributed on an &quot;AS IS&quot; BASIS, - WITHOUT 
        WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. - See the 
        License for the specific language governing permissions and - limitations 
        under the License. --&gt;
&lt;!DOCTYPE mycat:server SYSTEM &quot;server.dtd&quot;&gt;
&lt;mycat:server xmlns:mycat=&quot;http://io.mycat/&quot;&gt;
        &lt;user name=&quot;root&quot; defaultAccount=&quot;true&quot;&gt;
                &lt;property name=&quot;password&quot;&gt;root&lt;/property&gt;
                &lt;property name=&quot;schemas&quot;&gt;TESTDB&lt;/property&gt;
                &lt;property name=&quot;defaultSchema&quot;&gt;TESTDB&lt;/property&gt;
        &lt;/user&gt;
&lt;/mycat:server&gt;
</code></pre>
<p>2、修改完成后的 schema.xml</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;!DOCTYPE mycat:schema SYSTEM &quot;schema.dtd&quot;&gt;
&lt;mycat:schema xmlns:mycat=&quot;http://io.mycat/&quot;&gt;
        &lt;schema name=&quot;TESTDB&quot; checkSQLschema=&quot;false&quot; sqlMaxLimit=&quot;100&quot; dataNode=&quot;dn1&quot;&gt;
        &lt;/schema&gt;
        &lt;dataNode name=&quot;dn1&quot; dataHost=&quot;host1&quot; database=&quot;msb&quot; /&gt;
        &lt;dataHost name=&quot;host1&quot; maxCon=&quot;1000&quot; minCon=&quot;10&quot; balance=&quot;0&quot;
                          writeType=&quot;0&quot; dbType=&quot;mysql&quot; dbDriver=&quot;native&quot; switchType=&quot;1&quot;  slaveThreshold=&quot;100&quot;&gt;
                &lt;heartbeat&gt;select user()&lt;/heartbeat&gt;
                &lt;writeHost host=&quot;hostM1&quot; url=&quot;192.168.1.45:3306&quot; user=&quot;root&quot;
                                   password=&quot;root&quot;&gt;
                         &lt;readHost host=&quot;hostS1&quot; url=&quot;192.168.1.46:3306&quot; user=&quot;root&quot; password=&quot;root&quot;&gt;&lt;/readHost&gt;
                &lt;/writeHost&gt;
        &lt;/dataHost&gt;
&lt;/mycat:schema&gt;
</code></pre>
<p>3、修改 <strong>hosts</strong>  文件</p>
<pre><code class="shell">vim /etc/hosts

#添加
#ip name
192.168.1.164 node01
</code></pre>
<h4 id="4、启动mycat"><a href="#4、启动mycat" class="headerlink" title="4、启动mycat"></a>4、启动mycat</h4><p>​		mycat的启动有两种方式，一种是控制台启动，一种是后台启动，在初学的时候建议大家使用控制台启动的方式，当配置文件写错之后，可以方便的看到错误，及时修改，但是在生产环境中，使用后台启动的方式比较稳妥。</p>
<p>​		<strong>控制台启动：</strong></p>
<pre><code class="shell">cd /usrlocal/mycat/bin
./mycat console

#加入环境变量后可直接启动
mycat console
</code></pre>
<p>​		<strong>后台启动：</strong></p>
<pre><code class="shell">cd /usrlocal/mycat/bin
./mycat start

#加入环境变量后可直接启动
mycat start
</code></pre>
<p>​		按照如上配置在安装的时候应该不会报错，如果出现错误，根据错误的提示解决即可。</p>
<h4 id="5、登录验证"><a href="#5、登录验证" class="headerlink" title="5、登录验证"></a>5、登录验证</h4><p>​		<strong>管理窗口的登录</strong></p>
<p>​		从另外的虚拟机去登录访问当前mycat，输入如下命令即可</p>
<pre><code>mysql -uroot -proot -P 9066 -h ip
</code></pre>
<p>​		此时访问的是mycat的管理窗口，可以通过show @@help查看可以执行的命令</p>
<p>​		<strong>数据窗口的登录</strong></p>
<p>​		从另外的虚拟机去登录访问mycat，输入命令如下：【用户设置】</p>
<pre><code>mysql -uroot -proot -P8066 -h ip
</code></pre>
<p>​		当都能够成功的时候以为着mycat已经搭建完成。</p>
<h2 id="HAProxy安装"><a href="#HAProxy安装" class="headerlink" title="HAProxy安装"></a>HAProxy安装</h2><h3 id="——1-10"><a href="#——1-10" class="headerlink" title="——1"></a>——1</h3><h4 id="1、准备好HAProxy的安装包"><a href="#1、准备好HAProxy的安装包" class="headerlink" title="1、准备好HAProxy的安装包"></a>1、准备好HAProxy的安装包</h4><p><span class="exturl" data-url="aHR0cHM6Ly9zcmMuZmVkb3JhcHJvamVjdC5vcmcvcmVwby9wa2dzL2hhcHJveHkv">https://src.fedoraproject.org/repo/pkgs/haproxy/</span></p>
<h4 id="2、解压到-x2F-usr-x2F-local目录"><a href="#2、解压到-x2F-usr-x2F-local目录" class="headerlink" title="2、解压到&#x2F;usr&#x2F;local目录"></a>2、解压到&#x2F;usr&#x2F;local目录</h4><h4 id="3、进入到解压后的目录，查看内核版本，进行编译"><a href="#3、进入到解压后的目录，查看内核版本，进行编译" class="headerlink" title="3、进入到解压后的目录，查看内核版本，进行编译"></a>3、进入到解压后的目录，查看内核版本，进行编译</h4><pre><code class="shell">cd cd /usr/local/haproxy-1.8.25/

# 查看内核版本3.10=31
uname -r

make TARGET=linux31
</code></pre>
<h4 id="4、编译完成之后，开始进行安装"><a href="#4、编译完成之后，开始进行安装" class="headerlink" title="4、编译完成之后，开始进行安装"></a>4、编译完成之后，开始进行安装</h4><pre><code class="shell">make install PREFIX=/usr/local/haproxy
</code></pre>
<h4 id="5、安装完成之后，创建目录，创建HAProxy配置文件"><a href="#5、安装完成之后，创建目录，创建HAProxy配置文件" class="headerlink" title="5、安装完成之后，创建目录，创建HAProxy配置文件"></a>5、安装完成之后，创建目录，创建HAProxy配置文件</h4><pre><code class="shell">mkdir -p /usr/data/haproxy
mkdir /usr/local/haproxy/conf
vi /usr/local/haproxy/conf、haproxy.conf
</code></pre>
<p>6、向配置文件中添加配置信息</p>
<pre><code class="shell">    global
        log 127.0.0.1 local0
        #log 127.0.0.1 local1 notice
        #log loghost local0 info
        maxconn 4096
        chroot /usr/local/haproxy
        pidfile /usr/data/haproxy/haproxy.pid
        uid 99
        gid 99
        daemon
        #debug
        #quiet
defaults
        log global
        mode tcp
        option abortonclose
        option redispatch
        retries 3
        maxconn 2000
        timeout connect 5000
        timeout client 50000
        timeout server 50000
listen proxy_status
    bind :48066
        mode tcp
        balance roundrobin
        server mycat_1 192.168.85.111:8066 check inter 10s
        server mycat_2 192.168.85.112:8066 check inter 10s
frontend admin_stats
    bind :7777
        mode http
        stats enable
        option httplog
        maxconn 10
        stats refresh 30s
        stats uri /admin
        stats auth admin:123123
        stats hide-version
        stats admin if TRUE
</code></pre>
<ul>
<li>stats uri &#x2F;admin                   		   <strong>账号</strong></li>
<li>stats auth admin:123123       	   <strong>密码</strong></li>
</ul>
<h4 id="7、启动haproxy服务"><a href="#7、启动haproxy服务" class="headerlink" title="7、启动haproxy服务"></a>7、启动haproxy服务</h4><pre><code class="shell">    /usr/local/haproxy/sbin/haproxy -f /usr/local/haproxy/conf/haproxy.conf
</code></pre>
<h4 id="8、查看haproxy的进程，如果存在则说明没有问题"><a href="#8、查看haproxy的进程，如果存在则说明没有问题" class="headerlink" title="8、查看haproxy的进程，如果存在则说明没有问题"></a>8、查看haproxy的进程，如果存在则说明没有问题</h4><pre><code class="shell">    ps -ef | grep haproxy
</code></pre>
<h4 id="9、打开浏览器访问-用户名为admin，密码为123123"><a href="#9、打开浏览器访问-用户名为admin，密码为123123" class="headerlink" title="9、打开浏览器访问,用户名为admin，密码为123123"></a>9、打开浏览器访问,用户名为admin，密码为123123</h4><p>​	<span class="exturl" data-url="aHR0cDovLzE5Mi4xNjguMS4xNjQ6Nzc3Ny9hZG1pbg==">http://192.168.1.164:7777/admin</span></p>
<h2 id="Keepalived安装"><a href="#Keepalived安装" class="headerlink" title="Keepalived安装"></a>Keepalived安装</h2><h3 id="——1-11"><a href="#——1-11" class="headerlink" title="——1"></a>——1</h3><h4 id="1、准备好Keepalived安装包"><a href="#1、准备好Keepalived安装包" class="headerlink" title="1、准备好Keepalived安装包"></a>1、准备好Keepalived安装包</h4><h4 id="2、解压到-x2F-usr-x2F-local目录-1"><a href="#2、解压到-x2F-usr-x2F-local目录-1" class="headerlink" title="2、解压到&#x2F;usr&#x2F;local目录"></a>2、解压到&#x2F;usr&#x2F;local目录</h4><pre><code class="shell">tar -zxvf /usr/local/tmp/keepalived-1.4.5.tar.gz -C /usr/local/
</code></pre>
<h4 id="3、安装需要依赖的环境组件"><a href="#3、安装需要依赖的环境组件" class="headerlink" title="3、安装需要依赖的环境组件"></a>3、安装需要依赖的环境组件</h4><pre><code class="shell">yum install gcc openssl-devel popt-devel -y
</code></pre>
<h4 id="4、进入到解压目录，进行编译"><a href="#4、进入到解压目录，进行编译" class="headerlink" title="4、进入到解压目录，进行编译"></a>4、进入到解压目录，进行编译</h4><pre><code>cd /usr/local/keepalived-1.4.5
./configure --prefix=/usr/local/keepalived	
</code></pre>
<h4 id="5、编译完成之后，进行安装"><a href="#5、编译完成之后，进行安装" class="headerlink" title="5、编译完成之后，进行安装"></a>5、编译完成之后，进行安装</h4><pre><code class="shell">make &amp;&amp; make install
</code></pre>
<h4 id="6、将keepalived的服务注册为系统服务"><a href="#6、将keepalived的服务注册为系统服务" class="headerlink" title="6、将keepalived的服务注册为系统服务"></a>6、将keepalived的服务注册为系统服务</h4><pre><code class="shell">cp  -rf   /usr/local/keepalived-1.4.5/keepalived/etc/init.d/keepalived /etc/init.d/
mkdir /etc/keepalived
cp   -rf  /usr/local/keepalived/etc/keepalived/keepalived.conf /etc/keepalived/
cp   -rf  /usr/local/keepalived-1.4.5/keepalived/etc/sysconfig/keepalived /etc/sysconfig/
cp   -rf  /usr/local/keepalived/sbin/keepalived /usr/sbin/
</code></pre>
<h4 id="7、修改配置文件"><a href="#7、修改配置文件" class="headerlink" title="7、修改配置文件"></a>7、修改配置文件</h4><pre><code class="shell">vim  /etc/keepalived/keepalived.conf
</code></pre>
<p><strong>CentOS-6   下的配置文件</strong></p>
<pre><code class="shell">! Configuration File for keepalived
global_defs &#123;
   notification_email &#123;
     acassen@firewall.loc
     failover@firewall.loc
     sysadmin@firewall.loc
   &#125;
   notification_email_from Alexandre.Cassen@firewall.loc
   smtp_server 127.0.0.1
   smtp_connect_timeout 30
   router_id LVS_DEVEL
   vrrp_skip_check_adv_addr
   vrrp_garp_interval 0
   vrrp_gna_interval 0
&#125;

vrrp_instance VI_1 &#123;
    # 配置为主
    state MASTER
    # 设置网卡
    interface eth0
     # 虚拟路由ID，全局唯一
    virtual_router_id 51
    # 优先级，权重值
    priority 100
    advert_int 1
    authentication &#123;
        auth_type PASS
        auth_pass 1111
    &#125;
    virtual_ipaddress &#123;
         192.168.1.100/24  dev eth0 label eth0:3:
    &#125;
&#125;
</code></pre>
<p><strong>CentOS-7   下的配置文件</strong></p>
<pre><code class="conf">! Configuration File for keepalived
global_defs &#123;
   notification_email &#123;
     acassen@firewall.loc
     failover@firewall.loc
     sysadmin@firewall.loc
   &#125;
   notification_email_from Alexandre.Cassen@firewall.loc
   smtp_server 127.0.0.1
   smtp_connect_timeout 30
   router_id LVS_DEVEL
   vrrp_skip_check_adv_addr
   vrrp_garp_interval 0
   vrrp_gna_interval 0
&#125;

vrrp_instance VI_1 &#123;
    # 配置为主
    state MASTER
    # 设置网卡
    interface ens33
     # 虚拟路由ID，全局唯一
    virtual_router_id 51
    # 优先级，权重值
    priority 100
    advert_int 1
    authentication &#123;
        auth_type PASS
        auth_pass 1111
    &#125;
    virtual_ipaddress &#123;
        192.168.1.100/24 
    &#125;
&#125;
</code></pre>
<h4 id="8、启动keepalived"><a href="#8、启动keepalived" class="headerlink" title="8、启动keepalived"></a>8、启动keepalived</h4><pre><code class="shell">service keepalived start
#或者
systemctl start keepalived.service
</code></pre>
<h4 id="9、登录验证"><a href="#9、登录验证" class="headerlink" title="9、登录验证"></a>9、登录验证</h4><pre><code class="shell">mysql -uroot -p123456 -h 192.168.1.100 -P 48066
</code></pre>
<h2 id="mycat-web"><a href="#mycat-web" class="headerlink" title="mycat-web"></a>mycat-web</h2><h3 id="——1-12"><a href="#——1-12" class="headerlink" title="——1"></a>——1</h3><h4 id="1、下载mycat-web安装包"><a href="#1、下载mycat-web安装包" class="headerlink" title="1、下载mycat-web安装包"></a>1、下载mycat-web安装包</h4><p>​	官方地址：<span class="exturl" data-url="aHR0cDovL2RsLm15Y2F0Lm9yZy5jbi8=">http://dl.mycat.org.cn/</span></p>
<h4 id="2、解压安装包到-x2F-usr-x2F-local目录"><a href="#2、解压安装包到-x2F-usr-x2F-local目录" class="headerlink" title="2、解压安装包到&#x2F;usr&#x2F;local目录"></a>2、解压安装包到&#x2F;usr&#x2F;local目录</h4><pre><code class="shell">tar -zxvf Mycat-web-1.0-SNAPSHOT-20170102153329-linux.tar.gz -C /usr/local/
</code></pre>
<h4 id="3、进入mycat-web的目录运行启动命令"><a href="#3、进入mycat-web的目录运行启动命令" class="headerlink" title="3、进入mycat-web的目录运行启动命令"></a>3、进入mycat-web的目录运行启动命令</h4><pre><code class="shell">    ./start.sh &amp;
</code></pre>
<h4 id="4、mycat-web的服务端口是8082，查看服务是否启动"><a href="#4、mycat-web的服务端口是8082，查看服务是否启动" class="headerlink" title="4、mycat-web的服务端口是8082，查看服务是否启动"></a>4、mycat-web的服务端口是8082，查看服务是否启动</h4><pre><code class="shell">    netstat -nlpt | grep 8082
</code></pre>
<h4 id="5、通过地址访问服务"><a href="#5、通过地址访问服务" class="headerlink" title="5、通过地址访问服务"></a>5、通过地址访问服务</h4><pre><code class="shell">    192.168.1.164:8082/mycat/
</code></pre>
<h4 id="6、mycat-web配置"><a href="#6、mycat-web配置" class="headerlink" title="6、mycat-web配置"></a>6、mycat-web配置</h4><h5 id="6-1、配置zookeeper-可选"><a href="#6-1、配置zookeeper-可选" class="headerlink" title="6.1、配置zookeeper(可选)"></a>6.1、配置zookeeper(可选)</h5><pre><code class="shell">cd /usr/local/mycat-web/mycat-web/WEB-INF/classes

#修改mycat.properties文件，可以修改zookeeper的地址
vim mycat.properties
</code></pre>
<h5 id="6-2、添加mycat实例"><a href="#6-2、添加mycat实例" class="headerlink" title="6.2、添加mycat实例"></a>6.2、添加mycat实例</h5><pre><code>* 在页面的mycat配置

* mycat服务管理中添加mycat实例，需要填写相关的参数
</code></pre>
<h2 id="Nacos安装"><a href="#Nacos安装" class="headerlink" title="Nacos安装"></a>Nacos安装</h2><p><strong>注：</strong></p>
<ul>
<li><p>安装之前必须 配置  <a href="#jdk_install">jdk</a></p>
</li>
<li><p>安装之前必须 配置  <a href="#mysql_install">mysql5.6.+</a></p>
</li>
</ul>
<div name="nacos_install_1">

<h3 id="——1-13"><a href="#——1-13" class="headerlink" title="——1"></a>——1</h3><h4 id="1、准备安装包"><a href="#1、准备安装包" class="headerlink" title="1、准备安装包"></a>1、准备安装包</h4><p>官网：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FsaWJhYmEvbmFjb3MvcmVsZWFzZXM=">https://github.com/alibaba/nacos/releases</span></p>
<p>本篇我们选择version：2.0.3</p>
<h4 id="2、上传并解压"><a href="#2、上传并解压" class="headerlink" title="2、上传并解压"></a>2、上传并解压</h4><pre><code class="shell">tar -zxvf nacos-server-2.0.3 .tar.gz -C /usr/local/
</code></pre>
<h4 id="3、修改配置-1"><a href="#3、修改配置-1" class="headerlink" title="3、修改配置"></a>3、修改配置</h4><blockquote>
<p>1、使用nacos-mysql.sql</p>
<p>​		为我们储存数据建立数据库、表</p>
<p>2、<code>application.properties里面修改数据储存位置为mysql</code></p>
</blockquote>
<pre><code class="shell">cd /usr/local/nacos/conf
</code></pre>
<pre><code class="sql">-- 1 建立数据库
create  database nacos_config;
use nacos_config;

CREATE TABLE `config_info` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT &#39;id&#39;,
  `data_id` varchar(255) NOT NULL COMMENT &#39;data_id&#39;,
  `group_id` varchar(255) DEFAULT NULL,
  `content` longtext NOT NULL COMMENT &#39;content&#39;,
  `md5` varchar(32) DEFAULT NULL COMMENT &#39;md5&#39;,
  `gmt_create` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#39;创建时间&#39;,
  `gmt_modified` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#39;修改时间&#39;,
  `src_user` text COMMENT &#39;source user&#39;,
  `src_ip` varchar(50) DEFAULT NULL COMMENT &#39;source ip&#39;,
  `app_name` varchar(128) DEFAULT NULL,
  `tenant_id` varchar(128) DEFAULT &#39;&#39; COMMENT &#39;租户字段&#39;,
  `c_desc` varchar(256) DEFAULT NULL,
  `c_use` varchar(64) DEFAULT NULL,
  `effect` varchar(64) DEFAULT NULL,
  `type` varchar(64) DEFAULT NULL,
  `c_schema` text,
  PRIMARY KEY (`id`),
  UNIQUE KEY `uk_configinfo_datagrouptenant` (`data_id`,`group_id`,`tenant_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT=&#39;config_info&#39;;


CREATE TABLE `config_info_aggr` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT &#39;id&#39;,
  `data_id` varchar(255) NOT NULL COMMENT &#39;data_id&#39;,
  `group_id` varchar(255) NOT NULL COMMENT &#39;group_id&#39;,
  `datum_id` varchar(255) NOT NULL COMMENT &#39;datum_id&#39;,
  `content` longtext NOT NULL COMMENT &#39;内容&#39;,
  `gmt_modified` datetime NOT NULL COMMENT &#39;修改时间&#39;,
  `app_name` varchar(128) DEFAULT NULL,
  `tenant_id` varchar(128) DEFAULT &#39;&#39; COMMENT &#39;租户字段&#39;,
  PRIMARY KEY (`id`),
  UNIQUE KEY `uk_configinfoaggr_datagrouptenantdatum` (`data_id`,`group_id`,`tenant_id`,`datum_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT=&#39;增加租户字段&#39;;



CREATE TABLE `config_info_beta` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT &#39;id&#39;,
  `data_id` varchar(255) NOT NULL COMMENT &#39;data_id&#39;,
  `group_id` varchar(128) NOT NULL COMMENT &#39;group_id&#39;,
  `app_name` varchar(128) DEFAULT NULL COMMENT &#39;app_name&#39;,
  `content` longtext NOT NULL COMMENT &#39;content&#39;,
  `beta_ips` varchar(1024) DEFAULT NULL COMMENT &#39;betaIps&#39;,
  `md5` varchar(32) DEFAULT NULL COMMENT &#39;md5&#39;,
  `gmt_create` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#39;创建时间&#39;,
  `gmt_modified` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#39;修改时间&#39;,
  `src_user` text COMMENT &#39;source user&#39;,
  `src_ip` varchar(50) DEFAULT NULL COMMENT &#39;source ip&#39;,
  `tenant_id` varchar(128) DEFAULT &#39;&#39; COMMENT &#39;租户字段&#39;,
  PRIMARY KEY (`id`),
  UNIQUE KEY `uk_configinfobeta_datagrouptenant` (`data_id`,`group_id`,`tenant_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT=&#39;config_info_beta&#39;;


CREATE TABLE `config_info_tag` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT &#39;id&#39;,
  `data_id` varchar(255) NOT NULL COMMENT &#39;data_id&#39;,
  `group_id` varchar(128) NOT NULL COMMENT &#39;group_id&#39;,
  `tenant_id` varchar(128) DEFAULT &#39;&#39; COMMENT &#39;tenant_id&#39;,
  `tag_id` varchar(128) NOT NULL COMMENT &#39;tag_id&#39;,
  `app_name` varchar(128) DEFAULT NULL COMMENT &#39;app_name&#39;,
  `content` longtext NOT NULL COMMENT &#39;content&#39;,
  `md5` varchar(32) DEFAULT NULL COMMENT &#39;md5&#39;,
  `gmt_create` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#39;创建时间&#39;,
  `gmt_modified` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#39;修改时间&#39;,
  `src_user` text COMMENT &#39;source user&#39;,
  `src_ip` varchar(50) DEFAULT NULL COMMENT &#39;source ip&#39;,
  PRIMARY KEY (`id`),
  UNIQUE KEY `uk_configinfotag_datagrouptenanttag` (`data_id`,`group_id`,`tenant_id`,`tag_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT=&#39;config_info_tag&#39;;


CREATE TABLE `config_tags_relation` (
  `id` bigint(20) NOT NULL COMMENT &#39;id&#39;,
  `tag_name` varchar(128) NOT NULL COMMENT &#39;tag_name&#39;,
  `tag_type` varchar(64) DEFAULT NULL COMMENT &#39;tag_type&#39;,
  `data_id` varchar(255) NOT NULL COMMENT &#39;data_id&#39;,
  `group_id` varchar(128) NOT NULL COMMENT &#39;group_id&#39;,
  `tenant_id` varchar(128) DEFAULT &#39;&#39; COMMENT &#39;tenant_id&#39;,
  `nid` bigint(20) NOT NULL AUTO_INCREMENT,
  PRIMARY KEY (`nid`),
  UNIQUE KEY `uk_configtagrelation_configidtag` (`id`,`tag_name`,`tag_type`),
  KEY `idx_tenant_id` (`tenant_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT=&#39;config_tag_relation&#39;;


CREATE TABLE `group_capacity` (
  `id` bigint(20) unsigned NOT NULL AUTO_INCREMENT COMMENT &#39;主键ID&#39;,
  `group_id` varchar(128) NOT NULL DEFAULT &#39;&#39; COMMENT &#39;Group ID，空字符表示整个集群&#39;,
  `quota` int(10) unsigned NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;配额，0表示使用默认值&#39;,
  `usage` int(10) unsigned NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;使用量&#39;,
  `max_size` int(10) unsigned NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;单个配置大小上限，单位为字节，0表示使用默认值&#39;,
  `max_aggr_count` int(10) unsigned NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;聚合子配置最大个数，，0表示使用默认值&#39;,
  `max_aggr_size` int(10) unsigned NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;单个聚合数据的子配置大小上限，单位为字节，0表示使用默认值&#39;,
  `max_history_count` int(10) unsigned NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;最大变更历史数量&#39;,
  `gmt_create` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#39;创建时间&#39;,
  `gmt_modified` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#39;修改时间&#39;,
  PRIMARY KEY (`id`),
  UNIQUE KEY `uk_group_id` (`group_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT=&#39;集群、各Group容量信息表&#39;;


CREATE TABLE `his_config_info` (
  `id` bigint(64) unsigned NOT NULL,
  `nid` bigint(20) unsigned NOT NULL AUTO_INCREMENT,
  `data_id` varchar(255) NOT NULL,
  `group_id` varchar(128) NOT NULL,
  `app_name` varchar(128) DEFAULT NULL COMMENT &#39;app_name&#39;,
  `content` longtext NOT NULL,
  `md5` varchar(32) DEFAULT NULL,
  `gmt_create` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP,
  `gmt_modified` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP,
  `src_user` text,
  `src_ip` varchar(50) DEFAULT NULL,
  `op_type` char(10) DEFAULT NULL,
  `tenant_id` varchar(128) DEFAULT &#39;&#39; COMMENT &#39;租户字段&#39;,
  PRIMARY KEY (`nid`),
  KEY `idx_gmt_create` (`gmt_create`),
  KEY `idx_gmt_modified` (`gmt_modified`),
  KEY `idx_did` (`data_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT=&#39;多租户改造&#39;;


CREATE TABLE `tenant_capacity` (
  `id` bigint(20) unsigned NOT NULL AUTO_INCREMENT COMMENT &#39;主键ID&#39;,
  `tenant_id` varchar(128) NOT NULL DEFAULT &#39;&#39; COMMENT &#39;Tenant ID&#39;,
  `quota` int(10) unsigned NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;配额，0表示使用默认值&#39;,
  `usage` int(10) unsigned NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;使用量&#39;,
  `max_size` int(10) unsigned NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;单个配置大小上限，单位为字节，0表示使用默认值&#39;,
  `max_aggr_count` int(10) unsigned NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;聚合子配置最大个数&#39;,
  `max_aggr_size` int(10) unsigned NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;单个聚合数据的子配置大小上限，单位为字节，0表示使用默认值&#39;,
  `max_history_count` int(10) unsigned NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;最大变更历史数量&#39;,
  `gmt_create` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#39;创建时间&#39;,
  `gmt_modified` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#39;修改时间&#39;,
  PRIMARY KEY (`id`),
  UNIQUE KEY `uk_tenant_id` (`tenant_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT=&#39;租户容量信息表&#39;;


CREATE TABLE `tenant_info` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT &#39;id&#39;,
  `kp` varchar(128) NOT NULL COMMENT &#39;kp&#39;,
  `tenant_id` varchar(128) default &#39;&#39; COMMENT &#39;tenant_id&#39;,
  `tenant_name` varchar(128) default &#39;&#39; COMMENT &#39;tenant_name&#39;,
  `tenant_desc` varchar(256) DEFAULT NULL COMMENT &#39;tenant_desc&#39;,
  `create_source` varchar(32) DEFAULT NULL COMMENT &#39;create_source&#39;,
  `gmt_create` bigint(20) NOT NULL COMMENT &#39;创建时间&#39;,
  `gmt_modified` bigint(20) NOT NULL COMMENT &#39;修改时间&#39;,
  PRIMARY KEY (`id`),
  UNIQUE KEY `uk_tenant_info_kptenantid` (`kp`,`tenant_id`),
  KEY `idx_tenant_id` (`tenant_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT=&#39;tenant_info&#39;;

CREATE TABLE `users` (
    `username` varchar(50) NOT NULL PRIMARY KEY,
    `password` varchar(500) NOT NULL,
    `enabled` boolean NOT NULL
);

CREATE TABLE `roles` (
    `username` varchar(50) NOT NULL,
    `role` varchar(50) NOT NULL,
    UNIQUE INDEX `idx_user_role` (`username` ASC, `role` ASC) USING BTREE
);

CREATE TABLE `permissions` (
    `role` varchar(50) NOT NULL,
    `resource` varchar(255) NOT NULL,
    `action` varchar(8) NOT NULL,
    UNIQUE INDEX `uk_role_permission` (`role`,`resource`,`action`) USING BTREE
);

INSERT INTO users (username, password, enabled) VALUES (&#39;nacos&#39;, &#39;$2a$10$EuWPZHzz32dJN7jexM34MOeYirDdFAZm2kuWj7VEOJhhZkDrxfvUu&#39;, TRUE);

INSERT INTO roles (username, role) VALUES (&#39;nacos&#39;, &#39;ROLE_ADMIN&#39;);
</code></pre>
<pre><code class="shell">
#2 先留取备份
cp application.properties application.properties.bk

vim application.properties

# 在application.properties最后添加以下内容
spring.datasource.platform=mysql

db.num=1
db.url.0=jdbc:mysql://127.0.0.1:3306/nacos_config?characterEncoding=utf8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=true&amp;serverTimezone=UTC
db.user=root
db.password=root
</code></pre>
<h4 id="4、开启nacos"><a href="#4、开启nacos" class="headerlink" title="4、开启nacos"></a>4、开启nacos</h4><pre><code class="shell">/usr/local/nacos/bin/startup.sh
</code></pre>
<h4 id="5、查看"><a href="#5、查看" class="headerlink" title="5、查看"></a>5、查看</h4><ul>
<li>测试之前先关闭防火墙</li>
</ul>
<p><span class="exturl" data-url="aHR0cDovLzE5Mi4xNjguMS41Mjo4ODQ4L25hY29z">http://192.168.1.52:8848/nacos</span></p>
<h2 id="Nacos集群配置"><a href="#Nacos集群配置" class="headerlink" title="Nacos集群配置"></a>Nacos集群配置</h2><ul>
<li>前提</li>
</ul>
<blockquote>
<p>1、安装  <a href="#jdk_install">jdk</a></p>
<p>2、安装之前必须 配置  <a href="#mysql_install">mysql5.6.+</a></p>
<p>3、配置 <a href="#nginx_install_1">nginx</a></p>
<p>4、配置 <a href="#nacos_install_1">Nacos（单机版-1）</a></p>
</blockquote>
<ul>
<li>懒加载</li>
</ul>
<blockquote>
<p>我们启动nginx之后可能不会立即开始代理，打开日志等一会，没有结果的时候重配一下</p>
</blockquote>
<h3 id="——1-14"><a href="#——1-14" class="headerlink" title="——1"></a>——1</h3><p>​	* 此例中  <code>nginx:1.16</code> 安装教程为： <a href="#nacos_install_1">Nacos（单机版-1）</a></p>
<h4 id="1、修改集群配置文件"><a href="#1、修改集群配置文件" class="headerlink" title="1、修改集群配置文件"></a>1、修改集群配置文件</h4><p>​	这里开始正式配置集群，首先我们要更改   <strong>cluter.conf</strong>   这个配置文件，当然我们也需要备份，但是这里它的<strong>原始名称</strong>为：<strong>cluster.conf.example</strong> ，我们需要把它保留同时复制出一个cluster.conf来进行更改</p>
<pre><code class="shell">cd /usr/local/nacos/conf

# 先备份
cp cluster.conf.example cluster.conf
</code></pre>
<p>修改cluster.conf</p>
<pre><code class="shell"># 格式： ip地址:端口号
#
# Copyright 1999-2018 Alibaba Group Holding Ltd.
#
# Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

#it is ip
#example
#192.168.16.101:8847
#192.168.16.102
#192.168.16.10

#ip:port
192.168.124.133:3333
192.168.124.133:4444
192.168.124.133:5555
</code></pre>
<h4 id="2、编辑Nacos的启动脚本startup-sh"><a href="#2、编辑Nacos的启动脚本startup-sh" class="headerlink" title="2、编辑Nacos的启动脚本startup.sh"></a>2、编辑Nacos的启动脚本startup.sh</h4><pre><code class="shell">cd /usr/local/nacos/bin

# 先备份
cp startup.sh starup.sh.bk
vim  startup.sh 
</code></pre>
<pre><code class="shell">#1  在while 的变量中添加 o 并且在case 中添加对应处理
        o)
            PORT=$OPTARG;;
        
#2  在nohup 和&quot;$JAVA_OPT_EXT_FIX&quot;之前配置这个
     $JAVA -Dserver.port=$&#123;PORT&#125;  
 
</code></pre>
<img data-src="/2022/10/15/tools/tools-All/1648643016965.png" class="" width="1648643016965">

<img data-src="/2022/10/15/tools/tools-All/1648643157451.png" class="" width="1648643157451">





<h4 id="3、配置nginx"><a href="#3、配置nginx" class="headerlink" title="3、配置nginx"></a>3、配置nginx</h4><pre><code class="shell">    
    upstream  cluster&#123;
    server 192.168.1.52:3333;
    server 192.168.1.52:4444;
    server 192.168.1.52:5555;
    &#125;

    proxy_pass  http://cluter;
</code></pre>
<p><strong>图片中 <code>cluster</code>写错了 少了一个<code>s</code> ，其实问题也不大，但是要专业~~</strong></p>
<img data-src="/2022/10/15/tools/tools-All/1648643539716.png" class="" width="1648643539716">



<h4 id="4、启动Nginx"><a href="#4、启动Nginx" class="headerlink" title="4、启动Nginx"></a>4、启动Nginx</h4><pre><code class="shell">
</code></pre>
<h4 id="5、查看测试"><a href="#5、查看测试" class="headerlink" title="5、查看测试"></a>5、查看测试</h4><p><span class="exturl" data-url="aHR0cDovLzE5Mi4xNjguMS41Mi9uYWNvcw==">http://192.168.1.52:80/nacos</span></p>
<h2 id="OpenSSL安装"><a href="#OpenSSL安装" class="headerlink" title="OpenSSL安装"></a>OpenSSL安装</h2><h3 id="——1-15"><a href="#——1-15" class="headerlink" title="——1"></a>——1</h3><p>参考链接：<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZlY3Rvcl9kYXRhL2FydGljbGUvZGV0YWlscy8xMDc1NTc5NDE=">https://blog.csdn.net/vector_data/article/details/107557941</span></p>
<h4 id="1-安装依赖C语言依赖-1"><a href="#1-安装依赖C语言依赖-1" class="headerlink" title="1.安装依赖C语言依赖"></a>1.安装依赖C语言依赖</h4><p>​	redis使用C语言编写，所以需要安装C语言库</p>
<pre><code class="sh">yum install -y gcc zlib 
</code></pre>
<p>​	</p>
<h4 id="2-上传并解压-1"><a href="#2-上传并解压-1" class="headerlink" title="2.上传并解压"></a>2.上传并解压</h4><p>​	把 <code>openssl-1.1.1j.tar.gz</code> 上传到&#x2F;usr&#x2F;local&#x2F;tmp中，解压文件</p>
<pre><code> cd /usr/local/tmp

 tar zxf openssl-1.1.1j.tar.gz 
 mv openssl-1.1.1j ../openssl
 
</code></pre>
<h4 id="3-编译并安装-2"><a href="#3-编译并安装-2" class="headerlink" title="3.编译并安装"></a>3.编译并安装</h4><p>​	进入解压文件夹</p>
<pre><code class="sh">  cd /usr/local/openssl
</code></pre>
<p>​	 配置编译 </p>
<pre><code class="sh">./config
</code></pre>
<p>​	编译安装	</p>
<pre><code>make clean &amp;&amp; make install
</code></pre>
<p>​	测试</p>
<pre><code>openssl version -a
</code></pre>
<h2 id="Kettle安装"><a href="#Kettle安装" class="headerlink" title="Kettle安装"></a>Kettle安装</h2><p> <a href="#Windows_kettle">他是java写的，所以跨平台，去看Windows里面的安装方法</a></p>
<h1 id="未完成-！————Linux"><a href="#未完成-！————Linux" class="headerlink" title="未完成 ！————Linux"></a>未完成 ！————Linux</h1><h1 id="PATH——-Windows"><a href="#PATH——-Windows" class="headerlink" title="PATH——-Windows"></a>PATH——-Windows</h1><h2 id="MySQL安装"><a href="#MySQL安装" class="headerlink" title="MySQL安装"></a>MySQL安装</h2><h3 id="【1】MySQL的版本："><a href="#【1】MySQL的版本：" class="headerlink" title="【1】MySQL的版本："></a>【1】MySQL的版本：</h3><p>近期主要历史版本有5.0&#x2F;5.1&#x2F;5.5&#x2F;5.6&#x2F;5.7，目前最新版本是MySQL8。6.0曾经是个内部试验版本，已取消了。</p>
<p>MySQL8.0的版本历史</p>
<ol>
<li>2016-09-12第一个DM(development milestone)版本8.0.0发布</li>
<li>2018-04-19第一个GA(General Availability)版本开始，8.0.11发布</li>
<li>2018-07-27 8.0.12GA发布</li>
<li>2018-10-22 8.0.13GA发布</li>
<li>2019-01-21 8.0.14GA发布</li>
<li>2019-02-01 8.0.15GA发布</li>
<li>最新的版本是8.0.18,2019年10月14日正式发布</li>
<li>….后续更新</li>
</ol>
<h3 id="【2】官方下载地址："><a href="#【2】官方下载地址：" class="headerlink" title="【2】官方下载地址："></a>【2】官方下载地址：</h3><p><span class="exturl" data-url="aHR0cHM6Ly9kZXYubXlzcWwuY29tL2Rvd25sb2Fkcy93aW5kb3dzL2luc3RhbGxlci84LjAuaHRtbA==">https://dev.mysql.com/downloads/windows/installer/8.0.html</span></p>







<h3 id="【3】安装过程："><a href="#【3】安装过程：" class="headerlink" title="【3】安装过程："></a>【3】安装过程：</h3><p><strong>1.双击MySQL安装文件mysql-installer-community-8.0.18.0.msi，出现安装类型选项。</strong></p>
<ul>
<li><p>Developer Default：开发者默认</p>
</li>
<li><p>Server only：只安装服务器端 </p>
</li>
<li><p>Client only：只安装客户端</p>
</li>
<li><p>Full：安装全部选项</p>
</li>
<li><p>Custom：自定义安装</p>
</li>
</ul>





<p><strong>2.选择，然后继续：</strong></p>





<p><strong>3.进入产品配置向导，配置多个安装细节，点击Next按钮即可。</strong></p>





<p><strong>4.高可靠性High Availability，采用默认选项即可。</strong></p>
<ul>
<li><p>Standalone MySQL Server&#x2F;Classic MySQL Replication:独立MySQL服务器&#x2F;经典MySQL复制</p>
</li>
<li><p>InnoDB Cluster:InnoDB集群</p>
</li>
</ul>





<p><strong>5.类型和网络 Type and Networking，采用默认选项即可。记住MySQL的监听端口默认是3306。</strong></p>





<p><strong>6.身份验证方法Authentication Method，采用默认选项即可。</strong></p>
<p> <img data-src="/tools-All%5C1646193956569.png" alt="1646193956569"></p>
<p><strong>7.账户和角色 Accounts and Roles。MySQL管理员账户名称是root，在此处指定root用户的密码。还可以在此处通过Add User按钮添加其他新账户，此处省略该操作。</strong></p>





<p><strong>8.Windows服务：Windows Service。</strong></p>
<ul>
<li><p>Configure MySQL Server as a Windows Service:给MySQL服务器配置一个服务项。</p>
</li>
<li><p>Windows Service Name:服务名称，采用默认名称MySQL80即可。</p>
</li>
<li><p>Start the MySQL at System Startup：系统启动时开启MySQL服务</p>
</li>
</ul>









<p><strong>9.Apply Configuration：点击Execute按钮执行开始应用这些配置项。</strong></p>
<ul>
<li><p>Writing configuration file: 写配置文件。</p>
</li>
<li><p>Updating Windows Firewall rules：更新Windows防火墙规则</p>
</li>
<li><p>Adjusting Windows services：调整Windows服务</p>
</li>
<li><p>Initializing database：初始化数据库</p>
</li>
<li><p>Starting the server： 启动服务器</p>
</li>
<li><p>Applying security setting：应用安全设置</p>
</li>
<li><p>Updating the Start menu link：更新开始菜单快捷方式链接</p>
</li>
</ul>





<p><strong>PS：如果配置出错，查看右侧的log，查看对应错误信息。</strong><br><strong>执行完成后，如下图所示。单击Finish完成安装，进入产品配置环节。</strong></p>





<p><strong>10.产品配置Product Configuration到此结束：点击Next按钮。</strong></p>





<p><strong>11.安装完成 Installation Complete。点击Finish按钮完成安装。</strong></p>







<h3 id="【4】MySQL配置、登录"><a href="#【4】MySQL配置、登录" class="headerlink" title="【4】MySQL配置、登录"></a>【4】MySQL配置、登录</h3><p><strong>【1】登录：</strong><br>访问MySQL服务器对应的命令：mysql.exe ,位置：C:\Program Files\MySQL\MySQL Server 8.0\bin</p>







<p>（mysql.exe需要带参数执行，所以直接在图形界面下执行该命令会自动结束）</p>
<p>打开控制命令台：win+r:</p>





<p>执行mysql.exe命令的时候出现错误：</p>





<p>需要配置环境变量path:</p>





<p><strong>注意：控制命令台必须重启才会生效：</strong></p>
<p><strong>登录的命令：mysql  -hlocalhost -uroot –p</strong></p>
<ul>
<li><p>mysql：bin目录下的文件mysql.exe。mysql是MySQL的命令行工具，是一个客户端软件，可以对任何主机的mysql服务（即后台运行的mysqld）发起连接。</p>
</li>
<li><p>-h：host主机名。后面跟要访问的数据库服务器的地址；<strong>如果是登录本机，可以省略</strong></p>
</li>
<li><p>-u：user 用户名。后面跟登录数据的用户名，第一次安装后以root用户来登录，是MySQL的管理员用户</p>
</li>
<li><p>-p:   password 密码。一般不直接输入，而是回车后以保密方式输入。 </p>
<p><img data-src="/tools-All%5C1646194262329.png" alt="1646194262329"></p>
</li>
</ul>
<p><strong>【2】访问数据库</strong></p>
<p>显示MySQL中的数据库列表：</p>
<pre><code class="shell">show databases;
</code></pre>
<p> 默认有四个自带的数据库，每个数据库中可以有多个数据库表、视图等对象。</p>
<p>切换当前数据库的命令：</p>
<pre><code class="shell">use mysql;
</code></pre>
<ul>
<li><p>MySQL下可以有多个数据库，如果要访问哪个数据库，需要将其置为当前数据库。</p>
</li>
<li><p>该命令的作用就是将数据库mysql（默认提供的四个数据库之一的名字）置为当前数据库</p>
</li>
</ul>
<p>显示当前数据库的所有数据库表：</p>
<pre><code class="shell">show tables;
</code></pre>
<p>MySQL 层次：不同项目对应不同的数据库组成 - 每个数据库中有很多表  - 每个表中有很多数据</p>
<p><strong>【3】退出数据库</strong></p>
<p>退出数据库可以使用quit或者exit命令完成，也可以用\q;  完成退出操作</p>







<h3 id="【5】卸载"><a href="#【5】卸载" class="headerlink" title="【5】卸载"></a>【5】卸载</h3><p><strong>1)停止MySQL服务：在命令行模式下执行net stop mysql或者在Windows服务窗口下停止服务</strong></p>





<p><strong>2)在控制面板中删除MySQL软件</strong></p>





<p><strong>3)删除软件文件夹：直接删除安装文件夹C:\Program Files\MySQL，其实此时该文件夹已经被删除或者剩下一个空文件夹。</strong></p>
<p><strong>4)删除数据文件夹：直接删除文件夹C:\ProgramData\MySQL。此步不要忘记，否则会影响MySQL的再次安装。</strong><br><strong>（ProgramData文件夹可能是隐藏的，显示出来即可）</strong><br><strong>（MySQL文件下的内容才是真正的MySQL中数据）</strong></p>
<p><strong>5)删除path环境变量中关于MySQL安装路径的配置</strong> </p>
<h2 id="Tomcat安装-1"><a href="#Tomcat安装-1" class="headerlink" title="Tomcat安装"></a>Tomcat安装</h2><p>下载</p>
<p>下载地址：<span class="exturl" data-url="aHR0cDovL3RvbWNhdC5hcGFjaGUub3JnLw==">http://tomcat.apache.org/</span></p>





<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>tomcat由apache开源组织使用java开发的一款web容器,在使用之前需要安装JDK及配置JAVA_HOME.Tomcat是绿色软解，<strong>解压就可使用</strong>。如果之前已经安装了其他tomcat并且还配置了CATALINA_HOME 不要忘记修改CATALINA_HOME指向我们现在使用的这个tomcat</p>
<h3 id="Tomcat启动"><a href="#Tomcat启动" class="headerlink" title="Tomcat启动"></a>Tomcat启动</h3><p>运行startup.bat文件。</p>
<p>一定要配置JAVA_HOME   C:\Program Files\Java\jdk1.8.0_161<br>部分电脑需要配置CATALINA_HOME   D:&#x2F;<em><strong>&#x2F;</strong></em>&#x2F;apache-tomcat-9.0.41<br>记住一个习惯:以后我们装任何一个软件路径都应该避免中文,空格和特殊符号,可以使用_</p>
<h3 id="Tomcat关闭"><a href="#Tomcat关闭" class="headerlink" title="Tomcat关闭"></a>Tomcat关闭</h3><p>  运行shutdown.bat文件或者直接关闭掉启动窗口。</p>
<h3 id="访问Tomcat"><a href="#访问Tomcat" class="headerlink" title="访问Tomcat"></a>访问Tomcat</h3><p>访问Tomcat的URL格式：<span class="exturl" data-url="aHR0cDovL2lwOnBvcnQ=">http://ip:port</span></p>
<p>访问本机Tomcat的URL格式：<span class="exturl" data-url="aHR0cDovL2xvY2FsaG9zdDo4MDgwLw==">http://localhost:8080</span></p>
<h2 id="Git安装"><a href="#Git安装" class="headerlink" title="Git安装"></a>Git安装</h2><p>【1】Git官网：<br><span class="exturl" data-url="aHR0cHM6Ly9naXQtc2NtLmNvbS8=">https://git-scm.com/</span> </p>
<p>【2】安装过程：</p>
<p>一直下一步</p>






































<p>点击Git Bash Here打开Git终端：</p>














<h2 id="OpenSSL安装教程"><a href="#OpenSSL安装教程" class="headerlink" title="OpenSSL安装教程"></a>OpenSSL安装教程</h2><p>openssl官网下载地址：<span class="exturl" data-url="aHR0cDovL3NscHJvd2ViLmNvbS9wcm9kdWN0cy9XaW4zMk9wZW5TU0wuaHRtbA==">http://slproweb.com/products/Win32OpenSSL.html</span></p>
<h3 id="安装环境"><a href="#安装环境" class="headerlink" title="安装环境:"></a>安装环境:</h3><blockquote>
<p>windows 10<br>Win64 OpenSSL v1.1.1i</p>
</blockquote>
<h3 id="一-下载openssl安装版"><a href="#一-下载openssl安装版" class="headerlink" title="一.下载openssl安装版"></a>一.下载openssl安装版</h3><p>​	我这里是win10 64位,所以选的中间那个</p>
<p><img data-src="https://tools-all-blog.csdnimg.cn/20201222101342278.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ2NTUwOTY0,size_16,color_FFFFFF,t_70#pic_center" alt="按照操作系统选择"> </p>
<h3 id="二-安装过程"><a href="#二-安装过程" class="headerlink" title="二.安装过程"></a>二.安装过程</h3><p>​	也没啥特殊的 ，一直next，只有两点注意：</p>
<p>1、修改安装地址</p>
<p>2、最后一步，不要勾选，会掏钱。</p>
<p> <img data-src="https://tools-all-blog.csdnimg.cn/20201222102601218.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ2NTUwOTY0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"> </p>
<p> <img data-src="https://tools-all-blog.csdnimg.cn/20201222102703276.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ2NTUwOTY0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"> </p>
<p> <img data-src="https://tools-all-blog.csdnimg.cn/20201222102703268.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ2NTUwOTY0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"> </p>
<p> <img data-src="https://tools-all-blog.csdnimg.cn/20201222102721958.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ2NTUwOTY0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"> </p>
<img data-src="/2022/10/15/tools/tools-All/1650347562395.png" class="" width="1650347562395">

<h3 id="三-配置环境变量"><a href="#三-配置环境变量" class="headerlink" title="三.配置环境变量"></a>三.配置环境变量</h3><img data-src="/2022/10/15/tools/tools-All/1650351119292.png" class="" width="1650351119292">

 <img data-src="/2022/10/15/tools/tools-All/1650351138506.png" class="" width="1650351138506">



<h3 id="四-测试"><a href="#四-测试" class="headerlink" title="四.测试"></a>四.测试</h3><pre><code class="sh">openssl -version
</code></pre>
<img data-src="/2022/10/15/tools/tools-All/1650351011263.png" class="" width="1650351011263">







<h2 id="Kafka安装"><a href="#Kafka安装" class="headerlink" title="Kafka安装"></a>Kafka安装</h2><p>​	kafka 的安装包其实没有分window 还是 linux, 所以下载的安装包还是之前的安装包，直接解压出来即可；</p>
<p><img data-src="https://pic3.zhimg.com/80/v2-5ea0647a0e4acab3a7c6de90df11fe3e_720w.jpg" alt="img"></p>
<p>启动Zookeeper 服务端命令</p>
<pre><code class="text">./bin\windows\zookeeper-server-start.bat  ./config\zookeeper.properties 
</code></pre>
<p>这边会报一个奇葩的错误，命令行太长，直接将压缩包解压到根目录或者桌面进行操作</p>
<p><img data-src="https://pic4.zhimg.com/80/v2-0f8d03dbe85bdf6f44e05a20d87bc60b_720w.png" alt="img"></p>
<p>启动成功</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/onlymarryu/typora-ims-test@master/tools-All/v2-348c2d162934ac0844103a2cfcf2f16c_720w.jpg" alt="img"></p>
<p>启动kafka服务端命令</p>
<pre><code class="text"> ./bin\windows\kafka-server-start.bat  ./config\server.properties
</code></pre>
<p>启动成功</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/onlymarryu/typora-ims-test@master/tools-All/v2-4f9527f5ed1fb0a09b90cd598b5c09c3_720w.jpg" alt="img"></p>
<div name="Windows_kettle">

<h2 id="Kettle安装-1"><a href="#Kettle安装-1" class="headerlink" title="Kettle安装"></a>Kettle安装</h2><p>下载地址：<span class="exturl" data-url="aHR0cHM6Ly9saW5rLnpoaWh1LmNvbS8/dGFyZ2V0PWh0dHBzOi8vc291cmNlZm9yZ2UubmV0L3Byb2plY3RzL3BlbnRhaG8vZmlsZXMvRGF0YSUyMEludGVncmF0aW9uLw==">https://sourceforge.net/project</span></p>
<p>下载完成解压到任意路径</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/onlymarryu/typora-ims-test@master/tools-All/v2-9b34b600471d87b624e1a355af5e1a77_720w.png" alt="img"></p>
<p>打开文件夹，找到Spoon.bat，创建桌面快捷方式，打开</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/onlymarryu/typora-ims-test@master/tools-All/v2-304e8e08f977c9e1f6c3c1aef07d76ad_720w.png" alt="img"></p>
<p><img data-src="https://cdn.jsdelivr.net/gh/onlymarryu/typora-ims-test@master/tools-All/v2-5a6b50aa38075f30a80868319b57189a_720w.jpg" alt="img"></p>
<p>成功打开，安装完成</p>
<p>最后还要配置下oracle的驱动</p>
<p>找到oracle的安装目录搜索关键字：ojdbc</p>
<p>把ojdbc5.jar文件复制到ETL的lib目录下</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/onlymarryu/typora-ims-test@master/tools-All/v2-dd6bd35ae080600c32d3cf75ccc40389_720w.jpg" alt="img"></p>
<p>这样就可以在kettle里连接到数据库了</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/onlymarryu/typora-ims-test@master/tools-All/v2-79043e230a5f8c040c429855c8766b9c_720w.jpg" alt="img"></p>
<h2 id="redis安装-1"><a href="#redis安装-1" class="headerlink" title="redis安装"></a>redis安装</h2><p><strong>下载地址：</strong><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3Rwb3JhZG93c2tpL3JlZGlzL3JlbGVhc2Vz">https://github.com/tporadowski/redis/releases</span></p>
<img data-src="/2022/10/15/tools/tools-All/3B8D633F-14CE-42E3-B174-FCCD48B11FF3.jpg" class="" title="img">



<p>打开文件夹，内容如下：</p>
<p><img data-src="https://www.runoob.com/wp-content/uploads/2014/11/C2CEBAA0-30B9-4340-8D23-78F6FEB8CBE2.png%22" alt="img"></p>
<p>打开一个 <strong>cmd</strong> 窗口 使用 cd 命令切换目录到 <strong>C:\redis</strong> 运行：</p>
<pre><code class="sh">redis-server.exe redis.windows.conf
</code></pre>
<p>如果想方便的话，可以把 redis 的路径加到系统的环境变量里，这样就省得再输路径了，后面的那个 redis.windows.conf 可以省略，如果省略，会启用默认的。输入之后，会显示如下界面：</p>
<img data-src="/2022/10/15/tools/tools-All/redis-install1.png" class="" title="Redis 安装">



<p>这时候另启一个 cmd 窗口，原来的不要关闭，不然就无法访问服务端了。</p>
<p>切换到 redis 目录下运行:</p>
<pre><code>redis-cli.exe -h 127.0.0.1 -p 6379
</code></pre>
<h1 id="未完成-！————-Windows"><a href="#未完成-！————-Windows" class="headerlink" title="未完成 ！———— Windows"></a>未完成 ！———— Windows</h1><h1 id="———————————————-1"><a href="#———————————————-1" class="headerlink" title="———————————————"></a>———————————————</h1><h1 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h1><h2 id="0、布置在服务器中的东西，通过URL-无法访问"><a href="#0、布置在服务器中的东西，通过URL-无法访问" class="headerlink" title="0、布置在服务器中的东西，通过URL 无法访问"></a>0、布置在服务器中的东西，通过URL 无法访问</h2><blockquote>
<p>​	1、防火墙问题</p>
<p>​	2、端口 释放问题 ，<strong>·我们要手动去配置我们服务器的安全组·</strong></p>
</blockquote>
<div name="perblem-1">

<h2 id="1、解决：CentOS-7-每次进入要重新加载环境变量"><a href="#1、解决：CentOS-7-每次进入要重新加载环境变量" class="headerlink" title="1、解决：CentOS 7 每次进入要重新加载环境变量"></a>1、解决：CentOS 7 每次进入要重新加载环境变量</h2><pre><code class="shell">1.进入系统配置文件
vim ~/.bashrc

2.末尾添加如下代码
source /etc/profile

保存即可
:wq
</code></pre>
<h2 id="2、端口占用、查看端口"><a href="#2、端口占用、查看端口" class="headerlink" title="2、端口占用、查看端口"></a>2、端口占用、查看端口</h2><pre><code class="shell">查看是否运行端口   
netstat -tln 8080

查看端口属于哪个程序？端口被哪个进程占用(得到PID)	
lsof -i :8080  

关闭PID对应的程序            
kill -9 (PID)
</code></pre>
<div name="preblem_2">

<h2 id="3、防火墙关闭、开启"><a href="#3、防火墙关闭、开启" class="headerlink" title="3、防火墙关闭、开启"></a>3、防火墙关闭、开启</h2><pre><code class="shell">关闭防火墙 ，重启失效(Linux系统一重启Linux中的防火墙又会被开起)
service firewalld stop

禁用防火墙，永久有效
systemctl disable firewalld
systemctl disable firewalld.service

启动防火墙 (对禁用的防火墙进行启动)
systemctl enable firewalld

防火墙相关命令：

1）查看防火墙状态：
service  iptables status或者systemctl status firewalld或者firewall-cmd --state

2）暂时关闭防火墙：
systemctl stop firewalld或者service  iptables stop或者systemctl stop firewalld.service

3）永久关闭防火墙：
systemctl disable firewalld或者chkconfig iptables off或者systemctl disable firewalld.service

4）重启防火墙：
systemctl enable firewalld或者service iptables restart  或者systemctl restart firewalld.service

5)永久关闭后重启：
chkconfig iptables on
</code></pre>
<h2 id="4、failure-repodata-x2F-repomd-xml-from-epel-Errno-256-No-more-mirrors-to-try"><a href="#4、failure-repodata-x2F-repomd-xml-from-epel-Errno-256-No-more-mirrors-to-try" class="headerlink" title="4、failure: repodata&#x2F;repomd.xml from epel: [Errno 256] No more mirrors to try."></a>4、failure: repodata&#x2F;repomd.xml from epel: [Errno 256] No more mirrors to try.</h2><p><span class="exturl" data-url="aHR0cDovL21pcnJvcnMuYWxpeXVuLmNvbS9lcGVsLzUveDg2XzY0L3JlcG9kYXRhL3JlcG9tZC54bWw=">http://mirrors.aliyun.com/epel/5/x86_64/repodata/repomd.xml</span>: [Errno 14] HTTP Error 404 - Not Found的解决办法：</p>
<p>​	一直说那个XML文件不存在，以为是yum源是去读取xml当中的数据然后去下载。确实自己去访问也是404.还以	为是这阵子开会yum源都搞不能用了怎么。之前我用阿里用的挺好的。</p>
<p>​	最简单的办法就是删除 &#x2F;etc&#x2F;yum.repos.d&#x2F; 下所有的文件，重新来。</p>
<pre><code class="shell">cd /etc/yum.repos.d/
mkdir repo_bak
mv *.repo repo_bak/
#下载缓存文件 版本自己控制
wget http://mirrors.aliyun.com/repo/Centos-7.repo
yum clean all
yum makecache
</code></pre>
<div name="problem-5"></div>

<h2 id="5、Xshell连接centos7能连上但是连接过程很慢"><a href="#5、Xshell连接centos7能连上但是连接过程很慢" class="headerlink" title="5、Xshell连接centos7能连上但是连接过程很慢"></a>5、Xshell连接centos7能连上但是连接过程很慢</h2><pre><code class="shell">原因：因为在登录时，需要反向解析dns。
解决方法：修改linux配置文件，

vim /etc/ssh/sshd_config

将 # UseDNS yes 此处注释去掉
改为：UseDNS no
</code></pre>
<p><a href="#Linux_minInstall_4">跳转到Linux安装_4</a></p>
<div name="problem-6"></div>
## 6、Xshell 连接Centos7，root拒绝登录，而其他用户可登陆？———— root用户直接登录

<p><strong>PermitRootLogin</strong>  的值改成  yes  ，并保存 </p>
<pre><code class="shell">vim /etc/ssh/sshd_config
</code></pre>
<p> <img data-src="https://tools-all-blog.csdnimg.cn/20210712112157753.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1lhbmdfeWFuZ3lhbmc=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"> </p>
<p> 重启sshd 服务 </p>
<pre><code class="shell">service sshd restart
</code></pre>
<p> 如果上面命令提示文件不存在，可以用下面的命令 </p>
<pre><code>systemctl restart sshd.service
</code></pre>
<p> 如果还不行，直接 重启服务器。。。 </p>
<pre><code>reboot
</code></pre>
<p>意外的是，发现root依然不能登录。最后研究sshd_config的每一行意义，发现坑在这里： </p>
<p><strong>注：有则看，无则跳</strong></p>
<p> <img data-src="https://tools-all-blog.csdnimg.cn/2021071211252989.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1lhbmdfeWFuZ3lhbmc=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"> </p>
<p>文件的最后一行，有一行 ：AllowUsers <span class="exturl" data-url="bWFpbHRvOiYjeDc4OyYjeDc4OyYjMTIwOyYjNjQ7JiM0OTsmIzU3OyYjeDMyOyYjeDJlOyYjeDMxOyYjNTQ7JiM1NjsmI3gyZTsmI3gzMTs=">&#x78;&#x78;&#120;&#64;&#49;&#57;&#x32;&#x2e;&#x31;&#54;&#56;&#x2e;&#x31;</span>.<em>。这是写死的了，即：能远程登录的 用户名、IP 信息。难怪，其他用户一直无法登录。<br>所以，在后面追加：<span class="exturl" data-url="bWFpbHRvOiYjMTE0OyYjeDZmOyYjMTExOyYjeDc0OyYjeDQwOyYjNDk7JiM1NzsmIzUwOyYjeDJlOyYjNDk7JiN4MzY7JiN4Mzg7JiM0NjsmI3gzMTs=">&#114;&#x6f;&#111;&#x74;&#x40;&#49;&#57;&#50;&#x2e;&#49;&#x36;&#x38;&#46;&#x31;</span>.</em><br>修改完的代码为：<span class="exturl" data-url="bWFpbHRvOiYjeDc4OyYjeDc4OyYjMTIwOyYjNjQ7JiN4MzE7JiM1NzsmI3gzMjsmIzQ2OyYjeDMxOyYjNTQ7JiM1NjsmI3gyZTsmIzQ5Ow==">&#x78;&#x78;&#120;&#64;&#x31;&#57;&#x32;&#46;&#x31;&#54;&#56;&#x2e;&#49;</span>.* <span class="exturl" data-url="bWFpbHRvOiYjMTE0OyYjeDZmOyYjeDZmOyYjMTE2OyYjeDQwOyYjNDk7JiN4Mzk7JiN4MzI7JiN4MmU7JiM0OTsmIzU0OyYjNTY7JiN4MmU7JiM0OTs=">&#114;&#x6f;&#x6f;&#116;&#x40;&#49;&#x39;&#x32;&#x2e;&#49;&#54;&#56;&#x2e;&#49;</span>.*<br>然后再执行重启服务操作，然后发现root可以登录了！搞定！！！</p>
<blockquote>
<p>注意：<code>xxx@192.168.1.* root@192.168.1.*</code> 之间要有空格。</p>
<p>或者直接将此行 代码直接注释掉，也可以。</p>
</blockquote>
<p><a href="#Linux_minInstall_6">跳转到Linux安装_最小化安装_6</a></p>
<div name="problem-7"></div>
## 7、yum直接安装docker-ce报错找不到安装包

<pre><code class="shell">#更换成阿里云镜像仓库

yum-config-manager --add-repo   http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo

</code></pre>
<p><a href="#docker_install_3">回到Docker安装步骤3</a></p>
<h2 id="8、docker-查看日志"><a href="#8、docker-查看日志" class="headerlink" title="8、docker 查看日志"></a>8、docker 查看日志</h2><pre><code class="shell"> docker logs [OPTIONS] CONTAINER
  Options:
        --details        显示更多的信息
    -f, --follow         跟踪实时日志
        --since string   显示自某个timestamp之后的日志，或相对时间，如42m（即42分钟）
        --tail string    从日志末尾显示多少行日志， 默认是all
        
    -t, --timestamps     显示时间戳
        --until string   显示自某个timestamp之前的日志，或相对时间，如42m（即42分钟）		
        
</code></pre>
<p>​	查看指定时间后的日志，只显示最后100行：</p>
<pre><code class="shell">$ docker logs -f -t --since=&quot;2018-02-08&quot; --tail=100 CONTAINER_ID
</code></pre>
<p>​	查看最近30分钟的日志:</p>
<pre><code class="shell">$ docker logs --since 30m CONTAINER_ID
</code></pre>
<p>​	查看某时间之后的日志：</p>
<pre><code class="shell">$ docker logs -t --since=&quot;2018-02-08T13:23:37&quot; CONTAINER_ID
</code></pre>
<p>​	查看某时间段日志：</p>
<pre><code class="shell">$ docker logs -t --since=&quot;2018-02-08T13:23:37&quot; --until &quot;2018-02-09T12:23:37&quot; CONTAINER_ID
</code></pre>
<h2 id="9-、如何解决error-failed-to-push-some-refs-to-‘https-gitee-com"><a href="#9-、如何解决error-failed-to-push-some-refs-to-‘https-gitee-com" class="headerlink" title="9 、如何解决error: failed to push some refs to ‘https://gitee.com/"></a>9 、如何解决error: failed to push some refs to ‘<span class="exturl" data-url="aHR0cHM6Ly9naXRlZS5jb20v">https://gitee.com/</span></h2><p>​	出现错误的主要原因是gitee(github)中的README.md文件不在本地代码目录中</p>
<p>​	此时我们要执行git pull –rebase origin master命令<strong>README.md</strong>拉到本地</p>
<pre><code class="shell">git pull --rebase origin master
</code></pre>
<p>然后执行git push origin master</p>
<pre><code class="shell">git push origin master
</code></pre>
<p>就ok啦！</p>
<h2 id="10-、idea-官网下载插件过慢"><a href="#10-、idea-官网下载插件过慢" class="headerlink" title="10 、idea 官网下载插件过慢"></a>10 、idea 官网下载插件过慢</h2><p> <span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1JlYWxfQ1NETl9Vc2VyL2FydGljbGUvZGV0YWlscy8xMTM5NDQ0OTY=">(29条消息) Intellij IDEA下载插件太慢，怎么办？_Real_csdn_User的博客-CSDN博客_idea下载插件很慢</span> </p>
<h3 id="（1）查询自己的网络服务提供商"><a href="#（1）查询自己的网络服务提供商" class="headerlink" title="（1）查询自己的网络服务提供商"></a>（1）查询自己的网络服务提供商</h3><p>访问<span class="exturl" data-url="aHR0cHM6Ly93d3cuaXAxMzguY29tLw==">iP138查询网</span>，查看自己的网络服务提供商并记下它。比如我访问该网站截图如下：<br><img data-src="https://tools-all-blog.csdnimg.cn/20210222191130433.png#pic_center" alt="我的网络服务提供商是移动（为保护隐私，部分内容打码）"><br>如果你已经知道自己的网络服务提供商就不需要这一步。</p>
<h3 id="（2）查找访问插件网站最快的IP"><a href="#（2）查找访问插件网站最快的IP" class="headerlink" title="（2）查找访问插件网站最快的IP"></a>（2）查找访问插件网站最快的IP</h3><p>Intellij IDEA的插件主页地址是<span class="exturl" data-url="aHR0cHM6Ly9wbHVnaW5zLmpldGJyYWlucy5jb20v">https://plugins.jetbrains.com</span>。打开<span class="exturl" data-url="aHR0cDovL3Rvb2wuY2hpbmF6LmNvbS9zcGVlZHRlc3Qv">网站测速 - 站长工具</span>，将插件的主页地址填入输入框内，点击查看分析按钮。一段时间后，就可以看到全中国各个地区访问插件主页的速度。点击表头“总耗时”右侧的小按钮，令全国各地访问插件主页的总耗时按增长顺序排列，这样耗时最短、速度最快的行就在最上方。从表格中找到与自己网络服务提供商相同的行，记下对应的IP地址。下面是我测量的访问插件主页的速度的结果：<br><img data-src="https://tools-all-blog.csdnimg.cn/20210222193138206.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1JlYWxfQ1NETl9Vc2Vy,size_16,color_FFFFFF,t_70#pic_center" alt="我的网络服务提供商是移动，我记下的IP是54.192.23.52"></p>
<h3 id="（3）在hosts文件中为plugins-jetbrains-com添加相关条目"><a href="#（3）在hosts文件中为plugins-jetbrains-com添加相关条目" class="headerlink" title="（3）在hosts文件中为plugins.jetbrains.com添加相关条目"></a>（3）在hosts文件中为plugins.jetbrains.com添加相关条目</h3><p>用文本编辑器打开C:\Windows\System32\drivers\etc\hosts文件。在文件最下方添加一行文字：<br>[你记下的IP地址] plugins.jetbrains.com<br>[你记下的IP地址]用你记下的IP地址代替，记住不要带上方括号，而且IP地址和plugins.jetbrains.com之间有空格。例如我在文件中添加的文字是：<br>13.225.160.7 plugins.jetbrains.com<br>注意：编辑hosts文件需要管理员权限。</p>
<h3 id="三、题外话"><a href="#三、题外话" class="headerlink" title="三、题外话"></a>三、题外话</h3><p>这种方法并不只限于加快下载IDEA插件的速度，只要你知道网络资源的网址，而且该网络资源使用了下载加速服务器，都可以用这种方法。</p>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2><h1 id="未完成——问题"><a href="#未完成——问题" class="headerlink" title="未完成——问题"></a>未完成——问题</h1><h1 id="未完成"><a href="#未完成" class="headerlink" title="未完成"></a>未完成</h1>]]></content>
      <categories>
        <category>工具软件安装</category>
      </categories>
  </entry>
  <entry>
    <title>设计模式</title>
    <url>/2022/10/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/DesignMode/</url>
    <content><![CDATA[<p>valine:<br>  placeholder: “1. 提问前请先仔细阅读本文档⚡\n2. 页面显示问题💥，请提供控制台截图📸或者您的测试网址\n3. 其他任何报错💣，请提供详细描述和截图📸，祝食用愉快💪”</p>
<h1 id="谈谈你对设计模式的理解"><a href="#谈谈你对设计模式的理解" class="headerlink" title="谈谈你对设计模式的理解"></a>谈谈你对设计模式的理解</h1><p>1.首先谈设计模式的作用：经验的传承，提高了软件复用的水平，最终达到提高软件开发效率</p>
<p><strong>五大原则</strong></p>
<table>
<thead>
<tr>
<th>设计原则</th>
<th align="left">简单说明</th>
</tr>
</thead>
<tbody><tr>
<td>单一职责</td>
<td align="left">一个类只负责一项职责</td>
</tr>
<tr>
<td>里氏替换原则</td>
<td align="left">子类可以扩展父类的功能，但不能改变父类原有的功能</td>
</tr>
<tr>
<td>依赖倒置原则</td>
<td align="left">要依赖于抽象，不要依赖于具体，核心思想是<strong>面向接口编程</strong></td>
</tr>
<tr>
<td>接口隔离原则</td>
<td align="left">建立单一接口，不要建立庞大臃肿的接口，尽量细化接口，接口中的方法尽量少</td>
</tr>
<tr>
<td>迪米特法则 （最少知道原则）</td>
<td align="left">一个对象应该对其他对象保持最少的了解</td>
</tr>
<tr>
<td>开闭原则</td>
<td align="left">对扩展开放，对修改关闭</td>
</tr>
</tbody></table>
<p>2.设计模式的分类</p>
<p><img data-src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/1462/1648123011000/2014caaf469649d1a3c84a582ef7319b.png" alt="image.png"></p>
<p>3.创建型模式：都是用来帮助我们创建对象的！</p>
<p><img data-src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/1462/1648123011000/c6b87746e9884c22b56ca99bc265c496.png" alt="image.png"></p>
<p>4.结构性模式:关注对象和类的组织</p>
<p><img data-src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/1462/1648123011000/6b8dffa88b924af6ba3664386d6a9f0a.png" alt="image.png"></p>
<p>5.行为型模式:关注系统中对象之间的相互交换，研究系统在运行时对象之间的相互通信和协作，进一步明确对象的职责，共有11中模式</p>
<p><img data-src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/1462/1648123011000/9bfe35ab4a494cc4ae84a20ee9e30a5c.png" alt="image.png"></p>
<h1 id="一、创建型模式"><a href="#一、创建型模式" class="headerlink" title="一、创建型模式"></a>一、创建型模式</h1><h2 id="1-单例模式"><a href="#1-单例模式" class="headerlink" title="1.单例模式"></a>1.单例模式</h2><p>作用：单例模式的核心是<strong>保证一个类只有一个实例，并且提供一个访问实例的全局访问点。</strong></p>
<table>
<thead>
<tr>
<th>实现方式</th>
<th align="left">优缺点</th>
</tr>
</thead>
<tbody><tr>
<td>饿汉式</td>
<td align="left">线程安全，调用效率高 ，但是不能延迟加载</td>
</tr>
<tr>
<td>懒汉式</td>
<td align="left">线程安全，调用效率不高，能延迟加载</td>
</tr>
<tr>
<td>双重检测锁式</td>
<td align="left">在懒汉式的基础上解决并发问题</td>
</tr>
<tr>
<td>静态内部类式</td>
<td align="left">线程安全，资源利用率高，可以延时加载</td>
</tr>
<tr>
<td>枚举单例</td>
<td align="left">线程安全，调用效率高，但是不能延迟加载</td>
</tr>
</tbody></table>
<h3 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h3><p>也就是类加载的时候立即实例化对象，实现的步骤是先私有化构造方法，对外提供唯一的静态入口方法，实现如下</p>
<pre><code class="java">/**
 * 单例模式：饿汉式
 *
 */
public class SingletonInstance1 &#123;
    // 声明此类型的变量，并实例化，当该类被加载的时候就完成了实例化并保存在了内存中
    private final static SingletonInstance1 instance = new SingletonInstance1();

    // 私有化所有的构造方法,防止直接通过new关键字实例化
    private SingletonInstance1()&#123;&#125;
    // 对外提供一个获取实例的静态方法
    public static SingletonInstance1 getInstance()&#123;
        return instance;
    &#125;
&#125;
</code></pre>
<p>饿汉式单例模式代码中，static变量会在类装载时初始化，此时也不会涉及多个线程对象访问该对象的问题。虚拟机保证只会装载一次该类，肯定不会发生并发访问的问题。因此，可以省略synchronized关键字</p>
<p>问题：如果只是加载本类，而不是要调用getInstance()，甚至永远没有调用，则会造成资源浪费！</p>
<pre><code class="java">/**
 * 单例模式：饿汉式
 *
 */
public class SingletonInstance1 &#123;
    private byte[] b1 = new byte[1024*1024];
    private byte[] b2 = new byte[1024*1024];
    private byte[] b3 = new byte[1024*1024];
    // 声明此类型的变量，并实例化，当该类被加载的时候就完成了实例化并保存在了内存中
    private final static SingletonInstance1 instance = new SingletonInstance1();

    // 私有化所有的构造方法,防止直接通过new关键字实例化
    private SingletonInstance1()&#123;&#125;
    // 对外提供一个获取实例的静态方法
    public static SingletonInstance1 getInstance()&#123;
        return instance;
    &#125;
&#125;
</code></pre>
<h3 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h3><pre><code class="java">/**
 * 单例模式：懒汉式
 *
 */
public class SingletonInstance2 &#123;
    // 声明此类型的变量,但没有实例化
    private static SingletonInstance2 instance = null;

    // 私有化所有的构造方法,防止直接通过new关键字实例化
    private SingletonInstance2()&#123;&#125;
    // 对外提供一个获取实例的静态方法，为了数据安全添加synchronized关键字
    public static synchronized SingletonInstance2 getInstance()&#123;
        if(instance == null)&#123;
            // 当instance不为空的时候才实例化
            instance = new SingletonInstance2();
        &#125;
        return instance;
    &#125;
&#125;
</code></pre>
<p>&amp;emsp;&amp;emsp;此种方式在类加载后如果我们一直没有调用getInstance方法，那么就不会实例化对象。实现了延迟加载，但是因为在方法上添加了synchronized关键字，每次调用getInstance方法都会同步，所以对性能的影响比较大。</p>
<h3 id="双重检测锁"><a href="#双重检测锁" class="headerlink" title="双重检测锁"></a>双重检测锁</h3><pre><code class="java">/**
 * 单例模式：懒汉式
 * 双重检测机制
 *
 */
public class SingletonInstance3 &#123;
    // 声明此类型的变量,但没有实例化
    private static volatile  SingletonInstance3 instance = null;

    // 私有化所有的构造方法,防止直接通过new关键字实例化
    private SingletonInstance3()&#123;&#125;
    // 对外提供一个获取实例的静态方法，
    public static  SingletonInstance3 getInstance()&#123;
        if(instance == null)&#123;
            synchronized(SingletonInstance3.class)&#123;
                if(instance == null)&#123;
                    // 1.分配内存空间  2. 执行构造方法，实例化对象 3.把这个对象赋值给这个空间
                    // 如果不加volatile 会执行重排序 1 3 2 
                    instance = new SingletonInstance3();
                &#125;
            &#125;
        &#125;
        return instance;
    &#125;
&#125;
</code></pre>
<p>不加volatile有指令重排序的问题。添加后可以解决。</p>
<h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><pre><code class="java">/**
 * 静态内部类实现方式
 *
 */
public class SingletonInstance4 &#123;
    // 静态内部类
    public static class SingletonClassInstance&#123;
        // 声明外部类型的静态常量
        public static final SingletonInstance4 instance = new SingletonInstance4();
    &#125;
    // 私有化构造方法
    private SingletonInstance4()&#123;&#125;

    // 对外提供的唯一获取实例的方法
    public static SingletonInstance4 getInstance()&#123;
        return SingletonClassInstance.instance;
    &#125;
&#125;
</code></pre>
<h3 id="枚举单例"><a href="#枚举单例" class="headerlink" title="枚举单例"></a>枚举单例</h3><pre><code class="java">/**
 * 单例模式：枚举方式实现
 *
 */
public enum SingletonInstance5 &#123;

    // 定义一个枚举元素，则这个元素就代表了SingletonInstance5的实例
    INSTANCE;

    public void singletonOperation()&#123;
        // 功能处理
    &#125;
&#125;
</code></pre>
<h2 id="2-怎么解决反射爆破单例"><a href="#2-怎么解决反射爆破单例" class="headerlink" title="2.怎么解决反射爆破单例"></a>2.怎么解决反射爆破单例</h2><p>&amp;emsp;&amp;emsp;在单例中我们定义的私有的构造器，但是我们知道反射是可以操作私有的属性和方法的，这时我们应该怎么处理？</p>
<pre><code class="java">public static void main(String[] args) throws Exception, IllegalAccessException &#123;
    SingletonInstance1 s1 = SingletonInstance1.getInstance();
    // 反射方式获取实例
    Class c1 = SingletonInstance1.class;
    Constructor constructor = c1.getDeclaredConstructor(null);
    constructor.setAccessible(true);
    SingletonInstance1 s2 = (SingletonInstance1)constructor.newInstance(null);
    System.out.println(s1);
    System.out.println(s2);
&#125;
</code></pre>
<p>输出结果</p>
<pre><code class="txt">com.dpb.single.SingletonInstance1@15db9742
com.dpb.single.SingletonInstance1@6d06d69c
</code></pre>
<p>产生了两个对象，和单例的设计初衷违背了。<br>解决的方式是在无参构造方法中手动抛出异常控制,或者声明一个全局变量来控制。</p>
<pre><code class="java">// 私有化所有的构造方法,防止直接通过new关键字实例化
private SingletonInstance2()&#123;
    if(instance != null)&#123;
        // 只能有一个实例存在，如果再次调用该构造方法就抛出异常，防止反射方式实例化
        throw new RuntimeException(&quot;单例模式只能创建一个对象&quot;);
    &#125;
&#125;
</code></pre>
<p>上面这种方式我们还可以通过反序列化的方式来破解</p>
<pre><code class="java">public static void main(String[] args) throws Exception, IllegalAccessException &#123;
    SingletonInstance2 s1 = SingletonInstance2.getInstance();
    // 将实例对象序列化到文件中
    ObjectOutputStream oos = new ObjectOutputStream(
            new FileOutputStream(&quot;c:/tools/a.txt&quot;));
    oos.writeObject(s1);
    oos.flush();
    oos.close();
    // 将实例从文件中反序列化出来
    ObjectInputStream ois = new ObjectInputStream(
            new FileInputStream(&quot;c:/tools/a.txt&quot;));
    SingletonInstance2 s2 = (SingletonInstance2) ois.readObject();
    ois.close();
    System.out.println(s1);
    System.out.println(s2);
&#125;
</code></pre>
<p>我们只需要在单例类中重写readResolve方法并在该方法中返回单例对象即可，如下:</p>
<pre><code class="java">package com.dpb.single;

import java.io.ObjectStreamException;
import java.io.Serializable;

/**
 * 单例模式：懒汉式
 *
 */
public class SingletonInstance2 implements Serializable&#123;

    // 声明此类型的变量,但没有实例化
    private static SingletonInstance2 instance = null;

    // 私有化所有的构造方法,防止直接通过new关键字实例化
    private SingletonInstance2()&#123;
        if(instance != null)&#123;
            // 只能有一个实例存在，如果再次调用该构造方法就抛出异常，防止反射方式实例化
            throw new RuntimeException(&quot;单例模式只能创建一个对象&quot;);
        &#125;
    &#125;
    // 对外提供一个获取实例的静态方法，为了数据安全添加synchronized关键字
    public static synchronized SingletonInstance2 getInstance()&#123;
        if(instance == null)&#123;
            // 当instance不为空的时候才实例化
            instance = new SingletonInstance2();
        &#125;
        return instance;
    &#125;
    // 重写该方法，防止序列化和反序列化获取实例
    private Object readResolve() throws ObjectStreamException&#123;
        return instance;
    &#125;
&#125;
</code></pre>
<p>说明:readResolve方法是基于回调的，反序列化时，如果定义了readResolve()则直接返回此方法指定的对象，而不需要在创建新的对象！</p>
<h2 id="3-说说你在哪些框架中看到了单例的设计"><a href="#3-说说你在哪些框架中看到了单例的设计" class="headerlink" title="3.说说你在哪些框架中看到了单例的设计"></a>3.说说你在哪些框架中看到了单例的设计</h2><p>1.Spring中的Bean对象，默认是单例模式</p>
<p>2.相关的工厂对象都是单例，比如：MyBatis中的SqlSessionFactory，Spring中的BeanFactory</p>
<p>3.保存相关配置信息的都是单例，比如：MyBatis中的Configuration对象，SpringBoot中的各个XXXAutoConfiguration对象等</p>
<p>4.应用程序的日志应用，一般都会通过单例来实现</p>
<p>5.数据库连接池的设计也是单例模式</p>
<h2 id="4-工厂模式"><a href="#4-工厂模式" class="headerlink" title="4.工厂模式"></a>4.工厂模式</h2><p>&amp;emsp;&amp;emsp;工厂模式的作用是帮助我们创建对象，我们不用自己来创建，根据需要创建的对象的复杂度我们可以把工厂模式分为简单工厂，工厂方法和抽象工厂。</p>
<p><img data-src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/1462/1648123011000/95f501de57d3451faf9228414dc6f75f.png" alt="image.png"></p>
<h3 id="4-1-简单工厂"><a href="#4-1-简单工厂" class="headerlink" title="4.1 简单工厂"></a>4.1 简单工厂</h3><p>&amp;emsp;&amp;emsp;简单工厂模式又称为静态工厂方法，他可以根据不同的参数而返回不同的实例，简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。</p>
<p>JDK中的简单工厂应用：DataFormat</p>
<p><img data-src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/1462/1648123011000/4fdddcfbf8784080a3706158f6945e9a.png" alt="image.png"></p>
<p>自己写一个简单工厂的案例</p>
<p><img data-src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/1462/1648123011000/de2237eb14fe491fbd38c5a815fa7c27.png" alt="image.png"></p>
<pre><code class="java">/**
 * 简单工厂
 */
public class SimpleFactory &#123;

    public static void main(String[] args) &#123;
        // 根据对应的类型返回相关产品
        CarFactory.createCar(&quot;奥迪&quot;).run();
        CarFactory.createCar(&quot;Byd&quot;).run();
    &#125;
&#125;

// 定义公共的接口
interface Car&#123;
    void run();
&#125;

class Audi implements Car&#123;
    @Override
    public void run() &#123;
        System.out.println(&quot;奥迪在跑...&quot;);
    &#125;
&#125;

class Byd implements Car&#123;
    @Override
    public void run() &#123;
        System.out.println(&quot;Byd在跑...&quot;);
    &#125;
&#125;

// 创建对应的简单工厂类
class CarFactory&#123;
    public static Car createCar(String type)&#123;
        if(&quot;奥迪&quot;.equals(type))&#123;
            return new Audi();
        &#125;else if(&quot;Byd&quot;.equals(type))&#123;
            return new Byd();
        &#125;else&#123;
            throw new RuntimeException(&quot;该产品不能生产&quot;);
        &#125;
    &#125;
&#125;
</code></pre>
<p>我们可以发现简单工厂对于新增产品是无能为力的！不修改原有代码根本就没办法扩展!!!</p>
<h3 id="4-2-工厂方法"><a href="#4-2-工厂方法" class="headerlink" title="4.2 工厂方法"></a>4.2 工厂方法</h3><p>&amp;emsp;&amp;emsp;针对于简单工厂的短板，引出了工厂方法模式，定义一个用户创建对象的接口，让子类决定实例化哪个类，工厂方法使一个类的实例化延迟到了其子类中。</p>
<p><img data-src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/1462/1648123011000/cedbded5fc4543eb80dd3663bbe814c7.png" alt="image.png"></p>
<p>代码实现：</p>
<pre><code class="java">/**
 * 工厂方法模式
 */
public class FactoryMethod &#123;

    public static void main(String[] args) &#123;
        new AudiCarFactory().createCar().run();
        new BydCarFactory().createCar().run();
    &#125;


    public static interface  Car&#123;
        public void run();
    &#125;

    public static class Byd implements Car&#123;
        @Override
        public void run() &#123;
            System.out.println(&quot;比亚迪...&quot;);
        &#125;
    &#125;

    public static class Audi implements Car&#123;
        @Override
        public void run() &#123;
            System.out.println(&quot;奥迪...&quot;);
        &#125;
    &#125;

    public static interface CarFactory&#123;
        public Car createCar();
    &#125;

    // 扩展的工厂
    public static class AudiCarFactory implements CarFactory&#123;
        @Override
        public Car createCar() &#123;
            return new Audi();
        &#125;
    &#125;

    public static class BydCarFactory implements CarFactory&#123;
        @Override
        public Car createCar() &#123;
            return new Byd();
        &#125;
    &#125;
&#125;
</code></pre>
<p>简单工厂和工厂方法模式的对比</p>
<ol>
<li>简单工厂只有一个工厂，而工厂方法有多个工厂</li>
<li>简单工厂不支持扩展，而工厂方法支持扩展，扩展的方式就是添加对应的工厂类即可</li>
<li>简单工厂代码复杂度低，工厂方法代码复杂度高</li>
<li>…</li>
</ol>
<h3 id="4-3-抽象工厂"><a href="#4-3-抽象工厂" class="headerlink" title="4.3 抽象工厂"></a>4.3 抽象工厂</h3><p>&amp;emsp;&amp;emsp;上面的两种方式实现的工厂都是生产同一大类的产品，如果要实现生产不同类型的产品这时我们就可以用抽象工厂模式来实现。</p>
<p><img data-src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/1462/1648123011000/185ba2bc37394c47ae8f62390d019829.png" alt="image.png"></p>
<p>代码实现：</p>
<pre><code class="java">/**
 * 抽象工厂：多个产品族
 */
public class AbstractFactory &#123;

    public static void main(String[] args) &#123;
        Car car = new LuxuryEngineCarFacory().createCar();
        Engine engine = new LuxuryEngineCarFacory().createEngine();
        car.run();
        engine.run();
    &#125;

    // 抽象工厂
    public static interface AbstarctComponentFactory&#123;
        Car createCar();
        Engine createEngine();
    &#125;

    public static class LuxuryEngineCarFacory implements AbstarctComponentFactory&#123;
        @Override
        public Engine createEngine() &#123;
            return new LuxuryEngineFactory().createEngine();
        &#125;

        @Override
        public Car createCar() &#123;
            return new BydCarFactory().createCar();
        &#125;
    &#125;

    public static class LowEngineCarFacory implements AbstarctComponentFactory&#123;
        @Override
        public Car createCar() &#123;
            return new AudiCarFactory().createCar();
        &#125;

        @Override
        public Engine createEngine() &#123;
            return new LowEngineFactory().createEngine();
        &#125;
    &#125;

    // 汽车产品族
    public static interface  Car&#123;
        public void run();
    &#125;

    public static class Byd implements Car &#123;
        @Override
        public void run() &#123;
            System.out.println(&quot;比亚迪...&quot;);
        &#125;
    &#125;

    public static class Audi implements Car &#123;
        @Override
        public void run() &#123;
            System.out.println(&quot;奥迪...&quot;);
        &#125;
    &#125;

    public static interface CarFactory&#123;
        public Car createCar();
    &#125;

    // 扩展的工厂
    public static class AudiCarFactory implements CarFactory &#123;
        @Override
        public Car createCar() &#123;
            return new Audi();
        &#125;
    &#125;

    public static class BydCarFactory implements  CarFactory&#123;
        @Override
        public Car createCar() &#123;
            return new Byd();
        &#125;
    &#125;

    // 发动机产品族
    public static interface Engine&#123;
        public void run();
    &#125;

    public static class LuxuryEngine implements Engine&#123;
        @Override
        public void run() &#123;
            System.out.println(&quot;豪华版发动机...&quot;);
        &#125;
    &#125;

    public static class LowEngine implements Engine&#123;
        @Override
        public void run() &#123;
            System.out.println(&quot;低配版发动机...&quot;);
        &#125;
    &#125;

    public static interface EngineFactory&#123;
        public Engine createEngine();
    &#125;

    public static class LuxuryEngineFactory implements EngineFactory&#123;
        @Override
        public Engine createEngine() &#123;
            return new LuxuryEngine();
        &#125;
    &#125;

    public static class LowEngineFactory implements EngineFactory&#123;
        @Override
        public Engine createEngine() &#123;
            return new LowEngine();
        &#125;
    &#125;
&#125;
</code></pre>
<p>三者的对比：</p>
<ol>
<li>简单工厂模式(静态工厂模式) ：虽然某种程度不符合设计原则，但实际使用最多。</li>
<li>工厂方法模式：不修改已有类的前提下，通过增加新的工厂类实现扩展。</li>
<li>抽象工厂模式：不可以增加产品，可以增加产品族！</li>
</ol>
<h2 id="5-建造者模式"><a href="#5-建造者模式" class="headerlink" title="5.建造者模式"></a>5.建造者模式</h2><p>&amp;emsp;&amp;emsp;实际开发中，我们所需要的对象构建时非常复杂，且有很多步骤需要处理时，这时建造者模式就很适合。比如MyBatis中的SqlSessionFactory对象的创建，我们不光要创建SqlSessionFactory本身的对象，还有完成MyBatis的全局配置文件和映射文件的加载解析操作，之后把解析出来的信息绑定在SqlSessionFactory对象中，</p>
<p><img data-src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/1462/1648123011000/21221aa599f9428083bc92d81ac151d2.png" alt="image.png"></p>
<p>直接参考MyBatis的代码即可</p>
<p><img data-src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/1462/1648123011000/6d7aec1477204d9397cf5b59a1f2ad65.png" alt="image.png"></p>
<p>所以建造者模式的作用就是帮助我们解决了复杂对象的创建</p>
<p>建造者模式和工厂模式的区别：</p>
<ul>
<li>关注的维度是不一样的</li>
<li>工厂模式创建对象 new 出来</li>
<li>建造者模式关注的是对象创建的本身</li>
</ul>
<h2 id="6-原型模式"><a href="#6-原型模式" class="headerlink" title="6.原型模式"></a>6.原型模式</h2><p>&amp;emsp;&amp;emsp;在java中我们知道通过new关键字创建的对象是非常繁琐的(类加载判断，内存分配，初始化等)，在我们需要大量对象的情况下，原型模式就是我们可以考虑实现的方式。<br>&amp;emsp;&amp;emsp;原型模式我们也称为克隆模式，即一个某个对象为原型克隆出来一个一模一样的对象，该对象的属性和原型对象一模一样。而且对于原型对象没有任何影响。原型模式的克隆方式有两种：浅克隆和深度克隆.</p>
<table>
<thead>
<tr>
<th>原型模式</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td>浅克隆</td>
<td align="left">只是拷贝本对象,其对象内部的数组、引用对象等都不拷贝，&#96;&#96;还是指向原生对象的内部元素地址</td>
</tr>
<tr>
<td>深度克隆</td>
<td align="left">深复制把要复制的对象所引用的对象都复制了一遍</td>
</tr>
</tbody></table>
<h3 id="6-1-浅克隆"><a href="#6-1-浅克隆" class="headerlink" title="6.1 浅克隆"></a>6.1 浅克隆</h3><p>&amp;emsp;&amp;emsp;被复制对象的所有变量都含有与原来的对象相同的值，而所有的对其他对象的引用仍然指向原来的对象。换言之，浅复制仅仅复制所考虑的对象，而不复制它所引用的对象。 Object类提供的方法clone&#x3D;只是拷贝本对象&#x3D; ， &#x3D;其对象内部的数组、引用对象等都不拷贝&#x3D; ，还是指向原生对象的内部元素地址.</p>
<p>&amp;emsp;&amp;emsp;被克隆的对象必须Cloneable,Serializable这两个接口;</p>
<pre><code class="java">package com.bobo.prototype;

import java.io.Serializable;
import java.util.Date;

public class User implements Cloneable, Serializable &#123;

    private String name;

    private Date birth;

    private int age;

    /**
     * 实现克隆的方法
     * @return
     * @throws CloneNotSupportedException
     */
    @Override
    protected Object clone() throws CloneNotSupportedException &#123;
        return super.clone();
    &#125;

    public String getName() &#123;
        return name;
    &#125;

    public void setName(String name) &#123;
        this.name = name;
    &#125;

    public Date getBirth() &#123;
        return birth;
    &#125;

    public void setBirth(Date birth) &#123;
        this.birth = birth;
    &#125;

    public int getAge() &#123;
        return age;
    &#125;

    public void setAge(int age) &#123;
        this.age = age;
    &#125;

    public static void main(String[] args) throws Exception &#123;
        // 创建一个普通对象
        Date date =  new Date(666666);
        User user = new User();
        user.setName(&quot;波波烤鸭&quot;);
        user.setAge(18);
        user.setBirth(date);
        System.out.println(&quot;原型对象的属性：&quot; + user);
        // 克隆对象
        User cloneUser = (User) user.clone();
        System.out.println(&quot;克隆的对象的属性：&quot; + cloneUser);
        // 修改原型对象的属性
        date.setTime(12345677);
        // 修改克隆对象的属性
        cloneUser.setName(&quot;波哥&quot;);
        System.out.println(&quot;原型对象的属性：&quot; + user);
        System.out.println(&quot;克隆的对象的属性：&quot; + cloneUser);
    &#125;

    @Override
    public String toString() &#123;
        return &quot;User&#123;&quot; +
                &quot;name=&#39;&quot; + name + &#39;\&#39;&#39; +
                &quot;, birth=&quot; + birth +
                &quot;, age=&quot; + age +
                &#39;&#125;&#39;;
    &#125;
&#125;
</code></pre>
<p>输出结果</p>
<p><img data-src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/1462/1648123011000/6443e2d851514225a9253ca8d26de73f.png" alt="image.png"></p>
<p>浅克隆的问题:虽然产生了两个完全不同的对象，但是被复制的对象的所有变量都含有与原来的对象相同的值，而所有的对其他对象的引用都仍然指向原来的对象。<img data-src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/1462/1648123011000/05ad80babac04b43956010b8244cd85b.png" alt="image.png"></p>
<h3 id="6-2-深度克隆"><a href="#6-2-深度克隆" class="headerlink" title="6.2 深度克隆"></a>6.2 深度克隆</h3><p>&amp;emsp;&amp;emsp;被复制对象的所有变量都含有与原来的对象相同的值，除去那些引用其他对象的变量。那些引用其他对象的变量将指向被复制过的新对象，而不再是原有的那些被引用的对象。换言之，深复制把要复制的对象所引用的对象都复制了一遍。<br>实现的效果是:</p>
<p><img data-src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/1462/1648123011000/6fdf967a6fc74e8690b75e3bb3640b7c.png" alt="image.png"></p>
<p>深度克隆(deep clone)有两种实现方式，第一种是在浅克隆的基础上实现，第二种是通过序列化和反序列化实现，我们分别来介绍</p>
<p>方式一：在浅克隆的基础上实现</p>
<pre><code class="java">    /**
     * 实现克隆的方法
     * @return
     * @throws CloneNotSupportedException
     */
    @Override
    protected Object clone() throws CloneNotSupportedException &#123;
        User user = (User) super.clone();
        // 实现深度克隆
        user.birth = (Date) this.birth.clone();
        return user;
    &#125;
</code></pre>
<p><img data-src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/1462/1648123011000/1ba148deb0244a4dbfef33a8f1b3bcbd.png" alt="image.png"></p>
<p>方式二：序列化和反序列化</p>
<table>
<thead>
<tr>
<th>名称</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td>序列化</td>
<td align="left">把对象转换为字节序列的过程。</td>
</tr>
<tr>
<td>反序列化</td>
<td align="left">把字节序列恢复为对象的过程。</td>
</tr>
</tbody></table>
<pre><code class="java">public static void main(String[] args) throws CloneNotSupportedException, Exception &#123;
    Date date =  new Date(1231231231231l);
    User user = new User();
    user.setName(&quot;波波烤鸭&quot;);
    user.setAge(18);
    user.setBirth(date);
    System.out.println(&quot;-----原型对象的属性------&quot;);
    System.out.println(user);

    //使用序列化和反序列化实现深复制
    ByteArrayOutputStream bos = new ByteArrayOutputStream();
    ObjectOutputStream    oos = new ObjectOutputStream(bos);
    oos.writeObject(user);
    byte[] bytes = bos.toByteArray();

    ByteArrayInputStream  bis = new ByteArrayInputStream(bytes);
    ObjectInputStream	  ois = new ObjectInputStream(bis);

    //克隆好的对象！
    User user1 = (User) ois.readObject();   

    // 修改原型对象的值
    date.setTime(221321321321321l);
    System.out.println(user.getBirth());

    System.out.println(&quot;------克隆对象的属性-------&quot;);
    System.out.println(user1);
&#125;
</code></pre>
<h2 id="7-谈谈你对创建型模式的理解"><a href="#7-谈谈你对创建型模式的理解" class="headerlink" title="7.谈谈你对创建型模式的理解"></a>7.谈谈你对创建型模式的理解</h2><p>&amp;emsp;&amp;emsp;Java的23种设计模式分为3类，分别是</p>
<p><img data-src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1651200196055/e7bfebaff043483eae41837038342d60.png" alt="image.png"></p>
<p>而创建型模式中有包含的如下的相关模式：</p>
<p><img data-src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1651200196055/370c67f33136431c8c3b4ab9f9e46445.png" alt="image.png"></p>
<p>而每个设计模式的作用如下：</p>
<p><img data-src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1651200196055/19e2c33ad56e4b2cb22b3447fcf0e6a5.png" alt="image.png"></p>
<h1 id="二、结构性模式"><a href="#二、结构性模式" class="headerlink" title="二、结构性模式"></a>二、结构性模式</h1><h2 id="1-代理模式"><a href="#1-代理模式" class="headerlink" title="1.代理模式"></a>1.代理模式</h2><h3 id="1-1-代理模式的作用"><a href="#1-1-代理模式的作用" class="headerlink" title="1.1 代理模式的作用"></a>1.1 代理模式的作用</h3><p>&amp;emsp;&amp;emsp;代理模式的作用是通过代理对象来增强目标对象的功能。利用的是AOP横切的思想。</p>
<h3 id="1-2-代理模式的实现方式"><a href="#1-2-代理模式的实现方式" class="headerlink" title="1.2 代理模式的实现方式"></a>1.2 代理模式的实现方式</h3><p>&amp;emsp;&amp;emsp;代理模式的实现方式有三种：静态代理，动态代理(JDK动态代理和CGLIB动态代理)</p>
<p><img data-src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1651200196055/ff3031b921b948338282ee57ee510c84.png" alt="image.png"></p>
<h4 id="1-2-1-静态代理"><a href="#1-2-1-静态代理" class="headerlink" title="1.2.1 静态代理"></a>1.2.1 静态代理</h4><p>我们先声明接口和目标实现类</p>
<pre><code class="java">/**
 * 定义公共接口
 */
public interface SomeService &#123;
    String doSome();
&#125;
</code></pre>
<p>目标类</p>
<pre><code class="java">/**
 * 目标对象 target
 */
public class SomeServiceImpl implements SomeService &#123;
    @Override
    public String doSome() &#123;
        System.out.println(&quot;目标对象：doSome()&quot; );
        return &quot;hello ...&quot;;
    &#125;
&#125;
</code></pre>
<p>然后创建对应的代理类</p>
<pre><code class="java">/**
 * 代理类
 *     增强实现类
 *     和实现类实现同一个接口
 */
public class SomeProxy implements SomeService&#123;

    private SomeService target;

    public SomeProxy(SomeService target)&#123;
        this.target = target;
    &#125;

    /**
     * 增强的方法
     * @return
     */
    @Override
    public String doSome() &#123;
        System.out.println(&quot;目标方法执行之前...&quot;);
        String s = target.doSome();
        System.out.println(&quot;目标方法执行之后...&quot;);
        return s.toUpperCase();
    &#125;
&#125;
</code></pre>
<p>然后测试实现</p>
<pre><code class="java">public class MainTest &#123;
    public static void main(String[] args) &#123;
        SomeService some = new SomeServiceImpl();
        SomeProxy proxy = new SomeProxy(some);
        System.out.println(proxy.doSome());
    &#125;
&#125;
</code></pre>
<p>对应的输出结果</p>
<pre><code class="java">目标方法执行之前...
目标对象：doSome()
目标方法执行之后...
HELLO ...
</code></pre>
<p>可以看到代理对象实现了目标对象的调用，同时增强了目标对象的功能。</p>
<h4 id="1-2-2-JDK动态代理"><a href="#1-2-2-JDK动态代理" class="headerlink" title="1.2.2 JDK动态代理"></a>1.2.2 JDK动态代理</h4><p>&amp;emsp;&amp;emsp;上面的静态代理我们需要手动的创建一个对应的代理来实现，不是太灵活，针对目标对象有实现相关接口的情况，我们可以使用JDK动态代理。</p>
<pre><code class="java">public class JdkDynamicProxy &#123;

    /**
     * JDK动态代理：目标对象必须实现相关的接口
     * @param args
     */
    public static void main(String[] args) &#123;
        SomeService target = new SomeServiceImpl();
        SomeService proxy = (SomeService) Proxy.newProxyInstance(JdkDynamicProxy.class.getClassLoader(), // 类加载器
                target.getClass().getInterfaces() // 目标对象实现的相关接口
                , new InvocationHandler() &#123; // 代理对象的回调方法
                    @Override
                    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;
                        System.out.println(&quot;before...&quot;);
                        Object invoke = method.invoke(target, args);
                        System.out.println(&quot;end...&quot;);
                        if (invoke != null) &#123;
                            return invoke.toString().toUpperCase();
                        &#125;
                        return null;
                    &#125;
                &#125;);
        // 通过代理对象来执行
        System.out.println(&quot;proxy.doSome() = &quot; + proxy.doSome());

    &#125;
&#125;
</code></pre>
<p>输出结构</p>
<pre><code>before...
目标对象：doSome()
end...
proxy.doSome() = HELLO ...
</code></pre>
<h4 id="1-2-3-CGLIB动态代理"><a href="#1-2-3-CGLIB动态代理" class="headerlink" title="1.2.3 CGLIB动态代理"></a>1.2.3 CGLIB动态代理</h4><p>&amp;emsp;&amp;emsp;如果目标对象实现了对应的接口我们可以通过JDK动态代理的方式来实现，但如果目标对象没有实现任何的接口，这时我们只能通过CGLIB动态代理来实现了，这时我们需要单独引入cglib的依赖</p>
<pre><code class="java">public class CGLIBDynamicProxy &#123;

    /**
     * CGLIB动态代理
     * @param args
     */
    public static void main(String[] args) &#123;
        SomeService target = new SomeServiceImpl();
        SomeServiceImpl proxy = new MethodInterceptor() &#123;

            /**
             * 创建 CGLIB 代理对象的方法
             * @return
             */
            public SomeServiceImpl createProxy() &#123;
                // 创建增强器
                Enhancer e = new Enhancer();
                // 指定父类
                e.setSuperclass(target.getClass());
                // 指定回调接口对象
                e.setCallback(this);
                // 创建CGLIB代理对象
                return (SomeServiceImpl) e.create();
            &#125;

            /**
             * 拦截回调的方法
             */
            @Override
            public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable &#123;
                System.out.println(&quot;cglib -- befor&quot; );
                Object res = method.invoke(target, args);
                System.out.println(&quot;cglib -- end&quot;);
                return res.toString().toUpperCase();
            &#125;
        &#125;.createProxy();
        System.out.println(&quot;proxy.doSome() = &quot; + proxy.doSome());
    &#125;
&#125;
</code></pre>
<p>输出的结果</p>
<pre><code>cglib -- befor
目标对象：doSome()
cglib -- end
proxy.doSome() = HELLO ...
</code></pre>
<h2 id="2-适配器模式"><a href="#2-适配器模式" class="headerlink" title="2.适配器模式"></a>2.适配器模式</h2><h3 id="2-1-适配器的作用"><a href="#2-1-适配器的作用" class="headerlink" title="2.1 适配器的作用"></a>2.1 适配器的作用</h3><p>&amp;emsp;&amp;emsp;适配器模式的作用是把两个不兼容的对象通过适配器能够连接起来工作。</p>
<p><img data-src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1651200196055/4f1b8160dfaf4de6816c2d7bc7c79ed3.png" alt="image.png"></p>
<h3 id="2-2-具体案例分析"><a href="#2-2-具体案例分析" class="headerlink" title="2.2 具体案例分析"></a>2.2 具体案例分析</h3><p>&amp;emsp;&amp;emsp;以MyBatis中的日志模块为例来介绍。常见的日志框架有log4j,log4j2,slf4j,logbak等，但是每种日志框架中的日志级别都有差异。</p>
<p>log4j2的接口：</p>
<p><img data-src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1651200196055/97882ce34e7c45b38a242335fee35136.png" alt="image.png"></p>
<p>slf4j的接口</p>
<p><img data-src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1651200196055/2e0b96e4f72b4d4cb1da9ef190e06f7e.png" alt="image.png"></p>
<p>也就是可以看到不同的日志框架里面所定义的日志级别和对应的方法都有区别，那么我们的框架怎么来统一使用这些日志框架呢？在MyBatis中通过定义了一个日志接口，定义了日志具有的级别和方法。</p>
<p><img data-src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1651200196055/13b885d6a2e742c8902a41cca65a77f3.png" alt="image.png"></p>
<p>那这时候我们就发现具体的日志框架和这个接口其实是没有办法直接来使用的。</p>
<p><img data-src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1651200196055/5394d7aab0b9407bb44e7a43b5a46c35.png" alt="image.png"></p>
<p>这时我们就需要通过对应的适配器来处理这种情况，以Slf4J为例。</p>
<p><img data-src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1651200196055/cc1a1999be144995bbdfd0d52af15aa1.png" alt="image.png"></p>
<h2 id="3-装饰者模式"><a href="#3-装饰者模式" class="headerlink" title="3.装饰者模式"></a>3.装饰者模式</h2><h3 id="3-1-装饰者模式的作用"><a href="#3-1-装饰者模式的作用" class="headerlink" title="3.1 装饰者模式的作用"></a>3.1 装饰者模式的作用</h3><p>&amp;emsp;&amp;emsp;装饰者模式又称为包装模式(<span class="exturl" data-url="aHR0cHM6Ly9zby5jc2RuLm5ldC9zby9zZWFyY2g/cT1XcmFwcGVyJnNwbT0xMDAxLjIxMDEuMzAwMS43MDIw">Wrapper</span>),作用是用来动态的为一个对象增加新的功能。装饰模式是一种用于代替继承的技术， 无须通过继承增加子类就能扩展对象的新功能 。使用对象的关联关系代替继承关系，更加灵活，同时避免类型体系的快速膨胀。</p>
<p><img data-src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1651200196055/3d6542b45adc4fc1954b5a32e0cefe0b.png" alt="image.png"></p>
<h3 id="3-2-装饰者模式的应用"><a href="#3-2-装饰者模式的应用" class="headerlink" title="3.2 装饰者模式的应用"></a>3.2 装饰者模式的应用</h3><p>&amp;emsp;&amp;emsp;装饰者模式的应用场景还是非常多的，比如</p>
<ul>
<li>IO流中的FileInputStream，FileOutputStream等</li>
<li>Spring中的各种Wrapper</li>
<li>MyBatis中的缓存设计</li>
</ul>
<p>我们以MyBatis中的缓存实例为例来看看其具体的实现。</p>
<p>首先是Cache接口</p>
<p><img data-src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1651200196055/4fd123c411d44b9b9be4b6fc042cd1a0.png" alt="image.png"></p>
<p>然后是PerpetualCache实现：仅仅实现了数据基于内存的读写操作。功能单一。</p>
<p><img data-src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1651200196055/64a1d022065f46d5ad8f05fa0a884130.png" alt="image.png"></p>
<p>装饰类：然后在MyBatis中给我们提供了很多的装饰类。</p>
<p><img data-src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1651200196055/b6a6d87b24bb40d08c86267957622a18.png" alt="image.png"></p>
<p>每个装饰类都有自己的作用</p>
<ul>
<li>BlockingCache：阻塞的</li>
<li>LruCache:根据Lru规则来淘汰缓存数据</li>
<li>FifoCache：根据FIFO规则来淘汰缓存数据</li>
<li>….</li>
</ul>
<p>源码中的装饰：</p>
<p><img data-src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1651200196055/15cfb22ba61c4fc9a3c0ee7db595d8b7.png" alt="image.png"></p>
<p><img data-src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1651200196055/7379277ae49d422cbfe571f0852af446.png" alt="image.png"></p>
<table>
<thead>
<tr>
<th>比较</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td>优点</td>
<td align="left">1. 扩展对象功能，比继承灵活，不会导致类个数急剧增加&amp;#x3c;br &#x2F;&gt;2. 可以对一个对象进行多次装饰,创造出不同行为的组合,得到功能更加强大的对象&amp;#x3c;br &#x2F;&gt;3. 具体构建类和具体装饰类可以独立变化,&amp;#x3c;br &#x2F;&gt;用户可以根据需要自己增加新的具体构件子类和具体装饰子类。</td>
</tr>
<tr>
<td>缺点</td>
<td align="left">1.  产生很多小对象。大量小对象占据内存，一定程度上影响性能。&amp;#x3c;br &#x2F;&gt;2. 装饰模式易于出错，调试排查比较麻烦。</td>
</tr>
</tbody></table>
<h2 id="4-组合模式"><a href="#4-组合模式" class="headerlink" title="4.组合模式"></a>4.组合模式</h2><h3 id="4-1-组合模式的作用"><a href="#4-1-组合模式的作用" class="headerlink" title="4.1 组合模式的作用"></a>4.1 组合模式的作用</h3><p>&amp;emsp;&amp;emsp;其实解决的是对象与对象之间的包含关系。也就是 部分-整体 的层次结构。</p>
<h3 id="4-2-组合模式的应用"><a href="#4-2-组合模式的应用" class="headerlink" title="4.2 组合模式的应用"></a>4.2 组合模式的应用</h3><p>&amp;emsp;&amp;emsp;组合模式在配置文件的加载解析中其实会用的相对比较多。以SpringSecurity的配置文件为例</p>
<p><img data-src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1651200196055/451caf5510724dbdb8781edc504a3108.png" alt="image.png"></p>
<p>上面是具体的定义</p>
<p><img data-src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1651200196055/225305de9e79499b9858fdf0954bee43.png" alt="image.png"></p>
<p>应用</p>
<p><img data-src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1651200196055/f27879a6ed534ecda344e3c8033e8b66.png" alt="image.png"></p>
<h2 id="5-门面模式"><a href="#5-门面模式" class="headerlink" title="5.门面模式"></a>5.门面模式</h2><p>&amp;emsp;&amp;emsp;门面模式也称为外观模式，他隐藏了系统的复杂性，并向客户端提供了一个可以访问系统的接口。这种类型的设计模式属于结构性模式。为子系统中的一组接口提供了一个统一的访问接口，这个接口使得子系统更容易被访问或者使用。</p>
<p><img data-src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1651200196055/d7cbb356c586445cbae588a9c6944c48.png" alt="image.png"></p>
<p>&amp;emsp;&amp;emsp;具体的例子比如：MyBatis中的SqlSession接口，对外提供了数据库操作的相关功能，具体的实现细节对调用者是隐藏的，这种模式在实际项目和框架中很频繁</p>
<h2 id="6-桥接模式"><a href="#6-桥接模式" class="headerlink" title="6.桥接模式"></a>6.桥接模式</h2><p>&amp;emsp;&amp;emsp;桥接模式的出现是替代掉多层继承的问题。提高了系统的扩展性。</p>
<p><img data-src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1651200196055/689902586ed3400e808b3cdaf88a93de.png" alt="image.png"></p>
<p>具体的应用比如JDBC中的DriverManager其实有用到桥接模式，不同的数据库厂商对应不同的驱动和连接</p>
<h2 id="7-享元模式"><a href="#7-享元模式" class="headerlink" title="7.享元模式"></a>7.享元模式</h2><p>&amp;emsp;&amp;emsp;这个问题相对来说比较冷门，用到的也比较少，主要是针对内存这块的节省处理，如果有很多个完全相同或相似的对象，我们可以通过享元模式，节省内存.</p>
<p>享元模式以共享的方式高效地支持大量细粒度对象的重用。</p>
<p>享元对象能做到共享的关键是区分了内部状态和外部状态。<br>•  <strong>内部状态</strong> ：可以共享，不会随环境变化而改变<br>•  <strong>外部状态</strong> ：不可以共享，会随环境变化而改变</p>
<p>比如以围棋为例:</p>
<p><img data-src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1651200196055/ed27059ad63b4d408568033cd3d18998.png" alt="image.png"></p>
<p><img data-src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1651200196055/d2cd6a9f545e4f09af78a4e4f3c09677.png" alt="image.png"></p>
<h1 id="三、行为型模式"><a href="#三、行为型模式" class="headerlink" title="三、行为型模式"></a>三、行为型模式</h1><p>&amp;emsp;&amp;emsp;行为型模式关注的是对象之间的通信，也就是描述多个类或者对象之间，通过协作共同完成一个任务。主要涉及的是 <strong>对象</strong> 和 <strong>算法</strong>之间职责的分配。</p>
<p>行为型模式分为两类：</p>
<ul>
<li>类行为模式： 通过继承机制来在类间分派行为。 主要是通过多态来分配父类和子类的职责</li>
<li>对象行为模式： 通过组合或聚合，在对象间分派行为。通过对象关联等方式来分配类的职责。</li>
</ul>
<p><img data-src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1651992608037/44e5adf5c4a2487584f3b072b4a19d8a.png" alt="image.png"></p>
<h2 id="1-解释器模式"><a href="#1-解释器模式" class="headerlink" title="1.解释器模式"></a>1.解释器模式</h2><h3 id="1-1-解释器模式的作用"><a href="#1-1-解释器模式的作用" class="headerlink" title="1.1 解释器模式的作用"></a>1.1 解释器模式的作用</h3><p>&amp;emsp;&amp;emsp;解释器模式在业务开发面是很少接触到的。主要的作用是定义的解释器来解析各种表达式，比如SQL语句，SPEL表达式，权限注解中的表达式 hasAnyRole(‘ROLE_ADMIN’)等。</p>
<h3 id="1-2-解释器的应用"><a href="#1-2-解释器的应用" class="headerlink" title="1.2 解释器的应用"></a>1.2 解释器的应用</h3><p>&amp;emsp;&amp;emsp;比较常见的应用比如Spring中的针对SPEL表达式做的解析处理</p>
<pre><code class="java">    public static void main(String[] args) &#123;
        SpelExpressionParser parser = new SpelExpressionParser();
        Expression expression = parser.parseExpression(&quot;500-100*2+60&quot;);
        Object value = expression.getValue();
        System.out.println(&quot;value = &quot; + value);
    &#125;
</code></pre>
<h2 id="2-模板模式"><a href="#2-模板模式" class="headerlink" title="2.模板模式"></a>2.模板模式</h2><h3 id="2-1-模板模式的作用"><a href="#2-1-模板模式的作用" class="headerlink" title="2.1 模板模式的作用"></a>2.1 模板模式的作用</h3><p>&amp;emsp;&amp;emsp;模板模式是一种相对简单的设计模式。作用是在父类中固定程序的执行顺序，具体的实现在子类中实现。比如银行定义每个人去银行开户的流程，</p>
<ol>
<li>取号</li>
<li>填写单子</li>
<li>等待</li>
<li>办理业务</li>
<li>结束</li>
</ol>
<p>然后每个人来开户都会走这个流程，只是每个人的具体操作内容会有区别</p>
<h3 id="2-2-模板模式的应用"><a href="#2-2-模板模式的应用" class="headerlink" title="2.2 模板模式的应用"></a>2.2 模板模式的应用</h3><p>&amp;emsp;&amp;emsp;模板模式的应用就比较多如下：</p>
<ol>
<li>Servlet中的doGet和doPost方法</li>
<li>Spring中的JdbcTemplate</li>
<li>MyBatis中的Executor处理</li>
<li>…..</li>
</ol>
<h2 id="3-责任链模式"><a href="#3-责任链模式" class="headerlink" title="3.责任链模式"></a>3.责任链模式</h2><h3 id="3-1-责任链模式的作用"><a href="#3-1-责任链模式的作用" class="headerlink" title="3.1 责任链模式的作用"></a>3.1 责任链模式的作用</h3><p>&amp;emsp;&amp;emsp;将能够处理同一类请求的对象连成一条链，所提交的请求沿着链传递，链上的对象逐个判断是否有能力处理该请求，如果能则处理，如果不能则传递给链上的下一个对象处理。</p>
<p><img data-src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1651992608037/4c895e3c35f0466b8832bfaf6d4aa9f2.png" alt="image.png"></p>
<h3 id="3-2-责任链模式的应用"><a href="#3-2-责任链模式的应用" class="headerlink" title="3.2 责任链模式的应用"></a>3.2 责任链模式的应用</h3><p>&amp;emsp;&amp;emsp;责任链模式的应用场景比较多，对大家来说印象比较深刻的应该是SpringSecurity中的处理请求的过滤器链了。</p>
<p><img data-src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1651992608037/627ec42ef657483289810bcd60d202d4.png" alt="image.png"></p>
<p>&amp;emsp;&amp;emsp;可以和面试官具体聊下SpringSecurity中的这块设计。当然还有一些其他的也可聊比如：</p>
<ol>
<li>Java中，异常机制就是一种责任链模式。一个try可以对应多个catch，当第一个catch不匹配类型，则自动跳到第二个catch.</li>
<li>Javascript语言中，事件的冒泡和捕获机制。Java语言中，事件的处理采用观察者模式。</li>
<li>SpringMVC中，拦截器的调用也是典型的责任链模式</li>
<li>同样的Servlet中的过滤器链同样是责任链模式的实现。</li>
</ol>
<h2 id="4-观察者模式"><a href="#4-观察者模式" class="headerlink" title="4.观察者模式"></a>4.观察者模式</h2><h3 id="4-1-观察者模式的作用"><a href="#4-1-观察者模式的作用" class="headerlink" title="4.1 观察者模式的作用"></a>4.1 观察者模式的作用</h3><p>&amp;emsp;&amp;emsp;建立对象与对象之间的依赖关系，一个对象发生改变时，会自动通知其他对象。这个场景中，发生改变的对象被称为观察目标，被通知的对象称为观察者。一个观察目标可以有多个观察者，而这些观察者之间可以没有联系，可以根据需要增加或删除观察者。</p>
<p><img data-src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1651992608037/28ad3ed5e28f41a69a490ee02fa0bb25.png" alt="image.png"></p>
<h3 id="4-2-观察者模式的应用"><a href="#4-2-观察者模式的应用" class="headerlink" title="4.2 观察者模式的应用"></a>4.2 观察者模式的应用</h3><p>&amp;emsp;&amp;emsp;观察者模式在Java编程中用到最多的可能就是事件模块的处理，可以和面试官详细的聊下Spring的事件管理机制或者SpringBoot的事件处理机制。我们以SpringBoot的事件机制为例来说明</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NTI2NTczL2FydGljbGUvZGV0YWlscy8xMjIxNDMyNTg=">https://blog.csdn.net/qq_38526573/article/details/122143258</span> 单独通过一篇文章来说明事件的本质。</p>
<h2 id="5-策略模式"><a href="#5-策略模式" class="headerlink" title="5.策略模式"></a>5.策略模式</h2><h3 id="5-1-策略模式的作用"><a href="#5-1-策略模式的作用" class="headerlink" title="5.1 策略模式的作用"></a>5.1 策略模式的作用</h3><p>&amp;emsp;&amp;emsp;策略模式的作用就是我们想要实现某个目的，实现的方式可以有很多种，那么这里的每一种实现方式都可以称为一种策略。比如：</p>
<p><img data-src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1651992608037/22ad4a07e93c4074ac60ae1c7924452a.png" alt="image.png"></p>
<p>&amp;emsp;&amp;emsp;我们可以将每一种交通方式都封装为一个独立的类，这就是一种策略。为了保证策略的一致性，还可以用一个抽象的交通方式类 来 做交通方式的定义。</p>
<h3 id="5-2-策略模式的应用"><a href="#5-2-策略模式的应用" class="headerlink" title="5.2 策略模式的应用"></a>5.2 策略模式的应用</h3><p>&amp;emsp;&amp;emsp;策略模式在实际开发中用到的同样会比较多。</p>
<ol>
<li>AOP 中根据不同的策略可以通过JDK动态代理或者CGLIB代理来创建代理对象</li>
<li>Spring框架中的Resources接口，资源访问的策略</li>
<li>Servlet中的service方法，会根据客户端的不同提交方式来调用对应的doGet或者doPost方法来处理请求</li>
<li>Shiro中的多Realm认证中，根据我们不同的配置可以使用所有Realm认证通过或者其中一个认证通过等</li>
<li>SpringSecurity中的Authentication对象的存储方式</li>
<li>…….</li>
</ol>
<h2 id="6-迭代器模式"><a href="#6-迭代器模式" class="headerlink" title="6.迭代器模式"></a>6.迭代器模式</h2><h3 id="6-1-迭代器模式的作用"><a href="#6-1-迭代器模式的作用" class="headerlink" title="6.1 迭代器模式的作用"></a>6.1 迭代器模式的作用</h3><p>场景：访问聚合对象中的各个元素的时候，比如链表的遍历。我们一般是将遍历的方法也放在链表类中。但是如果需要修改遍历方法，就需要修改链表类的代码，违背了开闭原则。</p>
<p>迭代器模式就是在客户访问和聚合类之间插入一个迭代器，这样就将<strong>聚合对象</strong> 和 <strong>遍历方法</strong>解耦了，并且对外隐藏其实现细节。</p>
<p><img data-src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1651992608037/8a9095d4fbe04245b476ca16250ab2eb.png" alt="image.png"></p>
<h3 id="6-2-迭代器模式的应用"><a href="#6-2-迭代器模式的应用" class="headerlink" title="6.2 迭代器模式的应用"></a>6.2 迭代器模式的应用</h3><ol>
<li>JDK中的List&#x2F;Set集合中的迭代器</li>
<li>……</li>
</ol>
<h2 id="7-中介者模式"><a href="#7-中介者模式" class="headerlink" title="7.中介者模式"></a>7.中介者模式</h2><h3 id="7-1-中介则模式的作用"><a href="#7-1-中介则模式的作用" class="headerlink" title="7.1 中介则模式的作用"></a>7.1 中介则模式的作用</h3><p>&amp;emsp;&amp;emsp;对象之间具有很强的关联性，而且有大量的相互调用，这种情况下，如果一个对象发生了变化，就需要追踪该对象关联的其他对象，并进行相应的处理，这就变得很复杂。而中介者模式，就是用一个中介者对象来封装一系列的对象交互，中介者使各对象不需要显式的相互引用，这就使得系统变得低耦合。比如：</p>
<p><img data-src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1651992608037/bfe0f0f3fbff44e7ad83bc64c9637758.png" alt="image.png"></p>
<p>假如没有总经理。下面三个部门：财务部、市场部、研发部。财务部要发工资，让大家核对公司需要跟市场部和研发部都通气；市场部要接个新项目，需要研发部处理技术、需要财务部出资金。市场部跟各个部门打交道。 虽然只有三个部门，但是关系非常乱。</p>
<p><img data-src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1651992608037/af819fcb665d4aacacc4af386c9b3f8e.png" alt="image.png"></p>
<p>实际上，公司都有总经理。各个部门有什么事情都通报到总经理这里，总经理再通知各个相关部门。</p>
<h3 id="7-2-中介则模式的应用"><a href="#7-2-中介则模式的应用" class="headerlink" title="7.2 中介则模式的应用"></a>7.2 中介则模式的应用</h3><ol>
<li>MVC模式中的C，控制器就是一个中介者对象，M和V都和C打交道</li>
<li>代理对象中的invoke方法，客户端和目标对象都是通过invoke来打交到的。</li>
<li>…..</li>
</ol>
<h2 id="8-状态模式"><a href="#8-状态模式" class="headerlink" title="8.状态模式"></a>8.状态模式</h2><p>场景： 如果一个对象的行为会根据 其某个属性的变化而不同，那这个属性就可以被称为该对象的状态。这样的对象也被称为有状态对象（stateful）。如果这样的对象因为某些事件，其内部状态发生了改变，那么系统的行为也要随之发生变化的话，就可以使用状态模式。</p>
<h2 id="9-命令模式"><a href="#9-命令模式" class="headerlink" title="9.命令模式"></a>9.命令模式</h2><p>场景：请求的发送者和接收者之间解耦，让对象之间的调用关系更加灵活。发送者和接收者之间没有直接的引用关系，发送请求的对象只需要知道如何发送，而不必关心如何完成请求。</p>
<h2 id="10-备忘录模式"><a href="#10-备忘录模式" class="headerlink" title="10.备忘录模式"></a>10.备忘录模式</h2><p>场景：记录一个对象的内部状态，当用户后悔时能撤销当前的操作，是数据恢复到它原来的状态。比如我们编程的时候，ctrl+z 就是撤销当前操作，恢复到修改前的状态。又叫快照模式。</p>
<h2 id="11-访问者模式"><a href="#11-访问者模式" class="headerlink" title="11.访问者模式"></a>11.访问者模式</h2><p>场景：有些集合对象中会有多种不同的元素，每种元素都有不同的访问者 和 处理方式。这种被处理的数据元素相对稳定，但是处理方式比较多样的情况，可以用访问者模式来处理。</p>
<p>访问者模式将数据结构中的各元素的操作分离出来，封装成独立的类，使其在不改变数据结构的前提下，可以添加作用于这些元素的新操作。为数据结构中的每个元素提供多种访问方式。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>MySQL基础</title>
    <url>/2022/10/07/DataBase/MySQL/MySQL_Basic/</url>
    <content><![CDATA[<h1 id="MySQL安装"><a href="#MySQL安装" class="headerlink" title="MySQL安装"></a>MySQL安装</h1><h2 id="1、卸载原来的版本"><a href="#1、卸载原来的版本" class="headerlink" title="1、卸载原来的版本"></a>1、卸载原来的版本</h2><h3 id="1、查看mysql的安装情况"><a href="#1、查看mysql的安装情况" class="headerlink" title="1、查看mysql的安装情况"></a>1、查看mysql的安装情况</h3><pre><code class="sh">rpm -qa | grep -i mysql
</code></pre>
<img data-src="/2022/10/07/DataBase/MySQL/MySQL_Basic/1570605325400.png" class="">



<h3 id="2、删除上图安装的软件"><a href="#2、删除上图安装的软件" class="headerlink" title="2、删除上图安装的软件"></a>2、删除上图安装的软件</h3><pre><code class="sh">rpm -ev --nodeps mysql57-community-release-el5-7.noarch
rpm -ev --nodeps mysql-community-server-5.7.18-1.el5.x86_64
rpm -ev --nodeps mysql-community-client-5.7.18-1.el5.x86_64
rpm -ev --nodeps mysql-community-libs-5.7.18-1.el5.x86_64
rpm -ev --nodeps mysql-community-common-5.7.18-1.el5.x86_64
rpm -ev --nodeps mysql-5.7.18-1.el5.x86_64
rpm -ev --nodeps mysql-community-libs-compat-5.7.18-1.el5.x86_64
</code></pre>
<h3 id="3、都删除成功之后，查找相关的mysql的文件"><a href="#3、都删除成功之后，查找相关的mysql的文件" class="headerlink" title="3、都删除成功之后，查找相关的mysql的文件"></a>3、都删除成功之后，查找相关的mysql的文件</h3><pre><code class="sh">find / -name mysql
</code></pre>
<img data-src="/2022/10/07/DataBase/MySQL/MySQL_Basic/1570605553095.png" class="">



<h3 id="4、删除全部文件"><a href="#4、删除全部文件" class="headerlink" title="4、删除全部文件"></a>4、删除全部文件</h3><pre><code class="sh">rm -rf /etc/selinux/targeted/active/modules/100/mysql
rm -rf /root/mysql
rm -rf /root/mysql/data/mysql
rm -rf /var/lib/mysql
rm -rf /var/lib/mysql/mysql
rm -rf /usr/share/mysql
</code></pre>
<h3 id="5、再次执行命令"><a href="#5、再次执行命令" class="headerlink" title="5、再次执行命令"></a>5、再次执行命令</h3><pre><code class="shell">rpm -qa | grep -i mysql
#如果没有显式则表示卸载完成
</code></pre>
<h2 id="2、删除mariadb-libs-不可省略"><a href="#2、删除mariadb-libs-不可省略" class="headerlink" title="2、删除mariadb-libs(不可省略)"></a>2、删除mariadb-libs(不可省略)</h2><pre><code class="sh"># 检查mariadb-libs
rpm -qa|grep mariadb
# 卸载mariadb-libs
yum remove -y mariadb-libs
</code></pre>
<h2 id="3、安装MySQL"><a href="#3、安装MySQL" class="headerlink" title="3、安装MySQL"></a>3、安装MySQL</h2><h3 id="1，输入："><a href="#1，输入：" class="headerlink" title="1，输入："></a>1，输入：</h3><p>wegt <span class="exturl" data-url="aHR0cHM6Ly9kZXYubXlzcWwuY29tL2dldC9teXNxbCVFNyU4OSU4OCVFNiU5QyVBQyVFNSU4RiVCNy1jb21tdW5pdHktcmVsZWFzZS1lbCVFNSVBNCVBNyVFNyU4OSU4OCVFNiU5QyVBQy0lRTUlQjAlOEYlRTclODklODglRTYlOUMlQUMubm9hcmNoLnJwbQ==">https://dev.mysql.com/get/mysql版本号-community-release-el大版本-小版本.noarch.rpm</span></p>
<pre><code class="sh">wget https://dev.mysql.com/get/mysql57-community-release-el5-7.noarch.rpm
</code></pre>
<h3 id="2、安装数据源"><a href="#2、安装数据源" class="headerlink" title="2、安装数据源"></a>2、安装数据源</h3><pre><code class="sh">yum install -y mysql57-community-release-el5-7.noarch.rpm
</code></pre>
<h3 id="3、查看mysql源是否安装成功"><a href="#3、查看mysql源是否安装成功" class="headerlink" title="3、查看mysql源是否安装成功"></a>3、查看mysql源是否安装成功</h3><pre><code class="sh">yum repolist enabled | grep &quot;mysql.*-community.*&quot;
</code></pre>
<h3 id="4、安装数据库"><a href="#4、安装数据库" class="headerlink" title="4、安装数据库"></a>4、安装数据库</h3><pre><code class="sh">yum install -y  mysql-community-server



# 如果过期可以在运行安装程序之前导入密钥
rpm --import https://repo.mysql.com/RPM-GPG-KEY-mysql-2022
</code></pre>
<h3 id="5、启动mysql"><a href="#5、启动mysql" class="headerlink" title="5、启动mysql"></a>5、启动mysql</h3><pre><code class="sh"># centos7
systemctl restart mysqld
systemctl status mysqld


# centos6
service mysqld start
service mysqld status
</code></pre>
<h3 id="6、显示mysql的随机密码"><a href="#6、显示mysql的随机密码" class="headerlink" title="6、显示mysql的随机密码"></a>6、显示mysql的随机密码</h3><pre><code class="sh">grep &#39;temporary password&#39; /var/log/mysqld.log
</code></pre>
<img data-src="/2022/10/07/DataBase/MySQL/MySQL_Basic/image-20220827193405451.png" class="">



<h3 id="7、登录并修改mysql密码"><a href="#7、登录并修改mysql密码" class="headerlink" title="7、登录并修改mysql密码"></a>7、登录并修改mysql密码</h3><p>登录：mysql -u root -p   		然后输入上面生成的密码</p>
<p><strong><em>修改自定义密码，设置自己想要的密码</em></strong></p>
<pre><code class="sql">-- ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;密码&#39;;

ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;root&#39;;
</code></pre>
<p><strong><em>失败了的话就修改策略，将策略降低一下就可以了</em></strong></p>
<p>查看密码策略：</p>
<pre><code class="sql">SHOW VARIABLES LIKE &#39;%validate_password%&#39;;
</code></pre>
<p>修改密码策略</p>
<pre><code class="sql">-- 修改密码长度：（长度）
set global validate_password.length=1;
set global validate_password_length=1;
-- 修改密码等级：（等级）
set global validate_password.policy=0;
set global validate_password_policy=0;
</code></pre>
<h2 id="4、其他配置"><a href="#4、其他配置" class="headerlink" title="4、其他配置"></a>4、其他配置</h2><h3 id="1-开机自启"><a href="#1-开机自启" class="headerlink" title="1.开机自启"></a>1.开机自启</h3><pre><code class="sh"># 开机启动
systemctl enable mysql
# 关闭自动启动
systemctl disable mysqld
</code></pre>
<h3 id="2-远程连接"><a href="#2-远程连接" class="headerlink" title="2.远程连接"></a>2.远程连接</h3><h4 id="方法一、创建一个用户-支持远程连接"><a href="#方法一、创建一个用户-支持远程连接" class="headerlink" title="方法一、创建一个用户 支持远程连接"></a>方法一、创建一个用户 支持远程连接</h4><p>①登录 ：mysql -u root -p</p>
<p>②创建用户： create user ‘aaa‘@’%’ identified by ‘123456’;</p>
<p>③授权所有权限给user这个新用户 ：grant all on <em>.</em> to ‘aaa‘@’%’;</p>
<p>④退出mysql：quit;</p>
<h4 id="方法二、设置root用户支持远程连接"><a href="#方法二、设置root用户支持远程连接" class="headerlink" title="方法二、设置root用户支持远程连接"></a>方法二、设置root用户支持远程连接</h4><p>①登录：mysql -u root -p （ 注：系统提示输入数据库root用户的密码，输入完成后即进入mysql控制台，这个命令的第一个mysql是执行命令，第二个mysql是系统数据名称，不一样的。）</p>
<p>②设置权限：</p>
<p>赋予权限格式： grant 权限 on 数据库对象 to 用户@IP(或者相应正则)</p>
<pre><code class="sql">-- 新建用户规则或者直接修改root用户的规则 ，2 选一
use mysql;

-- 这里表示赋予该用户所有数据库所有表（*.*表示所有表），%表示所有IP地址。
GRANT ALL PRIVILEGES ON *.* TO &#39;root&#39;@&#39;%&#39; IDENTIFIED BY &#39;123456&#39; WITH GRANT OPTION;
-- 使root能再任何host访问
update user set host = &#39;%&#39; where user = &#39;root&#39;;      

-- 刷新
FLUSH PRIVILEGES;
</code></pre>
<p>③查看：</p>
<pre><code class="sql">use mysql;
SELECT HOST,USER FROM USER;
</code></pre>
<img data-src="/2022/10/07/DataBase/MySQL/MySQL_Basic/920952e9041b4af1a8a49eb64e0f4430.jpeg" class="">



<p> ④退出mysql：quit;</p>
<h2 id="其他安装方式"><a href="#其他安装方式" class="headerlink" title="其他安装方式"></a>其他安装方式</h2><h3 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h3><h4 id="1、查询镜像"><a href="#1、查询镜像" class="headerlink" title="1、查询镜像"></a>1、查询镜像</h4><pre><code class="shell">docker search mysql
</code></pre>
<h4 id="2、拉取镜像"><a href="#2、拉取镜像" class="headerlink" title="2、拉取镜像"></a>2、拉取镜像</h4><pre><code class="shell">docker pull mysql:5.7
</code></pre>
<h4 id="3、构建容器"><a href="#3、构建容器" class="headerlink" title="3、构建容器"></a>3、构建容器</h4><p>先自己创建配置文件基础模板（<strong>要是后期要修改配置文件必须加入 模板中的两个元素，不然容器启动会出错</strong>）</p>
<pre><code class="shell">mkdir -p /root/mysql/conf
vim  /root/mysql/conf/my.cnf
</code></pre>
<p><strong>模板内容：</strong></p>
<pre><code class="shell">!includedir /etc/mysql/conf.d/
!includedir /etc/mysql/mysql.conf.d/

[mysql]
default-character-set=utf8mb4
[mysqld]
character_set_server=utf8mb4
init_connect=&#39;SET NAMES utf8&#39;
lower_case_table_names = 1
</code></pre>
<p><strong>构建容器</strong></p>
<pre><code class="shell">docker run \
-p 3306:3306 \
-v /root/mysql/data:/var/lib/mysql \
-v /root/mysql/logs:/logs \
-v /root/mysql/conf/my.cnf:/etc/mysql/my.cnf \
-e MYSQL_ROOT_PASSWORD=root \
--name mysql \
--hostname node1 \
--restart=always \
-d mysql:5.7
</code></pre>
<p><strong>注</strong>：出错时将本地映射文件检查一下，要是不需要配置，只需映射直接删掉就可，以后再改配置文件</p>
<h4 id="4、进入容器"><a href="#4、进入容器" class="headerlink" title="4、进入容器"></a>4、进入容器</h4><pre><code class="shell">docker exec -it mysql /bin/bash
或者
docker exec -it mysql mysql -uroot -p
</code></pre>
<h3 id="docker-compose"><a href="#docker-compose" class="headerlink" title="docker-compose"></a>docker-compose</h3><blockquote>
<p>前提安装了 docker-compose</p>
</blockquote>
<h4 id="配置-docker-comose-yml-文件"><a href="#配置-docker-comose-yml-文件" class="headerlink" title="配置  docker-comose.yml 文件"></a>配置  docker-comose.yml 文件</h4><p>5.7：</p>
<pre><code class="yml">version: &quot;3.0&quot;
services:
  mysql8:
    image: mysql:5.7.32
    container_name: my_db57
    restart: always
    volumes:
      - ./db:/var/lib/mysql
      - ./conf/my.cnf:/etc/my.cnf
      # 数据库初始化脚本，当Mysql容器首次启动时，会在 /docker-entrypoint-initdb.d目录下扫描 .sh，.sql，.sql.gz类型的文件。如果这些类型的文件存在，将执行它们来初始化一个数据库；
      - ./init/:/docker-entrypoint-initdb.d/
    environment:
      - MYSQL_ROOT_PASSWORD=123456
      # 指定初始化sql文件的数据库，简单来书就是新建一个数据库
      - MYSQL_DATABASE=my_db
      - TZ=Asia/Shanghai
    ports:
      - 3311:3306
</code></pre>
<p>8.0</p>
<pre><code class="yml">version: &quot;3.0&quot;
services:
  mysql8:
    image: mysql:8.0.25
    container_name: my_db8
    restart: always
    volumes:
      - ./db:/var/lib/mysql
      - ./conf/my.cnf:/etc/my.cnf
      # 数据库初始化脚本，当Mysql容器首次启动时，会在 /docker-entrypoint-initdb.d目录下扫描 .sh，.sql，.sql.gz类型的文件。如果这些类型的文件存在，将执行它们来初始化一个数据库；
      - ./init/:/docker-entrypoint-initdb.d/
    environment:
      - MYSQL_ROOT_PASSWORD=123456
      # 指定初始化sql文件的数据库，简单来书就是新建一个数据库
      - MYSQL_DATABASE=my_db
      - TZ=Asia/Shanghai
    ports:
      - 3301:3306
</code></pre>
<h4 id="配置文件-my-cnf"><a href="#配置文件-my-cnf" class="headerlink" title="配置文件 my.cnf"></a>配置文件 my.cnf</h4><p>5.7：</p>
<pre><code class="shell">[mysql]
# 设置mysql客户端默认字符集
default-character-set=utf8mb4

[mysqld]
datadir=/var/lib/mysql
socket=/var/lib/mysql/mysql.sock

symbolic-links=0

log-error=/var/log/mysqld.log
pid-file=/var/run/mysqld/mysqld.pid
# 服务端使用的字符集默认为8比特编码的latin1字符集
character-set-server=utf8mb4

# 创建新表时将使用的默认存储引擎
default-storage-engine=INNODB
</code></pre>
<p>8.0：</p>
<pre><code class="shell">[mysql]
# 设置mysql客户端默认字符集
default-character-set=utf8mb4
[mysqld]
# 允许最大连接数
max_connections=200

# 服务端使用的字符集默认为8比特编码的latin1字符集
character-set-server=utf8mb4

# 创建新表时将使用的默认存储引擎
default-storage-engine=INNODB
</code></pre>
<h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>1、Can’t create&#x2F;write to file ‘&#x2F;var&#x2F;run&#x2F;mysqld&#x2F;mysqld.pid</p>
<p>去配置文件中找到 errorlog的地址，查看错误日志</p>
<img data-src="/2022/10/07/DataBase/MySQL/MySQL_Basic/20190602012200812.png" class="">



<p>错误原因为：&#x2F;var&#x2F;run&#x2F;mysqld&#x2F;目录的拥有者为root，mysql不能在其中创建文件</p>
<p>使用如下命令修改目录使用者</p>
<pre><code class="shell"># 先查看目录是否存在
ls -ld /var/run/mysqld/
# 权限
chown mysql.mysql /var/run/mysqld/
# 修改后重启mysql服务
/etc/init.d/mysqld start
</code></pre>
]]></content>
      <categories>
        <category>MySQL</category>
        <category>MySQL基础</category>
      </categories>
  </entry>
  <entry>
    <title>MySQL调优</title>
    <url>/2022/10/07/DataBase/MySQL/MySQL_Super/</url>
    <content><![CDATA[<h1 id="MySQL性能调优"><a href="#MySQL性能调优" class="headerlink" title="MySQL性能调优"></a>MySQL性能调优</h1><blockquote>
<p>环境：CentOS7.5					 Version：MySQL57.39</p>
</blockquote>
<h1 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h1><p><a href="#MySQL%E7%9A%84%E6%9E%B6%E6%9E%84%E4%BB%8B%E7%BB%8D">1、MySQL的架构介绍</a></p>
<p><a href="#%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%E5%88%86%E6%9E%90">2、索引优化分析</a></p>
<p><a href="#%E6%9F%A5%E8%AF%A2%E6%88%AA%E5%8F%96%E5%88%86%E6%9E%90">3、查询截取分析</a></p>
<p><a href="#MySQL%E7%9A%84%E9%94%81%E6%9C%BA%E5%88%B6">4、MySQL的锁机制</a></p>
<div name=MySQL的架构介绍 >

<h1 id="MySQL文件目录结构"><a href="#MySQL文件目录结构" class="headerlink" title="MySQL文件目录结构"></a>MySQL文件目录结构</h1><table>
<thead>
<tr>
<th align="left">路径</th>
<th align="left">解释</th>
<th align="left">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="left">&#x2F;var&#x2F;lib&#x2F;mysql&#x2F;</td>
<td align="left">mysql数据库文件的存放路径</td>
<td align="left">&#x2F;var&#x2F;lib&#x2F;mysql&#x2F;atguidgu.cloud.pid</td>
</tr>
<tr>
<td align="left">&#x2F;usr&#x2F;share&#x2F;mysql</td>
<td align="left">配置文件目录</td>
<td align="left">mysql.server命令及配置及文件</td>
</tr>
<tr>
<td align="left">&#x2F;usr&#x2F;bin&#x2F;</td>
<td align="left">相关命令目录</td>
<td align="left">mysqladmin 、mysqldump等相关命令</td>
</tr>
<tr>
<td align="left">&#x2F;ect&#x2F;init.d&#x2F;mysql</td>
<td align="left">启停相关脚本</td>
<td align="left"></td>
</tr>
</tbody></table>
<h1 id="主要配置文件"><a href="#主要配置文件" class="headerlink" title="主要配置文件"></a>主要配置文件</h1><p>1、二进制日志 log-bin ：主从复制</p>
<p>2、错误日志 log-error ：默认是关闭的，记录严重的警告和错误信息，每次启动和关闭的详细信息等</p>
<p>3、查询日志 log ：默认关闭，记录查询的SQL语句，如果开启就会降低mysql的整体性能</p>
<p>4、数据文件 : </p>
<ul>
<li><p>系统</p>
<ul>
<li>Windows：本地安装的目录下&#x2F;data  目录下可以挑选很多库</li>
<li>Windows：本地安装的目录下&#x2F;data  目录下可以挑选很多库</li>
</ul>
</li>
<li><p>frm文件： 存放表结构</p>
</li>
<li><p>myd文件：存放表数据</p>
</li>
<li><p>myi文件： 存放表索引</p>
</li>
</ul>
<h1 id="逻辑架构"><a href="#逻辑架构" class="headerlink" title="逻辑架构"></a>逻辑架构</h1><img data-src="/2022/10/07/DataBase/MySQL/MySQL_Super/image-20220816182921842.png" class="">





<h2 id="1-连接层"><a href="#1-连接层" class="headerlink" title="1.连接层"></a>1.连接层</h2><p>​	最上层是一些客户端和连接服务，包含本地sock通信和大多数基于客户端&#x2F;服务端工具实现的类似于tcplip的通信。主要完成一些类似于连接处理、授权认证、及相关的安全方案。在该层上引入了线程池的概念，为通过认证安全接入的客户端提供线程。同样在该层上可以实现基于SSL的安全链接。服务器也会为安全接入的每个客户端验证它所具有的操作权限。</p>
<h2 id="⒉服务层"><a href="#⒉服务层" class="headerlink" title="⒉服务层"></a>⒉服务层</h2><p>​	第二层架构主要完成大多少的核心服务功能，如SQL接口，并完成缓存的查询，SQL的分析和优化及部分内置函数的执行。所有跨存储引擎的功能也在这一层实现，如过程、函数等。在该层，服务器会解析查询并创建相应的内部解析树，并对其完成相应的优化如确定查询表的顺序，是否利用索引等，最后生成相应的执行操作。如果是select语句，服务器还会查询内部的缓存。如果缓存空间足够大，这样在解决大量读操作的环境中能够很好的提升系统的性能。</p>
<h2 id="3-引擎层"><a href="#3-引擎层" class="headerlink" title="3.引擎层"></a>3.引擎层</h2><p>​	存储引擎层，存储引擎真正的负责了MySQL中数据的存储和提取，服务器通过API与存储引擎进行通信。不同的存储引擎具有的功能不同，这样我们可以根据自己的实际需要进行选取。后面介绍MylSAM和InnoDB</p>
<p>常用的存储引擎：MyISAM、InnoDB(最常用)</p>
<table>
<thead>
<tr>
<th align="left">对比项</th>
<th align="center">MylSAM</th>
<th align="center">InnoDB</th>
</tr>
</thead>
<tbody><tr>
<td align="left">主外键</td>
<td align="center">不支持</td>
<td align="center">支持</td>
</tr>
<tr>
<td align="left">事务</td>
<td align="center">不馳</td>
<td align="center">支持</td>
</tr>
<tr>
<td align="left">行表锁</td>
<td align="center">表锁，即使操作一条记录也会锁住整 个表，不适合高并发的操作</td>
<td align="center">行锁,操作时只锁某一行，不对其它 行有影响， 适合高并发的操作</td>
</tr>
<tr>
<td align="left">緩存</td>
<td align="center">只緩存索引，不缓存真实数据</td>
<td align="center">不仅缓存索引还要缓存真实数据，对 内存要求较高，而且内存大小对性能 有决定性的影响</td>
</tr>
<tr>
<td align="left">表空间</td>
<td align="center">小</td>
<td align="center">大</td>
</tr>
<tr>
<td align="left">关注点</td>
<td align="center">性能</td>
<td align="center">事务</td>
</tr>
<tr>
<td align="left">默认安装</td>
<td align="center">Y</td>
<td align="center">Y</td>
</tr>
</tbody></table>
<h2 id="4-存储层"><a href="#4-存储层" class="headerlink" title="4.存储层"></a>4.存储层</h2><p>​	数据存储层，主要是将数据存储在运行于裸设备的文件系统之上，并完成与存储引擎的交互。</p>
<img data-src="/2022/10/07/DataBase/MySQL/MySQL_Super/image-20220816181915861.png" class="">



<h2 id="连接器"><a href="#连接器" class="headerlink" title="连接器"></a>连接器</h2><p>▪  连接器负责跟客户端建立连接，获取权限、维持和管理连接<br>– 用户名密码验证<br>– 查询权限信息，分配对应的权限<br>– 可以使用show processlist查看现在的连接<br>– 如果太长时间没有动静，  就会自动断开，通过wait_timeout控制，默认8小时</p>
<p>▪  连接可以分为两类：</p>
<p>– 长连接：推荐使用，但是要周期性的断开长连接</p>
<p>– 短链接：</p>
<h2 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h2><p>▪  当执行查询语句的时候，会先去查询缓存中查看结果，之前执行 过的sql语句及其结果可能以key-value的形式存储在缓存中，如 果能找到则直接返回，如果找不到，就继续执行后续的阶段。<br>&#x3D;&#x3D;▪  但是，不推荐使用查询缓存：&#x3D;&#x3D;<br>– 1、查询缓存的失效比较频繁，只要表更新，缓存就会清空</p>
<p>– 2、缓存对应新更新的数据命中率比较低</p>
<h2 id="分析器"><a href="#分析器" class="headerlink" title="分析器"></a>分析器</h2><p>▪  词法分析：  Mysql需要把输入的字符串进行识别每个部分代表什 么意思<br>– 把字符串 T 识别成 表名 T<br>– 把字符串 ID 识别成 列ID<br>▪  语法分析：</p>
<p>▪  根据语法规则判断这个sql语句是否满足mysql的语法，如果不符 合就会报错“You have an error in your SQL synta”</p>
<h2 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h2><p>▪  在具体执行SQL语句之前，要先经过优化器的处理<br>– 当表中有多个索引的时候，决定用哪个索引<br>– 当sql语句需要做多表关联的时候，  决定表的连接顺序<br>– 等等<br>▪ 不同的执行方式对SQL语句的执行效率影响很大<br>– RBO:基于规则的优化</p>
<p>– CBO:基于成本的优化</p>
<h1 id="SQL性能下降原因"><a href="#SQL性能下降原因" class="headerlink" title="SQL性能下降原因"></a>SQL性能下降原因</h1><ol>
<li>查询语句写的烂</li>
<li>索引失效</li>
<li>关联查询太多 join </li>
<li>服务器调优及各个参数设置（缓冲、线程数）</li>
<li>……….etc</li>
</ol>
<h1 id="SQL语句机读过程"><a href="#SQL语句机读过程" class="headerlink" title="SQL语句机读过程"></a>SQL语句机读过程</h1><p>人工：</p>
<pre><code class="sql">    SELECT DISTINCT
        &lt;SELECT_list&gt;
    FROM
        &lt;left_table&gt; &lt;join_type&gt;
    Join &lt;right_table&gt; on &lt;join_condition&gt;
    WHERE 
        &lt;WHERE_Condition&gt;
    GROUP BY
        &lt;group_by_list&gt;
    HAVING
        &lt;having_condition&gt;
    ORDER BY
        &lt;order_by_condition&gt;
    LIMIT &lt;limit_num&gt;
</code></pre>
<p>机器：</p>
<img data-src="/2022/10/07/DataBase/MySQL/MySQL_Super/image-20220816200725202.png" class="">



<p>注意第一步是 from –&gt; on –&gt; join –&gt;where –&gt;group by –&gt;having –&gt;select –&gt;order by –&gt;limit</p>
<pre><code class="sql">    from &lt;left table&gt;
        on &lt;on_condition&gt;
    &lt;join_type&gt; join &lt;join_table&gt;
    where &lt;where_condition&gt;
    group by &lt;group_by_list&gt;
        &lt;sum()avg()等聚合函数&gt;
    having &lt;having_condition&gt;
    select &lt;select_list&gt;
    distinct
    order by &lt;order_by_condition&gt;
    limit &lt;limit_number&gt;
</code></pre>
<h2 id="on和where的区别？"><a href="#on和where的区别？" class="headerlink" title="on和where的区别？"></a>on和where的区别？</h2><p>​	简单地说，当有外关联表时，on主要是针对外关联表进行筛选，主表保留，当没有关联表时，二者作用相同。</p>
<p>例如在左外连时，首先执行on，筛选掉外连表中不符合on表达式的数据，而where的筛选是对主表的筛选。</p>
<h1 id="MySql执行顺序理解"><a href="#MySql执行顺序理解" class="headerlink" title="MySql执行顺序理解"></a>MySql执行顺序理解</h1><p>第一步：加载from子句的前两个表计算笛卡尔积，生成虚拟表vt1；</p>
<p>第二步：筛选关联表符合on表达式的数据，保留主表，生成虚拟表vt2；</p>
<p>第三步：如果使用的是外连接，执行on的时候，会将主表中不符合on条件的数据也加载进来，做为外部行</p>
<p>第四步：如果from子句中的表数量大于2，则重复第一步到第三步，直至所有的表都加载完毕，更新vt3；</p>
<p>第五步：执行where表达式，筛选掉不符合条件的数据生成vt4；</p>
<p>第六步：执行group by子句。group by 子句执行过后，会对子句组合成唯一值并且对每个唯一值只包含一行，生成vt5,。一旦执行group by，后面的所有步骤只能得到vt5中的列（group by的子句包含的列）和聚合函数。</p>
<p>第七步：执行聚合函数，生成vt6；</p>
<p>第八步：执行having表达式，筛选vt6中的数据。having是唯一一个在分组后的条件筛选，生成vt7;</p>
<p>第九步：从vt7中筛选列，生成vt8；</p>
<p>第十步：执行distinct，对vt8去重，生成vt9。其实执行过group by后就没必要再去执行distinct，因为分组后，每组只会有一条数据，并且每条数据都不相同。</p>
<p>第十一步：对vt9进行排序，此处返回的不是一个虚拟表，而是一个游标，记录了数据的排序顺序，此处可以使用别名；</p>
<p>第十二步：执行limit语句，将结果返回给客户端</p>
<div name=索引优化分析 >

<h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><p>​	MySQL官方对索引的定义为：索引(Index）是帮助MySQL高效获取数据的数据结构。可以得到索引的本质:&#x3D;&#x3D;索引是数据结构&#x3D;&#x3D;。</p>
<p><font color=red >可以简单理解为 “排好序的快速查找数据结构”</font></p>
<p>一般来说索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上</p>
<p>我们平常所说的&#x3D;&#x3D;索引，如果没有特别指明，都是指B树(多路搜索树，并不一定是二叉的)结构组织的索引&#x3D;&#x3D;。其中聚集索引，次要索引，复合索引，前缀索引，唯一索引默认都是使用B+树索引，统称索引。当然，除了B+树这种类型的索引之外还有哈稀索引(hash，index)等。</p>
<p>简单来说&#x3D;&#x3D;最大的作用&#x3D;&#x3D;就是 &#x3D;&#x3D;排序&#x3D;&#x3D; 和 &#x3D;&#x3D;查询&#x3D;&#x3D; </p>
<h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><p>提高查询效率，可以类比字典，<br>如果要查“mysql”这个单询，我们肯定需要定位到m字母，然后从下往下找到y字母，再找到剩下的sql。<br>如果没有索引，那么你可能需要a—-z，如果我想找到Java开头的单词呢?或者Oracle开头的单词呢?<br>是不是觉得如果没有索引，这个事情根本无法完成?</p>
<h2 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h2><p>​	在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引。</p>
<p>下图就是一种可能的索引方式示例:</p>
<img data-src="/2022/10/07/DataBase/MySQL/MySQL_Super/image-20220816211711261.png" class="">



<p>​				左边是数据表，一共有两列七条记录，最左边的是数据记录的物理地址</p>
<p>​	为了加快Col2的查找，可以维护一个右边所示的二叉查找树，每个节点分别包含索引键值和一个指向对应数据记录物理地址的指针，这样就可以运用二叉查找在一定的复杂度内获取到相应数据，从而快速的检索出符合条件的记录.</p>
<h2 id="优劣"><a href="#优劣" class="headerlink" title="优劣"></a>优劣</h2><p>优势：</p>
<p>​	类似大学图书馆建书目索引，提高数据检索的效率，降低数据库的IO成本</p>
<p>​	 通过索引列对数据进行排序，降低数据排序的成本，降低了CPU的消耗</p>
<p>劣势：</p>
<p>​	1、实际上索引也是一张表，该表保存了主键与索引字段，并指向实体表的记录，所以索引列也是要占用空间</p>
<p>​	2、虽然索引大大提高了查询速度，同时却会降低更新表的速度，如对表进行INSERT、UPDATE和DELETE。因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件每次更新添加了索引列的字段，<br>都会调整因为更新所带来的键值变化后的索引信息<br>​	3、索引只是提高效率的一个因素，如果你的MySQL有大数据量的表，就需要花时间研究建立最优秀的索引</p>
<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><ul>
<li>单值索引：即一个索引只包含单个列，一个表可以有多个单列索引</li>
<li>唯一索引：索引列的值必须唯一，但允许有空值</li>
<li>复合索引：即一个索引包含多个列</li>
</ul>
<h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><ul>
<li><p>创建：</p>
<ul>
<li>CREATE	 [UNIQUE ]INDEX  	indexName   	ON   	mytable(columnname(length));</li>
<li>CREATE	 [UNIQUE ]INDEX      indexName   	ON   	mytable(columnname(length));</li>
</ul>
<p>	</p>
</li>
<li><p>删除 </p>
<ul>
<li>DROP 	INDEX 	[indexName] 	ON 	mytable;</li>
</ul>
</li>
<li><p>查看  </p>
<ul>
<li>SHOW 		INDEX 		FROM 		table_name\G</li>
</ul>
</li>
<li><p>使用ALTER命令</p>
</li>
</ul>
<h2 id="MySQL索引结构"><a href="#MySQL索引结构" class="headerlink" title="MySQL索引结构"></a>MySQL索引结构</h2><ul>
<li><p>BTree索引</p>
</li>
<li><p>Hash索引</p>
</li>
<li><p>Full-Text全文索引</p>
</li>
<li><p>R-Tree索引</p>
</li>
</ul>
<h2 id="哪些情况下需要创建索引"><a href="#哪些情况下需要创建索引" class="headerlink" title="哪些情况下需要创建索引"></a>哪些情况下需要创建索引</h2><ol>
<li><p>主键自动建立唯一索引</p>
</li>
<li><p>频繁作为查询条件的字段应该创建索引</p>
</li>
<li><p>查询中与其它表关联的字段，外键关系建立索引</p>
</li>
<li><p>频繁更新的字段不适合创建索引or因为每次更新不单单是更新了记录还会更新索引</p>
</li>
<li><p>Where条件里用不到的字段不创建索引</p>
</li>
<li><p>单键&#x2F;组合索引的选择问题，who?(在高并发下倾向创建组合索引)</p>
</li>
<li><p>查询中排序的字段，排序字段若通过索引去访问将大大提高排序速度</p>
</li>
<li><p>查询中统计或者分组字段</p>
</li>
</ol>
<h2 id="哪些情况不建索引"><a href="#哪些情况不建索引" class="headerlink" title="哪些情况不建索引"></a>哪些情况不建索引</h2><ol>
<li><p>表记录太少</p>
</li>
<li><p>经常增删改的表</p>
<p> Why:提高了查询速度，同时却会降低更新表的速度，如对表进行INSERT、UPDATE和DELETE。因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件</p>
</li>
<li><p>数据重复且分布平均的表字段，因此应该只为最经常查询和最经常排序的数据列建立索引。注意，如果某个数据列包含许多重复的内容，为它建立索引就没有太大的实际效果。</p>
</li>
</ol>
<h1 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h1><h2 id="MySql-Query-Optimizer"><a href="#MySql-Query-Optimizer" class="headerlink" title="MySql Query Optimizer"></a>MySql Query Optimizer</h2><ol>
<li><p>Mysql中有专门负责优化SELECT语句的优化器模块，主要功能:通过计算分析系统中收集到的统计信息，为客户端请求的Query提供他认为最优的执行计划（他认为最优的数据检索方式，但不见得是DBA认为是最优的，这部分最耗费时间)</p>
</li>
<li><p>当客户端向MySQL请求一条Query，命令解析器模块完成请求分类，区别出是SELECT并转发给MySQLQuery Optimizer时，MySQL Query Optimizer首先会对整条Query进行优化，处理掉一些常量表达式的预算，直接换算成常量值。并对Query中的查询条件进行简化和转换，如去掉一些无用或显而易见的条件、结构调整等。然后分析Query 中的Hint信息(如果有），看显示Hint信息是否可以完全确定该Query 的执行计划。如果没有Hint 或Hint 信息还不足以完全确定执行计划，则会读取所涉及对象的统计信息，根据Query进行写相应的计算分析，然后再得出最后的执行计划。</p>
</li>
</ol>
<h2 id="MysQL常见瓶颈"><a href="#MysQL常见瓶颈" class="headerlink" title="MysQL常见瓶颈"></a>MysQL常见瓶颈</h2><p>CPU:CPU在饱和的时候一般发生在数据装入内存或从磁盘上读取数据时候</p>
<p>IO:磁盘I&#x2F;O瓶颈发生在装入数据远大于内存容量的时候</p>
<p>服务器硬件的性能瓶颈: top,free, iostat和vmstat来查看系统的性能状态</p>
<h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>​	查看执行计划</p>
<p>​	使用EXPLAIN关键字可以模拟优化器执行sQL查询语句，从而知道MySQL是如何处理你的SQL语句的。分析你的查询语句或是表结构的性能瓶颈</p>
<h3 id="作用范围"><a href="#作用范围" class="headerlink" title="作用范围"></a>作用范围</h3><ol>
<li><p>表的读取顺序   __ id__</p>
</li>
<li><p>数据读取操作的操作类型哪些索引可以使用  <strong>possible key</strong></p>
</li>
<li><p>哪些索引被实际使用表之间的引用  <strong>key</strong></p>
</li>
<li><p>每张表有多少行被优化器查询    <strong>rows</strong></p>
</li>
<li><p>表之间的引用 <strong>table</strong></p>
</li>
<li><p>每张表有多少行被优化     <strong>rows</strong></p>
</li>
</ol>
<h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><p>explain + SQL语句</p>
<h3 id="执行计划包含的信息"><a href="#执行计划包含的信息" class="headerlink" title="执行计划包含的信息"></a>执行计划包含的信息</h3><p><span class="exturl" data-url="aHR0cHM6Ly9kZXYubXlzcWwuY29tL2RvYy9yZWZtYW4vNS43L2VuL2V4cGxhaW4tb3V0cHV0Lmh0bWwjZXhwbGFpbl9zZWxlY3RfdHlwZQ==">MySQL ：： MySQL 5.7 参考手册 ：： 8.8.2 EXPLAIN 输出格式</span></p>
<table>
<thead>
<tr>
<th align="center">列</th>
<th align="center">JSON名称</th>
<th align="center">意义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">id</td>
<td align="center">select_id</td>
<td align="center">标识符SELECT</td>
</tr>
<tr>
<td align="center"><a href="#select_type">select type</a></td>
<td align="center">没有</td>
<td align="center">类型SELECT</td>
</tr>
<tr>
<td align="center">table</td>
<td align="center">table_name</td>
<td align="center">输出行的表</td>
</tr>
<tr>
<td align="center">partitions</td>
<td align="center">partitions</td>
<td align="center">匹配的分区</td>
</tr>
<tr>
<td align="center"><span class="exturl" data-url="aHR0cHM6Ly9kZXYubXlzcWwuY29tL2RvYy9yZWZtYW4vNS43L2VuL2V4cGxhaW4tb3V0cHV0Lmh0bWwjZXhwbGFpbi1qb2luLXR5cGVz">type</span></td>
<td align="center">access_type</td>
<td align="center">联接頰</td>
</tr>
<tr>
<td align="center">possible keys</td>
<td align="center">possible_keys</td>
<td align="center">可供选择的可能索引</td>
</tr>
<tr>
<td align="center">key</td>
<td align="center">key</td>
<td align="center">实际选择的索引</td>
</tr>
<tr>
<td align="center">key 丄en</td>
<td align="center">key_length</td>
<td align="center">所选密钥的长度</td>
</tr>
<tr>
<td align="center">ref</td>
<td align="center">ref</td>
<td align="center">与索引相比的列</td>
</tr>
<tr>
<td align="center">rows</td>
<td align="center">rows</td>
<td align="center">要检查的行的估计值</td>
</tr>
<tr>
<td align="center">filtered</td>
<td align="center">filtered</td>
<td align="center">符合某条件的记录数百分比。</td>
</tr>
<tr>
<td align="center">Extra</td>
<td align="center">None</td>
<td align="center">附加信息</td>
</tr>
</tbody></table>
<h3 id="字段解释"><a href="#字段解释" class="headerlink" title="字段解释"></a>字段解释</h3><h4 id="id"><a href="#id" class="headerlink" title="id"></a>id</h4><p>id相同，执行顺序由上至下</p>
<p>id不同，如果是子查询，id的序号会递增，id值越大优先级越高，越先被执行</p>
<p>null 为结果集的整合</p>
<p>总结：</p>
<ul>
<li>&#x3D;&#x3D;id如果相同，可以认为是一组，从上往下顺序执行&#x3D;&#x3D;;</li>
<li>id值越大，优先级越高，越先执行</li>
</ul>
<h4 id="select-type"><a href="#select-type" class="headerlink" title="select_type"></a>select_type</h4><p><a href="#select_type">见下方附录</a></p>
<h4 id="table"><a href="#table" class="headerlink" title="table"></a>table</h4><p>对应行正在访问哪一个表，表名或者别名，可能是临时表或者union合并结果集<br>        1、如果是具体的表名，则表明从实际的物理表中获取数据，当然也可以是表的别名</p>
<p>​		2、表名是derivedN的形式，表示使用了id为N的查询产生的衍生表</p>
<p>​		3、当有union result的时候，表名是union n1,n2等的形式，n1,n2表示参与union的id</p>
<h4 id="type"><a href="#type" class="headerlink" title="type"></a>type</h4><p><a href="#type_example">例子见下方附录</a></p>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">性能</th>
<th>注释</th>
</tr>
</thead>
<tbody><tr>
<td align="center">system</td>
<td align="center">1</td>
<td>&#x3D;&#x3D;表只有一行记录&#x3D;&#x3D;(等于系统表),这是const类型的特例，平时不会出现，可忽略</td>
</tr>
<tr>
<td align="center">const</td>
<td align="center">2</td>
<td>表示该表最多有一个匹配行通过索引一次就找到了,const用于比较primary key或者<br/>unique索引。因为只匹配一行数据，所以很快如将主键置于where列表中<br/>MySQL就能将该查询转换为一个常量</td>
</tr>
<tr>
<td align="center">eq_ref</td>
<td align="center">3</td>
<td>&#x3D;&#x3D;唯一性索引&#x3D;&#x3D;扫描，对于&#x3D;&#x3D;每个索引键，表中只有一条记录与之匹配&#x3D;&#x3D;。<br/>常见于主键或唯一索引扫描</td>
</tr>
<tr>
<td align="center">ref</td>
<td align="center">4</td>
<td>&#x3D;&#x3D;非唯一性索引&#x3D;&#x3D;扫描，&#x3D;&#x3D;返回匹配某个单独值的所有行&#x3D;&#x3D;.<br/>本质上也是一种索引访问，它返回所有匹配某个单独值的行，然而， <br/>它可能会找到多个符合条件的行，所以他应该属于查找和扫描的混合体</td>
</tr>
<tr>
<td align="center">range</td>
<td align="center">5</td>
<td>&#x3D;&#x3D;只检索给定范围的行,使用一个索引来选择行&#x3D;&#x3D;。key列显示使用了哪个索引，<br/>一般就是在你的where语句中出现了between、&lt;、&gt;、in等的查询  <br/>这种范围扫描索引扫描比全表扫描要好，，这样避免了index的全索引扫描<br/>因为它只需要开始于索引的某一点，而结束语另一点，不用扫描全部索引</td>
</tr>
<tr>
<td align="center">index</td>
<td align="center">6</td>
<td>联接类型与 <a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#jointype_all"><code>ALL</code></a> 相同，只是扫描了索引树。这以两种方式发生：<code>index</code> <br/>Full Index Scan，index与ALL区别为index类型只遍历索引树。这通常比ALL快，<br/>因为索引文件通常比数据文件小。(也就是说虽然all和Index都是读全表，<br/>但index是从索引中读取的，而all是从硬盘中读的)<br/>全索引扫描这个比all的效率要好，主要有两种情况,一种是当前的查询时覆盖索引<br/>即我们需要的数据在索引中就可以索取，或者是使用了索引进行排序，<br/>这样就避免数据的重排序</td>
</tr>
<tr>
<td align="center">all</td>
<td align="center">7</td>
<td>将遍历全表以找到匹配的行<br/>全表扫描，一般情况下出现这样的sql语句而且数据量比较大的话那么就需要进行优化。</td>
</tr>
</tbody></table>
<p><font color=red>一般来说，得保证查询至少要达到 range 级别，最好能达到 ref </font></p>
<h4 id="possible-key"><a href="#possible-key" class="headerlink" title="possible_key"></a>possible_key</h4><p>显示可能应用在这张表中的索引，一个或多个</p>
<p>查询涉及到的字段上若存在索引，则该索引将被列出，<font color=red>但不一定被查询实际使用</font>。</p>
<h4 id="key"><a href="#key" class="headerlink" title="key"></a>key</h4><p>&#x3D;&#x3D;实际使用的索引。如果为NULL，则没有使用索引&#x3D;&#x3D;</p>
<p>查询中若使用了覆盖索引，则该索引仅出现在key列表中</p>
<p><font color=red>引申：</font></p>
<p>覆盖索引：简单来说就是你查询到的字段数目和你建立索引所对应字段相同且数量相同</p>
<h4 id="key-len"><a href="#key-len" class="headerlink" title="key_len"></a>key_len</h4><p>​	表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度。在不损失精确性的情况下，&#x3D;&#x3D;长度越短越好&#x3D;&#x3D;<br>​	key_len显示的值为索刳字段的最大可能长度，<font color=red>并非实际使用长度</font>，即key_len是根据表定义计算而得，不是通过表内检索出的</p>
<h4 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h4><p>​	显示索引的哪一列被使用了，如果可能的话，是一个常数。哪些列或常量被用于查找索引列上的值</p>
<h4 id="rows"><a href="#rows" class="headerlink" title="rows"></a>rows</h4><p>​	根据表的统计信息及索引使用情况，大致估算出找出所需记录需要读取的行数，此参数很重要，直接反应的sql找了多少数据，在完成目的的情况下越少越好</p>
<h4 id="extra"><a href="#extra" class="headerlink" title="extra"></a>extra</h4><p>包含不适合在其他列中显示但十分重要的额外信息</p>
<ul>
<li><p>Using filesort(<font color=red>索引本来就是排序和查找,这种等于只用了一半,而且排序本身就比较耗时</font>)</p>
<p>  说明mysq|会对数据使用一个外部的索引排序，而不是按照表内的索引顺序进行读取。</p>
<p>  MySQL中无法利用索引完成的排序操作称为“文件排序”</p>
</li>
<li><p>Using temporay(<font color=red>严重影响性能</font>)</p>
<p>  使了用临时表保存中间结果,MySQL在对查询结果排序时使用临时表。</p>
<p>  常见于排序orderby和分组查询groupby。</p>
</li>
<li><p>Using  index</p>
<p>  表示相应的select操作中使用了覆盖索引(Covering Index)，避免访问了表的数据行，效率不错!如果同时出现</p>
<p>  using where，表明索引被用来执行索引键值的查找;</p>
<p>  如果没有同时出现using where，表明索引用来读取数据而非执行查找动作。</p>
<p>  <strong>&#x3D;&#x3D;覆盖索引(Covering Index)&#x3D;&#x3D;</strong></p>
<p>  理解方式：就是select的数据列只用从索引中就能够取得，不必读取数据行，MySQL可 以利用索引返回select列表中的字段，而不必根据索引再次读取数据文件,换句话说查询列要被所建的索引覆盖。</p>
<p>  &#x3D;&#x3D;<strong>注意:</strong>&#x3D;&#x3D;<br>  如果要使用覆盖索引，一-定 要注意select列表中只取出需要的列，不可   **&#x3D;&#x3D;Select   <em>&#x3D;&#x3D;</em>*<br>  因为如果将所有字段一起做索引会导致索引文件过大，查询性能下降。</p>
</li>
</ul>
<p><a href="#extra_example">具体事例见附录</a></p>
<h1 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a>索引优化</h1><h2 id="单表优化"><a href="#单表优化" class="headerlink" title="单表优化"></a>单表优化</h2><p>准备</p>
<pre><code class="sql">CREATE TABLE IF NOT EXISTS article (
id INT(10) UNSIGNED NOT NULL PRIMARY KEY auto_INCREMENT,
author_id INT(10) UNSIGNED NOT NULL,
category_id INT(10) UNSIGNED NOT NULL,
views INT(10) UNSIGNED NOT NULL,
comments INT(10) UNSIGNED NOT NULL,
title VARBINARY(255) NOT NULL,
content TEXT NOT NULL
);

INSERT INTO article ( author_id ,category_id ,views ,comments ,title,content ) VALUES
(1, 1, 1, 1,&#39;1&#39;,&#39;1&#39;),
(2,2, 2,2, &#39;2&#39;,&#39;2&#39;),
(1, 1,3,3, &#39;3&#39;,&#39;3&#39;);


-- ----------------------------------------------
-- 01
explain select id,author_id
from article 
where category_id =1 and comments &gt;1 
order by views desc 
limit 1\G
-- 01-1
create index idx_id_article_ccv on article(category_id,comments,views);
drop index idx_id_article_ccv on article;
create index idx_id_article_cv on article(category_id,views);
drop index idx_id_article_cv on article;
-- 查看之后发现因为 &gt; 1 的原因导致我们索引失效 我们直接放弃这个字段从三个改为两个字段的索引，性能更优
explain select id,author_id from article where category_id =1 and comments &gt;1  order by views desc limit 1 ;
explain select id,author_id from article where category_id =1 and comments =1  order by views desc limit 1 ;
</code></pre>
<h2 id="双表优化"><a href="#双表优化" class="headerlink" title="双表优化"></a>双表优化</h2><pre><code class="sql">CREATE TABLE IF NOT EXISTS `class`(
`id` INT(10) UNSIGNED NOT NULL AUTO_INCREMENT,
`card`INT(10) UNSIGNED NOT NULL,
 PRIMARY KEY (id)
 );
create TABLE IF NOT EXISTS `book` (
`bookid` INT(10) UNSIGNED NOT NULL AUTO_INCREMENT,
`card`  INT(10) UNSIGNED NOT NULL,
 PRIMARY KEY (bookid)
);
INSERT INTO class(card) VALUES(FLOOR(1 + (rand() * 20)));
INSERT INTO class(card) VALUES(FLOOR(1 + (rand() * 20)));
INSERT INTO class(card) VALUES(FLOOR(1 + (rand() * 20)));
INSERT INTO class(card) VALUES(FLOOR(1 + (rand() * 20)));
INSERT INTO class(card) VALUES(FLOOR(1 + (rand() * 20)));
INSERT INTO class(card) VALUES(FLOOR(1 + (rand() * 20)));
INSERT INTO class(card) VALUES(FLOOR(1 + (rand() * 20)));
INSERT INTO class(card) VALUES(FLOOR(1 + (rand() * 20)));
INSERT INTO book(card) VALUES(FLOOR(1 + (rand() * 20)));
INSERT INTO book(card) VALUES(FLOOR(1 + (rand() * 20)));
INSERT INTO book(card) VALUES(FLOOR(1 + (rand() * 20)));
INSERT INTO book(card) VALUES(FLOOR(1 + (rand() * 20)));
INSERT INTO book(card) VALUES(FLOOR(1 + (rand() * 20)));
INSERT INTO book(card) VALUES(FLOOR(1 + (rand() * 20)));
INSERT INTO book(card) VALUES(FLOOR(1 + (rand() * 20)));
INSERT INTO book(card) VALUES(FLOOR(1 + (rand() * 20)));
-- ----------------------------------------------
select * from book;
select * from class;

-- type=all
show index from book;
show index from class;

create index idx_card on  book(card);
create index idx_card on  class(card);
drop index idx_card on  book;
drop index idx_card on  class;

explain select * from  book left join class on class.card=book.card;

explain select * from  class left join book on class.card=book.card;
</code></pre>
<p><strong>左连接</strong></p>
<img data-src="/2022/10/07/DataBase/MySQL/MySQL_Super/image-20220818221306990.png" class="">



<p>结果显示，在没有用索引的状况下我们的索引类型均为ALL。</p>
<p>因为是&#x3D;&#x3D;左连接&#x3D;&#x3D;的缘故我们的&#x3D;&#x3D;左表是根据右表搜索行&#x3D;&#x3D;的，&#x3D;&#x3D;左边一定都有&#x3D;&#x3D;,所以&#x3D;&#x3D;右边是我们的关键点&#x3D;&#x3D;，一定需要建立索引。</p>
<img data-src="/2022/10/07/DataBase/MySQL/MySQL_Super/image-20220818221831192.png" class="">



<p>可以看到第二行的type变为了ref，rows 也变成了优化比较明显。这是由左连接特性决定的。LEFT  JOIN条件用于确定如何从右表搜索行。所以右边是我们的关键点,-定需要建立索引。</p>
<p><strong>同理可证右连接</strong><br>因为RIGHTJOIN条件用于确定如何从左表搜索行，右边一定都有,所以左边是我们的关键点，一定需要建立索引。</p>
<h2 id="三表优化"><a href="#三表优化" class="headerlink" title="三表优化"></a>三表优化</h2><pre><code class="sql">CREATE TABLE IF NOT EXISTS phone(
    phoneid INT(10) UNSIGNED NOT null AUTO_INCREMENT,
    card INT(10) UNSIGNED NOT NULL,
    PRIMARY KEY (phoneid)
) ENGINE = INNODB;
INSERT INTO phone(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO phone(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO phone(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO phone(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO phone(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO phone(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO phone(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO phone(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO phone(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO phone(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO phone(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO phone(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO phone(card) VALUES(FLOOR(1 + (RAND() * 20)));
-- --------===============================================
select * from phone;

alter table class add index X (card); 
alter table phone add index Y (card); 
drop index X on class;
drop index Y on phone;

explain select * from class left join book on class.card = book.card join phone on book.card = phone.card;

show index from phone;
show index from book;
show index from class;
</code></pre>
<p>初始结果</p>
<img data-src="/2022/10/07/DataBase/MySQL/MySQL_Super/image-20220818222159241.png" class="">



<p>优化后</p>
<img data-src="/2022/10/07/DataBase/MySQL/MySQL_Super/image-20220818222905733.png" class="">



<p>后2行的type都是ref且总rows优化很好效果不错。</p>
<p>因此索引最好设置在需要经常查询的字段中</p>
<p>解释：不论是class还是phone都是需要book.card来确定而且在第二个join中还需要全部扫描book所以尽管他是一个与class的左连接，理论上要给book建立一个索引，但是因为phone的关系我们倒不如给phone和class做索引，减少可以减少的，book反正要全表无所谓。</p>
<p>总结就是&#x3D;&#x3D;小结果集推动大结果集&#x3D;&#x3D;就可以起到优化作用</p>
<h2 id="结论"><a href="#结论" class="headerlink" title="[结论]"></a>[结论]</h2><p>Join语句的优化</p>
<p>尽可能减少Join语句中的NestedL oop的循环总次数;“ 永远用小结果集驱动大的结果集”。</p>
<p>优先优化Nested L oop的内层循环;</p>
<p>保证Join语句中被驱动表上Join条件 字段已经被索引;</p>
<p>当无法保证被驱动表的Join条件字段被索引且内存资源充足的前提下，不要太吝惜JoinBuffer的设置;</p>
<h1 id="索引失效"><a href="#索引失效" class="headerlink" title="索引失效"></a>索引失效</h1><ol>
<li>全值匹配我最爱</li>
</ol>
<blockquote>
<p>​	每个索引字段都存在</p>
</blockquote>
<ol start="2">
<li>最佳左前缀法则(&#x3D;&#x3D;where条件&#x3D;&#x3D;)</li>
</ol>
<blockquote>
<p>​	如果索引了多列(&#x3D;&#x3D;3个及以上&#x3D;&#x3D;)，要遵守最左前缀法则。指的是查询&#x3D;&#x3D;从索引的最左前列开始&#x3D;&#x3D;并且&#x3D;&#x3D;不跳过索引中的列&#x3D;&#x3D;。<br>​	简单来说就是&#x3D;&#x3D;每个字段的带头大哥不能丢，中间兄弟不能断&#x3D;&#x3D; </p>
<pre><code class="sql">drop table if exists tbl_user;
create table if not exists tbl_user(
id int(10) primary key auto_increment,
   name varchar(20) not null,
   age int(10),
    sex int(2) check( sex in (1,2)),
   email varchar(20)
);
-- 添加测试数据
delete from  tbl_user;
insert into tbl_user(name,age,sex,email) values 
(&#39;aa11aa&#39;,12,1,&#39;123@qq.com&#39;),(&#39;aa22aa&#39;,22,2,&#39;456@qq.com&#39;),(&#39;aa33aa&#39;,32,2,&#39;789@qq.com&#39;);
(&#39;aa11aa&#39;,22,1,&#39;123@qq.com&#39;),(&#39;aa22aa&#39;,22,1,&#39;456@qq.com&#39;),(&#39;aa33aa&#39;,32,1,&#39;789@qq.com&#39;);
-- 走索引且key_len越来越长
explain select * from tbl_user where name = &#39;aa11aa&#39;;
explain select * from tbl_user where name = &#39;aa11aa&#39; and age = 11;
explain select * from tbl_user where name = &#39;aa11aa&#39; and age = 11 and sex = 1;

-- 走索引
explain select * from tbl_user where name = &#39;aa11aa&#39;  and sex = 1;
-- 不走索引带头大哥没了
explain select * from tbl_user where age = 11 and sex = 1;
</code></pre>
</blockquote>
<ol start="3">
<li><p>不在索引列上做任何操作(计算、函数(自动or手动)类型转换)，会导致索引失效而转向全表扫描 </p>
</li>
<li><p>存储引擎 &#x3D;&#x3D;不能使用索引中范围条件&#x3D;&#x3D;<font color=red>右边的列</font> (&#x3D;&#x3D;自己是最后一个&#x3D;&#x3D;)</p>
<pre><code class="sql">-- 范围条件
alter table tbl_user add index idx_tbl_user_age_sex_email (age,sex,email);
-- 全部走了索引
explain select age from tbl_user ;
explain select age,sex from tbl_user ;
explain select age,sex,email from tbl_user ;
-- 部分走了索引
explain select age from tbl_user where sex &gt; 1;
explain select age,sex from tbl_user where sex &gt; 1;
explain select age,sex,email from tbl_user where sex &gt; 1;
</code></pre>
</li>
<li><p>&#x3D;&#x3D;尽量使用覆盖索引&#x3D;&#x3D;(只访问索引的查询(索引列和查询列一致))， 减少 select  *</p>
</li>
<li><p>mysql在&#x3D;&#x3D;使用不等于(!&#x3D;或者&lt;&gt; )&#x3D;&#x3D;的时候&#x3D;&#x3D;无法使用索引&#x3D;&#x3D;会导致&#x3D;&#x3D;全表扫描团&#x3D;&#x3D;</p>
</li>
<li><p>is null ,is not null也无法使用索引</p>
</li>
<li><p>like&#x3D;&#x3D;以通配符开头(&#x3D;&#x3D;’%abc…)mysq|&#x3D;&#x3D;索引失效&#x3D;&#x3D;会变成全表扫描的操作。(&#x3D;&#x3D;放右边可以&#x3D;&#x3D;)</p>
<p> <strong>问题:解决like’%字符串%’时索引不被使用的方法??</strong></p>
<pre><code class="sql">-- 建立索引
alter table tbl_user add index idx_tbl_user_name_age (name,age);

-- 测试
select * from tbl_user;
-- 走索引
explain select id from tbl_user where name like &#39;%aa%&#39;;
explain select name from tbl_user where name like &#39;%aa%&#39;;
explain select age from tbl_user where name like &#39;%aa%&#39;;
-- 走索引
explain select id,name from tbl_user where name like &#39;%aa%&#39;;
explain select id,name,age from tbl_user where name like &#39;%aa%&#39;;
explain select name,age from tbl_user where name like &#39;%aa%&#39;;
-- 不走索引
explain select * from tbl_user where name like &#39;%aa%&#39;;
explain select id,name,email from tbl_user where name like &#39;%aa%&#39;;
explain select id,name,age,email from tbl_user where name like &#39;%aa%&#39;;
</code></pre>
</li>
<li><p>&#x3D;&#x3D;字符串不加单引号索引失效&#x3D;&#x3D;</p>
</li>
<li><p>少用or，用它来连接时会索引失效</p>
</li>
</ol>
<h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><pre><code class="sql">-- indexc1234
select * from test03 where c1=&#39;a1&#39; and c2=&#39;a2&#39; and c5=&#39;a5&#39; order by c3,c2;
select * from test03 where c1=&#39;a1&#39; and c5=&#39;a5&#39; order by c3,c2;
</code></pre>
<p><em><strong>这两种SQL的区别在哪？</strong></em></p>
<blockquote>
<p>都走了索引，但是在第2条SQL会产生文件的内排序，为什么呢？这是因为本来应该是自动的顺序排列，即c1,c2,c3…..默认，但是我们写了 order by 所以产生了内排。但是同样第1条SQL为什么没有呢？因为我们在where 条件中使用了他让他固定成了一个常量 constant ，即 c3虽然一直在动，但是c2已经固定没有了排序的过程所以不会产生内排的步骤</p>
<pre><code class="sql">drop table if exists t1;
create table t1(
    id int(10) primary key auto_increment,
    c1 int(10),
    c2 int(10),
    c3 int(10),
    c4 int(10),
    c5 int(10)
);
insert into t1(c1,c2,c3,c4,c5) values
(1,1,1,1,1)
(2,2,2,2,2),
(3,3,3,3,3),
(4,4,4,4,4),
(5,5,5,5,5);

alter table t1 add index idx_c1234 (c1,c2,c3,c4); 
explain select * from t1 where c1 =1 and c2 = 1 and c4 = 1 ORDER BY c3,c2 desc;
explain select * from t1 where c1 =1 and c4 = 1 ORDER BY c3,c2 ;  
</code></pre>
</blockquote>
<p>结果：</p>
<img data-src="/2022/10/07/DataBase/MySQL/MySQL_Super/image-20220818213253106.png" class="">



<p><em><strong>同理论证gourp by</strong></em></p>
<ul>
<li>分组之前比排序，可能会产生临时表的产生</li>
</ul>
<img data-src="/2022/10/07/DataBase/MySQL/MySQL_Super/image-20220818213434892.png" class="">





<h2 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h2><ul>
<li><p>对于单键索引，尽量选择针对当前query过滤性更好的索引</p>
</li>
<li><p>在选择组合索引的时候，当前Query中过滤性最好的字段在索引字段顺序中，位置越靠前越好。</p>
</li>
<li><p>在选择组合索引的时候，尽量选择可以能够包含当前query中的where字句中更多字段的索引</p>
</li>
<li><p>尽可能通过分析统计信息和调整query的写法来达到选择合适索引的目的</p>
</li>
</ul>
<h2 id="口诀"><a href="#口诀" class="headerlink" title="口诀"></a>口诀</h2><p>全值匹配我最爱	，最左前缀要遵守;</p>
<p>帶头大哥不能死	，中间兄弟不能断;</p>
<p>索引列上少计算	，范围之后全失效;</p>
<p>LIKE百分写最右	，覆盖索引不写星;</p>
<p>不等空值还有or     ，索引失效要少用;</p>
<p>VAR的引号不可丢，SQL高级也不难 !</p>
<div name=查询截取分析 >

<h1 id="查询截取分析"><a href="#查询截取分析" class="headerlink" title="查询截取分析"></a>查询截取分析</h1><h2 id="内容："><a href="#内容：" class="headerlink" title="内容："></a>内容：</h2><p>​	查询优化</p>
<p>​	慢查询日志</p>
<p>​	批量数据脚本</p>
<p>​	show profile</p>
<p>​	全局查询日志</p>
<h2 id="工作一般流程-分析过程"><a href="#工作一般流程-分析过程" class="headerlink" title="工作一般流程(分析过程)"></a>工作一般流程(分析过程)</h2><ol>
<li>观察，至少跑1天，看看生产的慢SQL情况。</li>
<li>开启慢查询日志，设置阙值，比如超过5秒钟的就是慢SQL，并将它抓取出来。</li>
<li>explain+慢SQL分析</li>
<li>show profile</li>
<li>运维经理or DBA，进行SQL数据库服务器的参数调优。。</li>
</ol>
<p>&#x3D;&#x3D;总结&#x3D;&#x3D;</p>
<ol>
<li><p>慢查询的开启并捕获</p>
</li>
<li><p>explain+慢SQL分析</p>
</li>
<li><p>show profile查询SQL在Mysql服务器里面的执行细节和生命周期情况</p>
</li>
<li><p>SQL数据库服务器的参数调优。</p>
</li>
</ol>
<h2 id="查询优化"><a href="#查询优化" class="headerlink" title="查询优化"></a>查询优化</h2><h3 id="永远小表驱动大表-即小的数据集驱动大的数据集"><a href="#永远小表驱动大表-即小的数据集驱动大的数据集" class="headerlink" title="永远小表驱动大表,即小的数据集驱动大的数据集"></a>永远小表驱动大表,即小的数据集驱动大的数据集</h3><p>小表驱动大表，类似嵌套循环 Nested Loop</p>
<h4 id="Case-1："><a href="#Case-1：" class="headerlink" title="Case 1："></a>Case 1：</h4><pre><code class="java">for(int i =5;;)&#123;
    for(int j = 1000;;)&#123;
        
    &#125;
&#125;
for(int i =1000;;)&#123;
    for(int j = 5;;)&#123;
        
    &#125;
&#125;
</code></pre>
<p>两个简单的 for循环，但是在SQL中我们就应该选择 第一个循环而不是第二个</p>
<ul>
<li>小的循环在外层,表连接需要5次</li>
<li>大的循环在外层,表连接需要1000次,浪费数据库资源</li>
</ul>
<p><strong>总结:</strong> 小表驱动大表的主要目的是通过减少表连接创建的次数,加快查询速度.</p>
<h4 id="Case-2"><a href="#Case-2" class="headerlink" title="Case 2"></a>Case 2</h4><pre><code class="sql">select * from A where  id in (select id from B)
-- 等价于
for select id from B
for select * from A where A.id = B.id
for（B)&#123;
    for(A)&#123;
        A.id=B.id
    &#125;
&#125;
</code></pre>
<p>当B表的数据集小于A表的数据集时，用in优于exists。</p>
<pre><code class="sql">select * from A where exists (select 1 from B where B.id = A.id)
-- 等价于
for select* from A
for select * from B where B.id = A.id
for（A)&#123;
    for(B)&#123;
        A.id=B.id
    &#125;
&#125;
</code></pre>
<p>当A表的数据集小于B表的数据集时，用exists优于in。</p>
<p>注意:A表与B表的ID字段应建立索引。</p>
<ul>
<li>EXISTS</li>
</ul>
<blockquote>
<p>语法：SELECT .….. FROM table WHERE EXISTS (subquery)</p>
</blockquote>
<p>​	该语法可以理解为。&#x3D;&#x3D;将主查询的数据，放到子查询中做条件验证，根据验证结果（TRUE或FALSE)来决定主查询的数据结果是否得以保留&#x3D;&#x3D;。 </p>
<ul>
<li>提示<ol>
<li>&#x3D;&#x3D;EXSTS (stbuey)只返回TRUE或FALSE，因此子查询中的 SELECT *也可以是 SELECT  1或是 SELECT ‘X’。官方说法是：实际执行时会忽略SELECT清单，因此没有区别&#x3D;&#x3D;</li>
<li>EXSTS子查询的实际执行过程可能经过了优化而不是我们理解上的逐条对比，如果担忧效率问题，可进行实际检验以确定是否有效率问题。</li>
<li>EXISTS子查询往往也可以用条件表达式、其他子查询或者JOIN来替代，&#x3D;&#x3D;何种最优需要具体问题具体分析&#x3D;&#x3D;</li>
</ol>
</li>
</ul>
<h3 id="为排序使用索引OrdeBy优化"><a href="#为排序使用索引OrdeBy优化" class="headerlink" title="为排序使用索引OrdeBy优化"></a>为排序使用索引OrdeBy优化</h3><p>MySQL支持&#x3D;&#x3D;二种方式的排序&#x3D;&#x3D;，&#x3D;&#x3D;FileSort&#x3D;&#x3D;和&#x3D;&#x3D;Index&#x3D;&#x3D;，&#x3D;&#x3D;Index效率高。&#x3D;&#x3D;</p>
<p>它指MySQL扫描索引本身完成排序。FileSort方式效率较低。</p>
<p><font color=red>ORDER BY满足两情况，会使用Index方式排序：</font></p>
<ul>
<li><p>ORDER BY语句使用索引最左前列</p>
</li>
<li><p>使用where 字句与Order By字句条件列组合满足&#x3D;&#x3D;索引最左前列&#x3D;&#x3D;</p>
</li>
</ul>
<p>建议：</p>
<p>​	尽量使用Index方式排序，避免使用FileSort方式排序尽可能在索引列上完成排序操作，遵照索引建的最佳左前缀</p>
<p><font color=red>如果不在索引列上，filesort有两种算法：mysql就要启动双路排序和单路排序</font></p>
<p>&#x3D;&#x3D;<em>双路排序</em>&#x3D;&#x3D;</p>
<blockquote>
<p>MySQL 4.1之前是使用双路排序,字面意思就是两次扫描磁盘，最终得到数据，<br>读取行指针和orderby列，对他们进行排序，然后扫描已经排序好的列表，按照列表中的值重新从列表中读取对应的数据输出</p>
<p>从磁盘取排序字段，在buffer进行排序，再从磁盘取其他字段。</p>
<p>取一批数据， 要对磁盘进行了两次扫描，众所周知，I\O是很耗时的，所以在mysql4.1之后，出现了第二种改进的算法，就是单路排序</p>
</blockquote>
<p>&#x3D;&#x3D;<em>单路排序</em>&#x3D;&#x3D;</p>
<blockquote>
<p>从磁盘读取查询需要的所有列，按照order by列在buffer对它们进行排序，然后扫描排序后的列表进行输出，它的效率更快一些，避免了第二次读取数据。并且把随机IO变成了顺序I0,但是它会使用更多的空间，因为它把每一行都保存在内存中了。</p>
</blockquote>
<p>结论：</p>
<p>​	<strong>由于单路是后出的，总体而言好过双路!</strong></p>
<p>引申出来的问题：</p>
<blockquote>
<p>​	在sort_buffer中，方法B比方法A要多占用很多空间，因为方法B是把所有字段都取出,所以有可能取出的数据的总大小超出了sort_buffer的容量，导致每次只能取sort_buffer容量大小的数据，进行排序（创建tmp文件，多路合并〉，排完再取取 sort_buffer 容量大小，再排……从而多次I&#x2F;O。本来想省一次I&#x2F;O操作，反而导致了大量的I&#x2F;O操作，反而得不偿失。</p>
</blockquote>
<p>优化策略</p>
<ul>
<li>增大sort_buffer_size参数的设置</li>
<li>增大max_length_for_sort_data参数的设置</li>
</ul>
<p><font color=red>提高Order By的速度</font></p>
<ol>
<li><p>Order by时select是一个大忌只Query需要的字段，这点非常重要。在这里的影响是:</p>
<ol>
<li>当Query的字段共小总和小于max_length_for_sort_data而且排序字段不是TEXTIBLOB类型时，会用改进后的算法——单路排序，否则用老算法——多路排序。</li>
<li>两种算法的数据都有可能超出sort_buffer的容量，超出之后，会创建tmp文件进行合并排序，导致多次IO，但是用单路排序算法的风险会更大一些,所以要提高sort_buffer_size.</li>
</ol>
</li>
<li><p>尝试提高sort_buffer_size<br> 不管用哪种算法，提高这个参数都会提高效率，当然，要根据系统的能力去提高，因为这个参数是针对每个进程的</p>
</li>
<li><p>尝试提高max_length_for_sort_data<br> 提高这个参数，会增加用改进算法的概率。但是如果设的太高，数据总容量超出sort_buffer_size的概率就增大，明显症状是高的磁盘I&#x2F;O活动和低的处理器使用率.</p>
</li>
</ol>
<h3 id="Group-By"><a href="#Group-By" class="headerlink" title="Group By"></a>Group By</h3><p> group by实质是&#x3D;&#x3D;先排序&#x3D;&#x3D;后进行&#x3D;&#x3D;分组&#x3D;&#x3D;，&#x3D;&#x3D;遵照索引建的最佳左前缀&#x3D;&#x3D;</p>
<p>当无法使用索引列，增大max_length_for_sort_data参数的设置+增大sort_buffer_size参数的设置</p>
<p>where高于having，能写在where限定的条件就不要去having限定了。</p>
<p>其余均和Order by相同</p>
<h2 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h2><ul>
<li><p>MySQL的慢查询日志是MySQL提供的一种日志记录，它用来记录在MySQL中响应时间超过阀值的语句, 具体指运行时间超过long_query_time值的SQL，则会被记录到慢查询日志中。</p>
</li>
<li><p>具体指运行时间超过long_query_time值的SQL，则会被记录到慢查询日志中。long_query_time的默认值为10，意思是运行10秒以上的语句。</p>
</li>
<li><p>由他来查看哪些SQL超出了我们的最大忍耐时间值，比如一条sql执行超过5秒钟，我们就算慢SQL，希望能收集超过5秒的sql，结合之前explain进行全面分析。</p>
</li>
</ul>
<h3 id="操作说明"><a href="#操作说明" class="headerlink" title="操作说明"></a>操作说明</h3><p><font color=red>默认情况下，MySQL数据库没有开启慢查询日志</font>，需要我们手动来设置这个参数。</p>
<p><font color=red>当然，如果不是调优需要的话，一般不建议启动该参数</font>，因为开启慢查询日志会或多或少带来一定的性能影响。慢查询日志支持将日志记录写入文件</p>
<h3 id="查看是否开启及开启"><a href="#查看是否开启及开启" class="headerlink" title="查看是否开启及开启"></a>查看是否开启及开启</h3><p>默认：</p>
<pre><code class="sql">show variables like &#39;%slow_query_log%&#39;; -- OFF关闭
</code></pre>
<img data-src="/2022/10/07/DataBase/MySQL/MySQL_Super/image-20220819170427373.png" class="">



<p>开启</p>
<p>开启了慢查询日志只对当前数据库生效，如果MySQL重启后则会失效。</p>
<pre><code class="sql">set global slow_query_log=1;
</code></pre>
<p>如果要永久生效，就必须修改配置文件my.cnf（其它系统变量也是如此)</p>
<p>修改my.cnf文件，[mysqld]下增加或修改参数<br>slow_query_log和slow_query_log_file后，然后重启MySQL服务器。也即将如下两行配置进my.cnf文件</p>
<pre><code class="sh">slow_query_log =1
slow_query_log_file=/var/lib/mysqlslow-slow.log
</code></pre>
<p>关于慢查询的参数slow_query_log_file，它指定慢查询日志文件的存放路径，<font color=red>系统默认会给一个缺省的文件host_name-slow.log</font>(如果没有指定参数slow_query_log_file的话)</p>
<h3 id="那么开启了慢查询日志后，什么样的SQL才会记录到慢查询日志里面呢"><a href="#那么开启了慢查询日志后，什么样的SQL才会记录到慢查询日志里面呢" class="headerlink" title="那么开启了慢查询日志后，什么样的SQL才会记录到慢查询日志里面呢?"></a>那么开启了慢查询日志后，什么样的SQL才会记录到慢查询日志里面呢?</h3><p>这个是由参数long_query_time控制，默认情况下long_query_time的值为10秒，命令:</p>
<pre><code class="sql">SHoW VARIABLES LIKE &#39;long_query_time%;
</code></pre>
<img data-src="/2022/10/07/DataBase/MySQL/MySQL_Super/image-20220819171026557.png" class="">




<p>可以使用命令修改，也可以在my.cnf参数里面修改。</p>
<p>假如运行时间正好等于long_query_time的情况，并不会被记录下来。也就是说，在mysql源码里是<font color=red>判断大于long_query_time，而非大于等于</font>。</p>
<h3 id="Case"><a href="#Case" class="headerlink" title="Case"></a>Case</h3><ol>
<li>查看当前多少秒算慢</li>
</ol>
<pre><code class="sql">SHOW VARIABLES LIKE &#39;long_query_time%&#39;;
</code></pre>
<ol start="2">
<li>设置慢的阙值时间</li>
</ol>
<pre><code class="sql">set global long_query_time=3;
</code></pre>
<img data-src="/2022/10/07/DataBase/MySQL/MySQL_Super/image-20220819171344450.png" class="">



<ol start="3">
<li>为什么设置后看不出变化?</li>
</ol>
<p>需要&#x3D;&#x3D;重新连接或新开一个会话&#x3D;&#x3D;才能看到修改值</p>
<pre><code class="sql">SHow VARIABLES LIKE &#39;long _query_time%&#39;;

show global variables like &#39;long_query_time&#39;;
</code></pre>
<ol start="4">
<li>记录慢SQL并后续分析R</li>
</ol>
<pre><code class="sql">select sleep(4);-- 睡4s
-- 查看日志
</code></pre>
<img data-src="/2022/10/07/DataBase/MySQL/MySQL_Super/image-20220819171955968.png" class="">



<ol start="5">
<li>查询当前系统中有多少条慢查询记录冒R</li>
</ol>
<pre><code class="sql">show global status like &#39;%Slow_queries%&#39;;
</code></pre>
<img data-src="/2022/10/07/DataBase/MySQL/MySQL_Super/image-20220819172043683.png" class="">



<h3 id="配置版"><a href="#配置版" class="headerlink" title="配置版"></a>配置版</h3><p>【mysqld】下配置:</p>
<pre><code class="sh"># 开启查询日志
slow_query_log=1;
# 日志地址
slow_query_log_file=/var/lib/mysql/atguigu-slow.log
# 最大的查询时间，超过就算是慢查询
long_query_time=3;
# 日志输出
log_output=FILE
</code></pre>
<h3 id="日志分析工具—mysqldumpslow"><a href="#日志分析工具—mysqldumpslow" class="headerlink" title="日志分析工具—mysqldumpslow"></a>日志分析工具—mysqldumpslow</h3><p>​	在生产环境中，如果要手工分析日志，查找、分析SQL，显然是个体力活，MySQL提供了日志分析工具mysqldumpslow </p>
<p>查看mysqldumpslow的帮助信息</p>
<pre><code class="sh">mysqldumpslow --help
</code></pre>
<table>
<thead>
<tr>
<th align="center">常用参数</th>
<th align="center">注解</th>
</tr>
</thead>
<tbody><tr>
<td align="center">s</td>
<td align="center">是表示按照何种方式排序</td>
</tr>
<tr>
<td align="center">c</td>
<td align="center">访问次数</td>
</tr>
<tr>
<td align="center">l</td>
<td align="center">锁定时间</td>
</tr>
<tr>
<td align="center">r</td>
<td align="center">返回记录</td>
</tr>
<tr>
<td align="center">t</td>
<td align="center">查询时间</td>
</tr>
<tr>
<td align="center">al</td>
<td align="center">平均锁定时间</td>
</tr>
<tr>
<td align="center">ar</td>
<td align="center">平均返回记录数</td>
</tr>
<tr>
<td align="center">at</td>
<td align="center">平均查询时间</td>
</tr>
<tr>
<td align="center">t</td>
<td align="center">即为返回前面多少条的数据;</td>
</tr>
<tr>
<td align="center">g</td>
<td align="center">后边搭配一个正则匹配模式，大小写不敏感的;</td>
</tr>
</tbody></table>
<pre><code class="sh">得到返回记录集最多的10个SQL
mysqldumpslow -s r -t 10 /var/lib/mysql/atguigu-slow.log

得到访问次数最多的10个SQL
mysqldumpslow -s c -t 10 /var/lib/mysql/atguigu-slow.log

得到按照时间排序的前10条里面含有左连接的查询语句
mysqldumpslow -s t -t 10 -g &quot;left join&quot;lar/lib/mysql/atguigu-slow.log

另外建议在使用这些命令时结合|和more使用，否则有可能出现爆屏情况
mysqldumpslow -s r -t 10 /ar/lib/mysql/atguigu-slow.log | more
</code></pre>
<h2 id="批量数据脚本"><a href="#批量数据脚本" class="headerlink" title="批量数据脚本"></a>批量数据脚本</h2><p>1.建表(dept,emp)</p>
<p>2.设置参数log_bin_trust_function_creatorst</p>
<pre><code class="sql">-- 创建函数，假如报错:This function has none of DETERMINISTIC

-- 由于开启过慢查询日志，因为我们开启了bin-log,我们就必须为我们的function指定一个参数。
show variables like &#39;log_bin_trust_function_creators&#39;;
set global log_bin_trust_function_creators=1;
-- 这样添加了参数以后，如果mysqld重启，上述参数又会消失，永久方法:
I
windows下my.ini[mysqld]加上log_bin_trust_function_creators=1
linux下letc/my.cnf 下my.cnf[mysqld]加上log_bin_trust_function_creators=1
</code></pre>
<p>3.创建函数,保证每条数据都不同</p>
<p>随机产生字符串</p>
<p>随机产生部门编号</p>
<pre><code class="sql">DELIMITER $$
CREATE FUNCTION rand_string(n lNT) RETURNS VARCHAR(255）
BEGIN
    DECLARE chars_str VARCHAR(100) DEFAULT &#39;abcdefghijlklmnoparstuvwxyABCDEFJHIJKLMNOPQRSTUWWXYZ&#39;;
    DECLARE return_str VARCHAR(255) DEFAULT &#39;&#39; ;
    DECLARE i INT DEFAULT 0;
    WHILE i &lt; n DO
        SET return_str =CONCAT(return_str,SUBSTRING(chars_str,FLOOR(1+RAND()*52),1);
        SET i =i+ 1;
    END WHILE;
    RETURN return_str;
END
$$
DFLIMITER ;
                               
delimiter $$
CREATE FUNCTLON rand_num( )RETURNS INT(5)
BEGIN
    DECLARE i int default 0;
    SET i = FLOOR(100+RAND()*10);
    RETURN i;
END 
delimiter $$
DFLIMITER ;
</code></pre>
<p>4.创建存储过程</p>
<pre><code class="sql">创建往emp表中插入数据的存储过程
DELIMITER $$
CREATE PROCEDURE insert_emp(IN START INT(10),IN max_num INT(10))
BEGIN
    DECLARE i INT DEFAULT 0;
    #set autocomnit = 0 把autocommit设置成0
    SET autocommit =0;
    REPEAT
    SET i=i+ 1;
    INSERT INTo emp(empno，ename , job ,mgr ,hiredate ,sal ,comm ,deptno ) values((SEAR+i) ,rand_string(6), &#39;sAESLsy&#39;,0001,now(),1000,0,10);
    UNTIL i = max_num;
    END REPEAT;
    COMMIT;
END 
$$
DFLIMITER ;

创建往dept表中插入数据的存储过程
DFLIMITER $$
CREATE PROCEDURE insert_dept(IN START INT(10),IN max_num lNT(10))
BEGIN
    DECLARE i lNT DEFAULT 0;
    SET autocommit = 0;
    REPEAT
    SETi= i+1;
    INSERT INTO dept (deptno ,dname,loc ) VALUES((START+i) ,rand_string(10),rand_string(8);
    UNTIL i = max_num;
    END REPEAT;COMMIT;
END $$
DFLIMITER ;
</code></pre>
<p>5.调用存储过程</p>
<pre><code class="sql">call insert_emp(10001,50000);
call inser_dept(100,10);
</code></pre>
<h2 id="Show-profile"><a href="#Show-profile" class="headerlink" title="Show profile"></a>Show profile</h2><p>是什么:是mysql提供可以用来分析当前会话中语句执行的资源消耗情况。可以用于SQL的调优的测量</p>
<p>官网: <span class="exturl" data-url="aHR0cDovL2Rldi5teXNxbC5jb20vZG9jL3JlZm1hbi81LjUvZW4vc2hvdy1wcm9maWxlLmh0bWw=">http://dev.mysql.com/doc/refman/5.5/en/show-profile.html</span></p>
<p>默认情况下，参数处于关闭状态，并保存最近15次的运行结果</p>
<p>分析步骤</p>
<p>1.是否支持，看看当前的mysql版本是否支持</p>
<pre><code class="sql">show variables like &#39;profiling&#39;;
-- 默认是关闭，使用前需要开启
</code></pre>
<p>2.开启功能，默认是关闭，使用前需要开启</p>
<pre><code class="sql">set profiling=on;
show variables like &#39;profiling&#39;;
</code></pre>
<p>3.运行SQL</p>
<pre><code class="sql">select * from emp;

select * from emp e join dept d on e.deptno =d.deptno;

select * from emp group by id%10 limit 1500;

select * from emp group by id%20 order by 5;
</code></pre>
<p>4.查看结果，show profiles;</p>
<pre><code class="sql">show profiles;
</code></pre>
<img data-src="/2022/10/07/DataBase/MySQL/MySQL_Super/image-20220819180736190.png" class="">



<p>5.诊断SQL， </p>
<pre><code class="sql">show profile cpu,block io for query 3;-- 最后数字是上一步前面的SQL的Id;
</code></pre>
<table>
<thead>
<tr>
<th align="center">常用参数</th>
<th>注释</th>
</tr>
</thead>
<tbody><tr>
<td align="center">ALL</td>
<td>显示所有的开销信息</td>
</tr>
<tr>
<td align="center">BLOCK IO</td>
<td>显示块IO相关开销</td>
</tr>
<tr>
<td align="center">CONTEXT SWITCHES</td>
<td>上下文切换相关开销</td>
</tr>
<tr>
<td align="center">CPU</td>
<td>显示CPU相关开销信息</td>
</tr>
<tr>
<td align="center">IPC</td>
<td>显示发送和接收相关开销信息</td>
</tr>
<tr>
<td align="center">MEMORY</td>
<td>显示内存相关开销信息</td>
</tr>
<tr>
<td align="center">PAGE FAULTS</td>
<td>显示页面错误相关开销信息|</td>
</tr>
<tr>
<td align="center">SOURCE</td>
<td>显示和Source_function，Source_file，Source_line相关的开销信息</td>
</tr>
<tr>
<td align="center">SWAPS</td>
<td>显示交换次数相关开销的信息</td>
</tr>
</tbody></table>
<img data-src="/2022/10/07/DataBase/MySQL/MySQL_Super/image-20220819182050124.png" class="">



<p>6.日常开发需要注意的结论</p>
<ul>
<li><p>converting HEAP to MyISAM     查询结果太大，内存都不够用了往磁盘上搬了。</p>
</li>
<li><p>Creating tmp table       创建临时表</p>
<ul>
<li>拷贝数据到临时表</li>
<li>用完再删除</li>
</ul>
</li>
<li><p>Copying to tmp table on disk      把内存中临时表复制到磁盘，危险!! !</p>
</li>
<li><p>locked    (死锁)</p>
</li>
</ul>
<h2 id="全局查询日志"><a href="#全局查询日志" class="headerlink" title="全局查询日志"></a>全局查询日志</h2><p><font color=red><strong>永远不要在生产环境开启这个功能</strong>。</font></p>
<p>配置启用</p>
<pre><code class="sh">#在mysql的my.cnf中，设置如下:
#开启
general_log=1
#记录日志文件的路径
general_log_file=/path/logfile
#输出格式
log_output=FILE
</code></pre>
<p>编码启用</p>
<pre><code class="sql">-- 命令
set global general_log=1;
set global log_output=&#39;TABLE&#39;;

-- 此后，你所编写的sql语句，将会记录到mysql库里的general_log表，可以用下面的命令查看
select * from mysql.general_lpg;
</code></pre>
<div name=MySQL的锁机制>

<h1 id="MySQL锁机制"><a href="#MySQL锁机制" class="headerlink" title="MySQL锁机制"></a>MySQL锁机制</h1><p>概述：锁是计算机协调多个进程或线程并发访问某一资源的机制。在数据库中，除传统的计算资源〈如CPU、RAM、V&#x2F;O等）的争用以外，数据也是一种供许多用户共享的资源。如何保证数据并发访问的一致性、有效性是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。从这个角度来说，锁对数据库而言显得尤其重要，也更加复杂。[</p>
<p>打个比方，我们到淘宝上买一件商品，商品只有一件库存，这个时候如果还有另一个人买，那么如何解决是你买到还是另一个人买到的问题?</p>
<img data-src="/2022/10/07/DataBase/MySQL/MySQL_Super/image-20220819183900802.png" class="">



<p>这里肯定要用到事务，我们先从库存表中取出物品数量，然后插入订单，付款后插入付款表信息，然后更新商品数量。在这个过程中，使用锁可以对有限的资源进行保护，解决隔离和并发的矛盾。</p>
<h2 id="锁的分类"><a href="#锁的分类" class="headerlink" title="锁的分类"></a>锁的分类</h2><ul>
<li><p>从对数据操作的粒度分</p>
<ul>
<li>表锁(偏读，解决幻读(一个事务中对数据添加、删除，并且多次查询，每次结果不都相同))</li>
<li>行锁(偏写，解决重复读(一个事务中对一条数据多次修改，并且多次查询，每次结果不都相同))</li>
</ul>
</li>
<li><p>从对数据操作的类型（读\写)分</p>
<ul>
<li>&#x3D;&#x3D;读锁(共享锁)&#x3D;&#x3D;：针对同一份数据，多个读操作可以同时进行而不会互相影响。</li>
<li>&#x3D;&#x3D;写锁(排它锁)&#x3D;&#x3D;：当前写操作没有完成前，它会阻断其他写锁和读锁。</li>
</ul>
</li>
</ul>
<h2 id="读锁-案例介绍"><a href="#读锁-案例介绍" class="headerlink" title="读锁(案例介绍)"></a>读锁(案例介绍)</h2><p>准备：</p>
<pre><code class="sql">create table mylock(
id int not null primary key auto_increment,
name varchar(20)
)engine myisam;

insert into mylock(name) values(&#39;a&#39;);
insert into mylock(name) values(&#39;b&#39;);
insert into mylock(name) values(&#39;c&#39;);
insert into mylock(name) values(&#39;d&#39;);
insert into mylock(name) values(&#39;e&#39;);
select * from mylock;

CREATE TABLE `book` ( 
    `bookid` int(10) unsigned NOT NULL AUTO_INCREMENT,
    `card` int(10) unsigned NOT NULL,
    PRIMARY KEY (`bookid`),
    KEY `idx_card` (`card`)
) ENGINE=InnoDB AUTO_INCREMENT=9 DEFAULT CHARSET=utf8;
insert into book(card) values(1);
insert into book(card) values(2);
insert into book(card) values(3);
insert into book(card) values(4);
insert into book(card) values(5);
</code></pre>
<pre><code class="sql">-- 手动添加表锁
-- 语法：lock table Table_1_Name  read/write,Table_2_name read/write,..;
lock table mylock read ;

-- 查看锁
show open tables;

-- 释放锁
unlock tables;
    
select * from mylock;	
-- 读锁没有释放之前这个回话只能读取这个读锁表，其他回话可以查询或者更新未锁定的表
-- 其他回话插入或者更新表的时候会进入阻塞状态，直至锁的释放
update mylock set name = &#39;aa&#39; where id =1;
select * from book;
</code></pre>
<h2 id="写锁-案例介绍"><a href="#写锁-案例介绍" class="headerlink" title="写锁(案例介绍)"></a>写锁(案例介绍)</h2><p>Session 1(产生锁)</p>
<pre><code class="sql">lock table mylock write;

select * from mylock; --ok

update mylock set name =&#39;aa&#39; where  id =1; -- ok

select * from book;
/*
ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &#39;uplock tables&#39; at line 1
*/

unlock tables; 
</code></pre>
<p>Session 2</p>
<pre><code class="sql"> select * from mylock; -- block 阻塞住了 ,直至锁的释放才看到了
</code></pre>
<h2 id="读写结论"><a href="#读写结论" class="headerlink" title="读写结论"></a>读写结论</h2><p>MyISAM在执行查询语句〈SELECT)前，会自动给涉及的所有表加读锁，在执行增删改操作前，会自动给涉及的表加写锁。</p>
<p>MySQL的表级锁有两种模式:</p>
<p>​	表共享读锁(Table Read Lock)</p>
<p>​	表独享读锁(Table Write Lock)</p>
<table>
<thead>
<tr>
<th align="center">lock_type</th>
<th align="center">是否共享</th>
<th align="center">读锁</th>
<th align="center">写锁</th>
</tr>
</thead>
<tbody><tr>
<td align="center">读锁</td>
<td align="center">是</td>
<td align="center">是</td>
<td align="center">否</td>
</tr>
<tr>
<td align="center">写锁</td>
<td align="center">是</td>
<td align="center">否</td>
<td align="center">否</td>
</tr>
</tbody></table>
<p>&#x3D;&#x3D;结论:&#x3D;&#x3D;</p>
<p>结合上表，所以对MyISAM表进行操作，会有以下情况:</p>
<p>1、对MyISAM表的读操作〈加读锁)，不会阻塞其他进程对同一表的读请求，但会阻塞对同一表的写请求。只有当读锁释放后，才会执行其它进程的写操作。</p>
<p>2、对MyISAM表的写操作（加写锁)，会阻塞其他进程对同一表的读和写操作，只有当写锁释放后，才会执行其它进程的读写操作。</p>
<p><font color=red><strong>简而言之，就是读锁会阻塞写，但是不会堵塞读。而写锁则会把读和写都堵塞</strong>。</font></p>
<h2 id="表锁-案例介绍"><a href="#表锁-案例介绍" class="headerlink" title="表锁(案例介绍)"></a>表锁(案例介绍)</h2><p>【如何分析表锁定】<br>可以通过检查table_locks_waited和table_locks_immedlate状态变量来分析系统上的表锁定:</p>
<pre><code class="sql">show status like &#39;table%&#39;;
</code></pre>
<img data-src="/2022/10/07/DataBase/MySQL/MySQL_Super/image-20220819205444832.png" class="">



<p>这里有两个状态变量记录MySQL内部表级锁定的情况，两个变量说明如下:</p>
<p><font color=blue>T<strong>able_locks_immediate:产生表级锁定的次数，表示可以立即获取锁的查询次数，每立即获取锁值加1</strong></font></p>
<p><font color=blue><strong>Table_locks_waited:出现表级锁定争用而发生等待的次数(不能立即获取锁的次数，每等待一次锁值加1),</strong><br><strong>此值高则说明存在着较严重的表级锁争用情况;</strong></font></p>
<p><font color=red><strong>此外，<u><em><strong>Myisam</strong></em></u>的读写锁调度是写优先，这也是<u><em><strong>myisam</strong></em></u>不适合做写为主表的引擎。因为写锁后，其他线程不能做任何操作，大量的更新会使查询很难得到锁，从而造成永远阻塞</strong></font></p>
<h2 id="行锁-案例介绍"><a href="#行锁-案例介绍" class="headerlink" title="行锁(案例介绍)"></a>行锁(案例介绍)</h2><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><blockquote>
<p>​	偏向InnoDB存储引擎，开销大，加锁慢;会出现死锁;锁定粒度最小，发生锁冲突的概率最低,并发度也最高。</p>
<p>​	InnoDB与MyISAM的最大不同有两点:</p>
<p>​	一、是支持事务（TRANSACTION);</p>
<p>​	二、是采用了行级锁</p>
</blockquote>
<h3 id="事务知识复习"><a href="#事务知识复习" class="headerlink" title="事务知识复习"></a>事务知识复习</h3><h4 id="四大特性"><a href="#四大特性" class="headerlink" title="四大特性"></a>四大特性</h4><p>事务是由一组SQL语句组成的逻辑处理单元，事务具有以下4个属性，通常简称为事务的ACID属性。</p>
<ul>
<li><font color=red>原子性（Atomicity)</font>﹔事务是一个原子操作单元，其对数据的修改，要么全都执行，要么全都不执行。</li>
<li><font color=red>一致性（Consistent)</font>:在事务开始和完成时，数据都必须保持一致状态。这意味着所有相关的数据规则都必须应用于事务的修改，以保持数据的完整性;事务结束时，所有的内部数据结构（如B树索引或双向链表）也都必须是正确的。</li>
<li><font color=red>隔离性（lsolation)</font>:数据库系统提供一定的隔离机制，保证事务在不受外部并发操作影响的“独立”环境执行。这意味着事务处理过程中的中间状态对外部是不可见的，反之亦然。</li>
<li><font color=red>持久性（Durable)</font>:事务完成之后，它对于数据的修改是永久性的，即使出现系统故障也能够保持。</li>
</ul>




<h4 id="并发带来的问题"><a href="#并发带来的问题" class="headerlink" title="并发带来的问题"></a>并发带来的问题</h4><p>更新丢失(Lost Update)</p>
<blockquote>
<p>当两个或多个事务选择同一行，然后基于最初选定的值更新该行时，由于每个事务都不知道其他事务的存在，就会发生丢失更新问题――最后的更新覆盖了由其他事务所做的更新。<br>例如，两个程序员修改同一java文件。每程序员独立地更改其副本，然后保存更改后的副本，这样就覆盖了原始文档。最后保存其更改副本的编辑人员覆盖前一个程序员所做的更改。<br>如果在一个程序员完成并提交事务之前，另一个程序员不能访问同一文件，则可避免此问题。</p>
</blockquote>
<p>脏读(Dirty Reads)</p>
<blockquote>
<p>简单来说就是 读了未提交的，此时事务级别在最低，改善方法就是提高级别即可</p>
</blockquote>
<p>不可重复读(Non-Repeatable Reads)</p>
<blockquote>
<p>简单来说就是在一个事务中多次读取某些数据，数据的条数没有变，但是数据却变了。</p>
<p>重在修改</p>
</blockquote>
<p>幻读(Phantom Reads)</p>
<blockquote>
<p>简单来说就是在一个事务中多次读取某些数据，数据的条数变了</p>
<p>重在添加、删除</p>
</blockquote>
<h4 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h4><img data-src="/2022/10/07/DataBase/MySQL/MySQL_Super/image-20220819211429410.png" class="">





<h4 id="面试题-1"><a href="#面试题-1" class="headerlink" title="面试题"></a>面试题</h4><p>不可重复读和幻读的区别？如何解决？</p>
<blockquote>
<p>​	他们都是在一个事务中对某些数据进行多次读取，但是不可重复读的问题重在多次读取的数据不都一致；幻读重在多次读取确得到不一样数据量的数据</p>
<p>解决办法：</p>
<p>​	重复读加行数</p>
<p>​	幻读加表锁</p>
</blockquote>
<h3 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h3><p>准备</p>
<pre><code class="sql">create table test_innodb_lock (
a int(11),
b varchar(16)
)engine=innodb;I

insert into test_innodb_lock values(1,&#39;b2&#39;);
insert into test_innodb_lock values(3,&#39;3&#39;);
insert into test_innodb_lock values(4,&#39;4000&#39;);
insert into test_innodb_lock values(5,&#39;5000&#39;);
insert into test_innodb_lock values(6,&#39;6000&#39;);
insert into test_innodb_lock values(7,&#39;7000&#39;);
insert into test_innodb_lock values(8,&#39;80O0&#39;);
insert into test_innodb_lock values(9,&#39;9000&#39;);
insert into test_innodb_lock values(10,&#39;b1&#39;);

create index test_innodb_a_ind  on test_innodb_lock(a);
create index test_innodb_b_ind  on test_innodb_lock(b);
-- 打开两个会话 并且都关闭自动提交
set autocommit=0;
</code></pre>
<h4 id="行锁演示"><a href="#行锁演示" class="headerlink" title="行锁演示"></a>行锁演示</h4><style>
    table td{
        text-align:center;
        border-bottom: 1px solid #000000;
        border-right: 1px solid #000000;
    }
    table tr:first-child td{
        text-align:center;
        border-top: 1px solid #000000;
    }
    table tr td:first-child{
        text-align:center;
        border-left: 1px solid #000000;
    }
</style>
<table  border="1px solid red;" >
    <tr >
        <th>Session 1</th>
        <th>Session 2</th>
        <th>explain  </th>
    </tr>
    <tr>
        <th style="text-align:center; " colspan='3'>case 1</th>
    </tr>
    <tr>
        <td>
            <img data-src= "img/image-20220819233537212.png"/><br/>
            <p style="text-align:center; ">
                关闭 Session 1 的自动提交
            </p><br/>
        </td>
        <td>
            <img data-src= "img/image-20220819230937872.png"/><br/>
            <p>
                关闭 Session 2 的自动提交
            </p>
        </td>
        <td>
             <p style="text-align:center; ">
                目的是:模拟高并发的情况下事务的处理情况，就好比一个SQL在修改但是没又被提交
            </p><br/>
            <p style="text-align:center; ">
                在Innodb引擎作用下默认行锁，可以自动锁住我们当行数据保证数据的准确性
            </p>
        </td>
    </tr>
    <tr>
      <th colspan="3" style="text-align:center;"  >case 2</th>
    </tr>
    <tr>
        <td>
            <img src = "img/image-20220819234521630.png"/><br/>
            <p style="text-align:center; ">
                Session 1 修改a=4的数据，不提交
            </p>
        </td>
        <td>
            <img src = "img/image-20220819233807979.png "/><br/>
            <p style="text-align:center; ">
                Session 2 无法查询到原有数据
            </p>
        </td>
        <td>
            <p>
            </p>
        </td>
    </tr>
    <tr>
      <th colspan="3"  style="text-align:center;" >case 3</th>
    </tr>
    <tr>
        <td>
            <img src = "img/image-20220819234824459.png"/><br/>
            <p style="text-align:center; ">
                Session 1 提交事务
            </p>
        </td>
        <td>
            <img src = "img/image-20220819234803742.png "/><br/>
            <p style="text-align:center; ">
                Session 2 提交事务()
            </p>
        </td>
        <td>
            <p style="text-align:center; ">>
                Session 2 这里也可以当做是清除之前数据库累计事务
            </p>
            <br/>
            <p style="text-align:center; ">
               如果不提交，我们的Session 2 还是原来的数据
            </p>
        </td>
    </tr>
    <tr>
      <th colspan="3" style="text-align:center;" >case 4</th>
    </tr>
    <tr>
        <td>
            <img src = "img/image-20220819235205871.png "/>
            <br/>
            <p style="text-align:center; ">
                Session 1 修改a=4的数据，不提交
            </p>
        </td>
        <td>
            <img src = " img/image-20220819235132716.png"/><br/>            
            <p style="text-align:center; ">
                Session 2 修改a=9的数据，不提交
            </p>
        </td>
        <td>
            <p style="text-align:center; ">
                两个 Session 操作不同的数据，互补影响，充分的体现了行锁的作用
            </p>
        </td>
    </tr>
    <tr>
      <th colspan="3" style="text-align:center;" >case 5</th>
    </tr>
    <tr>
        <td>
            <img src = "img/image-20220820093552303.png "/>
            <br/>
            <p style="text-align:center; ">
                Session 1 修改a=1的数据，不提交
            </p>
        </td>
        <td>
            <img src = " img/image-20220820093614653.png"/><br/>            
            <p style="text-align:center; ">
                Session 2 修改a=1的数据，不提交
            </p>
        </td>
        <td>
            <p style="text-align:center; ">
                两个 Session 操作相同的数据，互相影响
            </p><br/>
            <p style="text-align:center; ">
                Session2 在 Session1 没有提交之前，直接处于阻塞状态
            </p>
        </td>
    </tr>
    <tr>
      <th colspan="3" style="text-align:center;" >case 5</th>
    </tr>
    <tr>
        <td>
            <img src = "img/image-20220819235205871.png "/>
            <br/>
            <p style="text-align:center; ">
                Session 1 修改a=4的数据，不提交
            </p>
        </td>
        <td>
            <img src = " img/image-20220819235132716.png"/><br/>            
            <p style="text-align:center; ">
                Session 2 修改a=9的数据，不提交
            </p>
        </td>
        <td>
            <p style="text-align:center; ">
                两个 Session 操作不同的数据，互补影响，充分的体现了行锁的作用
            </p>
        </td>
    </tr>
    </table>





<h4 id="索引失效导致行锁变成表锁"><a href="#索引失效导致行锁变成表锁" class="headerlink" title="索引失效导致行锁变成表锁"></a>索引失效导致行锁变成表锁</h4><style>
    table td{
        text-align:center;
        border-bottom: 1px solid #000000;
        border-right: 1px solid #000000;
    }
    table tr:first-child td{
        text-align:center;
        border-top: 1px solid #000000;
    }
    table tr td:first-child{
        text-align:center;
        border-left: 1px solid #000000;
    }
</style>
<table  border="1px solid red;" >
    <tr >
        <th>Session 1</th>
        <th>Session 2</th>
        <th>explain  </th>
    </tr>
    <tr>
        <td>
            <img data-src= "img/image-20220820000724418.png"/><br/>
        </td>
        <td>
            <img data-src= "img/image-20220820000816926.png"/><br/>
        </td>
        <td>
            <p style="text-align:center; ">        
                我们在最开始准备阶段，就创建了关于a ,b 的索引(单索引)
            </p><br/>
            <p style="text-align:center; ">        
                我们之前说过，在where上不要进行隐式转换，这样会导致索引失效
            </p><br/>
            <p style="text-align:center; ">        
                从这个例子中我们左边进行了隐式操作，导致索引失效，第二个 Session
            </p><br/>
            <p style="text-align:center; ">        
                直接进入到了阻塞状态，<a font="color:'red'">表明了我们的索引失效让行锁变成了表锁</a>
            </p>
        </td>
    </tr>
    <tr>
        <td>
            <img src = "img/image-20220820000801075.png"/><br/>
        </td>
        <td>
            <img src = "img/image-20220820000837775.png"/><br/>
        </td>
        <td>
            <p style="text-align:center; ">        
               上面的例子中直至Session 1 回话结束，这时候释放了锁
            </p><br/>
            <p style="text-align:center; ">        
              我们的 Session 2 才接受到了锁，进入了表
            </p><br/>
            <p style="text-align:center; ">        
               这个例子充分的表明了，我们在操作中一定要注意索引失效的问题
            </p><br/>
            <p style="text-align:center; ">        
                他有可能会导致我们效率更低
            </p>
        </td>
    </tr>
</table>




<h4 id="间隙锁的危害"><a href="#间隙锁的危害" class="headerlink" title="间隙锁的危害"></a>间隙锁的危害</h4><p>【概念】</p>
<p>​	当我们用范围条件而不是相等条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据记录的索引项加锁;对于键值在条件范围内但并木存在的记录，叫做“间隙（GAP)”，</p>
<p>InnoDB也会对这个“间隙”加锁，这种锁机制就是所谓的间隙锁（Next-Key锁）。</p>
<p>【危害】<br>因为Query执行过程中通过过范围查找的话，他会锁定整个范围内所有的索引键值，即使这个键值并不存在间隙锁有一个比较致命的弱点，就是当锁定一个范围键值之后，即使某些不存在的键值也会被无辜的锁定，<br>而造成在锁定的时候无<br>法插入锁定键值范围内的任何数据。在某些场景下这可能会对性能造成很大的危害</p>
<pre><code class="sql">-- session 1
update t1 set b=&#39;12312&#39; where a&gt;1 and a&lt;8;

-- session 2
insert into t1 values(5,&#39;asda&#39;);
</code></pre>
<img data-src="/2022/10/07/DataBase/MySQL/MySQL_Super/image-20220820001444127.png" class="">



<p>明显的看到在Session 1执行结束之后，执行Session 2 即使他们操作的不是同一行也会因为间隙锁的缘故锁定这一行，即使不存在也是如此，直到commit之后 Session 2才反应</p>
<h4 id="如何锁定一行"><a href="#如何锁定一行" class="headerlink" title="如何锁定一行"></a>如何锁定一行</h4><pre><code class="sql">/*
select xoo.... for update锁定某一行后，其它的操作会械阻塞，直到锁定行的会话提交commit
*/
begin;
select * from test_innodb_lock where a = 8 for update;
commit;
</code></pre>
<h3 id="案例结论"><a href="#案例结论" class="headerlink" title="案例结论"></a>案例结论</h3><p>​	Innodb存储引擎由于实现了行级锁定，虽然在锁定机制的实现方面所带来的性能损耗可能比表级锁定会要更高一些，但是在整体并发处理能力方面要远远优于MyISAM的表级锁定的。当系统并发量较高的时候，Innodb的整体性能和MyIlSAM相比就会有比较明显的优势了。</p>
<p>​	但是，Innodb的行级锁定同样也有其脆弱的一面，当我们使用不当的时候，可能会让Innodb的整体性能表现不仅不能比MyISAM高，甚至可能会更差。(索引失效行锁变表锁)</p>
<h3 id="如何分析行锁定"><a href="#如何分析行锁定" class="headerlink" title="如何分析行锁定"></a>如何分析行锁定</h3><p>通过检查InnoDB_row_lock状态变量来分析系统上的行锁的争夺情况</p>
<pre><code class="sql">show status like &#39;innodb_row_lock%&#39;;
</code></pre>
<img data-src="/2022/10/07/DataBase/MySQL/MySQL_Super/image-20220820002244586.png" class="">



<p>对各个状态量的说明如下:</p>
<p>Innodb_row_lock_current_waits：当前正在等待锁定的数量;</p>
<p>Innodb_row_lock_time：队系统启动到现在锁定总时间长度;</p>
<p>Innodb_row_lock_time_avg：每次等待所花平均时间;</p>
<p>Innodb_row_lock_time_max：从系统启动到现在等待最常的一次所花的时间;</p>
<p>Innodb_row_lock_waits：系统启动后到现在总共等待的次数;</p>
<p>对于这5个状态变量，比较重要的主要是</p>
<p><font color=red>Innodb_row_lock_time_avg（等待平均时长）</font>，</p>
<p><font color=red>Innodb_row_lock_waits（等待总次数)</font> ，</p>
<p><font color=red>lnnodb_row_lock_time（等待总时长）这三项</font>。</p>
<p>尤其是当等踌次数很高，而且每次等待时长也不小的时候，我们就需要分析系统中为什么会有如此多的等待<br>然后根据分析结果着手指定优化计划。</p>
<h3 id="优化意见"><a href="#优化意见" class="headerlink" title="优化意见"></a>优化意见</h3><ol>
<li><p>尽可能让所有数据检索都通过索引来完成，避免无索引行锁升级为表锁。</p>
</li>
<li><p>合理设计索引，尽量缩小锁的范围</p>
</li>
<li><p>尽可能较少检索条件，避免间隙锁</p>
</li>
<li><p>尽量控制事务大小，减少锁定资源量和时间长度</p>
</li>
<li><p>尽可能低级别事务隔离</p>
</li>
</ol>
<h2 id="页锁-案例介绍"><a href="#页锁-案例介绍" class="headerlink" title="页锁(案例介绍)"></a>页锁(案例介绍)</h2><p>开销和加锁时间界于表锁和行锁之间;会出现死锁;锁定粒度界于表锁和行锁之间，并发度一般。</p>
<h1 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h1><p>在总结MySQL的分库分表时候再将，Mycat章节(也有可能是Shardingsphere)</p>
<h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><h2>
    <div name=select_type>
        <a style="color:red; " >Select_Type</a>
    </div>
</h2>

<table>
<thead>
<tr>
<th align="center">select_type价值</th>
<th align="center">JSON名称</th>
<th align="center">意义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">SIMPLE</td>
<td align="center">没有</td>
<td align="center">简单选择（不使用UNION或子查询）</td>
</tr>
<tr>
<td align="center">PRIMARY</td>
<td align="center">没有</td>
<td align="center">多层子查询中最外层选择</td>
</tr>
<tr>
<td align="center">UNION</td>
<td align="center">没有</td>
<td align="center">联盟中的第二个或稍后的SELECT语句<br/>若第二个SELECT出现在UNION之后，则被标记为UNION;<br/>若UNION包含在FROM子句的子查询中,外层SELECT将被标记为:DERIVED</td>
</tr>
<tr>
<td align="center">DEPENDENT UNION</td>
<td align="center">dependent(true)</td>
<td align="center">UNION中的第二个或更高版本的SELECT语句，依赖于外部查询</td>
</tr>
<tr>
<td align="center">UNION RESULT</td>
<td align="center">union_result</td>
<td align="center">从UNION表获取结果的SELECT</td>
</tr>
<tr>
<td align="center">SUBQUERY</td>
<td align="center">没有</td>
<td align="center">子查询中的第一个SELECT<br/>在SELECT 或 WHERE列表中包含了子查询</td>
</tr>
<tr>
<td align="center">DEPENDENT SUBQUERY</td>
<td align="center">dependent(true)</td>
<td align="center">子查询中的第一个SELECT,依赖于外部查询</td>
</tr>
<tr>
<td align="center">DERIVED</td>
<td align="center">没有</td>
<td align="center">派生表<br/>在FROM列表中包含的子查询被标记为DERIVED(衍生)MySQL会递归执行这些子查询，把结果放在临时表里。</td>
</tr>
<tr>
<td align="center">MATERIALIZED</td>
<td align="center">material!zed_from_subquery</td>
<td align="center">实例化子查询</td>
</tr>
<tr>
<td align="center">UNCACHEABLE SU3QUERY</td>
<td align="center">cacheable(false)</td>
<td align="center">无法缓存其结果并且必须为外部查询的每一行重新计算其结果的子查询</td>
</tr>
<tr>
<td align="center">UNCACHEABLE UNION</td>
<td align="center">cacheable(false)</td>
<td align="center">在属于不可缓存子查询的UNION中的第二个或更高版本选择（请参见UNCACHEABLE SUBQUERY）</td>
</tr>
</tbody></table>
<pre><code class="sql">--sample:简单的查询，不包含子查询和union
explain select * from emp;

--primary:查询中若包含任何复杂的子查询，最外层查询则被标记为Primary
explain select staname,ename supname from (select ename staname,mgr from emp) t join emp on t.mgr=emp.empno ;

--union:若第二个select出现在union之后，则被标记为union
explain select * from emp where deptno = 10 union select * from emp where sal &gt;2000;

--dependent union:跟union类似，此处的depentent表示union或union all联合而成的结果会受外部表影响
explain select * from emp e where e.empno  in ( select empno from emp where deptno = 10 union select empno from emp where sal &gt;2000)

--union result:从union表获取结果的select
explain select * from emp where deptno = 10 union select * from emp where sal &gt;2000;

--subquery:在select或者where列表中包含子查询
explain select * from emp where sal &gt; (select avg(sal) from emp) ;

--dependent subquery:subquery的子查询要受到外部表查询的影响
explain select * from emp e where e.deptno in (select distinct deptno from dept);

--DERIVED: from子句中出现的子查询，也叫做派生类，
explain select staname,ename supname from (select ename staname,mgr from emp) t join emp on t.mgr=emp.empno ;

--UNCACHEABLE SUBQUERY：表示使用子查询的结果不能被缓存
 explain select * from emp where empno = (select empno from emp where deptno=@@sort_buffer_size);
 
--uncacheable union:表示union的查询结果不能被缓存：sql语句未验证
</code></pre>
<h2>
    <div name=extra_example >
        <p style="color:red; font-size:25px; " >
            type_example
        </p>
    </div> 
</h2>

<pre><code class="sql">--all:全表扫描，一般情况下出现这样的sql语句而且数据量比较大的话那么就需要进行优化。
explain select * from emp;

--index：全索引扫描这个比all的效率要好，主要有两种情况，一种是当前的查询时覆盖索引，即我们需要的数据在索引中就可以索取，或者是使用了索引进行排序，这样就避免数据的重排序
explain  select empno from emp;

--range：表示利用索引查询的时候限制了范围，在指定范围内进行查询，这样避免了index的全索引扫描，适用的操作符： =, &lt;&gt;, &gt;, &gt;=, &lt;, &lt;=, IS NULL, BETWEEN, LIKE, or IN() 
explain select * from emp where empno between 7000 and 7500;

--index_subquery：利用索引来关联子查询，不再扫描全表
explain select * from emp where emp.job in (select job from t_job);

--unique_subquery:该连接类型类似与index_subquery,使用的是唯一索引
 explain select * from emp e where e.deptno in (select distinct deptno from dept);
 
--index_merge：在查询过程中需要多个索引组合使用，没有模拟出来

--ref_or_null：对于某个字段即需要关联条件，也需要null值的情况下，查询优化器会选择这种访问方式
explain select * from emp e where  e.mgr is null or e.mgr=7369;

--ref：使用了非唯一性索引进行数据的查找
 create index idx_3 on emp(deptno);
 explain select * from emp e,dept d where e.deptno =d.deptno;

--eq_ref ：使用唯一性索引进行数据查找
explain select * from emp,emp2 where emp.empno = emp2.empno;

--const：这个表至多有一个匹配行，
explain select * from emp where empno = 7369;
 
--system：表只有一行记录（等于系统表），这是const类型的特例，平时不会出现
</code></pre>
<h2>
    <div name=extra_example >
        <p style="color:red; font-size:25px; " >extra_example</p>
    </div> 
</h2>

<pre><code class="sql">--using filesort:说明mysql无法利用索引进行排序，只能利用排序算法进行排序，会消耗额外的位置
explain select * from emp order by sal;

--using temporary:建立临时表来保存中间结果，查询完成之后把临时表删除
explain select ename,count(*) from emp where deptno = 10 group by ename;

--using index:这个表示当前的查询时覆盖索引的，直接从索引中读取数据，而不用访问数据表。如果同时出现using where 表名索引被用来执行索引键值的查找，如果没有，表面索引被用来读取数据，而不是真的查找
explain select deptno,count(*) from emp group by deptno limit 10;

--using where:使用where进行条件过滤
explain select * from t_user where id = 1;

--using join buffer:使用连接缓存，情况没有模拟出来

--impossible where：where语句的结果总是false
explain select * from emp where empno = 7469;
</code></pre>
]]></content>
      <categories>
        <category>MySQL</category>
        <category>MySQL高级部分</category>
      </categories>
  </entry>
  <entry>
    <title>Redis基础</title>
    <url>/2022/10/07/DataBase/Redis/Redis/</url>
    <content><![CDATA[<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h2 id="一-Redis简介"><a href="#一-Redis简介" class="headerlink" title="一.Redis简介"></a>一.Redis简介</h2><h3 id="1-NoSQL简介"><a href="#1-NoSQL简介" class="headerlink" title="1.NoSQL简介"></a>1.NoSQL简介</h3><p>​	目前市场主流数据存储都是使用关系型数据库。每次操作关系型数据库时都是I&#x2F;O操作，I&#x2F;O操作是主要影响程序执行性能原因之一，连接数据库关闭数据库都是消耗性能的过程。尽量减少对数据库的操作，能够明显的提升程序运行效率。</p>
<p>​	针对上面的问题，市场上就出现了各种NoSQL(Not Only SQL,不仅仅可以使用关系型数据库)数据库，它们的宣传口号：不是什么样的场景都必须使用关系型数据库，一些特定的场景使用NoSQL数据库更好。</p>
<p>常见NoSQL数据库：</p>
<p>​	memcached ：键值对，内存型数据库，所有数据都在内存中。</p>
<p>​	Redis:和Memcached类似，还具备持久化能力。</p>
<p>​	HBase：以列作为存储。</p>
<p>​	MongoDB：以Document做存储。</p>
<h3 id="2-Redis简介"><a href="#2-Redis简介" class="headerlink" title="2.Redis简介"></a>2.<strong>Redis简介</strong></h3><p>​	Redis是以Key-Value形式进行存储的NoSQL数据库。</p>
<p>​	Redis是使用C语言进行编写的。</p>
<p>​	平时操作的数据都在内存中，效率特高，读的效率110000&#x2F;s，写81000&#x2F;s，所以多把Redis当做缓存工具使用。</p>
<p>​	Redis以solt（槽）作为数据存储单元，每个槽中可以存储N多个键值对。Redis中固定具有16384。理论上可以实现一个槽是一个Redis。每个向Redis存储数据的key都会进行crc16算法得出一个值后对16384取余就是这个key存放的solt位置。</p>
<p>​	同时通过Redis Sentinel提供高可用，通过Redis Cluster提供自动分区。</p>
<h2 id="二-Redis单机版安装"><a href="#二-Redis单机版安装" class="headerlink" title="二. Redis单机版安装"></a>二. Redis单机版安装</h2><p>​	1.安装依赖C语言依赖</p>
<p>​	redis使用C语言编写，所以需要安装C语言库</p>
<pre><code class="shell">
yum install -y gcc-c++ automake autoconf libtool make tcl 
</code></pre>
<p>​	2.上传并解压</p>
<p>​	把redis-5.0.5.tar.gz上传到&#x2F;usr&#x2F;local&#x2F;tmp中</p>
<p>​	解压文件</p>
<pre><code># cd /usr/local/tmp

# tar zxf redis-5.0.5.tar.gz
</code></pre>
<p>​	3.编译并安装</p>
<p>​	进入解压文件夹</p>
<pre><code>
# cd /usr/local/tmp/redis-5.0.5/
</code></pre>
<p>​	编译</p>
<pre><code>
# make
</code></pre>
<p>​	安装	</p>
<pre><code>
# make install PREFIX=/usr/local/redis
</code></pre>
<p>​	4.开启守护进程</p>
<p>​	复制cd &#x2F;usr&#x2F;local&#x2F;tmp&#x2F;redis-5.0.5&#x2F;中redis.conf配置文件	</p>
<pre><code>
# cp redis.conf /usr/local/redis/bin/
</code></pre>
<p>​	修改配置文件	</p>
<pre><code># cd /usr/local/redis/bin/

# vim redis.conf
</code></pre>
<p>​	把daemonize的值由no修改为yes</p>
<img data-src="/2022/10/07/DataBase/Redis/Redis/Redis-01.jpg" class="">


<p>​	5.修改外部访问</p>
<p>​	在redis5中需要修改配置文件redis.conf允许外部访问。需要修改两处。</p>
<p>​	注释掉下面</p>
<p>​	bind 127.0.0.1</p>
<pre><code>#bind 127.0.0.1
</code></pre>
<p>​	protected-mode yes 改成 no</p>
<img data-src="/2022/10/07/DataBase/Redis/Redis/Redis-02.jpg" class="">


<p>​	6.启动并测试</p>
<p>​	启动redis</p>
<pre><code class="shell">
./redis-server redis.conf
</code></pre>
<p>​	重启redis</p>
<pre><code>./redis-cli shutdown

./redis-server redis.conf
</code></pre>
<p>​	启动客户端工具</p>
<p>​	在redis5中客户端工具对命令会有提供功能。</p>
<pre><code class="shell">./redis-cli 
</code></pre>
<h2 id="二-、docker安装Redis"><a href="#二-、docker安装Redis" class="headerlink" title="二.、docker安装Redis"></a>二.、docker安装Redis</h2><p>1、拉取镜像文件</p>
<pre><code class="shell">
docker pull redis[:(版本号)]
</code></pre>
<p>2、去gitee库中下载redis配置文件（docker不自带配置文件）【也可不进行此步骤】</p>
<p><strong>建议看完，先别操作，再看三，看完三之后再决定如何操作</strong></p>
<p>然后按照文章内容进行，忽略下载。</p>
<p>文章地址： <span class="exturl" data-url="aHR0cHM6Ly93d3cuamI1MS5uZXQvYXJ0aWNsZS8yMDMyNzQuaHRt">https://www.jb51.net/article/203274.htm</span> </p>
<p>、</p>













<p>3、创建一个redis 服务容器 </p>
<p><strong>第二步进行了的</strong></p>
<pre><code class="shell">
docker run -p 6379:6379 --name myredis -v /usr/local/docker/redis.conf:/etc/redis/redis.conf -v /usr/local/docker/data:/data -d redis redis-server /etc/redis/redis.conf --appendonly yes


</code></pre>
<p><strong>第二步没有进行的</strong></p>
<pre><code class="shell">
docker run -p 6379:6379 --name myredis -v /root/myredis/data:/data -v /root/myredis/conf/redis.conf:/usr/local/etc/redis/redis.conf -d redis redis-server /usr/local/etc/redis/redis.conf --appendonly yes


</code></pre>
<p><strong>区别：</strong></p>
<p>​	其实也没有什么区别，只是映射的文件不同，也可以将第二步的文件直接创建到第二种创建服务容器的配置文件地址中去，这样也可使用第二个创建方式。</p>






























<h2 id="三-Redis常用的五大类型"><a href="#三-Redis常用的五大类型" class="headerlink" title="三.Redis常用的五大类型"></a>三.Redis常用的五大类型</h2><p>​	 Redis不仅仅支持简单的k&#x2F;v类型的数据，同时还提供list，set，zset，hash等数据结构的存储，它还支持数据的备份，即master-slave模式的数据备份，同样Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用。</p>
<p>​        Redis支持的五大数据类型包括String（字符串  用法： 键  值），Hash（哈希 类似Java中的 map  用法： 键  键值对），List（列表  用法：键 集合 不可以重复），Set（集合 用法：键 集合 可以重复），Zset（sorted set 有序集合    用法： 键  值 值）</p>
<h3 id="String（字符串）"><a href="#String（字符串）" class="headerlink" title="String（字符串）"></a>String（字符串）</h3><p>​	string 是 redis 最基本的类型，你可以理解成与 Memcached 一模一样的类型，一个 key 对应一个 value。string 类型是二进制安全的。意思是 redis 的 string 可以包含任何数据。比如jpg图片或者序列化的对象。string 类型是 Redis 最基本的数据类型，string 类型的值最大能存储 512MB。</p>
<p>应用场景：  </p>
<p>​	String是最常用的一种数据类型，普通的key&#x2F;value存储都可以归为此类，value其实不仅是String，  </p>
<p>也可以是数字：比如想知道什么时候封锁一个IP地址(访问超过几次)。</p>
<h3 id="Hash（哈希）"><a href="#Hash（哈希）" class="headerlink" title="Hash（哈希）"></a>Hash（哈希）</h3><p>​	Redis hash 是一个键值(key&#x3D;&gt;value)对集合。</p>
<p>​	Redis hash 是一个 string 类型的 field 和 value 的映射表，hash 特别适合用于存储对象。</p>
<p>​	使用场景：存储、读取、修改用户属性</p>
<p>​	我们简单举个实例来描述下Hash的应用场景，比如我们要存储一个用户信息对象数据，包含以下信息：    用户ID，为查找的key，  </p>
<p>​    	存储的value用户对象包含姓名name，年龄age，生日birthday 等信息，  如果用普通的key&#x2F;value结构来存储，主要有以下2种存储方式：  </p>
<p>​    	第一种方式将用户ID作为查找key,把其他信息封装成一个对象以序列化的方式存储，  </p>
<p>​           如：set u001 “李三,18,20010101”  </p>
<p>​     	这种方式的缺点是，增加了序列化&#x2F;反序列化的开销，并且在需要修改其中一项信息时，需要把整个对象取回，并且修改操作需要对并发进行保护，引入CAS等复杂问题。  </p>
<p>​     	第二种方法是这个用户信息对象有多少成员就存成多少个key-value对儿，用用户ID+对应属性的名称作为唯一标识来取得对应属性的值，  </p>
<p>​       	如：mset user:001:name “李三 “user:001:age18 user:001:birthday “20010101”  虽然省去了序列化开销和并发问题，但是用户ID为重复存储，如果存在大量这样的数据，内存浪费还是非常可观的。  </p>
<p>​    	那么Redis提供的Hash很好的解决了这个问题。</p>
<h3 id="List（列表）"><a href="#List（列表）" class="headerlink" title="List（列表）"></a>List（列表）</h3><p>​	Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）。</p>
<p>应用场景：  </p>
<pre><code>    Redis list的应用场景非常多，也是Redis最重要的数据结构之一。  
</code></pre>
<p>​    	我们可以轻松地实现最新消息排行等功能。  </p>
<pre><code>   Lists的另一个应用就是消息队列，可以利用Lists的PUSH操作，将任务存在Lists中，然后工作线程再用POP操作将任务取出进行执行。  
</code></pre>
<h3 id="Set（集合）"><a href="#Set（集合）" class="headerlink" title="Set（集合）"></a>Set（集合）</h3><p>​	Redis的Set是string类型的无序集合。</p>
<p>​	使用场景：1.共同好友、二度好友 </p>
<p>​			   2. 利用唯一性，可以统计访问网站的所有独立 IP </p>
<pre><code>  Redis set对外提供的功能与list类似是一个列表的功能，特殊之处在于set是可以自动排重的，当你需要存储一个列表数据，又不希望出现重复数据时，set是一个很好的选择，并且set提供了判断某个成员是否在一个set集合内的重要接口，这个也是list所不能提供的。  


 

  比如在微博应用中，每个人的好友存在一个集合（set）中，这样求两个人的共同好友的操作，可能就只需要用求交集命令即可。  
</code></pre>
<p>​    	Redis还为集合提供了求交集、并集、差集等操作，可以非常方便的实  </p>
<pre><code>  实现方式：  
</code></pre>
<p>​    	set 的内部实现是一个 value永远为null的HashMap，实际就是通过计算hash的方式来快速排重的，这也是set能提供判断一个成员是否在集合内的原因。 </p>
<h3 id="zset-sorted-set：有序集合"><a href="#zset-sorted-set：有序集合" class="headerlink" title="zset(sorted set：有序集合)"></a>zset(sorted set：有序集合)</h3><pre><code> Redis zset 和 set 一样也是string类型元素的集合,且不允许重复的成员。不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。zset的成员是唯一的,但分数(score)却可以重复。
</code></pre>
<p>使用场景：1.带有权重的元素，比如一个游戏的用户得分排行榜 </p>
<p>​		   2.比较复杂的数据结构，一般用到的场景不算太多</p>
<h2 id="四-Redis常用命令"><a href="#四-Redis常用命令" class="headerlink" title="四. Redis常用命令"></a>四. Redis常用命令</h2><p>Redis命令相关手册有很多，下面为其中比较好用的两个</p>
<p>  1.<span class="exturl" data-url="aHR0cHM6Ly93d3cucmVkaXMubmV0LmNuL29yZGVyLw==">https://www.redis.net.cn/order/</span></p>
<p>  2.<span class="exturl" data-url="aHR0cDovL2RvYy5yZWRpc2ZhbnMuY29tL3RleHQtaW4=">http://doc.redisfans.com/text-in</span></p>
<h3 id="1-Key操作"><a href="#1-Key操作" class="headerlink" title="1. Key操作"></a>1. Key操作</h3><h4 id="1-1-exists"><a href="#1-1-exists" class="headerlink" title="1.1  exists"></a>1.1  exists</h4><p>​	判断key是否存在。</p>
<p>​	语法：exists key名称</p>
<p>​	返回值：存在返回数字，不存在返回0</p>
<h4 id="1-2-expire"><a href="#1-2-expire" class="headerlink" title="1.2 expire"></a>1.2 expire</h4><p>​	设置key的过期时间，单位秒</p>
<p>​	语法：expire key 秒数</p>
<p>​	返回值：成功返回1，失败返回0</p>
<h4 id="1-3-ttl"><a href="#1-3-ttl" class="headerlink" title="1.3 ttl"></a>1.3 ttl</h4><p>​	查看key的剩余过期时间</p>
<p>​	语法：ttl key</p>
<p>​	返回值：返回剩余时间，如果不过期返回-1</p>
<h4 id="1-4-del"><a href="#1-4-del" class="headerlink" title="1.4 del"></a>1.4 del</h4><p>​	根据key删除键值对。</p>
<p>​	语法：del key</p>
<p>​	返回值：被删除key的数量</p>
<h3 id="2-字符串值-String"><a href="#2-字符串值-String" class="headerlink" title="2. 字符串值(String)"></a>2. <strong>字符串值(String)</strong></h3><h4 id="2-1-set"><a href="#2-1-set" class="headerlink" title="2.1 set"></a>2.1 <strong>set</strong></h4><p>​	设置指定key的值</p>
<p>​	语法：set key value</p>
<p>​	返回值：成功OK</p>
<h4 id="2-2-get"><a href="#2-2-get" class="headerlink" title="2.2 get"></a>2.2 <strong>get</strong></h4><p>​	获取指定key的值</p>
<p>​	语法：get key</p>
<p>​	返回值：key的值。不存在返回nil</p>
<h4 id="2-3-setnx"><a href="#2-3-setnx" class="headerlink" title="2.3 setnx"></a>2.3 <strong>setnx</strong></h4><p>​	当且仅当key不存在时才新增。</p>
<p>​	语法：setnx key value</p>
<p>​	返回值：不存在时返回1，存在返回0</p>
<h4 id="2-4-setex"><a href="#2-4-setex" class="headerlink" title="2.4 setex"></a>2.4 <strong>setex</strong></h4><p>​	设置key的存活时间，无论是否存在指定key都能新增，如果存在key覆盖旧值。同时必须指定过期时间。</p>
<p>​	语法：setex key seconds value</p>
<p>​	返回值：OK</p>
<h3 id="3-哈希表-Hash"><a href="#3-哈希表-Hash" class="headerlink" title="3.哈希表(Hash)"></a>3.<strong>哈希表(Hash)</strong></h3><p>​	Hash类型的值中包含多组field value。</p>
<img data-src="/2022/10/07/DataBase/Redis/Redis/Redis-03.jpg" class="">




<h4 id="3-1-hset"><a href="#3-1-hset" class="headerlink" title="3.1 hset"></a>3.1 <strong>hset</strong></h4><p>​	给key中field设置值。</p>
<p>​	语法：hset key field value</p>
<p>​	返回值：成功1，失败0</p>
<h4 id="3-2-hget"><a href="#3-2-hget" class="headerlink" title="3.2 hget"></a>3.2 <strong>hget</strong></h4><p>​	获取key中某个field的值</p>
<p>​	语法：hget key field </p>
<p>​	返回值：返回field的内容</p>
<h4 id="3-3-hmset"><a href="#3-3-hmset" class="headerlink" title="3.3 hmset"></a>3.3 <strong>hmset</strong></h4><p>​	给key中多个filed设置值</p>
<p>​	语法：hmset key field value field value</p>
<p>​	返回值：成功OK</p>
<h4 id="3-4-hmget"><a href="#3-4-hmget" class="headerlink" title="3.4 hmget"></a>3.4 <strong>hmget</strong></h4><p>​	一次获取key中多个field的值</p>
<p>​	语法：hmget key field field</p>
<p>​	返回值：value列表</p>
<h4 id="3-5-hvals"><a href="#3-5-hvals" class="headerlink" title="3.5 hvals"></a>3.5 <strong>hvals</strong></h4><p>​	获取key中所有field的值</p>
<p>​	语法：hvals key</p>
<p>​	返回值：value列表</p>
<h4 id="3-6-hgetall"><a href="#3-6-hgetall" class="headerlink" title="3.6 hgetall"></a>3.6 <strong>hgetall</strong></h4><p>​	获取所有field和value</p>
<p>​	语法：hgetall key</p>
<p>​	返回值：field和value交替显示列表</p>
<h4 id="3-7-hdel"><a href="#3-7-hdel" class="headerlink" title="3.7 hdel"></a>3.7 <strong>hdel</strong></h4><p>​	删除key中任意个field</p>
<p>​	语法：hdel key field field</p>
<p>​	返回值：成功删除field的数量</p>
<h3 id="4-列表（List）"><a href="#4-列表（List）" class="headerlink" title="4. 列表（List）"></a>4. <strong>列表（List）</strong></h3><h4 id="4-1-Rpush"><a href="#4-1-Rpush" class="headerlink" title="4.1 Rpush"></a>4.1 <strong>Rpush</strong></h4><p>​	向列表末尾中插入一个或多个值</p>
<p>​	语法；rpush key value value</p>
<p>​	返回值：列表长度</p>
<h4 id="4-2-lrange"><a href="#4-2-lrange" class="headerlink" title="4.2 lrange"></a>4.2 <strong>lrange</strong></h4><p>​	返回列表中指定区间内的值。可以使用-1代表列表末尾</p>
<p>​	语法：lrange list 0 -1</p>
<p>​	返回值：查询到的值</p>
<h4 id="4-3-lpush"><a href="#4-3-lpush" class="headerlink" title="4.3 lpush"></a>4.3 <strong>lpush</strong></h4><p>​	将一个或多个值插入到列表前面</p>
<p>​	语法：lpush key value value</p>
<p>​	返回值：列表长度</p>
<h4 id="4-4-llen"><a href="#4-4-llen" class="headerlink" title="4.4 llen"></a>4.4 <strong>llen</strong></h4><p>​	获取列表长度</p>
<p>​	语法：llen key</p>
<p>​	返回值：列表长度</p>
<h4 id="4-5-lrem"><a href="#4-5-lrem" class="headerlink" title="4.5 lrem"></a>4.5 <strong>lrem</strong></h4><p>​	删除列表中元素。count为正数表示从左往右删除的数量。负数从右往左删除的数量。</p>
<p>​	语法：lrem key count value</p>
<p>​	返回值：删除数量。</p>
<h3 id="5-集合-Set"><a href="#5-集合-Set" class="headerlink" title="5 集合(Set)"></a>5 <strong>集合(Set)</strong></h3><p>​	set和java中集合一样。</p>
<h4 id="5-1-sadd"><a href="#5-1-sadd" class="headerlink" title="5.1 sadd"></a>5.1 <strong>sadd</strong></h4><p>​	向集合中添加内容。不允许重复。</p>
<p>​	语法：sadd key value value value</p>
<p>​	返回值：集合长度</p>
<h4 id="5-2-scard"><a href="#5-2-scard" class="headerlink" title="5.2 scard"></a>5.2 <strong>scard</strong></h4><p>​	返回集合元素数量</p>
<p>​	语法：scard key</p>
<p>​	返回值：集合长度</p>
<h4 id="5-3-smembers"><a href="#5-3-smembers" class="headerlink" title="5.3 **smembers **"></a>5.3 **smembers **</h4><p>​	查看集合中元素内容</p>
<p>​	语法：smembers key</p>
<p>​	返回值：集合中元素</p>
<h3 id="6-有序集合（Sorted-Set）"><a href="#6-有序集合（Sorted-Set）" class="headerlink" title="6 .有序集合（Sorted Set）"></a>6 .<strong>有序集合（Sorted Set）</strong></h3><p>​	有序集合中每个value都有一个分数（score），根据分数进行排序。</p>
<h4 id="6-1-zadd"><a href="#6-1-zadd" class="headerlink" title="6.1 zadd"></a>6.1 <strong>zadd</strong></h4><p>​	向有序集合中添加数据</p>
<p>​	语法：zadd key score value score value</p>
<p>​	返回值：长度</p>









<h4 id="6-2-zrange"><a href="#6-2-zrange" class="headerlink" title="6.2 zrange"></a>6.2 <strong>zrange</strong></h4><p>​	返回区间内容想·，withscores表示带有分数</p>
<p>​	语法：zrange key 区间 [withscores]</p>
<p>​	返回值：值列表</p>


















<h2 id="五、-Redis持久化策略"><a href="#五、-Redis持久化策略" class="headerlink" title="五、 Redis持久化策略"></a>五、 <strong>Redis持久化策略</strong></h2><p>​	Redis不仅仅是一个内存型数据库，还具备持久化能力。</p>
<h3 id="1-RDB"><a href="#1-RDB" class="headerlink" title="1. RDB"></a>1. <strong>RDB</strong></h3><p>​	rdb模式是默认模式，可以在指定的时间间隔内生成数据快照（snapshot），默认保存到dump.rdb文件中。当redis重启后会自动加载dump.rdb文件中内容到内存中。</p>
<p>​	用户可以使用SAVE（同步）或BGSAVE（异步）手动保存数据。</p>
<p>​	可以设置服务器配置的save选项，让服务器每隔一段时间自动执行一次BGSAVE命令，可以通过save选项设置多个保存条件，但只要其中任意一个条件被满足，服务器就会执行BGSAVE命令。</p>
<p>　　	例如：</p>
<p>　　	save 900 1</p>
<p>　　	save 300 10</p>
<p>　　	save 60 10000</p>
<p>　　那么只要满足以下三个条件中的任意一个，BGSAVE命令就会被执行</p>
<p>　　服务器在900秒之内，对数据库进行了至少1次修改</p>
<p>　　服务器在300秒之内，对数据库进行了至少10次修改</p>
<p>　　服务器在60秒之内，对数据库进行了至少10000次修改</p>
<h4 id="1-1-优点"><a href="#1-1-优点" class="headerlink" title="1.1 优点"></a>1.1 <strong>优点</strong></h4><p>​	rdb文件是一个紧凑文件，直接使用rdb文件就可以还原数据。</p>
<p>​	数据保存会由一个子进程进行保存，不影响父进程。</p>
<p>​	恢复数据的效率要高于aof</p>
<h4 id="1-2-缺点"><a href="#1-2-缺点" class="headerlink" title="1.2 缺点"></a>1.2 <strong>缺点</strong></h4><p>​	每次保存点之间导致redis不可意料的关闭，可能会丢失数据。</p>
<p>​	由于每次保存数据都需要fork()子进程，在数据量比较大时可能会比较耗费性能。</p>
<h3 id="2-AOF"><a href="#2-AOF" class="headerlink" title="2 AOF"></a>2 <strong>AOF</strong></h3><p>​	AOF默认是关闭的，需要在配置文件中开启AOF。Redis支持AOF和RDB同时生效，如果同时存在，AOF优先级高于RDB（Redis重新启动时会使用AOF进行数据恢复）</p>
<p>​	监听执行的命令，如果发现执行了修改数据的操作，同时直接同步到数据库文件中。</p>
<h4 id="2-1-优点"><a href="#2-1-优点" class="headerlink" title="2.1 优点"></a>2.1 <strong>优点</strong></h4><p>​	相对RDB数据更加安全。</p>
<h4 id="2-2-缺点"><a href="#2-2-缺点" class="headerlink" title="2.2 缺点"></a>2.2 <strong>缺点</strong></h4><p>​	相同数据集AOF要大于RDB。</p>
<p>​	相对RDB可能会慢一些。</p>
<h4 id="2-3-开启办法"><a href="#2-3-开启办法" class="headerlink" title="2.3 开启办法"></a>2.3 <strong>开启办法</strong></h4><p>​	修改redis.conf中</p>
<pre><code>
# 默认no

appendonly yes

# aof文件名

appendfilename &quot;appendonly.aof&quot;
</code></pre>
<h2 id="六-Redis主从复制"><a href="#六-Redis主从复制" class="headerlink" title="六. Redis主从复制"></a>六. <strong>Redis主从复制</strong></h2><p>​	Redis支持集群功能。为了保证单一节点可用性，redis支持主从复制功能。每个节点有N个复制品（replica），其中一个复制品是主（master），另外N-1个复制品是从（Slave），也就是说Redis支持一主多从。</p>
<p>​	一个主可有多个从，而一个从又可以看成主，它还可以有多个从。</p>
<img data-src="/2022/10/07/DataBase/Redis/Redis/Redis-04.jpg" class="">




<h3 id="1-主从优点"><a href="#1-主从优点" class="headerlink" title="1. 主从优点"></a>1. <strong>主从优点</strong></h3><p>​	增加单一节点的健壮性，从而提升整个集群的稳定性。（Redis中当超过1&#x2F;2节点不可用时，整个集群不可用）</p>
<p>​	从节点可以对主节点数据备份，提升容灾能力。</p>
<p>​	读写分离。在redis主从中，主节点一般用作写（具备读的能力），从节点只能读，利用这个特性实现读写分离，写用主，读用从。</p>
<h4 id="1-1-一主多从搭建"><a href="#1-1-一主多从搭建" class="headerlink" title="1.1 一主多从搭建"></a>1.1 <strong>一主多从搭建</strong></h4><p>​	在已经搭建的单机版redis基础上进行操作。</p>
<p>​	并且关闭redis单机版</p>
<pre><code>
./redis-cli shutdown
</code></pre>
<h4 id="1-2-新建目录"><a href="#1-2-新建目录" class="headerlink" title="1.2 新建目录"></a>1.2 <strong>新建目录</strong></h4><pre><code>
# mkdir /usr/local/replica
</code></pre>
<h4 id="1-3-复制目录"><a href="#1-3-复制目录" class="headerlink" title="1.3 复制目录"></a>1.3 <strong>复制目录</strong></h4><p>​	把之前安装的redis单机版中bin目录复制三份，分别叫做：master、slave1、slave2</p>
<pre><code>
# cp -r /usr/local/redis/bin /usr/local/replica/master

# cp -r /usr/local/redis/bin /usr/local/replica/slave1

# cp -r /usr/local/redis/bin /usr/local/replica/slave2
</code></pre>
<h4 id="1-4-修改从的配置文件"><a href="#1-4-修改从的配置文件" class="headerlink" title="1.4 修改从的配置文件"></a>1.4 <strong>修改从的配置文件</strong></h4><p>​	修改2个从的redis.conf，指定主节点ip和端口。并修改自身端口号防止和其他redis冲突。</p>
<pre><code>
# vim /usr/local/replica/slave1/redis.conf
</code></pre>
<p>​	指定主节点ip和端口</p>
<pre><code>
replicaof 192.168.93.10 6379
</code></pre>
<p>​	修改自己端口</p>
<pre><code>
port 6380
</code></pre>
<pre><code>
# vim /usr/local/replica/slave2/redis.conf
</code></pre>
<p>​	指定主节点ip和端口</p>
<pre><code>
replicaof 192.168.93.10 6379
</code></pre>
<p>​	修改自己端口</p>
<pre><code>
port 6381
</code></pre>
<h4 id="1-5-启动三个redis实例"><a href="#1-5-启动三个redis实例" class="headerlink" title="1.5 启动三个redis实例"></a>1.5 <strong>启动三个redis实例</strong></h4><p>​	注意：一定要关闭单机的redis，否则端口冲突。</p>
<pre><code>
# cd /usr/local/replica

# vim startup.sh
</code></pre>
<p>​	在文件中添加下面内容</p>
<pre><code>
cd /usr/local/replica/master/

./redis-server redis.conf

  cd /usr/local/replica/slave1

./redis-server redis.conf

  cd /usr/local/replica/slave2

./redis-server redis.conf
</code></pre>
<pre><code> 赋予权限
</code></pre>
<pre><code>
# chmod a+x startup.sh
</code></pre>
<p>​	开启</p>
<pre><code>
# ./startup.sh
</code></pre>
<h4 id="1-6-查看启动状态"><a href="#1-6-查看启动状态" class="headerlink" title="1.6 查看启动状态"></a>1.6 <strong>查看启动状态</strong></h4><pre><code>
# ps aux|grep redis
</code></pre>
<img data-src="/2022/10/07/DataBase/Redis/Redis/Redis-05.jpg" class="">




<h4 id="1-7-测试"><a href="#1-7-测试" class="headerlink" title="1.7 测试*"></a>1.7 <strong>测试</strong>*</h4><pre><code>
# cd /usr/local/replica/master/

# ./redis-cli 
</code></pre>
<img data-src="/2022/10/07/DataBase/Redis/Redis/Redis-06.jpg" class="">




<p>​	在客户端命令行模式下，添加一条数据：</p>
<img data-src="/2022/10/07/DataBase/Redis/Redis/Redis-07.jpg" class="">




<p>​	进去slave查看数据是否同步。</p>
<pre><code>
# cd /usr/local/replica/slave1

# ./redis-cli -p 6380
</code></pre>
<img data-src="/2022/10/07/DataBase/Redis/Redis/Redis-08.jpg" class="">




<h3 id="2、docker下操作"><a href="#2、docker下操作" class="headerlink" title="2、docker下操作"></a>2、docker下操作</h3><p>​	可以自定义<strong>redis.conf</strong>文件只写要修改的，不改的就别写，这里主要是要书写<strong>新的端口号</strong>以及<strong>父节点</strong>的<strong>ip和端口</strong></p>
<p><strong>注意：</strong>所有修改必须在容器外，容器内修改无效，在退出重启的那一刻就已经还原了</p>
<p>我们通常使用  CP 来修改</p>
<pre><code class="shell">
docker  cp  本机文件路径   容器id: 容器内文件路径

#所有路径是所在文件夹路径，并不是文件的路径，简单来说就是写到文件夹所在路径即可，不需要指定特定文件
</code></pre>
<h4 id="1、修改端口号"><a href="#1、修改端口号" class="headerlink" title="1、修改端口号"></a>1、修改端口号</h4><p>同上</p>
<h4 id="2、指定父节点"><a href="#2、指定父节点" class="headerlink" title="2、指定父节点"></a>2、指定父节点</h4><p>同上</p>
<h4 id="3、重启"><a href="#3、重启" class="headerlink" title="3、重启"></a>3、重启</h4><p><strong>（如果在启动前修改不需要，这里是指已经启动了的容器，在修改之后的操作）</strong></p>
<pre><code class="shell">
docker restart 容器id
</code></pre>
<h4 id="4、测试并查看"><a href="#4、测试并查看" class="headerlink" title="4、测试并查看"></a>4、测试并查看</h4><p>·同上</p>
<pre><code class="shell">
role



或者



info replication
</code></pre>
<h2 id="七-哨兵（Sentinel）"><a href="#七-哨兵（Sentinel）" class="headerlink" title="七.  哨兵（Sentinel）"></a>七.  <strong>哨兵（Sentinel）</strong></h2><p>​	在redis主从默认是只有主具备写的能力，而从只能读。如果主宕机，整个节点不具备写能力。但是如果这是让一个从变成主，整个节点就可以继续工作。即使之前的主恢复过来也当做这个节点的从即可。</p>
<p>​	Redis的哨兵就是帮助监控整个节点的，当节点主宕机等情况下，帮助重新选取主。</p>
<p>​	Redis中哨兵支持单哨兵和多哨兵。单哨兵是只要这个哨兵发现master宕机了，就直接选取另一个master。而多哨兵是根据我们设定，达到一定数量哨兵认为master宕机后才会进行重新选取主。我们以多哨兵演示。</p>
<h3 id="1-没有哨兵下主从效果"><a href="#1-没有哨兵下主从效果" class="headerlink" title="1. 没有哨兵下主从效果"></a>1. <strong>没有哨兵下主从效果</strong></h3><p>​	只要杀掉主，整个节点无法在写数据，从身份不会变化，主的信息还是以前的信息。</p>
<img data-src="/2022/10/07/DataBase/Redis/Redis/Redis-09.jpg" class="">




<h3 id="2-搭建多哨兵"><a href="#2-搭建多哨兵" class="headerlink" title="2.搭建多哨兵"></a>2.<strong>搭建多哨兵</strong></h3><p>​	前提：安装了单机的redis</p>
<h4 id="2-1-新建目录"><a href="#2-1-新建目录" class="headerlink" title="2.1 新建目录"></a>2.1 <strong>新建目录</strong></h4><pre><code>
# mkdir /usr/local/sentinel
</code></pre>
<h4 id="2-2-复制redis"><a href="#2-2-复制redis" class="headerlink" title="2.2 复制redis"></a>2.2 <strong>复制redis</strong></h4><pre><code>
# cp -r /usr/local/redis/bin/* /usr/local/sentinel
</code></pre>
<h4 id="2-3-复制配置文件"><a href="#2-3-复制配置文件" class="headerlink" title="2.3 复制配置文件"></a>2.3 <strong>复制配置文件</strong></h4><p>​	从redis解压目录中复制sentinel配置文件</p>
<pre><code>
# cd /usr/local/tmp/redis-5.0.5/

# cp sentinel.conf /usr/local/sentinel/
</code></pre>
<h4 id="2-4-修改配置文件"><a href="#2-4-修改配置文件" class="headerlink" title="2.4 修改配置文件"></a>2.4 <strong>修改配置文件</strong></h4><pre><code>
# cd /usr/local/sentinel

# vim sentinel.conf



port 26379

daemonize yes

#这个提示里面的/var/log/redis/redis.log日志文件指的是容器中的文件，千万别理解为宿主机中的路径，如果你在宿主机创建此文件并授权，最后结果也是一样的，理解这一点很重要。

logfile “/usr/local/sentinel/26379.log”



sentinel monitor mymaster 192.168.93.10 6379 2
</code></pre>
<p>​	复制sentinel.conf，命名为sentinel-26380.conf</p>
<pre><code>
# cp sentinel.conf sentinel-26380.conf

# vim sentinel-26380.conf



port 26380

daemonize yes

logfile “/usr/local/sentinel/26380.log”

sentinel monitor mymaster 192.168.93.10 6379 2
</code></pre>
<p>复制sentinel.conf，命名为sentinel-26381.conf</p>
<pre><code>
# cp sentinel.conf sentinel-26381.conf

# vim sentinel-26381.conf



port 26381

daemonize yes

logfile “/usr/local/sentinel/26381.log”

sentinel monitor mymaster 192.168.93.10 6379 2
</code></pre>
<h4 id="2-5-启动主从"><a href="#2-5-启动主从" class="headerlink" title="2.5 启动主从"></a>2.5 <strong>启动主从</strong></h4><p>​	如果已经启动状态，忽略下面命令。如果启动部分，全部kill后重新启动。</p>
<p>​	使用kill杀死全部redis</p>
<pre><code>
# ps aux|grep redis

# kill -9 进程号
</code></pre>
<p>​	启动redis主从</p>
<pre><code>
# cd /usr/local/replica

# ./startup.sh
</code></pre>
<h4 id="2-6-启动三个哨兵"><a href="#2-6-启动三个哨兵" class="headerlink" title="2.6 启动三个哨兵"></a>2.6 <strong>启动三个哨兵</strong></h4><pre><code>
# cd /usr/local/sentinel

# ./redis-sentinel sentinel.conf

# ./redis-sentinel sentinel-26380.conf

# ./redis-sentinel sentinel-26381.conf
</code></pre>
<h4 id="2-7-查看日志"><a href="#2-7-查看日志" class="headerlink" title="2.7 查看日志"></a>2.7 <strong>查看日志</strong></h4><pre><code>
# cat 26379.log
</code></pre>
<h4 id="2-8-测试宕机"><a href="#2-8-测试宕机" class="headerlink" title="2.8 测试宕机"></a>2.8 <strong>测试宕机</strong></h4><p>​	查看redis进程号</p>
<pre><code>
# ps aux|grep redis
</code></pre>
<p>​	杀死主进程号</p>
<pre><code>
# kill -9 进程号
</code></pre>
<p>​	查看日志，短暂延迟后会发现，出现新的主。</p>
<pre><code>
# cat 26379.log
</code></pre>
<h2 id="八-集群-Cluster-–nt-have-doc"><a href="#八-集群-Cluster-–nt-have-doc" class="headerlink" title="八. 集群(Cluster)–nt have doc"></a>八. 集群(Cluster)–nt have doc</h2><p>​	前提：已经安装好redis单机版。</p>
<p>​	当集群中超过或等于1&#x2F;2节点不可用时，整个集群不可用。为了搭建稳定集群，都采用奇数节点。</p>
<h3 id="1-复制redis配置文件"><a href="#1-复制redis配置文件" class="headerlink" title="1 .复制redis配置文件"></a>1 .<strong>复制redis配置文件</strong></h3><p>​	从&#x2F;usr&#x2F;local&#x2F;redis&#x2F;bin下把redis.conf复制到当前目录中，命名为redis-7001.conf</p>
<pre><code>
# cp /usr/local/redis/bin/redis.conf /usr/local/redis/bin/redis-7001.conf
</code></pre>
<h3 id="2-修改redis-7001-conf"><a href="#2-修改redis-7001-conf" class="headerlink" title="2. 修改redis-7001.conf"></a>2. <strong>修改redis-7001.conf</strong></h3><pre><code>
# cd /usr/local/redis/bin

# vim redis-7001.conf
</code></pre>
<p>​	需要修改如下</p>
<pre><code>
port 7001

cluster-enabled yes

cluster-config-file nodes-7001.conf

cluster-node-timeout 15000

# appendonly yes 如果开启aof默认，需要修改为yes。如果使用rdb，此处不需要修改

daemonize yes

protected-mode no

pidfile /var/run/redis_7001.pid
</code></pre>
<h3 id="3-复制配置文件，并修改内容"><a href="#3-复制配置文件，并修改内容" class="headerlink" title="3 .复制配置文件，并修改内容"></a>3 .<strong>复制配置文件，并修改内容</strong></h3><p>​	把redis-7001.conf 复制5份，分别叫做redis-7002.conf、redis-7003.conf、redis-7004.conf、redis-7005.conf、redis-7006.conf </p>
<pre><code>
# cp redis-7001.conf redis-7002.conf

# cp redis-7001.conf redis-7003.conf

# cp redis-7001.conf redis-7004.conf

# cp redis-7001.conf redis-7005.conf

# cp redis-7001.conf redis-7006.conf
</code></pre>
<pre><code> 新复制的5个配置文件都需要需改三处。
</code></pre>
<p>​	例如nodes-7002.conf中需要把所有7001都换成7002。</p>
<p>​	可以使用 :%s&#x2F;7001&#x2F;7002&#x2F;g 进行全局修改。 </p>
<pre><code>
port 7002

cluster-config-file nodes-7002.conf

pidfile /var/run/redis_7002.pid
</code></pre>
<h3 id="4-启动6个redis"><a href="#4-启动6个redis" class="headerlink" title="4 .启动6个redis"></a>4 .<strong>启动6个redis</strong></h3><p>​	可以使用redis-server结合6个配置文件进行启动6个实例。</p>
<p>​	执行之前一定要先删除dump.rdb</p>
<pre><code>
# rm -f dump.rdb

# vim startup.sh



./redis-server redis-7001.conf

./redis-server redis-7002.conf

./redis-server redis-7003.conf

./redis-server redis-7004.conf

./redis-server redis-7005.conf

./redis-server redis-7006.conf





# chmod a+x startup.sh

# ./startup.sh
</code></pre>
<h3 id="5-查看启动状态"><a href="#5-查看启动状态" class="headerlink" title="5. 查看启动状态"></a>5. <strong>查看启动状态</strong></h3><img data-src="/2022/10/07/DataBase/Redis/Redis/Redis-10.jpg" class="">




<h3 id="6-建立集群"><a href="#6-建立集群" class="headerlink" title="6. 建立集群"></a>6. <strong>建立集群</strong></h3><p>​	在redis3的时候需要借助ruby脚本实现集群。在redis5中可以使用自带的redis-cli实现集群功能，比redis3的时候更加方便了。</p>
<p>​	建议配置静态ip，ip改变集群失效</p>
<pre><code>
./redis-cli --cluster create 192.168.93.10:7001 192.168.93.10:7002 192.168.93.10:7003 192.168.93.10:7004 192.168.93.10:7005 192.168.93.10:7006 --cluster-replicas 1
</code></pre>
<h3 id="7-测试"><a href="#7-测试" class="headerlink" title="7. 测试"></a>7. <strong>测试</strong></h3><p>​	集群测试时，千万不要忘记最后一个-c参数。</p>
<pre><code>
# ./redis-cli -p 7001 -c

# set age 18
</code></pre>
<h3 id="8-编写关闭脚本"><a href="#8-编写关闭脚本" class="headerlink" title="8 .编写关闭脚本"></a>8 .<strong>编写关闭脚本</strong></h3><pre><code>
# vim stop.sh

# chmod a+x stop.sh



./redis-cli -p 7001 shutdown

./redis-cli -p 7002 shutdown

./redis-cli -p 7003 shutdown

./redis-cli -p 7004 shutdown

./redis-cli -p 7005 shutdown

./redis-cli -p 7006 shutdown
</code></pre>
<h2 id="八-集群-Cluster-PATH-docker"><a href="#八-集群-Cluster-PATH-docker" class="headerlink" title="八. 集群(Cluster)-PATH:docker"></a>八. 集群(Cluster)-PATH:docker</h2><p>​	<strong>注：</strong>1.如果是配置修改之前<strong>已经创建过的集群时</strong>，要先进行第七步操作。</p>
<p>​			2.要是想重启集群可以省略第一步，但是得<strong>先删除已经创建的容器</strong>，重新进行2、3（合并也行）</p>
<h3 id="0、创建网络"><a href="#0、创建网络" class="headerlink" title="0、创建网络"></a>0、创建网络</h3><p><strong>目的：</strong>让宿主机可以访问到自身</p>
<pre><code class="shell">
docker network create net-redis --subnet 172.38.0.0/16
</code></pre>
<p>补充：关于虚拟机的三种网路连接方式区别</p>
<p> <span class="exturl" data-url="aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYmlmZW5nbWlhb3podWFuL2FydGljbGUvZGV0YWlscy83OTg4NzY5Mj9zcG09MTAwMS4yMTAxLjMwMDEuNjY2MS4xJmFtcDt1dG1fbWVkaXVtPWRpc3RyaWJ1dGUucGNfcmVsZXZhbnRfdDAubm9uZS10YXNrLWJsb2ctMn5kZWZhdWx0fkNUUkxJU1R+UmF0ZS0xLnBjX3JlbGV2YW50X2RlZmF1bHQmYW1wO2RlcHRoXzEtdXRtX3NvdXJjZT1kaXN0cmlidXRlLnBjX3JlbGV2YW50X3QwLm5vbmUtdGFzay1ibG9nLTJ+ZGVmYXVsdH5DVFJMSVNUflJhdGUtMS5wY19yZWxldmFudF9kZWZhdWx0JmFtcDt1dG1fcmVsZXZhbnRfaW5kZXg9MQ==">http://blog.csdn.net/bifengmiaozhuan/article/details/79887692?spm=1001.2101.3001.6661.1&amp;utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1.pc_relevant_default&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1.pc_relevant_default&amp;utm_relevant_index=1</span> </p>









<h3 id="1、创建并修改配置文件"><a href="#1、创建并修改配置文件" class="headerlink" title="1、创建并修改配置文件"></a>1、创建并修改配置文件</h3><p><strong>注：</strong></p>
<pre><code>
In certain deployments, Redis Cluster nodes address discovery fails, because addresses are NAT-ted or because ports are forwarded (the typical case is Docker and other containers).



在某些部署中，Redis群集节点地址发现失败，因为地址是NAT，或者端口是转发的（典型情况是Docker和其他容器）。



In order to make Redis Cluster working in such environments, a static configuration where each node knows its public address is needed. The following two options are used for this scope, and are:



为了让Redis集群在这样的环境中工作，需要一种静态配置，其中每个节点都知道自己的公共地址。以下两个选项用于此范围，分别是：



cluster-announce-ip



cluster-announce-port

---------------------------------------------------------------------------------------

你的docker内网是172，你宿主的IP是192网段



根据redis的配置文件中的解释



要在你的配置文件上加上上面的2个配置
</code></pre>
<p><strong>方法一：</strong>参考上面的方法一样行。</p>
<p><strong>方法二：</strong>使用脚本</p>
<pre><code class="shell">
#cat &lt;&lt;EOF EOF在这里没有特殊的含义，你可以使用FOE或000等;

#表示以cat &lt;&lt;EOF 开始输入以 EOF 结束结束输入

#cat&gt;创建文件，并把标准输入输出到后面的filename文件





 * cluster-announce-ip					192.168.1.195	#*群集ip

 * cluster-announce-port				700$&#123;port&#125;		#*群集总线端口

 * cluster-announce-bus-port#*群集ip    1700$&#123;port&#125;	   #*群集公布端口

# 集群 ip 是固定+10000



# 可以使用 :  %s/7001/7002/g     进行全局修改。 ---将全局的7001修改成7002



for port in $(seq 1 6); \ 

do \

mkdir  -p  /root/myredis/conf700$&#123;port&#125;

touch  /root/myredis/conf700$&#123;port&#125;/redis.conf

cat &lt;&lt;TTT &gt; /root/myredis/conf700$&#123;port&#125;/redis.conf port 6379

bind 0.0.0.0

port 700$&#123;port&#125;

cluster-enabled yes

cluster-config-file nodes-700$&#123;port&#125;.conf

cluster-node-timeout 15000

protected-mode no

pidfile /var/run/redis_ 700$&#123;port&#125;.pid

cluster-announce-ip  192.168.1.195 

cluster-announce-port  700$&#123;port) 

cluster-announce-bus-port 1700$&#123;port) 

appendonly yes 

TTT 

done
</code></pre>
<h3 id="2、创建容器"><a href="#2、创建容器" class="headerlink" title="2、创建容器"></a>2、创建容器</h3><p><strong>方法一：</strong>手动创建容器，并启动</p>
<pre><code class="shell">
docker run -p 7001:7001   -p 17001:17001  --name redis7001  -v /root/myredis/conf7001/redis.conf:/etc/redis/redis.conf -v /root/myredis/data7001:/data -d redis redis-server /etc/redis/redis.conf --appendonly yes
</code></pre>
<p>​	7002 ~~~7006同上，自行修改参数</p>
<p><strong>方法二：</strong>脚本一键启动，效果同上</p>
<p>​	<strong>注意：</strong></p>
<ul>
<li><p>其中要指定两个端口号**-p 1700${port}:1700${port}**不要忘记，否则会在创建几群的时候出现  **Waiting for the cluster to join   ** 。【具体原因，我还没查出来，后面补充】</p>
</li>
<li><p>在docker创建集群容器的时候，<strong>一定要</strong> 指定  ip</p>
</li>
</ul>
<p><strong>补充：</strong></p>
<ul>
<li>那肯定是你端口没有开启，不要质疑，这里的端口不是7000-7005，而是17000-17005，因为redis设置集群的端口号是”redis端口+10000“，这个非常重要。并且7001:7006也是必须打开的。</li>
</ul>
<pre><code class="shell">
for port in $(seq 1 6);  \

do \

docker run -p 700$&#123;port&#125;:700$&#123;port&#125;   -p 1700$&#123;port&#125;:1700$&#123;port&#125;  --name redis700$&#123;port&#125;  \

-v /root/redis/redis700$&#123;port&#125;.conf:/etc/redis/redis.conf \

-v /root/redis/data700$&#123;port&#125;:/data \

-d --ip 192.168.1.195 redis redis-server /etc/redis/redis.conf 

done
</code></pre>
<h3 id="3、进入容器"><a href="#3、进入容器" class="headerlink" title="3、进入容器"></a>3、进入容器</h3><pre><code class="shell">
docker exec -it redis7001 /bin/bash
</code></pre>
<h3 id="4、创建集群"><a href="#4、创建集群" class="headerlink" title="4、创建集群"></a>4、创建集群</h3><p>​	<strong>注：</strong>有一步操作，要自行进行确认，一定要输入 <strong>yes</strong> 而不是 <strong>y</strong> 或者其他之类的，除了 yes一律视为 <strong>no</strong> 。</p>
<pre><code class="shell">
redis-cli --cluster create 192.168.1.195:7001 192.168.1.195:7002 192.168.1.195:7003 192.168.1.195:7004 192.168.1.195:7005 192.168.1.195:7006 --cluster-replicas 1
</code></pre>
<h3 id="5、测试"><a href="#5、测试" class="headerlink" title="5、测试"></a>5、测试</h3><p>​	集群测试时，千万不要忘记最后一个-c参数。</p>
<pre><code class="shel">
redis-cli -p 7001 -c
</code></pre>
<h3 id="6、关闭集群"><a href="#6、关闭集群" class="headerlink" title="6、关闭集群"></a>6、关闭集群</h3><p><strong>方法一：</strong></p>
<p>​	自行手动一个一个停止，并且删除容器</p>
<pre><code class="shell">
docker stop redis7001 #7002 ~~~7006



docker rm -f redis7001
</code></pre>
<p><strong>方法二：</strong></p>
<p>​	脚本程序，一劳永逸</p>
<pre><code class="shell">
for port in $(seq 1 6);  \

do \

docker stop redis700$&#123;port&#125;

docker rm -f redis700$&#123;port&#125;

done
</code></pre>
<h3 id="7、清空集群文件"><a href="#7、清空集群文件" class="headerlink" title="7、清空集群文件"></a>7、清空集群文件</h3><pre><code class="shell">
for port in $(seq 1 6);  \

do \

rm  -rf  ./data700$&#123;port&#125;/* 

done
</code></pre>
<h2 id="九-Jedis"><a href="#九-Jedis" class="headerlink" title="九. Jedis"></a>九. <strong>Jedis</strong></h2><p>​	Redis给Java语言提供了客户端API，称之为Jedis。</p>
<p>​	Jedis API和Redis 命令几乎是一样的。</p>
<p>​	例如：Redis对String值新增时set命令，Jedis中也是set方法。所以本课程中没有重点把所有方法进行演示，重要演示Jedis如何使用。</p>
<p>​	Jedis API特别简单，基本上都是创建对象调用方法即可。</p>
<h3 id="1-单机版"><a href="#1-单机版" class="headerlink" title="1. 单机版"></a>1. <strong>单机版</strong></h3><pre><code>
public void testStandalone()&#123;

    Jedis jedis = new Jedis(&quot;192.168.93.10&quot;,6379);

    jedis.set(&quot;name&quot;,&quot;msb-standalone&quot;);

    String value = jedis.get(&quot;name&quot;);

    System.out.println(value);

&#125;
</code></pre>
<h3 id="2-带有连接池"><a href="#2-带有连接池" class="headerlink" title="2. 带有连接池"></a>2. <strong>带有连接池</strong></h3><pre><code>
public void testPool()&#123;

    JedisPoolConfig jedisPoolConfig = new JedisPoolConfig();

    jedisPoolConfig.setMaxTotal(20);

    jedisPoolConfig.setMaxIdle(5);

    jedisPoolConfig.setMinIdle(3);

    JedisPool jedisPool = new JedisPool(jedisPoolConfig,&quot;192.168.93.10&quot;,6379);

    Jedis jedis = jedisPool.getResource();

    jedis.set(&quot;name&quot;,&quot;msb-pool&quot;);

    String value = jedis.get(&quot;name&quot;);

    System.out.println(value);

&#125;
</code></pre>
<h3 id="3-集群"><a href="#3-集群" class="headerlink" title="3. 集群"></a>3. <strong>集群</strong></h3><pre><code>
public void testCluster()&#123;

    Set&lt;HostAndPort&gt; set = new HashSet&lt;&gt;();

    set.add(new HostAndPort(&quot;192.168.93.10&quot;,7001));

    set.add(new HostAndPort(&quot;192.168.93.10&quot;,7002));

    set.add(new HostAndPort(&quot;192.168.93.10&quot;,7003));

    set.add(new HostAndPort(&quot;192.168.93.10&quot;,7004));

    set.add(new HostAndPort(&quot;192.168.93.10&quot;,7005));

    set.add(new HostAndPort(&quot;192.168.93.10&quot;,7006));

    JedisCluster jedisCluster = new JedisCluster(set);

    jedisCluster.set(&quot;name&quot;,&quot;bjmsb&quot;);

    String value = jedisCluster.get(&quot;name&quot;);

    System.out.println(value);

&#125;
</code></pre>
<h2 id="十-使用SpringBoot整合SpringDataRedis操作redis"><a href="#十-使用SpringBoot整合SpringDataRedis操作redis" class="headerlink" title="十. 使用SpringBoot整合SpringDataRedis操作redis"></a>十. <strong>使用SpringBoot整合SpringDataRedis操作redis</strong></h2><p>​	Spring Data是Spring公司的顶级项目，里面包含了N多个二级子项目，这些子项目都是相对独立的项目。每个子项目是对不同API的封装。</p>
<p>​	所有Spring Boot整合Spring Data xxxx的启动器都叫做spring-boot-starter-data-xxxx</p>
<p>​	Spring Data 好处很方便操作对象类型。</p>
<p>​	把Redis不同值得类型放到一个opsForXXX方法中。</p>
<p>​		opsForValue : String值</p>
<p>​		opsForList : 列表List</p>
<p>​		opsForHash: 哈希表Hash</p>
<p>​		opsForZSet: 有序集合Sorted Set</p>
<p>​		opsForSet : 集合</p>
<h3 id="1-添加依赖"><a href="#1-添加依赖" class="headerlink" title="1. 添加依赖"></a>1. <strong>添加依赖</strong></h3><pre><code>
     &lt;parent&gt;

        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;

        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;

        &lt;version&gt;2.2.2.RELEASE&lt;/version&gt;

    &lt;/parent&gt;



    &lt;dependencies&gt;

        &lt;dependency&gt;

            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;

            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;

        &lt;/dependency&gt;

        &lt;dependency&gt;

            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;

            &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;

            &lt;version&gt;2.2.5.RELEASE&lt;/version&gt;

        &lt;/dependency&gt;

        &lt;dependency&gt;

            &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;

            &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;

            &lt;version&gt;2.1.1&lt;/version&gt;

        &lt;/dependency&gt;

        &lt;dependency&gt;

            &lt;groupId&gt;mysql&lt;/groupId&gt;

            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;

            &lt;version&gt;5.1.47&lt;/version&gt;

        &lt;/dependency&gt;

        &lt;dependency&gt;

            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;

            &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;

            &lt;version&gt;2.2.2.RELEASE&lt;/version&gt;

        &lt;/dependency&gt;

        &lt;dependency&gt;

            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;

            &lt;artifactId&gt;lombok&lt;/artifactId&gt;

            &lt;version&gt;1.18.20&lt;/version&gt;

        &lt;/dependency&gt;

        &lt;dependency&gt;

            &lt;groupId&gt;redis.clients&lt;/groupId&gt;

            &lt;artifactId&gt;jedis&lt;/artifactId&gt;

            &lt;version&gt;3.3.0&lt;/version&gt;

        &lt;/dependency&gt;

    &lt;/dependencies&gt;
</code></pre>
<h3 id="2-配置配置文件"><a href="#2-配置配置文件" class="headerlink" title="2. 配置配置文件"></a>2. <strong>配置配置文件</strong></h3><p><strong>注：</strong></p>
<ul>
<li><p>spring.redis.host&#x3D;localhost 默认值</p>
</li>
<li><p>spring.redis.port&#x3D;6379 端口号默认值</p>
</li>
</ul>
<pre><code>
mybatis:

  mapper-locations: classpath:mybatis/*

  type-aliases-package: com.msb.pojo

spring:

  datasource:

    url: jdbc:mysql://localhost:3306/mydb

    username: root

    password: root

    driver-class-name: com.mysql.jdbc.Driver

  redis:

    host: 192.168.1.195

    cluster:

      nodes: 192.168.1.195:7001,192.168.1.195:7002,192.168.1.195:7003,192.168.1.195:7004,192.168.1.195:7005,192.168.1.195:7006
</code></pre>
<h3 id="3-编写配置类（可直接复制）"><a href="#3-编写配置类（可直接复制）" class="headerlink" title="3.编写配置类（可直接复制）"></a>3.<strong>编写配置类</strong>（可直接复制）</h3><pre><code>
@Configuration

public class RedisConfig &#123;

    @Bean

    public RedisTemplate&lt;String,Object&gt; redisTemplate(RedisConnectionFactory 		  factory)&#123;

        RedisTemplate&lt;String,Object&gt; redisTemplate = new RedisTemplate&lt;&gt;();

        redisTemplate.setConnectionFactory(factory);

        redisTemplate.setKeySerializer(new StringRedisSerializer());

        redisTemplate.setValueSerializer(new Jackson2JsonRedisSerializer&lt;Object&gt;(Object.class));

        return redisTemplate;

    &#125;

&#125;
</code></pre>
<h3 id="4-编写代码"><a href="#4-编写代码" class="headerlink" title="4. 编写代码"></a>4. <strong>编写代码</strong></h3><h4 id="4-1-编写对象新增"><a href="#4-1-编写对象新增" class="headerlink" title="4.1 编写对象新增"></a>4.1 <strong>编写对象新增</strong></h4><pre><code>
@Autowired

private RedisTemplate&lt;String, Object&gt; redisTemplate;



@Test

public void testString() &#123;

    People peo = new People(1, &quot;张三&quot;);

    redisTemplate.opsForValue().set(&quot;peo1&quot;, peo);

&#125;
</code></pre>
<h4 id="4-2-编写对象获取"><a href="#4-2-编写对象获取" class="headerlink" title="4.2 编写对象获取"></a>4.2 <strong>编写对象获取</strong></h4><p>此处必须编写值序列化器。不指定时返回类型为LinkedHashMap</p>
<pre><code>
@Test

public void testGetString() &#123;

    redisTemplate.setValueSerializer(new Jackson2JsonRedisSerializer&lt;People&gt;(People.class));

    People peo = (People) redisTemplate.opsForValue().get(&quot;peo1&quot;);

    System.out.println(peo);

&#125;
</code></pre>
<h4 id="4-3-编写List"><a href="#4-3-编写List" class="headerlink" title="4.3 编写List"></a>4.3 <strong>编写List</strong></h4><pre><code>
@Test

public void testList() &#123;

    List&lt;People&gt; list = new ArrayList&lt;&gt;();

    list.add(new People(1, &quot;张三&quot;));

    list.add(new People(2, &quot;李四&quot;));

    redisTemplate.opsForValue().set(&quot;list2&quot;, list);

&#125;
</code></pre>
<h4 id="4-4-编写List取值"><a href="#4-4-编写List取值" class="headerlink" title="4.4 编写List取值"></a>4.4 <strong>编写List取值</strong></h4><pre><code>
@Test

public void testGetList()&#123;

    redisTemplate.setValueSerializer(new Jackson2JsonRedisSerializer&lt;List&gt;(List.class));

    List&lt;People&gt; list2 = (List&lt;People&gt;) redisTemplate.opsForValue().get(&quot;list2&quot;);

    System.out.println(list2);

&#125;
</code></pre>
<h2 id="十一-使用Redis效果"><a href="#十一-使用Redis效果" class="headerlink" title="十一. 使用Redis效果"></a>十一. <strong>使用Redis效果</strong></h2><p>​	使用缓存流程</p>
<p>​	1. 先判断缓存中是否存在。如果存在直接从缓存中取出数据。不执行2，3步骤</p>
<p>​	2. 如果不存在，从mysql中获取数据</p>
<p>​	3. 获取数据后，把数据缓存到redis中</p>
<img data-src="/2022/10/07/DataBase/Redis/Redis/Redis-11.jpg" class="">


]]></content>
      <categories>
        <category>数据库</category>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>分布式</tag>
        <tag>中间件</tag>
        <tag>Redis基础</tag>
        <tag>NoSQL数据库</tag>
      </tags>
  </entry>
</search>
