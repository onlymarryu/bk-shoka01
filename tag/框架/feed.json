{
    "version": "https://jsonfeed.org/version/1",
    "title": "记录“美食”每刻 • All posts by \"框架\" tag",
    "description": "记录“美食”每刻",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/2022/10/07/ORM/MybatisPlus/",
            "url": "http://example.com/2022/10/07/ORM/MybatisPlus/",
            "title": "MybatisPlus",
            "date_published": "2022-10-06T16:00:00.000Z",
            "content_html": "<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2Jhb21pZG91L215YmF0aXMtcGx1cw==\">MyBatis-Plus (opens new window)</span>（简称 MP）是一个 <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubXliYXRpcy5vcmcvbXliYXRpcy0zLw==\">MyBatis (opens new window)</span>的增强工具，在 MyBatis 的基础上只做增强不做改变，为简化开发、提高效率而生。</p>\n<blockquote>\n<p>愿景</p>\n<p>我们的愿景是成为 MyBatis 最好的搭档，就像 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYW9taWRvdS5jb20vaW1nL2NvbnRyYS5qcGc=\">魂斗罗</span> 中的 1P、2P，基友搭配，效率翻倍。</p>\n</blockquote>\n<h2 id=\"特性\"><a href=\"#特性\" class=\"headerlink\" title=\"特性\"></a>特性</h2><ul>\n<li><strong>无侵入</strong>：只做增强不做改变，引入它不会对现有工程产生影响，如丝般顺滑</li>\n<li><strong>损耗小</strong>：启动即会自动注入基本 CURD，性能基本无损耗，直接面向对象操作</li>\n<li><strong>强大的 CRUD 操作</strong>：内置通用 Mapper、通用 Service，仅仅通过少量配置即可实现单表大部分 CRUD 操作，更有强大的条件构造器，满足各类使用需求</li>\n<li><strong>支持 Lambda 形式调用</strong>：通过 Lambda 表达式，方便的编写各类查询条件，无需再担心字段写错</li>\n<li><strong>支持主键自动生成</strong>：支持多达 4 种主键策略（内含分布式唯一 ID 生成器 - Sequence），可自由配置，完美解决主键问题</li>\n<li><strong>支持 ActiveRecord 模式</strong>：支持 ActiveRecord 形式调用，实体类只需继承 Model 类即可进行强大的 CRUD 操作</li>\n<li><strong>支持自定义全局通用操作</strong>：支持全局通用方法注入（ Write once, use anywhere ）</li>\n<li><strong>内置代码生成器</strong>：采用代码或者 Maven 插件可快速生成 Mapper 、 Model 、 Service 、 Controller 层代码，支持模板引擎，更有超多自定义配置等您来使用</li>\n<li><strong>内置分页插件</strong>：基于 MyBatis 物理分页，开发者无需关心具体操作，配置好插件之后，写分页等同于普通 List 查询</li>\n<li><strong>分页插件支持多种数据库</strong>：支持 MySQL、MariaDB、Oracle、DB2、H2、HSQL、SQLite、Postgre、SQLServer 等多种数据库</li>\n<li><strong>内置性能分析插件</strong>：可输出 SQL 语句以及其执行时间，建议开发测试时启用该功能，能快速揪出慢查询</li>\n<li><strong>内置全局拦截插件</strong>：提供全表 delete 、 update 操作智能分析阻断，也可自定义拦截规则，预防误操作</li>\n</ul>\n<h2 id=\"支持数据库\"><a href=\"#支持数据库\" class=\"headerlink\" title=\"支持数据库\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYW9taWRvdS5jb20vcGFnZXMvMjQxMTJmLyMlRTYlOTQlQUYlRTYlOEMlODElRTYlOTUlQjAlRTYlOEQlQUUlRTUlQkElOTM=\"></span>支持数据库</h2><blockquote>\n<p>任何能使用 <code>MyBatis</code> 进行 CRUD, 并且支持标准 SQL 的数据库，具体支持情况如下，如果不在下列表查看分页部分教程 PR 您的支持。</p>\n</blockquote>\n<ul>\n<li>MySQL，Oracle，DB2，H2，HSQL，SQLite，PostgreSQL，SQLServer，Phoenix，Gauss ，ClickHouse，Sybase，OceanBase，Firebird，Cubrid，Goldilocks，csiidb</li>\n<li>达梦数据库，虚谷数据库，人大金仓数据库，南大通用(华库)数据库，南大通用数据库，神通数据库，瀚高数据库</li>\n</ul>\n<h2 id=\"框架结构\"><a href=\"#框架结构\" class=\"headerlink\" title=\"框架结构\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYW9taWRvdS5jb20vcGFnZXMvMjQxMTJmLyMlRTYlQTElODYlRTYlOUUlQjYlRTclQkIlOTMlRTYlOUUlODQ=\"></span>框架结构</h2><img data-src=\"/2022/10/07/ORM/MybatisPlus/mybatis-plus-framework.jpg\" class=\"\" title=\"framework\">\n\n\n\n<h1 id=\"快速使用\"><a href=\"#快速使用\" class=\"headerlink\" title=\"快速使用\"></a>快速使用</h1><blockquote>\n<p>使用的mybatis 3.5之前版本，也就是官方的旧版本</p>\n</blockquote>\n<h2 id=\"初始化工程\"><a href=\"#初始化工程\" class=\"headerlink\" title=\"初始化工程\"></a>初始化工程</h2><p>创建一个空的 Spring Boot 工程（工程将以 H2 作为默认数据库进行演示）</p>\n<p>提示</p>\n<p>可以使用 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9zdGFydC5zcHJpbmcuaW8v\">Spring Initializer (opens new window)</span>快速初始化一个 Spring Boot 工程</p>\n<h2 id=\"pom-添加依赖\"><a href=\"#pom-添加依赖\" class=\"headerlink\" title=\"pom 添加依赖\"></a><code>pom</code> 添加依赖</h2><pre><code class=\"xml\">    &lt;properties&gt;\n        &lt;java.version&gt;1.8&lt;/java.version&gt;\n        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;\n        &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;\n        &lt;spring-boot.version&gt;2.3.7.RELEASE&lt;/spring-boot.version&gt;\n    &lt;/properties&gt;\n\n    &lt;dependencies&gt;\n        &lt;!--freemarker--&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.freemarker&lt;/groupId&gt;\n            &lt;artifactId&gt;freemarker&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n        &lt;!--velocity--&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.apache.velocity&lt;/groupId&gt;\n            &lt;artifactId&gt;velocity-engine-core&lt;/artifactId&gt;\n            &lt;version&gt;2.2&lt;/version&gt;\n        &lt;/dependency&gt;\n        &lt;!--generator--&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;com.baomidou&lt;/groupId&gt;\n            &lt;artifactId&gt;mybatis-plus-generator&lt;/artifactId&gt;\n            &lt;version&gt;3.4.1&lt;/version&gt;\n        &lt;/dependency&gt;\n        &lt;!--mybatis-plus--&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;com.baomidou&lt;/groupId&gt;\n            &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;\n            &lt;version&gt;3.4.1&lt;/version&gt;\n        &lt;/dependency&gt;\n        &lt;!--jdbc--&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;mysql&lt;/groupId&gt;\n            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;\n            &lt;scope&gt;runtime&lt;/scope&gt;\n        &lt;/dependency&gt;\n        &lt;!--lombok--&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;\n            &lt;artifactId&gt;lombok&lt;/artifactId&gt;\n            &lt;optional&gt;true&lt;/optional&gt;\n        &lt;/dependency&gt;\n        &lt;!--spring-start-web--&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n        &lt;!--spring-test--&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;\n            &lt;scope&gt;test&lt;/scope&gt;\n            &lt;exclusions&gt;\n                &lt;exclusion&gt;\n                    &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt;\n                    &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt;\n                &lt;/exclusion&gt;\n            &lt;/exclusions&gt;\n        &lt;/dependency&gt;\n        &lt;!--junit4--&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;junit&lt;/groupId&gt;\n            &lt;artifactId&gt;junit&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n    &lt;/dependencies&gt;\n\n    &lt;dependencyManagement&gt;\n        &lt;dependencies&gt;\n            &lt;dependency&gt;\n                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n                &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt;\n                &lt;version&gt;$&#123;spring-boot.version&#125;&lt;/version&gt;\n                &lt;type&gt;pom&lt;/type&gt;\n                &lt;scope&gt;import&lt;/scope&gt;\n            &lt;/dependency&gt;\n        &lt;/dependencies&gt;\n    &lt;/dependencyManagement&gt;\n\n    &lt;build&gt;\n        &lt;plugins&gt;\n            &lt;plugin&gt;\n                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;\n                &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;\n                &lt;version&gt;3.8.1&lt;/version&gt;\n                &lt;configuration&gt;\n                    &lt;source&gt;1.8&lt;/source&gt;\n                    &lt;target&gt;1.8&lt;/target&gt;\n                    &lt;encoding&gt;UTF-8&lt;/encoding&gt;\n                &lt;/configuration&gt;\n            &lt;/plugin&gt;\n            &lt;plugin&gt;\n                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;\n                &lt;version&gt;2.3.7.RELEASE&lt;/version&gt;\n                &lt;configuration&gt;\n                    &lt;mainClass&gt;com.example.TestMybatisplusApplication&lt;/mainClass&gt;\n                &lt;/configuration&gt;\n                &lt;executions&gt;\n                    &lt;execution&gt;\n                        &lt;id&gt;repackage&lt;/id&gt;\n                        &lt;goals&gt;\n                            &lt;goal&gt;repackage&lt;/goal&gt;\n                        &lt;/goals&gt;\n                    &lt;/execution&gt;\n                &lt;/executions&gt;\n            &lt;/plugin&gt;\n        &lt;/plugins&gt;\n    &lt;/build&gt;\n</code></pre>\n<h2 id=\"模板准备\"><a href=\"#模板准备\" class=\"headerlink\" title=\"模板准备\"></a>模板准备</h2><p>因为个人习惯原因，我修改了一下entity的模板。</p>\n<blockquote>\n<p>在<code>resource/templates </code>下创建一个<code>MyEntity.java.ftl</code>(就这个名字吧，不然还要改代码，再者这个没啥用，只用于我们的逆向工程) ，直接将下面的内容粘贴创建即可。</p>\n<p>注意：</p>\n<ul>\n<li>我用的模板引擎是 <code>freemarker</code> 一定得加依赖</li>\n<li>用 .vm 就要加 <code>velocity</code> 依赖</li>\n</ul>\n</blockquote>\n<h3 id=\"ftl文件\"><a href=\"#ftl文件\" class=\"headerlink\" title=\".ftl文件\"></a>.ftl文件</h3><pre><code class=\"ftl\">package $&#123;package.Entity&#125;;\n\n&lt;#list table.importPackages as pkg&gt;\nimport $&#123;pkg&#125;;\n&lt;/#list&gt;\n&lt;#if swagger2&gt;\n&lt;/#if&gt;\n&lt;#if entityLombokModel&gt;\nimport lombok.*;\n&lt;/#if&gt;\n\n/**\n * &lt;p&gt;\n * $&#123;table.comment!&#125;\n * &lt;/p&gt;\n *\n * @author $&#123;author&#125;\n * @since $&#123;date&#125;\n */\n&lt;#if entityLombokModel&gt;\n    &lt;#if superEntityClass??&gt;\n@EqualsAndHashCode(callSuper = true)\n    &lt;#else&gt;\n@EqualsAndHashCode(callSuper = false)\n    &lt;/#if&gt;\n    &lt;#if chainModel&gt;\n@Accessors(chain = true)\n    &lt;/#if&gt;\n&lt;/#if&gt;\n&lt;#if table.convert&gt;\n@TableName(&quot;$&#123;table.name&#125;&quot;)\n&lt;/#if&gt;\n@AllArgsConstructor\n@NoArgsConstructor\n@Data\n@ToString\n&lt;#if superEntityClass??&gt;\npublic class $&#123;entity&#125; extends $&#123;superEntityClass&#125;&lt;#if activeRecord&gt;&lt;$&#123;entity&#125;&gt;&lt;/#if&gt; &#123;\n&lt;#elseif activeRecord&gt;\npublic class $&#123;entity&#125; extends Model&lt;$&#123;entity&#125;&gt; &#123;\n&lt;#else&gt;\npublic class $&#123;entity&#125; implements Serializable &#123;\n&lt;/#if&gt;\n\n&lt;#if entitySerialVersionUID&gt;\n    private static final long serialVersionUID = 1L;\n&lt;/#if&gt;\n&lt;#-- ----------  BEGIN 字段循环遍历  ----------&gt;\n&lt;#list table.fields as field&gt;\n    &lt;#if field.keyFlag&gt;\n        &lt;#assign keyPropertyName=&quot;$&#123;field.propertyName&#125;&quot;/&gt;\n    &lt;/#if&gt;\n\n    &lt;#if field.comment!?length gt 0&gt;\n        &lt;#if swagger2&gt;\n    @ApiModelProperty(value = &quot;$&#123;field.comment&#125;&quot;)\n        &lt;#else&gt;\n    /**\n     * $&#123;field.comment&#125;\n     */\n        &lt;/#if&gt;\n    &lt;/#if&gt;\n    &lt;#if field.keyFlag&gt;\n        &lt;#-- 主键 --&gt;\n        &lt;#if field.keyIdentityFlag&gt;\n    @TableId(value = &quot;$&#123;field.annotationColumnName&#125;&quot;, type = IdType.AUTO)\n        &lt;#elseif idType??&gt;\n    @TableId(value = &quot;$&#123;field.annotationColumnName&#125;&quot;, type = IdType.$&#123;idType&#125;)\n        &lt;#elseif field.convert&gt;\n    @TableId(&quot;$&#123;field.annotationColumnName&#125;&quot;)\n        &lt;/#if&gt;\n        &lt;#-- 普通字段 --&gt;\n    &lt;#elseif field.fill??&gt;\n    &lt;#-- -----   存在字段填充设置   -----&gt;\n        &lt;#if field.convert&gt;\n    @TableField(value = &quot;$&#123;field.annotationColumnName&#125;&quot;, fill = FieldFill.$&#123;field.fill&#125;)\n        &lt;#else&gt;\n    @TableField(fill = FieldFill.$&#123;field.fill&#125;)\n        &lt;/#if&gt;\n    &lt;#elseif field.convert&gt;\n    @TableField(&quot;$&#123;field.annotationColumnName&#125;&quot;)\n    &lt;/#if&gt;\n    &lt;#-- 乐观锁注解 --&gt;\n    &lt;#if (versionFieldName!&quot;&quot;) == field.name&gt;\n    @Version\n    &lt;/#if&gt;\n    &lt;#-- 逻辑删除注解 --&gt;\n    &lt;#if (logicDeleteFieldName!&quot;&quot;) == field.name&gt;\n    @TableLogic\n    &lt;/#if&gt;\n    private $&#123;field.propertyType&#125; $&#123;field.propertyName&#125;;\n&lt;/#list&gt;\n&lt;#------------  END 字段循环遍历  ----------&gt;\n\n&lt;#if !entityLombokModel&gt;\n    &lt;#list table.fields as field&gt;\n        &lt;#if field.propertyType == &quot;boolean&quot;&gt;\n            &lt;#assign getprefix=&quot;is&quot;/&gt;\n        &lt;#else&gt;\n            &lt;#assign getprefix=&quot;get&quot;/&gt;\n        &lt;/#if&gt;\n    public $&#123;field.propertyType&#125; $&#123;getprefix&#125;$&#123;field.capitalName&#125;() &#123;\n        return $&#123;field.propertyName&#125;;\n    &#125;\n\n    &lt;#if chainModel&gt;\n    public $&#123;entity&#125; set$&#123;field.capitalName&#125;($&#123;field.propertyType&#125; $&#123;field.propertyName&#125;) &#123;\n    &lt;#else&gt;\n    public void set$&#123;field.capitalName&#125;($&#123;field.propertyType&#125; $&#123;field.propertyName&#125;) &#123;\n    &lt;/#if&gt;\n        this.$&#123;field.propertyName&#125; = $&#123;field.propertyName&#125;;\n        &lt;#if chainModel&gt;\n        return this;\n        &lt;/#if&gt;\n    &#125;\n    &lt;/#list&gt;\n&lt;/#if&gt;\n\n&lt;#if entityColumnConstant&gt;\n    &lt;#list table.fields as field&gt;\n    public static final String $&#123;field.name?upper_case&#125; = &quot;$&#123;field.name&#125;&quot;;\n\n    &lt;/#list&gt;\n&lt;/#if&gt;\n&lt;#if activeRecord&gt;\n    @Override\n    protected Serializable pkVal() &#123;\n    &lt;#if keyPropertyName??&gt;\n        return this.$&#123;keyPropertyName&#125;;\n    &lt;#else&gt;\n        return null;\n    &lt;/#if&gt;\n    &#125;\n\n&lt;/#if&gt;\n&lt;#if !entityLombokModel&gt;\n    @Override\n    public String toString() &#123;\n        return &quot;$&#123;entity&#125;&#123;&quot; +\n    &lt;#list table.fields as field&gt;\n        &lt;#if field_index==0&gt;\n            &quot;$&#123;field.propertyName&#125;=&quot; + $&#123;field.propertyName&#125; +\n        &lt;#else&gt;\n            &quot;, $&#123;field.propertyName&#125;=&quot; + $&#123;field.propertyName&#125; +\n        &lt;/#if&gt;\n    &lt;/#list&gt;\n        &quot;&#125;&quot;;\n    &#125;\n&lt;/#if&gt;\n&#125;\n</code></pre>\n<h3 id=\"vm文件\"><a href=\"#vm文件\" class=\"headerlink\" title=\".vm文件\"></a>.vm文件</h3><pre><code class=\"vm\">package $&#123;package.Entity&#125;;\n\n#foreach($pkg in $&#123;table.importPackages&#125;)\nimport $&#123;pkg&#125;;\n#end\n#if($&#123;entityLombokModel&#125;)\nimport lombok.*;\n#end\n\n/**\n * &lt;p&gt;\n * $!&#123;table.comment&#125;\n * &lt;/p&gt;\n *\n * @author $&#123;author&#125;\n * @since $&#123;date&#125;\n */\n#if($&#123;entityLombokModel&#125;)\n  #if($&#123;superEntityClass&#125;)\n@EqualsAndHashCode(callSuper = true)\n  #else\n@EqualsAndHashCode(callSuper = false)\n  #end\n#end\n#if($&#123;table.convert&#125;)\n@TableName(&quot;$&#123;table.name&#125;&quot;)\n#end\n@AllArgsConstructor\n@NoArgsConstructor\n@Data\n@ToString\n#if($&#123;superEntityClass&#125;)\npublic class $&#123;entity&#125; extends $&#123;superEntityClass&#125;#if($&#123;activeRecord&#125;)&lt;$&#123;entity&#125;&gt;#end &#123;\n#elseif($&#123;activeRecord&#125;)\npublic class $&#123;entity&#125; extends Model&lt;$&#123;entity&#125;&gt; &#123;\n#else\npublic class $&#123;entity&#125; implements Serializable &#123;\n#end\n\n#if($&#123;entitySerialVersionUID&#125;)\n    private static final long serialVersionUID = 1L;\n#end\n## ----------  BEGIN 字段循环遍历  ----------\n#foreach($field in $&#123;table.fields&#125;)\n\n#if($&#123;field.keyFlag&#125;)\n#set($keyPropertyName=$&#123;field.propertyName&#125;)\n#end\n#if(&quot;$!field.comment&quot; != &quot;&quot;)\n  #if($&#123;swagger2&#125;)\n    @ApiModelProperty(value = &quot;$&#123;field.comment&#125;&quot;)\n  #else\n    /**\n     * $&#123;field.comment&#125;\n     */\n  #end\n#end\n#if($&#123;field.keyFlag&#125;)\n## 主键\n  #if($&#123;field.keyIdentityFlag&#125;)\n    @TableId(value = &quot;$&#123;field.annotationColumnName&#125;&quot;, type = IdType.AUTO)\n  #elseif(!$null.isNull($&#123;idType&#125;) &amp;&amp; &quot;$!idType&quot; != &quot;&quot;)\n    @TableId(value = &quot;$&#123;field.annotationColumnName&#125;&quot;, type = IdType.$&#123;idType&#125;)\n  #elseif($&#123;field.convert&#125;)\n    @TableId(&quot;$&#123;field.annotationColumnName&#125;&quot;)\n  #end\n## 普通字段\n#elseif($&#123;field.fill&#125;)\n## -----   存在字段填充设置   -----\n  #if($&#123;field.convert&#125;)\n    @TableField(value = &quot;$&#123;field.annotationColumnName&#125;&quot;, fill = FieldFill.$&#123;field.fill&#125;)\n  #else\n    @TableField(fill = FieldFill.$&#123;field.fill&#125;)\n  #end\n#elseif($&#123;field.convert&#125;)\n    @TableField(&quot;$&#123;field.annotationColumnName&#125;&quot;)\n#end\n## 乐观锁注解\n#if($&#123;versionFieldName&#125;==$&#123;field.name&#125;)\n    @Version\n#end\n## 逻辑删除注解\n#if($&#123;logicDeleteFieldName&#125;==$&#123;field.name&#125;)\n    @TableLogic\n#end\n    private $&#123;field.propertyType&#125; $&#123;field.propertyName&#125;;\n#end\n## ----------  END 字段循环遍历  ----------\n\n#if(!$&#123;entityLombokModel&#125;)\n#foreach($field in $&#123;table.fields&#125;)\n  #if($&#123;field.propertyType.equals(&quot;boolean&quot;)&#125;)\n    #set($getprefix=&quot;is&quot;)\n  #else\n    #set($getprefix=&quot;get&quot;)\n  #end\n\n    public $&#123;field.propertyType&#125; $&#123;getprefix&#125;$&#123;field.capitalName&#125;() &#123;\n        return $&#123;field.propertyName&#125;;\n    &#125;\n\n  #if($&#123;chainModel&#125;)\n    public $&#123;entity&#125; set$&#123;field.capitalName&#125;($&#123;field.propertyType&#125; $&#123;field.propertyName&#125;) &#123;\n  #else\n    public void set$&#123;field.capitalName&#125;($&#123;field.propertyType&#125; $&#123;field.propertyName&#125;) &#123;\n  #end\n        this.$&#123;field.propertyName&#125; = $&#123;field.propertyName&#125;;\n  #if($&#123;chainModel&#125;)\n        return this;\n  #end\n    &#125;\n#end\n## --foreach end---\n#end\n## --end of #if(!$&#123;entityLombokModel&#125;)--\n\n#if($&#123;entityColumnConstant&#125;)\n  #foreach($field in $&#123;table.fields&#125;)\n    public static final String $&#123;field.name.toUpperCase()&#125; = &quot;$&#123;field.name&#125;&quot;;\n\n  #end\n#end\n#if($&#123;activeRecord&#125;)\n    @Override\n    protected Serializable pkVal() &#123;\n  #if($&#123;keyPropertyName&#125;)\n        return this.$&#123;keyPropertyName&#125;;\n  #else\n        return null;\n  #end\n    &#125;\n\n#end\n#if(!$&#123;entityLombokModel&#125;)\n    @Override\n    public String toString() &#123;\n        return &quot;$&#123;entity&#125;&#123;&quot; +\n  #foreach($field in $&#123;table.fields&#125;)\n    #if($!&#123;foreach.index&#125;==0)\n        &quot;$&#123;field.propertyName&#125;=&quot; + $&#123;field.propertyName&#125; +\n    #else\n        &quot;, $&#123;field.propertyName&#125;=&quot; + $&#123;field.propertyName&#125; +\n    #end\n  #end\n        &quot;&#125;&quot;;\n    &#125;\n#end\n&#125;\n</code></pre>\n<h2 id=\"逆向工程\"><a href=\"#逆向工程\" class=\"headerlink\" title=\"逆向工程\"></a>逆向工程</h2><blockquote>\n<p>通用模板代码，符合我的习惯。</p>\n<p>其他具体的风格配置可以因人而异再次修改。代码中注释很多</p>\n</blockquote>\n<pre><code class=\"java\">import com.baomidou.mybatisplus.core.toolkit.StringPool;\nimport com.baomidou.mybatisplus.generator.AutoGenerator;\nimport com.baomidou.mybatisplus.generator.InjectionConfig;\nimport com.baomidou.mybatisplus.generator.config.*;\nimport com.baomidou.mybatisplus.generator.config.po.TableInfo;\nimport com.baomidou.mybatisplus.generator.config.rules.NamingStrategy;\nimport com.baomidou.mybatisplus.generator.engine.FreemarkerTemplateEngine;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Objects;\nimport java.util.Scanner;\n\npublic class Generator &#123;\n\n    /*\n    * 逆向工程\n    * 要修改前缀、后缀的东西策略中，\n    * 其他的修改去代码里面翻一翻，大多数都注释了，找不到了可以看官网\n    *  */\n    public static void main(String[] args) &#123;\n        Scanner scanner = new Scanner(System.in);\n        System.out.println(&quot;====================================&quot;);\n        System.out.println(&quot;==============1.生成部分表============&quot;);\n        System.out.println(&quot;==============2.生成全部表============&quot;);\n        System.out.println(&quot;=====================================&quot;);\n        int i = scanner.nextInt();\n        switch (i) &#123;\n            case 1:\n                System.out.println(&quot;请输入你要逆向生成的表名，用 , 号分开&quot;);\n                String name = scanner.next();\n                generator(name);\n                break;\n            case 2: generator(null);break;\n        &#125;\n    &#125;\n    public static void generator(String tableName)&#123;\n        // 代码生成器\n        AutoGenerator mpg = new AutoGenerator();\n\n        // 全局配置\n        GlobalConfig gc = new GlobalConfig();\n        String projectPath = System.getProperty(&quot;user.dir&quot;);\n        gc.setOutputDir(projectPath + &quot;/src/main/java&quot;);\n        gc.setAuthor(&quot;zjj&quot;); //作者\n        gc.setOpen(false); //是否打开目录\n        gc.setBaseResultMap(true);//xml开启BaseResultMap\n        gc.setBaseColumnList(true);//xml 开启BaseColumn\n        // gc.setSwagger2(true); //实体属性 Swagger2 注解\n        mpg.setGlobalConfig(gc);\n\n        // 数据源配置\n        DataSourceConfig dsc = new DataSourceConfig();\n        dsc.setUrl(&quot;jdbc:mysql://localhost:3306/mydb?useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=Asia/Shanghai&quot;);\n        // dsc.setSchemaName(&quot;public&quot;);\n        dsc.setDriverName(&quot;com.mysql.cj.jdbc.Driver&quot;);\n        dsc.setUsername(&quot;root&quot;);\n        dsc.setPassword(&quot;root&quot;);\n        mpg.setDataSource(dsc);\n\n        // 包配置\n        PackageConfig pc = new PackageConfig();\n        //pc.setModuleName(scanner(&quot;模块名&quot;));\n        pc.setParent(&quot;com.zjj&quot;)\n                .setEntity(&quot;pojo&quot;)\n                .setMapper(&quot;mapper&quot;)\n                .setService(&quot;service&quot;)\n                .setServiceImpl(&quot;service.impl&quot;)\n                .setController(&quot;controller&quot;);\n        mpg.setPackageInfo(pc);\n\n        // 自定义配置\n        InjectionConfig cfg = new InjectionConfig() &#123;\n            @Override\n            public void initMap() &#123;\n                // to do nothing\n            &#125;\n        &#125;;\n\n        // 如果模板引擎是 freemarker\n        String templatePath = &quot;/templates/mapper.xml.ftl&quot;;\n        // 如果模板引擎是 velocity\n        // String templatePath = &quot;/templates/mapper.xml.vm&quot;;\n\n        // 自定义输出配置\n        List&lt;FileOutConfig&gt; focList = new ArrayList&lt;&gt;();\n        // 自定义配置会被优先输出\n        focList.add(new FileOutConfig(templatePath) &#123;\n            @Override\n            public String outputFile(TableInfo tableInfo) &#123;\n                // 自定义输出文件名 ， 如果你 Entity 设置了前后缀、此处注意 xml 的名称会跟着发生变化！！\n                System.out.println(pc.getModuleName());\n                return projectPath + &quot;/src/main/resources/mapper&quot; + pc.getModuleName()\n                        + &quot;/&quot; + tableInfo.getEntityName() + &quot;Mapper&quot; + StringPool.DOT_XML;\n            &#125;\n        &#125;);\n\n        cfg.setFileOutConfigList(focList);\n        mpg.setCfg(cfg);\n\n        // 配置模板\n        TemplateConfig templateConfig = new TemplateConfig();\n        // 配置自定义输出模板\n        //指定自定义模板路径，注意不要带上.ftl/.vm, 会根据使用的模板引擎自动识别\n        templateConfig.setEntity(&quot;/templates/MyEntity.java&quot;);\n        // templateConfig.setService();\n        // templateConfig.setController();\n        templateConfig.setXml(null);\n        mpg.setTemplate(templateConfig);\n\n        // 策略配置\n        StrategyConfig strategy = new StrategyConfig();\n        //数据库表映射到实体的命名策略\n        strategy.setNaming(NamingStrategy.underline_to_camel);\n        //数据库表字段映射到实体的命名策略\n        strategy.setColumnNaming(NamingStrategy.no_change);\n        //strategy.setSuperEntityClass(&quot;你自己的父类实体,没有就不用设置!&quot;);\n        //lombok模型\n        strategy.setEntityLombokModel(true);\n        //生成RestController\n        strategy.setRestControllerStyle(true);\n        // 公共父类\n        //strategy.setSuperControllerClass(&quot;你自己的父类控制器,没有就不用设置!&quot;);\n        // 写于父类中的公共字段\n        //strategy.setSuperEntityColumns(&quot;id&quot;);\n        if (!Objects.isNull(tableName)) &#123;\n            //strategy.setInclude(scanner(&quot;表名，多个英文逗号分割&quot;).split(&quot;,&quot;));\n            strategy.setInclude(tableName.split(&quot;,&quot;));\n        &#125;\n\n        strategy.setControllerMappingHyphenStyle(true);\n        //表前缀\n        // strategy.setTablePrefix(&quot;t_&quot;);\n        mpg.setStrategy(strategy);\n        mpg.setTemplateEngine(new FreemarkerTemplateEngine());\n        mpg.execute();\n    &#125;\n&#125;\n</code></pre>\n",
            "tags": [
                "框架",
                "ORM"
            ]
        },
        {
            "id": "http://example.com/2022/10/07/ORM/Mybatis/",
            "url": "http://example.com/2022/10/07/ORM/Mybatis/",
            "title": "Mybatis",
            "date_published": "2022-10-06T16:00:00.000Z",
            "content_html": "<h1 id=\"1-Mybatis入门\"><a href=\"#1-Mybatis入门\" class=\"headerlink\" title=\"1 Mybatis入门\"></a>1 Mybatis入门</h1><p>原生JDBC实现CURD的问题</p>\n<blockquote>\n<p>1 编码繁琐<br>2 需要我们自己将结果集映射成对象<br>3 性能不太好  连接池 缓存<br>4 SQL语句和java代码的耦合度特别高<br>5 … …</p>\n</blockquote>\n<p>MyBatis 本是Apache的一个开源项目iBatis, 2010年这个项目由Apache Software Foundation 迁移到了Google Code，且改名为MyBatis 。2013年11月迁移到GitHub。iBATIS一词来源于“internet”和“abatis”的组合，是一个基于Java的持久层框架。<br>MyBatis 是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 POJOs(Plain Ordinary Java Object,普通的 Java对象)映射成数据库中的记录。</p>\n<img data-src=\"/2022/10/07/ORM/Mybatis/image-20220617191731748.png\" class=\"\" title=\"image-20220617191731748\">\n\n\n\n\n\n<h2 id=\"1-认识框架\"><a href=\"#1-认识框架\" class=\"headerlink\" title=\"1 认识框架\"></a>1 认识框架</h2><p>框架（Framework）是一个框子——指其约束性，也是一个架子——指其支撑性。是一个基本概念上的结构，用于去解决或者处理复杂的问题。框架这个广泛的定义使用的十分流行，尤其在软件概念。<br>框架( Framework )对于java来说,就是一系列为了解决特定问题而定义的一系列接口和实现类,在组织框架代码时,使用了一系列优秀的设计模式,使代码无论在性能上还是API操作上得到很大提升.框架可以看做是项目开发的半成品,基本的底层操作已经封装完毕,通过框架,程序员可以从底层代码中解脱出来,专注于业务逻辑的完成和性能的优化。框架规定了你的应用的体系结构。它定义了整体结构，类和对象的分割，各部分的主要责任，类和对象怎么协作，以及控制流程。框架预定义了这些设计参数，以便于应用设计者或实现者能集中精力于应用本身的特定细节。</p>\n<p>如果将开发完成的软件比作是一套已经装修完毕的新房，那框架就好比是一套已经修建好的毛坯房。用户直接购买毛坯房，建筑质量和户型合理有保证，还省去了自己建造房屋的时间，一举多得。<br>在开发过程是使用框架，同样可以保证减少开发时间、降低开发难度，并且还保证设计质量。好比和世界上最优秀的软件工程师是一个项目的，并且他们完成的还是基础、全局的工作。想想是不是很嗨的一件事情。</p>\n<img data-src=\"/2022/10/07/ORM/Mybatis/image-20220617191818381.png\" class=\"\" title=\"image-20220617191818381\">\n\n\n\n\n\n<p>框架还有一个作用是约束。莎士比亚说,”一千个观众眼中有一千个哈姆雷特” 即仁者见仁,智者见智.说每个人都会对作品有不同的理解，每个人对待任何事物都有自己的看法，一千个人就有可能有一千种不同的看法1000人心中有1000个哈姆雷特。同样的技术解决同样的问题会产生不同流程和风格的解决方案，而采用一种框架其实就是限制用户必须使用其规定的方案来实现，<strong>可以降低程序员之间沟通以及日后维护的成本。</strong></p>\n<p>常用的基于JavaEE的三大开源框架，已经从SSH、SSH2过渡到了SSM：SpringMVC、Spring、MyBatis &gt;&gt;&gt; springBoot</p>\n<p><font face=\"微软雅黑\" size=6 color=#FF0000>总之，框架是一个半成品，已经对基础的代码进行了封装并提供相应的API，开发者在使用框架是直接调用封装好的API可以省去很多代码编写，从而提高工作效率和开发速度。</font></p>\n<h2 id=\"2-认识ORM\"><a href=\"#2-认识ORM\" class=\"headerlink\" title=\"2 认识ORM\"></a>2 认识ORM</h2><p>DBC的缺点：</p>\n<p>需要手动的完成面向对象的Java语言、面向关系的数据库之间数据的转换，代码繁琐无技术含量，影响了开发效率。</p>\n<p>如图所示，查询是需要手动的将结果集的列数据转换为Java对象的属性；而添加操作时需要手动将Java对象的属性转换为数据库表的列字段。</p>\n<p>关于面向对象的Java语言、面向关系的数据库之间数据的转换必须要做，问题在于这个转换是否可以不由开发者来做。可以的。ORM框架就是专门来做这个问题的，相当于在面向对象语言和关系数据库之间搭建一个桥梁。</p>\n<p>&#x3D;&#x3D;ORM，Object-Relationl Mapping，对象关系映射，它的作用是在关系型数据库和对象之间作一个映射，这样我们在具体的操作数据库的时候，只要像平时操作对象一样操作它就可以了，ORM框架会根据映射完成对数据库的操作，就不需要再去和复杂的SQL语句打交道了&#x3D;&#x3D;。</p>\n<img data-src=\"/2022/10/07/ORM/Mybatis/image-20220617192304044.png\" class=\"\" title=\"image-20220617192304044\">\n\n\n<p>另外学习ORM必须知道两个概念：持久化、持久层</p>\n<p><strong>什么是“持久化”</strong></p>\n<p>持久（Persistence），<font color=#FF0000>即把数据（如内存中的对象）保存到可永久保存的存储设备中（如磁盘）</font>。持久化的主要应用是将内存中的数据存储在关系型的数据库中，当然也可以存储在磁盘文件中、XML数据文件中等等。</p>\n<p><strong>什么是 “持久层”</strong></p>\n<p>持久层（Persistence Layer），即专注于实现数据持久化应用领域的某个特定系统的一个逻辑层面，将数据使用者和数据实体相关联。之前使用JDBC访问数据库的DAO层，后面采用MyBatis访问数据库的mapper层，就是持久层。</p>\n<p><strong>Mybatis是一持久层的款半自动的ORM映射框架</strong></p>\n<h2 id=\"3-认识MyBatis\"><a href=\"#3-认识MyBatis\" class=\"headerlink\" title=\"3 认识MyBatis\"></a>3 认识MyBatis</h2><blockquote>\n<p>MyBatis 本是Apache的一个开源项目iBatis, 2010年这个项目由Apache Software Foundation 迁移到了Google Code，且改名为MyBatis 。2013年11月迁移到GitHub。iBATIS一词来源于“internet”和“abatis”的组合，是一个基于Java的持久层框架。</p>\n</blockquote>\n<p>MyBatis 是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 POJOs(Plain Ordinary Java Object,普通的 Java对象)映射成数据库中的记录。</p>\n<img data-src=\"/2022/10/07/ORM/Mybatis/image-20220617192446302.png\" class=\"\" title=\"image-20220617192446302\">\n\n<p>精简解释：MyBatis是一个半自动ORM框架，其本质是对JDBC的封装。使用MyBatis重点需要程序员编写SQL命令，不需要写一行JDBC代码</p>\n<h1 id=\"2-MyBatis初次使用\"><a href=\"#2-MyBatis初次使用\" class=\"headerlink\" title=\"2 MyBatis初次使用\"></a>2 MyBatis初次使用</h1><h2 id=\"1-创建maven项目导入相关依赖\"><a href=\"#1-创建maven项目导入相关依赖\" class=\"headerlink\" title=\"1 创建maven项目导入相关依赖\"></a>1 创建maven项目导入相关依赖</h2><p>但凡是框架,使用都是分三步走</p>\n<p>1导入jar文件,maven</p>\n<p>2处理配置文件</p>\n<p>3开发业务代码</p>\n<p>先创建一个空项目,用于存放后面Mybatis相关项目模块</p>\n<img data-src=\"/2022/10/07/ORM/Mybatis/image-20220617192550409.png\" class=\"\" title=\"image-20220617192550409\">\n\n\n<p>项目名为mybatisAll即可</p>\n<img data-src=\"/2022/10/07/ORM/Mybatis/image-20220617192555641.png\" class=\"\" title=\"image-20220617192555641\">\n\n\n\n\n<p>这里不显示项目名 没关系,如果想看到项目名,可以close项目后,再次open即可</p>\n<img data-src=\"/2022/10/07/ORM/Mybatis/image-20220617192604832.png\" class=\"\" title=\"image-20220617192604832\">\n\n\n\n\n<p>关闭项目</p>\n<img data-src=\"/2022/10/07/ORM/Mybatis/image-20220617192611548.png\" class=\"\" title=\"image-20220617192611548\">\n\n\n<p>再次open</p>\n<img data-src=\"/2022/10/07/ORM/Mybatis/image-20220617192630884.png\" class=\"\" title=\"image-20220617192630884\">\n\n\n\n\n\n\n<p>项目名就显示了</p>\n<img data-src=\"/2022/10/07/ORM/Mybatis/image-20220617192636190.png\" class=\"\" title=\"image-20220617192636190\">\n\n\n<p>接下来设置maven为我们自己安装的,不用idea自带的(当然用自带的也行)</p>\n<img data-src=\"/2022/10/07/ORM/Mybatis/image-20220617192641520.png\" class=\"\" title=\"image-20220617192641520\">\n\n\n\n<img data-src=\"/2022/10/07/ORM/Mybatis/image-20220617192647200.png\" class=\"\" title=\"image-20220617192647200\">\n\n\n<p>在当前项目中创建模块</p>\n<img data-src=\"/2022/10/07/ORM/Mybatis/image-20220617192652567.png\" class=\"\" title=\"image-20220617192652567\">\n\n\n<p>选择maven项目 next</p>\n<img data-src=\"/2022/10/07/ORM/Mybatis/image-20220617192703265.png\" class=\"\" title=\"image-20220617192703265\">\n\n\n\n\n\n\n<p>输入groupid和aitifactid  然后finish</p>\n<img data-src=\"/2022/10/07/ORM/Mybatis/image-20220617192713221.png\" class=\"\" title=\"image-20220617192713221\">\n\n\n<p>检查项目目前在磁盘上的存放路径 然后next</p>\n<img data-src=\"/2022/10/07/ORM/Mybatis/image-20220617192719403.png\" class=\"\" title=\"image-20220617192719403\">\n\n\n\n\n<p>检查项目目录结构是否有缺失</p>\n<img data-src=\"/2022/10/07/ORM/Mybatis/image-20220617192723928.png\" class=\"\" title=\"image-20220617192723928\">\n\n\n<p>MyBatis官网说明文档   <span class=\"exturl\" data-url=\"aHR0cHM6Ly9teWJhdGlzLm9yZy9teWJhdGlzLTMvemgvaW5kZXguaHRtbA==\">https://mybatis.org/mybatis-3/zh/index.html</span></p>\n<p>在pom.xml中导入MyBatis相关依赖jar文件</p>\n<pre><code class=\"xml\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;\n         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;\n    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n    &lt;groupId&gt;com.msb&lt;/groupId&gt;\n    &lt;artifactId&gt;mybatisTest01&lt;/artifactId&gt;\n    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;\n    &lt;packaging&gt;jar&lt;/packaging&gt;\n    &lt;dependencies&gt;\n        &lt;!--mysqlConnector--&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;mysql&lt;/groupId&gt;\n            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;\n            &lt;version&gt;8.0.16&lt;/version&gt;\n        &lt;/dependency&gt;\n        &lt;!--mybatis 核心jar包--&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;\n            &lt;artifactId&gt;mybatis&lt;/artifactId&gt;\n            &lt;version&gt;3.5.3&lt;/version&gt;\n        &lt;/dependency&gt;\n        &lt;!--junit--&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;junit&lt;/groupId&gt;\n            &lt;artifactId&gt;junit&lt;/artifactId&gt;\n            &lt;version&gt;4.13.1&lt;/version&gt;\n            &lt;scope&gt;test&lt;/scope&gt;\n        &lt;/dependency&gt;\n        &lt;!--lombok --&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;\n            &lt;artifactId&gt;lombok&lt;/artifactId&gt;\n            &lt;version&gt;1.18.12&lt;/version&gt;\n            &lt;scope&gt;provided&lt;/scope&gt;\n        &lt;/dependency&gt;\n    &lt;/dependencies&gt;\n&lt;/project&gt;\n</code></pre>\n<p>安装lombok插件后,重启idea</p>\n<img data-src=\"/2022/10/07/ORM/Mybatis/image-20220617192808470.png\" class=\"\" title=\"image-20220617192808470\">\n\n\n\n\n<p>导入lombok依赖后,单独设置启用注解处理</p>\n<img data-src=\"/2022/10/07/ORM/Mybatis/image-20220617192814365.png\" class=\"\" title=\"image-20220617192814365\">\n\n\n\n<h2 id=\"2-准备数据库-包结构和实体类\"><a href=\"#2-准备数据库-包结构和实体类\" class=\"headerlink\" title=\"2  准备数据库_包结构和实体类\"></a>2  准备数据库_包结构和实体类</h2><p>数据库</p>\n<p><img data-src=\"/../spring/img/image-20220617192857161.png\" alt=\"image-20220617192857161\"></p>\n<p>项目结构</p>\n<img data-src=\"/2022/10/07/ORM/Mybatis/image-20220617192901785.png\" class=\"\" title=\"image-20220617192901785\">\n\n<p> 实体类Dept</p>\n<pre><code class=\"java\"> package com.msb.pojo;\nimport lombok.AllArgsConstructor;\nimport lombok.Data;\nimport lombok.NoArgsConstructor;\nimport java.io.Serializable;\n/**\n\n * @Author: Ma HaiYang\n * @Description: MircoMessage:Mark_7001\n    */\n    @Data\n    @AllArgsConstructor\n    @NoArgsConstructor\n    public class Dept implements Serializable &#123;\n    private Integer deptno;\n    private String dname;\n    private String loc;\n    &#125;\n</code></pre>\n<h2 id=\"3-准备Mapper映射文件和核心配置文件\"><a href=\"#3-准备Mapper映射文件和核心配置文件\" class=\"headerlink\" title=\"3 准备Mapper映射文件和核心配置文件\"></a>3 准备Mapper映射文件和核心配置文件</h2><p>resources目录下 创建 com&#x2F;msb&#x2F;mapper目录,然后添加DeptMapper.xml映射文件</p>\n<img data-src=\"/2022/10/07/ORM/Mybatis/image-20220617193030929.png\" class=\"\" title=\"image-20220617193030929\">\n\n<pre><code class=\"xml\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;\n&lt;!DOCTYPE mapper\n        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;\n        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;\n&lt;mapper namespace=&quot;aaa&quot;&gt;\n    &lt;!--public List&lt;Dept&gt; findAll()&#123;    &#125;--&gt;\n    &lt;select id=&quot;findAll&quot; resultType=&quot;com.msb.pojo.Dept&quot; &gt;\n        select * from dept\n    &lt;/select&gt;\n&lt;/mapper&gt;\n</code></pre>\n<p>resources目录下准备sqlMapConfig.xml 核心配置文件</p>\n<pre><code class=\"xml\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;\n&lt;!DOCTYPE configuration\n        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;\n        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;\n&lt;configuration&gt;\n    &lt;environments default=&quot;development&quot;&gt;\n        &lt;environment id=&quot;development&quot;&gt;\n            &lt;transactionManager type=&quot;JDBC&quot;/&gt;\n            &lt;dataSource type=&quot;POOLED&quot;&gt;\n                &lt;property name=&quot;driver&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt;\n                &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://127.0.0.1:3306/mydb?useSSL=false&amp;amp;useUnicode=true&amp;amp;characterEncoding=UTF-8&amp;amp;serverTimezone=Asia/Shanghai&quot;/&gt;\n                &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;\n                &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt;\n            &lt;/dataSource&gt;\n        &lt;/environment&gt;\n    &lt;/environments&gt;\n    &lt;!--加载mapper映射文件--&gt;\n    &lt;mappers&gt;\n        &lt;mapper resource=&quot;com/msb/mapper/DeptMapper.xml&quot;/&gt;\n    &lt;/mappers&gt;\n&lt;/configuration&gt;\n</code></pre>\n<h2 id=\"4-运行测试\"><a href=\"#4-运行测试\" class=\"headerlink\" title=\"4 运行测试\"></a>4 运行测试</h2><img data-src=\"/2022/10/07/ORM/Mybatis/image-20220617193244713.png\" class=\"\" title=\"image-20220617193244713\">\n\n<p>在test目录下开发测试代码并运行</p>\n<p><img data-src=\"/../spring/img/image-20220617193259351.png\" alt=\"image-20220617193259351\"></p>\n<pre><code class=\"java\"> package com.msb.test;\nimport com.msb.pojo.Dept;\nimport org.apache.ibatis.io.Resources;\nimport org.apache.ibatis.session.SqlSession;\nimport org.apache.ibatis.session.SqlSessionFactory;\nimport org.apache.ibatis.session.SqlSessionFactoryBuilder;\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Test;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.List;\n/**\n\n * @Author: Ma HaiYang\n * @Description: MircoMessage:Mark_7001\n    */\n    public class Test1 &#123;\n    private SqlSession sqlSession;\n    @Before\n    public void init()&#123;\n        SqlSessionFactoryBuilder ssfb =new SqlSessionFactoryBuilder();\n        InputStream resourceAsStream = null;\n        try &#123;\n            resourceAsStream = Resources.getResourceAsStream(&quot;sqlMapConfig.xml&quot;);\n        &#125; catch (IOException e) &#123;\n            e.printStackTrace();\n        &#125;\n        SqlSessionFactory factory=ssfb.build(resourceAsStream) ;\n        sqlSession=factory.openSession();\n    &#125;\n    @Test\n    public void testFindAll()&#123;\n        // 调用SQL语句\n        List&lt;Dept&gt; list = sqlSession.selectList(&quot;findAll&quot;);\n        for (Dept dept : list) &#123;\n            System.out.println(dept);\n        &#125;\n    &#125;\n    @After\n    public void release()&#123;\n        // 关闭SQLSession\n        sqlSession.close();\n    &#125;\n    &#125;\n</code></pre>\n<h1 id=\"3-MyBatis配置详解\"><a href=\"#3-MyBatis配置详解\" class=\"headerlink\" title=\"3 MyBatis配置详解\"></a>3 MyBatis配置详解</h1><h3 id=\"1-log4j1和log4j2的简单配置\"><a href=\"#1-log4j1和log4j2的简单配置\" class=\"headerlink\" title=\"1_log4j1和log4j2的简单配置\"></a>1_log4j1和log4j2的简单配置</h3><p>项目中添加依赖</p>\n<pre><code class=\"xml\">&lt;!-- log4j2 --&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;\n    &lt;artifactId&gt;log4j-core&lt;/artifactId&gt;\n    &lt;version&gt;2.12.1&lt;/version&gt;\n&lt;/dependency&gt;\n&lt;!-- log4j1 --&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;log4j&lt;/groupId&gt;\n    &lt;artifactId&gt;log4j&lt;/artifactId&gt;\n    &lt;version&gt;1.2.17&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>\n<pre><code>在mybatis.cfg.xml中配置MyBatis所使用的具体日志实现。如果不指定将自动搜索。可能会搜到log4j，但是如果优先搜到了其他的日志实现呢，所以还是设置为好。这一来log4j就跑不了了。\n</code></pre>\n<p>log4j 1</p>\n<pre><code>将log4j.properties文件负责到src下。另外在其中可以将全局的日志级别调高，避免大量debug信息的干扰。同时将对映射文件的操作调低，可以用来显示SQL语句的调试信息。开发阶段，建议启动控制的日志。\n</code></pre>\n<p> #定义全局日志级别调试阶段推荐debug</p>\n<pre><code class=\"properties\">log4j.rootLogger=debug,stdout \nlog4j.appender.stdout=org.apache.log4j.ConsoleAppender\nlog4j.appender.stdout.Target=System.err\nlog4j.appender.stdout.layout=org.apache.log4j.SimpleLayout\nlog4j.appender.logfile=org.apache.log4j.FileAppender\nlog4j.appender.logfile.File=d:/msb.log\nlog4j.appender.logfile.layout=org.apache.log4j.PatternLayout\nlog4j.appender.logfile.layout.ConversionPattern=%d&#123;yyyy-MM-dd HH:mm:ss&#125; %l %F %p %m%n\n</code></pre>\n<p>在核心配置文件中可以选择的其他日志处理方式</p>\n<p>log4j 2</p>\n<p>将log4j2.xml文件负责到resources下。</p>\n<pre><code class=\"xml\"> &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;Configuration status=&quot;DEBUG&quot;&gt;\n    &lt;Appenders&gt;\n        &lt;Console name=&quot;Console&quot; target=&quot;SYSTEM_ERR&quot;&gt;\n            &lt;PatternLayout pattern=&quot;%d&#123;YYYY-MM-dd HH:mm:ss&#125; [%t] %-5p %c&#123;1&#125;:%L - %msg%n&quot; /&gt;\n        &lt;/Console&gt;\n        &lt;RollingFile name=&quot;RollingFile&quot; filename=&quot;log/test.log&quot;\n                     filepattern=&quot;$&#123;logPath&#125;/%d&#123;YYYYMMddHHmmss&#125;-fargo.log&quot;&gt;\n            &lt;PatternLayout pattern=&quot;%d&#123;YYYY-MM-dd HH:mm:ss&#125; [%t] %-5p %c&#123;1&#125;:%L - %msg%n&quot; /&gt;\n            &lt;Policies&gt;\n                &lt;SizeBasedTriggeringPolicy size=&quot;10 MB&quot; /&gt;\n            &lt;/Policies&gt;\n            &lt;DefaultRolloverStrategy max=&quot;20&quot; /&gt;\n        &lt;/RollingFile&gt;\n    &lt;/Appenders&gt;\n    &lt;Loggers&gt;\n        &lt;Root level=&quot;INFO&quot;&gt;\n            &lt;AppenderRef ref=&quot;Console&quot; /&gt;\n        &lt;/Root&gt;\n    &lt;/Loggers&gt;\n&lt;/Configuration&gt;\n</code></pre>\n<p>核心配置文件中可以指定日志打印方式</p>\n<img data-src=\"/2022/10/07/ORM/Mybatis/image-20220617193736735.png\" class=\"\" title=\"image-20220617193736735\">\n\n\n\n<h2 id=\"2-关于事务配置\"><a href=\"#2-关于事务配置\" class=\"headerlink\" title=\"2_关于事务配置\"></a>2_关于事务配置</h2><img data-src=\"/2022/10/07/ORM/Mybatis/image-20220617193831478.png\" class=\"\" title=\"image-20220617193831478\">\n\n<p>在mybatis核心配置文件中 envirment中 通过transactionManager配置事务的处理策略</p>\n<p><font color=#FF000>JDBC</font> – 这个配置直接简单使用了 JDBC 的提交和回滚设置。它依赖于从数据源得到的连接来管理事务范围。</p>\n<p><font color=#FF000>MANAGED </font>– 这个配置几乎没做什么。它从来不提交或回滚一个连接。而它会让容器来管理事务的整个生命周期(比如 Spring 或 JEE 应用服务器的上下文) 默认情况下它会关闭连接。然而一些容器并不希望这样, 因此如果你需要从连接中停止它,将closeConnection 属性设置为 false. mybatis本身并不做事务的处理,交给其他框架去处理事务,如spring</p>\n<h2 id=\"3-关于映射文件的加载方式\"><a href=\"#3-关于映射文件的加载方式\" class=\"headerlink\" title=\"3_关于映射文件的加载方式\"></a>3_关于映射文件的加载方式</h2><p>1.mapper映射文件的文件路径导入 使用的mapper标签的resource属性</p>\n<p>2.网络资源路径 使用的mapper标签的url属性</p>\n<p>3.接口的全限定名导入 使用的是mapper标签的class属性 (基于接口的代理模式开发)</p>\n<p>4.包扫描形式加载所有的mapper映射文件 使用的是 package标签</p>\n<img data-src=\"/2022/10/07/ORM/Mybatis/image-20220617193946594.png\" class=\"\" title=\"image-20220617193946594\">\n\n<h2 id=\"4-关于实体类别名处理\"><a href=\"#4-关于实体类别名处理\" class=\"headerlink\" title=\"4_关于实体类别名处理\"></a>4_关于实体类别名处理</h2><p>在mybatis核心配置文件中使用别名处理</p>\n<pre><code class=\"xml\"> &lt;!--设置实体类别名--&gt;\n&lt;typeAliases&gt;\n    &lt;!--\n    通过包扫描给所有的实体类起别名\n    给指定报名下的所有类起别名\n    默认每个实体类的别名是首字母小写的类名\n    Dept   dept\n    Emp    emp\n    --&gt;\n    &lt;package name=&quot;com.msb.pojo&quot;/&gt;\n&lt;/typeAliases&gt;\n</code></pre>\n<p>在映射文件的resultType 返回值类型  和paramterType 上就可以使用别名了</p>\n<pre><code class=\"xml\">&lt;select id=&quot;selectByEmpno&quot;  resultType=&quot;emp&quot;&gt;\n    select * from emp where empno = 7566\n&lt;/select&gt;\n</code></pre>\n<h2 id=\"5-关于外部属性配置文件存储数据库连接信息\"><a href=\"#5-关于外部属性配置文件存储数据库连接信息\" class=\"headerlink\" title=\"5_关于外部属性配置文件存储数据库连接信息\"></a>5_关于外部属性配置文件存储数据库连接信息</h2><p>在resources下准备jdbc.properties属性配置文件</p>\n<img data-src=\"/2022/10/07/ORM/Mybatis/image-20220617194131042.png\" class=\"\" title=\"image-20220617194131042\">\n\n\n<p>配置文件中的内容</p>\n<pre><code class=\"properties\">jdbc_driver=com.mysql.cj.jdbc.Driver\njdbc_url=jdbc:mysql://127.0.0.1:3306/mydb?useSSL=false&amp;useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=Asia/Shanghai\njdbc_username=root\njdbc_password=root\n</code></pre>\n<p>在核心配置文件中引入db.properties属性文件</p>\n<pre><code class=\"xml\"> &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;\n&lt;!-- xml文档约束 约束xml文档中可以有哪些标签,哪些属性,以及标签的包含关系和顺序....\ndtd 约束\nschema 约束\n--&gt;\n\n&lt;!DOCTYPE configuration\n        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;\n        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;\n&lt;configuration&gt;\n    &lt;properties resource=&quot;jdbc.properties&quot;&gt;&lt;/properties&gt;\n    &lt;settings&gt;\n        &lt;!--设置日志处理方式--&gt;\n        &lt;setting name=&quot;logImpl&quot; value=&quot;LOG4J&quot;/&gt;\n    &lt;/settings&gt;\n    &lt;!--设置实体类别名--&gt;\n    &lt;typeAliases&gt;\n        &lt;!--\n        通过包扫描给所有的实体类起别名\n        给指定报名下的所有类起别名\n        默认每个实体类的别名是首字母小写的类名\n        Dept   dept\n        Emp    emp\n        --&gt;\n        &lt;package name=&quot;com.msb.pojo&quot;/&gt;\n    &lt;/typeAliases&gt;\n    &lt;!--配置数据库链接信息--&gt;\n    &lt;environments default=&quot;mysql&quot;&gt;\n        &lt;!--数据源1--&gt;\n        &lt;environment id=&quot;mysql&quot;&gt;\n            &lt;transactionManager type=&quot;JDBC&quot;/&gt;\n            &lt;!--一个数据源--&gt;\n            &lt;dataSource type=&quot;POOLED&quot;&gt;\n                &lt;property name=&quot;driver&quot; value=&quot;$&#123;jdbc_driver&#125;&quot;/&gt;\n                &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc_url&#125;&quot;/&gt;\n                &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc_username&#125;&quot;/&gt;\n                &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc_password&#125;&quot;/&gt;\n            &lt;/dataSource&gt;\n        &lt;/environment&gt;\n    &lt;/environments&gt;\n    &lt;!--加载映射文件的--&gt;\n    &lt;mappers&gt;\n        &lt;mapper resource=&quot;com/msb/mapper/DeptMapper.xml&quot;/&gt;\n    &lt;/mappers&gt;\n&lt;/configuration&gt;\n</code></pre>\n<h1 id=\"4-MyBatis传统DAO模式开发\"><a href=\"#4-MyBatis传统DAO模式开发\" class=\"headerlink\" title=\"4 MyBatis传统DAO模式开发\"></a>4 MyBatis传统DAO模式开发</h1><blockquote>\n<pre><code>普通模式,也称为传统DAO模式,就是在传统DAO模式下,定义接口和实现类,如 interface EmpDao  class EmpDaoImpl implements EmpDao.  在实现类中,用SQLSession对象调用select insert delete update 等方法实现.目前极为少见.在传统模式下,我们需要知道SqlSession对象 实现CURD和 参数传递的处理\n</code></pre>\n</blockquote>\n<h2 id=\"1-sqlSession查询的三种方式\"><a href=\"#1-sqlSession查询的三种方式\" class=\"headerlink\" title=\"1_sqlSession查询的三种方式\"></a>1_sqlSession查询的三种方式</h2><p>SqlSession对象本身的API中就有三个查询方法,分别能够实现如下查询方式</p>\n<p>1返回单个对象 selectOne</p>\n<p>2返回对象List集合 selectList</p>\n<p>3返回对象Map集合 selectMap</p>\n<p>接下来我们就对这三个方法进行一个快速的学习</p>\n<img data-src=\"/2022/10/07/ORM/Mybatis/image-20220617194257643.png\" class=\"\" title=\"image-20220617194257643\">\n\n\n<p>创建Emp实体类</p>\n<pre><code class=\"java\">@AllArgsConstructor\n@NoArgsConstructor\n@Data\npublic class Emp implements Serializable &#123;\n    private Integer empno;\n    private String ename;\n    private String job;\n    private Integer mgr;\n    private Date hiredate;\n    private Double sal;\n    private Double comm;\n    private Integer deptno;\n&#125;\n</code></pre>\n<p>准备Mapper映射文件</p>\n<pre><code class=\"xml\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;\n&lt;!DOCTYPE mapper\n        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;\n        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;\n&lt;mapper namespace=&quot;EmpMapper&quot;&gt;\n    &lt;!--\n    返回单个对象\n    public Emp findOne();\n    id 相当于方法名\n    resultType 相当于返回值类型\n        sql语句的查询结果用哪个类来进行封装 如果返回值类型是集合,这里写的也是集合中的元素对应的类,不是集合本身作为类型\n    paramaterType 参数类型\n    SQL语句就是具体的方法体的实现\n    --&gt;\n    &lt;select id=&quot;findOne&quot; resultType=&quot;emp&quot; &gt;\n        select * from emp where empno = 7499\n    &lt;/select&gt;\n    &lt;!--\n    返回多个对象List集合\n    查询全部的员工信息\n    public List&lt;Emp&gt; findAll()\n    --&gt;\n    &lt;select id=&quot;findAll&quot; resultType=&quot;emp&quot;&gt;\n        select * from emp\n    &lt;/select&gt;\n    &lt;!--返回多个对象的Map集合\n    把查询出来的数据中的某一列作为键,整条数据封装的对象作为值\n    public Map&lt;key,Emp&gt; findEmpMap()\n    &lt;empno,Emp&gt;\n    &lt;key,Emp&gt;\n    --&gt;\n    &lt;select id=&quot;findEmpMap&quot; resultType=&quot;map&quot;&gt;\n        select * from emp\n    &lt;/select&gt;\n&lt;/mapper&gt;\n</code></pre>\n<p>sqlMapConfig中导入EmpMapper映射文件</p>\n<pre><code class=\"xml\">&lt;!--加载mapper映射文件--&gt;\n&lt;mappers&gt;\n    &lt;mapper resource=&quot;com/msb/mapper/DeptMapper.xml&quot;/&gt;\n    &lt;mapper resource=&quot;com/msb/mapper/EmpMapper.xml&quot;/&gt;\n&lt;/mappers&gt;\n</code></pre>\n<p>测试代码</p>\n<pre><code class=\"java\">package com.msb.test;\nimport com.msb.pojo.Dept;\nimport com.msb.pojo.Emp;\nimport org.apache.ibatis.io.Resources;\nimport org.apache.ibatis.session.SqlSession;\nimport org.apache.ibatis.session.SqlSessionFactory;\nimport org.apache.ibatis.session.SqlSessionFactoryBuilder;\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Test;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n/**\n\n * @Author: Ma HaiYang\n * @Description: MircoMessage:Mark_7001\n    */\n    public class Test2 &#123;\n    private SqlSession sqlSession;\n    @Before\n    public void init()&#123;\n        SqlSessionFactoryBuilder ssfb =new SqlSessionFactoryBuilder();\n        InputStream resourceAsStream = null;\n        try &#123;\n            resourceAsStream = Resources.getResourceAsStream(&quot;sqlMapConfig.xml&quot;);\n        &#125; catch (IOException e) &#123;\n            e.printStackTrace();\n        &#125;\n        SqlSessionFactory factory=ssfb.build(resourceAsStream) ;\n        sqlSession=factory.openSession();\n    &#125;\n    @Test\n    public void testSelectOne()&#123;\n        // 查询单个对象\n        System.out.println(&quot;sqlSession查询单个对象&quot;);\n        Emp emp = sqlSession.selectOne(&quot;findOne&quot;);\n        System.out.println(emp);\n    &#125;\n    @Test\n    public void testSelectList()&#123;\n        // 查询多个对象的List集合\n        System.out.println(&quot;sqlSession查询对象List集合&quot;);\n        List&lt;Emp&gt; emps = sqlSession.selectList(&quot;EmpMapper.findAll&quot;);\n        emps.forEach(System.out::println);\n    &#125;\n    @Test\n    public void testSelectMap()&#123;\n        // 查询多个对象的Map集合\n        System.out.println(&quot;sqlSession查询对象Map集合&quot;);\n        Map&lt;Integer, Emp&gt; empMap = sqlSession.selectMap(&quot;findEmpMap&quot;, &quot;EMPNO&quot;);\n        Set&lt;Integer&gt; empnos = empMap.keySet();\n        for (Integer empno : empnos) &#123;\n            System.out.println(empno+&quot; :&quot; +empMap.get(empno));\n        &#125;\n    &#125;\n    @After\n    public void release()&#123;\n        // 关闭SQLSession\n        sqlSession.close();\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"2-sqlSession传递参数的三种方式\"><a href=\"#2-sqlSession传递参数的三种方式\" class=\"headerlink\" title=\"2_sqlSession传递参数的三种方式\"></a>2_sqlSession传递参数的三种方式</h2><p>1 单个基础数据类型作为参数</p>\n<p>2 多个基础数据类型的map 集合作为参数</p>\n<p>3 引用类型作为参数</p>\n<p>Mapper映射文件</p>\n<pre><code class=\"xml\"> &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;\n&lt;!DOCTYPE mapper\n        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;\n        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;\n&lt;mapper namespace=&quot;EmpMapper2&quot;&gt;\n    &lt;!--\n    参数为一个基本数据类型\n    根据员工工号查询员工的全部信息,返回单个员工对象\n    public Emp findByEmpno(int empno);\n    parameterType 在有参数情况下也是可以省略不写  mybatis 可以根据实际情况自动判断\n    如果要写parameterType 那么就要写对\n    在SQL语句上可以使用$&#123;&#125;  #&#123;&#125; 代表参数的占位\n    如果参数是单个基本数据类型,&#123;&#125;中名字可以随便写,见名知意\n    $&#123;&#125; 代表mybatis底层使用Statment语句对象,参数是以字符串拼接的形式设置\n    #&#123;&#125; 代表mybatis底层使用的preparedStatment语句对象,参数使用?作为占位符处理\n    #&#123;&#125; 以后常用\n    --&gt;\n    &lt;select id=&quot;findByEmpno&quot; resultType=&quot;emp&quot; parameterType=&quot;int&quot;&gt;\n        select  * from emp where empno = #&#123;empno&#125;\n    &lt;/select&gt;\n    &lt;!--\n    参数为map集合\n    查询指定部门号和指定最低薪资的员工信息\n    20 号部门 且工资在1500以上的员工信息\n    public List&lt;Emp&gt; findEmpByDeptnoAndSal(int deptno,double sal);\n    &lt;  &gt;  最好要进行转译处理,参照HTML转译  w3school在线文档中有转译符号对应规则\n     Map&lt;String,Object&gt; args=new HashMap&lt;&gt;();\n        args.put(&quot;deptno&quot;, 20);\n        args.put(&quot;sal&quot;, 1500.0);\n    #&#123;&#125;中写的是map集合中,参数的键\n    --&gt;\n    &lt;select id=&quot;findEmpByDeptnoAndSal&quot; resultType=&quot;emp&quot; parameterType=&quot;map&quot;&gt;\n    &lt;/select&gt;\n    &lt;!--\n   参数为对象\n   emp &gt;&gt;&gt;  deptno   sal\n   参数是我们自定义的类型,那么 #&#123;&#125;中写的是参数的属性名\n   --&gt;\n    &lt;select id=&quot;findEmpByDeptnoAndSal2&quot; resultType=&quot;emp&quot; parameterType=&quot;emp&quot;&gt;\n    &lt;/select&gt;\n&lt;/mapper&gt;\n</code></pre>\n<p>测试代码</p>\n<pre><code class=\"java\"> package com.msb.test;\nimport com.msb.pojo.Emp;\nimport org.apache.ibatis.io.Resources;\nimport org.apache.ibatis.session.SqlSession;\nimport org.apache.ibatis.session.SqlSessionFactory;\nimport org.apache.ibatis.session.SqlSessionFactoryBuilder;\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Test;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n/**\n\n * @Author: Ma HaiYang\n * @Description: MircoMessage:Mark_7001\n    */\n    public class Test3 &#123;\n    private SqlSession sqlSession;\n    @Before\n    public void init()&#123;\n        SqlSessionFactoryBuilder ssfb =new SqlSessionFactoryBuilder();\n        InputStream resourceAsStream = null;\n        try &#123;\n            resourceAsStream = Resources.getResourceAsStream(&quot;sqlMapConfig.xml&quot;);\n        &#125; catch (IOException e) &#123;\n            e.printStackTrace();\n        &#125;\n        SqlSessionFactory factory=ssfb.build(resourceAsStream) ;\n        sqlSession=factory.openSession();\n    &#125;\n    @Test\n    public void testSingleArg()&#123;\n        // 测试单个基本数据类型作为参数\n        Emp emp = sqlSession.selectOne(&quot;findByEmpno&quot;, 7499);\n        System.out.println(emp);\n    &#125;\n    @Test\n    public void testMapArg()&#123;\n        // 测试Map集合作为参数\n        Map&lt;String,Object&gt; args=new HashMap&lt;&gt;();\n        args.put(&quot;deptno&quot;, 20);\n        args.put(&quot;sal&quot;, 3000.0);\n        List&lt;Emp&gt; emps = sqlSession.selectList(&quot;findEmpByDeptnoAndSal&quot;, args);\n        emps.forEach(System.out::println);\n    &#125;\n    @Test\n    public void testEmpArg()&#123;\n        // 测试Map集合作为参数\n        Emp arg =new Emp();\n        arg.setDeptno(10);\n        arg.setSal(2000.0);\n        List&lt;Emp&gt; emps = sqlSession.selectList(&quot;findEmpByDeptnoAndSal2&quot;, arg);\n        emps.forEach(System.out::println);\n    &#125;\n    @After\n    public void release()&#123;\n        // 关闭SQLSession\n        sqlSession.close();\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"3-sqlSession完成DML所有操作\"><a href=\"#3-sqlSession完成DML所有操作\" class=\"headerlink\" title=\"3_sqlSession完成DML所有操作\"></a>3_sqlSession完成DML所有操作</h2><p>Mapper映射文件</p>\n<pre><code class=\"xml\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;\n&lt;!DOCTYPE mapper\n        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;\n        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;\n&lt;mapper namespace=&quot;EmpMapper3&quot;&gt;\n    &lt;!--\n    增删方法的返回值类型都是int\n    resultType就无需指定了\n    insert update delete 标签中没有resultType\n    但是仍然可以有paramaterType\n    --&gt;\n    &lt;!-- 增加方法\n    public int addEmp(Emp emp);\n    --&gt;\n    &lt;insert id=&quot;addEmp&quot; parameterType=&quot;emp&quot;&gt;\n    &lt;/insert&gt;\n    &lt;!--修改\n    根据工号修改员工姓名\n    public int updateEmp(Emp emp);\n    --&gt;\n    &lt;update id=&quot;updateEmp&quot; parameterType=&quot;emp&quot;&gt;\n    &lt;/update&gt;\n    &lt;!-- 删除\n    删除大于给定工号的员工信息\n    public int deleteEmp(int empno)\n    --&gt;\n    &lt;delete id=&quot;deleteEmp&quot; parameterType=&quot;int&quot;&gt;\n        delete from emp where empno &gt;= #&#123;empno&#125;\n    &lt;/delete&gt;\n&lt;/mapper&gt;\n</code></pre>\n<p>测试代码</p>\n<pre><code class=\"java\">package com.msb.test;\nimport com.msb.pojo.Emp;\nimport org.apache.ibatis.io.Resources;\nimport org.apache.ibatis.session.SqlSession;\nimport org.apache.ibatis.session.SqlSessionFactory;\nimport org.apache.ibatis.session.SqlSessionFactoryBuilder;\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Test;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n/**\n * @Author: Ma HaiYang\n * @Description: MircoMessage:Mark_7001\n */\npublic class Test4 &#123;\n    private SqlSession sqlSession;\n    @Before\n    public void init()&#123;\n        SqlSessionFactoryBuilder ssfb =new SqlSessionFactoryBuilder();\n        InputStream resourceAsStream = null;\n        try &#123;\n            resourceAsStream = Resources.getResourceAsStream(&quot;sqlMapConfig.xml&quot;);\n        &#125; catch (IOException e) &#123;\n            e.printStackTrace();\n        &#125;\n        SqlSessionFactory factory=ssfb.build(resourceAsStream) ;\n        sqlSession=factory.openSession(true);\n    &#125;\n    @Test\n    public void testInsert()&#123;\n        Emp emp =new Emp(null,&quot;按住啦Baby&quot;,&quot;SALESMAN&quot;,7839,new Date(),3100.0, 200.0,10 );\n        int rows = sqlSession.insert(&quot;addEmp&quot;, emp);\n        System.out.println(rows);\n        // 手动提交事务\n        //sqlSession.commit();\n        /*增删改 要提交事务\n        * sqlSession.commit();手动提交事务\n        * sqlSession=factory.openSession(true); 设置事务自动提交\n        * */\n    &#125;\n    @Test\n    public void testUpdate()&#123;\n        Emp emp =new Emp( );\n        emp.setEname(&quot;晓明&quot;);\n        emp.setEmpno(7937);\n        int rows = sqlSession.update(&quot;updateEmp&quot;, emp);\n        System.out.println(rows);\n    &#125;\n    @Test\n    public void testDelete()&#123;\n        int rows = sqlSession.delete(&quot;deleteEmp&quot;, 7936);\n        System.out.println(rows);\n    &#125;\n    @After\n    public void release()&#123;\n        // 关闭SQLSession\n        sqlSession.close();\n    &#125;\n&#125;\n</code></pre>\n<h1 id=\"5-MyBatis代理模式开发\"><a href=\"#5-MyBatis代理模式开发\" class=\"headerlink\" title=\"5 MyBatis代理模式开发\"></a>5 MyBatis代理模式开发</h1><p>前面已经使用MyBatis完成了对Emp表的CRUD操作，都是由SqlSession调用自身方法发送SQL命令并得到结果的，实现了MyBatis的入门。</p>\n<p>但是却存在如下缺点：</p>\n<ol>\n<li><p>不管是selectList()、selectOne()、selectMap()，都是通过SQLSession对象的API完成增删改查,都只能提供一个查询参数。如果要多个参数，需要封装到JavaBean或者Map中，并不一定永远是一个好办法。</p>\n</li>\n<li><p>返回值类型较固定。</p>\n</li>\n<li><p>只提供了映射文件，没有提供数据库操作的接口，不利于后期的维护扩展。</p>\n</li>\n</ol>\n<p>在MyBatis中提供了另外一种成为<strong>Mapper代理（或称为接口绑定）</strong>的操作方式。在实际开发中也使用该方式。下面我们就是要Mapper代理的方式来实现对Emp表的CRUD操作吧，还有完成多个参数传递、模糊查询、自增主键回填等更多的技能实现。搭建好的项目框架如图所示，相比而言，增加了接口EmployeeMapper。但是却会引起映射文件和测试类的变化。</p>\n<p>优点:</p>\n<p>1有接口 模块之间有规范了</p>\n<p>2参数的处理多样了,接口中的方法参数列表由我们自己决定</p>\n<p>3通过代理模式由mybatis提供接口的实现类对象 我们不用写实现类了</p>\n<p>项目结构:注意文件路径和文件位置!!!</p>\n<img data-src=\"/2022/10/07/ORM/Mybatis/image-20220617195010768.png\" class=\"\" title=\"image-20220617195010768\">\n\n\n<p>准备接口和mapper映射文件</p>\n<p>EmpMapper接口</p>\n<pre><code class=\"java\">package com.msb.mapper;\nimport com.msb.pojo.Emp;\nimport java.util.List;\n/**\n\n * @Author: Ma HaiYang\n * @Description: MircoMessage:Mark_7001\n    */\npublic interface EmpMapper &#123;\n    /**\n     * 该方法用于查询全部的员工信息\n     * @return 全部员工信息封装的Emp对象的List集合\n        */\n    List&lt;Emp&gt; findAll();\n &#125;\n</code></pre>\n<p>EmpMapper.xml映射文件</p>\n<pre><code class=\"xml\"> &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;\n&lt;!DOCTYPE mapper\n        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;\n        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;\n&lt;mapper namespace=&quot;com.msb.mapper.EmpMapper&quot;&gt;\n    &lt;!--\n    1 接口的名字和Mapper映射为文件名字必须保持一致(不包含拓展名)\n    2 Mapper映射文件的namespace必须是接口的全路径名\n    3 sql语句的id必须是对应方法的名\n    4 DeptMapper映射文件应该和接口编译之后放在同一个目录下\n    --&gt;\n    &lt;!--List&lt;Emp&gt; findAll();--&gt;\n    &lt;select id=&quot;findAll&quot; resultType=&quot;emp&quot; &gt;\n        select * from emp\n    &lt;/select&gt;\n&lt;/mapper&gt;\n</code></pre>\n<p>在sqlMapConfig.xml核心配置文件中使用包扫描形式加载所有的映射文件</p>\n<pre><code class=\"xml\"> &lt;!--加载mapper映射文件--&gt;\n&lt;mappers&gt;\n    &lt;!--通过类的全路径去找mapper映射文件--&gt;\n    &lt;mapper class=&quot;com.msb.mapper.EmpMapper&quot;/&gt;\n&lt;/mappers&gt;\n</code></pre>\n<p> 测试代码</p>\n<pre><code class=\"java\">package com.msb.test;\nimport com.msb.mapper.EmpMapper;\nimport com.msb.pojo.Dept;\nimport com.msb.pojo.Emp;\nimport org.apache.ibatis.io.Resources;\nimport org.apache.ibatis.session.SqlSession;\nimport org.apache.ibatis.session.SqlSessionFactory;\nimport org.apache.ibatis.session.SqlSessionFactoryBuilder;\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Test;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.List;\n/**\n\n * @Author: Ma HaiYang\n * @Description: MircoMessage:Mark_7001\n    */\n    public class Test1 &#123;\n    private SqlSession sqlSession;\n    @Before\n    public void init()&#123;\n        SqlSessionFactoryBuilder ssfb =new SqlSessionFactoryBuilder();\n        InputStream resourceAsStream = null;\n        try &#123;\n            resourceAsStream = Resources.getResourceAsStream(&quot;sqlMapConfig.xml&quot;);\n        &#125; catch (IOException e) &#123;\n            e.printStackTrace();\n        &#125;\n        SqlSessionFactory factory=ssfb.build(resourceAsStream) ;\n        sqlSession=factory.openSession();\n    &#125;\n    @Test\n    public void testFindAll()&#123;\n        EmpMapper empMapper=sqlSession.getMapper(EmpMapper.class);\n        List&lt;Emp&gt; emps = empMapper.findAll();\n        emps.forEach(System.out::println);\n    &#125;\n    @After\n    public void release()&#123;\n        // 关闭SQLSession\n        sqlSession.close();\n    &#125;\n&#125;\n</code></pre>\n<p><strong>代理模式浅析</strong></p>\n<p>mybatis是如何通过代理模式实现查询的</p>\n<p>这条语句的底层使用了动态代理模式，动态创建一个EmployeeMapper的一个代理对象并赋给接口引用。所以在MyBatis中不需要显式提供Mapper接口的实现类，这也是简单的地方。</p>\n<h1 id=\"6-代理模式下开发各种功能\"><a href=\"#6-代理模式下开发各种功能\" class=\"headerlink\" title=\"6 代理模式下开发各种功能\"></a>6 代理模式下开发各种功能</h1><h2 id=\"1-多种参数传递问题\"><a href=\"#1-多种参数传递问题\" class=\"headerlink\" title=\"1_多种参数传递问题\"></a>1_多种参数传递问题</h2><blockquote>\n<p>1单个基本数据类型</p>\n<p>2多个基本数据类型</p>\n<p>3单个引用数据类型</p>\n<p>4map集合数据类型</p>\n<p>5多个引用数据类型</p>\n</blockquote>\n<p>接口</p>\n<pre><code class=\"java\">package com.msb.mapper;\nimport com.msb.pojo.Emp;\nimport org.apache.ibatis.annotations.Param;\nimport java.util.List;\nimport java.util.Map;\n/**\n * @Author: Ma HaiYang\n * @Description: MircoMessage:Mark_7001\n */\npublic interface EmpMapper &#123;\n    /**\n     * 该方法用于查询全部的员工信息\n     * @return 全部员工信息封装的Emp对象的List集合\n     */\n    List&lt;Emp&gt; findAll();\n    /**\n     * 根据员工编号查询单个员工信息的方法\n     * @param empno 员工编号\n     * @return 如果找到了返回Emp对象,找不到返回null\n     */\n    Emp findByEmpno(int empno);\n    /**\n     * 根据员工编号和薪资下限去查询员工信息\n     * @param empno 员工编号\n     * @param sal 薪资下限\n     * @return 多个Emp对象的List集合\n     */\n    List&lt;Emp&gt; findByDeptnoAndSal(@Param(&quot;deptno&quot;) int deptno,@Param(&quot;sal&quot;) double sal);\n    List&lt;Emp&gt; findByDeptnoAndSal2(Map&lt;String,Object&gt; map);\n    List&lt;Emp&gt; findByDeptnoAndSal3(Emp emp);\n    List&lt;Emp&gt; findByDeptnoAndSal4(@Param(&quot;empa&quot;) Emp empa,@Param(&quot;empb&quot;) Emp empb);\n&#125;\n</code></pre>\n<p>mapper映射文件</p>\n<pre><code class=\"xml\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;\n&lt;!DOCTYPE mapper\n        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;\n        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;\n&lt;mapper namespace=&quot;com.msb.mapper.EmpMapper&quot;&gt;\n    &lt;!--\n    1 接口的名字和Mapper映射为文件名字必须保持一致(不包含拓展名)\n    2 Mapper映射文件的namespace必须是接口的全路径名\n    3 sql语句的id必须是对应方法的名\n    4 DeptMapper映射文件应该和接口编译之后放在同一个目录下\n    --&gt;\n    &lt;!--List&lt;Emp&gt; findAll();--&gt;\n    &lt;select id=&quot;findAll&quot; resultType=&quot;emp&quot; &gt;\n        select * from emp\n    &lt;/select&gt;\n    &lt;!--\n    单个基本数据类型作为方法参数\n    #&#123;&#125;中可以随便写,遵循见名知意\n    Emp findByEmpno(int empno);\n    --&gt;\n    &lt;select id=&quot;findByEmpno&quot; resultType=&quot;emp&quot; &gt;\n        select * from emp where empno =#&#123;empno&#125;\n    &lt;/select&gt;\n    &lt;!--\n     多个基本数据类型作为方法参数\n     List&lt;Emp&gt; findByDeptnoAndSal(@Param(&quot;detpno&quot;) int deptno,@Param(&quot;sal&quot;) double sal);\n     方式1 arg*     arg0 arg1 arg2 数字是索引,从0开始\n     方式2 param*   param1 param2 param3 数字是编号,从1开始\n     使用别名\n     List&lt;Emp&gt; findByDeptnoAndSal(@Param(&quot;detpno&quot;) int deptno,@Param(&quot;sal&quot;) double sal);\n     通过@Param注解使用别名之后,就不能再使用arg* 但是可以继续使用param*\n    --&gt;\n    &lt;select id=&quot;findByDeptnoAndSal&quot; resultType=&quot;emp&quot;&gt;\n    &lt;/select&gt;\n    &lt;!--\n    参数是map,&#123;&#125;写键的名字\n    --&gt;\n    &lt;select id=&quot;findByDeptnoAndSal2&quot; resultType=&quot;emp&quot; parameterType=&quot;map&quot; &gt;\n    &lt;/select&gt;\n    &lt;!--单个引用类型,&#123;&#125;中写的使用对象的属性名--&gt;\n    &lt;select id=&quot;findByDeptnoAndSal3&quot; resultType=&quot;emp&quot; parameterType=&quot;emp&quot; &gt;\n    &lt;/select&gt;\n    &lt;!--\n    多个引用类型作为方法参数\n     List&lt;Emp&gt; findByDeptnoAndSal4(@Param(&quot;empa&quot;) Emp empa,@Param(&quot;empb&quot;) Emp empb);\n     如果用@Param定义了别名,那么就不能使用arg*.属性名,但是可以使用param*.属性名和别名.属性名\n    --&gt;\n    &lt;select id=&quot;findByDeptnoAndSal4&quot; resultType=&quot;emp&quot;  &gt;\n    &lt;/select&gt;\n&lt;/mapper&gt;\n</code></pre>\n<p>测试 代码</p>\n<pre><code class=\"java\">package com.msb.testDemo;\nimport com.msb.mapper.EmpMapper;\nimport com.msb.pojo.Emp;\nimport com.msb.util.SqlSessionUtil;\nimport org.apache.ibatis.session.SqlSession;\nimport java.util.List;\npublic class Test1 &#123;\n    public static void main(String[] args) &#123;\n        SqlSession sqlSession = SqlSessionUtil.getSqlSession(true);\n        /*\n        * 帮助我们生成一个接口下的实现类对象的\n        *\n        * */\n        EmpMapper mapper = sqlSession.getMapper(EmpMapper.class);\n        List&lt;Emp&gt; emps = mapper.getAllEmp();\n        for(Emp emp:emps) &#123;\n            System.out.println(emp);\n        &#125;\n        // 1单个基本数据类型作为方法参数\n        Emp emp = mapper.getByEmpno(7902);\n        System.out.println(emp);\n        // 2多个基本数据类型作为方法参数\n        List&lt;Emp&gt; emps2 = mapper.getByDeptnoAndSal(10, 1500);\n        for(Emp em:emps2) &#123;\n            System.out.println(em);\n        &#125;\n        // 3单个引用类型作为方法参数\n        Emp condition=new Emp();\n        condition.setDeptno(10);\n        condition.setSal(1500.0);\n        List&lt;Emp&gt; emps3 = mapper.getByDeptnoAndSal2(condition);\n        for(Emp em:emps3) &#123;\n            System.out.println(em);\n        &#125;\n        // 4多个引用类型作为方法参数\n        Emp condition1=new Emp();\n        condition1.setDeptno(10);\n        Emp condition2=new Emp();\n        condition2.setSal(1500.0);\n        List&lt;Emp&gt; emps4 = mapper.getByDeptnoAndSal3(condition1,condition2);\n        for(Emp em:emps4) &#123;\n            System.out.println(em);\n        &#125;\n        sqlSession.close();\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"2-模糊查询功能\"><a href=\"#2-模糊查询功能\" class=\"headerlink\" title=\"2 模糊查询功能\"></a>2 模糊查询功能</h2><pre><code>在进行模糊查询时，在映射文件中可以使用concat()函数来连接参数和通配符。另外注意对于特殊字符，比如&lt;，不能直接书写，应该使用字符实体替换。\n</code></pre>\n<p>接口</p>\n<pre><code class=\"java\">/**\n * 根据名字做模糊查询\n * @param name 模糊查询的文字\n * @return  Emp对象List集合\n */\nList&lt;Emp&gt; findByEname( String name);\n</code></pre>\n<p>mapper映射文件</p>\n<pre><code class=\"xml\">&lt;!--List&lt;Emp&gt; getByName(String name);--&gt;\n&lt;select id=&quot;findByEname&quot;  resultType=&quot;emp&quot; &gt;\n    select * from emp where ename like concat(&#39;%&#39;,#&#123;name&#125;,&#39;%&#39;)\n&lt;/select&gt;\n</code></pre>\n<h2 id=\"3-主键自增回填\"><a href=\"#3-主键自增回填\" class=\"headerlink\" title=\"3_主键自增回填\"></a>3_主键自增回填</h2><pre><code>MySQL支持主键自增。有时候完成添加后需要立刻获取刚刚自增的主键，由下一个操作来使用。比如结算构造车后，主订单的主键确定后，需要作为后续订单明细项的外键存在。如何拿到主键呢，MyBatis提供了支持，可以非常简单的获取。\n</code></pre>\n<p>接口</p>\n<pre><code class=\"java\">public interface DeptMapper &#123;\n    int addDept(Dept dept);\n    int addDept2(Dept dept);\n&#125;\n</code></pre>\n<p>mapper映射文件</p>\n<pre><code class=\"xml\">&lt;mapper namespace=&quot;com.msb.mapper.DeptMapper&quot;&gt;\n   &lt;!-- int addDept(Dept dept);\n   useGeneratedKeys=&quot;true&quot; 返回数据库帮我们生成的主键\n   keyProperty=&quot;deptno&quot; 生成的主键值用我们dept对象那个属性存储\n   --&gt;\n    &lt;insert id=&quot;addDept&quot; parameterType=&quot;dept&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;deptno&quot;&gt;\n    &lt;/insert&gt;\n    &lt;insert id=&quot;addDept2&quot; parameterType=&quot;dept&quot;&gt;\n        &lt;selectKey order=&quot;AFTER&quot; keyProperty=&quot;deptno&quot;  resultType=&quot;int&quot;&gt;\n            select @@identity\n        &lt;/selectKey&gt;\n    &lt;/insert&gt;\n&lt;/mapper&gt;\n</code></pre>\n<p>测试代码</p>\n<pre><code class=\"java\">SqlSession sqlSession = SqlSessionUtil.getSqlSession(true);\nDeptMapper mapper = sqlSession.getMapper(DeptMapper.class);\nDept dept =new Dept(null,&quot;AI学院&quot;,&quot;北京&quot;);\nint i = mapper.addDept2(dept);\nSystem.out.println(i);\nSystem.out.println(dept.getDeptno());\nsqlSession.close();\n</code></pre>\n<p>方式1</p>\n<p>useGeneratedKeys：表示要使用自增的主键</p>\n<p>keyProperty：表示把自增的主键赋给JavaBean的哪个成员变量。</p>\n<p>以添加Dept对象为例，添加前Dept对象的deptno是空的，添加完毕后可以通过getDeptno() 获取自增的主键。</p>\n<p>方式2</p>\n<p>order：取值AFTER|BEFORE，表示在新增之后|之前执行<selectKey>中的SQL命令</p>\n<p>keyProperty：执行select @@identity后结果填充到哪个属性中</p>\n<p>resultType：结果类型。</p>\n<p><strong>技术扩展</strong><br>在很多应用场景中需要新增数据后获取到新增数据的主键值，针对这样的需求一般由三种解决方式：</p>\n<ul>\n<li>主键自定义，用户通过UUID或时间戳等方式生成唯一主键，把这个值当做主键值。在分布式场景中应用较多。</li>\n<li>查询后通过select max(主键) from 表获取主键最大值。这种方式在多线程访问情况下可能出现问题。</li>\n<li>查询后通过select @@identity获取最新生成主键。要求这条SQL必须在insert操作之后，且数据库连接没有关闭。</li>\n</ul>\n<h2 id=\"4-实现DML操作\"><a href=\"#4-实现DML操作\" class=\"headerlink\" title=\"4_实现DML操作\"></a>4_实现DML操作</h2><p>EmpMapper接口</p>\n<pre><code class=\"java\">/**\n * 增加员工信息\n * @param emp 存储新增员工信息的Emp对象\n * @return 对数据库数据产生影响的行数\n */\nint addEmp(Emp emp);\n/**\n * 根据员工编号修改员工姓名的方法\n * @param empno 要修改的员工编号\n * @param ename 修改之后的新的员工名字\n * @return 对数据库数据产生影响的行数\n */\nint updateEnameByEmpno(@Param(&quot;empno&quot;) int empno,@Param(&quot;ename&quot;) String ename);\n/**\n * 根据员工编号删除员工信息\n * @param empno 要删除的员工编号\n * @return 对数据库数据产生影响的行数\n */\nint deleteByEmpno(int empno);\n</code></pre>\n<p>EmpMapper映射 文件</p>\n<pre><code class=\"xml\">&lt;!--int addEmp(Emp emp);--&gt;\n&lt;insert id=&quot;addEmp&quot; &gt;\n&lt;/insert&gt;\n&lt;!--int updateEnameByEmpno(@Param(&quot;empno&quot;) int empno,@Param(&quot;ename&quot;) String ename);--&gt;\n&lt;update id=&quot;updateEnameByEmpno&quot; &gt;\n&lt;/update&gt;\n&lt;!--int deleteByEmpno(int empno);--&gt;\n&lt;update id=&quot;deleteByEmpno&quot; &gt;\n    delete from emp where empno =#&#123;empno&#125;\n&lt;/update&gt;\n</code></pre>\n<p>测试代码</p>\n<pre><code class=\"java\">package com.msb.test;\nimport com.msb.mapper.DeptMapper;\nimport com.msb.mapper.EmpMapper;\nimport com.msb.pojo.Dept;\nimport com.msb.pojo.Emp;\nimport org.apache.ibatis.io.Resources;\nimport org.apache.ibatis.session.SqlSession;\nimport org.apache.ibatis.session.SqlSessionFactory;\nimport org.apache.ibatis.session.SqlSessionFactoryBuilder;\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Test;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.Date;\n/**\n * @Author: Ma HaiYang\n * @Description: MircoMessage:Mark_7001\n */\npublic class Test3 &#123;\n    private SqlSession sqlSession;\n    @Before\n    public void init()&#123;\n        SqlSessionFactoryBuilder ssfb =new SqlSessionFactoryBuilder();\n        InputStream resourceAsStream = null;\n        try &#123;\n            resourceAsStream = Resources.getResourceAsStream(&quot;sqlMapConfig.xml&quot;);\n        &#125; catch (IOException e) &#123;\n            e.printStackTrace();\n        &#125;\n        SqlSessionFactory factory=ssfb.build(resourceAsStream) ;\n        sqlSession=factory.openSession();\n    &#125;\n    @Test\n    public void testAddEmp()&#123;\n        EmpMapper mapper = sqlSession.getMapper(EmpMapper.class);\n        mapper.addEmp(new Emp(null, &quot;TOM&quot;, &quot;SALESMAN&quot;, 7521, new Date(), 2314.0, 100.0, 10));\n        sqlSession.commit();\n    &#125;\n    @Test\n    public void testUpdateEnameByEmpno()&#123;\n        EmpMapper mapper = sqlSession.getMapper(EmpMapper.class);\n        mapper.updateEnameByEmpno(7938, &quot;TOM&quot;);\n        sqlSession.commit();\n    &#125;\n    @Test\n    public void testDeletByEmpno()&#123;\n        EmpMapper mapper = sqlSession.getMapper(EmpMapper.class);\n        mapper.deleteByEmpno(7938);\n        sqlSession.commit();\n    &#125;\n    @After\n    public void release()&#123;\n        // 关闭SQLSession\n        sqlSession.close();\n    &#125;\n&#125;\n</code></pre>\n<h1 id=\"7-动态SQL\"><a href=\"#7-动态SQL\" class=\"headerlink\" title=\"7 动态SQL\"></a>7 动态SQL</h1><pre><code>经常遇到很多按照很多查询条件进行查询的情况，比如京东根据不同的条件筛选商品。其中经常出现很多条件不取值的情况，在后台应该如何完成最终的SQL语句呢？\n\n\n\n\n\n\n\n\n\n如果采用JDBC进行处理，需要根据条件是否取值进行SQL语句的拼接，一般情况下是使用StringBuilder类及其append方法实现，还是有些繁琐的。如果你有使用 JDBC 或其它类似框架的经验，你就能体会到根据不同条件拼接 SQL语句的痛苦。例如拼接时要确保不能忘记添加必要的空格，还要注意去掉列表最后一个列名的逗号。利用动态 SQL 这一特性可以彻底摆脱这种痛苦。\n\nMyBatis在简化操作方法提出了动态SQL功能，将使用Java代码拼接SQL语句，改变为在XML映射文件中截止标签拼接SQL语句。相比而言，大大减少了代码量，更灵活、高度可配置、利于后期维护。\n\nMyBatis中动态SQL是编写在mapper.xml中的，其语法和JSTL类似，但是却是基于强大的OGNL表达式实现的。\n\nMyBatis也可以在注解中配置SQL，但是由于注解功能受限，尤其是对于复杂的SQL语句，可读性很差，所以较少使用。\n</code></pre>\n<h2 id=\"1-if标签\"><a href=\"#1-if标签\" class=\"headerlink\" title=\"1_if标签\"></a>1_if标签</h2><p>接口</p>\n<pre><code class=\"java\">public interface EmpMapper2 &#123;\n  List&lt;Emp&gt; findByCondition(Emp emp);\n&#125;\n</code></pre>\n<p>映射文件</p>\n<pre><code class=\"xml\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;\n&lt;!DOCTYPE mapper\n        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;\n        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;\n&lt;mapper namespace=&quot;com.msb.mapper.EmpMapper2&quot;&gt;\n&lt;!--List&lt;Emp&gt; findByCondition(Emp emp);--&gt;\n    &lt;select id=&quot;findByCondition&quot; resultType=&quot;emp&quot;&gt;\n        select * from emp where 1=1\n        &lt;if test=&quot;empno != null&quot;&gt;\n            and empno =#&#123;empno&#125;\n        &lt;/if&gt;\n        &lt;if test=&quot;ename != null and ename != &#39;&#39;&quot;&gt;\n            and ename like concat(&#39;%&#39;,#&#123;ename&#125;,&#39;%&#39;)\n        &lt;/if&gt;\n        &lt;if test=&quot;job != null and job != &#39;&#39;&quot;&gt;\n            and job =#&#123;job&#125;\n        &lt;/if&gt;\n        &lt;if test=&quot;mgr != null&quot;&gt;\n            and mgr =#&#123;mgr&#125;\n        &lt;/if&gt;\n        &lt;if test=&quot;hiredate != null&quot;&gt;\n            and hiredate =#&#123;hiredate&#125;\n        &lt;/if&gt;\n        &lt;if test=&quot;sal != null&quot;&gt;\n            and sal =#&#123;sal&#125;\n        &lt;/if&gt;\n        &lt;if test=&quot;comm != null&quot;&gt;\n            and comm =#&#123;comm&#125;\n        &lt;/if&gt;\n        &lt;if test=&quot;deptno != null&quot;&gt;\n            and deptno =#&#123;deptno&#125;\n        &lt;/if&gt;\n    &lt;/select&gt;\n&lt;/mapper&gt;\n</code></pre>\n<p>测试代码</p>\n<pre><code class=\"java\">public static void main(String[] args) &#123;\n    SqlSession sqlSession = MyBatisUtil.getSqlSession(false);\n    EmpMapper2 mapper = sqlSession.getMapper(EmpMapper2.class);\n    Emp condition =new Emp();\n   /* condition.setDeptno(20);*/\n   /* condition.setSal(3000.0);*/\n   /*condition.setHiredate(new java.sql.Date(81,1,22));*/\n   condition.setComm(0.0);\n   condition.setDeptno(20);\n    List&lt;Emp&gt; emps = mapper.findEmpByCondition(condition);\n    for (Emp e:emps\n         ) &#123;\n        System.out.println(e);\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"2-where标签\"><a href=\"#2-where标签\" class=\"headerlink\" title=\"2_where标签\"></a>2_where标签</h2><blockquote>\n<p>用于处理where关键字和and</p>\n<p>默认删除第一个and逻辑连接符</p>\n</blockquote>\n<pre><code class=\"xml\">&lt;select id=&quot;findEmpByCondition&quot; resultType=&quot;emp&quot;&gt;\n    select * from emp\n    &lt;where&gt;\n        &lt;if test=&quot;empno != null&quot;&gt;\n            and empno= #&#123;empno&#125;\n        &lt;/if&gt;\n        &lt;if test=&quot;ename != null and ename != &#39;&#39;&quot;&gt;\n            and ename= #&#123;ename&#125;\n        &lt;/if&gt;\n        &lt;if test=&quot;job != null and job != &#39;&#39;&quot;&gt;\n            and job= #&#123;job&#125;\n        &lt;/if&gt;\n        &lt;if test=&quot;mgr != null &quot;&gt;\n            and mgr= #&#123;mgr&#125;\n        &lt;/if&gt;\n        &lt;if test=&quot;hiredate != null &quot;&gt;\n            and hiredate= #&#123;hiredate&#125;\n        &lt;/if&gt;\n        &lt;if test=&quot;sal != null&quot;&gt;\n            and sal= #&#123;sal&#125;\n        &lt;/if&gt;\n        &lt;if test=&quot;comm != null &quot;&gt;\n             and comm =#&#123;comm&#125;\n        &lt;/if&gt;\n        &lt;if test=&quot;deptno != null &quot;&gt;\n            and deptno= #&#123;deptno&#125;\n        &lt;/if&gt;\n    &lt;/where&gt;\n&lt;/select&gt;\n</code></pre>\n<h2 id=\"3-choose标签\"><a href=\"#3-choose标签\" class=\"headerlink\" title=\"3_choose标签\"></a>3_choose标签</h2><p>前面的when条件成立 后面的 when就不再判断了</p>\n<pre><code class=\"xml\"> &lt;select id=&quot;findEmpByCondition2&quot; resultType=&quot;emp&quot;&gt;\n    select * from emp\n    &lt;where&gt;\n        &lt;choose&gt;\n            &lt;when test=&quot;empno != null&quot;&gt;\n                and empno= #&#123;empno&#125;\n            &lt;/when&gt;\n            &lt;when test=&quot;ename != null and ename != &#39;&#39;&quot;&gt;\n                and ename= #&#123;ename&#125;\n            &lt;/when&gt;\n            &lt;when test=&quot;job != null and job != &#39;&#39;&quot;&gt;\n                and job= #&#123;job&#125;\n            &lt;/when&gt;\n            &lt;when test=&quot;mgr != null &quot;&gt;\n                and mgr= #&#123;mgr&#125;\n            &lt;/when&gt;\n            &lt;when test=&quot;hiredate != null &quot;&gt;\n                and hiredate= #&#123;hiredate&#125;\n            &lt;/when&gt;\n            &lt;when test=&quot;sal != null&quot;&gt;\n                and sal= #&#123;sal&#125;\n            &lt;/when&gt;\n            &lt;when test=&quot;comm != null &quot;&gt;\n                and comm =#&#123;comm&#125;\n            &lt;/when&gt;\n            &lt;when test=&quot;deptno != null &quot;&gt;\n                and deptno= #&#123;deptno&#125;\n            &lt;/when&gt;\n        &lt;/choose&gt;\n    &lt;/where&gt;\n&lt;/select&gt;\n</code></pre>\n<h2 id=\"4-set标签\"><a href=\"#4-set标签\" class=\"headerlink\" title=\"4_set标签\"></a>4_set标签</h2><p>接口</p>\n<pre><code class=\"java\"> int updateEmpByCondtion(Emp emp);\n</code></pre>\n<p>映射文件</p>\n<pre><code class=\"xml\"> &lt;!--int updateEmpByCondtion(Emp emp);--&gt;\n&lt;update id=&quot;updateEmpByCondtion&quot; &gt;\n    update emp\n    &lt;set&gt;\n        &lt;if test=&quot;ename != null and ename != &#39;&#39; &quot;&gt;\n            , ename =#&#123;ename&#125;\n        &lt;/if&gt;\n        &lt;if test=&quot;job != null and ename != &#39;&#39; &quot;&gt;\n            , job =#&#123;job&#125;\n        &lt;/if&gt;\n        &lt;if test=&quot;mgr != null &quot;&gt;\n            , mgr =#&#123;mgr&#125;\n        &lt;/if&gt;\n        &lt;if test=&quot;hiredate != null &quot;&gt;\n            , hiredate =#&#123;hiredate&#125;\n        &lt;/if&gt;\n        &lt;if test=&quot;sal != null &quot;&gt;\n            , sal =#&#123;sal&#125;\n        &lt;/if&gt;\n        &lt;if test=&quot;comm != null &quot;&gt;\n            , comm =#&#123;comm&#125;\n        &lt;/if&gt;\n        &lt;if test=&quot;deptno != null &quot;&gt;\n            , deptno =#&#123;deptno&#125;\n        &lt;/if&gt;\n    &lt;/set&gt;\n    where empno =#&#123;empno&#125;\n&lt;/update&gt;\n</code></pre>\n<h2 id=\"5-trim标签\"><a href=\"#5-trim标签\" class=\"headerlink\" title=\"5_trim标签\"></a>5_trim标签</h2><blockquote>\n<p>Trim 标签处理 set  ，可以为他包裹起来的SQL语句前后 增加&#x2F;删除 关键词&#x2F;固定字符</p>\n</blockquote>\n<pre><code class=\"xml\">&lt;update id=&quot;updateEmpByCondition2&quot; &gt;\n    update emp\n    &lt;!--prefix 要增加什么前缀\n    prefixOverrides 要去除什么前缀\n    suffix 要增加什么后缀\n    suffixOverrides 要去除什么后缀\n    set 是trim的一种特殊情况\n    --&gt;\n    &lt;trim prefix=&quot;set&quot;  suffixOverrides=&quot;,&quot; &gt;\n        &lt;if test=&quot;ename != null and ename != &#39;&#39;&quot;&gt;\n            ename= #&#123;ename&#125;,\n        &lt;/if&gt;\n        &lt;if test=&quot;job != null and job != &#39;&#39;&quot;&gt;\n            job= #&#123;job&#125;,\n        &lt;/if&gt;\n        &lt;if test=&quot;mgr != null &quot;&gt;\n            mgr= #&#123;mgr&#125;,\n        &lt;/if&gt;\n        &lt;if test=&quot;hiredate != null &quot;&gt;\n            hiredate= #&#123;hiredate&#125;,\n        &lt;/if&gt;\n        &lt;if test=&quot;sal != null&quot;&gt;\n            sal= #&#123;sal&#125;,\n        &lt;/if&gt;\n        &lt;if test=&quot;comm != null &quot;&gt;\n            comm =#&#123;comm&#125;,\n        &lt;/if&gt;\n        &lt;if test=&quot;deptno != null &quot;&gt;\n            deptno= #&#123;deptno&#125;,\n        &lt;/if&gt;\n    &lt;/trim&gt;\n    where  empno = #&#123;empno&#125;\n&lt;/update&gt;\n</code></pre>\n<p>Trim标签  处理where</p>\n<pre><code class=\"xml\">    &lt;select id=&quot;findByCondition&quot; resultMap=&quot;EmpMap&quot;&gt;\n        select * from emp \n        &lt;trim prefix=&quot;where&quot; prefixOverrides=&quot;and&quot;&gt;\n            &lt;if test=&quot;empno != null&quot;&gt;\n                and empno =#&#123;empno&#125;\n            &lt;/if&gt;\n            &lt;if test=&quot;ename != null and ename != &#39;&#39;&quot;&gt;\n                &lt;bind name=&quot;likePattern&quot; value=&quot;&#39;%&#39;+ename+&#39;%&#39;&quot;/&gt;\n                and ename like #&#123;likePattern&#125;\n            &lt;/if&gt;\n            &lt;if test=&quot;job != null and job != &#39;&#39;&quot;&gt;\n                and job =#&#123;job&#125;\n            &lt;/if&gt;\n            &lt;if test=&quot;mgr != null&quot;&gt;\n                and mgr =#&#123;mgr&#125;\n            &lt;/if&gt;\n            &lt;if test=&quot;hiredate != null&quot;&gt;\n                and hiredate =#&#123;hiredate&#125;\n            &lt;/if&gt;\n            &lt;if test=&quot;sal != null&quot;&gt;\n                and sal =#&#123;sal&#125;\n            &lt;/if&gt;\n            &lt;if test=&quot;comm != null&quot;&gt;\n                and comm =#&#123;comm&#125;\n            &lt;/if&gt;\n            &lt;if test=&quot;deptno != null&quot;&gt;\n                and deptno =#&#123;deptno&#125;\n            &lt;/if&gt;\n        &lt;/trim&gt;\n    &lt;/select&gt;\n</code></pre>\n<h2 id=\"6-bind标签\"><a href=\"#6-bind标签\" class=\"headerlink\" title=\"6_bind标签\"></a>6_bind标签</h2><p>一般用于处理模糊查询的模板</p>\n<p>接口</p>\n<img data-src=\"/2022/10/07/ORM/Mybatis/image-20220617200421440.png\" class=\"\" title=\"image-20220617200421440\">\n\n\n<p>SQL语句</p>\n<pre><code class=\"xml\">&lt;!-- bind 写一个局部SQL模板，模糊 like 常用--&gt;\n    &lt;select id=&quot;findEmpByEname&quot; resultMap=&quot;EmpMap&quot;&gt;\n        &lt;bind name=&quot;likePatten&quot; value=&quot;&#39;%&#39;+param1+&#39;%&#39;&quot;/&gt;\n        select * from emp where ename like #&#123;likePatten&#125;;\n    &lt;/select&gt;\n</code></pre>\n<h2 id=\"7-nclude\"><a href=\"#7-nclude\" class=\"headerlink\" title=\"7_nclude\"></a>7_nclude</h2><p>引用提前写好的 SQL 标签的SQL语句</p>\n<pre><code class=\"xml\">    &lt;sql id=&quot;empColumn&quot;&gt;empno,ename,job,mgr,hiredate,sal,comm,deptno&lt;/sql&gt;\n    &lt;sql id=&quot;baseSelect&quot;&gt;\n        select &lt;include refid=&quot;empColumn&quot;&gt;&lt;/include&gt; from emp\n    &lt;/sql&gt;\n</code></pre>\n<h2 id=\"8-sql标签\"><a href=\"#8-sql标签\" class=\"headerlink\" title=\"8_sql标签\"></a>8_sql标签</h2><pre><code class=\"xml\"> &lt;sql id=&quot;empColumn&quot;&gt;empno,ename,job,mgr,hiredate,sal,comm,deptno&lt;/sql&gt;\n&lt;sql id=&quot;baseSelect&quot;&gt;select &lt;include refid=&quot;empColumn&quot;&gt;&lt;/include&gt; from emp&lt;/sql&gt;\n&lt;!--List&lt;Emp&gt; findByCondition(Emp emp);--&gt;\n&lt;select id=&quot;findByCondition&quot; resultType=&quot;emp&quot;&gt;\n    &lt;include refid=&quot;baseSelect&quot;&gt;&lt;/include&gt;\n    &lt;trim prefix=&quot;where&quot; prefixOverrides=&quot;and&quot;&gt;\n        &lt;if test=&quot;empno != null&quot;&gt;\n            and empno =#&#123;empno&#125;\n        &lt;/if&gt;\n        &lt;if test=&quot;ename != null and ename != &#39;&#39;&quot;&gt;\n            &lt;bind name=&quot;likePattern&quot; value=&quot;&#39;%&#39;+ename+&#39;%&#39;&quot;/&gt;\n            and ename like #&#123;likePattern&#125;\n        &lt;/if&gt;\n        &lt;if test=&quot;job != null and job != &#39;&#39;&quot;&gt;\n            and job =#&#123;job&#125;\n        &lt;/if&gt;\n        &lt;if test=&quot;mgr != null&quot;&gt;\n            and mgr =#&#123;mgr&#125;\n        &lt;/if&gt;\n        &lt;if test=&quot;hiredate != null&quot;&gt;\n            and hiredate =#&#123;hiredate&#125;\n        &lt;/if&gt;\n        &lt;if test=&quot;sal != null&quot;&gt;\n            and sal =#&#123;sal&#125;\n        &lt;/if&gt;\n        &lt;if test=&quot;comm != null&quot;&gt;\n            and comm =#&#123;comm&#125;\n        &lt;/if&gt;\n        &lt;if test=&quot;deptno != null&quot;&gt;\n            and deptno =#&#123;deptno&#125;\n        &lt;/if&gt;\n    &lt;/trim&gt;\n&lt;/select&gt;\n</code></pre>\n<h2 id=\"9-foreach标签\"><a href=\"#9-foreach标签\" class=\"headerlink\" title=\"9_foreach标签\"></a>9_foreach标签</h2><pre><code class=\"xml\"> &lt;!--List&lt;Emp&gt; findByEmpnos1(int[] empnos);\n collection=&quot;&quot;  遍历的集合或者是数组\n                 参数是数组,collection中名字指定为array\n                 参数是List集合,collection中名字指定为list\n separator=&quot;&quot;   多个元素取出的时候 用什么文字分隔\n open=&quot;&quot;        以什么开头\n close=&quot;&quot;       以什么结尾\n item=&quot;&quot;        中间变量名\n for(Person per:PersonList)\n --&gt;\n &lt;select id=&quot;findByEmpnos1&quot; resultType=&quot;emp&quot;&gt;\n     select * from emp  where empno in\n     &lt;foreach collection=&quot;array&quot; separator=&quot;,&quot; open=&quot;(&quot; close=&quot;)&quot; item=&quot;deptno&quot;&gt;\n         #&#123;deptno&#125;\n     &lt;/foreach&gt;\n &lt;/select&gt;\n&lt;!-- List&lt;Emp&gt; findByEmpnos2(List&lt;Integer&gt; empnos);--&gt;\n &lt;select id=&quot;findByEmpnos2&quot; resultType=&quot;emp&quot;&gt;\n     select * from emp  where empno in\n     &lt;foreach collection=&quot;list&quot; separator=&quot;,&quot; open=&quot;(&quot; close=&quot;)&quot; item=&quot;deptno&quot;&gt;\n         #&#123;deptno&#125;\n     &lt;/foreach&gt;\n &lt;/select&gt;\n</code></pre>\n<h1 id=\"8-MyBatis实现多表查询\"><a href=\"#8-MyBatis实现多表查询\" class=\"headerlink\" title=\"8 MyBatis实现多表查询\"></a>8 MyBatis实现多表查询</h1><p>前面已经使用MyBatis完成了对Emp表的CRUD操作，不管是使用SqlSession直接操作，还是使用Mapper代理方式，都只是完成了对单个数据库表的操作。这肯定是远远不够的。</p>\n<p>在实际开发中，经常会将来自多张表的数据在一个位置显示。比如查询并显示的员工信息中会有来自部门表、岗位表的数据，而后台一般是定义一个方法</p>\n<h2 id=\"1-关联查询\"><a href=\"#1-关联查询\" class=\"headerlink\" title=\"1 关联查询\"></a>1 关联查询</h2><h3 id=\"1-手动处理映射关系\"><a href=\"#1-手动处理映射关系\" class=\"headerlink\" title=\"1 手动处理映射关系\"></a>1 手动处理映射关系</h3><p>实体类</p>\n<pre><code class=\"java\">public class Emp  implements Serializable &#123;\n    private Integer empno;\n    private String name;\n    private String job;\n    private Integer mgr;\n    private Date hiredate;\n    private Double sal;\n    private Double comm;\n    private Integer deptno;\n&#125;\n</code></pre>\n<p>映射文件</p>\n<pre><code class=\"xml\">&lt;mapper namespace=&quot;com.msb.mapper.EmpMapper&quot;&gt;\n    &lt;!--手动处理数据库查询字段和封装实体类属性之间的映射关系\n    1 主键一般使用id属性\n    2 当属性名和查询出的数据表字段名相同 可以不写映射关系\n    --&gt;\n    &lt;resultMap id=&quot;empMap&quot; type=&quot;emp&quot;&gt;\n        &lt;!--&lt;id property=&quot;empno&quot; column=&quot;empno&quot;&gt;&lt;/id&gt;--&gt;\n        &lt;result property=&quot;name&quot; column=&quot;ename&quot;&gt;&lt;/result&gt;\n        &lt;!--&lt;result property=&quot;job&quot; column=&quot;job&quot;&gt;&lt;/result&gt;\n        &lt;result property=&quot;sal&quot; column=&quot;sal&quot;&gt;&lt;/result&gt;\n        &lt;result property=&quot;hiredate&quot; column=&quot;hiredate&quot;&gt;&lt;/result&gt;\n        &lt;result property=&quot;mgr&quot; column=&quot;mgr&quot;&gt;&lt;/result&gt;\n        &lt;result property=&quot;comm&quot; column=&quot;comm&quot;&gt;&lt;/result&gt;\n        &lt;result property=&quot;deptno&quot; column=&quot;deptno&quot;&gt;&lt;/result&gt;--&gt;\n    &lt;/resultMap&gt;\n    &lt;select id=&quot;findByEmpno&quot; resultMap=&quot;empMap&quot; &gt;\n        select * from emp where empno =#&#123;empno&#125;\n    &lt;/select&gt;\n&lt;/mapper&gt;\n</code></pre>\n<h3 id=\"2-一对一关联查询\"><a href=\"#2-一对一关联查询\" class=\"headerlink\" title=\"2 一对一关联查询\"></a>2 一对一关联查询</h3><p>数据准备: 创建项目表和项目记录表</p>\n<img data-src=\"/2022/10/07/ORM/Mybatis/image-20220617200808312.png\" class=\"\" title=\"image-20220617200808312\">\n\n\n\n<pre><code class=\"sql\">CREATE TABLE `projects`  (\n  `pid` int(2) NOT NULL AUTO_INCREMENT,\n  `pname` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL,\n  `money` int(11) NULL DEFAULT NULL,\n  PRIMARY KEY (`pid`) USING BTREE\n) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = Dynamic;\nINSERT INTO `projects` VALUES (1, &#39; ***大学OA&#39;, 500000);\nINSERT INTO `projects` VALUES (2, &#39;学生选课系统&#39;, 100000);\nINSERT INTO `projects` VALUES (3, &#39;讲师测评系统&#39;, 20000);\nINSERT INTO `projects` VALUES (4, &#39;线上问答系统 &#39;, 20000);\nCREATE TABLE `projectrecord`  (\n  `empno` int(4) NOT NULL,\n  `pid` int(2) NOT NULL,\n  PRIMARY KEY (`empno`, `pid`) USING BTREE,\n  INDEX `fk_project_pro`(`pid`) USING BTREE,\n  CONSTRAINT `fk_emp_pro` FOREIGN KEY (`empno`) REFERENCES `emp` (`EMPNO`) ON DELETE CASCADE ON UPDATE CASCADE,\n  CONSTRAINT `fk_project_pro` FOREIGN KEY (`pid`) REFERENCES `projects` (`pid`) ON DELETE CASCADE ON UPDATE CASCADE\n) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = Dynamic;\nINSERT INTO `projectrecord` VALUES (7369, 1);\nINSERT INTO `projectrecord` VALUES (7521, 1);\nINSERT INTO `projectrecord` VALUES (7369, 2);\nINSERT INTO `projectrecord` VALUES (7499, 2);\nINSERT INTO `projectrecord` VALUES (7521, 2);\nINSERT INTO `projectrecord` VALUES (7369, 3);\nINSERT INTO `projectrecord` VALUES (7499, 3);\nINSERT INTO `projectrecord` VALUES (7521, 3);\nINSERT INTO `projectrecord` VALUES (7369, 4);\nINSERT INTO `projectrecord` VALUES (7499, 4);\n</code></pre>\n<p>需求:根据编号查询员工信息及所在的部门信息</p>\n<p>实体类添加一个部门作为属性</p>\n<p>实体类</p>\n<pre><code class=\"java\">@AllArgsConstructor\n@NoArgsConstructor\n@Data\npublic class Emp implements Serializable &#123;\n    private Integer empno;\n    private String ename;\n    private String job;\n    private Integer mgr;\n    private Date hiredate;\n    private Double sal;\n    private Double comm;\n    private Integer deptno;\n    // 组合一个Dept对象作为自己的属性\n    private Dept dept;\n&#125;\n</code></pre>\n<p>接口</p>\n<pre><code class=\"java\">public interface EmpMapper &#123;\n    /**\n     * 根据员工编号查询员工的所有信息并携带所在的部门信息\n     * @param empno 要查询的员工编号\n     * @return Emp对象,组合了Dept对象作为属性,对部门信息进行存储\n     */\n    Emp findEmpJoinDeptByEmpno(int empno);\n&#125;\n</code></pre>\n<p>映射文件</p>\n<pre><code class=\"xml\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;\n&lt;!DOCTYPE mapper\n        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;\n        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;\n&lt;mapper namespace=&quot;com.msb.mapper.EmpMapper&quot;&gt;\n    &lt;!--Emp findEmpJoinDeptByEmpno(int empno);--&gt;\n    &lt;resultMap id=&quot;empJoinDept&quot; type=&quot;emp&quot;&gt;\n        &lt;!--设置emp本身的八个属性的映射关系--&gt;\n        &lt;id property=&quot;empno&quot; column=&quot;empno&quot;&gt;&lt;/id&gt;\n        &lt;result property=&quot;ename&quot; column=&quot;ename&quot;&gt;&lt;/result&gt;\n        &lt;result property=&quot;job&quot; column=&quot;job&quot;&gt;&lt;/result&gt;\n        &lt;result property=&quot;sal&quot; column=&quot;sal&quot;&gt;&lt;/result&gt;\n        &lt;result property=&quot;hiredate&quot; column=&quot;hiredate&quot;&gt;&lt;/result&gt;\n        &lt;result property=&quot;mgr&quot; column=&quot;mgr&quot;&gt;&lt;/result&gt;\n        &lt;result property=&quot;comm&quot; column=&quot;comm&quot;&gt;&lt;/result&gt;\n        &lt;result property=&quot;deptno&quot; column=&quot;deptno&quot;&gt;&lt;/result&gt;\n        &lt;!--\n        association 处理一对一\n        封装一对一信息关系的标签\n        property  emp类的属性名\n        javaType  用哪个类的对象给属性赋值\n        --&gt;\n        &lt;association property=&quot;dept&quot; javaType=&quot;dept&quot;&gt;\n            &lt;id column=&quot;deptno&quot; property=&quot;deptno&quot;&gt;&lt;/id&gt;\n            &lt;result column=&quot;dname&quot; property=&quot;dname&quot;&gt;&lt;/result&gt;\n            &lt;result column=&quot;loc&quot; property=&quot;loc&quot;&gt;&lt;/result&gt;\n        &lt;/association&gt;\n    &lt;/resultMap&gt;\n    &lt;select id=&quot;findEmpJoinDeptByEmpno&quot; resultMap=&quot;empJoinDept&quot; &gt;\n        select * from\n        emp e\n        left join dept  d\n        on e.deptno =d.deptno\n        where empno = #&#123;empno&#125;\n    &lt;/select&gt;\n&lt;/mapper&gt;\n</code></pre>\n<p>测试代码</p>\n<pre><code class=\"java\">@Test\npublic void testOneToOne() throws ParseException &#123;\n    EmpMapper mapper = sqlSession.getMapper(EmpMapper.class);\n    Emp emp = mapper.findEmpJoinDeptByEmpno(7499);\n    System.out.println(emp);\n&#125;\n</code></pre>\n<p>3 一对多关联查询</p>\n<p>根据部门号查询部门信息及该部门的所有员工信息</p>\n<p>实体类</p>\n<pre><code class=\"java\">@Data\n@AllArgsConstructor\n@NoArgsConstructor\npublic class Dept implements Serializable &#123;\n    private Integer deptno;\n    private String dname;\n    private String loc;\n    // 组合一个Emp的List集合作为属性\n    private List&lt;Emp&gt; empList;\n&#125;\n</code></pre>\n<p>接口</p>\n<pre><code class=\"java\">package com.msb.mapper;\nimport com.msb.pojo.Dept;\n/**\n * @Author: Ma HaiYang\n * @Description: MircoMessage:Mark_7001\n */\npublic interface DeptMapper &#123;\n    /**\n     * 根据部门编号查询部门信息及该部分的所有员工信息\n     * @param deptno 要查询的部门编号\n     * @return Dept对象,内部组合了一个Emp的List属性用于封装部门的所有员工信息\n     */\n    Dept findDeptJoinEmpsByDeptno(int deptno);\n&#125;\n</code></pre>\n<p>映射文件</p>\n<pre><code class=\"xml\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;\n&lt;!DOCTYPE mapper\n        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;\n        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;\n&lt;mapper namespace=&quot;com.msb.mapper.DeptMapper&quot;&gt;\n    &lt;!--Dept findDeptJoinEmpsByDeptno(int deptno);--&gt;\n    &lt;resultMap id=&quot;deptJoinEmps&quot; type=&quot;dept&quot;&gt;\n        &lt;id column=&quot;deptno&quot; property=&quot;deptno&quot;&gt;&lt;/id&gt;\n        &lt;result column=&quot;dname&quot; property=&quot;dname&quot;&gt;&lt;/result&gt;\n        &lt;result column=&quot;loc&quot; property=&quot;loc&quot;&gt;&lt;/result&gt;\n        &lt;!--处理一对多关系的标签--&gt;\n        &lt;collection property=&quot;empList&quot; ofType=&quot;emp&quot; &gt;\n            &lt;!--设置emp本身的八个属性的映射关系--&gt;\n            &lt;id property=&quot;empno&quot; column=&quot;empno&quot;&gt;&lt;/id&gt;\n            &lt;result property=&quot;ename&quot; column=&quot;ename&quot;&gt;&lt;/result&gt;\n            &lt;result property=&quot;job&quot; column=&quot;job&quot;&gt;&lt;/result&gt;\n            &lt;result property=&quot;sal&quot; column=&quot;sal&quot;&gt;&lt;/result&gt;\n            &lt;result property=&quot;hiredate&quot; column=&quot;hiredate&quot;&gt;&lt;/result&gt;\n            &lt;result property=&quot;mgr&quot; column=&quot;mgr&quot;&gt;&lt;/result&gt;\n            &lt;result property=&quot;comm&quot; column=&quot;comm&quot;&gt;&lt;/result&gt;\n            &lt;result property=&quot;deptno&quot; column=&quot;deptno&quot;&gt;&lt;/result&gt;\n        &lt;/collection&gt;\n    &lt;/resultMap&gt;\n    &lt;select id=&quot;findDeptJoinEmpsByDeptno&quot; resultMap=&quot;deptJoinEmps&quot;&gt;\n        select * from dept d left join emp e on d.deptno =e.deptno where d.deptno =#&#123;deptno&#125;\n    &lt;/select&gt;\n&lt;/mapper&gt;\n</code></pre>\n<p>测试代码</p>\n<pre><code class=\"java\">@Test\npublic void testOneToMany() throws ParseException &#123;\n    DeptMapper mapper = sqlSession.getMapper(DeptMapper.class);\n    Dept dept = mapper.findDeptJoinEmpsByDeptno(20);\n    System.out.println(dept);\n    System.out.println(&quot;---------&quot;);\n    List&lt;Emp&gt; empList = dept.getEmpList();\n    empList.forEach(System.out::println);\n&#125;\n</code></pre>\n<p>4 多对多关联查询</p>\n<p>根据项目编号查询项目信息,以及参与到该项目之中的所有的员工信息</p>\n<p>实体类</p>\n<pre><code class=\"java\">@NoArgsConstructor\n@AllArgsConstructor\n@Data\npublic class Project  implements Serializable &#123;\n    private Integer pid;\n    private String pname;\n    private Integer money;\n    // 组合一个ProjectRecord对象集合作为属性\n    private List&lt;ProjectRecord&gt; projectRecords;\n&#125;\n@Data\n@AllArgsConstructor\n@NoArgsConstructor\npublic class ProjectRecord implements Serializable &#123;\n    private Integer empno;\n    private Integer pid;\n    // 组合一个Emp对象作为属性\n    private Emp emp;\n&#125;\n</code></pre>\n<p>接口</p>\n<pre><code class=\"java\">package com.msb.mapper;\nimport com.msb.pojo.Emp;\nimport com.msb.pojo.Project;\n/**\n * @Author: Ma HaiYang\n * @Description: MircoMessage:Mark_7001\n */\npublic interface ProjectMapper &#123;\n    /**\n     * 根据项目编号查询一个项目信息及参与该项目的所有员工信息\n     * @param pid 项目编号\n     * @return 所有信息封装的Project对象\n     */\n    Project findProjectJoinEmpsByPid(int pid);\n&#125;\n</code></pre>\n<p>映射文件</p>\n<pre><code class=\"xml\">&lt;!DOCTYPE mapper\n        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;\n        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;\n&lt;mapper namespace=&quot;com.msb.mapper.ProjectMapper&quot;&gt;\n    &lt;!--Project findProjectJoinEmpsByPid(int pid);--&gt;\n    &lt;resultMap id=&quot;projectJoinEmps&quot; type=&quot;project&quot;&gt;\n        &lt;id column=&quot;pid&quot; property=&quot;pid&quot;&gt;&lt;/id&gt;\n        &lt;result column=&quot;pname&quot; property=&quot;pname&quot;&gt;&lt;/result&gt;\n        &lt;result column=&quot;money&quot; property=&quot;money&quot;&gt;&lt;/result&gt;\n        &lt;!--一对多 集合属性 collection--&gt;\n        &lt;collection property=&quot;projectRecords&quot; ofType=&quot;projectRecord&quot;&gt;\n            &lt;id column=&quot;empno&quot; property=&quot;empno&quot;&gt;&lt;/id&gt;\n            &lt;id column=&quot;pid&quot; property=&quot;pid&quot;&gt;&lt;/id&gt;\n            &lt;!--一对一 --&gt;\n            &lt;association property=&quot;emp&quot; javaType=&quot;emp&quot;&gt;\n                &lt;id property=&quot;empno&quot; column=&quot;empno&quot;&gt;&lt;/id&gt;\n                &lt;result property=&quot;ename&quot; column=&quot;ename&quot;&gt;&lt;/result&gt;\n                &lt;result property=&quot;job&quot; column=&quot;job&quot;&gt;&lt;/result&gt;\n                &lt;result property=&quot;sal&quot; column=&quot;sal&quot;&gt;&lt;/result&gt;\n                &lt;result property=&quot;hiredate&quot; column=&quot;hiredate&quot;&gt;&lt;/result&gt;\n                &lt;result property=&quot;mgr&quot; column=&quot;mgr&quot;&gt;&lt;/result&gt;\n                &lt;result property=&quot;comm&quot; column=&quot;comm&quot;&gt;&lt;/result&gt;\n                &lt;result property=&quot;deptno&quot; column=&quot;deptno&quot;&gt;&lt;/result&gt;\n            &lt;/association&gt;\n        &lt;/collection&gt;\n    &lt;/resultMap&gt;\n    &lt;select id=&quot;findProjectJoinEmpsByPid&quot;  resultMap=&quot;projectJoinEmps&quot;&gt;\n        select * from\n        project p\n        left join projectrecord pr\n        on p.pid = pr.pid\n        left join emp e\n        on e.empno = pr.empno\n        where p.pid= #&#123;pid&#125;\n    &lt;/select&gt;\n&lt;/mapper&gt;\n</code></pre>\n<p>测试代码</p>\n<pre><code class=\"java\">@Test\npublic void testManyToMany() throws ParseException &#123;\n    ProjectMapper mapper = sqlSession.getMapper(ProjectMapper.class);\n    Project project = mapper.findProjectJoinEmpsByPid(2);\n    System.out.println(project.getPid());\n    System.out.println(project.getPname());\n    System.out.println(project.getMoney());\n    List&lt;ProjectRecord&gt; projectRecords = project.getProjectRecords();\n    for (ProjectRecord projectRecord : projectRecords) &#123;\n        Emp emp = projectRecord.getEmp();\n        System.out.println(emp);\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"2-级联查询\"><a href=\"#2-级联查询\" class=\"headerlink\" title=\"2 级联查询\"></a>2 级联查询</h2><p>级联查询，顾名思义，就是利于数据库表间的外键关联关系进行自动的级联查询操作。使用MyBatis实现级联查询，除了实体类增加关联属性外，还需要在映射文件中进行配置。</p>\n<h3 id=\"1-立即加载\"><a href=\"#1-立即加载\" class=\"headerlink\" title=\"1 立即加载\"></a>1 立即加载</h3><h3 id=\"2-延迟加载\"><a href=\"#2-延迟加载\" class=\"headerlink\" title=\"2 延迟加载\"></a>2 延迟加载</h3><p><strong>延迟加载，又称按需加载</strong>。延迟加载的内容等到真正使用时才去进行加载（查询）。多用在关联对象或集合中。</p>\n<p>延迟加载的好处：先从单表查询、需要时再从关联表去关联查询，大大降低数据库在单位时间内的查询工作量,将工作在时间上的分配更加均匀，而且单表要比关联查询多张表速度要快。</p>\n<p>延迟加载的设置</p>\n<p>第一步：全局开关：在sqlMapConfig.xml中打开延迟加载的开关。配置完成后所有的association和collection元素都生效</p>\n<pre><code class=\"xml\">  &lt;settings&gt;\n      &lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot;/&gt;\n      &lt;setting name=&quot;aggressiveLazyLoading&quot; value=&quot;true&quot;/&gt;\n  &lt;/settings&gt;\n</code></pre>\n<p><font color=#008000>lazyLoadingEnabled</font>:是否开启延迟加载。是Mybatis是否启用懒加载的全局开关。当开启时，所有关联对象都会延迟加载。特定关联关系中可通过设置fetchType属性来覆盖该项的开关状态</p>\n<p><font color=#008000 >aggressiveLazyLoading</font>：当开启时，任何方法的调用都会懒加载对象的所有属性。否则，每个属性会按需加载,</p>\n<p>第二步：分开关：指定的association和collection元素中配置<font color=#0000FF>fetchType</font>属性。eager：表示立刻加载；lazy：表示延迟加载。<strong>将覆盖全局延迟设置。</strong></p>\n<h2 id=\"3-总结\"><a href=\"#3-总结\" class=\"headerlink\" title=\"3 总结\"></a>3 总结</h2><h4 id=\"resultMap中的常见属性\"><a href=\"#resultMap中的常见属性\" class=\"headerlink\" title=\"resultMap中的常见属性\"></a>resultMap中的常见属性</h4><table style=\"text-align: center;\" cellpadding=\"30\" >\n    <tr style=\"background-color:#E2EFD9 ;\">\n            <td>property</td>\n            <td>需要映射到JavaBean 的属性名称</td>\n        </tr>\n        <tr>\n            <td >javaType</td>\n            <td>property的类型，一个完整的类名，或者是一个类型别名。如果你匹配的是一个JavaBean，那MyBatis 通常会自行检测到</td>\n        </tr>\n        <tr style=\"background-color:#E2EFD9 ;\">\n            <td>column</td>\n            <td>数据表的列名或者列别名</td>\n        </tr>\n        <tr>\n            <td>jdbcType</td>\n            <td>column在数据库表中的类型。这个属性只在insert,update   或delete 的时候针对允许空的列有用。JDBC 需要这项，但MyBatis 不需要</td>\n        </tr>\n        <tr style=\"background-color:#E2EFD9 ;\">\n            <td>typeHandler</td>\n            <td>使用这个属性可以覆写类型处理器，实现javaType、jdbcType之间的相互转换。一般可以省略，会探测到使用的什么类型的typeHandler进行处理</td>\n        </tr>\n        <tr>\n            <td>fetchType</td>\n            <td>自动延迟加载</td>\n        </tr>\n        <tr style=\"background-color:#E2EFD9 ;\">\n            <td>select</td>\n            <td>association、collection的属性，使用哪个查询查询属性的值，要求指定namespace+id的全名称</td>\n        </tr>\n        <tr>\n            <td>ofType</td>\n            <td>collection的属性，指明集合中元素的类型（即泛型类型）</td>\n        </tr>\n    </table>\n\n\n\n\n<h4 id=\"级联查询和多表查询的比较及其选择\"><a href=\"#级联查询和多表查询的比较及其选择\" class=\"headerlink\" title=\"级联查询和多表查询的比较及其选择\"></a>级联查询和多表查询的比较及其选择</h4><table style=\"text-align: center;\" cellpadding=\"30\" >\n    <tr style=\"background-color:#E2EFD9 ;\">\n            <td>SQL语句数量</td>\n        <td>多条</td>\n        <td>一条</td>\n    </tr>\n    <tr>\n        <td >性能</td>\n        <td>性能低</td>\n        <td>性能高</td>\n    </tr>\n    <tr style=\"background-color:#E2EFD9 ;\">\n        <td>延迟加载</td>\n        <td>立即加载、延迟加载</td>\n        <td>只有立即加载</td>\n    </tr>\n    <tr>\n        <td>灵活性</td>\n        <td>更灵活</td>\n        <td>不灵活</td>\n    </tr>\n    <tr style=\"background-color:#E2EFD9 ;\">\n        <td>SQL难易度</td>\n        <td>简单</td>\n        <td>复杂</td>\n    </tr>\n    <tr>\n        <td>选择依据</td>\n        <td>简单、灵活</td>\n        <td>高性能</td>\n    </tr>\n</table>\n\n\n\n\n<p><strong>ResultType和ResultMap使用场景</strong></p>\n<ol>\n<li><pre><code>如果你做的是单表的查询并且封装的实体和数据库的字段一一对应   resultType\n</code></pre>\n</li>\n<li><pre><code>如果实体封装的属性和数据库的字段不一致  resultMap\n</code></pre>\n</li>\n<li><pre><code> 使用N+1级联查询的时候  resultMap\n</code></pre>\n</li>\n<li><pre><code>使用的是多表的连接查询  resultMap\n</code></pre>\n</li>\n</ol>\n<p><strong>一对一关联映射的实现</strong></p>\n<ol>\n<li><pre><code>实例：学生和学生证、雇员和工牌\n</code></pre>\n</li>\n<li><pre><code>数据库层次：主键关联或者外键关联（参看之前内容）\n</code></pre>\n</li>\n<li><pre><code> MyBatis层次：在映射文件的设置双方均使用association即可，用法相同\n</code></pre>\n</li>\n</ol>\n<p><strong>多对多映射的实现</strong></p>\n<ol>\n<li><pre><code>实例：学生和课程、用户和角色\n</code></pre>\n</li>\n<li><pre><code> 数据库层次：引入一个中间表将一个多对多转为两个一对多\n</code></pre>\n</li>\n<li><pre><code> MyBatis层次\n</code></pre>\n</li>\n</ol>\n<p>方法1：在映射文件的设置双方均使用collection即可，不用引入中间类</p>\n<p>方法2：引入中间类和中间类的映射文件，按照两个一对多处理</p>\n<p><strong>自关联映射</strong></p>\n<ol>\n<li><pre><code>实例：Emp表中的员工和上级。一般是一对多关联\n</code></pre>\n</li>\n<li><pre><code>数据库层次：外键参考当前表的主键（比如mgr参考empno）\n</code></pre>\n</li>\n<li><p>MyBatis层次：按照一对多处理，但是增加的属性都写到一个实体类中，增加的映射也都写到一个映射文件中</p>\n</li>\n</ol>\n<h1 id=\"9-MyBatis注解开发\"><a href=\"#9-MyBatis注解开发\" class=\"headerlink\" title=\"9 MyBatis注解开发\"></a>9 MyBatis注解开发</h1><pre><code class=\"java\">public interface DeptMapper &#123;\n    Dept findDeptByDeptno(int deptno);\n    @Select(&quot;select * from dept where deptno =#&#123;deptno&#125;&quot;)\n    Dept findByDeptno(int deptno);\n    int updateDept(Dept dept);\n    int addDept(Dept dept);\n    @Delete(&quot;delete from dept where deptno =#&#123;deptno&#125;&quot;)\n    int removeDept(int deptno);\n&#125;\n</code></pre>\n<p>1.使用注解没有实现Java代码和SQL语句的解耦</p>\n<p>2.无法实现SQL语句的动态拼接</p>\n<p>3.进行多表的查询时定制ResultMap比较麻烦</p>\n<p><strong>注解和XML的优缺点</strong></p>\n<table style=\"text-align: center;\" cellpadding=\"30\" >\n    <tr style=\"background-color:#E2EFD9 ;\">\n            <td>优点</td>\n        <td>类和类之间的解耦</td>\n        <td>简化配置</td>\n    </tr>\n    <tr>\n        <td > </td>\n        <td>利于修改。直接修改XML文件，无需到源代码中修改。</td>\n        <td>使用起来直观且容易，提升开发效率</td>\n    </tr>\n    <tr style=\"background-color:#E2EFD9 ;\">\n        <td></td>\n        <td>配置集中在XML中，对象间关系一目了然，利于快速了解项目和维护</td>\n        <td>类型安全，编译器进行校验，不用等到运行期才会发现错误</td>\n    </tr>\n    <tr>\n        <td></td>\n        <td>容易和其他系统进行数据交交换</td>\n        <td>注解的解析可以不依赖于第三方库，可以直接使用Java自带的反射</td>\n    </tr>\n</table>\n\n\n\n\n\n\n<h1 id=\"10-缓存\"><a href=\"#10-缓存\" class=\"headerlink\" title=\"10 缓存\"></a>10 缓存</h1><img data-src=\"/2022/10/07/ORM/Mybatis/image-20220617211853352.png\" class=\"\" title=\"image-20220617211853352\">\n\n<blockquote>\n<p>​\t是一种临时存储少量数据至内存或者是磁盘的一种技术.减少数据的加载次数,可以降低工作量,提高程序响应速度</p>\n<p>​\t缓存的重要性是不言而喻的。mybatis的缓存将相同查询条件的SQL语句执行一遍后所得到的结果存在内存或者某种缓存介质当中，当下次遇到一模一样的查询SQL时候不在执行SQL与数据库交互，而是直接从缓存中获取结果，减少服务器的压力；尤其是在查询越多、缓存命中率越高的情况下，使用缓存对性能的提高更明显。</p>\n<p>​\tMyBatis允许使用缓存，缓存一般放置在高速读&#x2F;写的存储器上，比如服务器的内存，能够有效的提供系统性能。MyBatis分为<font color=#FF0000>一级缓存和二级缓存</font>，同时也可配置关于缓存设置。</p>\n<p>​\t一级存储是SqlSession上的缓存，二级缓存是在SqlSessionFactory(namespace)上的缓存。默认情况下，MyBatis开启一级缓存，没有开启二级缓存。当数据量大的时候可以借助一些第三方缓存框架或Redis缓存来协助保存Mybatis的二级缓存数据。</p>\n</blockquote>\n<img data-src=\"/2022/10/07/ORM/Mybatis/image-20220617211938471.png\" class=\"\" title=\"image-20220617211938471\">\n\n\n\n<h2 id=\"1-一级缓存\"><a href=\"#1-一级缓存\" class=\"headerlink\" title=\"1 一级缓存\"></a>1 一级缓存</h2><p>一级存储是SqlSession上的缓存，默认开启，是一种内存型缓存,不要求实体类对象实现Serializable接口。</p>\n<p>缓存中的数据使用键值对形式存储数据</p>\n<p>&#x3D;&#x3D;namespace + sqlid + args + offset     &gt;&gt;&gt;   hash 值作为键,查询出的结果作为值&#x3D;&#x3D;</p>\n<img data-src=\"/2022/10/07/ORM/Mybatis/image-20220617212008075.png\" class=\"\" title=\"image-20220617212008075\">\n\n<p>测试 代码</p>\n<pre><code class=\"java\">@Test\npublic void testFindDeptByDetpno()   &#123;\n    EmpMapper mapper = sqlSession.getMapper(EmpMapper.class);\n    Emp emp = mapper.findByEmpno(7521);\n    System.out.println(emp);\n    // 中间发生了增删改或者是调用了SqlSession调用了commit,会自动清空缓存\n    sqlSession.commit();// 增删改的时候调用\n    EmpMapper mapper2 = sqlSession.getMapper(EmpMapper.class);\n    Emp emp2 = mapper2.findByEmpno(7521);\n    System.out.println(emp2); \n    \n    System.out.println(emp==emp2);// 没有commit之前为True\n    System.out.println(mapper==mapper2);// false 表示确实产生了两个代理对象\n&#125;\n</code></pre>\n<h2 id=\"2-二级缓存\"><a href=\"#2-二级缓存\" class=\"headerlink\" title=\"2 二级缓存\"></a>2 二级缓存</h2><p>二级缓存是以namespace为标记的缓存，可以是由一个SqlSessionFactory创建的SqlSession之间共享缓存数据。默认并不开启。下面的代码中创建了两个SqlSession，执行相同的SQL语句，尝试让第二个SqlSession使用第一个SqlSession查询后缓存的数据。要求实体类必须实现序列化接口</p>\n<img data-src=\"/2022/10/07/ORM/Mybatis/image-20220617212052512.png\" class=\"\" title=\"image-20220617212052512\">\n\n\n\n<p>接口</p>\n<pre><code class=\"java\">public interface EmpMapper &#123;\n    Emp findByEmpno(int empno);\n&#125;\n</code></pre>\n<p>映射文件</p>\n<pre><code class=\"xml\">&lt;mapper namespace=&quot;com.msb.mapper.EmpMapper&quot;&gt;\n    &lt;cache/&gt;\n    &lt;select id=&quot;findByEmpno&quot; resultType=&quot;emp&quot; useCache=&quot;true&quot; flushCache=&quot;false&quot;&gt;\n        select * from emp where empno =#&#123;empno&#125;\n    &lt;/select&gt;\n&lt;/mapper&gt;\n</code></pre>\n<p>测试 代码</p>\n<pre><code class=\"java\">package com.msb.test;\nimport com.msb.mapper.EmpMapper;\nimport com.msb.pojo.Emp;\nimport org.apache.ibatis.io.Resources;\nimport org.apache.ibatis.session.SqlSession;\nimport org.apache.ibatis.session.SqlSessionFactory;\nimport org.apache.ibatis.session.SqlSessionFactoryBuilder;\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Test;\nimport java.io.IOException;\nimport java.io.InputStream;\n/**\n * @Author: Ma HaiYang\n * @Description: MircoMessage:Mark_7001\n */\npublic class Test3 &#123;\n    private SqlSession sqlSession;\n    private SqlSession sqlSession2;\n    @Before\n    public void init()&#123;\n        SqlSessionFactoryBuilder ssfb =new SqlSessionFactoryBuilder();\n        InputStream resourceAsStream = null;\n        try &#123;\n            resourceAsStream = Resources.getResourceAsStream(&quot;sqlMapConfig.xml&quot;);\n        &#125; catch (IOException e) &#123;\n            e.printStackTrace();\n        &#125;\n        SqlSessionFactory factory=ssfb.build(resourceAsStream) ;\n        sqlSession=factory.openSession();\n        sqlSession2=factory.openSession();\n    &#125;\n    @Test\n    public void testFindDeptByDetpno()   &#123;\n        EmpMapper mapper = sqlSession.getMapper(EmpMapper.class);\n        Emp emp = mapper.findByEmpno(7521);\n        System.out.println(emp);\n        // SqlSession提交之后,才会将查询的结果放入二级缓存\n        sqlSession.commit();\n        EmpMapper mapper2 = sqlSession2.getMapper(EmpMapper.class);\n        Emp emp2 = mapper2.findByEmpno(7521);\n        System.out.println(emp2);\n    &#125;\n    @After\n    public void release()&#123;\n        // 关闭SQLSession\n        sqlSession.close();\n        sqlSession2.close();\n    &#125;\n&#125;\n</code></pre>\n<p><strong>注意：</strong></p>\n<p>​\t其中的commit()，执行该命令后才会将该SqlSession的查询结果从一级缓存中放入二级缓存，供其他SqlSession使用。另外执行SqlSession的close()也会将该SqlSession的查询结果从一级缓存中放入二级缓存。两种方式区别在当前SqlSession是否关闭了。</p>\n<p>执行结果显示进行了两次对数据库的SQL查询，说明二级缓存并没有开启。需要进行如下步骤完成开启。</p>\n<ol>\n<li>全局开关：在sqlMapConfig.xml文件中的<font color=blue><settings></font>标签配置开启二级缓存</li>\n</ol>\n<pre><code class=\"xml\">&lt;settings&gt;\n    &lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt;\n&lt;/settings&gt;\n</code></pre>\n<p>cacheEnabled的默认值就是true，所以这步的设置可以省略。</p>\n<ol start=\"2\">\n<li>分开关：在要开启二级缓存的mapper文件中开启缓存：</li>\n</ol>\n<pre><code class=\"xml\">&lt;mapper namespace=&quot;com.msb.mapper.EmployeeMapper&quot;&gt;\n    &lt;cache/&gt;\n&lt;/mapper&gt;\n</code></pre>\n<ol start=\"3\">\n<li>二级缓存未必完全使用内存,有可能占用硬盘存储,缓存中存储的JavaBean对象必须实现序列化接口,</li>\n</ol>\n<pre><code class=\"java\">public class Emp implements  Serializable &#123;  &#125;\n</code></pre>\n<p>经过设置后，查询结果如图所示。发现第一个SqlSession会首先去二级缓存中查找，如果不存在，就查询数据库，<font color=#FF0000>在commit()或者close()的时候将数据放入到二级缓存</font>。第二个SqlSession执行相同SQL语句查询时就直接从二级缓存中获取了。</p>\n<p><strong>注意：</strong></p>\n<p>​\t1)    MyBatis的二级缓存的缓存介质有多种多样，而并不一定是在内存中，所以需要对JavaBean对象实现序列化接口。</p>\n<ol start=\"2\">\n<li>二级缓存是以 namespace 为单位的，不同 namespace 下的操作互不影响</li>\n</ol>\n<p>​\t3)    加入Cache元素后，会对相应命名空间所有的select元素查询结果进行缓存，而其中的insert、update、delete在操作是会清空整个namespace的缓存。</p>\n<p>​\t4)    cache 有一些可选的属性 type, eviction, flushInterval, size, readOnly, blocking。</p>\n<pre><code class=\"xml\">&lt;cache type=&quot;&quot; readOnly=&quot;&quot; eviction=&quot;&quot;flushInterval=&quot;&quot;size=&quot;&quot;blocking=&quot;&quot;/&gt;\n</code></pre>\n<p>&lt;cache type&#x3D;”” readOnly&#x3D;”” eviction&#x3D;””flushInterval&#x3D;””size&#x3D;””blocking&#x3D;””&#x2F;&gt;</p>\n<table style=\"text-align: center;\" cellpadding=\"30\" >\n    <style>\n        td {\n            text-align:center;\n        }\n        p {\n          text-align:center;\n        }\n    </style>\n    <tr style=\"background-color:#E2EFD9 ;\">\n            <td>type</td>\n         <td><p>自定义缓存类，要求实现org.apache.ibatis.cache.Cache接口</p></td>\n            <td>null</td>\n        </tr>\n        <tr>\n            <td>readOnly</td>\n            <td ><p>是否只读</p>\n                <p> true:给所有调用者返回缓存对象的相同实例。因此这些对象不能被修改。 </p>\n                <span> 这提供了很重要的性能优势。</span>\n                <p>false:会返回缓存对象的拷贝(通过序列化)。</p>\n                <p> 这会慢一些,但是安全</p>\n            </td>\n            <td>false</td>\n        </tr>\n        <tr style=\"background-color:#E2EFD9 ;\">\n            <td>eviction</td>\n            <td>\t \n                <p>缓存策略<br>LRU（默认） – 最近最少使用：移除最长时间不被使用的对象。</p>\n                <p>FIFO – 先进先出：按对象进入缓存的顺序来移除它们。</p>\n                <p>SOFT – 软引用：基于垃圾回收器状态和软引用规则移除对象。</p>\n                <p>WEAK – 弱引用：更积极地基于垃圾收集器状态和弱引用规则移除对象。</p>\n            </td>\n            <td>LRU</td>\n        </tr>\n        <tr>\n            <td>flushInterval</td>\n            <td><p>\n                    刷新间隔，毫秒为单位。默认为null，也就是没有刷新间隔，\n                </p>\n                <p>\n                    只有执行update、insert、delete语句才会刷新\n                </p>\n            </td>\n            <td>null</td>\n        </tr>\n        <tr style=\"background-color:#E2EFD9 ;\">\n             <td>size</td>\n            <td><p>缓存对象个数<p></td>\n            <td>1024</td>\n        </tr>\n        <tr>\n            <td>blocking</td>\n            <td>\n                <p>是否使用阻塞性缓存BlockingCache</p>\n                <p>true：在查询缓存时锁住对应的Key，如果缓存命中了则会释放对应的锁，</p>\n                <span>否则会在查询数据库以后再释放锁，</span>\n                <p>保证只有一个线程到数据库中查找指定key对应的数据</p>\n                <p>false：不使用阻塞性缓存，性能更好</p>\n            </td>\n            <td>false</td>\n        </tr>\n</table>\n\n\n\n\n\n<ol start=\"5\">\n<li>如果在加入Cache元素的前提下让个别select 元素不使用缓存，可以使用useCache属性，设置为false。useCache控制当前sql语句是否启用缓存  flushCache控制当前sql执行一次后是否刷新缓存</li>\n</ol>\n<pre><code class=\"xml\">&lt;select id=&quot;findByEmpno&quot; resultType=&quot;emp&quot; useCache=&quot;true&quot; flushCache=&quot;false&quot;&gt;\n</code></pre>\n<h2 id=\"3-三方缓存\"><a href=\"#3-三方缓存\" class=\"headerlink\" title=\"3 三方缓存\"></a>3 三方缓存</h2><blockquote>\n<p>分布式缓存框架：我们系统为了提高系统并发和性能，一般对系统进行分布式部署（集群部署方式）不适用分布缓存， 缓存的数据在各个服务单独存储，不方便系统开发。所以要使用分布式缓存对缓存数据进行集中管理.ehcache,redis ,memcache缓存框架。</p>\n</blockquote>\n<p>Ehcache：是一种广泛使用的开源java分布式缓存。主要面向通用缓存，javaEE 和 轻量级容器。它具有内存和磁盘存储功能。被用于大型复杂分布式web application的</p>\n<p>这里的三方缓存是作为二级缓存使用的</p>\n<p>导入依赖的jar文件</p>\n<pre><code class=\"xml\"> &lt;dependency&gt;\n    &lt;groupId&gt;org.mybatis.caches&lt;/groupId&gt;\n    &lt;artifactId&gt;mybatis-ehcache&lt;/artifactId&gt;\n    &lt;version&gt;1.0.2&lt;/version&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;net.sf.ehcache&lt;/groupId&gt;\n    &lt;artifactId&gt;ehcache&lt;/artifactId&gt;\n    &lt;version&gt;2.10.1&lt;/version&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.slf4j&lt;/groupId&gt;\n    &lt;artifactId&gt;slf4j-nop&lt;/artifactId&gt;\n    &lt;version&gt;1.7.2&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>\n<p>去各自的sql映射文件里,开启二级缓存,并把缓存类型指定为EhcacheCache</p>\n<pre><code class=\"xml\"> &lt;cache type=&quot;org.mybatis.caches.ehcache.EhcacheCache&quot;/&gt;\n</code></pre>\n<p>在资源目录下放置一个缓存配置文件,文件名为: ehcache.xml 内容如下</p>\n<pre><code class=\"xml\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;ehcache xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n         xsi:noNamespaceSchemaLocation=&quot;ehcache.xsd&quot;\n         updateCheck=&quot;true&quot; monitoring=&quot;autodetect&quot;\n         dynamicConfig=&quot;true&quot;&gt;\n    &lt;diskStore path=&quot;D:\\msb\\ehcache&quot; /&gt;\n    &lt;defaultCache\n            maxElementsInMemory=&quot;1000&quot;\n            maxElementsOnDisk=&quot;10000000&quot;\n            eternal=&quot;false&quot;\n            overflowToDisk=&quot;true&quot;\n            timeToIdleSeconds=&quot;120&quot;\n            timeToLiveSeconds=&quot;120&quot;\n            diskExpiryThreadIntervalSeconds=&quot;120&quot;\n            memoryStoreEvictionPolicy=&quot;LRU&quot;&gt;\n    &lt;/defaultCache&gt;\n&lt;/ehcache&gt;\n        &lt;!--  Cache配置\n        ·           name：Cache的唯一标识\n        ·           maxElementsInMemory：内存中最大缓存对象数。\n        ·           maxElementsOnDisk：磁盘中最大缓存对象数，若是0表示无穷大。\n        ·           eternal：Element是否永久有效，一但设置了，timeout将不起作用。\n        ·           overflowToDisk：配置此属性，当内存中Element数量达到maxElementsInMemory时，Ehcache将会Element写到磁盘中。\n        ·           timeToIdleSeconds：设置Element在失效前的允许闲置时间。仅当element不是永久有效时使用，可选属性，默认值是0，也就是可闲置时间无穷大。\n        ·           timeToLiveSeconds：设置Element在失效前允许存活时间。最大时间介于创建时间和失效时间之间。仅当element不是永久有效时使用，默认是0.，也就是element存活时间无穷大。\n        ·           diskExpiryThreadIntervalSeconds：磁盘失效线程运行时间间隔，默认是120秒。\n        ·           diskSpoolBufferSizeMB：这个参数设置DiskStore（磁盘缓存）的缓存区大小。默认是30MB。每个Cache都应该有自己的一个缓冲区。\n        ·           memoryStoreEvictionPolicy：当达到maxElementsInMemory限制时，Ehcache将会根据指定的策略去清理内存。默认策略是LRU（最近最少使用）。你可以设置为FIFO（先进先出）或是LFU（较少使用）。     --&gt;\n</code></pre>\n<h1 id=\"11-逆向工程\"><a href=\"#11-逆向工程\" class=\"headerlink\" title=\"11 逆向工程\"></a>11 逆向工程</h1><blockquote>\n<p>MyBatisPlus 内容，简略分析，可以参考后面具体内容</p>\n</blockquote>\n<p>MyBatis的一个主要的特点就是需要程序员自己编写SQL，那么如果表太多的话，难免会很麻烦，所以MyBatis官方提供了一个逆向工程，可以针对单表自动生成MyBatis执行所需要的代码（包括mapper.xml，mapper.java，pojo）。一般在开发中，常用的逆向工程方式是通过数据库的表生成代码。</p>\n<p>创建maven项目导入逆向工程依赖</p>\n<img data-src=\"/2022/10/07/ORM/Mybatis/image-20220617221042957.png\" class=\"\" title=\"image-20220617221042957\">\n\n<pre><code class=\"xml\">&lt;dependencies&gt;\n  \n    &lt;!-- mysql驱动包 --&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;mysql&lt;/groupId&gt;\n        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;\n        &lt;version&gt;8.0.16&lt;/version&gt;\n    &lt;/dependency&gt;\n    &lt;!-- 日志包，方便查看执行信息--&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.slf4j&lt;/groupId&gt;\n        &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;\n        &lt;version&gt;1.6.1&lt;/version&gt;\n    &lt;/dependency&gt;\n    &lt;!-- 代码生成工具jar --&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt;\n        &lt;artifactId&gt;mybatis-generator-core&lt;/artifactId&gt;\n        &lt;version&gt;1.3.2&lt;/version&gt;\n    &lt;/dependency&gt;\n&lt;/dependencies&gt;\n</code></pre>\n<p>配置逆向工程配置文件 在resources目录下放置一个名为generatorConfig.xml的配置文件,文件内容如下</p>\n<pre><code class=\"xml\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;!DOCTYPE generatorConfiguration\n  PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;\n  &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt;\n&lt;generatorConfiguration&gt;\n   &lt;context id=&quot;testTables&quot; targetRuntime=&quot;MyBatis3&quot;&gt;\n      &lt;commentGenerator&gt;\n         &lt;!-- 是否去除自动生成的注释 true：是 ： false:否 --&gt;\n         &lt;property name=&quot;suppressAllComments&quot; value=&quot;true&quot; /&gt;\n      &lt;/commentGenerator&gt;\n      &lt;!--数据库连接的信息：驱动类、连接地址、用户名、密码 --&gt;\n      &lt;!-- &lt;jdbcConnection driverClass=&quot;com.mysql.jdbc.Driver&quot;\n         connectionURL=&quot;jdbc:mysql://localhost:3306/mybatis&quot; userId=&quot;root&quot;\n         password=&quot;123&quot;&gt;\n      &lt;/jdbcConnection&gt; --&gt;\n       &lt;jdbcConnection driverClass=&quot;com.mysql.cj.jdbc.Driver&quot;\n         connectionURL=&quot;jdbc:mysql://127.0.0.1:3306/mydb?useSSL=false&amp;amp;useUnicode=true&amp;amp;characterEncoding=UTF-8&amp;amp;serverTimezone=Asia/Shanghai&amp;amp;allowPublicKeyRetrieval=true&quot;\n         userId=&quot;root&quot;\n         password=&quot;root&quot;&gt;\n      &lt;/jdbcConnection&gt; \n      &lt;!-- 默认false，把JDBC DECIMAL 和 NUMERIC 类型解析为 Integer，为 true时把JDBC DECIMAL 和 \n         NUMERIC 类型解析为java.math.BigDecimal --&gt;\n      &lt;javaTypeResolver&gt;\n         &lt;property name=&quot;forceBigDecimals&quot; value=&quot;false&quot; /&gt;\n      &lt;/javaTypeResolver&gt;\n      &lt;!-- targetProject:生成PO类的位置 --&gt;\n      &lt;javaModelGenerator targetPackage=&quot;com.msb.pojo&quot;\n         targetProject=&quot;.\\src&quot;&gt;\n         &lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt;\n         &lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot; /&gt;\n         &lt;!-- 从数据库返回的值被清理前后的空格 --&gt;\n         &lt;property name=&quot;trimStrings&quot; value=&quot;true&quot; /&gt;\n      &lt;/javaModelGenerator&gt;\n        &lt;!-- targetProject:mapper映射文件生成的位置 --&gt;\n      &lt;sqlMapGenerator targetPackage=&quot;com.msb.mapper&quot;\n         targetProject=&quot;.\\src&quot;&gt;\n         &lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt;\n         &lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot; /&gt;\n      &lt;/sqlMapGenerator&gt;\n      &lt;!-- targetPackage：mapper接口生成的位置 --&gt;\n      &lt;javaClientGenerator type=&quot;XMLMAPPER&quot;\n         targetPackage=&quot;com.msb.mapper&quot;\n         targetProject=&quot;.\\src&quot;&gt;\n         &lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt;\n         &lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot; /&gt;\n      &lt;/javaClientGenerator&gt;\n      &lt;!-- 指定数据库表 --&gt;\n      \n      &lt;table tableName=&quot;dept&quot; domainObjectName=&quot;Dept&quot;\n       enableCountByExample=&quot;false&quot; enableUpdateByExample=&quot;false&quot; enableDeleteByExample=&quot;false&quot;    \n               enableSelectByExample=&quot;false&quot; selectByExampleQueryId=&quot;false&quot; &gt;\n               &lt;columnOverride column=&quot;id&quot; javaType=&quot;Integer&quot; /&gt;\n         &lt;/table&gt;\n      \n   &lt;/context&gt;\n&lt;/generatorConfiguration&gt;\n</code></pre>\n<p>在resources目录下放置一个名为log4j.properties的配置文件,文件内容如下</p>\n<pre><code class=\"properties\">log4j.rootLogger=debug,stdout\nlog4j.appender.stdout=org.apache.log4j.ConsoleAppender\nlog4j.appender.stdout.Target=System.err\nlog4j.appender.stdout.layout=org.apache.log4j.SimpleLayout\nlog4j.appender.logfile=org.apache.log4j.FileAppender\nlog4j.appender.logfile.File=d:/msb.log\nlog4j.appender.logfile.layout=org.apache.log4j.PatternLayout\nlog4j.appender.logfile.layout.ConversionPattern=%d&#123;yyyy-MM-dd HH:mm:ss&#125; %l %F %p %m%n\n</code></pre>\n<p>运行逆向工程代码</p>\n<pre><code class=\"java\">package com.msb.gennerator;\nimport org.mybatis.generator.api.MyBatisGenerator;\nimport org.mybatis.generator.config.Configuration;\nimport org.mybatis.generator.config.xml.ConfigurationParser;\nimport org.mybatis.generator.internal.DefaultShellCallback;\nimport java.io.File;\nimport java.util.ArrayList;\nimport java.util.List;\n/**\n *\n */\npublic class GeneratorSqlmap &#123;\n    public void generator() throws Exception&#123;\n        List&lt;String&gt; warnings = new ArrayList&lt;String&gt;();\n        boolean overwrite = true;\n        File configFile = new File(&quot;D:\\\\ideaProjects\\\\reverse\\\\target\\\\classes\\\\generatorConfig.xml&quot;);\n        ConfigurationParser cp = new ConfigurationParser(warnings);\n        Configuration config = cp.parseConfiguration(configFile);\n        DefaultShellCallback callback = new DefaultShellCallback(overwrite);\n        MyBatisGenerator myBatisGenerator = new MyBatisGenerator(config,\n                callback, warnings);\n        myBatisGenerator.generate(null);\n    &#125;\n    public static void main(String[] args) throws Exception &#123;\n        try &#123;\n            GeneratorSqlmap generatorSqlmap = new GeneratorSqlmap();\n            generatorSqlmap.generator();\n        &#125; catch (Exception e) &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>生成的实体类和Mapper接口和Mapper映射文件,包含了基本的CURD功能,哪里需要文件就放哪里</p>\n<img data-src=\"/2022/10/07/ORM/Mybatis/image-20220617221208040-1665157666426.png\" class=\"\" title=\"image-20220617221208040\">\n\n<h1 id=\"12-main目录下配置文件打包问题\"><a href=\"#12-main目录下配置文件打包问题\" class=\"headerlink\" title=\"12 main目录下配置文件打包问题\"></a>12 main目录下配置文件打包问题</h1><pre><code class=\"xml\">&lt;build&gt;\n    &lt;!--告诉maven将项目源码中的xml文件也进行编译，并放到编译目录中--&gt;\n    &lt;resources&gt;\n        &lt;resource&gt;\n            &lt;directory&gt;src/main/java&lt;/directory&gt;\n            &lt;includes&gt;\n                &lt;include&gt;**/*.xml&lt;/include&gt;\n            &lt;/includes&gt;\n            &lt;filtering&gt;true&lt;/filtering&gt;\n        &lt;/resource&gt;\n        &lt;resource&gt;\n            &lt;directory&gt;src/main/resources&lt;/directory&gt;\n            &lt;filtering&gt;true&lt;/filtering&gt;\n        &lt;/resource&gt;\n    &lt;/resources&gt;\n&lt;/build&gt;\n</code></pre>\n",
            "tags": [
                "框架",
                "ORM"
            ]
        },
        {
            "id": "http://example.com/2022/10/07/Spring_Family/Spring/",
            "url": "http://example.com/2022/10/07/Spring_Family/Spring/",
            "title": "Spring",
            "date_published": "2022-10-06T16:00:00.000Z",
            "content_html": "<h1 id=\"概念：\"><a href=\"#概念：\" class=\"headerlink\" title=\"概念：\"></a>概念：</h1><ul>\n<li><p>Spring是**一个轻量级 **Java开发框架，目的是为了解决企业级应用开发的业务逻辑层和其他各层的耦合问题。它是一个分层的JavaSE&#x2F;JavaEE full-stack（一站式）轻量级开源框架，为开发Java应用程序提供全面的基础架构支持。Spring负责基础架构，因此Java开发者可以专注于应用程序的开发。</p>\n</li>\n<li><p>Spring最根本的使命是<strong>解决企业级应用开发的复杂性，</strong>即简化<em>Java</em>开发。</p>\n</li>\n<li><p>Spring可以做很多事情，它为企业级开发提供给了丰富的功能，但是这些功能的底层都依赖于它的</p>\n</li>\n</ul>\n<p>两个核心特性，也就是<strong>依赖注入（dependency injection，DI</strong>）和<strong>面向切面编程</strong>（<strong>aspect-</strong></p>\n<p><strong>oriented programming，AOP）</strong>。</p>\n<p>为了降低Java开发的复杂性，Spring采取了以下4种关键策略</p>\n<ul>\n<li><p>基于POJO的轻量级和最小侵入性编程；</p>\n</li>\n<li><p>通过依赖注入和面向接口实现松耦合；</p>\n</li>\n<li><p>基于切面和惯例进行声明式编程；</p>\n</li>\n<li><p>通过切面和模板减少样板式代码。</p>\n</li>\n</ul>\n<h1 id=\"Spring的俩大核心概念\"><a href=\"#Spring的俩大核心概念\" class=\"headerlink\" title=\"Spring的俩大核心概念\"></a>Spring的俩大核心概念</h1><h2 id=\"IOC（控制翻转）：\"><a href=\"#IOC（控制翻转）：\" class=\"headerlink\" title=\"IOC（控制翻转）：\"></a>IOC（控制翻转）：</h2><p>控制翻转，也叫依赖注入，他就是不会直接创建对象，只是把对象声明出来，在代码 中不直</p>\n<p>接与对象和服务进行连接，但是在配置文件中描述了哪一项组件需要哪一项服 务，容器将他</p>\n<p>们组件起来。在一般的IOC场景中容器创建了所有的对象，并设置了必 要的属性将他们联系</p>\n<p>在一起，等到需要使用的时候才把他们声明出来，使用注解就跟 方便了，容器会自动根据注</p>\n<p>解把对象组合起来</p>\n<h2 id=\"其中还有一个点DI-依赖注入\"><a href=\"#其中还有一个点DI-依赖注入\" class=\"headerlink\" title=\"其中还有一个点DI(依赖注入)\"></a>其中还有一个点DI(依赖注入)</h2><h2 id=\"AOP（面对切面编程）\"><a href=\"#AOP（面对切面编程）\" class=\"headerlink\" title=\"AOP（面对切面编程）\"></a>AOP（面对切面编程）</h2><p>面对切面编程，这是一种编程模式，他允许程序员通过自定义的横切点进行模块 化，将那些</p>\n<p>影响多个类的行为封装到课重用的模块中。 例子：比如日志输出，不使用AOP的话就需要把</p>\n<p>日志的输出语句放在所有类中，方法 中，但是有了AOP就可以把日志输出语句封装一个可重</p>\n<p>用模块，在以声明的方式将他 们放在类中，每次使用类就自动完成了日志输出。</p>\n<h1 id=\"Bean的生命周期\"><a href=\"#Bean的生命周期\" class=\"headerlink\" title=\"Bean的生命周期\"></a>Bean的生命周期</h1><p>1 通过构造器创建bean实例           执行构造器<br>2 为bean属性赋值                         执行set方法<br>3 初始化bean                                调用bean的初始化方法,需要配置指定调用的方法<br>4 bean的获取                                容器对象 getBean方法<br>5 容器关闭销毁bean                      调用销毁方法,需要配置指定调用的方法</p>\n<pre><code class=\"java\">public class User &#123;\n    private Integer userid;\n    private String username;\n    private String password;\n    public void initUser()&#123;\n        System.out.println(&quot;第三步:User初始化&quot;);\n    &#125;\n    public User() &#123;\n        System.out.println(&quot;第一步:User构造&quot;);\n    &#125;\n    public void destoryUser()&#123;\n        System.out.println(&quot;第五步:User销毁&quot;);\n    &#125;\n    @Override\n    public String toString() &#123;\n        return &quot;User&#123;&quot; +\n                &quot;userid=&quot; + userid +\n                &quot;, username=&#39;&quot; + username + &#39;\\&#39;&#39; +\n                &quot;, password=&#39;&quot; + password + &#39;\\&#39;&#39; +\n                &#39;&#125;&#39;;\n    &#125;\n    public User(Integer userid, String username, String password) &#123;\n        this.userid = userid;\n        this.username = username;\n        this.password = password;\n    &#125;\n    public void setUserid(Integer userid) &#123;\n        System.out.println(&quot;setUserid&quot;);\n        this.userid = userid;\n    &#125;\n    public void setUsername(String username) &#123;\n        System.out.println(&quot;第二步:User属性赋值&quot;);\n        this.username = username;\n    &#125;\n    public void setPassword(String password) &#123;\n        this.password = password;\n    &#125;\n&#125;\n</code></pre>\n<p>配置Bean</p>\n<pre><code class=\"xml\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;\n       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n       xmlns:p=&quot;http://www.springframework.org/schema/p&quot;\n       xmlns:c=&quot;http://www.springframework.org/schema/c&quot;\n       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans\n       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;\n    &lt;!--  --&gt;\n    &lt;bean id=&quot;user&quot; class=&quot;com.msb.bean.User&quot; init-method=&quot;initUser&quot; destroy-method=&quot;destoryUser&quot;&gt;\n        &lt;property name=&quot;username&quot; value=&quot;xiaoming&quot;&gt;&lt;/property&gt;\n    &lt;/bean&gt;\n&lt;/beans&gt;\n</code></pre>\n<p>根据 Class、property 通过反射去找构造器创建实例，然后对property属性根据 set 方法注入依赖也叫赋值，</p>\n<p>通过指定 init-method(初始化方法) 来对我们的对象再次进行操作，第四步获取 Bean 对象，第五步项目结束Context销毁，调用销毁方法销毁Bean</p>\n<p>&#x3D;&#x3D;以上我们是对一般的过程其实在这个基础上我们还可以再次增加两步，这个叫后置处理器，处理后的顺序：&#x3D;&#x3D;</p>\n<p>1 通过构造器创建bean实例           执行构造器<br>2 为bean属性赋值                         执行set方法<br><font color=red>3 把bean实例传递给bean的后置处理器的方法</font><br>4 初始化bean                                调用bean的初始化方法,需要配置指定调用的方法<br><font color=red>5 把bean实例传递给bean的后置处理器的方法</font><br>6 bean的获取                                容器对象 getBean方法<br>7 容器关闭销毁bean                      调用销毁方法,需要配置指定调用的方法</p>\n<p>&#x3D;&#x3D;添加后置处理器&#x3D;&#x3D;</p>\n<p><strong>1 创建后置处理器 实现 BeanPostProcesser  重写两个方法</strong></p>\n<pre><code class=\"java\">\nimport org.springframework.beans.BeansException;\nimport org.springframework.beans.factory.config.BeanPostProcessor;\n// 1 创建后置处理器 实现 BeanPostProcesser  重写两个方法\npublic class MyBeanProcesser implements BeanPostProcessor &#123;\n    @Override\n    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException &#123;\n        //Object bean      实例化的bean\n        //String beanName  bean的id\n        System.out.println(&quot;bean:初始化方法之前&quot;);\n        return bean;// 这里必须return bean\n    &#125;\n    @Override\n    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123;\n        System.out.println(&quot;bean:初始化方法之后&quot;);\n        return bean;// 这里必须returnbean\n    &#125;\n&#125;\n</code></pre>\n<p><strong>2 配置后置处理器,对容器中的所有bean添加后置处理器的生命周期</strong></p>\n<pre><code class=\"xml\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;\n       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n       xmlns:p=&quot;http://www.springframework.org/schema/p&quot;\n       xmlns:c=&quot;http://www.springframework.org/schema/c&quot;\n       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans\n       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;\n    &lt;bean id=&quot;user&quot; class=&quot;com.msb.bean.User&quot; init-method=&quot;initUser&quot; destroy-method=&quot;destoryUser&quot;&gt;\n        &lt;property name=&quot;username&quot; value=&quot;xiaoming&quot;&gt;&lt;/property&gt;\n    &lt;/bean&gt;\n    \n    &lt;bean id=&quot;myBeanProcesser&quot; class=&quot;com.msb.beanProcesser.MyBeanProcesser&quot;&gt;&lt;/bean&gt;\n&lt;/beans&gt;\n</code></pre>\n<p><strong>BeanPostProcessor接口作用：</strong></p>\n<blockquote>\n<p>如果我们想在Spring容器中完成bean实例化、配置以及其他初始化方法前后要添加一些自己逻辑处理。我们需要定义一个或多个BeanPostProcessor接口实现类，然后注册到Spring IoC容器中。</p>\n</blockquote>\n<p>1、接口中的两个方法都要将传入的bean返回，而不能返回null，如果返回的是null那么我们通过getBean方法将得不到目标。<br>2、ApplicationContext会自动检测在配置文件中实现了BeanPostProcessor接口的所有bean，并把它们注册为后置处理器，然后在容器创建bean的适当时候调用它，因此部署一个后置处理器同部署其他的bean并没有什么区别。而使用BeanFactory实现的时候，bean 后置处理器必须通过代码显式地去注册，在IoC容器继承体系中的ConfigurableBeanFactory接口中定义了注册方法</p>\n<p><strong>总结</strong></p>\n<p>完整的过程：</p>\n<blockquote>\n<p>创建实例 –&gt; set赋值 –&gt; 再次初始化对象–&gt; 获取Bean对象–&gt; 销毁Bean对象</p>\n<p>创建实例 –&gt; set赋值 –&gt;把bean实例传递给bean的后置处理器的方法 –&gt; 再次初始化对象 –&gt; 把bean实例传递给bean的后置处理器的方法 —&gt; 获取Bean对象–&gt; 销毁Bean对象</p>\n</blockquote>\n<h1 id=\"Bean自动装配\"><a href=\"#Bean自动装配\" class=\"headerlink\" title=\"Bean自动装配\"></a>Bean自动装配</h1><p>通过property标签可以手动指定给属性进行注入<br>我们也可以通过自动转配,完成&#x3D;&#x3D;属性的自动注入&#x3D;&#x3D;,就是自动装配,可以简化DI的配置</p>\n<pre><code class=\"xml\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;\n       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n       xmlns:p=&quot;http://www.springframework.org/schema/p&quot;\n       xmlns:c=&quot;http://www.springframework.org/schema/c&quot;\n       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans\n       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;\n    &lt;bean id=&quot;dept&quot; class=&quot;com.msb.bean.Dept&quot;&gt;&lt;/bean&gt;\n    &lt;!--\n    autowire 属性控制自动将容器中的对象注入到当前对象的属性上\n    byName 根据目标id值和属性值注入,要保证当前对象的属性值和目标对象的id值一致\n    byType 根据类型注入,要保证相同类型的目标对象在容器中只有一个实例\n    --&gt;\n    &lt;bean id=&quot;emp&quot; class=&quot;com.msb.bean.Emp&quot; autowire=&quot;byName&quot;&gt;&lt;/bean&gt;\n&lt;/beans&gt;\n</code></pre>\n<h1 id=\"Spring注解管理Bean\"><a href=\"#Spring注解管理Bean\" class=\"headerlink\" title=\"Spring注解管理Bean\"></a>Spring注解管理Bean</h1><h2 id=\"1注解方式创建对象IOC\"><a href=\"#1注解方式创建对象IOC\" class=\"headerlink\" title=\"1注解方式创建对象IOC\"></a>1注解方式创建对象IOC</h2><p>导入依赖 aop</p>\n<p>@Component    放在类上,用于标记,告诉spring当前类需要由容器实例化bean并放入容器中<br>  该注解有三个子注解<br>  @Controller   用于实例化controller层bean<br>        @Service        用于实例化service层bean<br>        @Repository  用于实例化持久层bean<br>  当不确定是哪一层,就用Component<br>这几个注解互相混用其实也可以,但是不推荐</p>\n<h2 id=\"2注解方式依赖注入DI\"><a href=\"#2注解方式依赖注入DI\" class=\"headerlink\" title=\"2注解方式依赖注入DI\"></a>2注解方式依赖注入DI</h2><p>@Autowired   根据属性数据类型自动装配<br>@Qualifier      根据属性名称注入依赖<br>@Resources   可以根据类型,也可以根据名称注入<br>@Value           注入普通数据类型(8+String)</p>\n<pre><code class=\"java\">// 详解 \n/*\n    * @Autowired\n    * 根据类型到容器中去寻找对应的对象,找到后给当前属性赋值\n    * 不需要依赖 set方法\n    * 属性类型可以是接口,会自动匹配对应的实现类对象\n    * @Autowired配合 @Qualifier,可以通过名称指定注入的对象\n    *\n    * @Resource 如果不配置name 那么就是根据类型注入\n    * @Resource(name=&quot;userDaoImplB&quot;) 配置name,就是根据名称注入\n    *\n    *\n    * @Resource  是JDK中javax包的注解\n    * @Autowired 和 @Qualifier 是spring中的注解\n    *\n    * @Value 可以个普通属性赋值\n    * @Value 可以使用$&#123;&#125;这种表达式获取系统的变量值\n    *        或者是.properties属性配置文件中的值\n    *\n    * */\n</code></pre>\n<h1 id=\"代理\"><a href=\"#代理\" class=\"headerlink\" title=\"代理\"></a>代理</h1><p><em>概念</em>：在使用对象的时候，不直接使用用一个代理对象代理他，这样可以在目标<strong>对象基础上增强额外的功能</strong>。</p>\n<p><em>分类</em>：静态代理，动态代理</p>\n<h2 id=\"静态代理\"><a href=\"#静态代理\" class=\"headerlink\" title=\"静态代理\"></a>静态代理</h2><blockquote>\n<p>​\t静态代理中<strong>代理类</strong>与<strong>被代理类</strong>都<strong>需要实现同一个接口</strong>，这就说明我们的<strong>一个静态代理类只能代理一个类</strong>，并且还要事先知道我们<strong>要代理哪个类才能写代理类</strong>，如果我们<strong>有其他类还想使用代理那就必须再写一个代理类</strong>。</p>\n</blockquote>\n<p>​\t然而在实际开发中我们是可能是有非常多的类是需要被代理的，并且事先我们可能并不知道我们要代理哪个类。所以如果继续使用静态代理反而会增加许多的工作量，并且<strong>效率低下</strong>，<strong>代码复用率也不好</strong>。</p>\n<pre><code class=\"java\">public class Test1 &#123;\n    public static void main(String[] args) &#123;\n        /**\n        lawyer律师代替Person张三打官司，不用张三直接打，可以更加清楚\n        */\n        Person person =new Person(&quot;张三&quot;);\n        Court court=new Lawyer(person);\n        court.doCourt();\n    &#125;\n&#125;\n// 接口\ninterface Court&#123;\n    void doCourt();\n&#125;\n// 代理类\nclass Lawyer implements Court&#123;\n    private Person person;\n    public Lawyer(Person person) &#123;\n        this.person = person;\n    &#125;\n    @Override\n    public void doCourt() &#123;\n        System.out.println(&quot;律师取证:视频证明张三当时正在旅游,不在案发现场&quot;);\n        System.out.println(&quot;律师总结:张三不可能去杀人&quot;);\n        person.doCourt();\n    &#125;\n&#125;\n// 被代理的类\nclass Person implements Court&#123;\n    private String name;\n    public Person(String name) &#123;\n        this.name = name;\n    &#125;\n    @Override\n    public void doCourt() &#123;\n        System.out.println(name+&quot;说:我没有杀人&quot;);\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"动态代理\"><a href=\"#动态代理\" class=\"headerlink\" title=\"动态代理\"></a>动态代理</h2><p><em>概念</em>：动态代理可以<strong>针对</strong>于一些<strong>不特定的类</strong>或者一些<strong>不特定的方法</strong>进行代理,我们可以在程序运行时动态的变化代理的规则，<strong>代理类在程序运行时才创建的代理模式成为动态代理</strong>。这种情况下，代理类并不是在Java代码中定义好的，而是在程序运行时根据我们的在Java代码中的“指示”动态生成的</p>\n<p>实现方法：JDK自带的Proxy、CJlib</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\"><strong>Proxy</strong></th>\n<th align=\"center\"><strong>JDK动态代理</strong></th>\n<th align=\"center\"><strong>面向接口</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"><em><strong>cglib</strong></em></td>\n<td align=\"center\"><em><strong>第三方动态代理</strong></em></td>\n<td align=\"center\"><em><strong>面向父类</strong></em></td>\n</tr>\n</tbody></table>\n<p>实现案例：</p>\n<p>Proxy:</p>\n<pre><code class=\"java\">public class ProxyTest1 &#123;\n\n    public static void main(String[] args) &#123;\n        Dinner dinner = new Person(&quot;张三&quot;);\n        ClassLoader loader = dinner.getClass().getClassLoader();\n        Class&lt;?&gt;[] interfaces = dinner.getClass().getInterfaces();\n        /*\n           Object proxy, 代理对象\n           Method method,被代理的方法\n           Object[] args,被代理方法运行时的实参\n         */\n        /*InvocationHandler invocationHandler = (proxy,\n                                              method,\n                                              params)-&gt;&#123;\n            System.out.println(&quot;invoked 方法执行&quot;);\n\n            return null;\n        &#125;;*/\n        InvocationHandler invocationHandler = new InvocationHandler() &#123;\n            @Override\n            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;\n                Object res = new Object();\n\n                if (method.getName().equals(&quot;eat&quot;)) &#123;\n                    System.out.println(&quot;饭前洗手&quot;);\n                    // 让原有的eat的方法去运行\n                    res =method.invoke(dinner, args);\n                    System.out.println(&quot;饭后刷碗&quot;);\n                &#125;\n                else&#123;\n                    // 如果是其他方法,那么正常执行就可以了\n                    res =method.invoke(dinner, args);\n                &#125;\n                return res;\n            &#125;\n        &#125;;\n\n        /**\n         * 动态代理\n         * 需要三次个参数 loader代理类，增强的对象，\n         *              interfaces 实现的接口，\n         *              增强方法 invoke()\n         */\n        Dinner dinner1 = (Dinner) Proxy.newProxyInstance(loader,interfaces,invocationHandler);\n        dinner1.eat(&quot;包子&quot;);\n    &#125;\n&#125;\ninterface Dinner&#123;\n    void eat(String foodName);\n    void drink();\n&#125;\n\nclass Person implements Dinner&#123;\n    private String name;\n    public Person(String name) &#123;\n        this.name = name;\n    &#125;\n    @Override\n    public void eat(String foodName) &#123;\n        System.out.println(name+&quot;正在吃&quot;+foodName);\n    &#125;\n    @Override\n    public void drink( ) &#123;\n        System.out.println(name+&quot;正在喝茶&quot;);\n    &#125;\n&#125;\nclass Student implements Dinner&#123;\n    private String name;\n    public Student(String name) &#123;\n        this.name = name;\n    &#125;\n    @Override\n    public void eat(String foodName) &#123;\n        System.out.println(name+&quot;正在食堂吃&quot;+foodName);\n    &#125;\n    @Override\n    public void drink( ) &#123;\n        System.out.println(name+&quot;正在喝可乐&quot;);\n    &#125;\n&#125;\n</code></pre>\n<p>Cglib</p>\n<pre><code class=\"java\">public class ProxyTest2 &#123;\n\n    public static void main(String[] args) &#123;\n        // 获取一个Person的代理对象\n        Person person = new Person();\n        // 1 获得一个Enhancer对象\n        Enhancer enhancer = new Enhancer();\n        // 2 设置父类字节码\n        enhancer.setSuperclass(Person.class);\n        // 3 获取MethodIntercepter对象 用于定义增强规则\n        MethodInterceptor methodInterceptor = new MethodInterceptor() &#123;\n            /*\n            * Object o 生成之后的代理对象 personProxy\n            * Method method 父类中原本要执行的方法  Person&gt;&gt;&gt; eat()要增强的方法（还没有被增强，父类方法）\n            * Object[] objects 实际传入的参数\n            * MethodProxy methodProxy 子类中重写父类的方法 personProxy &gt;&gt;&gt; eat()代理对象增强的方法（增强的方法，子类对象）\n            * */\n            @Override\n            public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable &#123;\n                Object res = null;\n\n                if (method.getName().equals(&quot;eat&quot;)) &#123;\n                    System.out.println(&quot;饭前洗手&quot;);\n                    res=methodProxy.invokeSuper(o,objects);\n                    System.out.println(&quot;饭后刷碗&quot;);\n                &#125;else&#123;\n                    // 如果是其他方法 不增强运行\n                    res=methodProxy.invokeSuper(o,objects); // 子类对象方法在执行,默认会调用父类对应被重写的方法\n                &#125;\n                return res;\n            &#125;\n        &#125;;\n        // 4 设置methodInterceptor\n        enhancer.setCallback(methodInterceptor);\n        // 5 获得代理对象\n        Person personProxy = (Person)enhancer.create();\n        // 6 使用代理对象完成功能\n        personProxy.eat(&quot;包子&quot;);\n    &#125;\n&#125;\n\nclass Person  &#123;\n    public Person( ) &#123;\n    &#125;\n    public void eat(String foodName) &#123;\n        System.out.println(&quot;张三正在吃&quot;+foodName);\n    &#125;\n&#125;\n</code></pre>\n<blockquote>\n<p>总结</p>\n</blockquote>\n<ul>\n<li>在<strong>不修改原有代码</strong>的 或者没有办法修改原有代码的情况下  <strong>增强对象功能</strong>  <strong>使用代理对象</strong> 代替原来的对象去完成功能进而达到拓展功能的目的</li>\n<li><strong>JDK Proxy 动态代理面向接口的动态代理</strong>  一定<strong>要有接口</strong>和<strong>实现类</strong>的存在 代理对象<strong>增强的是实现类</strong> 在实现接口的方法重写的方法   生成的代理对象只能转换成 接口的不能转换成 被代理类代理对象只能增强接口中定义的方法  <strong>实现类中其他和接口无关的方法是无法增强的代理对象只能读取到接口中方法上的注解 不能读取到实现类方法上的注解</strong></li>\n</ul>\n<h1 id=\"AOP\"><a href=\"#AOP\" class=\"headerlink\" title=\"AOP\"></a>AOP</h1><p>全名：Aspect Oriented Programmings，面向切面编程，通过<strong>预编译</strong>和<strong>运行时生成动态代理</strong>实现程序功能的统一维护的一种技术。AOP是OOP的延续，是Spring框架的一个重要内容，是函数式编程的一种衍生范式。利用AOP可以对业务逻辑的各个部分进行隔离，从而使各个部分的耦合性降低，提高程序的可重用行，提高开发效率。</p>\n<hr>\n<p>AOP切面编程一般可以帮助我们在不修改现有代码的情况下,对程序的功能进行拓展,往往用于实现 日志处理,权限控制,性能检测,事务控制等<br>AOP实现的原理就是动态代理,在有接口的情况下,使用JDK动态代理,在没有接口的情况下使用cglib动态代理</p>\n<img data-src=\"/2022/10/07/Spring_Family/Spring/image-20220716162550876.png\" class=\"\">\n\n\n\n\n<p>AOP中的术语辨析</p>\n<p>1 连接点 Joint point：类里面那些可以被增强的方法</p>\n<p>2 切入点 Pointcu：实际被增强的方法,称之为切入点</p>\n<p>3 通知 Advice:：实际增强的逻辑部分称为通知 (增加的功能)</p>\n<p>4 目标对象 Target：被增强功能的对象(被代理的对象)</p>\n<p>5 切面Aspect： 表现为功能相关的一些advice方法放在一起声明成的一个Java类</p>\n<p>6 织入 Weaving：创建代理对象并实现功能增强的声明并运行过程</p>\n<p>具体操作</p>\n<pre><code class=\"java\">/*\n事先准备 dao 以及他的实现类\n我们直接编写 Aspect 层的代码\n*/\n\n@Component\n@Aspect\npublic class DaoAspect &#123;\n    /*\n    切入点表达式: 通过一个表达式来确定AOP要增强的是哪个或者那些方法\n    语法结构:execution([权限修饰符][返回值类型][类的全路径名][方法名](参数 列表) )\n    execution(* com.msb.dao.UserDaoImpl.add(..))   //指定切点为UserDaoImpl.add方法\n    execution(* com.msb.dao.UserDaoImpl.*(..))     //指定切点为UserDaoImpl.所有的方法\n    execution(* com.msb.dao.*.*(..))               //指定切点为dao包下所有的类中的所有的方法\n    execution(* com.msb.dao.*.add(..))             // 指定切点为dao包下所有的类中的add的方法\n    execution(* com.msb.dao.*.add*(..))            // 指定切点为dao包下所有的类中的add开头的方法\n    *  */\n    //定义公共切点\n    @Pointcut(&quot;execution( * com.zjj.aop.dao.*.add*(..) )&quot;)\n    public void addPointCut()&#123;\n\n    &#125;\n\n    /*\n     * 前置通知: 切点方法执行之前先执行的功能\n     * 参数列表可以用JoinPoint接收切点对象\n     * 可以获取方法执行的参数\n     * */\n    @Before(&quot;addPointCut()&quot;) // 这里用了公共切点，不然又要写一次公共切点上的 @PointCut()\n    public void methodBefore(JoinPoint joinPoint) &#123;\n        System.out.println(&quot;Before invoked&quot;);\n    &#125;\n\n\n    /*\n     * 后置通知:方法执行之后要增强的功能\n     * 无论切点方法是否出现异常都会执行的方法\n     * 参数列表可以用JoinPoint接收切点对象\n     * */\n    @After(&quot;addPointCut()&quot;)\n    public void methodAfter(JoinPoint joinPoint)&#123;\n        System.out.println(&quot;After invoked&quot;);\n    &#125;\n\n    /*\n     * 返回通知:切点方法正常运行结束后增强的功能\n     * 如果方法运行过程中出现异常,则该功能不运行\n     * 参数列表可以用 JoinPoint joinPoint接收切点对象\n     * 可以用Object res接收方法返回值,需要用returning指定返回值名称\n     * */\n    @AfterReturning( value = &quot;addPointCut()&quot;,returning = &quot;res&quot;)\n    public void methodAfterReturning(JoinPoint joinPoint,Object res)&#123;\n        System.out.println(&quot;AfterReturning invoked&quot;);\n    &#125;\n    /*\n     * 异常通知:切点方法出现异常时运行的增强功能\n     * 如果方法运行没有出现异常,则该功能不运行\n     * 参数列表可以用Exception ex接收异常对象 需要通过throwing指定异常名称\n     * */\n    @AfterThrowing( value = &quot;addPointCut()&quot;,throwing = &quot;ex&quot;)\n    public void methodAfterThrowing(Exception ex)&#123;\n        System.out.println(&quot;AfterThrowing invoked&quot;);\n    &#125;\n\n    /*环绕通知:在切点方法之前和之后都进行功能的增强\n     * 需要在通知中定义方法执行的位置,并在执行位置之前和之后自定义增强的功能\n     * 方法列表可以通过ProceedingJoinPoint获取执行的切点\n     * 通过proceedingJoinPoint.proceed()方法控制切点方法的执行位置\n     * proceedingJoinPoint.proceed()方法会将切点方法的返回值获取到,并交给我们,可以做后续处理\n     * 我们在环绕通知的最后需要将切点方法的返回值继续向上返回,否则切点方法在执行时接收不到返回值\n     * */\n    @Around(&quot;addPointCut()&quot;)\n    public Object methodAround(ProceedingJoinPoint proceedingJoinPoint) throws Throwable &#123;\n        System.out.println(&quot;aroundA invoked&quot;);\n        Object proceed = proceedingJoinPoint.proceed();\n        System.out.println(&quot;aroundB invoked&quot;);\n        return proceed;\n    &#125;\n\n&#125;\n</code></pre>\n<p>测试</p>\n<pre><code class=\"java\">@SpringBootTest(classes = MyAOPSpringApplication.class)\npublic class SpringAOPTests &#123;\n    @Resource\n    ApplicationContext context;\n    @Test\n    public void t1() &#123;\n        UserService userService = context.getBean(UserService.class);\n        userService.addUser(10, &quot;小明&quot;);\n    &#125;\n&#125;\n</code></pre>\n<p>结果：</p>\n<blockquote>\n<p>aroundA invoked</p>\n<p>Before invoked</p>\n<p>userDao add … …</p>\n<p>AfterReturning invoked</p>\n<p>After invoked</p>\n<p>aroundB invoked</p>\n</blockquote>\n<p>面试题</p>\n<p>如果在不使用框架的前提下你要做权限的校验你会怎么做?</p>\n<blockquote>\n<p>我会在要鉴权的方法加入环绕通知，在请求到方法前先进行一次查找，一般这些数据我们会在redis中也会存储一个，第一次查过来我们去redis中找，找到直接让他操作并且在之后提交事务，但是没找到的时候我们先让他去操作，但是不提交事务，同时去数据库中查找他的信息，找到后添加redis，提交事务，没找到就回滚事务即可。</p>\n</blockquote>\n<h1 id=\"事务\"><a href=\"#事务\" class=\"headerlink\" title=\"事务\"></a>事务</h1><h2 id=\"事务的概念\"><a href=\"#事务的概念\" class=\"headerlink\" title=\"事务的概念\"></a>事务的概念</h2><p>事务（Transaction）指的是一个操作序列，该操作序列中的多个操作要么都做，要么都不做，是一个不可分割的工作单位，是数据库环境中的逻辑工作单位，由DBMS中的事务管理子系统负责事务的处理。</p>\n<p>目前常用的存储引擎有InnoDB（MySQL5.5以后默认的存储引擎）和MyISAM（MySQL5.5之前默认的存储引擎），其中InnoDB支持事务处理机制，而MyISAM不支持。</p>\n<h2 id=\"事务的特性\"><a href=\"#事务的特性\" class=\"headerlink\" title=\"事务的特性\"></a>事务的特性</h2><p>事务处理可以确保除非事务性序列内的所有操作都成功完成，否则不会永久更新面向数据的资源。通过将一组相关操作组合为一个要么全部成功要么全部失败的序列，可以简化错误恢复并使应用程序更加可靠。</p>\n<p>但并不是所有的操作序列都可以称为事务，这是因为一个操作序列要成为事务，必须满足事务的原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）和持久性（Durability）。这四个特性简称为ACID特性。</p>\n<img data-src=\"/2022/10/07/Spring_Family/Spring/image-20220716210341261.png\" class=\"\">\n\n\n<ol>\n<li><pre><code>原子性\n</code></pre>\n</li>\n</ol>\n<p>原子是自然界最小的颗粒，具有不可再分的特性。事务中的所有操作可以看做一个原子，事务是应用中不可再分的最小的逻辑执行体。</p>\n<p>使用事务对数据进行修改的操作序列，要么全部执行，要么全不执行。通常，某个事务中的操作都具有共同的目标，并且是相互依赖的。如果数据库系统只执行这些操作中的一部分，则可能会破坏事务的总体目标，而原子性消除了系统只处理部分操作的可能性。</p>\n<ol start=\"2\">\n<li><pre><code> 一致性\n</code></pre>\n</li>\n</ol>\n<p>一致性是指事务执行的结果必须使数据库从一个一致性状态，变到另一个一致性状态。当数据库中只包含事务成功提交的结果时，数据库处于一致性状态。一致性是通过原子性来保证的。</p>\n<p>例如：在转账时，只有保证转出和转入的金额一致才能构成事务。也就是说事务发生前和发生后，数据的总额依然匹配。</p>\n<ol start=\"3\">\n<li><pre><code> 隔离性\n</code></pre>\n</li>\n</ol>\n<p>隔离性是指各个事务的执行互不干扰，任意一个事务的内部操作对其他并发的事务，都是隔离的。也就是说：并发执行的事务之间既不能看到对方的中间状态，也不能相互影响。</p>\n<p>例如：在转账时，只有当A账户中的转出和B账户中转入操作都执行成功后才能看到A账户中的金额减少以及B账户中的金额增多。并且其他的事务对于转账操作的事务是不能产生任何影响的。</p>\n<ol start=\"4\">\n<li><pre><code>持久性\n</code></pre>\n</li>\n</ol>\n<p>持久性指事务一旦提交，对数据所做的任何改变，都要记录到永久存储器中，通常是保存进物理数据库，即使数据库出现故障，提交的数据也应该能够恢复。但如果是由于外部原因导致的数据库故障，如硬盘被损坏，那么之前提交的数据则有可能会丢失。</p>\n<h2 id=\"事务的并发问题\"><a href=\"#事务的并发问题\" class=\"headerlink\" title=\"事务的并发问题\"></a>事务的并发问题</h2><p>脏读（Dirty read）</p>\n<p>当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。</p>\n<img data-src=\"/2022/10/07/Spring_Family/Spring/image-20220716210633569.png\" class=\"\">\n\n\n<p>不可重复读</p>\n<p>（Unrepeatableread）: 指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。</p>\n<img data-src=\"/2022/10/07/Spring_Family/Spring/image-20220716210640447.png\" class=\"\">\n\n\n<p>幻读</p>\n<p>（Phantom read）: 幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。</p>\n<img data-src=\"/2022/10/07/Spring_Family/Spring/image-20220716210646452.png\" class=\"\">\n\n\n<p><strong>不可重复度和幻读区别：</strong></p>\n<p>不可重复读的重点是修改，幻读的重点在于新增或者删除。</p>\n<p><strong>解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表</strong></p>\n<p>例1（同样的条件, 你读取过的数据, 再次读取出来发现值不一样了 ）：事务1中的A先生读取自己的工资为 1000的操作还没完成，事务2中的B先生就修改了A的工资为2000，导 致A再读自己的工资时工资变为 2000；这就是不可重复读。</p>\n<p>例2（同样的条件, 第1次和第2次读出来的记录数不一样 ）：假某工资单表中工资大于3000的有4人，事务1读取了所有工资大于3000的人，共查到4条记录，这时事务2又插入了一条工资大于3000的记录，事务1再次读取时查到的记录就变为了5条，这样就导致了幻读</p>\n<h2 id=\"事务的隔离级别\"><a href=\"#事务的隔离级别\" class=\"headerlink\" title=\"事务的隔离级别\"></a>事务的隔离级别</h2><p>事务的隔离级别用于决定如何控制并发用户读写数据的操作。数据库是允许多用户并发访问的，如果多个用户同时开启事务并对同一数据进行读写操作的话，有可能会出现脏读、不可重复读和幻读问题，所以MySQL中提供了四种隔离级别来解决上述问题。</p>\n<p>事务的隔离级别从低到高依次为READ UNCOMMITTED、READ COMMITTED、REPEATABLE READ以及SERIALIZABLE，隔离级别越低，越能支持高并发的数据库操作。</p>\n<p>​                                   </p>\n<h2 id=\"spring中可以使用如下方式实现事务的控制\"><a href=\"#spring中可以使用如下方式实现事务的控制\" class=\"headerlink\" title=\"spring中可以使用如下方式实现事务的控制\"></a>spring中可以使用如下方式实现事务的控制</h2><p>1 编程式(不推荐)</p>\n<p>2 声明式(掌握)</p>\n<p>​\t1) 注解(简单,必会)</p>\n<p>​\t2) XML配置(繁琐,了解)</p>\n<p>  <strong>Spring声明式事务的实现方式,底层就是AOP,AOP的底层就是动态代理</strong></p>\n<p>Spring事务管理相关的API</p>\n<p>事务管理器接口: PlatformTransactionManager  针对不同的框架,提供了不同的实现类</p>\n<img data-src=\"/2022/10/07/Spring_Family/Spring/image-20220716210813110.png\" class=\"\">\n\n\n<p>注解方式实现事务控制<br>在applicationContext.xml配置事务相关的配置</p>\n<pre><code class=\"xml\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;\n       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n       xmlns:p=&quot;http://www.springframework.org/schema/p&quot;\n       xmlns:c=&quot;http://www.springframework.org/schema/c&quot;\n       xmlns:util=&quot;http://www.springframework.org/schema/util&quot;\n       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;\n       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;\n       xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;\n       xsi:schemaLocation=&quot;\n       http://www.springframework.org/schema/beans\n       http://www.springframework.org/schema/beans/spring-beans.xsd\n       http://www.springframework.org/schema/util\n       http://www.springframework.org/schema/util/spring-util.xsd\n       http://www.springframework.org/schema/context\n       http://www.springframework.org/schema/context/spring-context.xsd\n       http://www.springframework.org/schema/aop\n       http://www.springframework.org/schema/aop/spring-aop.xsd\n       http://www.springframework.org/schema/tx\n       http://www.springframework.org/schema/tx/spring-tx.xsd\n&quot;&gt;\n    &lt;!--spring 注解扫描--&gt;\n    &lt;context:component-scan base-package=&quot;com.msb&quot;/&gt;\n    &lt;!--读取jdbc配置文件--&gt;\n    &lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot;/&gt;\n    &lt;!--配置德鲁伊连接池--&gt;\n    &lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt;\n        &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc_username&#125;&quot;&gt;&lt;/property&gt;\n        &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc_password&#125;&quot;&gt;&lt;/property&gt;\n        &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc_url&#125;&quot;&gt;&lt;/property&gt;\n        &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;jdbc_driver&#125;&quot;&gt;&lt;/property&gt;\n    &lt;/bean&gt;\n    &lt;!--配置JDBCTemplate对象,并向里面注入DataSource--&gt;\n    &lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt;\n        &lt;!--通过set方法注入连接池--&gt;\n        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;\n    &lt;/bean&gt;\n    &lt;!--配置一个事务管理器--&gt;\n    &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;\n        &lt;!--将数据源注入事务管理器--&gt;\n        &lt;property name=&quot;dataSource&quot;  ref=&quot;dataSource&quot;&gt;&lt;/property&gt;\n    &lt;/bean&gt;\n    &lt;!--开启事务注解--&gt;\n    &lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot;/&gt;\n&lt;/beans&gt;\n</code></pre>\n<pre><code class=\"java\">@Service\n//@Transactional //加在类上,代表类中的所有方法都添加了事务控制\npublic class AccountServiceImpl implements AccountService &#123;\n    @Autowired\n    private AccountDao accountDao;\n    @Override\n    @Transactional// 放在方法上,就是仅仅对当前方法增加了事务控制\n    public int transMoney(int from, int to, int money) &#123;\n        int rows=0;\n        rows+=accountDao.transMoney(from, 0 - money);\n        int i =1/0;\n        rows+=accountDao.transMoney(to, money);\n        return rows;\n    &#125;\n&#125;\n</code></pre>\n<p>再次测试,就算是service方法运行出现异常,自动会回滚,如果没有,那么自动提交</p>\n<p>@Transactional 注解的一些参数和参数的含义<br>@Transactional(propagation &#x3D; Propagation.REQUIRED,isolation &#x3D; Isolation.READ_UNCOMMITTED,readOnly &#x3D; true,rollbackFor &#x3D; ClassCastException.class,noRollbackFor &#x3D; NullPointerException.class,timeout &#x3D; 10)</p>\n<pre><code class=\"java\">@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)\n@Retention(RetentionPolicy.RUNTIME)\n@Inherited\n@Documented\npublic @interface Transactional &#123;\n    @AliasFor(&quot;transactionManager&quot;)\n    String value() default &quot;&quot;;\n    @AliasFor(&quot;value&quot;)\n    String transactionManager() default &quot;&quot;;\n    String[] label() default &#123;&#125;;\n    Propagation propagation() default Propagation.REQUIRED;\n    Isolation isolation() default Isolation.DEFAULT;\n    int timeout() default -1;\n    String timeoutString() default &quot;&quot;;\n    boolean readOnly() default false;\n    Class&lt;? extends Throwable&gt;[] rollbackFor() default &#123;&#125;;\n    String[] rollbackForClassName() default &#123;&#125;;\n    Class&lt;? extends Throwable&gt;[] noRollbackFor() default &#123;&#125;;\n    String[] noRollbackForClassName() default &#123;&#125;;\n&#125;\n</code></pre>\n<h2 id=\"propagation-事务的传播行为-面试\"><a href=\"#propagation-事务的传播行为-面试\" class=\"headerlink\" title=\"propagation  事务的传播行为(面试)\"></a>propagation  事务的传播行为(面试)</h2><p>多事务方法之间调用,事务是如何管理的</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">事务传播行为类型</th>\n<th align=\"center\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">PROPAGATION_REQUIRED</td>\n<td align=\"center\">如果当前没有事务，就新建一个事务，如果已经存在一个事务中，加入到这个事务中。这是最常见的选择(默认)。</td>\n</tr>\n<tr>\n<td align=\"center\">PROPAGATION_SUPPORTS</td>\n<td align=\"center\">支持当前事务，如果当前没有事务，就以非事务方式执行。</td>\n</tr>\n<tr>\n<td align=\"center\">PROPAGATION_MANDATORY</td>\n<td align=\"center\">使用当前的事务，如果当前没有事务，就抛出异常。</td>\n</tr>\n<tr>\n<td align=\"center\">PROPAGATION_REQUIRES_NEW</td>\n<td align=\"center\">新建事务，如果当前存在事务，把当前事务挂起。</td>\n</tr>\n<tr>\n<td align=\"center\">PROPAGATION_NOT_SUPPORTED</td>\n<td align=\"center\">以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。</td>\n</tr>\n<tr>\n<td align=\"center\">PROPAGATION_NEVER</td>\n<td align=\"center\">以非事务方式执行，如果当前存在事务，则抛出异常。</td>\n</tr>\n<tr>\n<td align=\"center\">PROPAGATION_NESTED</td>\n<td align=\"center\">如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与PROPAGATION_REQUIRED类似的操作。</td>\n</tr>\n</tbody></table>\n<p>如果service层  add方法调用了 addDept和addEmp两个方法</p>\n<p>&#x3D;&#x3D;<em><strong>PROPAGATION_REQUIRED</strong></em>&#x3D;&#x3D;<br>如果add方法有事务,那么addDept和addEmp就加入到add方法里的事务<br>如果add方法没有事务,那么就新建一个事务,将addDept和addEmp加入到这个新的事务中</p>\n<p>&#x3D;&#x3D;<em><strong>PROPAGATION_REQUIRES_NEW</strong></em>&#x3D;&#x3D;<br>无论add是否有事务,都建立一个新的事务,所有的方法都加入到新的事务中,add原来的事务就不用了</p>\n<p><strong>isolation 事务的隔离级别</strong></p>\n<ol>\n<li><p>DEFAULT （默认）<br>这是一个PlatfromTransactionManager默认的隔离级别，使用数据库默认的事务隔离级别。另外四个与JDBC的隔离级别相对应。<br>MySQL默认REPEATABLE_READ<br>Oracle默认READ_COMMITTED</p>\n</li>\n<li><p>READ_UNCOMMITTED （读未提交）<br>这是事务最低的隔离级别，它允许另外一个事务可以看到这个事务未提交的数据。这种隔离级别会产生脏读，不可重复读和幻像读。 </p>\n</li>\n<li><p>READ_COMMITTED （读已提交）<br>保证一个事务修改的数据提交后才能被另外一个事务读取，另外一个事务不能读取该事务未提交的数据。这种事务隔离级别可以避免脏读出现，但是可能会出现不可重复读和幻像读。 </p>\n</li>\n<li><p>REPEATABLE_READ （可重复读）<br>这种事务隔离级别可以防止脏读、不可重复读，但是可能出现幻像读。它除了保证一个事务不能读取另一个事务未提交的数据外，还保证了不可重复读。</p>\n</li>\n<li><p>SERIALIZABLE（串行化）<br>这是花费最高代价但是最可靠的事务隔离级别，事务被处理为顺序执行。除了防止脏读、不可重复读外，还避免了幻像读。</p>\n</li>\n</ol>\n<p><em>timeout 超时时间</em><br>事务一定要在多长时间之内提交,如果不提交就会回滚</p>\n<p><em>readOnly 只读事务</em><br>事务是否只能读取数据库的数据,如果为true,则不允许进行增删改</p>\n<p><em>rollbackFor 指定发生回滚的异常</em><br>当方法发生哪些异常时才会回滚</p>\n<p><em>noRollbackFor 指定不发生回滚的异常</em><br>当方法发生哪些异常时,不会回滚</p>\n<h1 id=\"面试题\"><a href=\"#面试题\" class=\"headerlink\" title=\"面试题\"></a>面试题</h1><h2 id=\"spring的循环依赖是什么？怎么解决\"><a href=\"#spring的循环依赖是什么？怎么解决\" class=\"headerlink\" title=\"spring的循环依赖是什么？怎么解决?\"></a>spring的循环依赖是什么？怎么解决?</h2><p>循环依赖：</p>\n<p>​\t指循环引用，是两个或多个Bean之间相互持有对方的引用</p>\n<p>三种依赖方式：</p>\n<p>​\t1、A依赖B ,B依赖A \t   \t\t\t\t\t——&gt; 直接依赖</p>\n<p>​\t2、A依赖C，C依赖B，B依赖A\t   ——&gt; 间接依赖</p>\n<p>​\t3、A依赖A \t\t\t\t\t\t\t\t\t\t\t——&gt; 自我依赖</p>\n<p>为什么会产生这个问题呢？</p>\n<p>​\t因为我们的 Spring 其中一大特点就是Spring IOC 、DI，Spring会自动帮我们创建对象和对对象赋值，而一旦产生循环依赖问题就会导致我们初始化的时候陷入阻塞状态，最终导致Spring容器都无法启动</p>\n<p>解决办法</p>\n<blockquote>\n<p>​\t使用缓存，缓存就是将所有缓存好的Bean，全部放在一个容器中缓存起来，并且呢，将已经完全实例化，但是没有完成赋值的Bean标记起来。然后呢，再Bean第一次实例化完成后，在扫描一次容器将没有完成赋值的Bean的属性完成赋值就可以了。(@Autowriter的对象)</p>\n<p>目前循环依赖只在属性&#x3D;&#x3D;set注入&#x3D;&#x3D;且&#x3D;&#x3D;单例&#x3D;&#x3D;的情况下才能解决</p>\n</blockquote>\n<h2 id=\"解决循环依赖问题一定要使用二级缓存吗？\"><a href=\"#解决循环依赖问题一定要使用二级缓存吗？\" class=\"headerlink\" title=\"解决循环依赖问题一定要使用二级缓存吗？\"></a>解决循环依赖问题一定要使用二级缓存吗？</h2><p>不一定，但是为什么又要设计二级缓存？假设我们只有一个缓存容器，并且缓存是直接开放给用户可以调用的，未完成赋值的Bean和已完成赋值的Bean全部放入一个容器的话，调用者就有可能会拿到未赋值的Bean，这对于用户来说是没有意义的，可能会造成空指针异常。所以基于这样的考虑，Spring将能够直接提供给用户使用的Bean放在了一级缓存中，这样的Bean称之为终态Bean；将已经完成初始化，但还不能提供给用户使用的Bean放在了二级缓存，称之为临时Bean。</p>\n<h2 id=\"为什么在二级缓存的基础上还要创建三级缓存\"><a href=\"#为什么在二级缓存的基础上还要创建三级缓存\" class=\"headerlink\" title=\"为什么在二级缓存的基础上还要创建三级缓存\"></a>为什么在二级缓存的基础上还要创建三级缓存</h2><p>Spring中的有很多的注入的Bean需要去创建代理的Bean，但是不是所有的Bean都需要去实例化之后就立马要创建代理Bean，是要等到Bean初始化之后，完成之后才能够去创建代理Bean，因此的循环依赖呢Spring又不得不去提前的创建代理Bean，如果不创建代理Bean，注入原始的Bean就会产生错误。所以Spring设计三级缓存专门存储这些代理Bean，但是每个代理Bean的Bean的创建规则他又不一样，因此呢，Spring的三级缓存中并不是直接去保存代理Bean的引用，而是保存了创建代理Bean的Factory</p>\n<h2 id=\"什么是-Spring-三级缓存？\"><a href=\"#什么是-Spring-三级缓存？\" class=\"headerlink\" title=\"什么是 Spring 三级缓存？\"></a>什么是 Spring 三级缓存？</h2><p>singletonObjects   \t\t \t\t&lt;ConCurrentHashMap&lt;&gt; \t  ——&gt;   \t 一级缓存</p>\n<p>earlySingletonObjects\t \t&lt;HashMap&lt;&gt;\t\t\t\t  \t\t\t——&gt;   \t 二级缓存</p>\n<p>singletonFactories\t\t\t\t&lt;HashMap&lt;&gt;\t\t\t\t\t\t \t ——&gt;   \t 三级缓存</p>\n<p>一级缓存就是终态缓存；二级缓存就是临时缓存；三级缓存就是代理工厂的缓存</p>\n<img data-src=\"/2022/10/07/Spring_Family/Spring/image-20220821162504894.png\" class=\"\">\n\n\n\n\n<h2 id=\"什么情况下循环依赖无法解决？\"><a href=\"#什么情况下循环依赖无法解决？\" class=\"headerlink\" title=\"什么情况下循环依赖无法解决？\"></a>什么情况下循环依赖无法解决？</h2><p>1、多实例Bean 通过 set注入无法解决</p>\n<p>2、构造器注入注入的Bean无法解决</p>\n<p>3、单里的代理Bean通过 set注入无法解决</p>\n<p>4、设置@DependsOn注解的Bean注入无法解决</p>\n<h2 id=\"后序补充……\"><a href=\"#后序补充……\" class=\"headerlink\" title=\"后序补充…….\"></a>后序补充…….</h2>",
            "tags": [
                "框架",
                "Spring"
            ]
        },
        {
            "id": "http://example.com/2022/10/07/Spring_Family/SpringBoot/",
            "url": "http://example.com/2022/10/07/Spring_Family/SpringBoot/",
            "title": "SpringBoot",
            "date_published": "2022-10-06T16:00:00.000Z",
            "content_html": "<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><h2 id=\"原有Spring优缺点分析\"><a href=\"#原有Spring优缺点分析\" class=\"headerlink\" title=\"原有Spring优缺点分析\"></a>原有Spring优缺点分析</h2><p>优点：</p>\n<blockquote>\n<p>Spring是Java企业版（JAVAEE)开发的一种相对简单的方法，通过依赖注入和面向切面编程，用简单 的Java对象实现了EJB&#x3D;&#x3D;(Enterprise Java Beans技术的简称, 又被称为企业Java Beans)&#x3D;&#x3D;的功能</p>\n</blockquote>\n<p>缺点：</p>\n<ul>\n<li>虽然Spring的组件<strong>代码是轻量级</strong>的，但它的<strong>配置却是重量级</strong>的</li>\n<li><strong>依赖管理</strong>也是一件耗时耗力的事情，会产生版本不兼容的问题</li>\n</ul>\n<h2 id=\"SpringBoot概念简介\"><a href=\"#SpringBoot概念简介\" class=\"headerlink\" title=\"SpringBoot概念简介\"></a>SpringBoot概念简介</h2><blockquote>\n<p>Spring Boot是Spring公司的一个顶级项目，和Spring Framework是一个级别的。<br>Spring Boot实际上是利用Spring Framework 4 自动配置特性完成。编写项目时不需要编写xml文件。发展到现在，Spring Boot已经具有很很大的生态圈，各种主流技术已经都提供了Spring Boot的启动器。</p>\n</blockquote>\n<h2 id=\"什么是启动器\"><a href=\"#什么是启动器\" class=\"headerlink\" title=\"什么是启动器\"></a>什么是启动器</h2><blockquote>\n<p>Spring框架在项目中作用是Spring整合各种其他技术，让其他技术使用更加方便。Spring Boot的启动器<strong>实际上就是一个依赖</strong>。这个依赖中包含了整个这个技术的相关jar包，还包含了这个技术的自动配置，以前绝大多数XML配置都不需要配置了。当然了，启动器中自动配置无法实现所有内容的自动配置，在使用Spring Boot时还需要进行少量的配置（这个配置不是在xml中了，而是在properties或yml中即可）。如果是<strong>Spring自己封装的启动器</strong>的artifact id<strong>名字满足：spring-boot-starter-<em>xxxx</em></strong>，如果是<strong>第三方公司提供的启动</strong>满足：<strong><em>xxxx</em>-spring-boot-starter</strong>。以后每次使用Spring Boot整合其他技术时首先需要考虑导入启动器。</p>\n</blockquote>\n<h1 id=\"Spring-Boot优点\"><a href=\"#Spring-Boot优点\" class=\"headerlink\" title=\"Spring Boot优点\"></a>Spring Boot优点</h1><p>①　使用Spring Boot可以创建独立的Spring应用程序<br>②　在Spring Boot中<strong>直接嵌入了Tomcat</strong>、Jetty、Undertow等Web  容器，在使用SpringBoot做Web开发时<strong>不需要部署WAR文件</strong><br>③　通过提供自己的启动器(Starter)依赖，简化项目构建配置<br>④　尽量的自动配置Spring和第三方库<br>⑤　绝对没有代码生成，也不需要XML配置文件</p>\n<h1 id=\"Spring-Boot的核心\"><a href=\"#Spring-Boot的核心\" class=\"headerlink\" title=\"Spring Boot的核心\"></a>Spring Boot的核心</h1><p><strong>起步依赖</strong>：起步依赖本质上是一个Maven项目对象模型（Project Object Model，POM），定义了对其他库的传递依赖，这些东西加在一起即支持某项功能。 简单的说，起步依赖就是将具备某种功能的坐标打包到一起，并提供一些默认的功能。</p>\n<p><strong>自动配置</strong> ：Spring Boot的自动配置是一个运行时（更准确地说，是应用程序启动时）的过程，考虑了众多因素，才决定 Spring配置应该用哪个，不该用哪个。该过程是Spring自动完成的。</p>\n<h1 id=\"启动原理分析\"><a href=\"#启动原理分析\" class=\"headerlink\" title=\"启动原理分析\"></a>启动原理分析</h1><img data-src=\"/2022/10/07/Spring_Family/SpringBoot/%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE.jpg\" class=\"\">\n\n\n\n\n<pre><code class=\"java\">static class Registrar implements ImportBeanDefinitionRegistrar, DeterminableImports &#123;\n    @Override\n    public void registerBeanDefinitions(AnnotationMetadata metadata, BeanDefinitionRegistry registry) &#123;\n        register(registry, new PackageImports(metadata).getPackageNames().toArray(new String[0]));\n    &#125;\n    @Override\n    public Set&lt;Object&gt; determineImports(AnnotationMetadata metadata) &#123;\n        return Collections.singleton(new PackageImports(metadata));\n    &#125;\n&#125;\n</code></pre>\n<p>将配置类@SpringBootApplication标注的类所在包及下面所有子包里的所有组件扫描到spring容器</p>\n<pre><code class=\"java\">protected List&lt;String&gt; getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes) &#123;\n        List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(getSpringFactoriesLoaderFactoryClass(),\n                getBeanClassLoader());\n        Assert.notEmpty(configurations, &quot;No auto configuration classes found in META-INF/spring.factories. If you &quot;\n                + &quot;are using a custom packaging, make sure that file is correct.&quot;);\n        return configurations;\n    &#125;\n</code></pre>\n<p><strong>通过 getCandidateConfigurations读取自带的配置文件，得到他们的全路径名，通过反射创建他们</strong></p>\n<h1 id=\"异常处理和拦截器\"><a href=\"#异常处理和拦截器\" class=\"headerlink\" title=\"异常处理和拦截器\"></a>异常处理和拦截器</h1><p><strong>均与SpringMVC中处理一致</strong></p>\n<h1 id=\"分页\"><a href=\"#分页\" class=\"headerlink\" title=\"分页\"></a>分页</h1><p>主要参数：</p>\n<p>当前页 、一页n个(每页的数量)、 总条数</p>\n<h2 id=\"属性介绍\"><a href=\"#属性介绍\" class=\"headerlink\" title=\"属性介绍\"></a>属性介绍</h2><table>\n<thead>\n<tr>\n<th align=\"center\">属性名</th>\n<th align=\"center\">类型</th>\n<th align=\"center\">默认值</th>\n<th align=\"center\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">overflow</td>\n<td align=\"center\">boolean</td>\n<td align=\"center\">false</td>\n<td align=\"center\">溢出总页数后是否进行处理<br/>(默认不处理,参见 <code>插件#continuePage</code> 方法)</td>\n</tr>\n<tr>\n<td align=\"center\">maxLimit</td>\n<td align=\"center\">Long</td>\n<td align=\"center\"></td>\n<td align=\"center\">单页分页条数限制<br/>(默认无限制,参见 <code>插件#handlerLimit</code> 方法)</td>\n</tr>\n<tr>\n<td align=\"center\">dbType</td>\n<td align=\"center\">DbType</td>\n<td align=\"center\"></td>\n<td align=\"center\">数据库类型<br/>(根据类型获取应使用的分页方言,参见 <code>插件#findIDialect</code> 方法)</td>\n</tr>\n<tr>\n<td align=\"center\">dialect</td>\n<td align=\"center\">IDialect</td>\n<td align=\"center\"></td>\n<td align=\"center\">方言实现类<br/>(参见 <code>插件#findIDialect</code> 方法)</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>建议单一数据库类型的均设置 dbType</p>\n</blockquote>\n<pre><code class=\"java\">    @GetMapping(&quot;/test&quot;)\n    public Response test()&#123;\n        Page&lt;Produce&gt; producePage = new Page&lt;&gt;(1,1);\n        Page&lt;Produce&gt; page = produceService.page(producePage);\n        System.out.println(producePage == page);\n        List&lt;Produce&gt; records = page.getRecords();\n        for (Produce record : records) &#123;\n            System.out.println(record);\n        &#125;\n        return new Response&lt;&gt;(records, ResultEnum.SUCCESS);\n    &#125;\n</code></pre>\n<img data-src=\"/2022/10/07/Spring_Family/SpringBoot/656c18aaaf9ed11fee9b9f1576cc840f.png\" class=\"\">\n\n\n<p>默认是会查询总条数，都有get、set方法，可以根据自己的需求设置（点开Page类看看）</p>\n<img data-src=\"/2022/10/07/Spring_Family/SpringBoot/d0e0280ca8a9d46a4a41c4a1de89ab3c.png\" class=\"\">\n\n\n\n\n\n\n\n\n\n\n<h1 id=\"项目打包和部署\"><a href=\"#项目打包和部署\" class=\"headerlink\" title=\"项目打包和部署\"></a>项目打包和部署</h1><h2 id=\"打包\"><a href=\"#打包\" class=\"headerlink\" title=\"打包\"></a>打包</h2><p>SpringBoot项目打包在linux服务器中运行:<br>    ①jar类型项目会打成jar包:<br>    jar类型项目使用SpringBoot打包插件打包时，会在打成的jar中内置一个tomcat的jar。所以我们可以使用jdk直接运行该jar项目可，jar项目中有一个功能，将功能代码放到其内置的tomcat中运行。我们直接使用浏览器访问即可。<br>    ②war类型项目会打成war包:<br>    在打包时需要将内置的tomcat插件排除，配置servlet的依赖。将war正常的放到tomcat服务器中运行即可。</p>\n<img data-src=\"/2022/10/07/Spring_Family/SpringBoot/image-20220718170542347.png\" class=\"\">\n\n\n<h2 id=\"部署\"><a href=\"#部署\" class=\"headerlink\" title=\"部署\"></a>部署</h2><p><strong>注：这里是部署到Tomcat（war），jar直接编译启动</strong></p>\n<h3 id=\"第一步：\"><a href=\"#第一步：\" class=\"headerlink\" title=\"第一步：\"></a>第一步：</h3><pre><code>在部署到Tomcat 之前我们要将我们项目中的Tomcat(==它在Web中==)去掉，但是我们在项目中又有可能要使用他提供的jar包 HttpServlet 之类的，所以我们还需要再将它手动导入，但是他不需要他打包。\n</code></pre>\n<pre><code class=\"xml\">&lt;!--配置SpringBoot的web启动器--&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;\n    &lt;!--排除web启动中自动依赖的tomcat插件--&gt;\n    &lt;exclusions&gt;\n        &lt;exclusion&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;\n        &lt;/exclusion&gt;\n    &lt;/exclusions&gt;\n&lt;/dependency&gt;\n\n&lt;!--\n    手动依赖tomcat插件，但是表明项目打包时该依赖不会被打进去，目的主要是保证开发阶段本地SpringBoot\n    项目可以正常运行\n--&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;\n    &lt;!--打包的时候可以不用包进去，别的设施会提供。事实上该依赖理论上可以参与编译，测试，运行等周期。\n        相当于compile，但是打包阶段做了exclude操作--&gt;\n    &lt;scope&gt;provided&lt;/scope&gt;\n&lt;/dependency&gt;\n</code></pre>\n<h3 id=\"第二步：\"><a href=\"#第二步：\" class=\"headerlink\" title=\"第二步：\"></a>第二步：</h3><p>SpringBoot的<strong>启动类继承SpringBootServletInitializer</strong>，并<strong>重写configure</strong></p>\n<pre><code class=\"java\">@SpringBootApplication\npublic class MyApplication extends SpringBootServletInitializer &#123;\n    //重写配置方法\n    @Override\n    protected SpringApplicationBuilder configure(SpringApplicationBuilder application) &#123;\n        return application.sources(MyApplication.class);\n    &#125;\n    public static void main(String[] args) &#123;\n        //启动SpringBoot\n        SpringApplication.run(MyApplication.class,args);\n    &#125;\n&#125;\n</code></pre>\n<p>使用package命令打包项目，并将war包放到tomcat下的webapps下，启动tomcat即可。</p>\n<h3 id=\"注：\"><a href=\"#注：\" class=\"headerlink\" title=\"注：\"></a>注：</h3><ul>\n<li>部署到tomcat之后我们的URL就会变化，tomcat会自动编译war包，我们的<strong>项目名和war包同名</strong>，所以不想改变提前修改</li>\n<li><strong>端口号也是tomcat的端口号</strong>（tomcat&#x2F;conf&#x2F;server.xml）</li>\n</ul>\n<h1 id=\"面试题\"><a href=\"#面试题\" class=\"headerlink\" title=\"面试题\"></a>面试题</h1><h2 id=\"SpringBoot约定大于配置理解\"><a href=\"#SpringBoot约定大于配置理解\" class=\"headerlink\" title=\"SpringBoot约定大于配置理解\"></a>SpringBoot约定大于配置理解</h2><p>约定大于配置是一种开发原则，就是减少人为的配置，直接用默认的配置就能获得我们想要的结果。<br>　　SpringBoot的约定大于配置，按我的理解是：对比SpringMVC，需要在web.xml里面配置前端控制器，还需要在核心配置文件（*-servlet.xml）中配置视图解析器啥的，更要配置第三方的Tomcat服务器。而SpringBoot就不需要我们配置这些，他内嵌了Tomcat服务器，我们只需要在Maven配置文件（Pom.xml）里面导入SpringMVC所需要的依赖就可以了。<br>　　这就是SpringBoot的优势，在传统所需要配置的地方，SpringBoot都进行了约定（配置好了），开发人员能配置得更少，更直接地开发项目，写业务逻辑代码。<br>spring boot和maven的约定大于配置体现 点：<br>　　1.maven的目录文件结构<br>　　1）默认有resources文件夹,存放资源配置文件。src-main-resources,src-main-java<br>默认的编译生成的类都在targetwen。<br>　　2）默认有target文件夹，将生成class文件盒编程生成的jar存放在target文件夹下</p>\n<p>2.spring boot默认的配置文件必须是，也只能是application.命名的yml文件或者properties文件，且唯一</p>\n<p>1）spring boot默认只会去src-main-resources文件夹下去找application配置文件</p>\n<p>这个问题呢，我从四个方面来回答。</p>\n<p>首先，约定优于配置是一种软件设计的范式，它的核心思想，是减少软件开发人员对于配置项的。从而让开发人员更加聚焦在业务逻辑上</p>\n<p>第二个呢，Spring boot就是约定优于配置这一理念下的产物，它类似于spring框架下的一个脚手架，通过spring boot，我们可以快速开发基于spring生态下的应用程序。基于传统的spring框架开发web应用的时候，我们需要做很多和业务无关，并且只需要做一次的配置项，比如</p>\n<ol>\n<li><p>管理架包的依赖</p>\n</li>\n<li><p>web.xml的维护</p>\n</li>\n<li><p>spring MVC中的一个叫 Dispatch-Servlet.x ml 配置项的一个维护</p>\n</li>\n<li><p>应用需要自己手动去部署到web容器</p>\n</li>\n<li><p>第三方组件集成到spring IOC容器中，我们需要做配置项的维护</p>\n</li>\n</ol>\n<p>而在SpringBoot中，我们不再需要去做这些繁琐的配置，因为SpringBoot已经帮我们自动完成了，而完成这样一个动作的前提就是基于&#x3D;&#x3D;约定优于配置&#x3D;&#x3D;这样一个思想。</p>\n<p>最后呢，Spring boot约定优于配置的体现有很多，</p>\n<p>比如第一个spring boat start启动依赖，它能够帮助我们管理所有的jar包版本。</p>\n<p>第二个，如果当前的应用依赖了web这样一个 jar 包，那么spring boot会自动内置Tomcat，他们看着容器来去运行web应用，我们不再需要去单独进行应用部署。</p>\n<p>第三，Spring boot的自动装配机制的实现中，通过扫描约定路径下的spring.factory文件去进行识别配置类，从而去实现类的自动装载</p>\n<p>第四，Spring boot？默认会加载resource目录下的application.property文件。总的来说啊，约定优于配置呢，是一个比较常见的软件设计思想，它的核心本质都是为了去更加高效，以及更加便捷的去实现软件系统的开发和维护。</p>\n<p><strong>自我总结：</strong></p>\n<p>​\t约定大于配置，不是说我们要设定啥，原来规定的是什么就不能改变，不是这个意思。他真正的意思是说当我们配置某个选项时，springboot会自动帮我们加载可能会与其相关的配置，就好比我们应用依赖了 web，那么spring boot会自动内置Tomcat，他们看着容器来去运行web应用，我们不再需要去单独进行应用部署。</p>\n<p>​\t总的来说啊，约定优于配置呢，是一个比较常见的软件设计思想，它的核心本质都是为了去更加高效，以及更加便捷的去实现软件系统的开发和维护。</p>\n",
            "tags": [
                "框架",
                "Spring",
                "SpringBoot"
            ]
        },
        {
            "id": "http://example.com/2022/10/07/Spring_Family/SpringMVC/",
            "url": "http://example.com/2022/10/07/Spring_Family/SpringMVC/",
            "title": "SpringMVC",
            "date_published": "2022-10-06T16:00:00.000Z",
            "content_html": "<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><img data-src=\"/2022/10/07/Spring_Family/SpringMVC/image-20220716212203883.png\" class=\"\">\n\n\n<p>M   model      模型层   DAO封装        &gt;&gt;&gt; Mybatis<br>V    view         视图层   html css js  jsp<br>C    controller 控制层   Servlet封装    &gt;&gt;&gt; springMVC </p>\n<p>SpringMVC是spring为展现层提供的基于MVC设计理念的优秀WEB框架,是目前最主流的MVC框架之一<br>SpringMVC通过一套注解,可以让普通的JAVA类成为contrllor控制器,无需继承Servlet,实现了控制层和Servlet之间的解耦<br>SpringMVC支持Rest风格的URL写法<br>SpringMVC采用了松耦合,可热插的主键结构,比其他的框架更具扩展性和灵活性</p>\n<h1 id=\"执行流程\"><a href=\"#执行流程\" class=\"headerlink\" title=\"执行流程\"></a>执行流程</h1><img data-src=\"/2022/10/07/Spring_Family/SpringMVC/image-20220717190437596.png\" class=\"\">\n\n\n<img data-src=\"/2022/10/07/Spring_Family/SpringMVC/image-20220717190445738.png\" class=\"\">\n\n\n<p>1DispatcherServlet：前端控制器<br>用户请求到达前端控制器，它就相当于 mvc 模式中的 c，dispatcherServlet 是整个流程控制的中心，由 它调用其它组件处理用户的请求，dispatcherServlet 的存在降低了组件之间的耦合性。</p>\n<p><strong>2 HandlerMapping：处理器映射器</strong><br>HandlerMapping 负责根据用户请求找到 Handler 即处理器，SpringMVC 提供了不同的映射器实现不同的 映射方式，例如：配置文件方式，实现接口方式，注解方式等。</p>\n<p>3 Handler：处理器 (自己定义的Controller处理单元)<br>它就是我们开发中要编写的具体业务控制器。由 DispatcherServlet 把用户请求转发到 Handler。由 Handler 对具体的用户请求进行处理。</p>\n<p><strong>4 HandlAdapter：处理器适配器</strong><br>通过 HandlerAdapter 对处理器进行执行，这是适配器模式的应用，通过扩展适配器可以对更多类型的处理器进行执行</p>\n<p>5 View Resolver：视图解析器<br>View Resolver 负责将处理结果生成 View 视图，View Resolver 首先根据逻辑视图名解析成物理视图名 即具体的页面地址，再生成 View 视图对象，最后对 View 进行渲染将处理结果通过页面展示给用户。</p>\n<p>6 View：视图<br>SpringMVC 框架提供了很多的 View 视图类型的支持，包括：jstlView、freemarkerView、pdfView等。我们最常用的视图就是 jsp。 一般情况下需要通过页面标签或页面模版技术将模型数据通过页面展示给用户，需要由程序员根据业务需求开 发具体的页面。</p>\n<p>7 <span class=\"exturl\" data-url=\"bXZjOmFubm90YXRpb24tZHJpdmVu\">mvc:annotation-driven</span>说明<br>在 SpringMVC 的各个组件中，处理器映射器、处理器适配器、视图解析器称为 SpringMVC 的三大组件。<br>使 用 <span class=\"exturl\" data-url=\"bXZjOmFubm90YXRpb24tZHJpdmVu\">mvc:annotation-driven</span> 自动加载 RequestMappingHandlerMapping （处理映射器） 和 RequestMappingHandlerAdapter （ 处 理 适 配 器 ） ， 可 用 在 SpringMVC.xml 配 置 文 件 中 使 用 <span class=\"exturl\" data-url=\"bXZjOmFubm90YXRpb24tZHJpdmVu\">mvc:annotation-driven</span>替代注解处理器和适配器的配置。</p>\n<p>HandlerMapping的实现类的作用<br>实现类RequestMappingHandlerMapping，它会处理@RequestMapping 注解，并将其注册到请求映射表中。</p>\n<p>HandlerAdapter的实现类的作用<br>实现类RequestMappingHandlerAdapter，则是处理请求的适配器，确定调用哪个类的哪个方法，并且构造方法参数，返回值。</p>\n<p>当配置了mvc:annotation-driven&#x2F;后，Spring就知道了我们启用注解驱动。然后Spring通过context:component-scan&#x2F;标签的配置，会自动为我们将扫描到的@Component，@Controller，@Service，@Repository等注解标记的组件注册到工厂中，来处理我们的请求,这个时候接收返回json数据、参数验证、统一异常等功能。</p>\n<h1 id=\"重要注解\"><a href=\"#重要注解\" class=\"headerlink\" title=\"重要注解\"></a>重要注解</h1><h2 id=\"1、RequestMapping\"><a href=\"#1、RequestMapping\" class=\"headerlink\" title=\"1、RequestMapping\"></a>1、RequestMapping</h2><p>紧耦合方式(了解)<br>DispatcherServlet中的service方法直接将此次请求的request对象传递给调用的单元方法即可。同时在单元方法上声明形参HttpServletRequest来接收request实参即可。<br><strong>解耦合方式(熟练)</strong><br>DispatcherServlet在其service方法中将请求数据根据需求从request对象中获取出来后，将数据直接传递给对应的单元方法使用。同时在单元方法上直接声明对应的形参接收请求数据即可。在单元方法上声明形参来接收请求数据时，形参名必须和请求数据的键名一致，DispatcherServlet会将调用单元方法的形参名作为请求数据的键名获取请求数据，然后传递给单元方法。</p>\n<pre><code class=\"java\">@RestController\npublic class TestDataController &#123;\n    /*紧耦合方式参数注入\n    * 使用传统的HttpServletRequest对象获取参数  javax.servlet\n    * */\n    @RequestMapping(&quot;/getParamByRequest.do&quot;)\n    public String getParam1(HttpServletRequest req, HttpServletResponse resp)&#123;\n        String username = req.getParameter(&quot;username&quot;);\n        String password = req.getParameter(&quot;password&quot;);\n        System.out.println(&quot;username:&quot;+username+&quot;   password:&quot;+password);\n        return &quot;getParamSuccess&quot;;\n    &#125;\n    /*解耦合方式参数注入\n    * HttpServletRequest对象获取参数 通过SpringMVC框架功能,自动转换参数\n    * 处理单元参数列表中参数名必须和请求中的参数名一致\n                                        * 如不一致,可以通过@RequestParma注解进行转换\n    * */\n    @RequestMapping(&quot;/getParamByArgName.do&quot;)\n    public String getParam2(String username,@RequestParam(&quot;pwd&quot;) int password)&#123;\n        System.out.println(&quot;username:&quot;+username+&quot;   password:&quot;+password);\n        return &quot;getParamSuccess&quot;;\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"2、PathVariable注解和RESTful风格的支持\"><a href=\"#2、PathVariable注解和RESTful风格的支持\" class=\"headerlink\" title=\"2、PathVariable注解和RESTful风格的支持\"></a>2、PathVariable注解和RESTful风格的支持</h2><p><strong>普通形式的url</strong></p>\n<pre><code class=\"java\">*/contextPath/aaa.do\n*/contextPath/aaa.jsp\n*/contextPath/aaa.html\n*/contextPath/css/aaa.css\n*/contextPath/js/aaa.js\n*/contextPath/aaa.do?id=10&amp;username=root\n</code></pre>\n<p><strong>restFul风格的url</strong></p>\n<pre><code class=\"java\">*/contextPath/aaa/10/root\n*/contextPath/aaa\n</code></pre>\n<pre><code class=\"java\">@Controller\npublic class PathController &#123;\n    @RequestMapping(&quot;/testPathVariable/&#123;id&#125;/&#123;username&#125;&quot;)\n    public String testPathVariable(@PathVariable(&quot;id&quot;) Integer id, @PathVariable(&quot;username&quot;) String username)&#123;\n        System.out.println(&quot;id:&quot;+id);\n        System.out.println(&quot;username:&quot;+username);\n        System.out.println(&quot;testPathVariable1&quot;);\n        return &quot;success&quot;;\n    &#125;\n&#125;\n</code></pre>\n<img data-src=\"/2022/10/07/Spring_Family/SpringMVC/image-20220717191056216.png\" class=\"\">\n\n\n<img data-src=\"/2022/10/07/Spring_Family/SpringMVC/image-20220717191104583-1661419340091.png\" class=\"\">\n\n\n\n\n\n\n<h1 id=\"响应处理\"><a href=\"#响应处理\" class=\"headerlink\" title=\"响应处理\"></a>响应处理</h1><img data-src=\"/2022/10/07/Spring_Family/SpringMVC/image-20220717191212189-1661419342477.png\" class=\"\">\n\n\n\n\n<p>1、单元方法返回值为void</p>\n<img data-src=\"/2022/10/07/Spring_Family/SpringMVC/image-20220717191318663-1661419344199.png\" class=\"\">\n\n\n<blockquote>\n<p>在SpringMVC中如果对于当前的控制单元，没有写对应的返回值，这个时候<strong>SpringMVC就会找和自己控制单元名称一致的页面展示</strong>，<strong>如果没有配置视图解析器的前缀和后缀是没有产生404</strong>,需要注意控制单元仍然可以进。</p>\n</blockquote>\n<p>2、转发和重定向ServletAPI 实现</p>\n<pre><code class=\"java\">@RequestMapping(&quot;demo1&quot;)\n    public void testDemo1(HttpServletRequest request, HttpServletResponse response) throws Exception &#123;\n        // 请求转发\n        //request.getRequestDispatcher(&quot;/forward.jsp&quot;).forward(request,response);\n        // 响应重定向\n        response.sendRedirect(request.getContextPath()+&quot;/redirect.jsp&quot;);\n    &#125;\n</code></pre>\n<blockquote>\n<p>单元方法的返回值类型设置void。因为使用response对象在单元方法中直接对此次请求进行了响应，不再通过DispatcherServlet了，既然已经响应了，就不需要再给DispatcherServlet返回值了。在单元方法上声明HttpServletResponse形参，来接收此次请求的response对象。</p>\n</blockquote>\n<p>3、使用forward关键字完成响应</p>\n<pre><code class=\"java\"> /*\n    * 返回字符串告诉DispatcherServlet跳转的路径\n    * 在路径之前放上一个forward: 关键字,就是请求转发\n    * 如果路径前的关键字是forward,那么可以省略不写\n    * */\n    @RequestMapping(&quot;demo2&quot;)\n    public String testDemo2() throws Exception &#123;\n        //return &quot;forward:/forwardPage.jsp&quot;;\n        return &quot;/forwardPage.jsp&quot;;\n    &#125;\n</code></pre>\n<p>使用通过单元方法的返回值来告诉DispatcherServlet请求转发指定的资源,如果是请求转发，<strong>forward关键字可以<em>省略不写</em>的</strong></p>\n<p>4、使用redirect关键字完成响应</p>\n<pre><code class=\"java\">/*\n     * 返回字符串告诉DispatcherServlet跳转的路径\n     * 在路径之前放上一个redirect: 关键字,就是重定向\n     * 如果路径前的关键字是redirect,那么不可以省略\n     * /表示当前项目下.这里不需要项目的上下文路径\n     * */\n    @RequestMapping(&quot;demo3&quot;)\n    public String testDemo3() throws Exception &#123;\n        return &quot;redirect:/redirectPage.jsp&quot;;\n    &#125;\n</code></pre>\n<p>使用通过单元方法的返回值来告诉DispatcherServlet重定向指定的资源，注意这个<strong>redirect关键字<em>不可以省去</em></strong></p>\n<p>5、使用View视图转发和重定向</p>\n<pre><code class=\"java\"> @RequestMapping(&quot;demo4&quot;)\n    public View testDemo4(HttpServletRequest req)   &#123;\n        View  view =null;\n        // 请求转发\n        //view =new InternalResourceView(&quot;/forwardPage.jsp&quot;);\n        // 重定向\n        view=new RedirectView(req.getContextPath()+&quot;/redirectPage.jsp&quot;);\n        return view;\n    &#125;\n</code></pre>\n<blockquote>\n<p>RedirectView中所做的操作，最终的实现是在renderMergedOutputModel中完成实现的，简单来说RedirectView实现了链接的重定向，并且将数据保存到FlashMap中，这样在跳转后的链接中可以获取一些数据.</p>\n</blockquote>\n<p>6、使用ModelAndView转发重定向</p>\n<pre><code class=\"java\">@RequestMapping(&quot;demo5&quot;)\n    public ModelAndView testDemo5(HttpServletRequest req)   &#123;\n        ModelAndView mv=new ModelAndView();\n        // 请求转发\n        //mv.setViewName(&quot;forward:/forwardPage.jsp&quot;);\n        //mv.setView(new InternalResourceView(&quot;/forwardPage.jsp&quot;));\n        // 重定向\n        //mv.setViewName(&quot;redirect:/redirectPage.jsp&quot;);\n        mv.setView(new RedirectView(req.getContextPath()+&quot;/redirectPage.jsp&quot;));\n        return mv;\n    &#125;\n</code></pre>\n<p>​\tModelAndView中的Model代表模型，View代表视图，这个名字就很好地解释了该类的作用。业务处理器调用模型层处理完用户请求后，把结果数据存储在该类的model属性中，把要返回的视图信息存储在该类的view属性中，然后让该ModelAndView返回该Spring MVC框架。</p>\n<h1 id=\"作用域传参\"><a href=\"#作用域传参\" class=\"headerlink\" title=\"作用域传参\"></a>作用域传参</h1><img data-src=\"/2022/10/07/Spring_Family/SpringMVC/image-20220717191751516-1661419352934.png\" class=\"\">\n\n\n<blockquote>\n<p>PageContext对象</p>\n</blockquote>\n<p>作用域范围:当前jsp页面内有效</p>\n<blockquote>\n<p>request对象</p>\n</blockquote>\n<p>作用域范围:一次请求内。</p>\n<p>作用: 解决了一次请求内的资源的数据共享问题</p>\n<blockquote>\n<p>session对象</p>\n</blockquote>\n<p>作用域范围:一次会话内有效。</p>\n<p>说明:浏览器不关闭,并且后台的session不失效，在任意请求中都可以获取到同一个session对象。</p>\n<p>作用:解决了一个用户不同请求的数据共享问题。</p>\n<blockquote>\n<p>application(ServletContext)对象</p>\n</blockquote>\n<p>作用域范围:整个项目内有效。</p>\n<p>特点:一个项目只有一个，在服务器启动的时候即完成初始化创建无论如何获取都是同一个项目。</p>\n<p>作用:解决了不同用户的数据共享问题。</p>\n<h1 id=\"拦截器\"><a href=\"#拦截器\" class=\"headerlink\" title=\"拦截器\"></a>拦截器</h1><h2 id=\"引入\"><a href=\"#引入\" class=\"headerlink\" title=\"引入\"></a>引入</h2><blockquote>\n<p>&#x3D;&#x3D;过滤器的作用是保护请求的服务器资源，在请求资源被执行之前&#x3D;&#x3D;，如果请求地址符合拦截范围，则会先执行过滤器。&#x3D;&#x3D;过滤器的执行时机，是在Servlet之前执行的&#x3D;&#x3D;。但是在使用了SpringMVC后，Servlet只有一个了，也就是DisptcherServlet。那么，如果我们仍然使用过滤器来完成请求的拦截，因为过滤器是在Servlet之前执行的，就会造成，&#x3D;&#x3D;过滤器会拦截DispatcherServlet所有的请求&#x3D;&#x3D;。那么，如果我们有&#x3D;&#x3D;部分请求不想被拦截&#x3D;&#x3D;，怎么办？</p>\n</blockquote>\n<h2 id=\"拦截器使用\"><a href=\"#拦截器使用\" class=\"headerlink\" title=\"拦截器使用\"></a>拦截器使用</h2><img data-src=\"/2022/10/07/Spring_Family/SpringMVC/image-20220717191927439-1661419356594.png\" class=\"\">\n\n\n<p>Spring MVC中的拦截器（Interceptor）类似于Servlet中的过滤器（Filter），它主要用于拦截用户请求并作相应的处理。例如通过拦截器可以进行权限验证、记录请求信息的日志、判断用户是否登录等。<br>    要使用Spring MVC中的拦截器，就需要对拦截器类进行定义和配置。通常拦截器类可以通过两种方式来定义。<br>    1.通过实现HandlerInterceptor接口，或继承HandlerInterceptor接口的实现类（如HandlerInterceptorAdapter）来定义。<br>    2.通过实现WebRequestInterceptor接口，或继承WebRequestInterceptor接口的实现类来定义。</p>\n<h2 id=\"拦截器和过滤器的区别\"><a href=\"#拦截器和过滤器的区别\" class=\"headerlink\" title=\"拦截器和过滤器的区别\"></a>拦截器和过滤器的区别</h2><ol>\n<li><p>拦截器SpringMVC的，而过滤器是servlet的。\t</p>\n</li>\n<li><p>拦截器不依赖与servlet容器,由spring容器初始化，过滤器依赖与servlet容器,由servlet容器初始化。. </p>\n</li>\n<li><p>拦截器只能对action请求起作用，而过滤器则可以对几乎所有的请求起作用。</p>\n</li>\n<li><p>拦截器可以访问action上下文、值栈里的对象，而过滤器不能访问。</p>\n</li>\n<li><p>在action的生命周期中，拦截器可以多次被调用，而过滤器只能在容器初始化时被调用一次。</p>\n</li>\n<li><p>拦截器可以获取IOC容器中的各个bean，而过滤器就不太方便，这点很重要，在拦截器里注入一个service，可以调用业务逻辑。</p>\n</li>\n</ol>\n<pre><code class=\"java\">public class MyInterceptor implements HandlerInterceptor &#123;\n    @Override\n    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;\n        /*在请求到达我们定义的handler之前工作的*/\n        System.out.println(&quot;MyInterceptor preHandle&quot;);\n        /*返回的是true,代表放行,可以继续到达handler*/\n        return true;\n    &#125;\n    @Override\n    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123;\n        System.out.println(&quot;MyInterceptor postHandle&quot;);\n        /*handler 处理单元返回ModelAndView 时候进行 拦截*/\n    &#125;\n    @Override\n    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123;\n        /*\n        页面渲染完毕,但是还没有给浏览器响应数据的时候\n         */\n        System.out.println(&quot;MyInterceptor afterCompletion&quot;);\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"多个拦截器执行顺序\"><a href=\"#多个拦截器执行顺序\" class=\"headerlink\" title=\"多个拦截器执行顺序\"></a>多个拦截器执行顺序</h2><p>多个拦截器同时存在时,执行的顺序由配置顺序决定. 先配置谁, 谁就先执行.多个拦截器可以理解为拦截器栈, 先进后出(后进先出), 如图所示:</p>\n<img data-src=\"/2022/10/07/Spring_Family/SpringMVC/image-20220717192103889-1661419360360.png\" class=\"\">\n\n\n\n\n<h1 id=\"异常处理\"><a href=\"#异常处理\" class=\"headerlink\" title=\"异常处理\"></a>异常处理</h1><h2 id=\"SpringMVC异常简介\"><a href=\"#SpringMVC异常简介\" class=\"headerlink\" title=\"SpringMVC异常简介\"></a>SpringMVC异常简介</h2><p>​\t系统中异常包括两类：预期异常(检查型异常)和运行时异常 RuntimeException，前者通过捕获异常从而获取异常信息， 后者主要通过规范代码开发、测试通过手段减少运行时异常的发生</p>\n<h2 id=\"具体实现\"><a href=\"#具体实现\" class=\"headerlink\" title=\"具体实现\"></a>具体实现</h2><h3 id=\"1使用-ExceptionHandler注解处理异常\"><a href=\"#1使用-ExceptionHandler注解处理异常\" class=\"headerlink\" title=\"1使用@ExceptionHandler注解处理异常\"></a>1使用@ExceptionHandler注解处理异常</h3><p>缺点：只能处理当前Controller中的异常。</p>\n<pre><code class=\"java\"> @ExceptionHandler(value =&#123;ArithmeticException.class,NullPointerException.class&#125; )\n    public ModelAndView handelException()&#123;\n        ModelAndView mv =new ModelAndView();\n        mv.setViewName(&quot;error1.jsp&quot;);\n        return mv;\n    &#125;\n</code></pre>\n<h3 id=\"2使用：-ControllerAdvice-ExceptionHandler\"><a href=\"#2使用：-ControllerAdvice-ExceptionHandler\" class=\"headerlink\" title=\"2使用：@ControllerAdvice+@ExceptionHandler\"></a>2使用：@ControllerAdvice+@ExceptionHandler</h3><p>此处优先级低于局部异常处理器</p>\n<pre><code class=\"java\">@ControllerAdvice\npublic class GloableExceptionHandler1 &#123;\n    @ExceptionHandler(value =&#123;ArithmeticException.class,NullPointerException.class&#125; )\n    public ModelAndView handelException()&#123;\n        ModelAndView mv =new ModelAndView();\n        mv.setViewName(&quot;error1.jsp&quot;);\n        return mv;\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"3使用：SimpleMappingExceptionResolver\"><a href=\"#3使用：SimpleMappingExceptionResolver\" class=\"headerlink\" title=\"3使用：SimpleMappingExceptionResolver\"></a>3使用：SimpleMappingExceptionResolver</h3><pre><code class=\"java\">/**\n * 全局异常\n */\n  @Configuration\n  public class GloableException2 &#123;\n    @Bean\n    public SimpleMappingExceptionResolver getSimpleMappingExceptionResolver()&#123;\n        SimpleMappingExceptionResolver resolver = new SimpleMappingExceptionResolver();\n        Properties prop = new Properties();\n        prop.put(&quot;java.lang.NullPointerException&quot;,&quot;error1.jsp&quot;);\n        prop.put(&quot;java.lang.ArithmeticException&quot;,&quot;error2.jsp&quot;);\n        resolver.setExceptionMappings(prop);\n        return resolver;\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"4自定义的HandlerExceptionResolver\"><a href=\"#4自定义的HandlerExceptionResolver\" class=\"headerlink\" title=\"4自定义的HandlerExceptionResolver\"></a>4自定义的HandlerExceptionResolver</h3><pre><code class=\"java\">/**\n * 全局异常\n * HandlerExceptionResolve\n */\n  @Configuration\n  public class GloableException3 implements HandlerExceptionResolver &#123;\n    @Override\n    public ModelAndView resolveException(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e) &#123;\n        ModelAndView mv = new ModelAndView();\n        if(e instanceof NullPointerException)&#123;\n                mv.setViewName(&quot;error1&quot;);\n        &#125;\n        if(e instanceof ArithmeticException)&#123;\n                mv.setViewName(&quot;error2&quot;);\n        &#125;\n        mv.addObject(&quot;msg&quot;,e);\n        return mv;\n    &#125;&#125;\n</code></pre>\n<h1 id=\"其他注解\"><a href=\"#其他注解\" class=\"headerlink\" title=\"其他注解\"></a>其他注解</h1><h2 id=\"RequestBody\"><a href=\"#RequestBody\" class=\"headerlink\" title=\"@RequestBody\"></a>@RequestBody</h2><p>作用：</p>\n<p>​\t用于获取请求体json格式的字符串内容。直接使用得到是 key&#x3D;value&amp;key&#x3D;value…结构的数据，get 请求方式不适用。</p>\n<p>属性：</p>\n<p>​\trequired：是否必须有请求体。默认值是:true。当取值为 true 时,get 请求方式会报错。如果取值 为 false，get 请求得到是null。</p>\n<h2 id=\"CrossOrigin\"><a href=\"#CrossOrigin\" class=\"headerlink\" title=\"@CrossOrigin\"></a>@CrossOrigin</h2><p>作用：</p>\n<p>​\t解决ajax请求之间的跨域问题</p>\n<p>属性:</p>\n<p>origins  ： 允许可访问的域列表IP</p>\n<p>maxAge：准备响应前的缓存持续的最大时间（以秒为单位）。</p>\n",
            "tags": [
                "框架",
                "Spring",
                "SpringMVC"
            ]
        },
        {
            "id": "http://example.com/2022/10/07/Spring_Family/SpringSecurity/",
            "url": "http://example.com/2022/10/07/Spring_Family/SpringSecurity/",
            "title": "SpringSecurity",
            "date_published": "2022-10-06T16:00:00.000Z",
            "content_html": "<hr/>\n<p style=\"font-size:70px; color:red;background-color:66FF66\">Spring Security</p><br/><hr/>\n\n<h1 id=\"一、简介\"><a href=\"#一、简介\" class=\"headerlink\" title=\"一、简介\"></a>一、简介</h1><p>​\t\t<strong>Spring Security</strong> 是 Spring 家族中的一个安全管理框架。相比与另外一个安全框架<strong>Shiro</strong>，它提供了更丰富的功能，社区资源也比Shiro丰富。</p>\n<p>​\t一般来说中大型的项目都是使用<strong>SpringSecurity</strong> 来做安全框架。小项目有Shiro的比较多，因为相比与SpringSecurity，Shiro的上手更加的简单。</p>\n<p>​\t 一般Web应用的需要进行<strong>认证</strong>和<strong>授权</strong>。</p>\n<p>​\t\t<strong>认证：验证当前访问系统的是不是本系统的用户，并且要确认具体是哪个用户</strong></p>\n<p>​\t\t<strong>授权：经过认证后判断当前用户是否有权限进行某个操作</strong></p>\n<p>​\t而<strong>认证</strong>和<strong>授权</strong>也是SpringSecurity作为安全框架的<strong>核心功能</strong>。</p>\n<h1 id=\"二、第一个Spring-Security项目\"><a href=\"#二、第一个Spring-Security项目\" class=\"headerlink\" title=\"二、第一个Spring Security项目\"></a>二、第一个Spring Security项目</h1><h2 id=\"1-导入依赖\"><a href=\"#1-导入依赖\" class=\"headerlink\" title=\"1.导入依赖\"></a>1.导入依赖</h2><p>​\tSpring Security已经被Spring boot进行集成，使用时直接引入启动器即可。</p>\n<pre><code class=\"xml\">    &lt;properties&gt;\n        &lt;java.version&gt;1.8&lt;/java.version&gt;\n        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;\n        &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;\n        &lt;spring-boot.version&gt;2.3.7.RELEASE&lt;/spring-boot.version&gt;\n    &lt;/properties&gt;\t\n\n    &lt;dependencies&gt;\n        &lt;!--thymeleaf--&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n        &lt;!--druid--&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;\n            &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt;\n            &lt;version&gt;1.2.8&lt;/version&gt;\n        &lt;/dependency&gt;\n        &lt;!--mysql--&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;mysql&lt;/groupId&gt;\n            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n        &lt;!--mybatis-plus--&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;com.baomidou&lt;/groupId&gt;\n            &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;\n            &lt;version&gt;3.4.2&lt;/version&gt;\n        &lt;/dependency&gt;\n        &lt;!--redis依赖--&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n        &lt;!--fastjson依赖--&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;\n            &lt;artifactId&gt;fastjson&lt;/artifactId&gt;\n            &lt;version&gt;1.2.33&lt;/version&gt;\n        &lt;/dependency&gt;\n        &lt;!--jwt依赖--&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt;\n            &lt;artifactId&gt;jjwt&lt;/artifactId&gt;\n            &lt;version&gt;0.9.0&lt;/version&gt;\n        &lt;/dependency&gt;\n        &lt;!--spring-security--&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n        &lt;!--lombok--&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;\n            &lt;artifactId&gt;lombok&lt;/artifactId&gt;\n            &lt;optional&gt;true&lt;/optional&gt;\n        &lt;/dependency&gt;\n        &lt;!--spring-web--&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n        &lt;!--Spring test--&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;\n            &lt;scope&gt;test&lt;/scope&gt;\n            &lt;exclusions&gt;\n                &lt;exclusion&gt;\n                    &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt;\n                    &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt;\n                &lt;/exclusion&gt;\n            &lt;/exclusions&gt;\n        &lt;/dependency&gt;\n    &lt;/dependencies&gt;\n</code></pre>\n<h2 id=\"2-写一个控制器\"><a href=\"#2-写一个控制器\" class=\"headerlink\" title=\"2.写一个控制器\"></a>2.写一个控制器</h2><pre><code class=\"java\">\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RestController;\n\n@RestController\npublic class HelloController &#123;\n\n    @RequestMapping(&quot;/hello&quot;)\n    public String hello()&#123;\n        return &quot;hello&quot;;\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"3-访问页面\"><a href=\"#3-访问页面\" class=\"headerlink\" title=\"3.访问页面\"></a>3.访问页面</h2><p>​\t导入spring-boot-starter-security启动器后，Spring Security已经生效，默认拦截全部请求，如果用户没有登录，跳转到内置登录页面。</p>\n<p>​\t在项目中新建login.html页面后</p>\n<p>​\t在浏览器输入：<span class=\"exturl\" data-url=\"aHR0cDovL2xvY2FsaG9zdDo4MDgwL2xvZ2luLmh0bWwlRTUlOTAlOEUlRTQlQkMlOUElRTYlOTglQkUlRTclQTQlQkElRTQlQjglOEIlRTklOUQlQTIlRTklQTElQjUlRTklOUQlQTI=\">http://localhost:8080/login.html后会显示下面页面</span></p>\n<img data-src=\"/2022/10/07/Spring_Family/SpringSecurity/springSecurity-01.jpg\" class=\"\">\n\n\n<p>​\t默认的username为user，password打印在控制台中。当然了，每个人的显示的肯定和我的不一样。</p>\n<p>​\t\t在浏览器中输入账号和密码后会显示login.html页面内容。</p>\n<h1 id=\"三、用户认证\"><a href=\"#三、用户认证\" class=\"headerlink\" title=\"三、用户认证\"></a>三、用户认证</h1><h2 id=\"3-1-登陆校验流程\"><a href=\"#3-1-登陆校验流程\" class=\"headerlink\" title=\"3.1 登陆校验流程\"></a>3.1 登陆校验流程</h2><img data-src=\"/2022/10/07/Spring_Family/SpringSecurity/image-20211215094003288.png\" class=\"\">\n\n\n<h2 id=\"3-2-原理初探\"><a href=\"#3-2-原理初探\" class=\"headerlink\" title=\"3.2 原理初探\"></a>3.2 原理初探</h2><p>​\t想要知道如何实现自己的登陆流程就必须要先知道入门案例中SpringSecurity的流程。</p>\n<h3 id=\"3-2-1-SpringSecurity完整流程\"><a href=\"#3-2-1-SpringSecurity完整流程\" class=\"headerlink\" title=\"3.2.1 SpringSecurity完整流程\"></a>3.2.1 SpringSecurity完整流程</h3><p>​\tSpringSecurity的原理其实就是一个过滤器链，内部包含了提供各种功能的过滤器。这里我们可以看看入门案例中的过滤器。</p>\n<img data-src=\"/2022/10/07/Spring_Family/SpringSecurity/image-20211214144425527.png\" class=\"\">\n\n\n<p>​\t图中只展示了核心过滤器，其它的非核心过滤器并没有在图中展示。</p>\n<p><strong>UsernamePasswordAuthenticationFilter</strong>:负责处理我们在登陆页面填写了用户名密码后的登陆请求。入门案例的认证工作主要有它负责。</p>\n<p><strong>ExceptionTranslationFilter：</strong>处理过滤器链中抛出的任何AccessDeniedException和AuthenticationException 。</p>\n<p><strong>FilterSecurityInterceptor：</strong>负责权限校验的过滤器。</p>\n<p>​\t</p>\n<p>​\t我们可以通过Debug查看当前系统中SpringSecurity过滤器链中有哪些过滤器及它们的顺序。</p>\n<img data-src=\"/2022/10/07/Spring_Family/SpringSecurity/image-20211214145824903.png\" class=\"\">\n\n\n\n\n<h3 id=\"3-2-2-认证流程详解\"><a href=\"#3-2-2-认证流程详解\" class=\"headerlink\" title=\"3.2.2 认证流程详解\"></a>3.2.2 认证流程详解</h3><img data-src=\"/2022/10/07/Spring_Family/SpringSecurity/image-20211214151515385.png\" class=\"\">\n\n\n<p>概念速查:</p>\n<p>Authentication接口: 它的实现类，表示当前访问系统的用户，封装了用户相关信息。</p>\n<p>AuthenticationManager接口：定义了认证Authentication的方法 </p>\n<p>UserDetailsService接口：加载用户特定数据的核心接口。里面定义了一个根据用户名查询用户信息的方法。</p>\n<p>UserDetails接口：提供核心用户信息。通过UserDetailsService根据用户名获取处理的用户信息要封装成UserDetails对象返回。然后将这些信息封装到Authentication对象中。</p>\n<h2 id=\"3-3-实现方式\"><a href=\"#3-3-实现方式\" class=\"headerlink\" title=\"3.3 实现方式\"></a>3.3 实现方式</h2><ul>\n<li>前后端不分离，登录页面由自己提供——3.1(不推荐)</li>\n<li>前后端分离，登录页面由前端提供     ——3.2(推荐，后序我们其他授权和别的操作，均以这个为主)</li>\n</ul>\n<p>在第二部分的基础上，进行操作</p>\n<h3 id=\"3-3-1-前后端不分离\"><a href=\"#3-3-1-前后端不分离\" class=\"headerlink\" title=\"3.3.1 前后端不分离\"></a>3.3.1 前后端不分离</h3><h4 id=\"1-准备工作\"><a href=\"#1-准备工作\" class=\"headerlink\" title=\"1 准备工作\"></a>1 准备工作</h4><h5 id=\"application-yml\"><a href=\"#application-yml\" class=\"headerlink\" title=\"application.yml\"></a>application.yml</h5><pre><code class=\"yaml\">spring:\n  application:\n    name: msb-spring-security\n  datasource:\n    druid:\n      url: jdbc:mysql://localhost:3306/mydb?characterEncoding=utf-8&amp;serverTimezone=UTC\n      username: root\n      password: root\n      driver-class-name: com.mysql.cj.jdbc.Driver\n\nmybatis-plus:\n  mapper-locations: classpath:mapper/*.xml\nlogging:\n  level:\n    com:\n      zjj:\n        mapper: debug\nserver:\n  port: 8081\n</code></pre>\n<h5 id=\"数据库准备\"><a href=\"#数据库准备\" class=\"headerlink\" title=\"数据库准备\"></a>数据库准备</h5><pre><code class=\"sql\">\nSET NAMES utf8mb4;\nSET FOREIGN_KEY_CHECKS = 0;\n\n-- ----------------------------\n-- Table structure for sys_menu\n-- ----------------------------\nDROP TABLE IF EXISTS `sys_menu`;\nCREATE TABLE `sys_menu`  (\n  `id` bigint(20) NOT NULL AUTO_INCREMENT,\n  `menu_name` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL DEFAULT &#39;NULL&#39; COMMENT &#39;菜单名&#39;,\n  `path` varchar(200) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT &#39;路由地址&#39;,\n  `component` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT &#39;组件路径&#39;,\n  `visible` char(1) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT &#39;0&#39; COMMENT &#39;菜单状态（0显示 1隐藏）&#39;,\n  `status` char(1) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT &#39;0&#39; COMMENT &#39;菜单状态（0正常 1停用）&#39;,\n  `perms` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT &#39;权限标识&#39;,\n  `icon` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT &#39;#&#39; COMMENT &#39;菜单图标&#39;,\n  `create_by` bigint(20) NULL DEFAULT NULL,\n  `create_time` datetime NULL DEFAULT NULL,\n  `update_by` bigint(20) NULL DEFAULT NULL,\n  `update_time` datetime NULL DEFAULT NULL,\n  `del_flag` int(11) NULL DEFAULT 0 COMMENT &#39;是否删除（0未删除 1已删除）&#39;,\n  `remark` varchar(500) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT &#39;备注&#39;,\n  PRIMARY KEY (`id`) USING BTREE\n) ENGINE = InnoDB AUTO_INCREMENT = 6 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci COMMENT = &#39;菜单表&#39; ROW_FORMAT = Dynamic;\n\nDROP TABLE IF EXISTS `sys_role`;\nCREATE TABLE `sys_role`  (\n  `id` bigint(20) NOT NULL AUTO_INCREMENT,\n  `name` varchar(128) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,\n  `role_key` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT &#39;角色权限字符串&#39;,\n  `status` char(1) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT &#39;0&#39; COMMENT &#39;角色状态（0正常 1停用）&#39;,\n  `del_flag` int(1) NULL DEFAULT 0 COMMENT &#39;del_flag&#39;,\n  `create_by` bigint(200) NULL DEFAULT NULL,\n  `create_time` datetime NULL DEFAULT NULL,\n  `update_by` bigint(200) NULL DEFAULT NULL,\n  `update_time` datetime NULL DEFAULT NULL,\n  `remark` varchar(500) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT &#39;备注&#39;,\n  PRIMARY KEY (`id`) USING BTREE\n) ENGINE = InnoDB AUTO_INCREMENT = 6 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci COMMENT = &#39;角色表&#39; ROW_FORMAT = Dynamic;\n\nDROP TABLE IF EXISTS `sys_role_menu`;\nCREATE TABLE `sys_role_menu`  (\n  `role_id` bigint(200) NOT NULL AUTO_INCREMENT COMMENT &#39;角色ID&#39;,\n  `menu_id` bigint(200) NOT NULL DEFAULT 0 COMMENT &#39;菜单id&#39;,\n  PRIMARY KEY (`role_id`, `menu_id`) USING BTREE\n) ENGINE = InnoDB AUTO_INCREMENT = 4 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Dynamic;\n\nDROP TABLE IF EXISTS `sys_user`;\nCREATE TABLE `sys_user`  (\n  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT &#39;主键&#39;,\n  `user_name` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL DEFAULT &#39;NULL&#39; COMMENT &#39;用户名&#39;,\n  `nick_name` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL DEFAULT &#39;NULL&#39; COMMENT &#39;昵称&#39;,\n  `password` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL DEFAULT &#39;NULL&#39; COMMENT &#39;密码&#39;,\n  `status` char(1) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT &#39;0&#39; COMMENT &#39;账号状态（0正常 1停用）&#39;,\n  `email` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT &#39;邮箱&#39;,\n  `phonenumber` varchar(32) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT &#39;手机号&#39;,\n  `sex` char(1) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT &#39;用户性别（0男，1女，2未知）&#39;,\n  `avatar` varchar(128) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT &#39;头像&#39;,\n  `user_type` char(1) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL DEFAULT &#39;1&#39; COMMENT &#39;用户类型（0管理员，1普通用户）&#39;,\n  `create_by` bigint(20) NULL DEFAULT NULL COMMENT &#39;创建人的用户id&#39;,\n  `create_time` datetime NULL DEFAULT NULL COMMENT &#39;创建时间&#39;,\n  `update_by` bigint(20) NULL DEFAULT NULL COMMENT &#39;更新人&#39;,\n  `update_time` datetime NULL DEFAULT NULL COMMENT &#39;更新时间&#39;,\n  `del_flag` int(11) NULL DEFAULT 0 COMMENT &#39;删除标志（0代表未删除，1代表已删除）&#39;,\n  PRIMARY KEY (`id`) USING BTREE\n) ENGINE = InnoDB AUTO_INCREMENT = 4 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci COMMENT = &#39;用户表&#39; ROW_FORMAT = Dynamic;\n\n\nDROP TABLE IF EXISTS `sys_user_role`;\nCREATE TABLE `sys_user_role`  (\n  `user_id` bigint(200) NOT NULL AUTO_INCREMENT COMMENT &#39;用户id&#39;,\n  `role_id` bigint(200) NOT NULL DEFAULT 0 COMMENT &#39;角色id&#39;,\n  PRIMARY KEY (`user_id`, `role_id`) USING BTREE\n) ENGINE = InnoDB AUTO_INCREMENT = 4 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Dynamic;\n\n\n\nINSERT INTO `sys_menu` VALUES (2, &#39;demo:select&#39;, NULL, NULL, &#39;0&#39;, &#39;0&#39;, NULL, &#39;#&#39;, NULL, NULL, NULL, NULL, 0, NULL);\nINSERT INTO `sys_menu` VALUES (3, &#39;demo:update&#39;, NULL, NULL, &#39;0&#39;, &#39;0&#39;, NULL, &#39;#&#39;, NULL, NULL, NULL, NULL, 0, NULL);\nINSERT INTO `sys_menu` VALUES (4, &#39;demo:insert&#39;, NULL, NULL, &#39;0&#39;, &#39;0&#39;, NULL, &#39;#&#39;, NULL, NULL, NULL, NULL, 0, NULL);\nINSERT INTO `sys_menu` VALUES (5, &#39;demo:delete&#39;, NULL, NULL, &#39;0&#39;, &#39;0&#39;, NULL, &#39;#&#39;, NULL, NULL, NULL, NULL, 0, NULL);\n\nINSERT INTO `sys_role` VALUES (3, &#39;管理员&#39;, NULL, &#39;0&#39;, 0, NULL, NULL, NULL, NULL, NULL);\nINSERT INTO `sys_role` VALUES (4, &#39;员工&#39;, NULL, &#39;0&#39;, 0, NULL, NULL, NULL, NULL, NULL);\nINSERT INTO `sys_role` VALUES (5, &#39;普通用户&#39;, NULL, &#39;0&#39;, 0, NULL, NULL, NULL, NULL, NULL);\n\nINSERT INTO `sys_role_menu` VALUES (1, 1);\nINSERT INTO `sys_role_menu` VALUES (1, 2);\nINSERT INTO `sys_role_menu` VALUES (1, 3);\nINSERT INTO `sys_role_menu` VALUES (1, 4);\nINSERT INTO `sys_role_menu` VALUES (2, 1);\nINSERT INTO `sys_role_menu` VALUES (2, 4);\nINSERT INTO `sys_role_menu` VALUES (3, 1);\n\nINSERT INTO `sys_user` VALUES (1, &#39;zhangsan&#39;, &#39;zhangsan&#39;, &#39;$2a$10$CFr1dsdBA3XDNrNRtsfX3ezUj/pUVsEhkg6cpKa9QG0oraGBMOZ5u&#39;, &#39;0&#39;, &#39;12@qq.com&#39;, &#39;123&#39;, &#39;1&#39;, NULL, &#39;0&#39;, NULL, &#39;2022-08-03 08:51:48&#39;, NULL, &#39;2022-08-27 08:51:54&#39;, 0);\nINSERT INTO `sys_user` VALUES (2, &#39;lisi&#39;, &#39;lisi&#39;, &#39;$2a$10$GRjbaR73zd9c9tCnj0BnnexqGSbQzXCVrXTPVEiOJqaypwCijbe4O&#39;, &#39;0&#39;, &#39;65.@126.com&#39;, &#39;456&#39;, &#39;0&#39;, NULL, &#39;0&#39;, NULL, &#39;2022-08-19 08:51:51&#39;, NULL, &#39;2022-08-27 08:51:59&#39;, 0);\nINSERT INTO `sys_user` VALUES (3, &#39;wangwu&#39;, &#39;wangwu&#39;, &#39;$2a$10$PsFb4a4bn0A.5pf4Rq5kheKaOkrhJOaz6hlu2WmBnkE8H9wZOoNXS&#39;, &#39;0&#39;, NULL, NULL, NULL, NULL, &#39;1&#39;, NULL, NULL, NULL, NULL, 0);\n\nINSERT INTO `sys_user_role` VALUES (1, 1);\nINSERT INTO `sys_user_role` VALUES (2, 2);\nINSERT INTO `sys_user_role` VALUES (3, 3);\n</code></pre>\n<h5 id=\"实体类1\"><a href=\"#实体类1\" class=\"headerlink\" title=\"实体类1\"></a>实体类1</h5><p>​\t这里目前只提供了登录所需要的User对象，以及我们自己封装的 USerDetails 对象，其余对象自己后续生成。（easycode 、 mybatisX、….都行）</p>\n<pre><code class=\"java\">package com.zjj.pojo;\n\nimport java.util.Date;\nimport com.baomidou.mybatisplus.extension.activerecord.Model;\nimport java.io.Serializable;\nimport lombok.*;\nimport com.baomidou.mybatisplus.annotation.TableName;\nimport com.baomidou.mybatisplus.annotation.TableField;\n\n/**\n * 用户表(User)表实体类\n *\n * @author makejava\n * @since 2022-08-24 21:09:13\n */\n\n@AllArgsConstructor\n@NoArgsConstructor\n@Data\n@ToString\n@TableName(value = &quot;sys_user&quot;)\npublic class User implements Serializable &#123;\n    /**\n    * 主键    \n    */ \n    @TableField(&quot;id&quot;)\n    private Long id;\n    \n    /**\n    * 用户名    \n    */ \n    @TableField(&quot;user_name&quot;)\n    private String username;\n    \n    /**\n    * 昵称    \n    */ \n    @TableField(&quot;nick_name&quot;)\n    private String nickName;\n    \n    /**\n    * 密码    \n    */ \n    @TableField(&quot;password&quot;)\n    private String password;\n    \n    /**\n    * 账号状态（0正常 1停用）    \n    */ \n    @TableField(&quot;status&quot;)\n    private String status;\n    \n    /**\n    * 邮箱    \n    */ \n    @TableField(&quot;email&quot;)\n    private String email;\n    \n    /**\n    * 手机号    \n    */ \n    @TableField(&quot;phonenumber&quot;)\n    private String phonenumber;\n    \n    /**\n    * 用户性别（0男，1女，2未知）    \n    */ \n    @TableField(&quot;sex&quot;)\n    private String sex;\n    \n    /**\n    * 头像    \n    */ \n    @TableField(&quot;avatar&quot;)\n    private String avatar;\n    \n    /**\n    * 用户类型（0管理员，1普通用户）    \n    */ \n    @TableField(&quot;user_type&quot;)\n    private String userType;\n    \n    /**\n    * 创建人的用户id    \n    */ \n    @TableField(&quot;create_by&quot;)\n    private Long createBy;\n    \n    /**\n    * 创建时间    \n    */ \n    @TableField(&quot;create_time&quot;)\n    private Date createTime;\n    \n    /**\n    * 更新人    \n    */ \n    @TableField(&quot;update_by&quot;)\n    private Long updateBy;\n    \n    /**\n    * 更新时间    \n    */ \n    @TableField(&quot;update_time&quot;)\n    private Date updateTime;\n    \n    /**\n    * 删除标志（0代表未删除，1代表已删除）    \n    */ \n    @TableField(&quot;del_flag&quot;)\n    private Integer delFlag;\n    \n\n&#125;\n</code></pre>\n<h5 id=\"实体类2\"><a href=\"#实体类2\" class=\"headerlink\" title=\"实体类2\"></a>实体类2</h5><pre><code class=\"java\">import com.alibaba.fastjson.annotation.JSONField;\nimport lombok.AllArgsConstructor;\nimport lombok.Data;\nimport lombok.NoArgsConstructor;\nimport lombok.ToString;\nimport org.springframework.security.core.GrantedAuthority;\nimport org.springframework.security.core.authority.SimpleGrantedAuthority;\nimport org.springframework.security.core.userdetails.UserDetails;\n\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.stream.Collectors;\n\n@AllArgsConstructor\n@NoArgsConstructor\n@Data\n@ToString\npublic class LoginUser implements UserDetails &#123;\n    private User user;\n\n    private List&lt;String&gt; permission;\n\n    public LoginUser(User user, List&lt;String&gt; permission) &#123;\n        this.user = user;\n        this.permission = permission;\n    &#125;\n\n    @JSONField(serialize = false) //redis存储的话会出现问题，不让他序列化，主要为了安全\n    List&lt;SimpleGrantedAuthority&gt; authorities ;\n    @Override\n    public Collection&lt;? extends GrantedAuthority&gt; getAuthorities() &#123;\n        // 把permission中的String类型的权限信息封装成 SimpleGrantedAuthority 对象\n        if (null != authorities) return authorities;//要是有信息就不用再授权了\n        authorities = permission.stream()\n                .map(SimpleGrantedAuthority::new)\n                .collect(Collectors.toList());\n        return authorities;\n    &#125;\n\n    @Override\n    public String getPassword() &#123;\n        return user.getPassword();\n    &#125;\n\n    @Override\n    public String getUsername() &#123;\n        return user.getUsername();\n    &#125;\n\n    @Override\n    public boolean isAccountNonExpired() &#123;\n        return true;\n    &#125;\n\n    @Override\n    public boolean isAccountNonLocked() &#123;\n        return true;\n    &#125;\n\n    @Override\n    public boolean isCredentialsNonExpired() &#123;\n        return true;\n    &#125;\n\n    @Override\n    public boolean isEnabled() &#123;\n        return true;\n    &#125;\n&#125;\n</code></pre>\n<h4 id=\"2-重写一个登录服务-ServiceImpl\"><a href=\"#2-重写一个登录服务-ServiceImpl\" class=\"headerlink\" title=\"2 重写一个登录服务(ServiceImpl)\"></a>2 重写一个登录服务(ServiceImpl)</h4><p>​\t这里要实现一个实现 UserDetailsService ，重写loadUserByUsername，因为这里是我们认证的地方，在下一个章节我们会具体说明</p>\n<pre><code class=\"java\">package com.zjj.service.impl;\n\nimport com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;\nimport com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;\nimport com.zjj.mapper.UserMapper;\nimport com.zjj.pojo.LoginUser;\nimport com.zjj.pojo.User;\nimport com.zjj.service.UserService;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.security.authentication.AuthenticationManager;\nimport org.springframework.security.authentication.UsernamePasswordAuthenticationToken;\nimport org.springframework.security.core.Authentication;\nimport org.springframework.security.core.userdetails.UserDetails;\nimport org.springframework.security.core.userdetails.UserDetailsService;\nimport org.springframework.security.core.userdetails.UsernameNotFoundException;\nimport org.springframework.stereotype.Service;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Objects;\n\n/**\n * 用户表(User)表服务实现类\n * @author makejava\n * @since 2022-08-24 21:09:13\n */\n@Service(&quot;userService&quot;)\npublic class UserServiceImpl extends ServiceImpl&lt;UserMapper, User&gt;\n        implements UserService, UserDetailsService &#123;\n    @Autowired\n    private UserMapper userMapper;\n\n    @Override\n    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException &#123;\n        LambdaQueryWrapper&lt;User&gt; qw = new LambdaQueryWrapper&lt;&gt;();\n        qw.eq(User::getUsername, username);\n        User user = userMapper.selectOne(qw);\n        if (Objects.isNull(user)) &#123;\n            throw new UsernameNotFoundException(&quot;没有该用户&quot;);\n        &#125;\n\n        // TODO 权限信息后序添加\n        List&lt;String&gt; menus = userMapper.findMenuByUserId(user.getId());\n        List&lt;String&gt; roles = userMapper.findRoleByUserId(user.getId());\n        List&lt;String&gt; res = new ArrayList&lt;&gt;();\n\n        for (String menu : menus) &#123;\n            res.add(menu);\n        &#125;\n        for (String role : roles) &#123;\n            res.add(&quot;ROLE_&quot;+role);\n        &#125;\n        // 用户的权限和角色直接赋值 的话 要注意写法\n        /*\n        1、我们没有user对象直接往回 new UserDetails(username,password,Authorities) 对象时，\n            要注意Authorities手动String转化可以用 AuthorityUtils.commaSeparatedStringToAuthorityList(String str)\n                但是里面的 str里面包含了权限以及角色，每个要用 “,” 间隔，而且角色开头要要拼接 ROLE_\n\n        2、我们自定义了user 实现了 UserDetails 对象 我们重写了 getAuthorities属性，具体看这个类的注释\n            他在初始化值的时候我们传参传递的是一个list对象，这个时候我们不需要用 “，” 间隔，但是角色前要加 ROLE_\n         */\n        return new LoginUser(user,res);\n    &#125;\n&#125;\n</code></pre>\n<h4 id=\"3-重写mapper层和对应的映射文件\"><a href=\"#3-重写mapper层和对应的映射文件\" class=\"headerlink\" title=\"3 重写mapper层和对应的映射文件\"></a>3 重写mapper层和对应的映射文件</h4><pre><code class=\"java\">import com.baomidou.mybatisplus.core.mapper.BaseMapper;\nimport com.zjj.pojo.User;\nimport org.apache.ibatis.annotations.Mapper;\n\nimport java.util.List;\n\n/**\n * 用户表(User)表数据库访问层\n *\n * @author makejava\n * @since 2022-08-24 21:09:13\n */\n\n@Mapper\npublic interface UserMapper extends BaseMapper&lt;User&gt; &#123;\n    public List&lt;String&gt; findMenuByUserId(Long id);\n    public List&lt;String&gt; findRoleByUserId(Long id);\n\n&#125;\n</code></pre>\n<pre><code class=\"xml\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;\n&lt;mapper namespace=&quot;com.zjj.mapper.UserMapper&quot;&gt;\n\n    &lt;sql id=&quot;AllUserColumn&quot;&gt;id , user_name , nick_name , password , status , email , phonenumber , sex , avatar , user_type , create_by , create_time , update_by , update_time , del_flag &lt;/sql&gt;   \n    &lt;resultMap type=&quot;com.zjj.pojo.User&quot; id=&quot;UserMap&quot;&gt;\n        &lt;result property=&quot;id&quot; column=&quot;id&quot; /&gt;\n        &lt;result property=&quot;userName&quot; column=&quot;user_name&quot; /&gt;\n        &lt;result property=&quot;nickName&quot; column=&quot;nick_name&quot; /&gt;\n        &lt;result property=&quot;password&quot; column=&quot;password&quot; /&gt;\n        &lt;result property=&quot;status&quot; column=&quot;status&quot; /&gt;\n        &lt;result property=&quot;email&quot; column=&quot;email&quot; /&gt;\n        &lt;result property=&quot;phonenumber&quot; column=&quot;phonenumber&quot; /&gt;\n        &lt;result property=&quot;sex&quot; column=&quot;sex&quot; /&gt;\n        &lt;result property=&quot;avatar&quot; column=&quot;avatar&quot; /&gt;\n        &lt;result property=&quot;userType&quot; column=&quot;user_type&quot; /&gt;\n        &lt;result property=&quot;createBy&quot; column=&quot;create_by&quot; /&gt;\n        &lt;result property=&quot;createTime&quot; column=&quot;create_time&quot; /&gt;\n        &lt;result property=&quot;updateBy&quot; column=&quot;update_by&quot; /&gt;\n        &lt;result property=&quot;updateTime&quot; column=&quot;update_time&quot; /&gt;\n        &lt;result property=&quot;delFlag&quot; column=&quot;del_flag&quot; /&gt;\n    &lt;/resultMap&gt;\n    &lt;select id=&quot;findMenuByUserId&quot; resultType=&quot;java.lang.String&quot;&gt;\n        SELECT\n            distinct(m.menu_name)\n        FROM\n            sys_user_role ur\n                LEFT JOIN sys_user u on u.id = ur.user_id\n                LEFT JOIN sys_role r ON ur.role_id = r.id\n                LEFT JOIN sys_role_menu rm ON ur.role_id = rm.role_id\n                LEFT JOIN sys_menu m ON m.id = rm.menu_id\n        WHERE\n            u.id = #&#123;args1&#125;\n          AND r.status = 0\n          AND m.status = 0\n    &lt;/select&gt;\n    &lt;select id=&quot;findRoleByUserId&quot; resultType=&quot;java.lang.String&quot;&gt;\n        SELECT\n            distinct(r.name)\n        FROM\n            sys_user_role ur\n                LEFT JOIN sys_user u on u.id = ur.user_id\n                LEFT JOIN sys_role r ON ur.role_id = r.id\n                LEFT JOIN sys_role_menu rm ON ur.role_id = rm.role_id\n                LEFT JOIN sys_menu m ON m.id = rm.menu_id\n        WHERE\n            u.id = #&#123;args1&#125;\n          AND r.status = 0\n          AND m.status = 0\n    &lt;/select&gt;\n    \n\n&lt;/mapper&gt;\n</code></pre>\n<h4 id=\"4-导入我们的登录页面\"><a href=\"#4-导入我们的登录页面\" class=\"headerlink\" title=\"4 导入我们的登录页面\"></a>4 导入我们的登录页面</h4><pre><code class=\"html\">&lt;!DOCTYPE html&gt;\n&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n    &lt;head&gt;\n        &lt;meta charset=&quot;UTF-8&quot;&gt;\n        &lt;title&gt;内容&lt;/title&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n        &lt;form action=&quot;/login&quot; method=&quot;post&quot;&gt;\n            username:&lt;input type=&quot;text&quot; name=&quot;username&quot;/&gt;&lt;br/&gt;\n            password:&lt;input type=&quot;password&quot; name=&quot;password&quot;/&gt;&lt;br/&gt;\n            &lt;input type=&quot;submit&quot; value=&quot;提交&quot;/&gt;\n        &lt;/form&gt;\n\n    &lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<h4 id=\"5-提供登录接口\"><a href=\"#5-提供登录接口\" class=\"headerlink\" title=\"5 提供登录接口\"></a>5 提供登录接口</h4><p>​\t就是一个页面的跳转指定我们的登录页面(&#x3D;&#x3D;要配置的&#x3D;&#x3D;)</p>\n<pre><code class=\"java\">import com.zjj.pojo.User;\nimport com.zjj.service.UserService;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.RequestBody;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.ResponseBody;\n@Controller\npublic class LoginController &#123;\n    @Autowired\n    private UserService userService;\n\n    @RequestMapping(&quot;/demo&quot;)\n    @ResponseBody\n    public String demo() &#123;\n        return &quot;demo&quot;;\n    &#125;\n\n    // 登录页面\n    @RequestMapping(&quot;/showLogin&quot;)\n    public String logint() &#123;\n        System.out.println(&quot;logint invoked&quot;);\n        return &quot;login&quot;;\n    &#125;\n&#125;\n</code></pre>\n<h4 id=\"6-修改配置类\"><a href=\"#6-修改配置类\" class=\"headerlink\" title=\"6 修改配置类\"></a>6 修改配置类</h4><p>​\t主要内容和细节，在formLogin里面，一定仔细查看注释，小细节很多</p>\n<pre><code class=\"java\">import org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.security.authentication.AuthenticationManager;\nimport org.springframework.security.config.annotation.web.builders.HttpSecurity;\nimport org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;\nimport org.springframework.security.config.http.SessionCreationPolicy;\nimport org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;\nimport org.springframework.security.crypto.password.PasswordEncoder;\n\n@Configuration\npublic class MySecurityCore extends WebSecurityConfigurerAdapter &#123;\n    @Bean\n    public PasswordEncoder getPasswordEncoder()&#123;\n        return new BCryptPasswordEncoder();\n    &#125;\n\n    @Override\n    protected void configure(HttpSecurity http) throws Exception &#123;\n\n        // http.formLogin() 所有和表单有关系的\n        http.formLogin()\n                // 登录页面，走一个controller\n                // 注意要和，LoginProcessingUrl 配合使用，不然在表单中的action中 url 失效\n                // 因为只配置loginPage()， 会导致在初始化的时候将loginProcessingUrl的配置相同化，可以自己debug 在AbstractAuthenticationFilterConfigurer 的 updateAuthenticationDefaults 方法\n                // 也就是说loginPage(&quot;/login&quot;)  loginProcessingUrl(&quot;/login&quot;),导致提交信息失败最终导致认证失败\n                .loginPage(&quot;/showLogin&quot;)\n                // 当发现什么URL时，把请求转发给自定义登录逻辑\n                // 表单提交的地址 action ,他就会直接去认证进入到 UserDetailsServiceImpl\n                // 去这里进行用户的验证 和 用户权限信息的集体封装\n                .loginProcessingUrl(&quot;/login&quot;)\n                // 登录成功的操作\n                // 下面两种方法都可以，推荐第二种，两种同时写第一个直接失效\n                // 第一种写法，要注意在写映射的时候要注意请求的方法 get/post\n                .successForwardUrl(&quot;/showMain&quot;)\n                .successHandler((request, response, authentication) -&gt; &#123;\n                    System.out.println(&quot;successHandler invoked&quot;);\n                    // 我们在每次请求同一个页面尽量使用重定向，要是请求转发\n                    // 因为请求转发是浏览器的行为，每次都要请求服务器并且重复提交表单，不好\n                    // response.sendRedirect(&quot;/fail&quot;);\n                    LoginUser loginUser = (LoginUser) authentication.getPrincipal();\n                    for (String s : loginUser.getPermission()) &#123;\n                        System.out.println(s);\n                    &#125;\n                &#125;)\n                // 登录失败的操作\n                // 内容和上述情况相同，只是一个成功的一个失败的\n                .failureForwardUrl(&quot;/fail&quot;)\n                // 当前端表单传递过来的用户名参数、密码参数名和后端不对应，可以利用下列方法\n                // 指定前端传递过来的用户名参数名称，默认 username\n                //.usernameParameter(&quot;MyuserName&quot;)\n                // 指定前端传递过来的密码参数名称，默认 password\n                //.passwordParameter(&quot;MypassWord&quot;)\n        ;\n\n        // http.authorizeRequests() 所有和授权相关\n        http.authorizeRequests()\n                // 这里面支持 正则 和 ant表达式\n                .antMatchers(&quot;/showLogin&quot;).anonymous()\n                .antMatchers(&quot;/js/**&quot;).permitAll()\n                .anyRequest().authenticated();\n\n\n        // http.csrf\n        http.csrf().disable()\n                // 不通过Session获取SecurityContext\n                // 因为我们使用了前后端分离的思想，在session中不存在参数，要用让东西存在它里面，所以不让他生成\n                .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS);\n\n    &#125;\n&#125;\n</code></pre>\n<h4 id=\"7-启动测试\"><a href=\"#7-启动测试\" class=\"headerlink\" title=\"7 启动测试\"></a>7 启动测试</h4><p>这个时候我们的用户名、密码都是我们在数据库中存储的（&#x3D;&#x3D;密码必须使我们提供的加密方式加密之后的&#x3D;&#x3D;）</p>\n<img data-src=\"/2022/10/07/Spring_Family/SpringSecurity/image-20220825114004014.png\" class=\"\">\n\n\n<p>登录是否成功，一方面看是否请求被阻拦</p>\n<img data-src=\"/2022/10/07/Spring_Family/SpringSecurity/image-20220825114855873.png\" class=\"\">\n\n\n<p>另一方面，我在配置中设置了认证成功之后的操作 successHandler(request,response.authentication) 我在里面将我们获得认证的用户权限信息全部打印在了控制台，如果错误了也可同样配置一些信息，具体配置将在后序章节详细总结我们的配置类中的配置，现在主要目的是理清逻辑即可</p>\n<img data-src=\"/2022/10/07/Spring_Family/SpringSecurity/image-20220825114558928.png\" class=\"\">\n\n\n<h4 id=\"8-补充——密码加密\"><a href=\"#8-补充——密码加密\" class=\"headerlink\" title=\"8 补充——密码加密\"></a>8 补充——密码加密</h4><p>实际项目中我们不会把密码明文存储在数据库中。</p>\n<p>​\t默认使用的PasswordEncoder要求数据库中的密码格式为：{id}password 。它会根据id去判断密码的加密方式。但是我们一般不会采用这种方式。所以就需要替换PasswordEncoder。</p>\n<p>​\t我们一般使用SpringSecurity为我们提供的BCryptPasswordEncoder。</p>\n<p>​\t我们只需要使用把BCryptPasswordEncoder对象注入Spring容器中，SpringSecurity就会使用该PasswordEncoder来进行密码校验。</p>\n<p>​\t我们可以定义一个SpringSecurity的配置类，SpringSecurity要求这个配置类要继承WebSecurityConfigurerAdapter。</p>\n<pre><code class=\"java\">@Configuration\npublic class SecurityConfig extends WebSecurityConfigurerAdapter &#123;\n    \n    @Bean\n    public PasswordEncoder passwordEncoder()&#123;\n        return new BCryptPasswordEncoder();\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"3-3-2-前后端分离\"><a href=\"#3-3-2-前后端分离\" class=\"headerlink\" title=\"3.3.2  前后端分离\"></a>3.3.2  前后端分离</h3><h4 id=\"1-准备工作-1\"><a href=\"#1-准备工作-1\" class=\"headerlink\" title=\"1 准备工作\"></a>1 准备工作</h4><p>数据库、实体类均和3.3.1中相同</p>\n<p>application.yml</p>\n<pre><code class=\"yaml\">spring:\n  application:\n    name: spring-security\n  datasource:\n    druid:\n      url: jdbc:mysql://localhost:3306/mydb?characterEncoding=utf-8&amp;serverTimezone=UTC\n      username: root\n      password: root\n      driver-class-name: com.mysql.cj.jdbc.Driver\n  redis:\n    host: localhost\n    port: 6379\nmybatis-plus:\n  mapper-locations: classpath:mapper/*.xml\nlogging:\n  level:\n    com:\n      zjj:\n        mapper: debug\n</code></pre>\n<p>统一返回类</p>\n<pre><code class=\"java\">package com.zjj.common;\n\nimport com.fasterxml.jackson.annotation.JsonInclude;\n\n@JsonInclude(JsonInclude.Include.NON_NULL)\npublic class ResponseResult&lt;T&gt; &#123;\n    /**\n     * 状态码\n     */\n    private Integer code;\n    /**\n     * 提示信息，如果有错误时，前端可以获取该字段进行提示\n     */\n    private String msg;\n    /**\n     * 查询到的结果数据，\n     */\n    private T data;\n\n    public ResponseResult(Integer code, String msg) &#123;\n        this.code = code;\n        this.msg = msg;\n    &#125;\n\n    public ResponseResult(Integer code, T data) &#123;\n        this.code = code;\n        this.data = data;\n    &#125;\n\n    public Integer getCode() &#123;\n        return code;\n    &#125;\n\n    public void setCode(Integer code) &#123;\n        this.code = code;\n    &#125;\n\n    public String getMsg() &#123;\n        return msg;\n    &#125;\n\n    public void setMsg(String msg) &#123;\n        this.msg = msg;\n    &#125;\n\n    public T getData() &#123;\n        return data;\n    &#125;\n\n    public void setData(T data) &#123;\n        this.data = data;\n    &#125;\n\n    public ResponseResult(Integer code, String msg, T data) &#123;\n        this.code = code;\n        this.msg = msg;\n        this.data = data;\n    &#125;\n&#125;\n</code></pre>\n<p>工具类</p>\n<pre><code class=\"java\">import com.alibaba.fastjson.JSON;\nimport com.alibaba.fastjson.serializer.SerializerFeature;\nimport com.fasterxml.jackson.databind.JavaType;\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport com.fasterxml.jackson.databind.type.TypeFactory;\nimport org.springframework.data.redis.serializer.RedisSerializer;\nimport org.springframework.data.redis.serializer.SerializationException;\nimport com.alibaba.fastjson.parser.ParserConfig;\nimport org.springframework.util.Assert;\nimport java.nio.charset.Charset;\n\n/**\n * Redis使用FastJson序列化\n * \n * @author sg\n */\npublic class FastJsonRedisSerializer&lt;T&gt; implements RedisSerializer&lt;T&gt;\n&#123;\n\n    public static final Charset DEFAULT_CHARSET = Charset.forName(&quot;UTF-8&quot;);\n\n    private Class&lt;T&gt; clazz;\n\n    static\n    &#123;\n        ParserConfig.getGlobalInstance().setAutoTypeSupport(true);\n    &#125;\n\n    public FastJsonRedisSerializer(Class&lt;T&gt; clazz)\n    &#123;\n        super();\n        this.clazz = clazz;\n    &#125;\n\n    @Override\n    public byte[] serialize(T t) throws SerializationException\n    &#123;\n        if (t == null)\n        &#123;\n            return new byte[0];\n        &#125;\n        return JSON.toJSONString(t, SerializerFeature.WriteClassName).getBytes(DEFAULT_CHARSET);\n    &#125;\n\n    @Override\n    public T deserialize(byte[] bytes) throws SerializationException\n    &#123;\n        if (bytes == null || bytes.length &lt;= 0)\n        &#123;\n            return null;\n        &#125;\n        String str = new String(bytes, DEFAULT_CHARSET);\n\n        return JSON.parseObject(str, clazz);\n    &#125;\n\n\n    protected JavaType getJavaType(Class&lt;?&gt; clazz)\n    &#123;\n        return TypeFactory.defaultInstance().constructType(clazz);\n    &#125;\n&#125;\n</code></pre>\n<pre><code class=\"java\">package com.zjj.util;\n\nimport io.jsonwebtoken.Claims;\nimport io.jsonwebtoken.JwtBuilder;\nimport io.jsonwebtoken.Jwts;\nimport io.jsonwebtoken.SignatureAlgorithm;\n\nimport javax.crypto.SecretKey;\nimport javax.crypto.spec.SecretKeySpec;\nimport java.util.Base64;\nimport java.util.Date;\nimport java.util.UUID;\n\n/**\n * JWT工具类\n */\npublic class JwtUtil &#123;\n\n    //有效期为\n    public static final Long JWT_TTL = 60 * 60 *1000L;// 60 * 60 *1000  一个小时\n    //设置秘钥明文\n    public static final String JWT_KEY = &quot;sangeng&quot;;\n\n    public static String getUUID()&#123;\n        String token = UUID.randomUUID().toString().replaceAll(&quot;-&quot;, &quot;&quot;);\n        return token;\n    &#125;\n    \n    /**\n     * 生成jtw\n     * @param subject token中要存放的数据（json格式）\n     * @return\n     */\n    public static String createJWT(String subject) &#123;\n        JwtBuilder builder = getJwtBuilder(subject, null, getUUID());// 设置过期时间\n        return builder.compact();\n    &#125;\n\n    /**\n     * 生成jtw\n     * @param subject token中要存放的数据（json格式）\n     * @param ttlMillis token超时时间\n     * @return\n     */\n    public static String createJWT(String subject, Long ttlMillis) &#123;\n        JwtBuilder builder = getJwtBuilder(subject, ttlMillis, getUUID());// 设置过期时间\n        return builder.compact();\n    &#125;\n\n    private static JwtBuilder getJwtBuilder(String subject, Long ttlMillis, String uuid) &#123;\n        SignatureAlgorithm signatureAlgorithm = SignatureAlgorithm.HS256;\n        SecretKey secretKey = generalKey();\n        long nowMillis = System.currentTimeMillis();\n        Date now = new Date(nowMillis);\n        if(ttlMillis==null)&#123;\n            ttlMillis=JwtUtil.JWT_TTL;\n        &#125;\n        long expMillis = nowMillis + ttlMillis;\n        Date expDate = new Date(expMillis);\n        return Jwts.builder()\n                .setId(uuid)              //唯一的ID\n                .setSubject(subject)   // 主题  可以是JSON数据\n                .setIssuer(&quot;sg&quot;)     // 签发者\n                .setIssuedAt(now)      // 签发时间\n                .signWith(signatureAlgorithm, secretKey) //使用HS256对称加密算法签名, 第二个参数为秘钥\n                .setExpiration(expDate);\n    &#125;\n\n    /**\n     * 创建token\n     * @param id\n     * @param subject\n     * @param ttlMillis\n     * @return\n     */\n    public static String createJWT(String id, String subject, Long ttlMillis) &#123;\n        JwtBuilder builder = getJwtBuilder(subject, ttlMillis, id);// 设置过期时间\n        return builder.compact();\n    &#125;\n\n    public static void main(String[] args) throws Exception &#123;\n        String token = &quot;eyJhbGciOiJIUzI1NiJ9.eyJqdGkiOiJjYWM2ZDVhZi1mNjVlLTQ0MDAtYjcxMi0zYWEwOGIyOTIwYjQiLCJzdWIiOiJzZyIsImlzcyI6InNnIiwiaWF0IjoxNjM4MTA2NzEyLCJleHAiOjE2MzgxMTAzMTJ9.JVsSbkP94wuczb4QryQbAke3ysBDIL5ou8fWsbt_ebg&quot;;\n        Claims claims = parseJWT(token);\n        System.out.println(claims);\n    &#125;\n\n    /**\n     * 生成加密后的秘钥 secretKey\n     * @return\n     */\n    public static SecretKey generalKey() &#123;\n        byte[] encodedKey = Base64.getDecoder().decode(JwtUtil.JWT_KEY);\n        SecretKey key = new SecretKeySpec(encodedKey, 0, encodedKey.length, &quot;AES&quot;);\n        return key;\n    &#125;\n    \n    /**\n     * 解析\n     *\n     * @param jwt\n     * @return\n     * @throws Exception\n     */\n    public static Claims parseJWT(String jwt) throws Exception &#123;\n        SecretKey secretKey = generalKey();\n        return Jwts.parser()\n                .setSigningKey(secretKey)\n                .parseClaimsJws(jwt)\n                .getBody();\n    &#125;\n\n\n&#125;\n</code></pre>\n<pre><code class=\"java\">package com.zjj.util;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.data.redis.core.BoundSetOperations;\nimport org.springframework.data.redis.core.HashOperations;\nimport org.springframework.data.redis.core.RedisTemplate;\nimport org.springframework.data.redis.core.ValueOperations;\nimport org.springframework.stereotype.Component;\n\nimport java.util.*;\nimport java.util.concurrent.TimeUnit;\n\n@SuppressWarnings(value = &#123; &quot;unchecked&quot;, &quot;rawtypes&quot; &#125;)\n@Component\npublic class RedisCache\n&#123;\n    @Autowired\n    public RedisTemplate redisTemplate;\n\n    /**\n     * 缓存基本的对象，Integer、String、实体类等\n     *\n     * @param key 缓存的键值\n     * @param value 缓存的值\n     */\n    public &lt;T&gt; void setCacheObject(final String key, final T value)\n    &#123;\n        redisTemplate.opsForValue().set(key, value);\n    &#125;\n\n    /**\n     * 缓存基本的对象，Integer、String、实体类等\n     *\n     * @param key 缓存的键值\n     * @param value 缓存的值\n     * @param timeout 时间\n     * @param timeUnit 时间颗粒度\n     */\n    public &lt;T&gt; void setCacheObject(final String key, final T value, final Integer timeout, final TimeUnit timeUnit)\n    &#123;\n        redisTemplate.opsForValue().set(key, value, timeout, timeUnit);\n    &#125;\n\n    /**\n     * 设置有效时间\n     *\n     * @param key Redis键\n     * @param timeout 超时时间\n     * @return true=设置成功；false=设置失败\n     */\n    public boolean expire(final String key, final long timeout)\n    &#123;\n        return expire(key, timeout, TimeUnit.SECONDS);\n    &#125;\n\n    /**\n     * 设置有效时间\n     *\n     * @param key Redis键\n     * @param timeout 超时时间\n     * @param unit 时间单位\n     * @return true=设置成功；false=设置失败\n     */\n    public boolean expire(final String key, final long timeout, final TimeUnit unit)\n    &#123;\n        return redisTemplate.expire(key, timeout, unit);\n    &#125;\n\n    /**\n     * 获得缓存的基本对象。\n     *\n     * @param key 缓存键值\n     * @return 缓存键值对应的数据\n     */\n    public &lt;T&gt; T getCacheObject(final String key)\n    &#123;\n        ValueOperations&lt;String, T&gt; operation = redisTemplate.opsForValue();\n        return operation.get(key);\n    &#125;\n\n    /**\n     * 删除单个对象\n     *\n     * @param key\n     */\n    public boolean deleteObject(final String key)\n    &#123;\n        return redisTemplate.delete(key);\n    &#125;\n\n    /**\n     * 删除集合对象\n     *\n     * @param collection 多个对象\n     * @return\n     */\n    public long deleteObject(final Collection collection)\n    &#123;\n        return redisTemplate.delete(collection);\n    &#125;\n\n    /**\n     * 缓存List数据\n     *\n     * @param key 缓存的键值\n     * @param dataList 待缓存的List数据\n     * @return 缓存的对象\n     */\n    public &lt;T&gt; long setCacheList(final String key, final List&lt;T&gt; dataList)\n    &#123;\n        Long count = redisTemplate.opsForList().rightPushAll(key, dataList);\n        return count == null ? 0 : count;\n    &#125;\n\n    /**\n     * 获得缓存的list对象\n     *\n     * @param key 缓存的键值\n     * @return 缓存键值对应的数据\n     */\n    public &lt;T&gt; List&lt;T&gt; getCacheList(final String key)\n    &#123;\n        return redisTemplate.opsForList().range(key, 0, -1);\n    &#125;\n\n    /**\n     * 缓存Set\n     *\n     * @param key 缓存键值\n     * @param dataSet 缓存的数据\n     * @return 缓存数据的对象\n     */\n    public &lt;T&gt; BoundSetOperations&lt;String, T&gt; setCacheSet(final String key, final Set&lt;T&gt; dataSet)\n    &#123;\n        BoundSetOperations&lt;String, T&gt; setOperation = redisTemplate.boundSetOps(key);\n        Iterator&lt;T&gt; it = dataSet.iterator();\n        while (it.hasNext())\n        &#123;\n            setOperation.add(it.next());\n        &#125;\n        return setOperation;\n    &#125;\n\n    /**\n     * 获得缓存的set\n     *\n     * @param key\n     * @return\n     */\n    public &lt;T&gt; Set&lt;T&gt; getCacheSet(final String key)\n    &#123;\n        return redisTemplate.opsForSet().members(key);\n    &#125;\n\n    /**\n     * 缓存Map\n     *\n     * @param key\n     * @param dataMap\n     */\n    public &lt;T&gt; void setCacheMap(final String key, final Map&lt;String, T&gt; dataMap)\n    &#123;\n        if (dataMap != null) &#123;\n            redisTemplate.opsForHash().putAll(key, dataMap);\n        &#125;\n    &#125;\n\n    /**\n     * 获得缓存的Map\n     *\n     * @param key\n     * @return\n     */\n    public &lt;T&gt; Map&lt;String, T&gt; getCacheMap(final String key)\n    &#123;\n        return redisTemplate.opsForHash().entries(key);\n    &#125;\n\n    /**\n     * 往Hash中存入数据\n     *\n     * @param key Redis键\n     * @param hKey Hash键\n     * @param value 值\n     */\n    public &lt;T&gt; void setCacheMapValue(final String key, final String hKey, final T value)\n    &#123;\n        redisTemplate.opsForHash().put(key, hKey, value);\n    &#125;\n\n    /**\n     * 获取Hash中的数据\n     *\n     * @param key Redis键\n     * @param hKey Hash键\n     * @return Hash中的对象\n     */\n    public &lt;T&gt; T getCacheMapValue(final String key, final String hKey)\n    &#123;\n        HashOperations&lt;String, String, T&gt; opsForHash = redisTemplate.opsForHash();\n        return opsForHash.get(key, hKey);\n    &#125;\n\n    /**\n     * 删除Hash中的数据\n     * \n     * @param key\n     * @param hkey\n     */\n    public void delCacheMapValue(final String key, final String hkey)\n    &#123;\n        HashOperations hashOperations = redisTemplate.opsForHash();\n        hashOperations.delete(key, hkey);\n    &#125;\n\n    /**\n     * 获取多个Hash中的数据\n     *\n     * @param key Redis键\n     * @param hKeys Hash键集合\n     * @return Hash对象集合\n     */\n    public &lt;T&gt; List&lt;T&gt; getMultiCacheMapValue(final String key, final Collection&lt;Object&gt; hKeys)\n    &#123;\n        return redisTemplate.opsForHash().multiGet(key, hKeys);\n    &#125;\n\n    /**\n     * 获得缓存的基本对象列表\n     *\n     * @param pattern 字符串前缀\n     * @return 对象列表\n     */\n    public Collection&lt;String&gt; keys(final String pattern)\n    &#123;\n        return redisTemplate.keys(pattern);\n    &#125;\n&#125;\n</code></pre>\n<pre><code class=\"java\">package com.zjj.util;\n\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\n\npublic class WebUtils\n&#123;\n    /**\n     * 将字符串渲染到客户端\n     * \n     * @param response 渲染对象\n     * @param string 待渲染的字符串\n     * @return null\n     */\n    public static String renderString(HttpServletResponse response, String string) &#123;\n        try\n        &#123;\n            response.setStatus(200);\n            response.setContentType(&quot;application/json&quot;);\n            response.setCharacterEncoding(&quot;utf-8&quot;);\n            response.getWriter().print(string);\n        &#125;\n        catch (IOException e)\n        &#123;\n            e.printStackTrace();\n        &#125;\n        return null;\n    &#125;\n&#125;\n</code></pre>\n<pre><code class=\"java\">package com.zjj.config;\n\nimport com.zjj.util.FastJsonRedisSerializer;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.data.redis.connection.RedisConnectionFactory;\nimport org.springframework.data.redis.core.RedisTemplate;\nimport org.springframework.data.redis.serializer.StringRedisSerializer;\n\n@Configuration\npublic class RedisConfig &#123;\n\n    @Bean\n    @SuppressWarnings(value = &#123; &quot;unchecked&quot;, &quot;rawtypes&quot; &#125;)\n    public RedisTemplate&lt;Object, Object&gt; redisTemplate(RedisConnectionFactory connectionFactory)\n    &#123;\n        RedisTemplate&lt;Object, Object&gt; template = new RedisTemplate&lt;&gt;();\n        template.setConnectionFactory(connectionFactory);\n\n        FastJsonRedisSerializer serializer = new FastJsonRedisSerializer(Object.class);\n\n        // 使用StringRedisSerializer来序列化和反序列化redis的key值\n        template.setKeySerializer(new StringRedisSerializer());\n        template.setValueSerializer(serializer);\n\n        // Hash的key也采用StringRedisSerializer的序列化方式\n        template.setHashKeySerializer(new StringRedisSerializer());\n        template.setHashValueSerializer(serializer);\n\n        template.afterPropertiesSet();\n        return template;\n    &#125;\n&#125;\n</code></pre>\n<h4 id=\"2-重写登录服务-ServiceImpl\"><a href=\"#2-重写登录服务-ServiceImpl\" class=\"headerlink\" title=\"2  重写登录服务(ServiceImpl)\"></a>2  重写登录服务(ServiceImpl)</h4><p>​\t这里我们需要写一个LoginService 、LoginServiceImpl 以及&#x3D;&#x3D;认证服务&#x3D;&#x3D;  UserDetailServiceImpl (后续会详细解释)</p>\n<pre><code class=\"java\">package com.zjj.service.impl;\n\nimport com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;\nimport com.zjj.mapper.UserMapper;\nimport com.zjj.pojo.LoginUser;\nimport com.zjj.pojo.User;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.security.core.userdetails.UserDetails;\nimport org.springframework.security.core.userdetails.UserDetailsService;\nimport org.springframework.security.core.userdetails.UsernameNotFoundException;\nimport org.springframework.stereotype.Service;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Objects;\n\n@Service\npublic class UserDetailServiceImpl implements UserDetailsService &#123;\n    @Autowired\n    private UserMapper userMapper;\n\n    @Override\n    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException &#123;\n        LambdaQueryWrapper&lt;User&gt; qw = new LambdaQueryWrapper&lt;&gt;();\n        qw.eq(User::getUserName, username);\n        User user = userMapper.selectOne(qw);\n        if (Objects.isNull(user)) &#123;\n            throw new UsernameNotFoundException(&quot;没有该用户&quot;);\n        &#125;\n\n        // TODO 权限信息后序添加\n        List&lt;String&gt; menus = userMapper.findMenuByUserId(user.getId());\n        List&lt;String&gt; roles = userMapper.findRoleByUserId(user.getId());\n        List&lt;String&gt; res = new ArrayList&lt;&gt;();\n\n        \n        for (String menu : menus) &#123;\n            res.add(menu);\n        &#125;\n        for (String role : roles) &#123;\n            res.add(&quot;ROLE_&quot;+role);\n        &#125;\n        // 用户的权限和角色直接赋值 的话 要注意写法\n        /*\n        1、我们没有user对象直接往回 new UserDetails(username,password,Authorities) 对象时，\n            要注意Authorities手动String转化可以用 AuthorityUtils.commaSeparatedStringToAuthorityList(String str)\n                但是里面的 str里面包含了权限以及角色，每个要用 “,” 间隔，而且角色开头要要拼接 ROLE_\n\n        2、我们自定义了user 实现了 UserDetails 对象 我们重写了 getAuthorities属性，具体看这个类的注释\n            他在初始化值的时候我们传参传递的是一个list对象，这个时候我们不需要用 “，” 间隔，但是角色前要加 ROLE_\n         */\n        return new LoginUser(user,res);\n    &#125;\n&#125;\n</code></pre>\n<pre><code class=\"java\">public interface LoginService &#123;\n    public ResponseResult login(User user);\n\n    ResponseResult logout();\n&#125;\n</code></pre>\n<pre><code class=\"java\">import com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;\nimport com.zjj.mapper.UserMapper;\nimport com.zjj.pojo.LoginUser;\nimport com.zjj.pojo.User;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.security.core.userdetails.UserDetails;\nimport org.springframework.security.core.userdetails.UserDetailsService;\nimport org.springframework.security.core.userdetails.UsernameNotFoundException;\nimport org.springframework.stereotype.Service;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Objects;\n\n@Service\npublic class UserDetailServiceImpl implements UserDetailsService &#123;\n    @Autowired\n    private UserMapper userMapper;\n\n    @Override\n    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException &#123;\n        LambdaQueryWrapper&lt;User&gt; qw = new LambdaQueryWrapper&lt;&gt;();\n        qw.eq(User::getUserName, username);\n        User user = userMapper.selectOne(qw);\n        if (Objects.isNull(user)) &#123;\n            throw new UsernameNotFoundException(&quot;没有该用户&quot;);\n        &#125;\n\n        // TODO 权限信息后序添加\n        List&lt;String&gt; menus = userMapper.findMenuByUserId(user.getId());\n        List&lt;String&gt; roles = userMapper.findRoleByUserId(user.getId());\n        List&lt;String&gt; res = new ArrayList&lt;&gt;();\n\n        for (String menu : menus) &#123;\n            res.add(menu);\n        &#125;\n        for (String role : roles) &#123;\n            res.add(&quot;ROLE_&quot;+role);\n        &#125;\n        // 用户的权限和角色直接赋值 的话 要注意写法\n        /*\n        1、我们没有user对象直接往回 new UserDetails(username,password,Authorities) 对象时，\n            要注意Authorities手动String转化可以用 AuthorityUtils.commaSeparatedStringToAuthorityList(String str)\n                但是里面的 str里面包含了权限以及角色，每个要用 “,” 间隔，而且角色开头要要拼接 ROLE_\n\n        2、我们自定义了user 实现了 UserDetails 对象 我们重写了 getAuthorities属性，具体看这个类的注释\n            他在初始化值的时候我们传参传递的是一个list对象，这个时候我们不需要用 “，” 间隔，但是角色前要加 ROLE_\n         */\n        return new LoginUser(user,res);\n    &#125;\n&#125;\n</code></pre>\n<h4 id=\"3-重写mapper层和对应的映射文件-1\"><a href=\"#3-重写mapper层和对应的映射文件-1\" class=\"headerlink\" title=\"3 重写mapper层和对应的映射文件\"></a>3 重写mapper层和对应的映射文件</h4><p>和3.3.1的准备相同</p>\n<h4 id=\"4-配置类配置\"><a href=\"#4-配置类配置\" class=\"headerlink\" title=\"4 配置类配置\"></a>4 配置类配置</h4><pre><code class=\"java\">@Configuration\npublic class SecurityConfig extends WebSecurityConfigurerAdapter &#123;\n\n\n    @Bean\n    public PasswordEncoder passwordEncoder()&#123;\n        return new BCryptPasswordEncoder();\n    &#125;\n\n    @Override\n    protected void configure(HttpSecurity http) throws Exception &#123;\n        http\n                //关闭csrf\n                .csrf().disable()\n                //不通过Session获取SecurityContext\n                .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)\n                .and()\n                .authorizeRequests()\n                // 对于登录接口 允许匿名访问\n                .antMatchers(&quot;/user/login&quot;).anonymous()\n                // 除上面外的所有请求全部需要鉴权认证\n                .anyRequest().authenticated();\n    &#125;\n\n    @Bean\n    @Override\n    public AuthenticationManager authenticationManagerBean() throws Exception &#123;\n        return super.authenticationManagerBean();\n    &#125;\n&#125;\n</code></pre>\n<h4 id=\"5-对接登录接口\"><a href=\"#5-对接登录接口\" class=\"headerlink\" title=\"5 对接登录接口\"></a>5 对接登录接口</h4><p>假定登录接口为\t“&#x2F;user&#x2F;login”</p>\n<pre><code class=\"java\">@Controller\npublic class LoginController &#123;\n\n    @Autowired\n    private LoginService loginService;\n\n    @RequestMapping(&quot;/user/login&quot;)\n    @ResponseBody\n    public ResponseResult login(@RequestBody User user)&#123;\n        return loginService.login(user);\n    &#125;\n    @RequestMapping(&quot;/user/logout&quot;)\n    @ResponseBody\n    public ResponseResult logout() &#123;\n        return loginService.logout();\n    &#125;\n&#125;\n</code></pre>\n<p>5 测试接口</p>\n<p>这里用接口测试工具即可，我们没有登录页面，页面是前端提供的，所以我们只需要确保接口测试正确即可</p>\n<p><span class=\"exturl\" data-url=\"aHR0cDovL2xvY2FsaG9zdDo4MDgwL3VzZXIvbG9naW4=\">http://localhost:8080/user/login</span></p>\n<pre><code class=\"json\">&#123;\n    &quot;userName&quot;:&quot;zhangsan&quot;,\n    &quot;password&quot;:&quot;zhangsan&quot;\n    // &quot;userName&quot;:&quot;lisi&quot;,\n    // &quot;password&quot;:&quot;lisi&quot;\n    // &quot;userName&quot;:&quot;wangwu&quot;,\n    // &quot;password&quot;:&quot;wangwu&quot;\n&#125;\n</code></pre>\n<img data-src=\"/2022/10/07/Spring_Family/SpringSecurity/image-20220825120818298.png\" class=\"\">\n\n\n<h4 id=\"6-优化认证——引入Redis\"><a href=\"#6-优化认证——引入Redis\" class=\"headerlink\" title=\"6 优化认证——引入Redis\"></a>6 优化认证——引入Redis</h4><p>​\t我们在项目中，不可能每次这种常用数据都去数据库访问，这样会给数据库造成极大的负担，导致我们的数据库宕机。因此我们引入的NoSQL数据库、缓存数据库 Redis 用来存储我们短期常用数据。但是问题又来了。怎么存储呢？</p>\n<p>​\t引入 3.2.1SpringSecurity完整流程 </p>\n<img data-src=\"/2022/10/07/Spring_Family/SpringSecurity/image-20211214144425527.png\" class=\"\">\n\n\n<p>​\t我们每次的登录验证都需要经过 UsernamePasswordAuthenticationFilter ，在这个过滤器下我们必须得到一个认证的用户，所以我们在这里为了得到用户的认证信息我们老办法就是去数据库中查找，但是我们现在不想让他老去数据库中找，在他之前我们要是直接能得到这个认证过的用户岂不皆大欢喜，所以我们在他之前也加上一个过滤器用来查找每次请求是否有这个认证用户有的话我们就可以省略掉去数据库中查找他的信息的过程。</p>\n<p>​\t那么问题又来了我们如何存储一个用户的信息呢？</p>\n<p>这里我们可以利用JWT根据我们的用户ID生成一个Token，以他为键值存储到redis中</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA3MDE3NS9hcnRpY2xlL2RldGFpbHMvMTE4NTU5Mjcy\">JWT详解</span> ：除了讲解JWT，还很好的帮忙回顾了Token的优势</p>\n<pre><code class=\"java\">package com.zjj.filter;\n\nimport com.zjj.pojo.LoginUser;\nimport com.zjj.util.JwtUtil;\nimport com.zjj.util.RedisCache;\nimport io.jsonwebtoken.Claims;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.security.authentication.UsernamePasswordAuthenticationToken;\nimport org.springframework.security.core.context.SecurityContextHolder;\nimport org.springframework.stereotype.Component;\nimport org.springframework.util.StringUtils;\nimport org.springframework.web.filter.OncePerRequestFilter;\n\nimport javax.servlet.FilterChain;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport java.util.Objects;\n\n@Component\npublic class JwtAuthenticationTokenFilter extends OncePerRequestFilter &#123;\n\n    @Autowired\n    private RedisCache redisCache;\n\n    @Override\n    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException &#123;\n        //获取token\n        String token = request.getHeader(&quot;token&quot;);\n        if (!StringUtils.hasText(token)) &#123;\n            //放行\n            /*\n            * 解释一下，为什么没有Token还放行，因为没有token可以但是可能他是登录请求\n            * 我们还是要放行的，不然所有人都登录不了，但是问题是如果不是为什么还要放行\n            * 这里不用担心，如果不是登录请求他就可能会存在User对象的账户和密码，就无法完成第一步的认证工作，跟别说后面的鉴权了，所以他会直接被挡住\n            * 其次我们倒数第二个过滤器就是为我们处理我们出现的问题的过滤器，出了问题让他解决就行了，这里的问题其实大多数都是token错误，需要重新认证\n            * */\n            filterChain.doFilter(request, response);\n            return;\n        &#125;\n        //解析token\n        String userid;\n        try &#123;\n            Claims claims = JwtUtil.parseJWT(token);\n            userid = claims.getSubject();\n        &#125; catch (Exception e) &#123;\n            e.printStackTrace();\n            throw new RuntimeException(&quot;token非法&quot;);\n        &#125;\n        //从redis中获取用户信息\n        String redisKey = &quot;login:&quot; + userid;\n        LoginUser loginUser = redisCache.getCacheObject(redisKey);\n        if(Objects.isNull(loginUser))&#123;\n            throw new RuntimeException(&quot;用户未登录&quot;);\n        &#125;\n        //存入SecurityContextHolder ——&gt; 认证成功的对象都在这\n        //TODO 获取权限信息封装到Authentication中\n        /*\n        * 三参构造可以获取该对象是否是以认证状态\n        *  */\n        UsernamePasswordAuthenticationToken authenticationToken =\n                new UsernamePasswordAuthenticationToken(loginUser,null,loginUser.getAuthorities());\n        SecurityContextHolder.getContext().setAuthentication(authenticationToken);\n        //放行\n        filterChain.doFilter(request, response);\n    &#125;\n&#125;\n</code></pre>\n<h4 id=\"7-修改配置类\"><a href=\"#7-修改配置类\" class=\"headerlink\" title=\"7 修改配置类\"></a>7 修改配置类</h4><pre><code class=\"java\">package com.zjj.config;\n\nimport com.zjj.filter.JwtAuthenticationTokenFilter;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.security.authentication.AuthenticationManager;\nimport org.springframework.security.config.annotation.web.builders.HttpSecurity;\nimport org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;\nimport org.springframework.security.config.http.SessionCreationPolicy;\nimport org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;\nimport org.springframework.security.crypto.password.PasswordEncoder;\nimport org.springframework.security.web.AuthenticationEntryPoint;\nimport org.springframework.security.web.access.AccessDeniedHandler;\nimport org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;\n\n\n@Configuration\npublic class SpringSecurityConfig extends WebSecurityConfigurerAdapter &#123;\n\n    @Autowired\n    private JwtAuthenticationTokenFilter jwtAuthenticationTokenFilter;\n    @Autowired\n    private AuthenticationEntryPoint authenticationEntryPoint;\n    @Autowired\n    private AccessDeniedHandler accessDeniedHandler;\n\n    @Override\n    protected void configure(HttpSecurity http) throws Exception &#123;\n\n        // 认证、授权错误处理\n        http.exceptionHandling()\n                .authenticationEntryPoint(authenticationEntryPoint)\n                .accessDeniedHandler(accessDeniedHandler);\n        // 认证过滤器添加\n        http.addFilterBefore(jwtAuthenticationTokenFilter, UsernamePasswordAuthenticationFilter.class);\n\n        // url拦截\n        http.authorizeRequests()\n                // anonymous 匿名 没有认证的才可以访问，permitALL 谁都能访问，不需要认证\n                .antMatchers(&quot;/user/login&quot;,&quot;/login&quot;,&quot;/loginPage&quot;).anonymous()\n                .antMatchers(&quot;/login.html&quot;,&quot;/fail.html&quot;).permitAll()\n                // authenticated 认证了才能访问\n                .anyRequest().authenticated();\n\n        //关闭CSRF\n        http.csrf().disable()\n                // 不通过Session获取SecurityContext\n                .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS);\n        // Cors\n        http.cors();\n    &#125;\n\n    @Bean\n    @Override\n    public AuthenticationManager authenticationManagerBean() throws Exception &#123;\n        return super.authenticationManagerBean();\n    &#125;\n\n\n    @Bean\n    public PasswordEncoder getPasswordEncoder()&#123;\n        return new BCryptPasswordEncoder();\n    &#125;\n&#125;\n</code></pre>\n<h4 id=\"8-测试\"><a href=\"#8-测试\" class=\"headerlink\" title=\"8 测试\"></a>8 测试</h4><p>这里要打开你的 redis服务端 ，如果不是本地的，你要去配置中添加配置</p>\n<p>最后根据 步骤5 再次测试，成功后你的redis 中会多出一组数据，这就是我们的Token，具体步骤不再演示！</p>\n<h1 id=\"四、UserDetailsService详解\"><a href=\"#四、UserDetailsService详解\" class=\"headerlink\" title=\"四、UserDetailsService详解\"></a>四、UserDetailsService详解</h1><p>​\t当什么也没有配置的时候，账号和密码是由Spring Security定义生成的。而在实际项目中账号和密码都是从数据库中查询出来的。 所以我们要通过自定义逻辑控制**&#x3D;&#x3D;认证逻辑&#x3D;&#x3D;**。</p>\n<img data-src=\"/2022/10/07/Spring_Family/SpringSecurity/image-20211214151515385.png\" class=\"\">\n\n\n<p>​\t如果需要自定义逻辑时，只需要实现UserDetailsService接口即可。接口定义如下：</p>\n<img data-src=\"/2022/10/07/Spring_Family/SpringSecurity/springSecurity-03.jpg\" class=\"\">\n\n\n<h2 id=\"1-返回值\"><a href=\"#1-返回值\" class=\"headerlink\" title=\"1.返回值\"></a>1.返回值</h2><p>​\t返回值UserDetails是一个接口，定义如下</p>\n<img data-src=\"/2022/10/07/Spring_Family/SpringSecurity/springSecurity-04.jpg\" class=\"\">\n\n\n<p>​\t要想返回UserDetails的实例就只能返回接口的实现类。Spring Security中提供了如下的实例。对于我们只需要使用里面的User类即可。注意User的全限定路径是：</p>\n<p>​\torg.springframework.security.core.userdetails.User</p>\n<p>​\t此处经常和系统中自己开发的User类弄混。</p>\n<img data-src=\"/2022/10/07/Spring_Family/SpringSecurity/springSecurity-05.jpg\" class=\"\">\n\n\n<p>​\t在User类中提供了很多方法和属性。</p>\n<img data-src=\"/2022/10/07/Spring_Family/SpringSecurity/springSecurity-06.jpg\" class=\"\">\n\n\n<p>​\t其中构造方法有两个，调用其中任何一个都可以实例化UserDetails实现类User类的实例。而三个参数的构造方法实际上也是调用7个参数的构造方法。</p>\n<p>​\tusername:用户名</p>\n<p>​\tpassword:密码</p>\n<p>​\tauthorities：用户具有的权限。此处不允许为null</p>\n<img data-src=\"/2022/10/07/Spring_Family/SpringSecurity/springSecurity-07.jpg\" class=\"\">\n\n\n<p>​\t此处的用户名应该是客户端传递过来的用户名。而密码应该是从数据库中查询出来的密码。Spring Security会根据User中的password和客户端传递过来的password进行比较。如果相同则表示认证通过，如果不相同表示认证失败。</p>\n<p>​\tauthorities里面的权限对于后面学习授权是很有必要的，包含的所有内容为此用户具有的权限，如有里面没有包含某个权限，而在做某个事情时必须包含某个权限则会出现403。&#x3D;&#x3D;通常都是通过AuthorityUtils.commaSeparatedStringToAuthorityList(“”)来创建authorities集合对象的&#x3D;&#x3D;。参数是一个字符串，&#x3D;&#x3D;多个权限使用逗号分隔，角色信息前要加<font color=blue>  ROLE_  </font>来标识不然会当成权限信息处理&#x3D;&#x3D;。</p>\n<p><strong>建议</strong></p>\n<blockquote>\n<p>​\t我们的项目中对于用户信息的表，肯定是不同的，我们可以利用这个类，对于用来认证的UserDetails对象进行进一步封装，自定义我们的认证对象。例如：</p>\n<pre><code class=\"java\">package com.zjj.pojo;\n\nimport com.alibaba.fastjson.annotation.JSONField;\nimport lombok.AllArgsConstructor;\nimport lombok.Data;\nimport lombok.NoArgsConstructor;\nimport lombok.ToString;\nimport org.springframework.security.core.GrantedAuthority;\nimport org.springframework.security.core.authority.SimpleGrantedAuthority;\nimport org.springframework.security.core.userdetails.UserDetails;\n\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.stream.Collectors;\n\n@AllArgsConstructor\n@NoArgsConstructor\n@Data\n@ToString\npublic class LoginUser implements UserDetails &#123;\n    private User user;\n\n    private List&lt;String&gt; permission;\n\n    public LoginUser(User user, List&lt;String&gt; permission) &#123;\n        this.user = user;\n        this.permission = permission;\n    &#125;\n\n    @JSONField(serialize = false) //redis存储的话会出现问题，不让他序列化，主要为了安全\n    List&lt;SimpleGrantedAuthority&gt; authorities ;\n    @Override\n    public Collection&lt;? extends GrantedAuthority&gt; getAuthorities() &#123;\n        // 把permission中的String类型的权限信息封装成 SimpleGrantedAuthority 对象\n        if (null != authorities) return authorities;//要是有信息就不用再授权了\n        authorities = permission.stream()\n                .map(SimpleGrantedAuthority::new)\n                .collect(Collectors.toList());\n        return authorities;\n    &#125;\n\n    @Override\n    public String getPassword() &#123;\n        return user.getPassword();\n    &#125;\n\n    @Override\n    public String getUsername() &#123;\n        return user.getUsername();\n    &#125;\n\n    @Override\n    public boolean isAccountNonExpired() &#123;\n        return true;\n    &#125;\n\n    @Override\n    public boolean isAccountNonLocked() &#123;\n        return true;\n    &#125;\n\n    @Override\n    public boolean isCredentialsNonExpired() &#123;\n        return true;\n    &#125;\n\n    @Override\n    public boolean isEnabled() &#123;\n        return true;\n    &#125;\n&#125;\n</code></pre>\n<p>​\t这里只是一个例子，我重写了getAuthorities() ，其他的信息我们可以根据我们自己的数据库的User信息进行初始化，这里我为了测试方便其余都事 TRUE 打开了他们的权限</p>\n<p>​\t这里我自定义个 permission 用来存储我们查询到的权限信息，用它来对authorities来初始化 以及对getAuthorities() 的重写，authorities 是我们根据SpringSecurity 要求封装的权限集合 ，但是要注意，不要让他存储到redis中，redis存储的话会出现问题，不要让他序列化，主要为了安全。</p>\n<p>​\t这样我们每次认证的时候就直接可以利用这个认证对象，而我们的原生User还可以进行别的操作，这样做更加灵活。&#x3D;&#x3D;推荐********&#x3D;&#x3D;</p>\n</blockquote>\n<h2 id=\"2-方法参数\"><a href=\"#2-方法参数\" class=\"headerlink\" title=\"2.方法参数\"></a>2.方法参数</h2><p>​\t方法参数表示用户名。此值是客户端表单传递过来的数据。默认情况下必须叫username，否则无法接收。</p>\n<h2 id=\"3-异常\"><a href=\"#3-异常\" class=\"headerlink\" title=\"3.异常\"></a>3.异常</h2><p>​\tUsernameNotFoundException 用户名没有发现异常。在loadUserByUsername中是需要通过自己的逻辑从数据库中取值的。如果通过用户名没有查询到对应的数据，应该抛出UsernameNotFoundException，系统就知道用户名没有查询到。</p>\n<h1 id=\"五、配置类说明-1-—-认证配置\"><a href=\"#五、配置类说明-1-—-认证配置\" class=\"headerlink\" title=\"五、配置类说明 1 — 认证配置\"></a>五、配置类说明 1 — 认证配置</h1><h2 id=\"1-失败跳转\"><a href=\"#1-失败跳转\" class=\"headerlink\" title=\"1.失败跳转\"></a>1.失败跳转</h2><p>​\t表单处理中成功会跳转到一个地址，失败也可以跳转到一个地址中。</p>\n<h3 id=\"1-1编写页面\"><a href=\"#1-1编写页面\" class=\"headerlink\" title=\"1.1编写页面\"></a>1.1编写页面</h3><p>​\t在src&#x2F;main&#x2F;resources&#x2F;static下新建fail.html并编写如下内容</p>\n<pre><code class=\"html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n    &lt;head&gt;\n        &lt;meta charset=&quot;UTF-8&quot;&gt;\n        &lt;title&gt;Title&lt;/title&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n        操作失败，请重新登录. &lt;a href=&quot;/login.html&quot;&gt;跳转&lt;/a&gt;\n    &lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<h3 id=\"1-2修改表单配置\"><a href=\"#1-2修改表单配置\" class=\"headerlink\" title=\"1.2修改表单配置\"></a>1.2修改表单配置</h3><p>​\t在配置方法中表单认证部分添加failureForwardUrl()方法，表示登录失败跳转的url。此处依然是POST请求，所以跳转到可以接收POST请求的控制器&#x2F;fail中。</p>\n<pre><code class=\"java\">// 表单认证\nhttp.formLogin()\n    .loginProcessingUrl(&quot;/login&quot;)   //当发现/login时认为是登录，需要执行UserDetailsServiceImpl\n    .successForwardUrl(&quot;/toMain&quot;)   //此处是post请求\n    .failureForwardUrl(&quot;/fail&quot;)     //登录失败跳转地址\n    .loginPage(&quot;/login.html&quot;);\n</code></pre>\n<h3 id=\"1-3添加控制器方法\"><a href=\"#1-3添加控制器方法\" class=\"headerlink\" title=\"1.3添加控制器方法\"></a>1.3添加控制器方法</h3><p>​\t在控制器类中添加控制器方法，方法映射路径&#x2F;fail。此处要注意：由于是POST请求访问&#x2F;fail。所以如果返回值直接转发到fail.html中，及时有效果，控制台也会报警告，提示fail.html不支持POST访问方式。</p>\n<pre><code class=\"java\">@PostMapping(&quot;/fail&quot;)\npublic String fail()&#123;\n    return &quot;redirect:/fail.html&quot;;\n&#125;\n</code></pre>\n<h3 id=\"1-4设置fail-html不需要认证\"><a href=\"#1-4设置fail-html不需要认证\" class=\"headerlink\" title=\"1.4设置fail.html不需要认证\"></a>1.4设置fail.html不需要认证</h3><p>​\t认证失败跳转到fail.html页面中，所以必须配置fail.html不需要被认证。需要修改配置类中内容</p>\n<pre><code class=\"java\">// url 拦截\nhttp.authorizeRequests()\n        .antMatchers(&quot;/login.html&quot;).permitAll() //login.html不需要被认证\n        .antMatchers(&quot;/fail.html&quot;).permitAll()  //fail.html不需要被认证\n        .anyRequest().authenticated();//所有的请求都必须被认证。必须登录后才能访问。\n</code></pre>\n<h2 id=\"2-设置请求账户和密码的参数名\"><a href=\"#2-设置请求账户和密码的参数名\" class=\"headerlink\" title=\"2.设置请求账户和密码的参数名\"></a>2.设置请求账户和密码的参数名</h2><h3 id=\"2-1源码简介\"><a href=\"#2-1源码简介\" class=\"headerlink\" title=\"2.1源码简介\"></a>2.1源码简介</h3><p>​\t当进行登录时会执行UsernamePasswordAuthenticationFilter过滤器。</p>\n<p>​\tusernamePasrameter:账户参数名</p>\n<p>​\tpasswordParameter:密码参数名</p>\n<p>​\tpostOnly&#x3D;true:默认情况下只允许POST请求。</p>\n<img data-src=\"/2022/10/07/Spring_Family/SpringSecurity/springSecurity-10-1661413396371.jpg\" class=\"\">\n\n\n<h3 id=\"2-2修改配置\"><a href=\"#2-2修改配置\" class=\"headerlink\" title=\"2.2修改配置\"></a>2.2修改配置</h3><pre><code class=\"java\">// 表单认证\nhttp.formLogin()\n        .loginProcessingUrl(&quot;/login&quot;)   //当发现/login时认为是登录，需要执行UserDetailsServiceImpl\n        .successForwardUrl(&quot;/toMain&quot;)   //此处是post请求\n        .failureForwardUrl(&quot;/fail&quot;)     //登录失败跳转地址\n        .loginPage(&quot;/login.html&quot;)\n        .usernameParameter(&quot;myusername&quot;)\n        .passwordParameter(&quot;mypassword&quot;);\n</code></pre>\n<h3 id=\"2-3修改页面\"><a href=\"#2-3修改页面\" class=\"headerlink\" title=\"2.3修改页面\"></a>2.3修改页面</h3><p>​\t修改login.html</p>\n<pre><code class=\"html\">&lt;form action = &quot;/login&quot; method=&quot;post&quot;&gt;\n    用户名：&lt;input type=&quot;text&quot; name=&quot;myusername&quot;/&gt;&lt;br/&gt;\n    密码:&lt;input type=&quot;password&quot; name=&quot;mypassword&quot;/&gt;&lt;br/&gt;\n    &lt;input type=&quot;submit&quot; value=&quot;登录&quot;/&gt;\n&lt;/form&gt;\n</code></pre>\n<h2 id=\"3-自定义登录成功处理器\"><a href=\"#3-自定义登录成功处理器\" class=\"headerlink\" title=\"3.自定义登录成功处理器\"></a>3.自定义登录成功处理器</h2><h3 id=\"3-1源码分析\"><a href=\"#3-1源码分析\" class=\"headerlink\" title=\"3.1源码分析\"></a>3.1源码分析</h3><p>​\t使用successForwardUrl()时表示成功后转发请求到地址。内部是通过successHandler（）方法进行控制成功后交给哪个类进行处理</p>\n<img data-src=\"/2022/10/07/Spring_Family/SpringSecurity/springSecurity-11-1661413396370.jpg\" class=\"\">\n\n\n<p>​\tForwardAuthenticationSuccessHandler内部就是最简单的请求转发。由于是请求转发，当遇到需要跳转到站外或在前后端分离的项目中就无法使用了。</p>\n<img data-src=\"/2022/10/07/Spring_Family/SpringSecurity/springSecurity-12-1661413396371.jpg\" class=\"\">\n\n\n<p>​\t当需要控制登录成功后去做一些事情时，可以进行自定义认证成功控制器。</p>\n<h3 id=\"3-2代码实现\"><a href=\"#3-2代码实现\" class=\"headerlink\" title=\"3.2代码实现\"></a>3.2代码实现</h3><h4 id=\"3-2-1自定义类\"><a href=\"#3-2-1自定义类\" class=\"headerlink\" title=\"3.2.1自定义类\"></a>3.2.1自定义类</h4><p>​\t新建类MyAuthenticationSuccessHandler 实现 AuthenticationSuccessHandler ，编写如下：</p>\n<pre><code class=\"java\">public class MyAuthenticationSuccessHandler implements AuthenticationSuccessHandler &#123;\n    @Override\n    public void onAuthenticationSuccess(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Authentication authentication) throws IOException, ServletException &#123;\n        //Principal 主体，存放了登录用户的信息\n        User user = (User)authentication.getPrincipal();\n        System.out.println(user.getUsername());\n        System.out.println(user.getPassword());//密码输出为null\n        System.out.println(user.getAuthorities());\n        //重定向到百度。这只是一个示例，具体需要看项目业务需求\n        httpServletResponse.sendRedirect(&quot;http://www.baidu.com&quot;);\n    &#125;\n&#125;\n</code></pre>\n<h4 id=\"3-2-2修改配置项\"><a href=\"#3-2-2修改配置项\" class=\"headerlink\" title=\"3.2.2修改配置项\"></a>3.2.2修改配置项</h4><p>使用successHandler()方法设置成功后交给哪个对象进行处理</p>\n<pre><code class=\"java\">// 表单认证\nhttp.formLogin()\n        .loginProcessingUrl(&quot;/login&quot;)   //当发现/login时认为是登录，需要执行UserDetailsServiceImpl\n        .successHandler(new MyAuthenticationSuccessHandler())\n        //.successForwardUrl(&quot;/toMain&quot;)   //此处是post请求\n        .failureForwardUrl(&quot;/fail&quot;)     //登录失败跳转地址\n        .loginPage(&quot;/login.html&quot;);\n</code></pre>\n<h2 id=\"4-自定义登录失败处理器\"><a href=\"#4-自定义登录失败处理器\" class=\"headerlink\" title=\"4.自定义登录失败处理器\"></a>4.自定义登录失败处理器</h2><h3 id=\"4-1源码分析\"><a href=\"#4-1源码分析\" class=\"headerlink\" title=\"4.1源码分析\"></a>4.1源码分析</h3><p>​\tfailureForwardUrl()内部调用的是failureHandler()方法</p>\n<p>​\t<strong>ForwardAuthenticationFailureHandler</strong>中也是一个请求转发，并在request作用域中设置\t\t\t SPRING_SECURITY_LAST_EXCEPTION的key，内容为异常对象。</p>\n<img data-src=\"/2022/10/07/Spring_Family/SpringSecurity/springSecurity-14.jpg\" class=\"\">\n\n\n<h3 id=\"4-2代码实现\"><a href=\"#4-2代码实现\" class=\"headerlink\" title=\"4.2代码实现\"></a>4.2代码实现</h3><h4 id=\"4-2-1新建控制器\"><a href=\"#4-2-1新建控制器\" class=\"headerlink\" title=\"4.2.1新建控制器\"></a>4.2.1新建控制器</h4><p>​\t新建MyForwardAuthenticationFailureHandler实现 AuthenticationFailureHandler 。在方法中添加重定向语句</p>\n<pre><code class=\"java\">public class MyForwardAuthenticationFailureHandler implements AuthenticationFailureHandler &#123;\n    @Override\n    public void onAuthenticationFailure(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, AuthenticationException e) throws IOException, ServletException &#123;\n        httpServletResponse.sendRedirect(&quot;/fail.html&quot;);\n    &#125;\n&#125;\n</code></pre>\n<h4 id=\"4-2-2修改配置类\"><a href=\"#4-2-2修改配置类\" class=\"headerlink\" title=\"4.2.2修改配置类\"></a>4.2.2修改配置类</h4><p>​\t修改配置类中表单登录部分。设置失败时交给失败处理器进行操作。failureForwardUrl和failureHandler不可共存。</p>\n<pre><code class=\"java\">        // 表单认证\n        http.formLogin()\n                .loginProcessingUrl(&quot;/login&quot;)   //当发现/login时认为是登录，需要执行UserDetailsServiceImpl\n                .successHandler(new MyAuthenticationSuccessHandler())\n                //.successForwardUrl(&quot;/toMain&quot;)   //此处是post请求\n                .failureHandler(new MyForwardAuthenticationFailureHandler())\n//                .failureForwardUrl(&quot;/fail&quot;)     //登录失败跳转地址\n                .loginPage(&quot;/login.html&quot;);\n</code></pre>\n<h2 id=\"5-总结\"><a href=\"#5-总结\" class=\"headerlink\" title=\"5 总结\"></a>5 总结</h2><pre><code class=\"java\">        // http.formLogin() 所有和表单有关系的\n        http.formLogin()\n                // 登录页面，走一个controller\n                // 注意要和，LoginProcessingUrl 配合使用，不然在表单中的action中 url 失效\n                // 因为只配置loginPage()， 会导致在初始化的时候将loginProcessingUrl的配置相同化，可以自己debug 在AbstractAuthenticationFilterConfigurer 的 updateAuthenticationDefaults 方法\n                // 也就是说loginPage(&quot;/login&quot;)  loginProcessingUrl(&quot;/login&quot;),导致提交信息失败最终导致认证失败\n                .loginPage(&quot;/showLogin&quot;)\n                // 当发现什么URL时，把请求转发给自定义登录逻辑\n                // 表单提交的地址 action ,他就会直接去认证进入到 UserDetailsServiceImpl\n                // 去这里进行用户的验证 和 用户权限信息的集体封装\n                .loginProcessingUrl(&quot;/login&quot;)\n            \n                // 登录成功的操作\n                // 下面两种方法都可以，推荐第二种，两种同时写第一个直接失效\n                // 第一种写法，要注意在写映射的时候要注意请求的方法 get/post\n                .successForwardUrl(&quot;/showMain&quot;)\n                .successHandler((request, response, authentication) -&gt; &#123;\n                    System.out.println(&quot;successHandler invoked&quot;);\n                    // 我们在每次请求同一个页面尽量使用重定向，要是请求转发\n                    // 因为请求转发是浏览器的行为，每次都要请求服务器并且重复提交表单，不好\n                    // response.sendRedirect(&quot;/fail&quot;);\n                    LoginUser loginUser = (LoginUser) authentication.getPrincipal();\n                    for (String s : loginUser.getPermission()) &#123;\n                        System.out.println(s);\n                    &#125;\n                &#125;)\n                // 登录失败的操作\n                // 内容和上述情况相同，只是一个成功的一个失败的\n                .failureForwardUrl(&quot;/fail&quot;)\n                // 当前端表单传递过来的用户名参数、密码参数名和后端不对应，可以利用下列方法\n                // 指定前端传递过来的用户名参数名称\n                //.usernameParameter(&quot;MyuserName&quot;)\n                // 指定前端传递过来的密码参数名称\n                // .passwordParameter(&quot;MypassWord&quot;)\n        ;\n</code></pre>\n<h1 id=\"六、用户授权\"><a href=\"#六、用户授权\" class=\"headerlink\" title=\"六、用户授权\"></a>六、用户授权</h1><h2 id=\"1-权限系统的作用\"><a href=\"#1-权限系统的作用\" class=\"headerlink\" title=\"1 权限系统的作用\"></a>1 权限系统的作用</h2><p>​\t例如一个学校图书馆的管理系统，如果是普通学生登录就能看到借书还书相关的功能，不可能让他看到并且去使用添加书籍信息，删除书籍信息等功能。但是如果是一个图书馆管理员的账号登录了，应该就能看到并使用添加书籍信息，删除书籍信息等功能。</p>\n<p>​\t总结起来就是<a><strong>不同的用户可以使用不同的功能</strong></a>。这就是权限系统要去实现的效果。</p>\n<h2 id=\"2-授权基本流程\"><a href=\"#2-授权基本流程\" class=\"headerlink\" title=\"2 授权基本流程\"></a>2 授权基本流程</h2><p>​\t在SpringSecurity中，会使用默认的<strong>FilterSecurityInterceptor</strong>来进行权限校验。在 <strong>FilterSecurityInterceptor</strong>中会从<strong>SecurityContextHolder</strong>获取其<strong>Authentication</strong>，然后获取其中的权限信息。当前用户是否拥有访问当前资源所需的权限。</p>\n<p>​\t<a>所以我们在项目中只需要把当前登录用户的权限信息也存入Authentication。</a>然后设置我们的资源所需要的权限即可。</p>\n<h2 id=\"3-RBAC权限模型\"><a href=\"#3-RBAC权限模型\" class=\"headerlink\" title=\"3 RBAC权限模型\"></a>3 RBAC权限模型</h2><p>参考博客：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3F6dzc1Mjg5MDkxMy9hcnRpY2xlL2RldGFpbHMvMTI0NDYxOTUy\">https://blog.csdn.net/qzw752890913/article/details/124461952</span></p>\n<p>​\tRBAC（Role Based Access Control，基于角色的访问控制），就是用户通过角色与权限进行关联，而不是直接将权限赋予用户。</p>\n<p>​\t一个用户拥有若干个角色，每个角色拥有若干个权限，这样就构成了“用户-角色-权限”的授权模型。这种授权模型的好处在于，不必每次创建用户时都进行权限分配的操作，只要分配用户相应的角色即可，而且角色的权限变更比用户的权限变更要少得多，减少频繁设置。</p>\n<p>RBAC模型中，用户与角色之间、角色与权限之间，一般是多对多的关系。</p>\n<p>所谓“多对多”，就是双向的一对多。</p>\n<img data-src=\"/2022/10/07/Spring_Family/SpringSecurity/image-20220825151716381.png\" class=\"\">\n\n\n<p>​\t</p>\n<h2 id=\"4-授权实现\"><a href=\"#4-授权实现\" class=\"headerlink\" title=\"4 授权实现\"></a>4 授权实现</h2><ul>\n<li>基于配置——在SpringSecurity的配置类中和登录页一样进行权限配置(<font color=red>不推荐，过程繁琐，开发麻烦</font>)</li>\n<li>基于注解——直接可以对我们次处理，也就是对我们的控制层进行权限的设置(<font color=red>强烈推荐</font>)</li>\n</ul>\n<h3 id=\"4-1-基于配置授权\"><a href=\"#4-1-基于配置授权\" class=\"headerlink\" title=\"4.1 基于配置授权\"></a>4.1 基于配置授权</h3><p>这里没什么好说的，从刚开始我们就开始写了权限的认证，就是我们重写的配置类</p>\n<pre><code class=\"java\">// http.authorizeRequests() 所有和授权相关\nhttp.authorizeRequests()\n    // 这里面支持 正则 和 ant表达式\t\n    // anonymous 匿名 没有认证的才可以访问，permitALL 谁都能访问，不需要认证\n    .antMatchers(&quot;/user/login&quot;,&quot;/login&quot;,&quot;/loginPage&quot;).anonymous()\n    .antMatchers(&quot;/js/**&quot;).permitAll()\n    // authenticated 认证了才能访问\n    .anyRequest().authenticated();\n</code></pre>\n<p>这样写，除了静态资源权限需要这么写，其余请求折磨写太麻烦，我们的业务众多，这样写极大的增加了业务开发的负担，再加上静态资源我们都已经前后端分离也就涉及不到他的权限问题，所以这种方式了解就好。主要重点放在注解学习上。</p>\n<h3 id=\"4-2-基于注解授权\"><a href=\"#4-2-基于注解授权\" class=\"headerlink\" title=\"4.2 基于注解授权\"></a>4.2 基于注解授权</h3><h4 id=\"准备阶段\"><a href=\"#准备阶段\" class=\"headerlink\" title=\"准备阶段\"></a>准备阶段</h4><p>​\tSpringSecurity为我们提供了基于注解的权限控制方案，这也是我们项目中主要采用的方式。我们可以使用注解去指定访问对应的资源所需的权限。</p>\n<p>​\t&#x3D;&#x3D;但是要使用它我们需要先开启相关配置。&#x3D;&#x3D;，&#x3D;&#x3D;不打开直接用会 500&#x3D;&#x3D;</p>\n<pre><code class=\"java\">@EnableGlobalMethodSecurity(prePostEnabled = true)//启动类上添加注解\n</code></pre>\n<h4 id=\"找到对应的接口\"><a href=\"#找到对应的接口\" class=\"headerlink\" title=\"找到对应的接口\"></a>找到对应的接口</h4><p>这里我们找到需要授权的接口，对他们进行授权，主要有3个主要注解 </p>\n<ul>\n<li>@Secured</li>\n<li>@PerAuthorize() 、@PostAuthorize</li>\n</ul>\n<p>只要对我们的接口上添加相对应的注解即可，例如</p>\n<pre><code class=\"java\">@Controller\npublic class loginController&#123;\n    @Secured(&quot;ROLE_abc&quot;) //专门用于判断是否具有角色的。能写在方法或类上。参数要以ROLE_开头。\n    @RequestMapping(&quot;/toMain&quot;)\n    public String toMain()&#123;\n        return &quot;redirect:/main.html&quot;;\n    &#125;\n    \n    @RequestMapping(&quot;/hello3&quot;)\n    @ResponseBody\n    // 是方法或类级别注解。\n    @PreAuthorize(&quot;hasAnyAuthority(&#39;demo:delete&#39;)&quot;)\n    public String testThree()&#123;\n        return &quot;success!&quot;;\n    &#125;\n\n    @RequestMapping(&quot;/hello4&quot;)\n    @ResponseBody\n    //  是方法或类级别注解。\n    @PostAuthorize(&quot;hasAnyRole(&#39;ROLE_管理员&#39;)&quot;)\n    public String testFour()&#123;\n        return &quot;success!&quot;;\n    &#125;\n&#125;\n</code></pre>\n<h1 id=\"七、配置类说明-2-—访问控制\"><a href=\"#七、配置类说明-2-—访问控制\" class=\"headerlink\" title=\"七、配置类说明 2 —访问控制\"></a>七、配置类说明 2 —访问控制</h1><p>在前面讲解了认证中所有常用配置，主要是对http.formLogin()进行操作。而在配置类中\t\thttp.authorizeRequests()主要是对url进行控制，也就是我们所说的授权（访问控制）。http.authorizeRequests()也支持连缀写法，总体公式为：</p>\n<p>​\turl匹配规则.权限控制方法</p>\n<p>通过上面的公式可以有很多url匹配规则和很多权限控制方法。这些内容进行各种组合就形成了Spring Security中的授权。</p>\n<p>​\t在所有匹配规则中取所有规则的交集。配置顺序影响了之后授权效果，越是具体的应该放在前面，越是笼统的应该放到后面。\t</p>\n<h2 id=\"1-anyRequest\"><a href=\"#1-anyRequest\" class=\"headerlink\" title=\"1.anyRequest()\"></a>1.anyRequest()</h2><p>​\t在之前认证过程中我们就已经使用过anyRequest()，表示匹配所有的请求。一般情况下此方法都会使用，设置全部内容都需要进行认证。</p>\n<p>​\t代码示例:</p>\n<pre><code class=\"java\">anyRequest().authenticated();\n</code></pre>\n<h2 id=\"2-antMatcher\"><a href=\"#2-antMatcher\" class=\"headerlink\" title=\"2.antMatcher()\"></a>2.antMatcher()</h2><p>​\t方法定义如下：</p>\n<pre><code class=\"java\">public C antMatchers(String... antPatterns)\n</code></pre>\n<p>​\t参数是不定向参数，每个参数是一个 正则&#x2F;ant表达式，用于匹配URL规则。</p>\n<p>​\t规则如下：</p>\n<p>​\t? 匹配一个字符</p>\n<p>​\t* 匹配0个或多个字符</p>\n<p>​\t** 匹配0个或多个目录</p>\n<p>​\t在实际项目中经常需要放行所有静态资源，下面演示放行js文件夹下所有脚本文件。</p>\n<pre><code class=\"java\">.antMatchers(&quot;/js/**&quot;).permitAll()\n</code></pre>\n<p>还有一种配置方式是只要是.js文件都放行</p>\n<pre><code class=\"java\">antMatchers(&quot;/**/*.js&quot;).permitAll()\n</code></pre>\n<h2 id=\"3-regexMatchers\"><a href=\"#3-regexMatchers\" class=\"headerlink\" title=\"3.regexMatchers()\"></a>3.regexMatchers()</h2><h3 id=\"3-1介绍\"><a href=\"#3-1介绍\" class=\"headerlink\" title=\"3.1介绍\"></a>3.1介绍</h3><p>使用正则表达式进行匹配。和antMatchers()主要的区别就是参数，antMatchers()参数是ant表达式，regexMatchers()参数是正则表达式。</p>\n<p>演示所有以.js结尾的文件都被放行。</p>\n<pre><code class=\"java\">.regexMatchers(&quot;.+[.]js&quot;).permitAll()\n</code></pre>\n<h3 id=\"3-2两个参数时使用方式\"><a href=\"#3-2两个参数时使用方式\" class=\"headerlink\" title=\"3.2两个参数时使用方式\"></a>3.2两个参数时使用方式</h3><p>无论是antMatchers()还是regexMatchers()都具有两个参数的方法，其中第一个参数都是HttpMethod，表示请求方式，当设置了HttpMethod后表示只有设定的特定的请求方式才执行对应的权限设置。</p>\n<p>枚举类型HttpMethod内置属性如下：</p>\n<img data-src=\"/2022/10/07/Spring_Family/SpringSecurity/springSecurity-15.jpg\" class=\"\">\n\n\n<h2 id=\"4-内置访问控制方法介绍\"><a href=\"#4-内置访问控制方法介绍\" class=\"headerlink\" title=\"4 内置访问控制方法介绍\"></a>4 内置访问控制方法介绍</h2><p>​\tSpring Security匹配了URL后调用了permitAll()表示不需要认证，随意访问。在Spring Security中提供了多种内置控制。</p>\n<h3 id=\"1-permitAll\"><a href=\"#1-permitAll\" class=\"headerlink\" title=\"1.permitAll()\"></a>1.permitAll()</h3><p>​\t<strong>permitAll()表示所匹配的URL任何人都允许访问。</strong></p>\n<h3 id=\"2-authenticated\"><a href=\"#2-authenticated\" class=\"headerlink\" title=\"2.authenticated()\"></a>2.authenticated()</h3><p>​\t<strong>authenticated()表示所匹配的URL都需要被认证才能访问。</strong></p>\n<h3 id=\"3-anonymous\"><a href=\"#3-anonymous\" class=\"headerlink\" title=\"3.anonymous()\"></a>3.anonymous()</h3><p>​\t<strong>anonymous()表示可以匿名访问匹配的URL。和permitAll()效果类似，只是设置为anonymous()的url会执行filter 链中</strong></p>\n<p>​\t官方源码定义如下：</p>\n<img data-src=\"/2022/10/07/Spring_Family/SpringSecurity/springSecurity-18.jpg\" class=\"\">\n\n\n<h3 id=\"4-denyAll\"><a href=\"#4-denyAll\" class=\"headerlink\" title=\"4.denyAll()\"></a>4.denyAll()</h3><p>​\t<strong>denyAll()表示所匹配的URL都不允许被访问。</strong></p>\n<img data-src=\"/2022/10/07/Spring_Family/SpringSecurity/springSecurity-19.jpg\" class=\"\">\n\n\n<h3 id=\"5-rememberMe\"><a href=\"#5-rememberMe\" class=\"headerlink\" title=\"5.rememberMe()\"></a>5.rememberMe()</h3><p>​\t<strong>被“remember me”的用户允许访问</strong></p>\n<img data-src=\"/2022/10/07/Spring_Family/SpringSecurity/springSecurity-20.jpg\" class=\"\">\n\n\n<h3 id=\"6-fullyAuthenticated\"><a href=\"#6-fullyAuthenticated\" class=\"headerlink\" title=\"6.fullyAuthenticated()\"></a>6.fullyAuthenticated()</h3><p>​\t<strong>如果用户不是被remember me的，才可以访问</strong>。</p>\n<img data-src=\"/2022/10/07/Spring_Family/SpringSecurity/springSecurity-21.jpg\" class=\"\">\n\n\n<h3 id=\"7-hasIpAddress-String\"><a href=\"#7-hasIpAddress-String\" class=\"headerlink\" title=\"7.hasIpAddress(String)\"></a>7.hasIpAddress(String)</h3><p>如果请求是指定的IP就运行访问。</p>\n<p>​\t可以通过request.getRemoteAddr()获取ip地址。</p>\n<p>​\t需要注意的是在本机进行测试时localhost和127.0.0.1输出的ip地址是不一样的。</p>\n<p>​\t当浏览器中通过localhost进行访问时控制台打印的内容：</p>\n<img data-src=\"/2022/10/07/Spring_Family/SpringSecurity/springSecurity-25-1661415211434.jpg\" class=\"\">\n\n\n<p>​\t当浏览器中通过127.0.0.1访问时控制台打印的内容：</p>\n<img data-src=\"/2022/10/07/Spring_Family/SpringSecurity/springSecurity-26-1661415211434.jpg\" class=\"\">\n\n\n<p>​\t当浏览器中通过具体ip进行访问时控制台打印内容：</p>\n<img data-src=\"/2022/10/07/Spring_Family/SpringSecurity/springSecurity-27-1606734864126-1661415211434.jpg\" class=\"\">\n\n\n<p>​\t使用Spring Security时经常会看见403（无权限），默认情况下显示的效果如下：</p>\n<img data-src=\"/2022/10/07/Spring_Family/SpringSecurity/springSecurity-28-1661415211434.jpg\" class=\"\">\n\n\n<p>​\t而在实际项目中可能都是一个异步请求，显示上述效果对于用户就不是特别友好了。Spring Security支持自定义权限受限。</p>\n<h4 id=\"1-新建类\"><a href=\"#1-新建类\" class=\"headerlink\" title=\"1.新建类\"></a>1.新建类</h4><p>​\t新建类实现<strong>AccessDeniedHandler</strong></p>\n<pre><code class=\"java\">@Component\npublic class MyAccessDeniedHandler implements AccessDeniedHandler &#123;\n    @Override\n    public void handle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, AccessDeniedException e) throws IOException, ServletException &#123;\n        httpServletResponse.setStatus(HttpServletResponse.SC_FORBIDDEN);\n        httpServletResponse.setHeader(&quot;Content-Type&quot;,&quot;application/json;charset=utf-8&quot;);\n        PrintWriter out = httpServletResponse.getWriter();\n        out.write(&quot;&#123;\\&quot;status\\&quot;:\\&quot;error\\&quot;,\\&quot;msg\\&quot;:\\&quot;权限不足，请联系管理员!\\&quot;&#125;&quot;);\n        out.flush();\n        out.close();\n    &#125;\n&#125;\n</code></pre>\n<h4 id=\"2-修改配置类\"><a href=\"#2-修改配置类\" class=\"headerlink\" title=\"2.修改配置类\"></a>2.修改配置类</h4><p>​\t配置类中重点添加异常处理器。设置访问受限后交给哪个对象进行处理。</p>\n<p>​\tmyAccessDeniedHandler是在配置类中进行自动注入的。</p>\n<pre><code class=\"java\">//异常处理\nhttp.exceptionHandling()\n        .accessDeniedHandler(myAccessDeniedHandler);\n</code></pre>\n<h2 id=\"5-总结-1\"><a href=\"#5-总结-1\" class=\"headerlink\" title=\"5 总结\"></a>5 总结</h2><p>在选择特定请求时 2&#x2F;3 任选其一 效果相同，主要注意内置访问控制方法的选择</p>\n<h1 id=\"八、配置类说明-3-—基于表达式的访问控制\"><a href=\"#八、配置类说明-3-—基于表达式的访问控制\" class=\"headerlink\" title=\"八、配置类说明 3 —基于表达式的访问控制\"></a>八、配置类说明 3 —基于表达式的访问控制</h1><h2 id=\"1-access-方法使用\"><a href=\"#1-access-方法使用\" class=\"headerlink\" title=\"1.access()方法使用\"></a>1.access()方法使用</h2><p>​\t之前学习的登录用户权限判断实际上底层实现都是调用access(表达式)</p>\n<img data-src=\"/2022/10/07/Spring_Family/SpringSecurity/springSecurity-29.jpg\" class=\"\">\n\n\n<p>​\t可以通过access()实现和之前学习的权限控制完成相同的功能。</p>\n<h3 id=\"1-1以hasRole和permitAll举例\"><a href=\"#1-1以hasRole和permitAll举例\" class=\"headerlink\" title=\"1.1以hasRole和permitAll举例\"></a>1.1以hasRole和permitAll举例</h3><p>​\t下面代码和直接使用permitAll()和hasRole()是等效的。</p>\n<img data-src=\"/2022/10/07/Spring_Family/SpringSecurity/springSecurity-30.jpg\" class=\"\">\n\n\n<h2 id=\"2-自定义权限验证方法\"><a href=\"#2-自定义权限验证方法\" class=\"headerlink\" title=\"2.自定义权限验证方法\"></a>2.自定义权限验证方法</h2><p>​\t虽然这里面已经包含了很多的表达式(方法)但是在实际项目中很有可能出现需要自己自定义逻辑的情况。</p>\n<p>​\t判断登录用户是否具有访问当前URL权限。</p>\n<h3 id=\"2-1新建接口及实现类\"><a href=\"#2-1新建接口及实现类\" class=\"headerlink\" title=\"2.1新建接口及实现类\"></a>2.1新建接口及实现类</h3><p>​\t新建接口com.msb.service.MyService后新建实现类。</p>\n<pre><code class=\"java\">public interface MyService &#123;\n    boolean hasPermission(HttpServletRequest request, Authentication authentication);\n&#125;\n</code></pre>\n<pre><code class=\"java\">@Component\npublic class MyServiceImpl implements MyService &#123;\n    @Override\n    public boolean hasPermission(HttpServletRequest request, Authentication authentication) &#123;\n        Object obj = authentication.getPrincipal();\n        if(obj instanceof UserDetails)&#123;\n            UserDetails user = (UserDetails) obj;\n            Collection&lt;? extends GrantedAuthority&gt; authorities = user.getAuthorities();\n            return authorities.contains(new SimpleGrantedAuthority(request.getRequestURI()));\n        &#125;\n        return false;\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"2-2修改配置类\"><a href=\"#2-2修改配置类\" class=\"headerlink\" title=\"2.2修改配置类\"></a>2.2修改配置类</h3><p>​\t在access中通过@bean的id名.方法(参数)的形式进行调用</p>\n<p>​\t配置类中修改如下：</p>\n<pre><code class=\"java\"> // url 拦截 (授权)\nhttp.authorizeRequests()\n        .antMatchers(&quot;/login.html&quot;).access(&quot;permitAll&quot;)\n        .antMatchers(&quot;/fail.html&quot;).permitAll()\n        // @Bean的名字，表示引入某个Bean，我们的Bean在主动命名的情况下，都是以首字母小写命名\n        .anyRequest().access(&quot;@myServiceImpl.hasPermission(request,authentication)&quot;);\n</code></pre>\n<h1 id=\"九、基于注解的访问控制\"><a href=\"#九、基于注解的访问控制\" class=\"headerlink\" title=\"九、基于注解的访问控制\"></a>九、基于注解的访问控制</h1><p>​\t在Spring Security中提供了一些访问控制的注解。这些注解都是默认是都不可用的，需要通过@EnableGlobalMethodSecurity进行开启后使用。</p>\n<p>​\t&#x3D;&#x3D;如果设置的条件允许，程序正常执行。如果不允许会报500&#x3D;&#x3D;</p>\n<p>​\t这些注解可以写到Service接口或方法上上也可以写到Controller或Controller的方法上。通常情况下都是写在控制器方法上的，控制接口URL是否允许被访问。</p>\n<h2 id=\"1-Secured\"><a href=\"#1-Secured\" class=\"headerlink\" title=\"1.@Secured\"></a>1.@Secured</h2><p>​\t@Secured是&#x3D;&#x3D;专门用于判断是否具有角色的&#x3D;&#x3D;。能写在&#x3D;&#x3D;方法或类&#x3D;&#x3D;上。&#x3D;&#x3D;参数要以ROLE_开头&#x3D;&#x3D;。</p>\n<img data-src=\"/2022/10/07/Spring_Family/SpringSecurity/springSecurity-32-1661416083118.jpg\" class=\"\">\n\n\n<h3 id=\"1-1实现步骤\"><a href=\"#1-1实现步骤\" class=\"headerlink\" title=\"1.1实现步骤\"></a>1.1实现步骤</h3><h4 id=\"1-1-1-开启注解\"><a href=\"#1-1-1-开启注解\" class=\"headerlink\" title=\"1.1.1 开启注解\"></a>1.1.1 开启注解</h4><p>​\t在启动类(也可以在配置类等能够扫描的类上)上添加@EnableGlobalMethodSecurity(securedEnabled &#x3D; true)</p>\n<pre><code class=\"java\">@SpringBootApplication\n@EnableGlobalMethodSecurity(securedEnabled = true)\npublic class MyApp &#123;\n    public static void main(String [] args)&#123;\n        SpringApplication.run(MyApp.class,args);\n    &#125;\n&#125;\n</code></pre>\n<h4 id=\"1-1-2在控制器方法上添加-Secured注解\"><a href=\"#1-1-2在控制器方法上添加-Secured注解\" class=\"headerlink\" title=\"1.1.2在控制器方法上添加@Secured注解\"></a>1.1.2在控制器方法上添加@Secured注解</h4><p>​\t在LoginController中方法上添加注解</p>\n<pre><code class=\"java\">@Secured(&quot;ROLE_abc&quot;)\n@RequestMapping(&quot;/toMain&quot;)\npublic String toMain()&#123;\n    return &quot;redirect:/main.html&quot;;\n&#125;\n</code></pre>\n<h4 id=\"1-1-3配置类\"><a href=\"#1-1-3配置类\" class=\"headerlink\" title=\"1.1.3配置类\"></a>1.1.3配置类</h4><p>​\t配置类中方法配置保留最基本的配置即可。</p>\n<pre><code class=\"java\">protected void configure(HttpSecurity http) throws Exception &#123;\n    // 表单认证\n    http.formLogin()\n            .loginProcessingUrl(&quot;/login&quot;)   //当发现/login时认为是登录，需要执行UserDetailsServiceImpl\n            .successForwardUrl(&quot;/toMain&quot;)   //此处是post请求\n            .loginPage(&quot;/login.html&quot;);\n\n    // url 拦截\n    http.authorizeRequests()\n            .antMatchers(&quot;/login.html&quot;).permitAll() //login.html不需要被认证\n            .anyRequest().authenticated();//所有的请求都必须被认证。必须登录后才能访问。\n\n    //关闭csrf防护\n    http.csrf().disable();\n\n&#125;\n</code></pre>\n<h2 id=\"2-PreAuthorize-x2F-PostAuthorize\"><a href=\"#2-PreAuthorize-x2F-PostAuthorize\" class=\"headerlink\" title=\"2.@PreAuthorize&#x2F;@PostAuthorize\"></a>2.@PreAuthorize&#x2F;@PostAuthorize</h2><p>​\t@PreAuthorize和@PostAuthorize都是方法或类级别注解。</p>\n<p>​\t**@PreAuthorize ** 表示访问方法或类在&#x3D;&#x3D;执行之前先判断权限&#x3D;&#x3D;，大多情况下都是使用这个注解，注解的参数和access()方法参数取值相同，都是权限表达式。</p>\n<p>​\t@<strong>PostAuthorize</strong> 表示&#x3D;&#x3D;方法或类执行结束后判断权限&#x3D;&#x3D;，此注解很少被使用到。</p>\n<img data-src=\"/2022/10/07/Spring_Family/SpringSecurity/image-20220825155542682.png\" class=\"\">\n\n\n<h3 id=\"2-1实现步骤\"><a href=\"#2-1实现步骤\" class=\"headerlink\" title=\"2.1实现步骤\"></a>2.1实现步骤</h3><h4 id=\"2-1-1开启注解\"><a href=\"#2-1-1开启注解\" class=\"headerlink\" title=\"2.1.1开启注解\"></a>2.1.1开启注解</h4><p>​\t在启动类中开启@PreAuthorize注解。</p>\n<pre><code class=\"java\">@SpringBootApplication\n@EnableGlobalMethodSecurity(prePostEnabled = true)\npublic class MyApp &#123;\n    public static void main(String [] args)&#123;\n        SpringApplication.run(MyApp.class,args);\n    &#125;\n&#125;\n</code></pre>\n<h4 id=\"2-1-2添加-PreAuthorize\"><a href=\"#2-1-2添加-PreAuthorize\" class=\"headerlink\" title=\"2.1.2添加@PreAuthorize\"></a>2.1.2添加@PreAuthorize</h4><p>​\t在控制器方法上添加@PreAuthorize，参数可以是任何access()支持的表达式</p>\n<pre><code class=\"java\">@PreAuthorize(&quot;hasRole(&#39;abc&#39;)&quot;)\n@RequestMapping(&quot;/toMain&quot;)\npublic String toMain()&#123;\n    return &quot;redirect:/main.html&quot;;\n&#125;\n</code></pre>\n<h2 id=\"3-自定义权限校验方法-针对Pre注解\"><a href=\"#3-自定义权限校验方法-针对Pre注解\" class=\"headerlink\" title=\"3.自定义权限校验方法(针对Pre注解)\"></a>3.自定义权限校验方法(针对Pre注解)</h2><p>我们如果觉得单纯验证不合适，或者说不符合我们的业务我们也可以自定义方法</p>\n<h3 id=\"其它权限校验方法\"><a href=\"#其它权限校验方法\" class=\"headerlink\" title=\"其它权限校验方法\"></a>其它权限校验方法</h3><p>​\t我们前面都是使用@PreAuthorize注解，然后在在其中使用的是hasAuthority方法进行校验。SpringSecurity还为我们提供了其它方法例如：hasAnyAuthority，hasRole，hasAnyRole等。</p>\n<p>​\t这里我们先不急着去介绍这些方法，我们先去理解hasAuthority的原理，然后再去学习其他方法你就更容易理解，而不是死记硬背区别。并且我们也可以选择定义校验方法，实现我们自己的校验逻辑。</p>\n<p>​\t<strong>hasAuthority</strong>方法实际是执行到了<strong>SecurityExpressionRoot</strong>的<strong>hasAuthority</strong>，大家只要断点调试既可知道它内部的校验原理。</p>\n<p>​\t它内部其实是调用<strong>authentication</strong>的<strong>getAuthorities</strong>方法获取用户的权限列表。然后判断我们存入的方法参数数据在权限列表中。</p>\n<p>​\t<strong>hasAnyAuthority</strong>方法可以传入多个权限，只有用户有其中任意一个权限都可以访问对应资源。</p>\n<pre><code class=\"java\">    @PreAuthorize(&quot;hasAnyAuthority(&#39;admin&#39;,&#39;test&#39;,&#39;system:dept:list&#39;)&quot;)\n    public String hello()&#123;\n        return &quot;hello&quot;;\n    &#125;\n</code></pre>\n<p>​\t<strong>hasRole</strong>要求有对应的角色才可以访问，但是它内部会把我们传入的参数拼接上 <strong>ROLE_</strong> 后再去比较。所以这种情况下要用用户对应的权限也要有 <strong>ROLE_</strong> 这个前缀才可以。</p>\n<pre><code class=\"java\">    @PreAuthorize(&quot;hasRole(&#39;system:dept:list&#39;)&quot;)\n    public String hello()&#123;\n        return &quot;hello&quot;;\n    &#125;\n</code></pre>\n<p>​\t<strong>hasAnyRole</strong> 有任意的角色就可以访问。它内部也会把我们传入的参数拼接上 <strong>ROLE_</strong> 后再去比较。所以这种情况下要用用户对应的权限也要有 <strong>ROLE_</strong> 这个前缀才可以。</p>\n<pre><code class=\"java\">    @PreAuthorize(&quot;hasAnyRole(&#39;admin&#39;,&#39;system:dept:list&#39;)&quot;)\n    public String hello()&#123;\n        return &quot;hello&quot;;\n    &#125;\n</code></pre>\n<h3 id=\"自定义权限校验方法\"><a href=\"#自定义权限校验方法\" class=\"headerlink\" title=\"自定义权限校验方法\"></a>自定义权限校验方法</h3><p>​\t我们也可以定义自己的权限校验方法，在@PreAuthorize注解中使用我们的方法。</p>\n<pre><code class=\"java\">@Component(&quot;ex&quot;)\npublic class MyExpressionRoot &#123;\n    // 一定要返回一个Bool值\n    public boolean hasAuthority(String authority)&#123;\n        //获取当前用户的权限\n        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();\n        LoginUser loginUser = (LoginUser) authentication.getPrincipal();\n        List&lt;String&gt; permissions = loginUser.getPermissions();\n        //判断用户权限集合中是否存在authority\n        return permissions.contains(authority);\n    &#125;\n&#125;\n</code></pre>\n<p>​\t <strong>在SPEL表达式中使用 @ex相当于获取容器中bean的名字为ex的对象。然后再调用这个对象的hasAuthority方法</strong></p>\n<pre><code class=\"java\">    @RequestMapping(&quot;/hello&quot;)\n    @PreAuthorize(&quot;@ex.hasAuthority(&#39;system:dept:list&#39;)&quot;)\n    public String hello()&#123;\n        return &quot;hello&quot;;\n    &#125;\n</code></pre>\n<h1 id=\"十、自定义失败处理\"><a href=\"#十、自定义失败处理\" class=\"headerlink\" title=\"十、自定义失败处理\"></a>十、自定义失败处理</h1><p>​\t我们还希望在认证失败或者是授权失败的情况下也能和我们的接口一样返回相同结构的json，这样可以让前端能对响应进行统一的处理。要实现这个功能我们需要知道SpringSecurity的异常处理机制。</p>\n<p>​\t在SpringSecurity中，如果我们在认证或者授权的过程中出现了异常会被ExceptionTranslationFilter捕获到。在ExceptionTranslationFilter中会去判断是认证失败还是授权失败出现的异常。</p>\n<p>​\t如果是&#x3D;&#x3D;认证过程中出现的异常&#x3D;&#x3D;会被封装成<strong>AuthenticationException</strong>然后调用<strong>AuthenticationEntryPoint</strong>对象的方法去进行异常处理。</p>\n<p>​\t如果是&#x3D;&#x3D;授权过程中出现的异常&#x3D;&#x3D;会被封装成<strong>AccessDeniedException</strong>然后调用<strong>AccessDeniedHandler</strong>对象的方法去进行异常处理。</p>\n<p>​\t所以如果我们&#x3D;&#x3D;需要自定义异常处理&#x3D;&#x3D;，我们只需要&#x3D;&#x3D;自定义AuthenticationEntryPoint和AccessDeniedHandler然后配置给SpringSecurity即可&#x3D;&#x3D;。</p>\n<h2 id=\"①自定义实现类\"><a href=\"#①自定义实现类\" class=\"headerlink\" title=\"①自定义实现类\"></a>①自定义实现类</h2><pre><code class=\"java\">@Component\npublic class AccessDeniedHandlerImpl implements AccessDeniedHandler &#123;\n    @Override\n    public void handle(HttpServletRequest request, HttpServletResponse response, AccessDeniedException accessDeniedException) throws IOException, ServletException &#123;\n        ResponseResult result = new ResponseResult(HttpStatus.FORBIDDEN.value(), &quot;权限不足&quot;);\n        String json = JSON.toJSONString(result);\n        WebUtils.renderString(response,json);\n    &#125;\n&#125;\n</code></pre>\n<pre><code class=\"java\">@Component\npublic class AuthenticationEntryPointImpl implements AuthenticationEntryPoint &#123;\n    @Override\n    public void commence(HttpServletRequest request, HttpServletResponse response, AuthenticationException authException) throws IOException, ServletException &#123;\n        ResponseResult result = new ResponseResult(HttpStatus.UNAUTHORIZED.value(), &quot;认证失败请重新登录&quot;);\n        String json = JSON.toJSONString(result);\n        WebUtils.renderString(response,json);\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"②配置给SpringSecurity\"><a href=\"#②配置给SpringSecurity\" class=\"headerlink\" title=\"②配置给SpringSecurity\"></a>②配置给SpringSecurity</h2><p>​\t先注入对应的处理器</p>\n<pre><code class=\"java\">    @Autowired\n    private AuthenticationEntryPoint authenticationEntryPoint;\n\n    @Autowired\n    private AccessDeniedHandler accessDeniedHandler;\n</code></pre>\n<p>​\t然后我们可以使用HttpSecurity对象的方法去配置。</p>\n<pre><code class=\"java\">        http.exceptionHandling()\n            .authenticationEntryPoint(authenticationEntryPoint)\n            .accessDeniedHandler(accessDeniedHandler);\n</code></pre>\n<h1 id=\"十一、Remember-Me功能实现\"><a href=\"#十一、Remember-Me功能实现\" class=\"headerlink\" title=\"十一、Remember Me功能实现\"></a>十一、Remember Me功能实现</h1><p>​\tSpring Security 中Remember Me为“记住我”功能，用户只需要在登录时添加remember-me复选框，取值为true。Spring Security会自动把用户信息存储到数据源中，以后就可以不登录进行访问。</p>\n<h2 id=\"1-添加依赖\"><a href=\"#1-添加依赖\" class=\"headerlink\" title=\"1.添加依赖\"></a>1.添加依赖</h2><p>​\tSpring Security实现Remember Me 功能时底层实现依赖Spring-JDBC，所以需要导入Spring-JDBC。以后多使用MyBatis框架而很少直接导入spring-jdbc，所以此处导入mybatis启动器</p>\n<p>同时还需要添加MySQL驱动</p>\n<pre><code class=\"xml\">&lt;dependency&gt;\n    &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;\n    &lt;version&gt;2.1.1&lt;/version&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;mysql&lt;/groupId&gt;\n    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;\n    &lt;version&gt;5.1.6&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>\n<h2 id=\"2-配置数据源\"><a href=\"#2-配置数据源\" class=\"headerlink\" title=\"2.配置数据源\"></a>2.配置数据源</h2><p>​\t在application.properties中配置数据源。请确保数据库中已经存在security数据库</p>\n<pre><code class=\"properties\">spring.datasource.driver-class-name=com.mysql.jdbc.Driver\nspring.datasource.url=jdbc:mysql://127.0.0.1:3306/mashibing\nspring.datasource.username=root\nspring.datasource.password=root\n</code></pre>\n<h2 id=\"3-编写配置\"><a href=\"#3-编写配置\" class=\"headerlink\" title=\"3.编写配置\"></a>3.编写配置</h2><p>​\t新建com.msb.config.RememberMeConfig类，并创建Bean对象</p>\n<pre><code class=\"java\">@Configuration\npublic class RememberMeConfig &#123;\n    @Autowired\n    private DataSource dataSource;\n    @Bean\n    public PersistentTokenRepository getPersistentTokenRepository() &#123;\n        JdbcTokenRepositoryImpl jdbcTokenRepositoryImpl=new JdbcTokenRepositoryImpl();\n        jdbcTokenRepositoryImpl.setDataSource(dataSource);\n        //自动建表，第一次启动时需要，第二次启动时注释掉\n//        jdbcTokenRepositoryImpl.setCreateTableOnStartup(true);\n        return jdbcTokenRepositoryImpl;\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"4-修改SecurityConfig\"><a href=\"#4-修改SecurityConfig\" class=\"headerlink\" title=\"4.修改SecurityConfig\"></a>4.修改SecurityConfig</h2><p>​\t在SecurityConfig中添加RememberMeConfig和UserDetailsService实现类对象，并自动注入。</p>\n<p>​\t在configure中添加下面配置内容。</p>\n<pre><code class=\"java\">http.rememberMe()\n    .userDetailsService(userDetailsService) //登录逻辑交给哪个对象\n    .tokenRepository(repository);   //持久层对象\n</code></pre>\n<h2 id=\"5-在客户端页面中添加复选框\"><a href=\"#5-在客户端页面中添加复选框\" class=\"headerlink\" title=\"5.在客户端页面中添加复选框\"></a>5.在客户端页面中添加复选框</h2><p>​\t在客户端登录页面中添加remember-me的复选框，只要用户勾选了复选框下次就不需要进行登录了。</p>\n<pre><code class=\"html\">&lt;form action = &quot;/login&quot; method=&quot;post&quot;&gt;\n    用户名：&lt;input type=&quot;text&quot; name=&quot;username&quot;/&gt;&lt;br/&gt;\n    密码:&lt;input type=&quot;text&quot; name=&quot;password&quot;/&gt;&lt;br/&gt;\n    &lt;input type=&quot;checkbox&quot; name=&quot;remember-me&quot; value=&quot;true&quot;/&gt; &lt;br/&gt;\n    &lt;input type=&quot;submit&quot; value=&quot;登录&quot;/&gt;\n&lt;/form&gt;\n</code></pre>\n<h2 id=\"6-有效时间\"><a href=\"#6-有效时间\" class=\"headerlink\" title=\"6.有效时间\"></a>6.有效时间</h2><p>​\t默认情况下重启项目后登录状态失效了。但是可以通过设置状态有效时间，即使项目重新启动下次也可以正常登录。</p>\n<pre><code class=\"java\">//remember Me\nhttp.rememberMe()\n        .tokenValiditySeconds(120)//单位：秒\n        .tokenRepository(repository)\n        .userDetailsService(userDetailsServiceImpl);\n</code></pre>\n<h1 id=\"十二、Thymeleaf中Spring-Security的使用\"><a href=\"#十二、Thymeleaf中Spring-Security的使用\" class=\"headerlink\" title=\"十二、Thymeleaf中Spring Security的使用\"></a>十二、Thymeleaf中Spring Security的使用</h1><p>​\tSpring Security可以在一些视图技术中进行控制显示效果。例如：JSP或Thymeleaf。在非前后端分离且使用Spring Boot的项目中多使用Thymeleaf作为视图展示技术。</p>\n<p>​\tThymeleaf对Spring Security的支持都放在thymeleaf-extras-springsecurityX中，目前最新版本为5。所以需要在项目中添加此jar包的依赖和thymeleaf的依赖。</p>\n<pre><code class=\"xml\">&lt;dependency&gt;\n    &lt;groupId&gt;org.thymeleaf.extras&lt;/groupId&gt;\n    &lt;artifactId&gt;thymeleaf-extras-springsecurity5&lt;/artifactId&gt;\n    &lt;version&gt;3.0.4.RELEASE&lt;/version&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;\n&lt;/dependency&gt;\n</code></pre>\n<p>​\t在html页面中引入thymeleaf命名空间和security命名空间</p>\n<pre><code class=\"html\">&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;\n      xmlns:th=&quot;http://www.thymeleaf.org&quot;\nxmlns:sec=&quot;http://www.thymeleaf.org/thymeleaf-extras-springsecurity5&quot;&gt;\n</code></pre>\n<h2 id=\"1-获取属性\"><a href=\"#1-获取属性\" class=\"headerlink\" title=\"1.获取属性\"></a>1.获取属性</h2><p>​\t可以在html页面中通过 sec:authentication&#x3D;””获取UsernamePasswordAuthenticationToken中所有getXXX的内容，包含父类中的getXXX的内容。</p>\n<p>​\t根据源码得出下面属性：</p>\n<p>​\tl name：登录账号名称</p>\n<p>​\tl principal：登录主体，在自定义登录逻辑中是UserDet ails</p>\n<p>​\tl credentials：凭证</p>\n<p>​\tl authorities：权限和角色</p>\n<p>​\tl details：实际上是WebAuthenticationDetails的实例。可以获取remoteAddress(客户端ip)和sessionId(当\t前sessionId)</p>\n<h3 id=\"1-1实现步骤：\"><a href=\"#1-1实现步骤：\" class=\"headerlink\" title=\"1.1实现步骤：\"></a>1.1实现步骤：</h3><h4 id=\"1-1-1新建demo-html\"><a href=\"#1-1-1新建demo-html\" class=\"headerlink\" title=\"1.1.1新建demo.html\"></a>1.1.1新建demo.html</h4><p>​\t在项目resources中新建templates文件夹，在templates中新建demo.html页面</p>\n<img data-src=\"/2022/10/07/Spring_Family/SpringSecurity/springSecurity-34.jpg\" class=\"\">\n\n\n<h4 id=\"1-1-2编写demo-html\"><a href=\"#1-1-2编写demo-html\" class=\"headerlink\" title=\"1.1.2编写demo.html\"></a>1.1.2编写demo.html</h4><p>​\t在demo.html中编写下面内容，测试获取到的值</p>\n<pre><code class=\"html\">&lt;!DOCTYPE html&gt;\n&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;\n      xmlns:th=&quot;http://www.thymeleaf.org&quot;\n      xmlns:sec=&quot;http://www.thymeleaf.org/thymeleaf-extras-springsecurity5&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;title&gt;Title&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    登录账号:&lt;span sec:authentication=&quot;name&quot;&gt;&lt;/span&gt;&lt;br/&gt;\n    登录账号:&lt;span sec:authentication=&quot;principal.username&quot;&gt;&lt;/span&gt;&lt;br/&gt;\n    凭证：&lt;span sec:authentication=&quot;credentials&quot;&gt;&lt;/span&gt;&lt;br/&gt;\n    权限和角色：&lt;span sec:authentication=&quot;authorities&quot;&gt;&lt;/span&gt;&lt;br/&gt;\n    客户端地址：&lt;span sec:authentication=&quot;details.remoteAddress&quot;&gt;&lt;/span&gt;&lt;br/&gt;\n    sessionId：&lt;span sec:authentication=&quot;details.sessionId&quot;&gt;&lt;/span&gt;&lt;br/&gt;\n&lt;/body&gt;\n&lt;/html&gt;  \n</code></pre>\n<h4 id=\"1-1-3编写控制器\"><a href=\"#1-1-3编写控制器\" class=\"headerlink\" title=\"1.1.3编写控制器\"></a>1.1.3编写控制器</h4><p>​\tthymeleaf页面需要控制转发，在控制器类中编写下面方法</p>\n<pre><code class=\"java\">@RequestMapping(&quot;/demo&quot;)\npublic String demo()&#123;\n    return &quot;demo&quot;;\n&#125;\n</code></pre>\n<h2 id=\"2-权限判断\"><a href=\"#2-权限判断\" class=\"headerlink\" title=\"2.权限判断\"></a>2.权限判断</h2><p>​\t在html页面中可以使用sec:authorize&#x3D;”表达式”进行权限控制，判断是否显示某些内容。表达式的内容和access(表达式)的用法相同。如果用户具有指定的权限，则显示对应的内容；如果表达式不成立，则不显示对应的元素。</p>\n<h3 id=\"2-1不同权限的用户显示不同的按钮\"><a href=\"#2-1不同权限的用户显示不同的按钮\" class=\"headerlink\" title=\"2.1不同权限的用户显示不同的按钮\"></a>2.1不同权限的用户显示不同的按钮</h3><h4 id=\"2-1-1设置用户角色和权限\"><a href=\"#2-1-1设置用户角色和权限\" class=\"headerlink\" title=\"2.1.1设置用户角色和权限\"></a>2.1.1设置用户角色和权限</h4><p>​\t设定用户具有admin，&#x2F;insert，&#x2F;delete权限ROLE_abc角色。</p>\n<pre><code class=\"java\">return new User(username,password, \n                AuthorityUtils.commaSeparatedStringToAuthorityList(&quot;admin,ROLE_abc,/insert,/delete&quot;));\n</code></pre>\n<h4 id=\"2-1-2控制页面显示效果\"><a href=\"#2-1-2控制页面显示效果\" class=\"headerlink\" title=\"2.1.2控制页面显示效果\"></a>2.1.2控制页面显示效果</h4><p>在页面中根据用户权限和角色判断页面中显示的内容</p>\n<pre><code class=\"html\">通过权限判断：\n&lt;button sec:authorize=&quot;hasAuthority(&#39;/insert&#39;)&quot;&gt;新增&lt;/button&gt;\n&lt;button sec:authorize=&quot;hasAuthority(&#39;/delete&#39;)&quot;&gt;删除&lt;/button&gt;\n&lt;button sec:authorize=&quot;hasAuthority(&#39;/update&#39;)&quot;&gt;修改&lt;/button&gt;\n&lt;button sec:authorize=&quot;hasAuthority(&#39;/select&#39;)&quot;&gt;查看&lt;/button&gt;\n&lt;br/&gt;\n通过角色判断：\n&lt;button sec:authorize=&quot;hasRole(&#39;abc&#39;)&quot;&gt;新增&lt;/button&gt;\n&lt;button sec:authorize=&quot;hasRole(&#39;abc&#39;)&quot;&gt;删除&lt;/button&gt;\n&lt;button sec:authorize=&quot;hasRole(&#39;abc&#39;)&quot;&gt;修改&lt;/button&gt;\n&lt;button sec:authorize=&quot;hasRole(&#39;abc&#39;)&quot;&gt;查看&lt;/button&gt;\n</code></pre>\n<h1 id=\"十三、SpringSecurity-的”跨域”问题\"><a href=\"#十三、SpringSecurity-的”跨域”问题\" class=\"headerlink\" title=\"十三、SpringSecurity 的”跨域”问题\"></a>十三、SpringSecurity 的”跨域”问题</h1><p>​\t浏览器出于安全的考虑，使用 XMLHttpRequest对象发起 HTTP请求时必须遵守同源策略，否则就是跨域的HTTP请求，默认情况下是被禁止的。 同源策略要求源相同才能正常进行通信，即协议、域名、端口号都完全一致。 </p>\n<p>​\t前后端分离项目，前端项目和后端项目一般都不是同源的，所以肯定会存在跨域请求的问题。</p>\n<p>​\t所以我们就要处理一下，让前端能进行跨域请求。</p>\n<h2 id=\"①先对SpringBoot配置，运行跨域请求\"><a href=\"#①先对SpringBoot配置，运行跨域请求\" class=\"headerlink\" title=\"①先对SpringBoot配置，运行跨域请求\"></a>①先对SpringBoot配置，运行跨域请求</h2><p>这里的方式多种多想可以 配置类，也可以对跨域的请求直接加注解 ，自己视情况而定</p>\n<pre><code class=\"java\">@Configuration\npublic class CorsConfig implements WebMvcConfigurer &#123;\n\n    @Override\n    public void addCorsMappings(CorsRegistry registry) &#123;\n      // 设置允许跨域的路径\n        registry.addMapping(&quot;/**&quot;)\n                // 设置允许跨域请求的域名\n                .allowedOriginPatterns(&quot;*&quot;)\n                // 是否允许cookie\n                .allowCredentials(true)\n                // 设置允许的请求方式\n                .allowedMethods(&quot;GET&quot;, &quot;POST&quot;, &quot;DELETE&quot;, &quot;PUT&quot;)\n                // 设置允许的header属性\n                .allowedHeaders(&quot;*&quot;)\n                // 跨域允许时间\n                .maxAge(3600);\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"②开启SpringSecurity的跨域访问\"><a href=\"#②开启SpringSecurity的跨域访问\" class=\"headerlink\" title=\"②开启SpringSecurity的跨域访问\"></a>②开启SpringSecurity的跨域访问</h2><p>由于我们的资源都会收到SpringSecurity的保护，所以想要跨域访问还要让SpringSecurity运行跨域访问。</p>\n<pre><code class=\"java\">    @Override\n    protected void configure(HttpSecurity http) throws Exception &#123;\n        http\n                //关闭csrf\n                .csrf().disable()\n                //不通过Session获取SecurityContext\n                .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)\n                .and()\n                .authorizeRequests()\n                // 对于登录接口 允许匿名访问\n                .antMatchers(&quot;/user/login&quot;).anonymous()\n                // 除上面外的所有请求全部需要鉴权认证\n                .anyRequest().authenticated();\n\n        //添加过滤器\n        http.addFilterBefore(jwtAuthenticationTokenFilter, UsernamePasswordAuthenticationFilter.class);\n\n        //配置异常处理器\n        http.exceptionHandling()\n                //配置认证失败处理器\n                .authenticationEntryPoint(authenticationEntryPoint)\n                .accessDeniedHandler(accessDeniedHandler);\n\n        //允许跨域\n        http.cors();\n    &#125;\n</code></pre>\n<h1 id=\"十三、退出登录\"><a href=\"#十三、退出登录\" class=\"headerlink\" title=\"十三、退出登录\"></a>十三、退出登录</h1><p>​\t用户只需要向Spring Security项目中发送&#x2F;logout退出请求即可。</p>\n<h2 id=\"1-退出实现\"><a href=\"#1-退出实现\" class=\"headerlink\" title=\"1.退出实现\"></a>1.退出实现</h2><p>实现退出非常简单，只要在页面中添加&#x2F;logout的超链接即可。</p>\n<pre><code class=\"html\">&lt;a href=&quot;/logout&quot;&gt;退出登录&lt;/a&gt;\n</code></pre>\n<p>​\t为了实现更好的效果，通常添加退出的配置。默认的退出url为&#x2F;logout，退出成功后跳转到&#x2F;login?logout</p>\n<p>​\t如果不希望使用默认值，可以通过下面的方法进行修改。</p>\n<pre><code class=\"java\">http.logout()     \n    .logoutUrl(**&quot;/logout&quot;**)     \n    .logoutSuccessUrl(**&quot;/login.html&quot;**);\n</code></pre>\n<h2 id=\"2-logout其他常用配置源码解读\"><a href=\"#2-logout其他常用配置源码解读\" class=\"headerlink\" title=\"2.logout其他常用配置源码解读\"></a>2.logout其他常用配置源码解读</h2><h3 id=\"2-1-addLogoutHandler-LogoutHandler\"><a href=\"#2-1-addLogoutHandler-LogoutHandler\" class=\"headerlink\" title=\"2.1.addLogoutHandler(LogoutHandler)\"></a>2.1.addLogoutHandler(LogoutHandler)</h3><p>​\t默认是contextLogoutHandler</p>\n<p>​\t默认实例内容</p>\n<img data-src=\"/2022/10/07/Spring_Family/SpringSecurity/springSecurity-37.jpg\" class=\"\">\n\n\n<h3 id=\"2-2clearAuthentication-boolean\"><a href=\"#2-2clearAuthentication-boolean\" class=\"headerlink\" title=\"2.2clearAuthentication(boolean)\"></a>2.2clearAuthentication(boolean)</h3><p>​\t是否清除认证状态，默认为true</p>\n<h5 id=\"2-3invalidateHttpSession-boolean\"><a href=\"#2-3invalidateHttpSession-boolean\" class=\"headerlink\" title=\"2.3invalidateHttpSession(boolean)\"></a>2.3invalidateHttpSession(boolean)</h5><p>​\t是否销毁HttpSession对象，默认为true</p>\n<h3 id=\"2-4logoutSuccessHandler-LogoutSuccessHandler\"><a href=\"#2-4logoutSuccessHandler-LogoutSuccessHandler\" class=\"headerlink\" title=\"2.4logoutSuccessHandler(LogoutSuccessHandler)\"></a>2.4logoutSuccessHandler(LogoutSuccessHandler)</h3><p>​\t退出成功处理器。</p>\n<p>​\t也可以自己进行定义退出成功处理器。只要实现了LogoutSuccessHandler接口。与之前讲解的登录成功处理器和登录失败处理器极其类似。</p>\n<h1 id=\"十四、Spring-Security-中-CSRF\"><a href=\"#十四、Spring-Security-中-CSRF\" class=\"headerlink\" title=\"十四、Spring Security 中 CSRF\"></a>十四、Spring Security 中 CSRF</h1><p>​\t从刚开始学习Spring Security时，在配置类中一直存在这样一行代码：http.csrf().disable();如果没有这行代码导致用户无法被认证。这行代码的含义是：关闭csrf防护。</p>\n<h2 id=\"1-什么是CSRF\"><a href=\"#1-什么是CSRF\" class=\"headerlink\" title=\"1.什么是CSRF\"></a>1.什么是CSRF</h2><p>​\tCSRF（Cross-site request forgery）跨站请求伪造，也被称为“One Click Attack” 或者Session Riding。通过伪造用户请求访问受信任站点的非法请求访问。</p>\n<p>​\t跨域：只要网络协议，ip地址，端口中任何一个不相同就是跨域请求。</p>\n<p>​\t客户端与服务进行交互时，由于http协议本身是无状态协议，所以引入了cookie进行记录客户端身份。在cookie中会存放session id用来识别客户端身份的。在跨域的情况下，session id可能被第三方恶意劫持，通过这个session id向服务端发起请求时，服务端会认为这个请求是合法的，可能发生很多意想不到的事情。</p>\n<h2 id=\"2-Spring-Security中CSRF\"><a href=\"#2-Spring-Security中CSRF\" class=\"headerlink\" title=\"2.Spring Security中CSRF\"></a>2.Spring Security中CSRF</h2><p>​\t从Spring Security4开始CSRF防护默认开启。默认会拦截请求。进行CSRF处理。CSRF为了保证不是其他第三方网站访问，要求访问时携带参数名为_csrf值为token(token在服务端产生)的内容，如果token和服务端的token匹配成功，则正常访问。 </p>\n<h3 id=\"2-1实现步骤-1\"><a href=\"#2-1实现步骤-1\" class=\"headerlink\" title=\"2.1实现步骤\"></a>2.1实现步骤</h3><h4 id=\"2-1-1-编写控制器方法\"><a href=\"#2-1-1-编写控制器方法\" class=\"headerlink\" title=\"2.1.1 编写控制器方法\"></a>2.1.1 编写控制器方法</h4><p>​\t编写控制器方法，跳转到templates中login.html页面。</p>\n<pre><code class=\"java\">@GetMapping(&quot;/showLogin&quot;)\npublic String showLogin() &#123;\n    return &quot;login&quot;;\n&#125;\n</code></pre>\n<h4 id=\"2-1-2新建login-html\"><a href=\"#2-1-2新建login-html\" class=\"headerlink\" title=\"2.1.2新建login.html\"></a>2.1.2新建login.html</h4><p>在项目resources下新建templates文件夹，并在文件夹中新建login.html页面。红色部分是必须存在的否则无法正常登录。</p>\n<pre><code class=\"html\">&lt;!DOCTYPE html&gt;\n&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;\n      xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;title&gt;Title&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;form action = &quot;/login&quot; method=&quot;post&quot;&gt;\n    &lt;input type=&quot;hidden&quot; th:value=&quot;$&#123;_csrf.token&#125;&quot; name=&quot;_csrf&quot; th:if=&quot;$&#123;_csrf&#125;&quot;/&gt;\n    用户名：&lt;input type=&quot;text&quot; name=&quot;username&quot;/&gt;&lt;br/&gt;\n    密码:&lt;input type=&quot;password&quot; name=&quot;password&quot;/&gt;&lt;br/&gt;\n    &lt;input type=&quot;submit&quot; value=&quot;登录&quot;/&gt;\n&lt;/form&gt;\n&lt;/body&gt;\n&lt;/html&gt;     \n</code></pre>\n<h4 id=\"2-1-3修改配置类\"><a href=\"#2-1-3修改配置类\" class=\"headerlink\" title=\"2.1.3修改配置类\"></a>2.1.3修改配置类</h4><p>在配置类中注释掉CSRF防护失效</p>\n<pre><code class=\"java\">//关闭csrf防护\n//http.csrf().disable();\n</code></pre>\n",
            "tags": [
                "框架",
                "Spring",
                "SpringSecurity"
            ]
        },
        {
            "id": "http://example.com/2022/10/06/bkBasic/hexo/",
            "url": "http://example.com/2022/10/06/bkBasic/hexo/",
            "title": "hexo",
            "date_published": "2022-10-06T06:50:57.000Z",
            "content_html": "<hr>\n<p>title: hexo<br>date: 2022-10-06 14:53:52<br>categories:<br>    - 基础使用<br>tags:<br>    - 环境搭建<br>    - 博客</p>\n<hr>\n<h1 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h1><p><code>hexo</code>是一个基于nodejs的静态博客网站生成器，作者是来自台湾的<code>Tommy Chen</code>，为许多技术博客的博主所青睐，主要有如下的一些优点：</p>\n<ul>\n<li><p>支持Markdown语法，编辑简单，排版优美；</p>\n</li>\n<li><p>能够快速生成静态html文件；</p>\n</li>\n<li><p>部署容易，接口简单； 兼容于各大主流操作系统；</p>\n</li>\n<li><p>社区主题、插件很多，遇到问题的时候能查到的参考材料也很多。</p>\n</li>\n</ul>\n<p>Hexo官方文档：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL3poLWNuL2RvY3Mv\">https://hexo.io/zh-cn/docs/</span></p>\n<p>Gitee Pages：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRlZS5jb20vaGVscC9hcnRpY2xlcy80MTM2I2FydGljbGUtaGVhZGVyMA==\">https://gitee.com/help/articles/4136#article-header0</span></p>\n<h1 id=\"环境配置\"><a href=\"#环境配置\" class=\"headerlink\" title=\"环境配置\"></a>环境配置</h1><p>搭建hexo首先需要有nodejs的环境，可以从官网直接下载。</p>\n<img data-src=\"/2022/10/06/bkBasic/hexo/2xKvaPTDoyZcFbp.png\" class=\"\" title=\"nodejs\">\n\n<h1 id=\"生成博客\"><a href=\"#生成博客\" class=\"headerlink\" title=\"生成博客\"></a>生成博客</h1><h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><p>有了npm包管理软件，安装hexo就很方便了，只需要一行命令：</p>\n<pre><code class=\"shell\">npm install node # homebrew安装nodejs\n</code></pre>\n<p>其中-g参数表示全局安装，没有这个参数就只在当前目录下安装，建议全局安装。</p>\n<h2 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化\"></a>初始化</h2><p>运行命令：</p>\n<pre><code class=\"shell\">hexo init\n</code></pre>\n<pre><code class=\"shell\">INFO  Cloning hexo-starter https://github.com/hexojs/hexo-starter.git\nINFO  Install dependencies\n# 一些可能的中间信息\nINFO  Start blogging with Hexo!\n</code></pre>\n<p>然后进入博客目录：</p>\n<blockquote>\n<p> cd “博客目录”</p>\n</blockquote>\n<p>安装博客需要的其他支持：</p>\n<pre><code class=\"sh\">npm install # 安装的依赖项在package.json文件的dependencies字段中可以看到\n</code></pre>\n<h2 id=\"博客项目目录结构介绍\"><a href=\"#博客项目目录结构介绍\" class=\"headerlink\" title=\"博客项目目录结构介绍\"></a>博客项目目录结构介绍</h2><p>查看目录结构：</p>\n<pre><code class=\"sh\">tree -L 1 \n</code></pre>\n<p>结果如下：</p>\n<blockquote>\n<p>.<br>├── _config.landscape.yml<br>├── _config.yml<br>├── node_modules<br>├── package-lock.json<br>├── package.json<br>├── scaffolds<br>├── source<br>└── themes</p>\n</blockquote>\n<p>各部分的含义：</p>\n<ul>\n<li>`_config.yml &#96;<ul>\n<li>为全局配置文件，网站的很多信息都在这里配置，比如说网站名称，副标题，描述，作者，语言，主题等等。具体可以参考官方文档：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL3poLWNuL2RvY3MvY29uZmlndXJhdGlvbi5odG1sJUUzJTgwJTgy\">https://hexo.io/zh-cn/docs/configuration.html。</span></li>\n</ul>\n</li>\n<li><code>_scaffolds</code><ul>\n<li>骨架文件，是生成新页面或者新博客的模版。可以根据需求编辑，当<code>hexo</code>生成新博客的时候，会用这里面的模版进行初始化。</li>\n</ul>\n</li>\n<li><code>_source</code><ul>\n<li>这个文件夹下面存放的是网站的<code>markdown</code>源文件，里面有一个<code>_post</code>文件夹，所有的<code>.md</code>博客文件都会存放在这个文件夹下。现在，你应该能看到里面有一个<code>hello-world.md</code>文件。_</li>\n</ul>\n</li>\n<li><code>_themes</code><ul>\n<li>网站主题目录，<code>hexo</code>有非常丰富的主题支持，主题目录会存放在这个目录下面。</li>\n<li>我们后续会以默认主题来演示，更多的主题参见：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL3RoZW1lcy8=\">https://hexo.io/themes/</span></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"生成新文章\"><a href=\"#生成新文章\" class=\"headerlink\" title=\"生成新文章\"></a>生成新文章</h2><pre><code class=\"sh\">hexo new post &quot;test&quot; # 会在 source/_posts/ 目录下生成文件 ‘test.md’，打开编辑\nhexo generate        # 生成静态HTML文件到 /public 文件夹中\nhexo server          # 本地运行server服务预览，打开 http://localhost:4000 即可预览你的博客\n</code></pre>\n<p><strong>本地预览效果：</strong></p>\n<img data-src=\"/2022/10/06/bkBasic/hexo/image-20221006120456734.png\" class=\"\" title=\"image-20221006120456734\">\n\n<p>这是hexo的默认主题，更多的主题可以从官网下载。</p>\n<p>更详细的hexo命令可以查看文档：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL3poLWNuL2RvY3MvY29tbWFuZHM=\">https://hexo.io/zh-cn/docs/commands</span></p>\n<h1 id=\"Hexo配置并部署\"><a href=\"#Hexo配置并部署\" class=\"headerlink\" title=\"Hexo配置并部署\"></a>Hexo配置并部署</h1><blockquote>\n<p>提前对要提交的仓库配置ssh</p>\n</blockquote>\n<h2 id=\"1-安装部署工具\"><a href=\"#1-安装部署工具\" class=\"headerlink\" title=\"1.安装部署工具\"></a>1.安装部署工具</h2><pre><code class=\"sh\">npm install hexo-deployer-git --save\n</code></pre>\n<h2 id=\"2-配置部署信息\"><a href=\"#2-配置部署信息\" class=\"headerlink\" title=\"2.配置部署信息\"></a>2.配置部署信息</h2><p>站点配置文件_config.yml</p>\n<pre><code class=\"yml\">deploy:\n  type: git\n  repo: &lt;repository url&gt; # 输入你的仓库地址\n  branch: [branch] # 输入分支\n  token:   #token\n</code></pre>\n<blockquote>\n<p>deploy:</p>\n<p> type: git</p>\n<p> repo: <span class=\"exturl\" data-url=\"bWFpbHRvOiYjeDY3OyYjMTA1OyYjeDc0OyYjeDQwOyYjeDY3OyYjeDY5OyYjMTE2OyYjeDY1OyYjMTAxOyYjNDY7JiN4NjM7JiMxMTE7JiN4NmQ7\">&#x67;&#105;&#x74;&#x40;&#x67;&#x69;&#116;&#x65;&#101;&#46;&#x63;&#111;&#x6d;</span>:cysheng&#x2F;cysheng.git # 输入你的仓库地址</p>\n<p> branch: master # 输入分支</p>\n</blockquote>\n<h2 id=\"3-部署\"><a href=\"#3-部署\" class=\"headerlink\" title=\"3.部署\"></a>3.部署</h2><pre><code class=\"sh\"> hexo clean  \n hexo g  \n hexo d \n</code></pre>\n<ul>\n<li><p>hexo clean</p>\n<p>清除缓存文件 (db.json) 和已生成的静态文件 (public)。</p>\n</li>\n<li><p>hexo g</p>\n<p>hexo解析站点文件夹，生成一个public文件夹（只包含浏览器可以解析的html、css、js），也就是我们需要部署的文件夹。</p>\n</li>\n<li><p>hexo d</p>\n<p>部署，即将我们的public文件夹推送到我们配置的仓库</p>\n</li>\n</ul>\n<h2 id=\"4-开启Gitee-Pages服务\"><a href=\"#4-开启Gitee-Pages服务\" class=\"headerlink\" title=\"4.开启Gitee Pages服务\"></a>4.开启Gitee Pages服务</h2><p>找到新创建的仓库-&gt;【服务】-&gt;【Gitee Pages】  <img data-src=\"/2022/10/06/bkBasic/hexo/image-20221006120734926.png\" class=\"\" title=\"hexo&#x2F;image-20221006120734926\"></p>\n<p>如图，选择部署分支，部署目录</p>\n<ul>\n<li><p>部署分支，与本地hexo配置一致</p>\n</li>\n<li><p>部署目录，不填即整个仓库</p>\n</li>\n<li><p>强制使用https</p>\n<p>一个是进行加密，还有一个是我在用next主题时使用http访问会有跨域问题导致图标显示不出来</p>\n</li>\n<li><p>点击启动</p>\n</li>\n<li><p>访问给出的网站地址（以我的为例：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9jeXNoZW5nLmdpdGVlLmlvKS8=\">https://cysheng.gitee.io）</span></p>\n</li>\n</ul>\n<h1 id=\"hexo-框架常用的指令：\"><a href=\"#hexo-框架常用的指令：\" class=\"headerlink\" title=\"hexo 框架常用的指令：\"></a>hexo 框架常用的指令：</h1><table>\n<thead>\n<tr>\n<th align=\"left\">指令</th>\n<th align=\"left\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>hexo clean &amp;&amp; hexo g</code></td>\n<td align=\"left\">清除本地项目并重新生成 （重新部署时使用）</td>\n</tr>\n<tr>\n<td align=\"left\"><code>hexo g</code></td>\n<td align=\"left\">重新生成</td>\n</tr>\n<tr>\n<td align=\"left\"><code>Hexo s</code></td>\n<td align=\"left\">开启本地预览</td>\n</tr>\n<tr>\n<td align=\"left\"><code>Hexo d</code></td>\n<td align=\"left\">推送到github</td>\n</tr>\n</tbody></table>\n<h1 id=\"功能设置\"><a href=\"#功能设置\" class=\"headerlink\" title=\"功能设置\"></a>功能设置</h1><h2 id=\"标题和分类\"><a href=\"#标题和分类\" class=\"headerlink\" title=\"标题和分类\"></a>标题和分类</h2><p>在文章开头我们可以设置 FontMatter，例如</p>\n<pre><code class=\"yml\">---\ntitle: jQuery对表单的操作及更多应用 # 标题\ndate: 2022-01-07 22:53:43 # 创建时间\ncategories: # 分类，级别递减\n- web前端 # 一级分类\n- web前端2 # 二级分类\ntags: # 标签，没有级别\n    - a1\n    - a2\n---\n</code></pre>\n<p>​\t为了简化我们的操作，所以我们可以以设置模板，在 <code>/scaffolds</code> 下的 <code>draft.md</code> 、<code>page.md</code> 、 <code>post.md</code>  我们用来设置模板，例如我们最常使用的<code>post</code> 目录下的文件，所以我们配置一下<code>post.md</code></p>\n<pre><code class=\"yaml\">---\ntitle: &#123;&#123; title &#125;&#125;\ndate: &#123;&#123; date &#125;&#125;\ncomments:\ntags:\n---\n</code></pre>\n<p><strong>问题</strong></p>\n<p>如果我们在没有找到 tags 、categories 、link 、about文件时，我们手动创建</p>\n<pre><code class=\"sh\">hexo new page tags\nhexo new page categories \nhexo new page link \nhexo new page about\n</code></pre>\n<p>成功后，提示</p>\n<pre><code class=\"sh\">INFO  Created: ~/Documents/blog/source/xxx/index.md\n</code></pre>\n<p>根据上面的路径，找到<code>index.md</code>这个文件，打开后默认内容是这样的：</p>\n<pre><code class=\"yaml\">---\ntitle: 文章分类\ndate: 2022-01-07 22:53:43\ntype: &quot;categories&quot; # 哪个文件就是那个类型\nlayout: &quot;categories&quot; # 哪个文件就是那个类型\n---\n</code></pre>\n<p>最后清除缓存，重新启动就行了 </p>\n<pre><code class=\"sh\">hexo cl &amp;&amp; hexo g &amp;&amp; hexo s\n</code></pre>\n<h2 id=\"搜索\"><a href=\"#搜索\" class=\"headerlink\" title=\"搜索\"></a>搜索</h2><h3 id=\"1、注册账号\"><a href=\"#1、注册账号\" class=\"headerlink\" title=\"1、注册账号\"></a>1、注册账号</h3><p>官网：<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYWxnb2xpYS5jb20vdXNlcnMvc2lnbl9pbg==\">https://www.algolia.com/users/sign_in</span></p>\n<h3 id=\"2、之后在左侧导航栏中找到Search\"><a href=\"#2、之后在左侧导航栏中找到Search\" class=\"headerlink\" title=\"2、之后在左侧导航栏中找到Search\"></a>2、之后在左侧导航栏中找到Search</h3><img data-src=\"/2022/10/06/bkBasic/hexo/image-20221007104401652.png\" class=\"\" title=\"image-20221007104401652\">\n\n<h3 id=\"3、创建Index\"><a href=\"#3、创建Index\" class=\"headerlink\" title=\"3、创建Index\"></a>3、创建Index</h3><img data-src=\"/2022/10/06/bkBasic/hexo/image-20221007104429043.png\" class=\"\" title=\"image-20221007104429043\">\n\n<img data-src=\"/2022/10/06/bkBasic/hexo/image-20221007104449209.png\" class=\"\" title=\"image-20221007104449209\">\n\n<p><strong>随便写</strong></p>\n<h3 id=\"4、创建APPID\"><a href=\"#4、创建APPID\" class=\"headerlink\" title=\"4、创建APPID\"></a>4、创建APPID</h3><img data-src=\"/2022/10/06/bkBasic/hexo/image-20221007105625601.png\" class=\"\" title=\"image-20221007105625601\">\n\n<img data-src=\"/2022/10/06/bkBasic/hexo/image-20221007105704120.png\" class=\"\" title=\"image-20221007105704120\">\n\n<p>这两个后面有用</p>\n<img data-src=\"/2022/10/06/bkBasic/hexo/image-20221007105750168.png\" class=\"\" title=\"image-20221007105750168\">\n\n<blockquote>\n<p>Indices 是我们上面创建 index </p>\n</blockquote>\n<img data-src=\"/2022/10/06/bkBasic/hexo/20210516112405506.png\" class=\"\" title=\"在这里插入图片描述\">\n\n\n\n<h3 id=\"5、到博客根目录下安装hexo-algolia\"><a href=\"#5、到博客根目录下安装hexo-algolia\" class=\"headerlink\" title=\"5、到博客根目录下安装hexo-algolia\"></a>5、到博客根目录下安装hexo-algolia</h3><pre><code class=\"sh\">npm install hexo-algolia --save\n</code></pre>\n<h3 id=\"6、前往站点根目录打开-config-yml添加以下代码\"><a href=\"#6、前往站点根目录打开-config-yml添加以下代码\" class=\"headerlink\" title=\"6、前往站点根目录打开_config.yml添加以下代码\"></a>6、前往站点根目录打开_config.yml添加以下代码</h3><blockquote>\n<p><strong>注意：</strong>这是对全局的配置，所以是根目录的配置</p>\n</blockquote>\n<pre><code class=\"sh\">algolia:\n  appId:  &quot;***&quot;  #上面的application ID\n  apiKey:  &quot;****&quot;  # 上面的 Search-Only API Key\n  adminApiKey:  &quot;***&quot;  #上面的 Admin API Keys\n  chunkSize:  5000\n  indexName:  &quot;test001&quot; # Indices的index\n  fields: # 要搜索的词条范围\n    - title #必须配置\n    - path #必须配置\n    - categories #推荐配置\n    - content:strip:truncate,0,2000\n    - tags\n</code></pre>\n<p>例如：</p>\n<pre><code class=\"yml\">algolia:\n  appId: &quot;Z7A3XW4R2I&quot;\n  apiKey: &quot;12db1ad54372045549ef465881c17e743&quot;\n  adminApiKey: &quot;40321c7c207e7f73b63a19aa24c4761b&quot;\n  chunkSize: 5000\n  indexName: &quot;my-hexo-blog&quot;\n  fields:\n    - content:strip:truncate,0,500\n    - excerpt:strip\n    - gallery\n    - permalink\n    - photos\n    - slug\n    - tags\n    - title\n</code></pre>\n<h3 id=\"7、设置HEXO-ALGOLIA-INDEXING-KEY\"><a href=\"#7、设置HEXO-ALGOLIA-INDEXING-KEY\" class=\"headerlink\" title=\"7、设置HEXO_ALGOLIA_INDEXING_KEY\"></a>7、设置HEXO_ALGOLIA_INDEXING_KEY</h3><p>在博客根目录右击git bash</p>\n<pre><code class=\"sh\"># export HEXO_ALGOLIA_INDEXING_KEY=&quot;你刚才新创建的 APPKEY、appId、adminApiKey &quot;一个试一下 \nexport HEXO_ALGOLIA_INDEXING_KEY=&quot;******&quot; \n# 将我们的信息上川岛algolia\nhexo algolia\n</code></pre>\n<h3 id=\"8、修改主题内的-config-yml\"><a href=\"#8、修改主题内的-config-yml\" class=\"headerlink\" title=\"8、修改主题内的_config.yml\"></a>8、修改主题内的_config.yml</h3><blockquote>\n<p><strong>注意：</strong> 这是是对主题的配置</p>\n</blockquote>\n<pre><code class=\"yml\">#Algolia Search\nalgolia_search:\n  enable: true\n  hits:\n    per_page: 6\n  labels:\n    input_placeholder: Search for Posts !\n    hits_empty: &#39;我们没有找到任何搜索结果：$&#123;query&#125;&#39;\n    hits_stats: &#39;找到约$&#123;hits&#125;条结果 (用时$&#123;time&#125;ms)&#39;\n\n# local searach\nlocal_sreach:\n  enable : false\n</code></pre>\n<h3 id=\"9、启动即可\"><a href=\"#9、启动即可\" class=\"headerlink\" title=\"9、启动即可\"></a>9、启动即可</h3><pre><code class=\"sh\">hexo s\n</code></pre>\n<h3 id=\"10、测试\"><a href=\"#10、测试\" class=\"headerlink\" title=\"10、测试\"></a>10、测试</h3><img data-src=\"/2022/10/06/bkBasic/hexo/image-20221007123724497.png\" class=\"\" title=\"image-20221007123724497\">\n\n<p>参考：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1MTczNDA0L2FydGljbGUvZGV0YWlscy8xMjI4NjEzMjE=\">https://blog.csdn.net/qq_45173404/article/details/122861321</span></p>\n<h2 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h2><p>&#x3D;&#x3D;toc 插件是：添加生成文章目录的一个插件&#x3D;&#x3D;</p>\n<p>一、安装(这里是hexo的路径下，也就是博客根目录下)</p>\n<pre><code class=\"shell\">npm install hexo-toc --save\n</code></pre>\n<p>二、配置博客根目录下的_config.yml文件：</p>\n<pre><code class=\"yml\">toc:  \n  maxdepth: 3 \n</code></pre>\n<p>在最后的空白处添加</p>\n<p>三、在markdown里使用</p>\n<p>在Markdown中需要显示文章目录的地方添加</p>\n<pre><code class=\"shell\">&lt;!-- toc --&gt;\n</code></pre>\n<p>然后就会将他&#x3D;&#x3D;后面&#x3D;&#x3D;的内容按照标题级别分层</p>\n<h2 id=\"图片显示\"><a href=\"#图片显示\" class=\"headerlink\" title=\"图片显示\"></a>图片显示</h2><h3 id=\"方法一：\"><a href=\"#方法一：\" class=\"headerlink\" title=\"方法一：\"></a>方法一：</h3><p><strong>typroa设置</strong></p>\n<p>打开typora，选择：偏好设置 - 图像 - 插入图片时，做如下更改：</p>\n<blockquote>\n<p>复制到指定路径</p>\n<p>.&#x2F;${filename}</p>\n</blockquote>\n<p>当插入图片时，会生成一个和文件名相同的文件夹，并将图片存入这个文件夹内。</p>\n<p><strong>Hexo 设置</strong></p>\n<ol>\n<li>安装 <code>hexo-renderer-marked</code></li>\n</ol>\n<pre><code class=\"sh\">npm install hexo-renderer-marked --save\n</code></pre>\n<ol start=\"2\">\n<li>之后更改 _config.yml 配置</li>\n</ol>\n<pre><code class=\"yml\">post_asset_folder: true \n</code></pre>\n<p>安装插件<code>hexo-image-link </code></p>\n<pre><code class=\"shell\">npm install hexo-image-link --save\n</code></pre>\n<p>此时，在typora 文件中正常显示的图片，在hexo发布后依旧能正常显示。</p>\n<p><strong>NOTE：</strong></p>\n<ol>\n<li>如果想用插件 <code>Hexo-renderer-markdown-it </code>（推荐）代替 <code>Hexo-renderer-marked </code></li>\n</ol>\n<pre><code class=\"sh\">npm uninstall hexo-renderer-marker --save  #卸载 marked \n\nnpm install hexo-renderer-markdown-it --save  #安装markdown-it\n</code></pre>\n<ol start=\"2\">\n<li>路径转换的解释</li>\n</ol>\n<p>假设：<br>文件名: .&#x2F;test.md</p>\n<p>图片路径: .&#x2F;test&#x2F;image.jpg</p>\n<pre><code>当插入图片 image.jpg 到 test.md 中时，typora 的引用路径为\n &#123;% asset_img image.jpg  %&#125; \n\nHexo 发布后的引用路径为\n![](image.jpg) \n</code></pre>\n<p>因此，typora的md文件引入hexo时，应转换路径。即删掉图片路径中的 “test&#x2F;“部分；（此时md文件已不能正常显示图片，而 hexo server 可正常显示）</p>\n<p>插件hexo-image-link帮助实现了这种路径转换。</p>\n<p>安装后，typora 文件中正常显示的图片，在hexo发布后依旧能正常显示。</p>\n<h3 id=\"方法2：\"><a href=\"#方法2：\" class=\"headerlink\" title=\"方法2：\"></a>方法2：</h3><blockquote>\n<p>同样的思路，相对路径，</p>\n</blockquote>\n<p>下载插件</p>\n<pre><code class=\"shell\">npm install hexo-asset-img --save\n</code></pre>\n<blockquote>\n<p>文件要求：</p>\n<p>​\t图片必须在 xx.md 同一级目录下的同名文件中存储，也就是在xx 文件夹下，所以md文档的图片路径就是\t&#x3D;&#x3D;![图片注释](xx&#x2F;图片名)&#x3D;&#x3D;</p>\n</blockquote>\n<h2 id=\"每篇文章的log设置\"><a href=\"#每篇文章的log设置\" class=\"headerlink\" title=\"每篇文章的log设置\"></a>每篇文章的log设置</h2><pre><code>---\n***\ncover: 图床链接/图片路径\n---\n</code></pre>\n<h1 id=\"主题\"><a href=\"#主题\" class=\"headerlink\" title=\"主题\"></a>主题</h1><ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9hdXJvcmEudHJpZGlhbW9uZC50ZWNoL3poL2d1aWRlL2dldHRpbmctc3RhcnRlZC5odG1sIyVFNCVCRSU5RCVFOCVCNSU5NiVFNyU4RSVBRiVFNSVBMiU4Mw==\">aurora</span>    \t（最推荐）</li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9zaG9rYS5sb3N0eXUubWUvY29tcHV0ZXItc2NpZW5jZS9ub3RlL3RoZW1lLXNob2thLWRvYy8=\">shoka</span>        （好看，但是少东西，好多要自己配）</li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL25leHQtdGhlbWUvaGV4by10aGVtZS1uZXh0\">next</span>           （中等，但是好多人用，配东西好查的一批）</li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2plcnJ5YzEyNy9oZXhvLXRoZW1lLWJ1dHRlcmZseQ==\">butterfly  </span>（中等，要自己配一些）</li>\n</ul>\n<blockquote>\n<p>shoka</p>\n</blockquote>\n<pre><code class=\"shell\">npm i  hexo-renderer-multi-markdown-it --save #markdown解析的\nnpm i  hexo-autoprefixer --save\t\t#css\\html文件压缩的\nnpm i  hexo-algoliasearch --save\t#全文搜索的\nnpm i  hexo-symbols-count-time --save # 文字/时间统计\nnpm i  hexo-feed --save # 可选\nnpm un hexo-renderer-marked --save      #删除多余的库\n\ngit clone https://github.com/amehime/hexo-theme-shoka.git ./themes/shoka\n</code></pre>\n<p>_config.yml</p>\n<pre><code class=\"yaml\"># markdown渲染\nmarkdown:\n  render: # 渲染器设置\n    html: false # 过滤 HTML 标签\n    xhtmlOut: true # 使用 &#39;/&#39; 来闭合单标签 （比如 &lt;br /&gt;）。\n    breaks: true # 转换段落里的 &#39;\\n&#39; 到 &lt;br&gt;。\n    linkify: true # 将类似 URL 的文本自动转换为链接。\n    typographer: \n    quotes: &#39;“”‘’&#39;\n  plugins: # markdown-it 插件设置\n    - plugin:\n        name: markdown-it-toc-and-anchor\n        enable: true\n        options: # 文章目录以及锚点应用的 class 名称，shoka 主题必须设置成这样\n          tocClassName: &#39;toc&#39;\n          anchorClassName: &#39;anchor&#39;\n    - plugin:\n        name: markdown-it-multimd-table\n        enable: true\n        options:\n          multiline: true\n          rowspan: true\n          headerless: true\n    - plugin:\n        name: ./markdown-it-furigana\n        enable: true\n        options:\n          fallbackParens: &quot;()&quot;\n    - plugin:\n        name: ./markdown-it-spoiler\n        enable: true\n        options:\n          title: &quot;你知道得太多了&quot;\n\n# 压缩CSS/hTML\nminify:\n  html:\n    enable: true\n    exclude: # 排除 hexo-feed 用到的模板文件\n      - &#39;**/json.ejs&#39;\n      - &#39;**/atom.ejs&#39;\n      - &#39;**/rss.ejs&#39;\n  css:\n    enable: true\n    exclude:\n      - &#39;**/*.min.css&#39;\n  js:\n    enable: true\n    mangle:\n      toplevel: true\n    output:\n    compress:\n    exclude:\n      - &#39;**/*.min.js&#39;\n\n#css文件后缀\nautoprefixer:\n  exclude:\n    - &#39;*.min.css&#39;\n\n# 全文搜索\nalgolia:\n  appId: #Your appId\n  apiKey: #Your apiKey\n  adminApiKey: #Your adminApiKey\n  chunkSize: 5000\n  indexName: #&quot;shoka&quot;\n  fields:\n    - title #必须配置\n    - path #必须配置\n    - categories #推荐配置\n    - content:strip:truncate,0,2000\n    - gallery\n    - photos\n    - tags\n    \n</code></pre>\n<h2 id=\"未完成\"><a href=\"#未完成\" class=\"headerlink\" title=\"未完成\"></a>未完成</h2><h1 id=\"Netlify部署\"><a href=\"#Netlify部署\" class=\"headerlink\" title=\"Netlify部署\"></a>Netlify部署</h1><blockquote>\n<p><strong>前提</strong>：</p>\n<pre><code>在github上建立一个仓库，权限无所谓\n上传也只需要传编译后的public文件就行了\n</code></pre>\n</blockquote>\n<ul>\n<li><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubmV0bGlmeS5jb20v\">Netlify</span> 账号注册</p>\n</li>\n<li><p>添加新的站点</p>\n  <img data-src=\"/2022/10/06/bkBasic/hexo/image-20221013222215469.png\" class=\"\" title=\"image-20221013222215469\">\n\n  <img data-src=\"/2022/10/06/bkBasic/hexo/oSa6BOtIQ8WkZX1.png\" class=\"\" title=\"connect-github\">\n</li>\n<li><p>选取一个仓库，作为我们的资源地址</p>\n  <img data-src=\"/2022/10/06/bkBasic/hexo/image-20221013222447157.png\" class=\"\" title=\"image-20221013222447157\">\n</li>\n<li><p>一切默认，除了构建命令改成我们之前设置的<code>npm run netlify</code> ，当然也可以不设置</p>\n<p>  前提要在<code>package.json</code> 里面添加一个 <code>netlify</code> 命令 ，例如我们的：</p>\n<pre><code class=\"json\">&quot;scripts&quot;: &#123;\n        &quot;build&quot;: &quot;hexo generate&quot;,\n        &quot;clean&quot;: &quot;hexo clean&quot;,\n        &quot;deploy&quot;: &quot;hexo deploy&quot;,\n        &quot;server&quot;: &quot;hexo server&quot;,\n        // 每次提交会清除内容，然后重新建立项目，不要在项目中写这个注释，报错\n        &quot;netlify&quot;: &quot;npm run clean &amp;&amp; npm run build&quot; \n  &#125;,\n</code></pre>\n<p>  还要有将你的全部文件上传到github，才可以使用<code>npm</code></p>\n  <img data-src=\"/2022/10/06/bkBasic/hexo/p3P2NJaQzuIZnYs.png\" class=\"\" title=\"site-config\"></li>\n</ul>\n<blockquote>\n<p>这里BaseDirectory为空表示项目目录是仓库目录的根目录。</p>\n</blockquote>\n<ul>\n<li>构建完成后我们就能够看到一个URL，打开网址就是我们的个人博客了</li>\n</ul>\n<img data-src=\"/2022/10/06/bkBasic/hexo/image-20221013223348730.png\" class=\"\" title=\"image-20221013223348730\">\n\n<ul>\n<li><p>修改地址前缀（<strong>因为后缀不能改</strong>）</p>\n<p>  网站设置—》常规—》更改站点名，完成后缀是固定的 <code> *.netlify.app</code> ，要想改变就要买域名，然后配置域名的映射。</p>\n</li>\n<li><p>配置域名映射</p>\n  <img data-src=\"/2022/10/06/bkBasic/hexo/image-20221013223414819.png\" class=\"\" title=\"image-20221013223414819\">\n\n<ul>\n<li>配置域名的前提自然是要购买域名了，从任意域名服务商处购买一个域名。</li>\n</ul>\n  <img data-src=\"/2022/10/06/bkBasic/hexo/DFHYzywifpJTxqj.png\" class=\"\" title=\"domian-purchase\">\n\n<ul>\n<li>然后设置域名解析，类型为CNAME（DNS知识点参见计算机网络相关教程），内容为xxxxx.netlify.app，其中xxxxx为你自己设置的个性二级域名。</li>\n</ul>\n  <img data-src=\"/2022/10/06/bkBasic/hexo/5OVcw9ypvRKQePJ.png\" class=\"\" title=\"domain-resolve\">\n\n<ul>\n<li><p>设置完毕之后需要等待一段时间，因为DNS服务器需要一段时间来进行同步。</p>\n<p>  然后，我们还需要回到netlify中配置一下自己的用户域名，这样的话可以在国外获得netlify本身的CDN支持。</p>\n<ul>\n<li><p>在netlify设置用户域名。</p>\n  <img data-src=\"/2022/10/06/bkBasic/hexo/MDjxbIcWBEoLURA.png\" class=\"\" title=\"set-custom-domain\">\n\n<ul>\n<li><p>进行相关的配置，由于我们的域名本身已经配置了解析，这里会显示出来，不用再额外添加记录，只需要一路默认即可。</p>\n  <img data-src=\"/2022/10/06/bkBasic/hexo/cqwL9xF8Eov6yVa.png\" class=\"\" title=\"add-record\">\n\n  <img data-src=\"/2022/10/06/bkBasic/hexo/RTLcjynQYXbW9vI.png\" class=\"\" title=\"activate-dns\">\n</li>\n<li><p>设置一下netlify本身的对于国外CDN的支持。</p>\n  <img data-src=\"/2022/10/06/bkBasic/hexo/8v3ROjQc2WY9q7T.png\" class=\"\" title=\"netlify-cdn\">\n\n<p>  之后，我们就可以通过自己配置的域名访问自己的个人博客。</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>这里<code>https</code>访问需要在<code>netlify</code>中配置，否则应该只能<code>http</code>访问。<br><a href=\"https://s2.loli.net/2022/09/05/f3q8hPbG5vsImeY.png\"><img data-src=\"/2022/10/06/bkBasic/hexo/f3q8hPbG5vsImeY.png\" class=\"\" title=\"https-config\"></a><br>需要注意一下的是，此刻的https配置过程中的dns验证已经可以通过，但是证书检查会失败，等到后面clouldflare加速配置完成之后，这个问题 就可以解决了。所以暂时应该只能http访问。</p>\n</blockquote>\n<p>  <strong>但是，此刻我们的博客访问依然需要科学上网，因为我们还没有国内的CDN的支持，下面，我们来解决这个问题。</strong></p>\n</li>\n</ul>\n<h1 id=\"ClouldFlare加速\"><a href=\"#ClouldFlare加速\" class=\"headerlink\" title=\"ClouldFlare加速\"></a>ClouldFlare加速</h1><h2 id=\"介绍-1\"><a href=\"#介绍-1\" class=\"headerlink\" title=\"介绍\"></a>介绍</h2><p>Netlify 虽然已经提供了 CDN 加速，但在使用过程中发现国内访问还是比较慢，Cloudflare 相对于国内的七牛云、阿里云等云服务商的 CDN 速度会慢一些，但是它有免费版本，而且最重要的是域名不用备案。</p>\n<h2 id=\"加速步骤\"><a href=\"#加速步骤\" class=\"headerlink\" title=\"加速步骤\"></a>加速步骤</h2><ol>\n<li><p>注册<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuY2xvdWRmbGFyZS5jb20vemgtY24v\">Clouldflare</span>并登陆</p>\n</li>\n<li><p>添加站点</p>\n<ul>\n<li><a href=\"https://s2.loli.net/2022/09/05/rqNObP5dzE6GY83.png\"><img data-src=\"/2022/10/06/bkBasic/hexo/rqNObP5dzE6GY83.png\" class=\"\" title=\"add-site\"></a></li>\n<li><a href=\"https://s2.loli.net/2022/09/05/Dk3Y4BrltQeCOHI.png\"><img data-src=\"/2022/10/06/bkBasic/hexo/Dk3Y4BrltQeCOHI.png\" class=\"\" title=\"config-site\"></a></li>\n</ul>\n</li>\n<li><p>选择免费套餐</p>\n<ul>\n<li><a href=\"https://s2.loli.net/2022/09/05/SrhEAvmGZeqn8Co.png\"><img data-src=\"/2022/10/06/bkBasic/hexo/SrhEAvmGZeqn8Co.png\" class=\"\" title=\"choose-project\"></a></li>\n</ul>\n</li>\n<li><p>添加 DNS 记录</p>\n<ul>\n<li><p>一般情况下 Cloudflare 会检测出来几条 DNS 记录，类型大多数是A，或者AAAA，由于我们是转发，所以应该是 CNAME 类型才对。有必要的话可能得手动配置一下。</p>\n<p>  <a href=\"https://s2.loli.net/2022/09/05/fSsAGV5JCeZuF1w.png\"><br>  <img data-src=\"/2022/10/06/bkBasic/hexo/fSsAGV5JCeZuF1w.png\" class=\"\" title=\"update-record\"></a></p>\n</li>\n<li><p>更改名称服务器</p>\n<ul>\n<li>这个步骤Cloudflare会提供一个在线的教程，主要步骤是在你的域名服务商那里修改 dns 解析服务器为 cloudflare 提供的地址，修改完成后点击完成。</li>\n<li><a href=\"https://s2.loli.net/2022/09/05/vd2WxXGbJHmgAey.png\"><img data-src=\"/2022/10/06/bkBasic/hexo/vd2WxXGbJHmgAey.png\" class=\"\" title=\"modify-server\"></a></li>\n<li>以阿里云为例，设置的步骤如下:<ol>\n<li>进入域名的配置界面<ul>\n<li><a href=\"https://s2.loli.net/2022/09/05/ZfLiNUejRsCyhG3.png\"><img data-src=\"/2022/10/06/bkBasic/hexo/ZfLiNUejRsCyhG3.png\" class=\"\" title=\"dns-manage\"></a></li>\n</ul>\n</li>\n<li>将域名服务器从阿里云的默认服务器改成clouldflare的服务器<ul>\n<li><a href=\"https://s2.loli.net/2022/09/05/juxWl7i9QaeLTGK.png\"><img data-src=\"/2022/10/06/bkBasic/hexo/juxWl7i9QaeLTGK.png\" class=\"\" title=\"change-server\"></a></li>\n</ul>\n</li>\n</ol>\n</li>\n<li>配置完成后，clouldflare会有邮件通知(一般不会等太久)<br>  <a href=\"https://s2.loli.net/2022/09/05/JbBvp18Trne37kC.png\"><img data-src=\"/2022/10/06/bkBasic/hexo/JbBvp18Trne37kC.png\" class=\"\" title=\"mail-notice\"></a></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"配置https\"><a href=\"#配置https\" class=\"headerlink\" title=\"配置https\"></a>配置https</h2><p> 在clouldflare配置完成之后，我们可以回到netlify去配置一下https访问。</p>\n<ol>\n<li>先确认一下dns解析</li>\n<li>:<ul>\n<li><a href=\"https://s2.loli.net/2022/09/05/r6iHKWLktnRap1j.png\"><img data-src=\"/2022/10/06/bkBasic/hexo/r6iHKWLktnRap1j.png\" class=\"\" title=\"verify-dns\"></a></li>\n</ul>\n</li>\n<li>然后自动安装证书:<ul>\n<li><a href=\"https://s2.loli.net/2022/09/05/KvDupBFh8b9CScN.png\"><img data-src=\"/2022/10/06/bkBasic/hexo/KvDupBFh8b9CScN.png\" class=\"\" title=\"certify\"></a></li>\n</ul>\n</li>\n<li>最后看到如下的界面，就说明https配置完成了<ul>\n<li><a href=\"https://s2.loli.net/2022/09/05/f3q8hPbG5vsImeY.png\"><img data-src=\"/2022/10/06/bkBasic/hexo/f3q8hPbG5vsImeY.png\" class=\"\" title=\"https-config\"></a></li>\n</ul>\n</li>\n</ol>\n<h1 id=\"测试站点\"><a href=\"#测试站点\" class=\"headerlink\" title=\"测试站点\"></a>测试站点</h1><p> 等待一段时间之后，我们可以试着用自己的浏览器去访问自己配置的域名地址，如果在不科学上网的情况下能够正常看到如下的默认页面，则我们的个人博客就配置成功了。</p>\n<p> <a href=\"https://s2.loli.net/2022/09/05/HESMpeXbUFT3rsR.png\"><img data-src=\"/2022/10/06/bkBasic/hexo/HESMpeXbUFT3rsR.png\" class=\"\" title=\"default-page\"></a></p>\n<p> 本机能够正常访问之后，我们可以用<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYm9jZS5jb20v\">拨测</span>来检测一下域名解析与访问的速度。</p>\n<p> <a href=\"https://s2.loli.net/2022/09/05/7C496Ruof1rBknM.png\"><img data-src=\"/2022/10/06/bkBasic/hexo/7C496Ruof1rBknM.png\" class=\"\" title=\"speed\"></a></p>\n<p> 到此为止，我们的个人博客就彻底搭建完成啦。后续我们只需要修改博客的配置文件和博客本身的markdown源文件，然后push到github上，netlify会自动帮我们运行当初配置的建站脚本，然后将生成在public文件夹中的静态网页部署出去。</p>\n<p> 关于hexo博客的<span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL3poLWNuL2RvY3Mvd3JpdGluZw==\">写作方法</span>与各种好看的<span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL3RoZW1lcy8=\">主题的配置</span>可以查看官方的文档，多尝试多摸索，配置自己的个性页面吧。</p>\n</li>\n</ol>\n",
            "tags": [
                "框架",
                "博客"
            ]
        }
    ]
}