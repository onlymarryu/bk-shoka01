<?xml version="1.0"?>
<rss version="2.0">
    <channel>
        <title>记录“美食”每刻 • Posts by &#34;springboot&#34; tag</title>
        <link>http://example.com</link>
        <description>记录“美食”每刻</description>
        <language>zh-CN</language>
        <pubDate>Fri, 07 Oct 2022 00:00:00 +0800</pubDate>
        <lastBuildDate>Fri, 07 Oct 2022 00:00:00 +0800</lastBuildDate>
        <category>博客</category>
        <category>环境搭建</category>
        <category>分布式</category>
        <category>Dubbo</category>
        <category>FastDFS</category>
        <category>MySQL</category>
        <category>数据库基础</category>
        <category>数据库基本知识</category>
        <category>数据库</category>
        <category>框架</category>
        <category>ORM</category>
        <category>RPC</category>
        <category>中间件</category>
        <category>RabbitMQ</category>
        <category>Solr</category>
        <category>快速搜索</category>
        <category>Redis基础</category>
        <category>NoSQL数据库</category>
        <category>Spring</category>
        <category>SpringBoot</category>
        <category>SpringMVC</category>
        <category>SpringSecurity</category>
        <category>JavaSE</category>
        <category>-JavaSE</category>
        <item>
            <guid isPermalink="true">http://example.com/2022/10/07/SpringBoot/</guid>
            <title>SpringBoot</title>
            <link>http://example.com/2022/10/07/SpringBoot/</link>
            <category>框架</category>
            <category>Spring</category>
            <category>SpringBoot</category>
            <pubDate>Fri, 07 Oct 2022 00:00:00 +0800</pubDate>
            <description><![CDATA[ &lt;h1 id=&#34;简介&#34;&gt;&lt;a href=&#34;#简介&#34; class=&#34;headerlink&#34; title=&#34;简介&#34;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;h2 id=&#34;原有Spring优缺点分析&#34;&gt;&lt;a href=&#34;#原有Spring优缺点分析&#34; class=&#34;headerlink&#34; title=&#34;原有Spring优缺点分析&#34;&gt;&lt;/a&gt;原有Spring优缺点分析&lt;/h2&gt;&lt;p&gt;优点：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Spring是Java企业版（JAVAEE)开发的一种相对简单的方法，通过依赖注入和面向切面编程，用简单 的Java对象实现了EJB&amp;#x3D;&amp;#x3D;(Enterprise Java Beans技术的简称, 又被称为企业Java Beans)&amp;#x3D;&amp;#x3D;的功能&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;缺点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;虽然Spring的组件&lt;strong&gt;代码是轻量级&lt;/strong&gt;的，但它的&lt;strong&gt;配置却是重量级&lt;/strong&gt;的&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;依赖管理&lt;/strong&gt;也是一件耗时耗力的事情，会产生版本不兼容的问题&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;SpringBoot概念简介&#34;&gt;&lt;a href=&#34;#SpringBoot概念简介&#34; class=&#34;headerlink&#34; title=&#34;SpringBoot概念简介&#34;&gt;&lt;/a&gt;SpringBoot概念简介&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;Spring Boot是Spring公司的一个顶级项目，和Spring Framework是一个级别的。&lt;br&gt;Spring Boot实际上是利用Spring Framework 4 自动配置特性完成。编写项目时不需要编写xml文件。发展到现在，Spring Boot已经具有很很大的生态圈，各种主流技术已经都提供了Spring Boot的启动器。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;什么是启动器&#34;&gt;&lt;a href=&#34;#什么是启动器&#34; class=&#34;headerlink&#34; title=&#34;什么是启动器&#34;&gt;&lt;/a&gt;什么是启动器&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;Spring框架在项目中作用是Spring整合各种其他技术，让其他技术使用更加方便。Spring Boot的启动器&lt;strong&gt;实际上就是一个依赖&lt;/strong&gt;。这个依赖中包含了整个这个技术的相关jar包，还包含了这个技术的自动配置，以前绝大多数XML配置都不需要配置了。当然了，启动器中自动配置无法实现所有内容的自动配置，在使用Spring Boot时还需要进行少量的配置（这个配置不是在xml中了，而是在properties或yml中即可）。如果是&lt;strong&gt;Spring自己封装的启动器&lt;/strong&gt;的artifact id&lt;strong&gt;名字满足：spring-boot-starter-&lt;em&gt;xxxx&lt;/em&gt;&lt;/strong&gt;，如果是&lt;strong&gt;第三方公司提供的启动&lt;/strong&gt;满足：&lt;strong&gt;&lt;em&gt;xxxx&lt;/em&gt;-spring-boot-starter&lt;/strong&gt;。以后每次使用Spring Boot整合其他技术时首先需要考虑导入启动器。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;Spring-Boot优点&#34;&gt;&lt;a href=&#34;#Spring-Boot优点&#34; class=&#34;headerlink&#34; title=&#34;Spring Boot优点&#34;&gt;&lt;/a&gt;Spring Boot优点&lt;/h1&gt;&lt;p&gt;①　使用Spring Boot可以创建独立的Spring应用程序&lt;br&gt;②　在Spring Boot中&lt;strong&gt;直接嵌入了Tomcat&lt;/strong&gt;、Jetty、Undertow等Web  容器，在使用SpringBoot做Web开发时&lt;strong&gt;不需要部署WAR文件&lt;/strong&gt;&lt;br&gt;③　通过提供自己的启动器(Starter)依赖，简化项目构建配置&lt;br&gt;④　尽量的自动配置Spring和第三方库&lt;br&gt;⑤　绝对没有代码生成，也不需要XML配置文件&lt;/p&gt;
&lt;h1 id=&#34;Spring-Boot的核心&#34;&gt;&lt;a href=&#34;#Spring-Boot的核心&#34; class=&#34;headerlink&#34; title=&#34;Spring Boot的核心&#34;&gt;&lt;/a&gt;Spring Boot的核心&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;起步依赖&lt;/strong&gt;：起步依赖本质上是一个Maven项目对象模型（Project Object Model，POM），定义了对其他库的传递依赖，这些东西加在一起即支持某项功能。 简单的说，起步依赖就是将具备某种功能的坐标打包到一起，并提供一些默认的功能。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;自动配置&lt;/strong&gt; ：Spring Boot的自动配置是一个运行时（更准确地说，是应用程序启动时）的过程，考虑了众多因素，才决定 Spring配置应该用哪个，不该用哪个。该过程是Spring自动完成的。&lt;/p&gt;
&lt;h1 id=&#34;启动原理分析&#34;&gt;&lt;a href=&#34;#启动原理分析&#34; class=&#34;headerlink&#34; title=&#34;启动原理分析&#34;&gt;&lt;/a&gt;启动原理分析&lt;/h1&gt;&lt;img data-src=&#34;/2022/10/07/SpringBoot/%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE.jpg&#34; class=&#34;&#34;&gt;




&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;static class Registrar implements ImportBeanDefinitionRegistrar, DeterminableImports &amp;#123;
    @Override
    public void registerBeanDefinitions(AnnotationMetadata metadata, BeanDefinitionRegistry registry) &amp;#123;
        register(registry, new PackageImports(metadata).getPackageNames().toArray(new String[0]));
    &amp;#125;
    @Override
    public Set&amp;lt;Object&amp;gt; determineImports(AnnotationMetadata metadata) &amp;#123;
        return Collections.singleton(new PackageImports(metadata));
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;将配置类@SpringBootApplication标注的类所在包及下面所有子包里的所有组件扫描到spring容器&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;protected List&amp;lt;String&amp;gt; getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes) &amp;#123;
        List&amp;lt;String&amp;gt; configurations = SpringFactoriesLoader.loadFactoryNames(getSpringFactoriesLoaderFactoryClass(),
                getBeanClassLoader());
        Assert.notEmpty(configurations, &amp;quot;No auto configuration classes found in META-INF/spring.factories. If you &amp;quot;
                + &amp;quot;are using a custom packaging, make sure that file is correct.&amp;quot;);
        return configurations;
    &amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;通过 getCandidateConfigurations读取自带的配置文件，得到他们的全路径名，通过反射创建他们&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&#34;异常处理和拦截器&#34;&gt;&lt;a href=&#34;#异常处理和拦截器&#34; class=&#34;headerlink&#34; title=&#34;异常处理和拦截器&#34;&gt;&lt;/a&gt;异常处理和拦截器&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;均与SpringMVC中处理一致&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&#34;分页&#34;&gt;&lt;a href=&#34;#分页&#34; class=&#34;headerlink&#34; title=&#34;分页&#34;&gt;&lt;/a&gt;分页&lt;/h1&gt;&lt;p&gt;主要参数：&lt;/p&gt;
&lt;p&gt;当前页 、一页n个(每页的数量)、 总条数&lt;/p&gt;
&lt;h2 id=&#34;属性介绍&#34;&gt;&lt;a href=&#34;#属性介绍&#34; class=&#34;headerlink&#34; title=&#34;属性介绍&#34;&gt;&lt;/a&gt;属性介绍&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;属性名&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;类型&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;默认值&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;overflow&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;boolean&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;false&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;溢出总页数后是否进行处理&lt;br/&gt;(默认不处理,参见 &lt;code&gt;插件#continuePage&lt;/code&gt; 方法)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;maxLimit&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Long&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;单页分页条数限制&lt;br/&gt;(默认无限制,参见 &lt;code&gt;插件#handlerLimit&lt;/code&gt; 方法)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;dbType&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;DbType&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;数据库类型&lt;br/&gt;(根据类型获取应使用的分页方言,参见 &lt;code&gt;插件#findIDialect&lt;/code&gt; 方法)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;dialect&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;IDialect&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;方言实现类&lt;br/&gt;(参见 &lt;code&gt;插件#findIDialect&lt;/code&gt; 方法)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;blockquote&gt;
&lt;p&gt;建议单一数据库类型的均设置 dbType&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;    @GetMapping(&amp;quot;/test&amp;quot;)
    public Response test()&amp;#123;
        Page&amp;lt;Produce&amp;gt; producePage = new Page&amp;lt;&amp;gt;(1,1);
        Page&amp;lt;Produce&amp;gt; page = produceService.page(producePage);
        System.out.println(producePage == page);
        List&amp;lt;Produce&amp;gt; records = page.getRecords();
        for (Produce record : records) &amp;#123;
            System.out.println(record);
        &amp;#125;
        return new Response&amp;lt;&amp;gt;(records, ResultEnum.SUCCESS);
    &amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;img data-src=&#34;/2022/10/07/SpringBoot/656c18aaaf9ed11fee9b9f1576cc840f.png&#34; class=&#34;&#34;&gt;


&lt;p&gt;默认是会查询总条数，都有get、set方法，可以根据自己的需求设置（点开Page类看看）&lt;/p&gt;
&lt;img data-src=&#34;/2022/10/07/SpringBoot/d0e0280ca8a9d46a4a41c4a1de89ab3c.png&#34; class=&#34;&#34;&gt;










&lt;h1 id=&#34;项目打包和部署&#34;&gt;&lt;a href=&#34;#项目打包和部署&#34; class=&#34;headerlink&#34; title=&#34;项目打包和部署&#34;&gt;&lt;/a&gt;项目打包和部署&lt;/h1&gt;&lt;h2 id=&#34;打包&#34;&gt;&lt;a href=&#34;#打包&#34; class=&#34;headerlink&#34; title=&#34;打包&#34;&gt;&lt;/a&gt;打包&lt;/h2&gt;&lt;p&gt;SpringBoot项目打包在linux服务器中运行:&lt;br&gt;    ①jar类型项目会打成jar包:&lt;br&gt;    jar类型项目使用SpringBoot打包插件打包时，会在打成的jar中内置一个tomcat的jar。所以我们可以使用jdk直接运行该jar项目可，jar项目中有一个功能，将功能代码放到其内置的tomcat中运行。我们直接使用浏览器访问即可。&lt;br&gt;    ②war类型项目会打成war包:&lt;br&gt;    在打包时需要将内置的tomcat插件排除，配置servlet的依赖。将war正常的放到tomcat服务器中运行即可。&lt;/p&gt;
&lt;img data-src=&#34;/2022/10/07/SpringBoot/image-20220718170542347.png&#34; class=&#34;&#34;&gt;


&lt;h2 id=&#34;部署&#34;&gt;&lt;a href=&#34;#部署&#34; class=&#34;headerlink&#34; title=&#34;部署&#34;&gt;&lt;/a&gt;部署&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;注：这里是部署到Tomcat（war），jar直接编译启动&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;第一步：&#34;&gt;&lt;a href=&#34;#第一步：&#34; class=&#34;headerlink&#34; title=&#34;第一步：&#34;&gt;&lt;/a&gt;第一步：&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;在部署到Tomcat 之前我们要将我们项目中的Tomcat(==它在Web中==)去掉，但是我们在项目中又有可能要使用他提供的jar包 HttpServlet 之类的，所以我们还需要再将它手动导入，但是他不需要他打包。
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;xml&#34;&gt;&amp;lt;!--配置SpringBoot的web启动器--&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;
    &amp;lt;!--排除web启动中自动依赖的tomcat插件--&amp;gt;
    &amp;lt;exclusions&amp;gt;
        &amp;lt;exclusion&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-tomcat&amp;lt;/artifactId&amp;gt;
        &amp;lt;/exclusion&amp;gt;
    &amp;lt;/exclusions&amp;gt;
&amp;lt;/dependency&amp;gt;

&amp;lt;!--
    手动依赖tomcat插件，但是表明项目打包时该依赖不会被打进去，目的主要是保证开发阶段本地SpringBoot
    项目可以正常运行
--&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-boot-starter-tomcat&amp;lt;/artifactId&amp;gt;
    &amp;lt;!--打包的时候可以不用包进去，别的设施会提供。事实上该依赖理论上可以参与编译，测试，运行等周期。
        相当于compile，但是打包阶段做了exclude操作--&amp;gt;
    &amp;lt;scope&amp;gt;provided&amp;lt;/scope&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;第二步：&#34;&gt;&lt;a href=&#34;#第二步：&#34; class=&#34;headerlink&#34; title=&#34;第二步：&#34;&gt;&lt;/a&gt;第二步：&lt;/h3&gt;&lt;p&gt;SpringBoot的&lt;strong&gt;启动类继承SpringBootServletInitializer&lt;/strong&gt;，并&lt;strong&gt;重写configure&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;@SpringBootApplication
public class MyApplication extends SpringBootServletInitializer &amp;#123;
    //重写配置方法
    @Override
    protected SpringApplicationBuilder configure(SpringApplicationBuilder application) &amp;#123;
        return application.sources(MyApplication.class);
    &amp;#125;
    public static void main(String[] args) &amp;#123;
        //启动SpringBoot
        SpringApplication.run(MyApplication.class,args);
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用package命令打包项目，并将war包放到tomcat下的webapps下，启动tomcat即可。&lt;/p&gt;
&lt;h3 id=&#34;注：&#34;&gt;&lt;a href=&#34;#注：&#34; class=&#34;headerlink&#34; title=&#34;注：&#34;&gt;&lt;/a&gt;注：&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;部署到tomcat之后我们的URL就会变化，tomcat会自动编译war包，我们的&lt;strong&gt;项目名和war包同名&lt;/strong&gt;，所以不想改变提前修改&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;端口号也是tomcat的端口号&lt;/strong&gt;（tomcat&amp;#x2F;conf&amp;#x2F;server.xml）&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;面试题&#34;&gt;&lt;a href=&#34;#面试题&#34; class=&#34;headerlink&#34; title=&#34;面试题&#34;&gt;&lt;/a&gt;面试题&lt;/h1&gt;&lt;h2 id=&#34;SpringBoot约定大于配置理解&#34;&gt;&lt;a href=&#34;#SpringBoot约定大于配置理解&#34; class=&#34;headerlink&#34; title=&#34;SpringBoot约定大于配置理解&#34;&gt;&lt;/a&gt;SpringBoot约定大于配置理解&lt;/h2&gt;&lt;p&gt;约定大于配置是一种开发原则，就是减少人为的配置，直接用默认的配置就能获得我们想要的结果。&lt;br&gt;　　SpringBoot的约定大于配置，按我的理解是：对比SpringMVC，需要在web.xml里面配置前端控制器，还需要在核心配置文件（*-servlet.xml）中配置视图解析器啥的，更要配置第三方的Tomcat服务器。而SpringBoot就不需要我们配置这些，他内嵌了Tomcat服务器，我们只需要在Maven配置文件（Pom.xml）里面导入SpringMVC所需要的依赖就可以了。&lt;br&gt;　　这就是SpringBoot的优势，在传统所需要配置的地方，SpringBoot都进行了约定（配置好了），开发人员能配置得更少，更直接地开发项目，写业务逻辑代码。&lt;br&gt;spring boot和maven的约定大于配置体现 点：&lt;br&gt;　　1.maven的目录文件结构&lt;br&gt;　　1）默认有resources文件夹,存放资源配置文件。src-main-resources,src-main-java&lt;br&gt;默认的编译生成的类都在targetwen。&lt;br&gt;　　2）默认有target文件夹，将生成class文件盒编程生成的jar存放在target文件夹下&lt;/p&gt;
&lt;p&gt;2.spring boot默认的配置文件必须是，也只能是application.命名的yml文件或者properties文件，且唯一&lt;/p&gt;
&lt;p&gt;1）spring boot默认只会去src-main-resources文件夹下去找application配置文件&lt;/p&gt;
&lt;p&gt;这个问题呢，我从四个方面来回答。&lt;/p&gt;
&lt;p&gt;首先，约定优于配置是一种软件设计的范式，它的核心思想，是减少软件开发人员对于配置项的。从而让开发人员更加聚焦在业务逻辑上&lt;/p&gt;
&lt;p&gt;第二个呢，Spring boot就是约定优于配置这一理念下的产物，它类似于spring框架下的一个脚手架，通过spring boot，我们可以快速开发基于spring生态下的应用程序。基于传统的spring框架开发web应用的时候，我们需要做很多和业务无关，并且只需要做一次的配置项，比如&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;管理架包的依赖&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;web.xml的维护&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;spring MVC中的一个叫 Dispatch-Servlet.x ml 配置项的一个维护&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;应用需要自己手动去部署到web容器&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;第三方组件集成到spring IOC容器中，我们需要做配置项的维护&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;而在SpringBoot中，我们不再需要去做这些繁琐的配置，因为SpringBoot已经帮我们自动完成了，而完成这样一个动作的前提就是基于&amp;#x3D;&amp;#x3D;约定优于配置&amp;#x3D;&amp;#x3D;这样一个思想。&lt;/p&gt;
&lt;p&gt;最后呢，Spring boot约定优于配置的体现有很多，&lt;/p&gt;
&lt;p&gt;比如第一个spring boat start启动依赖，它能够帮助我们管理所有的jar包版本。&lt;/p&gt;
&lt;p&gt;第二个，如果当前的应用依赖了web这样一个 jar 包，那么spring boot会自动内置Tomcat，他们看着容器来去运行web应用，我们不再需要去单独进行应用部署。&lt;/p&gt;
&lt;p&gt;第三，Spring boot的自动装配机制的实现中，通过扫描约定路径下的spring.factory文件去进行识别配置类，从而去实现类的自动装载&lt;/p&gt;
&lt;p&gt;第四，Spring boot？默认会加载resource目录下的application.property文件。总的来说啊，约定优于配置呢，是一个比较常见的软件设计思想，它的核心本质都是为了去更加高效，以及更加便捷的去实现软件系统的开发和维护。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;自我总结：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​	约定大于配置，不是说我们要设定啥，原来规定的是什么就不能改变，不是这个意思。他真正的意思是说当我们配置某个选项时，springboot会自动帮我们加载可能会与其相关的配置，就好比我们应用依赖了 web，那么spring boot会自动内置Tomcat，他们看着容器来去运行web应用，我们不再需要去单独进行应用部署。&lt;/p&gt;
&lt;p&gt;​	总的来说啊，约定优于配置呢，是一个比较常见的软件设计思想，它的核心本质都是为了去更加高效，以及更加便捷的去实现软件系统的开发和维护。&lt;/p&gt;
 ]]></description>
        </item>
    </channel>
</rss>
