<?xml version="1.0"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>http://example.com</id>
    <title>记录“美食”每刻 • Posts by &#34;rpc&#34; tag</title>
    <link href="http://example.com" />
    <updated>2022-10-06T16:00:00.000Z</updated>
    <category term="分布式" />
    <category term="Dubbo" />
    <category term="FastDFS" />
    <category term="RPC" />
    <category term="中间件" />
    <category term="RabbitMQ" />
    <category term="Solr" />
    <category term="快速搜索" />
    <category term="JavaSE" />
    <category term="-JavaSE" />
    <category term="框架" />
    <category term="ORM" />
    <category term="博客" />
    <category term="环境搭建" />
    <category term="Spring" />
    <category term="SpringBoot" />
    <category term="SpringMVC" />
    <category term="SpringSecurity" />
    <category term="Redis基础" />
    <category term="NoSQL数据库" />
    <entry>
        <id>http://example.com/2022/10/07/Distribution/RPC/</id>
        <title>RPC</title>
        <link rel="alternate" href="http://example.com/2022/10/07/Distribution/RPC/"/>
        <content type="html">&lt;h1 id=&#34;【RPC】&#34;&gt;&lt;a href=&#34;#【RPC】&#34; class=&#34;headerlink&#34; title=&#34;【RPC】&#34;&gt;&lt;/a&gt;【RPC】&lt;/h1&gt;&lt;h2 id=&#34;主要内容&#34;&gt;&lt;a href=&#34;#主要内容&#34; class=&#34;headerlink&#34; title=&#34;主要内容&#34;&gt;&lt;/a&gt;主要内容&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;项目结构变化&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;RPC简介&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;RMI实现RPC&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;HttpClient实现RPC&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Zookeeper安装&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Zookeeper客户端常用命令&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;向Zookeeper中注册内容&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;从Zookeeper中发现内容&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;手写RPC框架&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;学习目标&#34;&gt;&lt;a href=&#34;#学习目标&#34; class=&#34;headerlink&#34; title=&#34;学习目标&#34;&gt;&lt;/a&gt;学习目标&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;知识点&lt;/th&gt;
&lt;th&gt;要求&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;项目架构变化&lt;/td&gt;
&lt;td&gt;掌握&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;RPC简介&lt;/td&gt;
&lt;td&gt;掌握&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;RMI实现RPC&lt;/td&gt;
&lt;td&gt;掌握&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;HttpClient实现RPC&lt;/td&gt;
&lt;td&gt;了解&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Zookeeper安装&lt;/td&gt;
&lt;td&gt;掌握&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Zookeeper客户端常用命令&lt;/td&gt;
&lt;td&gt;掌握&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;向Zookeeper中注册内容&lt;/td&gt;
&lt;td&gt;掌握&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;从zookeeper中发现内容&lt;/td&gt;
&lt;td&gt;掌握&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;手写RPC框架&lt;/td&gt;
&lt;td&gt;掌握&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;h3 id=&#34;一、今天学什么？为什么讲？&#34;&gt;&lt;a href=&#34;#一、今天学什么？为什么讲？&#34; class=&#34;headerlink&#34; title=&#34;一、今天学什么？为什么讲？&#34;&gt;&lt;/a&gt;一、今天学什么？为什么讲？&lt;/h3&gt;&lt;p&gt;​	 现在学习RPC。后期学习的Dubbo是一个RPC框架，学习好现在的内容，学习Dubbo将会变得容易一些。&lt;/p&gt;
&lt;h3 id=&#34;二、项目架构变化&#34;&gt;&lt;a href=&#34;#二、项目架构变化&#34; class=&#34;headerlink&#34; title=&#34;二、项目架构变化&#34;&gt;&lt;/a&gt;二、项目架构变化&lt;/h3&gt;&lt;h4 id=&#34;1-单体架构&#34;&gt;&lt;a href=&#34;#1-单体架构&#34; class=&#34;headerlink&#34; title=&#34;1     单体架构&#34;&gt;&lt;/a&gt;1     单体架构&lt;/h4&gt;&lt;h5 id=&#34;1-1-架构图&#34;&gt;&lt;a href=&#34;#1-1-架构图&#34; class=&#34;headerlink&#34; title=&#34;1.1   架构图&#34;&gt;&lt;/a&gt;1.1   架构图&lt;/h5&gt;&lt;p&gt;​	单体架构就是一个项目里面包含这个项目中全部代码。一个应用搞定全部功能。&lt;/p&gt;
&lt;p&gt;​	DNS 服务器可以是单映射，也可以配置多个映射。&lt;/p&gt;
&lt;img data-src=&#34;/2022/10/07/Distribution/RPC/rpc-01.png&#34; class=&#34;&#34;&gt;


&lt;h5 id=&#34;1-2-软件代码结构&#34;&gt;&lt;a href=&#34;#1-2-软件代码结构&#34; class=&#34;headerlink&#34; title=&#34;1.2   软件代码结构&#34;&gt;&lt;/a&gt;1.2   软件代码结构&lt;/h5&gt;&lt;p&gt;​	在单体架构项目中，团队都是通过包(package)进行区分每个模块。&lt;/p&gt;
&lt;p&gt;​	总体包结构：com.msb.*.分层包。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;项目名：
  -- com
    --msb
      -- common
        -- utils
      --user
        -- controller
        -- service
        -- mapper
      -- sys
        -- controller
        -- service
        -- mapper
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;1-3-优缺点&#34;&gt;&lt;a href=&#34;#1-3-优缺点&#34; class=&#34;headerlink&#34; title=&#34;1.3   优缺点&#34;&gt;&lt;/a&gt;1.3   优缺点&lt;/h4&gt;&lt;h5 id=&#34;1-3-1-优点&#34;&gt;&lt;a href=&#34;#1-3-1-优点&#34; class=&#34;headerlink&#34; title=&#34;1.3.1    优点&#34;&gt;&lt;/a&gt;1.3.1    优点&lt;/h5&gt;&lt;p&gt;​	部署简单&lt;/p&gt;
&lt;p&gt;​	维护方便&lt;/p&gt;
&lt;p&gt;​	成本低&lt;/p&gt;
&lt;h5 id=&#34;1-3-2-缺点&#34;&gt;&lt;a href=&#34;#1-3-2-缺点&#34; class=&#34;headerlink&#34; title=&#34;1.3.2    缺点&#34;&gt;&lt;/a&gt;1.3.2    缺点&lt;/h5&gt;&lt;p&gt;​	当项目规模大、用户访问频率高、并发量大、数据量大时，会大大降低程序执行效率，甚至出现服务器宕机等情况。&lt;/p&gt;
&lt;h4 id=&#34;1-4-适用项目&#34;&gt;&lt;a href=&#34;#1-4-适用项目&#34; class=&#34;headerlink&#34; title=&#34;1.4   适用项目&#34;&gt;&lt;/a&gt;1.4   适用项目&lt;/h4&gt;&lt;p&gt;传统管理项目，小型互联网项目。&lt;/p&gt;
&lt;h4 id=&#34;2-分布式架构&#34;&gt;&lt;a href=&#34;#2-分布式架构&#34; class=&#34;headerlink&#34; title=&#34;2     分布式架构&#34;&gt;&lt;/a&gt;2     分布式架构&lt;/h4&gt;&lt;h5 id=&#34;2-1-架构图（简易版）&#34;&gt;&lt;a href=&#34;#2-1-架构图（简易版）&#34; class=&#34;headerlink&#34; title=&#34;2.1   架构图（简易版）&#34;&gt;&lt;/a&gt;2.1   架构图（简易版）&lt;/h5&gt;&lt;p&gt;​	分布式架构会把一个项目按照特定要求（多按照模块或功能）拆分成多个项目，每个项目分别部署到不同的服务器上。&lt;/p&gt;
&lt;img data-src=&#34;/2022/10/07/Distribution/RPC/rpc-02.png&#34; class=&#34;&#34;&gt;


&lt;h5 id=&#34;2-2-软件代码结构&#34;&gt;&lt;a href=&#34;#2-2-软件代码结构&#34; class=&#34;headerlink&#34; title=&#34;2.2   软件代码结构&#34;&gt;&lt;/a&gt;2.2   软件代码结构&lt;/h5&gt;&lt;pre&gt;&lt;code&gt;项目1：
  --com.msb.xxx
    -- controller
    -- service
    -- mapper
项目2
  --com.msb.mmm
    -- controller
    -- service
    -- mapper
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;2-3-优缺点&#34;&gt;&lt;a href=&#34;#2-3-优缺点&#34; class=&#34;headerlink&#34; title=&#34;2.3   优缺点&#34;&gt;&lt;/a&gt;2.3   优缺点&lt;/h4&gt;&lt;h5 id=&#34;2-3-1-优点&#34;&gt;&lt;a href=&#34;#2-3-1-优点&#34; class=&#34;headerlink&#34; title=&#34;2.3.1    优点&#34;&gt;&lt;/a&gt;2.3.1    优点&lt;/h5&gt;&lt;p&gt;​	增大了系统可用性。减少单点故障，导致整个应用不可用。&lt;/p&gt;
&lt;p&gt;​	增加重用性。因为模块化，所以重用性更高。&lt;/p&gt;
&lt;p&gt;​	增加可扩展性。有新的模块增加新的项目即可。&lt;/p&gt;
&lt;p&gt;​	增加每个模块的负载能力。因为每个模块都是一个项目，所以每个模块的负载能力更强。&lt;/p&gt;
&lt;h5 id=&#34;2-3-2-缺点&#34;&gt;&lt;a href=&#34;#2-3-2-缺点&#34; class=&#34;headerlink&#34; title=&#34;2.3.2    缺点&#34;&gt;&lt;/a&gt;2.3.2    缺点&lt;/h5&gt;&lt;p&gt;​	成本更高。&lt;/p&gt;
&lt;p&gt;​	架构更加复杂。&lt;/p&gt;
&lt;p&gt;​	整体响应之间变长，一些业务需要多项目通信后给出结果。&lt;/p&gt;
&lt;p&gt;​	吞吐量更大。吞吐量&amp;#x3D; 请求数&amp;#x2F;秒。&lt;/p&gt;
&lt;h4 id=&#34;2-4-待解决问题&#34;&gt;&lt;a href=&#34;#2-4-待解决问题&#34; class=&#34;headerlink&#34; title=&#34;2.4   待解决问题&#34;&gt;&lt;/a&gt;2.4   待解决问题&lt;/h4&gt;&lt;p&gt;​	分布式架构中各个模块如何进行通信？&lt;/p&gt;
&lt;p&gt;​	可以使用Http协议，也可以使用RPC协议通信，也可以使用其他的通信方式。我们本阶段使用的是RPC协议，因为它比HTTP更适合项目内部通信。&lt;/p&gt;
&lt;h3 id=&#34;三、RPC简介&#34;&gt;&lt;a href=&#34;#三、RPC简介&#34; class=&#34;headerlink&#34; title=&#34;三、RPC简介&#34;&gt;&lt;/a&gt;三、RPC简介&lt;/h3&gt;&lt;h4 id=&#34;1-RFC&#34;&gt;&lt;a href=&#34;#1-RFC&#34; class=&#34;headerlink&#34; title=&#34;1     RFC&#34;&gt;&lt;/a&gt;1     RFC&lt;/h4&gt;&lt;p&gt;​	RFC(Request For Comments) 是由互联网工程任务组(IETF)发布的文件集。文件集中每个文件都有自己唯一编号，例如：rfc1831。目前RFC文件由互联网协会(Internet Society，ISOC)赞助发型。&lt;/p&gt;
&lt;p&gt;​	RPC就收集到了rfc 1831中。可以通过下面网址查看：&lt;/p&gt;
&lt;p&gt;​	&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9kYXRhdHJhY2tlci5pZXRmLm9yZy9kb2MvcmZjMTgzMS8=&#34;&gt;https://datatracker.ietf.org/doc/rfc1831/&lt;/span&gt;&lt;/p&gt;
&lt;h4 id=&#34;2-RPC&#34;&gt;&lt;a href=&#34;#2-RPC&#34; class=&#34;headerlink&#34; title=&#34;2     RPC&#34;&gt;&lt;/a&gt;2     RPC&lt;/h4&gt;&lt;p&gt;​	RPC在rfc 1831中收录 ，RPC（Remote Procedure Call） 远程过程调用协议&lt;/p&gt;
&lt;p&gt;​	RPC协议规定允许互联网中一台主机程序调用另一台主机程序，而程序员无需对这个交互过程进行编程。在RPC协议中强调当A程序调用B程序中功能或方法时，A是不知道B中方法具体实现的。&lt;/p&gt;
&lt;p&gt;​	RPC是上层协议，底层可以基于TCP协议，也可以基于HTTP协议。一般我们说RPC都是基于RPC的具体实现，如：Dubbo框架。从广义上讲只要是满足网络中进行通讯调用都统称为RPC，甚至HTTP协议都可以说是RPC的具体实现，但是具体分析看来RPC协议要比HTTP协议更加高效，基于RPC的框架功能更多。&lt;/p&gt;
&lt;p&gt;​	RPC协议是基于分布式架构而出现的，所以RPC在分布式项目中有着得天独厚的优势。&lt;/p&gt;
&lt;h4 id=&#34;3-RPC和HTTP对比&#34;&gt;&lt;a href=&#34;#3-RPC和HTTP对比&#34; class=&#34;headerlink&#34; title=&#34;3     RPC和HTTP对比&#34;&gt;&lt;/a&gt;3     RPC和HTTP对比&lt;/h4&gt;&lt;h5 id=&#34;3-1-具体实现&#34;&gt;&lt;a href=&#34;#3-1-具体实现&#34; class=&#34;headerlink&#34; title=&#34;3.1   具体实现&#34;&gt;&lt;/a&gt;3.1   具体实现&lt;/h5&gt;&lt;p&gt;​	RPC：可以基于TCP协议，也可以基于HTTP协议。&lt;/p&gt;
&lt;p&gt;​	HTTP：基于HTTP协议&lt;/p&gt;
&lt;h5 id=&#34;3-2-效率&#34;&gt;&lt;a href=&#34;#3-2-效率&#34; class=&#34;headerlink&#34; title=&#34;3.2   效率&#34;&gt;&lt;/a&gt;3.2   效率&lt;/h5&gt;&lt;p&gt;​	RPC：自定义具体实现可以减少很多无用的报文内容，使得报文体积更小。&lt;/p&gt;
&lt;p&gt;​	HTTP：如果是HTTP 1.1 报文中很多内容都是无用的。如果是HTTP2.0以后和RPC相差不大，比RPC少的可能就是一些服务治理等功能。&lt;/p&gt;
&lt;h5 id=&#34;3-3-连接方式&#34;&gt;&lt;a href=&#34;#3-3-连接方式&#34; class=&#34;headerlink&#34; title=&#34;3.3   连接方式&#34;&gt;&lt;/a&gt;3.3   连接方式&lt;/h5&gt;&lt;p&gt;​	RPC：长连接支持。&lt;/p&gt;
&lt;p&gt;​	HTTP：每次连接都是&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vbmV2ZXJtb3Jld2FuZy9wLzg5MDY4MzMuaHRtbA==&#34;&gt;三次握手四次挥手&lt;/span&gt;。&lt;/p&gt;
&lt;h5 id=&#34;3-4-性能&#34;&gt;&lt;a href=&#34;#3-4-性能&#34; class=&#34;headerlink&#34; title=&#34;3.4   性能&#34;&gt;&lt;/a&gt;3.4   性能&lt;/h5&gt;&lt;p&gt;​	RPC可以基于很多序列化方式。如：thrift&lt;/p&gt;
&lt;p&gt;​	HTTP 主要是通过JSON，序列化和反序列效率更低。&lt;/p&gt;
&lt;h5 id=&#34;3-5-注册中心&#34;&gt;&lt;a href=&#34;#3-5-注册中心&#34; class=&#34;headerlink&#34; title=&#34;3.5   注册中心&#34;&gt;&lt;/a&gt;3.5   注册中心&lt;/h5&gt;&lt;p&gt;​	RPC ：一般RPC框架都带有注册中心。&lt;/p&gt;
&lt;p&gt;​	HTTP：都是直连。&lt;/p&gt;
&lt;h5 id=&#34;3-6-负载均衡&#34;&gt;&lt;a href=&#34;#3-6-负载均衡&#34; class=&#34;headerlink&#34; title=&#34;3.6   负载均衡&#34;&gt;&lt;/a&gt;3.6   负载均衡&lt;/h5&gt;&lt;p&gt;​	RPC：绝大多数RPC框架都带有负载均衡测量。&lt;/p&gt;
&lt;p&gt;​	HTTP：一般都需要借助第三方工具。如：nginx&lt;/p&gt;
&lt;h5 id=&#34;3-7-综合结论&#34;&gt;&lt;a href=&#34;#3-7-综合结论&#34; class=&#34;headerlink&#34; title=&#34;3.7   综合结论&#34;&gt;&lt;/a&gt;3.7   综合结论&lt;/h5&gt;&lt;p&gt;​	RPC框架一般都带有丰富的服务治理等功能，更适合企业内部接口调用。而HTTP更适合多平台之间相互调用。&lt;/p&gt;
&lt;h3 id=&#34;四、HttpClient实现RPC&#34;&gt;&lt;a href=&#34;#四、HttpClient实现RPC&#34; class=&#34;headerlink&#34; title=&#34;四、HttpClient实现RPC&#34;&gt;&lt;/a&gt;四、HttpClient实现RPC&lt;/h3&gt;&lt;h4 id=&#34;1-HttpClient简介&#34;&gt;&lt;a href=&#34;#1-HttpClient简介&#34; class=&#34;headerlink&#34; title=&#34;1     HttpClient简介&#34;&gt;&lt;/a&gt;1     HttpClient简介&lt;/h4&gt;&lt;p&gt;​	在JDK中java.net包下提供了用户HTTP访问的基本功能，但是它缺少灵活性或许多应用所需要的功能。&lt;/p&gt;
&lt;p&gt;​	HttpClient起初是Apache Jakarta Common 的子项目。用来提供高效的、最新的、功能丰富的支持 HTTP 协议的客户端编程工具包，并且它支持 HTTP 协议最新的版本。2007年成为顶级项目。&lt;/p&gt;
&lt;p&gt;​	通俗解释：HttpClient可以实现使用Java代码完成标准HTTP请求及响应。&lt;/p&gt;
&lt;h4 id=&#34;2-代码实现&#34;&gt;&lt;a href=&#34;#2-代码实现&#34; class=&#34;headerlink&#34; title=&#34;2     代码实现&#34;&gt;&lt;/a&gt;2     代码实现&lt;/h4&gt;&lt;h5 id=&#34;2-1-服务端&#34;&gt;&lt;a href=&#34;#2-1-服务端&#34; class=&#34;headerlink&#34; title=&#34;2.1   服务端&#34;&gt;&lt;/a&gt;2.1   服务端&lt;/h5&gt;&lt;p&gt;​	新建项目HttpClientServer&lt;/p&gt;
&lt;h5 id=&#34;2-1-1-新建控制器&#34;&gt;&lt;a href=&#34;#2-1-1-新建控制器&#34; class=&#34;headerlink&#34; title=&#34;2.1.1    新建控制器&#34;&gt;&lt;/a&gt;2.1.1    新建控制器&lt;/h5&gt;&lt;p&gt;com.msb.controller.DemoController&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;@Controller
public class DemoController &amp;#123;
    @RequestMapping(&amp;quot;/demo&amp;quot;)
    @ResponseBody
    public String demo(String param)&amp;#123;
        return &amp;quot;demo&amp;quot;+param;
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;2-1-2-新建启动器&#34;&gt;&lt;a href=&#34;#2-1-2-新建启动器&#34; class=&#34;headerlink&#34; title=&#34;2.1.2    新建启动器&#34;&gt;&lt;/a&gt;2.1.2    新建启动器&lt;/h5&gt;&lt;p&gt;​	新建启动器&lt;/p&gt;
&lt;p&gt;com.msb.HttpClientServerApplication&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;@SpringBootApplication
public class HttpClientServerApplication &amp;#123;
    public static void main(String[] args) &amp;#123;
    SpringApplication.run(HttpClientServerApplication.class,args);
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;2-2-客户端&#34;&gt;&lt;a href=&#34;#2-2-客户端&#34; class=&#34;headerlink&#34; title=&#34;2.2   客户端&#34;&gt;&lt;/a&gt;2.2   客户端&lt;/h4&gt;&lt;p&gt;​	新建HttpClientDemo项目&lt;/p&gt;
&lt;h5 id=&#34;2-2-1-添加依赖&#34;&gt;&lt;a href=&#34;#2-2-1-添加依赖&#34; class=&#34;headerlink&#34; title=&#34;2.2.1    添加依赖&#34;&gt;&lt;/a&gt;2.2.1    添加依赖&lt;/h5&gt;&lt;pre&gt;&lt;code class=&#34;xml&#34;&gt; &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.apache.httpcomponents&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;httpclient&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;4.5.10&amp;lt;/version&amp;gt;
 &amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;2-2-2-新建类&#34;&gt;&lt;a href=&#34;#2-2-2-新建类&#34; class=&#34;headerlink&#34; title=&#34;2.2.2    新建类&#34;&gt;&lt;/a&gt;2.2.2    新建类&lt;/h5&gt;&lt;p&gt;​	新建com.msb.HttpClientDemo，编写主方法。&lt;/p&gt;
&lt;h6 id=&#34;2-2-2-1-使用GET方法访问&#34;&gt;&lt;a href=&#34;#2-2-2-1-使用GET方法访问&#34; class=&#34;headerlink&#34; title=&#34;2.2.2.1 使用GET方法访问&#34;&gt;&lt;/a&gt;2.2.2.1 使用GET方法访问&lt;/h6&gt;&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;public static void main(String[] args) &amp;#123;
    try &amp;#123;
        //创建http工具（理解成:浏览器） 发起请求，解析响应
        CloseableHttpClient httpClient = HttpClients.createDefault();
        //请求路径
        URIBuilder uriBuilder = new URIBuilder(&amp;quot;http://localhost:8080/demo&amp;quot;);
        uriBuilder.addParameter(&amp;quot;param&amp;quot;, &amp;quot;get123&amp;quot;);
        //创建HttpGet请求对象
        HttpGet get = new HttpGet(uriBuilder.build());
        //创建响应对象
        CloseableHttpResponse response = httpClient.execute(get);
        //由于响应体是字符串，因此把HttpEntity类型转换为字符串类型，并设置字符编码
        String result = EntityUtils.toString(response.getEntity(), &amp;quot;utf-8&amp;quot;);
        //输出结果
        System.out.println(result);
        //释放资源
        response.close();
        httpClient.close();
    &amp;#125; catch (URISyntaxException e) &amp;#123;
        e.printStackTrace();
    &amp;#125; catch (IOException e) &amp;#123;
        e.printStackTrace();
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h6 id=&#34;2-2-2-2-使用POST方式访问&#34;&gt;&lt;a href=&#34;#2-2-2-2-使用POST方式访问&#34; class=&#34;headerlink&#34; title=&#34;2.2.2.2 使用POST方式访问&#34;&gt;&lt;/a&gt;2.2.2.2 使用POST方式访问&lt;/h6&gt;&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;public class HttpClientDemo &amp;#123;
    public static void main(String[] args) &amp;#123;
        try &amp;#123;
            //创建http工具（理解成:浏览器） 发起请求，解析响应
            CloseableHttpClient httpClient = HttpClients.createDefault();
            //创建HttpPOST请求对象
            HttpPost post = new HttpPost(&amp;quot;http://localhost:8080/demo&amp;quot;);
            //所有请求参数
            List&amp;lt;NameValuePair&amp;gt; params = new ArrayList&amp;lt;&amp;gt;();
            params.add(new BasicNameValuePair(&amp;quot;param&amp;quot;,&amp;quot;123&amp;quot;));
            //创建HttpEntity接口的文本实现类的对象，放入参数并设置编码
            HttpEntity httpEntity = new UrlEncodedFormEntity(params,&amp;quot;utf-8&amp;quot;);
            //放入到HttpPost对象中
            post.setEntity(httpEntity);            
            //创建响应对象
            CloseableHttpResponse response = httpClient.execute(post);
            //由于响应体是字符串，因此把HttpEntity类型转换为字符串类型
            String result = EntityUtils.toString(response.getEntity());
            //输出结果
            System.out.println(result);
            //释放资源
            response.close();
            httpClient.close();
        &amp;#125; catch (IOException e) &amp;#123;
            e.printStackTrace();
        &amp;#125;
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;3-Jackson用法&#34;&gt;&lt;a href=&#34;#3-Jackson用法&#34; class=&#34;headerlink&#34; title=&#34;3. Jackson用法&#34;&gt;&lt;/a&gt;3. Jackson用法&lt;/h4&gt;&lt;h5 id=&#34;3-1-把对象转换为json字符串&#34;&gt;&lt;a href=&#34;#3-1-把对象转换为json字符串&#34; class=&#34;headerlink&#34; title=&#34;3.1   把对象转换为json字符串&#34;&gt;&lt;/a&gt;3.1   把对象转换为json字符串&lt;/h5&gt;&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;ObjectMapper objectMapper = new ObjectMapper();
People peo = new People();
objectMapper.writeValueAsString(peo);
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;3-2-把json字符串转换为对象&#34;&gt;&lt;a href=&#34;#3-2-把json字符串转换为对象&#34; class=&#34;headerlink&#34; title=&#34;3.2   把json字符串转换为对象&#34;&gt;&lt;/a&gt;3.2   把json字符串转换为对象&lt;/h5&gt;&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;ObjectMapper objectMapper = new ObjectMapper();
People peo = objectMapper.readValue(content, People.class);
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;3-3-把json字符串转换为List集合&#34;&gt;&lt;a href=&#34;#3-3-把json字符串转换为List集合&#34; class=&#34;headerlink&#34; title=&#34;3.3   把json字符串转换为List集合&#34;&gt;&lt;/a&gt;3.3   把json字符串转换为List集合&lt;/h5&gt;&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;ObjectMapper objectMapper = new ObjectMapper();
JavaType javaType = objectMapper.getTypeFactory().constructParametricType(List.class, People.class);
List&amp;lt;People&amp;gt; list = objectMapper.readValue(content, javaType);
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;4-HttpClient请求包含JSON&#34;&gt;&lt;a href=&#34;#4-HttpClient请求包含JSON&#34; class=&#34;headerlink&#34; title=&#34;4     HttpClient请求包含JSON&#34;&gt;&lt;/a&gt;4     HttpClient请求包含JSON&lt;/h4&gt;&lt;h5 id=&#34;4-1-java代码实现&#34;&gt;&lt;a href=&#34;#4-1-java代码实现&#34; class=&#34;headerlink&#34; title=&#34;4.1   java代码实现&#34;&gt;&lt;/a&gt;4.1   java代码实现&lt;/h5&gt;&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;public class HttpClientDemo &amp;#123;
    public static void main(String[] args) &amp;#123;
        try &amp;#123;
            CloseableHttpClient httpClient = HttpClients.createDefault();
            HttpPost post = new HttpPost(&amp;quot;http://localhost:8080/demo&amp;quot;);
            HttpEntity httpEntity= null;
            String json = &amp;quot;&amp;#123;&amp;#125;&amp;quot;;
            StringEntity entity = new StringEntity(json, ContentType.APPLICATION_JSON);
            post.setEntity(entity);
            CloseableHttpResponse response = httpClient.execute(post);
            String result = EntityUtils.toString(response.getEntity());
            System.out.println(result);
            response.close();
            httpClient.close();
        &amp;#125; catch (IOException e) &amp;#123;
            e.printStackTrace();
        &amp;#125;
    &amp;#125;
&amp;#125;

 @Test
    public void testInputSteam()&amp;#123;
        try &amp;#123;

            CloseableHttpClient httpClient = HttpClients.createDefault();

            URIBuilder uriBuilder = new URIBuilder(&amp;quot;http://localhost:8080/demo4&amp;quot;);

            HttpPost httpPost = new HttpPost(uriBuilder.build());
            //创建集合
            List&amp;lt;User&amp;gt; users = new ArrayList&amp;lt;&amp;gt;();
            users.add(new User(2,&amp;quot;李四&amp;quot;));
            users.add(new User(1,&amp;quot;张三&amp;quot;));
            //将集合对象转化成JSON字符串
            ObjectMapper objectMapper = new ObjectMapper();
            String UserJson = objectMapper.writeValueAsString(users);
            System.out.println(UserJson);
            StringEntity stringEntity = new StringEntity(UserJson, 		  ContentType.APPLICATION_JSON);
            //设置请求体
            httpPost.setEntity(stringEntity);
            CloseableHttpResponse response= httpClient.execute(httpPost);
            String result = EntityUtils.toString(response.getEntity());
            System.out.println(result);

            response.close();
            httpClient.close();
        &amp;#125; catch (Exception e) &amp;#123;
            e.printStackTrace();
        &amp;#125;
    &amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;5-控制器接口参数&#34;&gt;&lt;a href=&#34;#5-控制器接口参数&#34; class=&#34;headerlink&#34; title=&#34;5     控制器接口参数&#34;&gt;&lt;/a&gt;5     控制器接口参数&lt;/h4&gt;&lt;p&gt;​	@RequestBody把请求体中流数据转换为指定的对象。多用在请求参数是json数据且请求的Content-Type&amp;#x3D;”application&amp;#x2F;json”&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;@RequestMapping(&amp;quot;/demo4&amp;quot;)
@ResponseBody
public String demo4(@RequestBody List&amp;lt;People&amp;gt; list) &amp;#123;
    System.out.println(list);
    return list.toString();
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;6-Ajax发送json参数写法&#34;&gt;&lt;a href=&#34;#6-Ajax发送json参数写法&#34; class=&#34;headerlink&#34; title=&#34;6   Ajax发送json参数写法&#34;&gt;&lt;/a&gt;6   Ajax发送json参数写法&lt;/h4&gt;&lt;pre&gt;&lt;code class=&#34;html&#34;&gt;var json = &amp;#39;[&amp;#123;&amp;quot;id&amp;quot;:123,&amp;quot;name&amp;quot;:&amp;quot;msb&amp;quot;&amp;#125;,&amp;#123;&amp;quot;id&amp;quot;:123,&amp;quot;name&amp;quot;:&amp;quot;mashibing&amp;quot;&amp;#125;]&amp;#39;;
 $.ajax(&amp;#123;
     url:&amp;#39;/demo5&amp;#39;,
     type:&amp;#39;post&amp;#39;,
     success:function(data)&amp;#123;
         alert(data);
         for(var i = 0 ;i&amp;lt;data.length;i++)&amp;#123;

             alert(data[i].id +&amp;quot;  &amp;quot;+data[i].name);
         &amp;#125;
     &amp;#125;,
     contentType:&amp;#39;application/json&amp;#39;,//请求体中内容类型
     dataType:&amp;#39;json&amp;#39;,//响应内容类型。
     data:json
 &amp;#125;);
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;7-跨域&#34;&gt;&lt;a href=&#34;#7-跨域&#34; class=&#34;headerlink&#34; title=&#34;7     跨域&#34;&gt;&lt;/a&gt;7     跨域&lt;/h4&gt;&lt;p&gt;​	跨域：协议、ip、端口中只要有一个不同就是跨域请求。&lt;/p&gt;
&lt;p&gt;​	同源策略：浏览器默认只允许ajax访问同源(协议、ip、端口都相同)内容。&lt;/p&gt;
&lt;p&gt;​	解决同源策略：&lt;/p&gt;
&lt;p&gt;​	在控制器接口上添加@CrossOrigin。表示允许跨域。本质在响应头中添加Access-Control-Allow-Origin: *&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;html&#34;&gt;var json = &amp;#39;[&amp;#123;&amp;quot;id&amp;quot;:123,&amp;quot;name&amp;quot;:&amp;quot;msb&amp;quot;&amp;#125;,&amp;#123;&amp;quot;id&amp;quot;:456,&amp;quot;name&amp;quot;:&amp;quot;mashibing&amp;quot;&amp;#125;]&amp;#39;;
 $.ajax(&amp;#123;
     url:&amp;#39;/demo5&amp;#39;,
     type:&amp;#39;post&amp;#39;,
     success:function(data)&amp;#123;
         alert(data);
         for(var i = 0 ;i&amp;lt;data.length;i++)&amp;#123;

             alert(data[i].id +&amp;quot;  &amp;quot;+data[i].name);
         &amp;#125;
     &amp;#125;,
     contentType:&amp;#39;application/json&amp;#39;,//请求体中内容类型
     dataType:&amp;#39;json&amp;#39;,//响应内容类型。
     data:json
 &amp;#125;);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;五、RMI实现RPC&#34;&gt;&lt;a href=&#34;#五、RMI实现RPC&#34; class=&#34;headerlink&#34; title=&#34;五、RMI实现RPC&#34;&gt;&lt;/a&gt;五、RMI实现RPC&lt;/h3&gt;&lt;h4 id=&#34;1-RMI简-介&#34;&gt;&lt;a href=&#34;#1-RMI简-介&#34; class=&#34;headerlink&#34; title=&#34;1     RMI简 介&#34;&gt;&lt;/a&gt;1     RMI简 介&lt;/h4&gt;&lt;p&gt;​	RMI(Remote Method Invocation) 远程方法调用。&lt;/p&gt;
&lt;p&gt;​	RMI是从JDK1.2推出的功能，它可以实现在一个Java应用中可以像调用本地方法一样调用另一个服务器中Java应用（JVM）中的内容。&lt;/p&gt;
&lt;p&gt;​	RMI 是Java语言的远程调用，无法实现跨语言。&lt;/p&gt;
&lt;h4 id=&#34;2-执行流程&#34;&gt;&lt;a href=&#34;#2-执行流程&#34; class=&#34;headerlink&#34; title=&#34;2     执行流程&#34;&gt;&lt;/a&gt;2     执行流程&lt;/h4&gt;&lt;img data-src=&#34;/2022/10/07/Distribution/RPC/rpc-03.png&#34; class=&#34;&#34;&gt;


&lt;p&gt;​	Registry(注册表)是放置所有服务器对象的命名空间。 每次服务端创建一个对象时，它都会使用bind()或rebind()方法注册该对象。 这些是使用称为绑定名称的唯一名称注册的。 &lt;/p&gt;
&lt;p&gt;​	要调用远程对象，客户端需要该对象的引用。即通过服务端绑定的名称从注册表中获取对象(lookup()方法)。&lt;/p&gt;
&lt;h4 id=&#34;3-API介绍&#34;&gt;&lt;a href=&#34;#3-API介绍&#34; class=&#34;headerlink&#34; title=&#34;3     API介绍&#34;&gt;&lt;/a&gt;3     API介绍&lt;/h4&gt;&lt;h5 id=&#34;3-1-Remote&#34;&gt;&lt;a href=&#34;#3-1-Remote&#34; class=&#34;headerlink&#34; title=&#34;3.1   Remote&#34;&gt;&lt;/a&gt;3.1   Remote&lt;/h5&gt;&lt;p&gt;​	java.rmi.Remote 定义了此接口为远程调用接口。如果接口被外部调用，需要继承此接口。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;public interface Remote&amp;#123;&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;3-2-RemoteException&#34;&gt;&lt;a href=&#34;#3-2-RemoteException&#34; class=&#34;headerlink&#34; title=&#34;3.2   RemoteException&#34;&gt;&lt;/a&gt;3.2   RemoteException&lt;/h4&gt;&lt;p&gt;​	java.rmi.RemoteException&lt;/p&gt;
&lt;p&gt;​	继承了Remote接口的接口中，如果方法是允许被远程调用的，需要抛出此异常。&lt;/p&gt;
&lt;h4 id=&#34;3-3-UnicastRemoteObject&#34;&gt;&lt;a href=&#34;#3-3-UnicastRemoteObject&#34; class=&#34;headerlink&#34; title=&#34;3.3   UnicastRemoteObject&#34;&gt;&lt;/a&gt;3.3   UnicastRemoteObject&lt;/h4&gt;&lt;p&gt;​	java.rmi.server.UnicastRemoteObject&lt;/p&gt;
&lt;p&gt;​	此类实现了Remote接口和Serializable接口。&lt;/p&gt;
&lt;p&gt;​	自定义接口实现类除了实现自定义接口还需要继承此类。&lt;/p&gt;
&lt;h4 id=&#34;3-4-LocateRegistry&#34;&gt;&lt;a href=&#34;#3-4-LocateRegistry&#34; class=&#34;headerlink&#34; title=&#34;3.4   LocateRegistry&#34;&gt;&lt;/a&gt;3.4   LocateRegistry&lt;/h4&gt;&lt;p&gt;​	java.rmi.registry.LocateRegistry&lt;/p&gt;
&lt;p&gt;​	可以通过LocateRegistry在本机上创建Registry，通过特定的端口就可以访问这个Registry。&lt;/p&gt;
&lt;h4 id=&#34;3-5-Naming&#34;&gt;&lt;a href=&#34;#3-5-Naming&#34; class=&#34;headerlink&#34; title=&#34;3.5   Naming&#34;&gt;&lt;/a&gt;3.5   Naming&lt;/h4&gt;&lt;p&gt;​	java.rmi.Naming&lt;/p&gt;
&lt;p&gt;​	Naming定义了发布内容可访问RMI名称。也是通过Naming获取到指定的远程方法。&lt;/p&gt;
&lt;h4 id=&#34;4-代码实现&#34;&gt;&lt;a href=&#34;#4-代码实现&#34; class=&#34;headerlink&#34; title=&#34;4     代码实现&#34;&gt;&lt;/a&gt;4     代码实现&lt;/h4&gt;&lt;h5 id=&#34;4-1-服务端创建&#34;&gt;&lt;a href=&#34;#4-1-服务端创建&#34; class=&#34;headerlink&#34; title=&#34;4.1   服务端创建&#34;&gt;&lt;/a&gt;4.1   服务端创建&lt;/h5&gt;&lt;p&gt;​	创建RmiServer项目&lt;/p&gt;
&lt;h5 id=&#34;4-1-1-编写接口&#34;&gt;&lt;a href=&#34;#4-1-1-编写接口&#34; class=&#34;headerlink&#34; title=&#34;4.1.1    编写接口&#34;&gt;&lt;/a&gt;4.1.1    编写接口&lt;/h5&gt;&lt;p&gt;​	com.msb.service.DemoService 编写&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;public interface DemoService extends Remote &amp;#123;
    String demo(String demo) throws RemoteException;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;4-1-2-编写实现类&#34;&gt;&lt;a href=&#34;#4-1-2-编写实现类&#34; class=&#34;headerlink&#34; title=&#34;4.1.2    编写实现类&#34;&gt;&lt;/a&gt;4.1.2    编写实现类&lt;/h5&gt;&lt;p&gt;​	com.msb.service.impl.DemoServiceImpl 编写。&lt;/p&gt;
&lt;p&gt;​	注意：构造方法是public的。默认生成protected&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;public class DemoServiceImpl extends UnicastRemoteObject implements DemoService &amp;#123;
    public DemoServiceImpl() throws RemoteException &amp;#123;
    &amp;#125;
    @Override
    public String demo(String demo) throws RemoteException &amp;#123;
        return demo+&amp;quot;123&amp;quot;;
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;4-1-3-编写主方法&#34;&gt;&lt;a href=&#34;#4-1-3-编写主方法&#34; class=&#34;headerlink&#34; title=&#34;4.1.3    编写主方法&#34;&gt;&lt;/a&gt;4.1.3    编写主方法&lt;/h5&gt;&lt;p&gt;​	编写com.msb.DemoServer类，生成主方法&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;public class DemoServiceImpl extends UnicastRemoteObject implements DemoService &amp;#123;
    public DemoServiceImpl() throws RemoteException &amp;#123;
    &amp;#125;
    @Override
    public String demo(String demo) throws RemoteException &amp;#123;
        return demo+&amp;quot;123&amp;quot;;
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;public class DemoStart &amp;#123;
    public static void main(String[] args) &amp;#123;
        try &amp;#123;
            //1创建接口实现类
            RmiDemo rmiDemo = new RmiDemoImpl();
            //2创建注册表
            LocateRegistry.createRegistry(8099);
            //3绑定服务
            Naming.bind(&amp;quot;rmi://localhost:8099/rmiDemo&amp;quot;,rmiDemo);

            System.out.println(&amp;quot;服务器启动！&amp;quot;);
        &amp;#125; catch (RemoteException e) &amp;#123;
            e.printStackTrace();
        &amp;#125; catch (AlreadyBoundException e) &amp;#123;
            e.printStackTrace();
        &amp;#125; catch (MalformedURLException e) &amp;#123;
            e.printStackTrace();
        &amp;#125;
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;4-1-4-运行项目&#34;&gt;&lt;a href=&#34;#4-1-4-运行项目&#34; class=&#34;headerlink&#34; title=&#34;4.1.4    运行项目&#34;&gt;&lt;/a&gt;4.1.4    运行项目&lt;/h5&gt;&lt;p&gt;​	运行后项目，项目一直处于启动状态，表示可以远程访问此项目中的远程方法。&lt;/p&gt;
&lt;h4 id=&#34;4-2-创建客户端代码&#34;&gt;&lt;a href=&#34;#4-2-创建客户端代码&#34; class=&#34;headerlink&#34; title=&#34;4.2   创建客户端代码&#34;&gt;&lt;/a&gt;4.2   创建客户端代码&lt;/h4&gt;&lt;p&gt;​	创建项目RmiClient&lt;/p&gt;
&lt;h5 id=&#34;4-2-1-复制服务端接口&#34;&gt;&lt;a href=&#34;#4-2-1-复制服务端接口&#34; class=&#34;headerlink&#34; title=&#34;4.2.1    复制服务端接口&#34;&gt;&lt;/a&gt;4.2.1    复制服务端接口&lt;/h5&gt;&lt;p&gt;​	把服务端com.msb.service.DemoService粘贴到项目中&lt;/p&gt;
&lt;h5 id=&#34;4-2-2-创建主方法类&#34;&gt;&lt;a href=&#34;#4-2-2-创建主方法类&#34; class=&#34;headerlink&#34; title=&#34;4.2.2    创建主方法类&#34;&gt;&lt;/a&gt;4.2.2    创建主方法类&lt;/h5&gt;&lt;p&gt;​	新建com.msb.DemoClient&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;public class DemoServiceImpl extends UnicastRemoteObject implements DemoService &amp;#123;
    public DemoServiceImpl() throws RemoteException &amp;#123;
    &amp;#125;
    @Override
    public String demo(String demo) throws RemoteException &amp;#123;
        return demo+&amp;quot;123&amp;quot;;
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;六、Zookeeper安装&#34;&gt;&lt;a href=&#34;#六、Zookeeper安装&#34; class=&#34;headerlink&#34; title=&#34;六、Zookeeper安装&#34;&gt;&lt;/a&gt;六、Zookeeper安装&lt;/h3&gt;&lt;h4 id=&#34;1-Zookeeper简介&#34;&gt;&lt;a href=&#34;#1-Zookeeper简介&#34; class=&#34;headerlink&#34; title=&#34;1     Zookeeper简介&#34;&gt;&lt;/a&gt;1     Zookeeper简介&lt;/h4&gt;&lt;p&gt;​	zookeeper分布式管理软件。常用它做注册中心（依赖zookeeper的发布&amp;#x2F;订阅功能）、配置文件中心、分布式锁配置、集群管理等。&lt;/p&gt;
&lt;p&gt;​	zookeeper一共就有两个版本。主要使用的是java语言写的。&lt;/p&gt;
&lt;h4 id=&#34;2-安装&#34;&gt;&lt;a href=&#34;#2-安装&#34; class=&#34;headerlink&#34; title=&#34;2     安装&#34;&gt;&lt;/a&gt;2     安装&lt;/h4&gt;&lt;h5 id=&#34;2-1-上传压缩文件&#34;&gt;&lt;a href=&#34;#2-1-上传压缩文件&#34; class=&#34;headerlink&#34; title=&#34;2.1   上传压缩文件&#34;&gt;&lt;/a&gt;2.1   上传压缩文件&lt;/h5&gt;&lt;p&gt;​	上传到 &amp;#x2F;usr&amp;#x2F;local&amp;#x2F;tmp中&lt;/p&gt;
&lt;h4 id=&#34;2-2-解压&#34;&gt;&lt;a href=&#34;#2-2-解压&#34; class=&#34;headerlink&#34; title=&#34;2.2   解压&#34;&gt;&lt;/a&gt;2.2   解压&lt;/h4&gt;&lt;pre&gt;&lt;code class=&#34;sh&#34;&gt;tar zxf apache-zookeeper-3.5.5-bin.tar.gz
cp -r apache-zookeeper-3.5.5-bin ../zookeeper
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;2-3-新建data目录&#34;&gt;&lt;a href=&#34;#2-3-新建data目录&#34; class=&#34;headerlink&#34; title=&#34;2.3   新建data目录&#34;&gt;&lt;/a&gt;2.3   新建data目录&lt;/h4&gt;&lt;p&gt;进入到zookeeper中&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;sh&#34;&gt;cd /usr/local/zookeeper
mkdir data
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;2-4-修改配置文件&#34;&gt;&lt;a href=&#34;#2-4-修改配置文件&#34; class=&#34;headerlink&#34; title=&#34;2.4   修改配置文件&#34;&gt;&lt;/a&gt;2.4   修改配置文件&lt;/h4&gt;&lt;p&gt;进入conf中&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;sh&#34;&gt;cd conf
cp zoo_sample.cfg zoo.cfg
vim zoo.cfg
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;修改dataDir为data文件夹路径&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;sh&#34;&gt;dataDir=/usr/local/zookeeper/data
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;2-5-启动zookeeper&#34;&gt;&lt;a href=&#34;#2-5-启动zookeeper&#34; class=&#34;headerlink&#34; title=&#34;2.5   启动zookeeper&#34;&gt;&lt;/a&gt;2.5   启动zookeeper&lt;/h4&gt;&lt;p&gt;进入bin文件夹&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;sh&#34;&gt;cd /usr/local/zookeeper/bin
./zkServer.sh start
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过status查看启动状态。稍微有个等待时间&lt;/p&gt;
&lt;p&gt;# .&amp;#x2F;zkServer.sh status&lt;/p&gt;
&lt;h3 id=&#34;六、Zookeeper安装-Docker&#34;&gt;&lt;a href=&#34;#六、Zookeeper安装-Docker&#34; class=&#34;headerlink&#34; title=&#34;六、Zookeeper安装(Docker)&#34;&gt;&lt;/a&gt;六、Zookeeper安装(Docker)&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;资料：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cuY25ibG9ncy5jb20va2luZ2tvby9wLzg3MzI0NDguaHRtbA==&#34;&gt;https://www.cnblogs.com/kingkoo/p/8732448.html&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL2F2ODA4NzQ2NjY/ZnJvbT1zZWFyY2gmYW1wO3NlaWQ9MTYyOTE0NTAyNTIxMTk5OTEwNCZhbXA7c3BtX2lkX2Zyb209MzMzLjMzNy4wLjA=&#34;&gt;https://www.bilibili.com/video/av80874666?from=search&amp;amp;seid=1629145025211999104&amp;amp;spm_id_from=333.337.0.0&lt;/span&gt;&lt;/p&gt;
&lt;h4 id=&#34;1-Zookeeper简介-1&#34;&gt;&lt;a href=&#34;#1-Zookeeper简介-1&#34; class=&#34;headerlink&#34; title=&#34;1     Zookeeper简介&#34;&gt;&lt;/a&gt;1     Zookeeper简介&lt;/h4&gt;&lt;p&gt;​	zookeeper分布式管理软件。常用它做注册中心（依赖zookeeper的发布&amp;#x2F;订阅功能）、配置文件中心、分布式锁配置、集群管理等。&lt;/p&gt;
&lt;p&gt;​	zookeeper一共就有两个版本。主要使用的是java语言写的。&lt;/p&gt;
&lt;h4 id=&#34;2-安装-1&#34;&gt;&lt;a href=&#34;#2-安装-1&#34; class=&#34;headerlink&#34; title=&#34;2     安装&#34;&gt;&lt;/a&gt;2     安装&lt;/h4&gt;&lt;h5 id=&#34;2-1-拉取镜像&#34;&gt;&lt;a href=&#34;#2-1-拉取镜像&#34; class=&#34;headerlink&#34; title=&#34;2.1   拉取镜像&#34;&gt;&lt;/a&gt;2.1   拉取镜像&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;自定义zookeeper目录&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;shell&#34;&gt;mkdir /root/zookeeper

mkdir /root/zookeeper/data #原因参照上面 -在docker中data其实也不用在宿主机行自己生成(目前如此)

#仓库官网查看版本或者用命令直接查
docker search zookeeper

#拉取特定版本（3.5）
docker pull zookeeper:3.5
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;2-2-创建并启动容器&#34;&gt;&lt;a href=&#34;#2-2-创建并启动容器&#34; class=&#34;headerlink&#34; title=&#34;2.2 创建并启动容器&#34;&gt;&lt;/a&gt;2.2 创建并启动容器&lt;/h4&gt;&lt;p&gt;​	&lt;strong&gt;注：就目前而且 好像直接在docker中使用 zookeeper 不需要过多的配置，直接用命令创建吧，下面的解释先不看，具体原因后面补充&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;命令：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;shell&#34;&gt;docker run -d --name zookeeper -v /root/zookeeper/data:/data -p 2181:2181 --restart always zookeeper:3.5
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;--restart always&lt;/code&gt;：始终重启&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vYWdlb3ZiL3AvMTUzMjg3OTYuaHRtbA==&#34;&gt;https://www.cnblogs.com/ageovb/p/15328796.html&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;解释&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;1、这里为啥只挂载了 data 目录–》因为当我们 没有直接的安装压缩包时，我们的就没有配置文件，所以我们直接生成，容器中就回自动生成conf文件，其中就有我们需要的 一系列配置文件，我们第一次创建的时候就可以如此，我们在进&lt;strong&gt;行配置文件的修改完成&lt;/strong&gt;后，要将所有配置文件放到我们  bash 目录中的 conf 文件中去。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;2、第一次进入容器&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;在bash目录下进入bin 目录然后输入开启客户端命令&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;shell&#34;&gt;./zkCli.sh
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;3、第二次进入容器&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;shell&#34;&gt;docker exec -it zookeeper /bin/bash  -p    端口号
或
docker exec -it zookeeper zkCli.sh
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;只看到这就可*，容器创建成功就可以直接用了，还没有出现问题。有待补充&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&#34;2-3-修改配置文件&#34;&gt;&lt;a href=&#34;#2-3-修改配置文件&#34; class=&#34;headerlink&#34; title=&#34;2.3   修改配置文件&#34;&gt;&lt;/a&gt;2.3   修改配置文件&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;配置文件来源&lt;ul&gt;
&lt;li&gt;1、可以去我们的资料中直接解压出&lt;strong&gt;conf&lt;/strong&gt;目录粘贴到我们的 zookeeper 目录中去&lt;/li&gt;
&lt;li&gt;2、可以直接进行第 3 步，完事之后直接会在容器中生成。找到conf文件，修改其中的 zoo.cfg文件，&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;进入容器后，找到conf中的 **zoo.cfg文件，接下来就是修改 &lt;strong&gt;dataDir&lt;/strong&gt; 路径为容器中的 data文件目录。&lt;/p&gt;
&lt;p&gt;前提是要下载 vim ，因为容器中没有，命令是：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;sh&#34;&gt;apt-get update

apt-get install -y vim

cd conf
# 没有zoo.cfg 就先拷贝 zoo_sample.cfg 两个其实是一个文件，内容相同
#cp zoo_sample.cfg zoo.cfg
vim zoo.cfg
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;修改dataDir为data文件夹路径&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;sh&#34;&gt;dataDir=/usr/local/zookeeper/data
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;注：docker集群搭建在solr笔记中&#34;&gt;&lt;a href=&#34;#注：docker集群搭建在solr笔记中&#34; class=&#34;headerlink&#34; title=&#34;注：docker集群搭建在solr笔记中&#34;&gt;&lt;/a&gt;注：docker集群搭建在solr笔记中&lt;/h3&gt;&lt;h3 id=&#34;七、Zookeeper客户端常用命令&#34;&gt;&lt;a href=&#34;#七、Zookeeper客户端常用命令&#34; class=&#34;headerlink&#34; title=&#34;七、Zookeeper客户端常用命令&#34;&gt;&lt;/a&gt;七、Zookeeper客户端常用命令&lt;/h3&gt;&lt;p&gt;​	进入到.&amp;#x2F;zkCli.sh命令行工具后，可以使用下面常用命令&lt;/p&gt;
&lt;h4 id=&#34;1-ls&#34;&gt;&lt;a href=&#34;#1-ls&#34; class=&#34;headerlink&#34; title=&#34;1    ls&#34;&gt;&lt;/a&gt;1    ls&lt;/h4&gt;&lt;p&gt;​	ls [-s][-R] &amp;#x2F;path&lt;/p&gt;
&lt;p&gt;​	-s 详细信息，替代老版的ls2&lt;/p&gt;
&lt;p&gt;​	-R 当前目录和子目录中内容都罗列出来&lt;/p&gt;
&lt;p&gt;​	例如：ls -R &amp;#x2F; 显示根目录下所有内容&lt;/p&gt;
&lt;h4 id=&#34;2-create&#34;&gt;&lt;a href=&#34;#2-create&#34; class=&#34;headerlink&#34; title=&#34;2     create&#34;&gt;&lt;/a&gt;2     create&lt;/h4&gt;&lt;p&gt;​	create &amp;#x2F;path [data]&lt;/p&gt;
&lt;p&gt;​	[data] 包含内容&lt;/p&gt;
&lt;p&gt;​	创建指定路径信息&lt;/p&gt;
&lt;p&gt;​	例如：create &amp;#x2F;demo 创建&amp;#x2F;demo&lt;/p&gt;
&lt;h4 id=&#34;3-get&#34;&gt;&lt;a href=&#34;#3-get&#34; class=&#34;headerlink&#34; title=&#34;3     get&#34;&gt;&lt;/a&gt;3     get&lt;/h4&gt;&lt;p&gt;​	get [-s] &amp;#x2F;path&lt;/p&gt;
&lt;p&gt;​	[-s] 详细信息&lt;/p&gt;
&lt;p&gt;​	查看指定路径下内容。&lt;/p&gt;
&lt;p&gt;​	例如： get -s &amp;#x2F;demo&lt;/p&gt;
&lt;img data-src=&#34;/2022/10/07/Distribution/RPC/rpc-04.png&#34; class=&#34;&#34;&gt;


&lt;p&gt;​	null:存放的数据&lt;/p&gt;
&lt;p&gt;​	cZxid:创建时zxid(znode每次改变时递增的事务id)&lt;/p&gt;
&lt;p&gt;​	ctime:创建时间戳&lt;/p&gt;
&lt;p&gt;​	mZxid:最近一次更新的zxid&lt;/p&gt;
&lt;p&gt;​	mtime:最近一次更新的时间戳&lt;/p&gt;
&lt;p&gt;​	pZxid:子节点的zxid&lt;/p&gt;
&lt;p&gt;​	cversion:子节点更新次数&lt;/p&gt;
&lt;p&gt;​	dataversion:节点数据更新次数&lt;/p&gt;
&lt;p&gt;​	aclVersion:节点ACL(授权信息)的更新次数&lt;/p&gt;
&lt;p&gt;​	ephemeralOwner:如果该节点为ephemeral节点(临时，生命周期与session一样), ephemeralOwner值表示与该节点绑定的session id. 如果该节点不是ephemeral节点, ephemeralOwner值为0.&lt;/p&gt;
&lt;p&gt;​	dataLength:节点数据字节数&lt;/p&gt;
&lt;p&gt;​	numChildren:子节点数量&lt;/p&gt;
&lt;h4 id=&#34;4-set&#34;&gt;&lt;a href=&#34;#4-set&#34; class=&#34;headerlink&#34; title=&#34;4     set&#34;&gt;&lt;/a&gt;4     set&lt;/h4&gt;&lt;p&gt;​	set &amp;#x2F;path data&lt;/p&gt;
&lt;p&gt;​	设置节点内容&lt;/p&gt;
&lt;h4 id=&#34;5-delete&#34;&gt;&lt;a href=&#34;#5-delete&#34; class=&#34;headerlink&#34; title=&#34;5     delete&#34;&gt;&lt;/a&gt;5     delete&lt;/h4&gt;&lt;p&gt;​	delete &amp;#x2F;path&lt;/p&gt;
&lt;p&gt;​	删除节点&lt;/p&gt;
&lt;h3 id=&#34;八、向Zookeeper中注册内容&#34;&gt;&lt;a href=&#34;#八、向Zookeeper中注册内容&#34; class=&#34;headerlink&#34; title=&#34;八、向Zookeeper中注册内容&#34;&gt;&lt;/a&gt;八、向Zookeeper中注册内容&lt;/h3&gt;&lt;p&gt;​	新建项目ZookeeperClient&lt;/p&gt;
&lt;h4 id=&#34;1-创建-x2F-demo&#34;&gt;&lt;a href=&#34;#1-创建-x2F-demo&#34; class=&#34;headerlink&#34; title=&#34;1     创建&amp;#x2F;demo&#34;&gt;&lt;/a&gt;1     创建&amp;#x2F;demo&lt;/h4&gt;&lt;p&gt;​	使用zookeeper的客户端命令工具创建&amp;#x2F;demo&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;sh&#34;&gt;./zkCli.sh
create /demos
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;2-添加依赖&#34;&gt;&lt;a href=&#34;#2-添加依赖&#34; class=&#34;headerlink&#34; title=&#34;2     添加依赖&#34;&gt;&lt;/a&gt;2     添加依赖&lt;/h4&gt;&lt;pre&gt;&lt;code class=&#34;xml&#34;&gt;    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.apache.zookeeper&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;zookeeper&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;3.5.5&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;3-编写代码&#34;&gt;&lt;a href=&#34;#3-编写代码&#34; class=&#34;headerlink&#34; title=&#34;3     编写代码&#34;&gt;&lt;/a&gt;3     编写代码&lt;/h4&gt;&lt;p&gt;​	创建类com.msb.MyApp。&lt;/p&gt;
&lt;p&gt;​	ZooDefs.Ids.OPEN_ACL_UNSAFE 表示权限。&lt;/p&gt;
&lt;p&gt;​	CreateMode.PERSISTENT_SEQUENTIAL 永久存储，文件内容编号递增。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;public class SendContent &amp;#123;
    public static void main(String[] args) &amp;#123;
        try &amp;#123;
            /**
             * 创建ZooKeeper对象
             * param1: zookeeper_IP+端口号
             * param2: 访问超时设置---时间设置长一点
             * param3: 通过观察者模式发出访问回复，当连接成功后，编写成功信息
             */
            ZooKeeper zooKeeper = new ZooKeeper(
                    &amp;quot;192.168.88.128:2181&amp;quot;,
                    1000000,
                    new Watcher() &amp;#123;
                        @Override
                        public void process(WatchedEvent watchedEvent) &amp;#123;
                            System.out.println(&amp;quot;获取链接&amp;quot;);
                        &amp;#125;
                    &amp;#125;
            );

            /**
             * 发送内容  向zookeeper服务器中
             * param1: 发送的文件
             * param2: 发送的内容(要转变成Bytes[])
             * param3: 权限
             * param4: 内容的模式
             */
            String result = zooKeeper.create(
                    &amp;quot;/demos/rmi_address&amp;quot;,
                    &amp;quot;rmi:localhost:8080/demoService&amp;quot;.getBytes(),
                    ZooDefs.Ids.OPEN_ACL_UNSAFE,
                    CreateMode.PERSISTENT_SEQUENTIAL
            );

            System.out.println(&amp;quot;result  -&amp;gt; &amp;quot;+result);
        &amp;#125; catch (IOException e) &amp;#123;
            e.printStackTrace();
        &amp;#125; catch (KeeperException e) &amp;#123;
            e.printStackTrace();
        &amp;#125; catch (InterruptedException e) &amp;#123;
            e.printStackTrace();
        &amp;#125;

    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;4-查看上传数据&#34;&gt;&lt;a href=&#34;#4-查看上传数据&#34; class=&#34;headerlink&#34; title=&#34;4     查看上传数据&#34;&gt;&lt;/a&gt;4     查看上传数据&lt;/h4&gt;&lt;p&gt;​	ls -R &amp;#x2F;            :查看列表&lt;/p&gt;
&lt;p&gt;​	get  &amp;#x2F;demo&amp;#x2F;nn0000000002     :查看内容&lt;/p&gt;
&lt;h3 id=&#34;九、-从zookeeper中发现内容&#34;&gt;&lt;a href=&#34;#九、-从zookeeper中发现内容&#34; class=&#34;headerlink&#34; title=&#34;九、    从zookeeper中发现内容&#34;&gt;&lt;/a&gt;九、    从zookeeper中发现内容&lt;/h3&gt;&lt;p&gt;​	在原有项目中新建一个类，类中编写主方法。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;public static void main(String[] args) &amp;#123;
    try &amp;#123;
        ZooKeeper zookeeper = new ZooKeeper(&amp;quot;192.168.32.128:2181&amp;quot;, 10000, new Watcher() &amp;#123;
            @Override
            public void process(WatchedEvent watchedEvent) &amp;#123;
                System.out.println(&amp;quot;获取连接&amp;quot;);
            &amp;#125;
        &amp;#125;);
        //获取列表
        List&amp;lt;String&amp;gt; list = zookeeper.getChildren(&amp;quot;/demo&amp;quot;, false);
        for (String child : list) &amp;#123;
            byte[] result = zookeeper.getData(&amp;quot;/demo/&amp;quot; + child, false, null);
            System.out.println(new String(result));
        &amp;#125;
    &amp;#125; catch (IOException e) &amp;#123;
        e.printStackTrace();
    &amp;#125; catch (KeeperException e) &amp;#123;
        e.printStackTrace();
    &amp;#125; catch (InterruptedException e) &amp;#123;
        e.printStackTrace();
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;十、手写RPC框架&#34;&gt;&lt;a href=&#34;#十、手写RPC框架&#34; class=&#34;headerlink&#34; title=&#34;十、手写RPC框架&#34;&gt;&lt;/a&gt;十、手写RPC框架&lt;/h3&gt;&lt;p&gt;​	使用Zookeeper作为注册中心，RMI作为连接技术，手写RPC框架。&lt;/p&gt;
&lt;h4 id=&#34;1-创建项目ParentDemo&#34;&gt;&lt;a href=&#34;#1-创建项目ParentDemo&#34; class=&#34;headerlink&#34; title=&#34;1     创建项目ParentDemo&#34;&gt;&lt;/a&gt;1     创建项目ParentDemo&lt;/h4&gt;&lt;p&gt;​	创建父项目ParentDemo。&lt;/p&gt;
&lt;p&gt;​	包含3个聚合子项目。&lt;/p&gt;
&lt;p&gt;​	pojo: service中需要的实体类&lt;/p&gt;
&lt;p&gt;​	service：包含被serviceimpl和consumer依赖的接口。&lt;/p&gt;
&lt;p&gt;​	serviceimpl:provider提供的服务内容&lt;/p&gt;
&lt;p&gt;​	consumer：消费者，调用服务内容。&lt;/p&gt;
&lt;h4 id=&#34;2-在父项目中添加依赖&#34;&gt;&lt;a href=&#34;#2-在父项目中添加依赖&#34; class=&#34;headerlink&#34; title=&#34;2     在父项目中添加依赖&#34;&gt;&lt;/a&gt;2     在父项目中添加依赖&lt;/h4&gt;&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;public static void main(String[] args) &amp;#123;
    try &amp;#123;
        ZooKeeper zookeeper = new ZooKeeper(&amp;quot;192.168.32.128:2181&amp;quot;, 10000, new Watcher() &amp;#123;
            @Override
            public void process(WatchedEvent watchedEvent) &amp;#123;
                System.out.println(&amp;quot;获取连接&amp;quot;);
            &amp;#125;
        &amp;#125;);
        //获取列表
        List&amp;lt;String&amp;gt; list = zookeeper.getChildren(&amp;quot;/demo&amp;quot;, false);
        for (String child : list) &amp;#123;
            byte[] result = zookeeper.getData(&amp;quot;/demo/&amp;quot; + child, false, null);
            System.out.println(new String(result));
        &amp;#125;
    &amp;#125; catch (IOException e) &amp;#123;
        e.printStackTrace();
    &amp;#125; catch (KeeperException e) &amp;#123;
        e.printStackTrace();
    &amp;#125; catch (InterruptedException e) &amp;#123;
        e.printStackTrace();
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;3-创建service项目&#34;&gt;&lt;a href=&#34;#3-创建service项目&#34; class=&#34;headerlink&#34; title=&#34;3     创建service项目&#34;&gt;&lt;/a&gt;3     创建service项目&lt;/h4&gt;&lt;h4 id=&#34;4-创建DemoService接口&#34;&gt;&lt;a href=&#34;#4-创建DemoService接口&#34; class=&#34;headerlink&#34; title=&#34;4     创建DemoService接口&#34;&gt;&lt;/a&gt;4     创建DemoService接口&lt;/h4&gt;&lt;p&gt;​	创建com.msb.DemoService&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;public interface DemoService extends Remote &amp;#123;
    String demo(String param) throws RemoteException;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;5-创建serviceimpl项目&#34;&gt;&lt;a href=&#34;#5-创建serviceimpl项目&#34; class=&#34;headerlink&#34; title=&#34;5     创建serviceimpl项目&#34;&gt;&lt;/a&gt;5     创建serviceimpl项目&lt;/h4&gt;&lt;p&gt;​	此项目编写接口具体实现，RMI服务发布和把信息发送到Zookeeper中。&lt;/p&gt;
&lt;p&gt;​	项目结构如下：&lt;/p&gt;
&lt;p&gt;​	在pom.xml中添加对service项目的依赖&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;xml&#34;&gt;&amp;lt;dependencies&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;artifactId&amp;gt;service&amp;lt;/artifactId&amp;gt;
        &amp;lt;groupId&amp;gt;com.msb&amp;lt;/groupId&amp;gt;
        &amp;lt;version&amp;gt;1.0.0&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;
&amp;lt;/dependencies&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;6-创建DemoServiceImpl&#34;&gt;&lt;a href=&#34;#6-创建DemoServiceImpl&#34; class=&#34;headerlink&#34; title=&#34;6     创建DemoServiceImpl&#34;&gt;&lt;/a&gt;6     创建DemoServiceImpl&lt;/h4&gt;&lt;p&gt;​	创建com.bjsxt.service.impl.DemoServiceImpl&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;public class DemoServiceImpl extends UnicastRemoteObject implements DemoService &amp;#123;
    public DemoServiceImpl() throws RemoteException &amp;#123;
    &amp;#125;

    @Override
    public String demo(String param) throws RemoteException&amp;#123;
        return param+&amp;quot;123&amp;quot;;
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;7-创建RmiRun&#34;&gt;&lt;a href=&#34;#7-创建RmiRun&#34; class=&#34;headerlink&#34; title=&#34;7     创建RmiRun&#34;&gt;&lt;/a&gt;7     创建RmiRun&lt;/h4&gt;&lt;p&gt;​	创建com.msb.RmiRun。实现RMI服务的发布和Zookeeper消息的发布。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;public class RmiRun &amp;#123;
    public static void main(String[] args) &amp;#123;
        try &amp;#123;
            DemoService demoService = new DemoServiceImpl();
            LocateRegistry.createRegistry(8888);
            String url = &amp;quot;rmi://localhost:8888/demoService&amp;quot;;
            Naming.bind(url,demoService);
            ZooKeeper zookeeper = new ZooKeeper(&amp;quot;192.168.32.128:2181&amp;quot;, 10000, new Watcher() &amp;#123;
                @Override
                public void process(WatchedEvent watchedEvent) &amp;#123;
                    System.out.println(&amp;quot;获取连接&amp;quot;);
                &amp;#125;
            &amp;#125;);
            String content = zookeeper.create(&amp;quot;/demo/demoService&amp;quot;,url.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);
            System.out.println(&amp;quot;服务发布成功。。。。&amp;quot;);
        &amp;#125; catch (AlreadyBoundException e) &amp;#123;
            e.printStackTrace();
        &amp;#125; catch (IOException e) &amp;#123;
            e.printStackTrace();
        &amp;#125; catch (KeeperException e) &amp;#123;
            e.printStackTrace();
        &amp;#125; catch (InterruptedException e) &amp;#123;
            e.printStackTrace();
        &amp;#125;
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;8-创建Consumer项目&#34;&gt;&lt;a href=&#34;#8-创建Consumer项目&#34; class=&#34;headerlink&#34; title=&#34;8     创建Consumer项目&#34;&gt;&lt;/a&gt;8     创建Consumer项目&lt;/h4&gt;&lt;p&gt;​	新建consumer项目，此项目需要从zookeeper中获取rmi信息，并调用rmi服务&lt;/p&gt;
&lt;p&gt;​	在pom.xml中添加对service项目的依赖&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;xml&#34;&gt;&amp;lt;dependencies&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;artifactId&amp;gt;service&amp;lt;/artifactId&amp;gt;
        &amp;lt;groupId&amp;gt;com.msb&amp;lt;/groupId&amp;gt;
        &amp;lt;version&amp;gt;1.0.0&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;
&amp;lt;/dependencies&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;9-创建接口和实现类&#34;&gt;&lt;a href=&#34;#9-创建接口和实现类&#34; class=&#34;headerlink&#34; title=&#34;9     创建接口和实现类&#34;&gt;&lt;/a&gt;9     创建接口和实现类&lt;/h4&gt;&lt;p&gt;​	创建com.msb.service.ConsumerService接口&lt;/p&gt;
&lt;p&gt;​	创建com.msb.service.impl.ConsumerServiceImpl实现类 &lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;public interface ConsumerService &amp;#123;
    String consumerService(String param);
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;@Service
public class ConsumerServiceImpl implements ConsumerService &amp;#123;
    @Override
    public String consumerService(String param) &amp;#123;
        try &amp;#123;
            ZooKeeper zookeeper = new ZooKeeper(&amp;quot;192.168.32.128:2181&amp;quot;, 10000, new Watcher() &amp;#123;
                @Override
                public void process(WatchedEvent watchedEvent) &amp;#123;
                    System.out.println(&amp;quot;获取连接&amp;quot;);
                &amp;#125;
            &amp;#125;);
            byte[] urlByte = zookeeper.getData(&amp;quot;/demo/demoService&amp;quot;, false, null);
            DemoService demoService =(DemoService) Naming.lookup(new String(urlByte));
            String result = demoService.demo(param);
            System.out.println(result);
            return result;
        &amp;#125; catch (IOException e) &amp;#123;
            e.printStackTrace();
        &amp;#125; catch (KeeperException e) &amp;#123;
            e.printStackTrace();
        &amp;#125; catch (InterruptedException e) &amp;#123;
            e.printStackTrace();
        &amp;#125; catch (NotBoundException e) &amp;#123;
            e.printStackTrace();
        &amp;#125;
        return null;
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;10-创建控制器&#34;&gt;&lt;a href=&#34;#10-创建控制器&#34; class=&#34;headerlink&#34; title=&#34;10  创建控制器&#34;&gt;&lt;/a&gt;10  创建控制器&lt;/h4&gt;&lt;p&gt;​	创建com.msb.controller.DemoController控制器&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;@Controller
public class DemoController &amp;#123;

    @Autowired
    private ConsumerService consumerService;

    @RequestMapping(&amp;quot;/demo&amp;quot;)
    @ResponseBody
    public String demo(String param)&amp;#123;
        return consumerService.consumerService(param);
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;11-创建启动器&#34;&gt;&lt;a href=&#34;#11-创建启动器&#34; class=&#34;headerlink&#34; title=&#34;11  创建启动器&#34;&gt;&lt;/a&gt;11  创建启动器&lt;/h4&gt;&lt;p&gt;​	创建com.msb.ConsumerApplication&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;@SpringBootApplication
public class ConsumerApplication &amp;#123;
    public static void main(String[] args) &amp;#123;
        SpringApplication.run(ConsumerApplication.class,args);
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;12-测试&#34;&gt;&lt;a href=&#34;#12-测试&#34; class=&#34;headerlink&#34; title=&#34;12  测试&#34;&gt;&lt;/a&gt;12  测试&lt;/h4&gt;&lt;p&gt;​	在浏览器输入：&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cDovL2xvY2FsaG9zdDo4MDgwL2RlbW8/cGFyYW09ZGVtbw==&#34;&gt;http://localhost:8080/demo?param=demo&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;​	观察结果是否是：demo123&lt;/p&gt;
</content>
        <category term="分布式" />
        <category term="RPC" />
        <updated>2022-10-06T16:00:00.000Z</updated>
    </entry>
</feed>
