{
    "version": "https://jsonfeed.org/version/1",
    "title": "记录“美食”每刻 • All posts by \"orm\" tag",
    "description": "记录“美食”每刻",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/2022/10/07/ORM/MybatisPlus/",
            "url": "http://example.com/2022/10/07/ORM/MybatisPlus/",
            "title": "MybatisPlus",
            "date_published": "2022-10-06T16:00:00.000Z",
            "content_html": "<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2Jhb21pZG91L215YmF0aXMtcGx1cw==\">MyBatis-Plus (opens new window)</span>（简称 MP）是一个 <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubXliYXRpcy5vcmcvbXliYXRpcy0zLw==\">MyBatis (opens new window)</span>的增强工具，在 MyBatis 的基础上只做增强不做改变，为简化开发、提高效率而生。</p>\n<blockquote>\n<p>愿景</p>\n<p>我们的愿景是成为 MyBatis 最好的搭档，就像 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYW9taWRvdS5jb20vaW1nL2NvbnRyYS5qcGc=\">魂斗罗</span> 中的 1P、2P，基友搭配，效率翻倍。</p>\n</blockquote>\n<h2 id=\"特性\"><a href=\"#特性\" class=\"headerlink\" title=\"特性\"></a>特性</h2><ul>\n<li><strong>无侵入</strong>：只做增强不做改变，引入它不会对现有工程产生影响，如丝般顺滑</li>\n<li><strong>损耗小</strong>：启动即会自动注入基本 CURD，性能基本无损耗，直接面向对象操作</li>\n<li><strong>强大的 CRUD 操作</strong>：内置通用 Mapper、通用 Service，仅仅通过少量配置即可实现单表大部分 CRUD 操作，更有强大的条件构造器，满足各类使用需求</li>\n<li><strong>支持 Lambda 形式调用</strong>：通过 Lambda 表达式，方便的编写各类查询条件，无需再担心字段写错</li>\n<li><strong>支持主键自动生成</strong>：支持多达 4 种主键策略（内含分布式唯一 ID 生成器 - Sequence），可自由配置，完美解决主键问题</li>\n<li><strong>支持 ActiveRecord 模式</strong>：支持 ActiveRecord 形式调用，实体类只需继承 Model 类即可进行强大的 CRUD 操作</li>\n<li><strong>支持自定义全局通用操作</strong>：支持全局通用方法注入（ Write once, use anywhere ）</li>\n<li><strong>内置代码生成器</strong>：采用代码或者 Maven 插件可快速生成 Mapper 、 Model 、 Service 、 Controller 层代码，支持模板引擎，更有超多自定义配置等您来使用</li>\n<li><strong>内置分页插件</strong>：基于 MyBatis 物理分页，开发者无需关心具体操作，配置好插件之后，写分页等同于普通 List 查询</li>\n<li><strong>分页插件支持多种数据库</strong>：支持 MySQL、MariaDB、Oracle、DB2、H2、HSQL、SQLite、Postgre、SQLServer 等多种数据库</li>\n<li><strong>内置性能分析插件</strong>：可输出 SQL 语句以及其执行时间，建议开发测试时启用该功能，能快速揪出慢查询</li>\n<li><strong>内置全局拦截插件</strong>：提供全表 delete 、 update 操作智能分析阻断，也可自定义拦截规则，预防误操作</li>\n</ul>\n<h2 id=\"支持数据库\"><a href=\"#支持数据库\" class=\"headerlink\" title=\"支持数据库\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYW9taWRvdS5jb20vcGFnZXMvMjQxMTJmLyMlRTYlOTQlQUYlRTYlOEMlODElRTYlOTUlQjAlRTYlOEQlQUUlRTUlQkElOTM=\"></span>支持数据库</h2><blockquote>\n<p>任何能使用 <code>MyBatis</code> 进行 CRUD, 并且支持标准 SQL 的数据库，具体支持情况如下，如果不在下列表查看分页部分教程 PR 您的支持。</p>\n</blockquote>\n<ul>\n<li>MySQL，Oracle，DB2，H2，HSQL，SQLite，PostgreSQL，SQLServer，Phoenix，Gauss ，ClickHouse，Sybase，OceanBase，Firebird，Cubrid，Goldilocks，csiidb</li>\n<li>达梦数据库，虚谷数据库，人大金仓数据库，南大通用(华库)数据库，南大通用数据库，神通数据库，瀚高数据库</li>\n</ul>\n<h2 id=\"框架结构\"><a href=\"#框架结构\" class=\"headerlink\" title=\"框架结构\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYW9taWRvdS5jb20vcGFnZXMvMjQxMTJmLyMlRTYlQTElODYlRTYlOUUlQjYlRTclQkIlOTMlRTYlOUUlODQ=\"></span>框架结构</h2><img data-src=\"/2022/10/07/ORM/MybatisPlus/mybatis-plus-framework.jpg\" class=\"\" title=\"framework\">\n\n\n\n<h1 id=\"快速使用\"><a href=\"#快速使用\" class=\"headerlink\" title=\"快速使用\"></a>快速使用</h1><blockquote>\n<p>使用的mybatis 3.5之前版本，也就是官方的旧版本</p>\n</blockquote>\n<h2 id=\"初始化工程\"><a href=\"#初始化工程\" class=\"headerlink\" title=\"初始化工程\"></a>初始化工程</h2><p>创建一个空的 Spring Boot 工程（工程将以 H2 作为默认数据库进行演示）</p>\n<p>提示</p>\n<p>可以使用 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9zdGFydC5zcHJpbmcuaW8v\">Spring Initializer (opens new window)</span>快速初始化一个 Spring Boot 工程</p>\n<h2 id=\"pom-添加依赖\"><a href=\"#pom-添加依赖\" class=\"headerlink\" title=\"pom 添加依赖\"></a><code>pom</code> 添加依赖</h2><pre><code class=\"xml\">    &lt;properties&gt;\n        &lt;java.version&gt;1.8&lt;/java.version&gt;\n        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;\n        &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;\n        &lt;spring-boot.version&gt;2.3.7.RELEASE&lt;/spring-boot.version&gt;\n    &lt;/properties&gt;\n\n    &lt;dependencies&gt;\n        &lt;!--freemarker--&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.freemarker&lt;/groupId&gt;\n            &lt;artifactId&gt;freemarker&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n        &lt;!--velocity--&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.apache.velocity&lt;/groupId&gt;\n            &lt;artifactId&gt;velocity-engine-core&lt;/artifactId&gt;\n            &lt;version&gt;2.2&lt;/version&gt;\n        &lt;/dependency&gt;\n        &lt;!--generator--&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;com.baomidou&lt;/groupId&gt;\n            &lt;artifactId&gt;mybatis-plus-generator&lt;/artifactId&gt;\n            &lt;version&gt;3.4.1&lt;/version&gt;\n        &lt;/dependency&gt;\n        &lt;!--mybatis-plus--&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;com.baomidou&lt;/groupId&gt;\n            &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;\n            &lt;version&gt;3.4.1&lt;/version&gt;\n        &lt;/dependency&gt;\n        &lt;!--jdbc--&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;mysql&lt;/groupId&gt;\n            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;\n            &lt;scope&gt;runtime&lt;/scope&gt;\n        &lt;/dependency&gt;\n        &lt;!--lombok--&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;\n            &lt;artifactId&gt;lombok&lt;/artifactId&gt;\n            &lt;optional&gt;true&lt;/optional&gt;\n        &lt;/dependency&gt;\n        &lt;!--spring-start-web--&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n        &lt;!--spring-test--&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;\n            &lt;scope&gt;test&lt;/scope&gt;\n            &lt;exclusions&gt;\n                &lt;exclusion&gt;\n                    &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt;\n                    &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt;\n                &lt;/exclusion&gt;\n            &lt;/exclusions&gt;\n        &lt;/dependency&gt;\n        &lt;!--junit4--&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;junit&lt;/groupId&gt;\n            &lt;artifactId&gt;junit&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n    &lt;/dependencies&gt;\n\n    &lt;dependencyManagement&gt;\n        &lt;dependencies&gt;\n            &lt;dependency&gt;\n                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n                &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt;\n                &lt;version&gt;$&#123;spring-boot.version&#125;&lt;/version&gt;\n                &lt;type&gt;pom&lt;/type&gt;\n                &lt;scope&gt;import&lt;/scope&gt;\n            &lt;/dependency&gt;\n        &lt;/dependencies&gt;\n    &lt;/dependencyManagement&gt;\n\n    &lt;build&gt;\n        &lt;plugins&gt;\n            &lt;plugin&gt;\n                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;\n                &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;\n                &lt;version&gt;3.8.1&lt;/version&gt;\n                &lt;configuration&gt;\n                    &lt;source&gt;1.8&lt;/source&gt;\n                    &lt;target&gt;1.8&lt;/target&gt;\n                    &lt;encoding&gt;UTF-8&lt;/encoding&gt;\n                &lt;/configuration&gt;\n            &lt;/plugin&gt;\n            &lt;plugin&gt;\n                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;\n                &lt;version&gt;2.3.7.RELEASE&lt;/version&gt;\n                &lt;configuration&gt;\n                    &lt;mainClass&gt;com.example.TestMybatisplusApplication&lt;/mainClass&gt;\n                &lt;/configuration&gt;\n                &lt;executions&gt;\n                    &lt;execution&gt;\n                        &lt;id&gt;repackage&lt;/id&gt;\n                        &lt;goals&gt;\n                            &lt;goal&gt;repackage&lt;/goal&gt;\n                        &lt;/goals&gt;\n                    &lt;/execution&gt;\n                &lt;/executions&gt;\n            &lt;/plugin&gt;\n        &lt;/plugins&gt;\n    &lt;/build&gt;\n</code></pre>\n<h2 id=\"模板准备\"><a href=\"#模板准备\" class=\"headerlink\" title=\"模板准备\"></a>模板准备</h2><p>因为个人习惯原因，我修改了一下entity的模板。</p>\n<blockquote>\n<p>在<code>resource/templates </code>下创建一个<code>MyEntity.java.ftl</code>(就这个名字吧，不然还要改代码，再者这个没啥用，只用于我们的逆向工程) ，直接将下面的内容粘贴创建即可。</p>\n<p>注意：</p>\n<ul>\n<li>我用的模板引擎是 <code>freemarker</code> 一定得加依赖</li>\n<li>用 .vm 就要加 <code>velocity</code> 依赖</li>\n</ul>\n</blockquote>\n<h3 id=\"ftl文件\"><a href=\"#ftl文件\" class=\"headerlink\" title=\".ftl文件\"></a>.ftl文件</h3><pre><code class=\"ftl\">package $&#123;package.Entity&#125;;\n\n&lt;#list table.importPackages as pkg&gt;\nimport $&#123;pkg&#125;;\n&lt;/#list&gt;\n&lt;#if swagger2&gt;\n&lt;/#if&gt;\n&lt;#if entityLombokModel&gt;\nimport lombok.*;\n&lt;/#if&gt;\n\n/**\n * &lt;p&gt;\n * $&#123;table.comment!&#125;\n * &lt;/p&gt;\n *\n * @author $&#123;author&#125;\n * @since $&#123;date&#125;\n */\n&lt;#if entityLombokModel&gt;\n    &lt;#if superEntityClass??&gt;\n@EqualsAndHashCode(callSuper = true)\n    &lt;#else&gt;\n@EqualsAndHashCode(callSuper = false)\n    &lt;/#if&gt;\n    &lt;#if chainModel&gt;\n@Accessors(chain = true)\n    &lt;/#if&gt;\n&lt;/#if&gt;\n&lt;#if table.convert&gt;\n@TableName(&quot;$&#123;table.name&#125;&quot;)\n&lt;/#if&gt;\n@AllArgsConstructor\n@NoArgsConstructor\n@Data\n@ToString\n&lt;#if superEntityClass??&gt;\npublic class $&#123;entity&#125; extends $&#123;superEntityClass&#125;&lt;#if activeRecord&gt;&lt;$&#123;entity&#125;&gt;&lt;/#if&gt; &#123;\n&lt;#elseif activeRecord&gt;\npublic class $&#123;entity&#125; extends Model&lt;$&#123;entity&#125;&gt; &#123;\n&lt;#else&gt;\npublic class $&#123;entity&#125; implements Serializable &#123;\n&lt;/#if&gt;\n\n&lt;#if entitySerialVersionUID&gt;\n    private static final long serialVersionUID = 1L;\n&lt;/#if&gt;\n&lt;#-- ----------  BEGIN 字段循环遍历  ----------&gt;\n&lt;#list table.fields as field&gt;\n    &lt;#if field.keyFlag&gt;\n        &lt;#assign keyPropertyName=&quot;$&#123;field.propertyName&#125;&quot;/&gt;\n    &lt;/#if&gt;\n\n    &lt;#if field.comment!?length gt 0&gt;\n        &lt;#if swagger2&gt;\n    @ApiModelProperty(value = &quot;$&#123;field.comment&#125;&quot;)\n        &lt;#else&gt;\n    /**\n     * $&#123;field.comment&#125;\n     */\n        &lt;/#if&gt;\n    &lt;/#if&gt;\n    &lt;#if field.keyFlag&gt;\n        &lt;#-- 主键 --&gt;\n        &lt;#if field.keyIdentityFlag&gt;\n    @TableId(value = &quot;$&#123;field.annotationColumnName&#125;&quot;, type = IdType.AUTO)\n        &lt;#elseif idType??&gt;\n    @TableId(value = &quot;$&#123;field.annotationColumnName&#125;&quot;, type = IdType.$&#123;idType&#125;)\n        &lt;#elseif field.convert&gt;\n    @TableId(&quot;$&#123;field.annotationColumnName&#125;&quot;)\n        &lt;/#if&gt;\n        &lt;#-- 普通字段 --&gt;\n    &lt;#elseif field.fill??&gt;\n    &lt;#-- -----   存在字段填充设置   -----&gt;\n        &lt;#if field.convert&gt;\n    @TableField(value = &quot;$&#123;field.annotationColumnName&#125;&quot;, fill = FieldFill.$&#123;field.fill&#125;)\n        &lt;#else&gt;\n    @TableField(fill = FieldFill.$&#123;field.fill&#125;)\n        &lt;/#if&gt;\n    &lt;#elseif field.convert&gt;\n    @TableField(&quot;$&#123;field.annotationColumnName&#125;&quot;)\n    &lt;/#if&gt;\n    &lt;#-- 乐观锁注解 --&gt;\n    &lt;#if (versionFieldName!&quot;&quot;) == field.name&gt;\n    @Version\n    &lt;/#if&gt;\n    &lt;#-- 逻辑删除注解 --&gt;\n    &lt;#if (logicDeleteFieldName!&quot;&quot;) == field.name&gt;\n    @TableLogic\n    &lt;/#if&gt;\n    private $&#123;field.propertyType&#125; $&#123;field.propertyName&#125;;\n&lt;/#list&gt;\n&lt;#------------  END 字段循环遍历  ----------&gt;\n\n&lt;#if !entityLombokModel&gt;\n    &lt;#list table.fields as field&gt;\n        &lt;#if field.propertyType == &quot;boolean&quot;&gt;\n            &lt;#assign getprefix=&quot;is&quot;/&gt;\n        &lt;#else&gt;\n            &lt;#assign getprefix=&quot;get&quot;/&gt;\n        &lt;/#if&gt;\n    public $&#123;field.propertyType&#125; $&#123;getprefix&#125;$&#123;field.capitalName&#125;() &#123;\n        return $&#123;field.propertyName&#125;;\n    &#125;\n\n    &lt;#if chainModel&gt;\n    public $&#123;entity&#125; set$&#123;field.capitalName&#125;($&#123;field.propertyType&#125; $&#123;field.propertyName&#125;) &#123;\n    &lt;#else&gt;\n    public void set$&#123;field.capitalName&#125;($&#123;field.propertyType&#125; $&#123;field.propertyName&#125;) &#123;\n    &lt;/#if&gt;\n        this.$&#123;field.propertyName&#125; = $&#123;field.propertyName&#125;;\n        &lt;#if chainModel&gt;\n        return this;\n        &lt;/#if&gt;\n    &#125;\n    &lt;/#list&gt;\n&lt;/#if&gt;\n\n&lt;#if entityColumnConstant&gt;\n    &lt;#list table.fields as field&gt;\n    public static final String $&#123;field.name?upper_case&#125; = &quot;$&#123;field.name&#125;&quot;;\n\n    &lt;/#list&gt;\n&lt;/#if&gt;\n&lt;#if activeRecord&gt;\n    @Override\n    protected Serializable pkVal() &#123;\n    &lt;#if keyPropertyName??&gt;\n        return this.$&#123;keyPropertyName&#125;;\n    &lt;#else&gt;\n        return null;\n    &lt;/#if&gt;\n    &#125;\n\n&lt;/#if&gt;\n&lt;#if !entityLombokModel&gt;\n    @Override\n    public String toString() &#123;\n        return &quot;$&#123;entity&#125;&#123;&quot; +\n    &lt;#list table.fields as field&gt;\n        &lt;#if field_index==0&gt;\n            &quot;$&#123;field.propertyName&#125;=&quot; + $&#123;field.propertyName&#125; +\n        &lt;#else&gt;\n            &quot;, $&#123;field.propertyName&#125;=&quot; + $&#123;field.propertyName&#125; +\n        &lt;/#if&gt;\n    &lt;/#list&gt;\n        &quot;&#125;&quot;;\n    &#125;\n&lt;/#if&gt;\n&#125;\n</code></pre>\n<h3 id=\"vm文件\"><a href=\"#vm文件\" class=\"headerlink\" title=\".vm文件\"></a>.vm文件</h3><pre><code class=\"vm\">package $&#123;package.Entity&#125;;\n\n#foreach($pkg in $&#123;table.importPackages&#125;)\nimport $&#123;pkg&#125;;\n#end\n#if($&#123;entityLombokModel&#125;)\nimport lombok.*;\n#end\n\n/**\n * &lt;p&gt;\n * $!&#123;table.comment&#125;\n * &lt;/p&gt;\n *\n * @author $&#123;author&#125;\n * @since $&#123;date&#125;\n */\n#if($&#123;entityLombokModel&#125;)\n  #if($&#123;superEntityClass&#125;)\n@EqualsAndHashCode(callSuper = true)\n  #else\n@EqualsAndHashCode(callSuper = false)\n  #end\n#end\n#if($&#123;table.convert&#125;)\n@TableName(&quot;$&#123;table.name&#125;&quot;)\n#end\n@AllArgsConstructor\n@NoArgsConstructor\n@Data\n@ToString\n#if($&#123;superEntityClass&#125;)\npublic class $&#123;entity&#125; extends $&#123;superEntityClass&#125;#if($&#123;activeRecord&#125;)&lt;$&#123;entity&#125;&gt;#end &#123;\n#elseif($&#123;activeRecord&#125;)\npublic class $&#123;entity&#125; extends Model&lt;$&#123;entity&#125;&gt; &#123;\n#else\npublic class $&#123;entity&#125; implements Serializable &#123;\n#end\n\n#if($&#123;entitySerialVersionUID&#125;)\n    private static final long serialVersionUID = 1L;\n#end\n## ----------  BEGIN 字段循环遍历  ----------\n#foreach($field in $&#123;table.fields&#125;)\n\n#if($&#123;field.keyFlag&#125;)\n#set($keyPropertyName=$&#123;field.propertyName&#125;)\n#end\n#if(&quot;$!field.comment&quot; != &quot;&quot;)\n  #if($&#123;swagger2&#125;)\n    @ApiModelProperty(value = &quot;$&#123;field.comment&#125;&quot;)\n  #else\n    /**\n     * $&#123;field.comment&#125;\n     */\n  #end\n#end\n#if($&#123;field.keyFlag&#125;)\n## 主键\n  #if($&#123;field.keyIdentityFlag&#125;)\n    @TableId(value = &quot;$&#123;field.annotationColumnName&#125;&quot;, type = IdType.AUTO)\n  #elseif(!$null.isNull($&#123;idType&#125;) &amp;&amp; &quot;$!idType&quot; != &quot;&quot;)\n    @TableId(value = &quot;$&#123;field.annotationColumnName&#125;&quot;, type = IdType.$&#123;idType&#125;)\n  #elseif($&#123;field.convert&#125;)\n    @TableId(&quot;$&#123;field.annotationColumnName&#125;&quot;)\n  #end\n## 普通字段\n#elseif($&#123;field.fill&#125;)\n## -----   存在字段填充设置   -----\n  #if($&#123;field.convert&#125;)\n    @TableField(value = &quot;$&#123;field.annotationColumnName&#125;&quot;, fill = FieldFill.$&#123;field.fill&#125;)\n  #else\n    @TableField(fill = FieldFill.$&#123;field.fill&#125;)\n  #end\n#elseif($&#123;field.convert&#125;)\n    @TableField(&quot;$&#123;field.annotationColumnName&#125;&quot;)\n#end\n## 乐观锁注解\n#if($&#123;versionFieldName&#125;==$&#123;field.name&#125;)\n    @Version\n#end\n## 逻辑删除注解\n#if($&#123;logicDeleteFieldName&#125;==$&#123;field.name&#125;)\n    @TableLogic\n#end\n    private $&#123;field.propertyType&#125; $&#123;field.propertyName&#125;;\n#end\n## ----------  END 字段循环遍历  ----------\n\n#if(!$&#123;entityLombokModel&#125;)\n#foreach($field in $&#123;table.fields&#125;)\n  #if($&#123;field.propertyType.equals(&quot;boolean&quot;)&#125;)\n    #set($getprefix=&quot;is&quot;)\n  #else\n    #set($getprefix=&quot;get&quot;)\n  #end\n\n    public $&#123;field.propertyType&#125; $&#123;getprefix&#125;$&#123;field.capitalName&#125;() &#123;\n        return $&#123;field.propertyName&#125;;\n    &#125;\n\n  #if($&#123;chainModel&#125;)\n    public $&#123;entity&#125; set$&#123;field.capitalName&#125;($&#123;field.propertyType&#125; $&#123;field.propertyName&#125;) &#123;\n  #else\n    public void set$&#123;field.capitalName&#125;($&#123;field.propertyType&#125; $&#123;field.propertyName&#125;) &#123;\n  #end\n        this.$&#123;field.propertyName&#125; = $&#123;field.propertyName&#125;;\n  #if($&#123;chainModel&#125;)\n        return this;\n  #end\n    &#125;\n#end\n## --foreach end---\n#end\n## --end of #if(!$&#123;entityLombokModel&#125;)--\n\n#if($&#123;entityColumnConstant&#125;)\n  #foreach($field in $&#123;table.fields&#125;)\n    public static final String $&#123;field.name.toUpperCase()&#125; = &quot;$&#123;field.name&#125;&quot;;\n\n  #end\n#end\n#if($&#123;activeRecord&#125;)\n    @Override\n    protected Serializable pkVal() &#123;\n  #if($&#123;keyPropertyName&#125;)\n        return this.$&#123;keyPropertyName&#125;;\n  #else\n        return null;\n  #end\n    &#125;\n\n#end\n#if(!$&#123;entityLombokModel&#125;)\n    @Override\n    public String toString() &#123;\n        return &quot;$&#123;entity&#125;&#123;&quot; +\n  #foreach($field in $&#123;table.fields&#125;)\n    #if($!&#123;foreach.index&#125;==0)\n        &quot;$&#123;field.propertyName&#125;=&quot; + $&#123;field.propertyName&#125; +\n    #else\n        &quot;, $&#123;field.propertyName&#125;=&quot; + $&#123;field.propertyName&#125; +\n    #end\n  #end\n        &quot;&#125;&quot;;\n    &#125;\n#end\n&#125;\n</code></pre>\n<h2 id=\"逆向工程\"><a href=\"#逆向工程\" class=\"headerlink\" title=\"逆向工程\"></a>逆向工程</h2><blockquote>\n<p>通用模板代码，符合我的习惯。</p>\n<p>其他具体的风格配置可以因人而异再次修改。代码中注释很多</p>\n</blockquote>\n<pre><code class=\"java\">import com.baomidou.mybatisplus.core.toolkit.StringPool;\nimport com.baomidou.mybatisplus.generator.AutoGenerator;\nimport com.baomidou.mybatisplus.generator.InjectionConfig;\nimport com.baomidou.mybatisplus.generator.config.*;\nimport com.baomidou.mybatisplus.generator.config.po.TableInfo;\nimport com.baomidou.mybatisplus.generator.config.rules.NamingStrategy;\nimport com.baomidou.mybatisplus.generator.engine.FreemarkerTemplateEngine;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Objects;\nimport java.util.Scanner;\n\npublic class Generator &#123;\n\n    /*\n    * 逆向工程\n    * 要修改前缀、后缀的东西策略中，\n    * 其他的修改去代码里面翻一翻，大多数都注释了，找不到了可以看官网\n    *  */\n    public static void main(String[] args) &#123;\n        Scanner scanner = new Scanner(System.in);\n        System.out.println(&quot;====================================&quot;);\n        System.out.println(&quot;==============1.生成部分表============&quot;);\n        System.out.println(&quot;==============2.生成全部表============&quot;);\n        System.out.println(&quot;=====================================&quot;);\n        int i = scanner.nextInt();\n        switch (i) &#123;\n            case 1:\n                System.out.println(&quot;请输入你要逆向生成的表名，用 , 号分开&quot;);\n                String name = scanner.next();\n                generator(name);\n                break;\n            case 2: generator(null);break;\n        &#125;\n    &#125;\n    public static void generator(String tableName)&#123;\n        // 代码生成器\n        AutoGenerator mpg = new AutoGenerator();\n\n        // 全局配置\n        GlobalConfig gc = new GlobalConfig();\n        String projectPath = System.getProperty(&quot;user.dir&quot;);\n        gc.setOutputDir(projectPath + &quot;/src/main/java&quot;);\n        gc.setAuthor(&quot;zjj&quot;); //作者\n        gc.setOpen(false); //是否打开目录\n        gc.setBaseResultMap(true);//xml开启BaseResultMap\n        gc.setBaseColumnList(true);//xml 开启BaseColumn\n        // gc.setSwagger2(true); //实体属性 Swagger2 注解\n        mpg.setGlobalConfig(gc);\n\n        // 数据源配置\n        DataSourceConfig dsc = new DataSourceConfig();\n        dsc.setUrl(&quot;jdbc:mysql://localhost:3306/mydb?useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=Asia/Shanghai&quot;);\n        // dsc.setSchemaName(&quot;public&quot;);\n        dsc.setDriverName(&quot;com.mysql.cj.jdbc.Driver&quot;);\n        dsc.setUsername(&quot;root&quot;);\n        dsc.setPassword(&quot;root&quot;);\n        mpg.setDataSource(dsc);\n\n        // 包配置\n        PackageConfig pc = new PackageConfig();\n        //pc.setModuleName(scanner(&quot;模块名&quot;));\n        pc.setParent(&quot;com.zjj&quot;)\n                .setEntity(&quot;pojo&quot;)\n                .setMapper(&quot;mapper&quot;)\n                .setService(&quot;service&quot;)\n                .setServiceImpl(&quot;service.impl&quot;)\n                .setController(&quot;controller&quot;);\n        mpg.setPackageInfo(pc);\n\n        // 自定义配置\n        InjectionConfig cfg = new InjectionConfig() &#123;\n            @Override\n            public void initMap() &#123;\n                // to do nothing\n            &#125;\n        &#125;;\n\n        // 如果模板引擎是 freemarker\n        String templatePath = &quot;/templates/mapper.xml.ftl&quot;;\n        // 如果模板引擎是 velocity\n        // String templatePath = &quot;/templates/mapper.xml.vm&quot;;\n\n        // 自定义输出配置\n        List&lt;FileOutConfig&gt; focList = new ArrayList&lt;&gt;();\n        // 自定义配置会被优先输出\n        focList.add(new FileOutConfig(templatePath) &#123;\n            @Override\n            public String outputFile(TableInfo tableInfo) &#123;\n                // 自定义输出文件名 ， 如果你 Entity 设置了前后缀、此处注意 xml 的名称会跟着发生变化！！\n                System.out.println(pc.getModuleName());\n                return projectPath + &quot;/src/main/resources/mapper&quot; + pc.getModuleName()\n                        + &quot;/&quot; + tableInfo.getEntityName() + &quot;Mapper&quot; + StringPool.DOT_XML;\n            &#125;\n        &#125;);\n\n        cfg.setFileOutConfigList(focList);\n        mpg.setCfg(cfg);\n\n        // 配置模板\n        TemplateConfig templateConfig = new TemplateConfig();\n        // 配置自定义输出模板\n        //指定自定义模板路径，注意不要带上.ftl/.vm, 会根据使用的模板引擎自动识别\n        templateConfig.setEntity(&quot;/templates/MyEntity.java&quot;);\n        // templateConfig.setService();\n        // templateConfig.setController();\n        templateConfig.setXml(null);\n        mpg.setTemplate(templateConfig);\n\n        // 策略配置\n        StrategyConfig strategy = new StrategyConfig();\n        //数据库表映射到实体的命名策略\n        strategy.setNaming(NamingStrategy.underline_to_camel);\n        //数据库表字段映射到实体的命名策略\n        strategy.setColumnNaming(NamingStrategy.no_change);\n        //strategy.setSuperEntityClass(&quot;你自己的父类实体,没有就不用设置!&quot;);\n        //lombok模型\n        strategy.setEntityLombokModel(true);\n        //生成RestController\n        strategy.setRestControllerStyle(true);\n        // 公共父类\n        //strategy.setSuperControllerClass(&quot;你自己的父类控制器,没有就不用设置!&quot;);\n        // 写于父类中的公共字段\n        //strategy.setSuperEntityColumns(&quot;id&quot;);\n        if (!Objects.isNull(tableName)) &#123;\n            //strategy.setInclude(scanner(&quot;表名，多个英文逗号分割&quot;).split(&quot;,&quot;));\n            strategy.setInclude(tableName.split(&quot;,&quot;));\n        &#125;\n\n        strategy.setControllerMappingHyphenStyle(true);\n        //表前缀\n        // strategy.setTablePrefix(&quot;t_&quot;);\n        mpg.setStrategy(strategy);\n        mpg.setTemplateEngine(new FreemarkerTemplateEngine());\n        mpg.execute();\n    &#125;\n&#125;\n</code></pre>\n",
            "tags": [
                "框架",
                "ORM"
            ]
        },
        {
            "id": "http://example.com/2022/10/07/ORM/Mybatis/",
            "url": "http://example.com/2022/10/07/ORM/Mybatis/",
            "title": "Mybatis",
            "date_published": "2022-10-06T16:00:00.000Z",
            "content_html": "<h1 id=\"1-Mybatis入门\"><a href=\"#1-Mybatis入门\" class=\"headerlink\" title=\"1 Mybatis入门\"></a>1 Mybatis入门</h1><p>原生JDBC实现CURD的问题</p>\n<blockquote>\n<p>1 编码繁琐<br>2 需要我们自己将结果集映射成对象<br>3 性能不太好  连接池 缓存<br>4 SQL语句和java代码的耦合度特别高<br>5 … …</p>\n</blockquote>\n<p>MyBatis 本是Apache的一个开源项目iBatis, 2010年这个项目由Apache Software Foundation 迁移到了Google Code，且改名为MyBatis 。2013年11月迁移到GitHub。iBATIS一词来源于“internet”和“abatis”的组合，是一个基于Java的持久层框架。<br>MyBatis 是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 POJOs(Plain Ordinary Java Object,普通的 Java对象)映射成数据库中的记录。</p>\n<img data-src=\"/2022/10/07/ORM/Mybatis/image-20220617191731748.png\" class=\"\" title=\"image-20220617191731748\">\n\n\n\n\n\n<h2 id=\"1-认识框架\"><a href=\"#1-认识框架\" class=\"headerlink\" title=\"1 认识框架\"></a>1 认识框架</h2><p>框架（Framework）是一个框子——指其约束性，也是一个架子——指其支撑性。是一个基本概念上的结构，用于去解决或者处理复杂的问题。框架这个广泛的定义使用的十分流行，尤其在软件概念。<br>框架( Framework )对于java来说,就是一系列为了解决特定问题而定义的一系列接口和实现类,在组织框架代码时,使用了一系列优秀的设计模式,使代码无论在性能上还是API操作上得到很大提升.框架可以看做是项目开发的半成品,基本的底层操作已经封装完毕,通过框架,程序员可以从底层代码中解脱出来,专注于业务逻辑的完成和性能的优化。框架规定了你的应用的体系结构。它定义了整体结构，类和对象的分割，各部分的主要责任，类和对象怎么协作，以及控制流程。框架预定义了这些设计参数，以便于应用设计者或实现者能集中精力于应用本身的特定细节。</p>\n<p>如果将开发完成的软件比作是一套已经装修完毕的新房，那框架就好比是一套已经修建好的毛坯房。用户直接购买毛坯房，建筑质量和户型合理有保证，还省去了自己建造房屋的时间，一举多得。<br>在开发过程是使用框架，同样可以保证减少开发时间、降低开发难度，并且还保证设计质量。好比和世界上最优秀的软件工程师是一个项目的，并且他们完成的还是基础、全局的工作。想想是不是很嗨的一件事情。</p>\n<img data-src=\"/2022/10/07/ORM/Mybatis/image-20220617191818381.png\" class=\"\" title=\"image-20220617191818381\">\n\n\n\n\n\n<p>框架还有一个作用是约束。莎士比亚说,”一千个观众眼中有一千个哈姆雷特” 即仁者见仁,智者见智.说每个人都会对作品有不同的理解，每个人对待任何事物都有自己的看法，一千个人就有可能有一千种不同的看法1000人心中有1000个哈姆雷特。同样的技术解决同样的问题会产生不同流程和风格的解决方案，而采用一种框架其实就是限制用户必须使用其规定的方案来实现，<strong>可以降低程序员之间沟通以及日后维护的成本。</strong></p>\n<p>常用的基于JavaEE的三大开源框架，已经从SSH、SSH2过渡到了SSM：SpringMVC、Spring、MyBatis &gt;&gt;&gt; springBoot</p>\n<p><font face=\"微软雅黑\" size=6 color=#FF0000>总之，框架是一个半成品，已经对基础的代码进行了封装并提供相应的API，开发者在使用框架是直接调用封装好的API可以省去很多代码编写，从而提高工作效率和开发速度。</font></p>\n<h2 id=\"2-认识ORM\"><a href=\"#2-认识ORM\" class=\"headerlink\" title=\"2 认识ORM\"></a>2 认识ORM</h2><p>DBC的缺点：</p>\n<p>需要手动的完成面向对象的Java语言、面向关系的数据库之间数据的转换，代码繁琐无技术含量，影响了开发效率。</p>\n<p>如图所示，查询是需要手动的将结果集的列数据转换为Java对象的属性；而添加操作时需要手动将Java对象的属性转换为数据库表的列字段。</p>\n<p>关于面向对象的Java语言、面向关系的数据库之间数据的转换必须要做，问题在于这个转换是否可以不由开发者来做。可以的。ORM框架就是专门来做这个问题的，相当于在面向对象语言和关系数据库之间搭建一个桥梁。</p>\n<p>&#x3D;&#x3D;ORM，Object-Relationl Mapping，对象关系映射，它的作用是在关系型数据库和对象之间作一个映射，这样我们在具体的操作数据库的时候，只要像平时操作对象一样操作它就可以了，ORM框架会根据映射完成对数据库的操作，就不需要再去和复杂的SQL语句打交道了&#x3D;&#x3D;。</p>\n<img data-src=\"/2022/10/07/ORM/Mybatis/image-20220617192304044.png\" class=\"\" title=\"image-20220617192304044\">\n\n\n<p>另外学习ORM必须知道两个概念：持久化、持久层</p>\n<p><strong>什么是“持久化”</strong></p>\n<p>持久（Persistence），<font color=#FF0000>即把数据（如内存中的对象）保存到可永久保存的存储设备中（如磁盘）</font>。持久化的主要应用是将内存中的数据存储在关系型的数据库中，当然也可以存储在磁盘文件中、XML数据文件中等等。</p>\n<p><strong>什么是 “持久层”</strong></p>\n<p>持久层（Persistence Layer），即专注于实现数据持久化应用领域的某个特定系统的一个逻辑层面，将数据使用者和数据实体相关联。之前使用JDBC访问数据库的DAO层，后面采用MyBatis访问数据库的mapper层，就是持久层。</p>\n<p><strong>Mybatis是一持久层的款半自动的ORM映射框架</strong></p>\n<h2 id=\"3-认识MyBatis\"><a href=\"#3-认识MyBatis\" class=\"headerlink\" title=\"3 认识MyBatis\"></a>3 认识MyBatis</h2><blockquote>\n<p>MyBatis 本是Apache的一个开源项目iBatis, 2010年这个项目由Apache Software Foundation 迁移到了Google Code，且改名为MyBatis 。2013年11月迁移到GitHub。iBATIS一词来源于“internet”和“abatis”的组合，是一个基于Java的持久层框架。</p>\n</blockquote>\n<p>MyBatis 是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 POJOs(Plain Ordinary Java Object,普通的 Java对象)映射成数据库中的记录。</p>\n<img data-src=\"/2022/10/07/ORM/Mybatis/image-20220617192446302.png\" class=\"\" title=\"image-20220617192446302\">\n\n<p>精简解释：MyBatis是一个半自动ORM框架，其本质是对JDBC的封装。使用MyBatis重点需要程序员编写SQL命令，不需要写一行JDBC代码</p>\n<h1 id=\"2-MyBatis初次使用\"><a href=\"#2-MyBatis初次使用\" class=\"headerlink\" title=\"2 MyBatis初次使用\"></a>2 MyBatis初次使用</h1><h2 id=\"1-创建maven项目导入相关依赖\"><a href=\"#1-创建maven项目导入相关依赖\" class=\"headerlink\" title=\"1 创建maven项目导入相关依赖\"></a>1 创建maven项目导入相关依赖</h2><p>但凡是框架,使用都是分三步走</p>\n<p>1导入jar文件,maven</p>\n<p>2处理配置文件</p>\n<p>3开发业务代码</p>\n<p>先创建一个空项目,用于存放后面Mybatis相关项目模块</p>\n<img data-src=\"/2022/10/07/ORM/Mybatis/image-20220617192550409.png\" class=\"\" title=\"image-20220617192550409\">\n\n\n<p>项目名为mybatisAll即可</p>\n<img data-src=\"/2022/10/07/ORM/Mybatis/image-20220617192555641.png\" class=\"\" title=\"image-20220617192555641\">\n\n\n\n\n<p>这里不显示项目名 没关系,如果想看到项目名,可以close项目后,再次open即可</p>\n<img data-src=\"/2022/10/07/ORM/Mybatis/image-20220617192604832.png\" class=\"\" title=\"image-20220617192604832\">\n\n\n\n\n<p>关闭项目</p>\n<img data-src=\"/2022/10/07/ORM/Mybatis/image-20220617192611548.png\" class=\"\" title=\"image-20220617192611548\">\n\n\n<p>再次open</p>\n<img data-src=\"/2022/10/07/ORM/Mybatis/image-20220617192630884.png\" class=\"\" title=\"image-20220617192630884\">\n\n\n\n\n\n\n<p>项目名就显示了</p>\n<img data-src=\"/2022/10/07/ORM/Mybatis/image-20220617192636190.png\" class=\"\" title=\"image-20220617192636190\">\n\n\n<p>接下来设置maven为我们自己安装的,不用idea自带的(当然用自带的也行)</p>\n<img data-src=\"/2022/10/07/ORM/Mybatis/image-20220617192641520.png\" class=\"\" title=\"image-20220617192641520\">\n\n\n\n<img data-src=\"/2022/10/07/ORM/Mybatis/image-20220617192647200.png\" class=\"\" title=\"image-20220617192647200\">\n\n\n<p>在当前项目中创建模块</p>\n<img data-src=\"/2022/10/07/ORM/Mybatis/image-20220617192652567.png\" class=\"\" title=\"image-20220617192652567\">\n\n\n<p>选择maven项目 next</p>\n<img data-src=\"/2022/10/07/ORM/Mybatis/image-20220617192703265.png\" class=\"\" title=\"image-20220617192703265\">\n\n\n\n\n\n\n<p>输入groupid和aitifactid  然后finish</p>\n<img data-src=\"/2022/10/07/ORM/Mybatis/image-20220617192713221.png\" class=\"\" title=\"image-20220617192713221\">\n\n\n<p>检查项目目前在磁盘上的存放路径 然后next</p>\n<img data-src=\"/2022/10/07/ORM/Mybatis/image-20220617192719403.png\" class=\"\" title=\"image-20220617192719403\">\n\n\n\n\n<p>检查项目目录结构是否有缺失</p>\n<img data-src=\"/2022/10/07/ORM/Mybatis/image-20220617192723928.png\" class=\"\" title=\"image-20220617192723928\">\n\n\n<p>MyBatis官网说明文档   <span class=\"exturl\" data-url=\"aHR0cHM6Ly9teWJhdGlzLm9yZy9teWJhdGlzLTMvemgvaW5kZXguaHRtbA==\">https://mybatis.org/mybatis-3/zh/index.html</span></p>\n<p>在pom.xml中导入MyBatis相关依赖jar文件</p>\n<pre><code class=\"xml\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;\n         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;\n    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n    &lt;groupId&gt;com.msb&lt;/groupId&gt;\n    &lt;artifactId&gt;mybatisTest01&lt;/artifactId&gt;\n    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;\n    &lt;packaging&gt;jar&lt;/packaging&gt;\n    &lt;dependencies&gt;\n        &lt;!--mysqlConnector--&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;mysql&lt;/groupId&gt;\n            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;\n            &lt;version&gt;8.0.16&lt;/version&gt;\n        &lt;/dependency&gt;\n        &lt;!--mybatis 核心jar包--&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;\n            &lt;artifactId&gt;mybatis&lt;/artifactId&gt;\n            &lt;version&gt;3.5.3&lt;/version&gt;\n        &lt;/dependency&gt;\n        &lt;!--junit--&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;junit&lt;/groupId&gt;\n            &lt;artifactId&gt;junit&lt;/artifactId&gt;\n            &lt;version&gt;4.13.1&lt;/version&gt;\n            &lt;scope&gt;test&lt;/scope&gt;\n        &lt;/dependency&gt;\n        &lt;!--lombok --&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;\n            &lt;artifactId&gt;lombok&lt;/artifactId&gt;\n            &lt;version&gt;1.18.12&lt;/version&gt;\n            &lt;scope&gt;provided&lt;/scope&gt;\n        &lt;/dependency&gt;\n    &lt;/dependencies&gt;\n&lt;/project&gt;\n</code></pre>\n<p>安装lombok插件后,重启idea</p>\n<img data-src=\"/2022/10/07/ORM/Mybatis/image-20220617192808470.png\" class=\"\" title=\"image-20220617192808470\">\n\n\n\n\n<p>导入lombok依赖后,单独设置启用注解处理</p>\n<img data-src=\"/2022/10/07/ORM/Mybatis/image-20220617192814365.png\" class=\"\" title=\"image-20220617192814365\">\n\n\n\n<h2 id=\"2-准备数据库-包结构和实体类\"><a href=\"#2-准备数据库-包结构和实体类\" class=\"headerlink\" title=\"2  准备数据库_包结构和实体类\"></a>2  准备数据库_包结构和实体类</h2><p>数据库</p>\n<p><img data-src=\"/../spring/img/image-20220617192857161.png\" alt=\"image-20220617192857161\"></p>\n<p>项目结构</p>\n<img data-src=\"/2022/10/07/ORM/Mybatis/image-20220617192901785.png\" class=\"\" title=\"image-20220617192901785\">\n\n<p> 实体类Dept</p>\n<pre><code class=\"java\"> package com.msb.pojo;\nimport lombok.AllArgsConstructor;\nimport lombok.Data;\nimport lombok.NoArgsConstructor;\nimport java.io.Serializable;\n/**\n\n * @Author: Ma HaiYang\n * @Description: MircoMessage:Mark_7001\n    */\n    @Data\n    @AllArgsConstructor\n    @NoArgsConstructor\n    public class Dept implements Serializable &#123;\n    private Integer deptno;\n    private String dname;\n    private String loc;\n    &#125;\n</code></pre>\n<h2 id=\"3-准备Mapper映射文件和核心配置文件\"><a href=\"#3-准备Mapper映射文件和核心配置文件\" class=\"headerlink\" title=\"3 准备Mapper映射文件和核心配置文件\"></a>3 准备Mapper映射文件和核心配置文件</h2><p>resources目录下 创建 com&#x2F;msb&#x2F;mapper目录,然后添加DeptMapper.xml映射文件</p>\n<img data-src=\"/2022/10/07/ORM/Mybatis/image-20220617193030929.png\" class=\"\" title=\"image-20220617193030929\">\n\n<pre><code class=\"xml\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;\n&lt;!DOCTYPE mapper\n        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;\n        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;\n&lt;mapper namespace=&quot;aaa&quot;&gt;\n    &lt;!--public List&lt;Dept&gt; findAll()&#123;    &#125;--&gt;\n    &lt;select id=&quot;findAll&quot; resultType=&quot;com.msb.pojo.Dept&quot; &gt;\n        select * from dept\n    &lt;/select&gt;\n&lt;/mapper&gt;\n</code></pre>\n<p>resources目录下准备sqlMapConfig.xml 核心配置文件</p>\n<pre><code class=\"xml\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;\n&lt;!DOCTYPE configuration\n        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;\n        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;\n&lt;configuration&gt;\n    &lt;environments default=&quot;development&quot;&gt;\n        &lt;environment id=&quot;development&quot;&gt;\n            &lt;transactionManager type=&quot;JDBC&quot;/&gt;\n            &lt;dataSource type=&quot;POOLED&quot;&gt;\n                &lt;property name=&quot;driver&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt;\n                &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://127.0.0.1:3306/mydb?useSSL=false&amp;amp;useUnicode=true&amp;amp;characterEncoding=UTF-8&amp;amp;serverTimezone=Asia/Shanghai&quot;/&gt;\n                &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;\n                &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt;\n            &lt;/dataSource&gt;\n        &lt;/environment&gt;\n    &lt;/environments&gt;\n    &lt;!--加载mapper映射文件--&gt;\n    &lt;mappers&gt;\n        &lt;mapper resource=&quot;com/msb/mapper/DeptMapper.xml&quot;/&gt;\n    &lt;/mappers&gt;\n&lt;/configuration&gt;\n</code></pre>\n<h2 id=\"4-运行测试\"><a href=\"#4-运行测试\" class=\"headerlink\" title=\"4 运行测试\"></a>4 运行测试</h2><img data-src=\"/2022/10/07/ORM/Mybatis/image-20220617193244713.png\" class=\"\" title=\"image-20220617193244713\">\n\n<p>在test目录下开发测试代码并运行</p>\n<p><img data-src=\"/../spring/img/image-20220617193259351.png\" alt=\"image-20220617193259351\"></p>\n<pre><code class=\"java\"> package com.msb.test;\nimport com.msb.pojo.Dept;\nimport org.apache.ibatis.io.Resources;\nimport org.apache.ibatis.session.SqlSession;\nimport org.apache.ibatis.session.SqlSessionFactory;\nimport org.apache.ibatis.session.SqlSessionFactoryBuilder;\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Test;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.List;\n/**\n\n * @Author: Ma HaiYang\n * @Description: MircoMessage:Mark_7001\n    */\n    public class Test1 &#123;\n    private SqlSession sqlSession;\n    @Before\n    public void init()&#123;\n        SqlSessionFactoryBuilder ssfb =new SqlSessionFactoryBuilder();\n        InputStream resourceAsStream = null;\n        try &#123;\n            resourceAsStream = Resources.getResourceAsStream(&quot;sqlMapConfig.xml&quot;);\n        &#125; catch (IOException e) &#123;\n            e.printStackTrace();\n        &#125;\n        SqlSessionFactory factory=ssfb.build(resourceAsStream) ;\n        sqlSession=factory.openSession();\n    &#125;\n    @Test\n    public void testFindAll()&#123;\n        // 调用SQL语句\n        List&lt;Dept&gt; list = sqlSession.selectList(&quot;findAll&quot;);\n        for (Dept dept : list) &#123;\n            System.out.println(dept);\n        &#125;\n    &#125;\n    @After\n    public void release()&#123;\n        // 关闭SQLSession\n        sqlSession.close();\n    &#125;\n    &#125;\n</code></pre>\n<h1 id=\"3-MyBatis配置详解\"><a href=\"#3-MyBatis配置详解\" class=\"headerlink\" title=\"3 MyBatis配置详解\"></a>3 MyBatis配置详解</h1><h3 id=\"1-log4j1和log4j2的简单配置\"><a href=\"#1-log4j1和log4j2的简单配置\" class=\"headerlink\" title=\"1_log4j1和log4j2的简单配置\"></a>1_log4j1和log4j2的简单配置</h3><p>项目中添加依赖</p>\n<pre><code class=\"xml\">&lt;!-- log4j2 --&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;\n    &lt;artifactId&gt;log4j-core&lt;/artifactId&gt;\n    &lt;version&gt;2.12.1&lt;/version&gt;\n&lt;/dependency&gt;\n&lt;!-- log4j1 --&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;log4j&lt;/groupId&gt;\n    &lt;artifactId&gt;log4j&lt;/artifactId&gt;\n    &lt;version&gt;1.2.17&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>\n<pre><code>在mybatis.cfg.xml中配置MyBatis所使用的具体日志实现。如果不指定将自动搜索。可能会搜到log4j，但是如果优先搜到了其他的日志实现呢，所以还是设置为好。这一来log4j就跑不了了。\n</code></pre>\n<p>log4j 1</p>\n<pre><code>将log4j.properties文件负责到src下。另外在其中可以将全局的日志级别调高，避免大量debug信息的干扰。同时将对映射文件的操作调低，可以用来显示SQL语句的调试信息。开发阶段，建议启动控制的日志。\n</code></pre>\n<p> #定义全局日志级别调试阶段推荐debug</p>\n<pre><code class=\"properties\">log4j.rootLogger=debug,stdout \nlog4j.appender.stdout=org.apache.log4j.ConsoleAppender\nlog4j.appender.stdout.Target=System.err\nlog4j.appender.stdout.layout=org.apache.log4j.SimpleLayout\nlog4j.appender.logfile=org.apache.log4j.FileAppender\nlog4j.appender.logfile.File=d:/msb.log\nlog4j.appender.logfile.layout=org.apache.log4j.PatternLayout\nlog4j.appender.logfile.layout.ConversionPattern=%d&#123;yyyy-MM-dd HH:mm:ss&#125; %l %F %p %m%n\n</code></pre>\n<p>在核心配置文件中可以选择的其他日志处理方式</p>\n<p>log4j 2</p>\n<p>将log4j2.xml文件负责到resources下。</p>\n<pre><code class=\"xml\"> &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;Configuration status=&quot;DEBUG&quot;&gt;\n    &lt;Appenders&gt;\n        &lt;Console name=&quot;Console&quot; target=&quot;SYSTEM_ERR&quot;&gt;\n            &lt;PatternLayout pattern=&quot;%d&#123;YYYY-MM-dd HH:mm:ss&#125; [%t] %-5p %c&#123;1&#125;:%L - %msg%n&quot; /&gt;\n        &lt;/Console&gt;\n        &lt;RollingFile name=&quot;RollingFile&quot; filename=&quot;log/test.log&quot;\n                     filepattern=&quot;$&#123;logPath&#125;/%d&#123;YYYYMMddHHmmss&#125;-fargo.log&quot;&gt;\n            &lt;PatternLayout pattern=&quot;%d&#123;YYYY-MM-dd HH:mm:ss&#125; [%t] %-5p %c&#123;1&#125;:%L - %msg%n&quot; /&gt;\n            &lt;Policies&gt;\n                &lt;SizeBasedTriggeringPolicy size=&quot;10 MB&quot; /&gt;\n            &lt;/Policies&gt;\n            &lt;DefaultRolloverStrategy max=&quot;20&quot; /&gt;\n        &lt;/RollingFile&gt;\n    &lt;/Appenders&gt;\n    &lt;Loggers&gt;\n        &lt;Root level=&quot;INFO&quot;&gt;\n            &lt;AppenderRef ref=&quot;Console&quot; /&gt;\n        &lt;/Root&gt;\n    &lt;/Loggers&gt;\n&lt;/Configuration&gt;\n</code></pre>\n<p>核心配置文件中可以指定日志打印方式</p>\n<img data-src=\"/2022/10/07/ORM/Mybatis/image-20220617193736735.png\" class=\"\" title=\"image-20220617193736735\">\n\n\n\n<h2 id=\"2-关于事务配置\"><a href=\"#2-关于事务配置\" class=\"headerlink\" title=\"2_关于事务配置\"></a>2_关于事务配置</h2><img data-src=\"/2022/10/07/ORM/Mybatis/image-20220617193831478.png\" class=\"\" title=\"image-20220617193831478\">\n\n<p>在mybatis核心配置文件中 envirment中 通过transactionManager配置事务的处理策略</p>\n<p><font color=#FF000>JDBC</font> – 这个配置直接简单使用了 JDBC 的提交和回滚设置。它依赖于从数据源得到的连接来管理事务范围。</p>\n<p><font color=#FF000>MANAGED </font>– 这个配置几乎没做什么。它从来不提交或回滚一个连接。而它会让容器来管理事务的整个生命周期(比如 Spring 或 JEE 应用服务器的上下文) 默认情况下它会关闭连接。然而一些容器并不希望这样, 因此如果你需要从连接中停止它,将closeConnection 属性设置为 false. mybatis本身并不做事务的处理,交给其他框架去处理事务,如spring</p>\n<h2 id=\"3-关于映射文件的加载方式\"><a href=\"#3-关于映射文件的加载方式\" class=\"headerlink\" title=\"3_关于映射文件的加载方式\"></a>3_关于映射文件的加载方式</h2><p>1.mapper映射文件的文件路径导入 使用的mapper标签的resource属性</p>\n<p>2.网络资源路径 使用的mapper标签的url属性</p>\n<p>3.接口的全限定名导入 使用的是mapper标签的class属性 (基于接口的代理模式开发)</p>\n<p>4.包扫描形式加载所有的mapper映射文件 使用的是 package标签</p>\n<img data-src=\"/2022/10/07/ORM/Mybatis/image-20220617193946594.png\" class=\"\" title=\"image-20220617193946594\">\n\n<h2 id=\"4-关于实体类别名处理\"><a href=\"#4-关于实体类别名处理\" class=\"headerlink\" title=\"4_关于实体类别名处理\"></a>4_关于实体类别名处理</h2><p>在mybatis核心配置文件中使用别名处理</p>\n<pre><code class=\"xml\"> &lt;!--设置实体类别名--&gt;\n&lt;typeAliases&gt;\n    &lt;!--\n    通过包扫描给所有的实体类起别名\n    给指定报名下的所有类起别名\n    默认每个实体类的别名是首字母小写的类名\n    Dept   dept\n    Emp    emp\n    --&gt;\n    &lt;package name=&quot;com.msb.pojo&quot;/&gt;\n&lt;/typeAliases&gt;\n</code></pre>\n<p>在映射文件的resultType 返回值类型  和paramterType 上就可以使用别名了</p>\n<pre><code class=\"xml\">&lt;select id=&quot;selectByEmpno&quot;  resultType=&quot;emp&quot;&gt;\n    select * from emp where empno = 7566\n&lt;/select&gt;\n</code></pre>\n<h2 id=\"5-关于外部属性配置文件存储数据库连接信息\"><a href=\"#5-关于外部属性配置文件存储数据库连接信息\" class=\"headerlink\" title=\"5_关于外部属性配置文件存储数据库连接信息\"></a>5_关于外部属性配置文件存储数据库连接信息</h2><p>在resources下准备jdbc.properties属性配置文件</p>\n<img data-src=\"/2022/10/07/ORM/Mybatis/image-20220617194131042.png\" class=\"\" title=\"image-20220617194131042\">\n\n\n<p>配置文件中的内容</p>\n<pre><code class=\"properties\">jdbc_driver=com.mysql.cj.jdbc.Driver\njdbc_url=jdbc:mysql://127.0.0.1:3306/mydb?useSSL=false&amp;useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=Asia/Shanghai\njdbc_username=root\njdbc_password=root\n</code></pre>\n<p>在核心配置文件中引入db.properties属性文件</p>\n<pre><code class=\"xml\"> &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;\n&lt;!-- xml文档约束 约束xml文档中可以有哪些标签,哪些属性,以及标签的包含关系和顺序....\ndtd 约束\nschema 约束\n--&gt;\n\n&lt;!DOCTYPE configuration\n        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;\n        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;\n&lt;configuration&gt;\n    &lt;properties resource=&quot;jdbc.properties&quot;&gt;&lt;/properties&gt;\n    &lt;settings&gt;\n        &lt;!--设置日志处理方式--&gt;\n        &lt;setting name=&quot;logImpl&quot; value=&quot;LOG4J&quot;/&gt;\n    &lt;/settings&gt;\n    &lt;!--设置实体类别名--&gt;\n    &lt;typeAliases&gt;\n        &lt;!--\n        通过包扫描给所有的实体类起别名\n        给指定报名下的所有类起别名\n        默认每个实体类的别名是首字母小写的类名\n        Dept   dept\n        Emp    emp\n        --&gt;\n        &lt;package name=&quot;com.msb.pojo&quot;/&gt;\n    &lt;/typeAliases&gt;\n    &lt;!--配置数据库链接信息--&gt;\n    &lt;environments default=&quot;mysql&quot;&gt;\n        &lt;!--数据源1--&gt;\n        &lt;environment id=&quot;mysql&quot;&gt;\n            &lt;transactionManager type=&quot;JDBC&quot;/&gt;\n            &lt;!--一个数据源--&gt;\n            &lt;dataSource type=&quot;POOLED&quot;&gt;\n                &lt;property name=&quot;driver&quot; value=&quot;$&#123;jdbc_driver&#125;&quot;/&gt;\n                &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc_url&#125;&quot;/&gt;\n                &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc_username&#125;&quot;/&gt;\n                &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc_password&#125;&quot;/&gt;\n            &lt;/dataSource&gt;\n        &lt;/environment&gt;\n    &lt;/environments&gt;\n    &lt;!--加载映射文件的--&gt;\n    &lt;mappers&gt;\n        &lt;mapper resource=&quot;com/msb/mapper/DeptMapper.xml&quot;/&gt;\n    &lt;/mappers&gt;\n&lt;/configuration&gt;\n</code></pre>\n<h1 id=\"4-MyBatis传统DAO模式开发\"><a href=\"#4-MyBatis传统DAO模式开发\" class=\"headerlink\" title=\"4 MyBatis传统DAO模式开发\"></a>4 MyBatis传统DAO模式开发</h1><blockquote>\n<pre><code>普通模式,也称为传统DAO模式,就是在传统DAO模式下,定义接口和实现类,如 interface EmpDao  class EmpDaoImpl implements EmpDao.  在实现类中,用SQLSession对象调用select insert delete update 等方法实现.目前极为少见.在传统模式下,我们需要知道SqlSession对象 实现CURD和 参数传递的处理\n</code></pre>\n</blockquote>\n<h2 id=\"1-sqlSession查询的三种方式\"><a href=\"#1-sqlSession查询的三种方式\" class=\"headerlink\" title=\"1_sqlSession查询的三种方式\"></a>1_sqlSession查询的三种方式</h2><p>SqlSession对象本身的API中就有三个查询方法,分别能够实现如下查询方式</p>\n<p>1返回单个对象 selectOne</p>\n<p>2返回对象List集合 selectList</p>\n<p>3返回对象Map集合 selectMap</p>\n<p>接下来我们就对这三个方法进行一个快速的学习</p>\n<img data-src=\"/2022/10/07/ORM/Mybatis/image-20220617194257643.png\" class=\"\" title=\"image-20220617194257643\">\n\n\n<p>创建Emp实体类</p>\n<pre><code class=\"java\">@AllArgsConstructor\n@NoArgsConstructor\n@Data\npublic class Emp implements Serializable &#123;\n    private Integer empno;\n    private String ename;\n    private String job;\n    private Integer mgr;\n    private Date hiredate;\n    private Double sal;\n    private Double comm;\n    private Integer deptno;\n&#125;\n</code></pre>\n<p>准备Mapper映射文件</p>\n<pre><code class=\"xml\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;\n&lt;!DOCTYPE mapper\n        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;\n        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;\n&lt;mapper namespace=&quot;EmpMapper&quot;&gt;\n    &lt;!--\n    返回单个对象\n    public Emp findOne();\n    id 相当于方法名\n    resultType 相当于返回值类型\n        sql语句的查询结果用哪个类来进行封装 如果返回值类型是集合,这里写的也是集合中的元素对应的类,不是集合本身作为类型\n    paramaterType 参数类型\n    SQL语句就是具体的方法体的实现\n    --&gt;\n    &lt;select id=&quot;findOne&quot; resultType=&quot;emp&quot; &gt;\n        select * from emp where empno = 7499\n    &lt;/select&gt;\n    &lt;!--\n    返回多个对象List集合\n    查询全部的员工信息\n    public List&lt;Emp&gt; findAll()\n    --&gt;\n    &lt;select id=&quot;findAll&quot; resultType=&quot;emp&quot;&gt;\n        select * from emp\n    &lt;/select&gt;\n    &lt;!--返回多个对象的Map集合\n    把查询出来的数据中的某一列作为键,整条数据封装的对象作为值\n    public Map&lt;key,Emp&gt; findEmpMap()\n    &lt;empno,Emp&gt;\n    &lt;key,Emp&gt;\n    --&gt;\n    &lt;select id=&quot;findEmpMap&quot; resultType=&quot;map&quot;&gt;\n        select * from emp\n    &lt;/select&gt;\n&lt;/mapper&gt;\n</code></pre>\n<p>sqlMapConfig中导入EmpMapper映射文件</p>\n<pre><code class=\"xml\">&lt;!--加载mapper映射文件--&gt;\n&lt;mappers&gt;\n    &lt;mapper resource=&quot;com/msb/mapper/DeptMapper.xml&quot;/&gt;\n    &lt;mapper resource=&quot;com/msb/mapper/EmpMapper.xml&quot;/&gt;\n&lt;/mappers&gt;\n</code></pre>\n<p>测试代码</p>\n<pre><code class=\"java\">package com.msb.test;\nimport com.msb.pojo.Dept;\nimport com.msb.pojo.Emp;\nimport org.apache.ibatis.io.Resources;\nimport org.apache.ibatis.session.SqlSession;\nimport org.apache.ibatis.session.SqlSessionFactory;\nimport org.apache.ibatis.session.SqlSessionFactoryBuilder;\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Test;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n/**\n\n * @Author: Ma HaiYang\n * @Description: MircoMessage:Mark_7001\n    */\n    public class Test2 &#123;\n    private SqlSession sqlSession;\n    @Before\n    public void init()&#123;\n        SqlSessionFactoryBuilder ssfb =new SqlSessionFactoryBuilder();\n        InputStream resourceAsStream = null;\n        try &#123;\n            resourceAsStream = Resources.getResourceAsStream(&quot;sqlMapConfig.xml&quot;);\n        &#125; catch (IOException e) &#123;\n            e.printStackTrace();\n        &#125;\n        SqlSessionFactory factory=ssfb.build(resourceAsStream) ;\n        sqlSession=factory.openSession();\n    &#125;\n    @Test\n    public void testSelectOne()&#123;\n        // 查询单个对象\n        System.out.println(&quot;sqlSession查询单个对象&quot;);\n        Emp emp = sqlSession.selectOne(&quot;findOne&quot;);\n        System.out.println(emp);\n    &#125;\n    @Test\n    public void testSelectList()&#123;\n        // 查询多个对象的List集合\n        System.out.println(&quot;sqlSession查询对象List集合&quot;);\n        List&lt;Emp&gt; emps = sqlSession.selectList(&quot;EmpMapper.findAll&quot;);\n        emps.forEach(System.out::println);\n    &#125;\n    @Test\n    public void testSelectMap()&#123;\n        // 查询多个对象的Map集合\n        System.out.println(&quot;sqlSession查询对象Map集合&quot;);\n        Map&lt;Integer, Emp&gt; empMap = sqlSession.selectMap(&quot;findEmpMap&quot;, &quot;EMPNO&quot;);\n        Set&lt;Integer&gt; empnos = empMap.keySet();\n        for (Integer empno : empnos) &#123;\n            System.out.println(empno+&quot; :&quot; +empMap.get(empno));\n        &#125;\n    &#125;\n    @After\n    public void release()&#123;\n        // 关闭SQLSession\n        sqlSession.close();\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"2-sqlSession传递参数的三种方式\"><a href=\"#2-sqlSession传递参数的三种方式\" class=\"headerlink\" title=\"2_sqlSession传递参数的三种方式\"></a>2_sqlSession传递参数的三种方式</h2><p>1 单个基础数据类型作为参数</p>\n<p>2 多个基础数据类型的map 集合作为参数</p>\n<p>3 引用类型作为参数</p>\n<p>Mapper映射文件</p>\n<pre><code class=\"xml\"> &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;\n&lt;!DOCTYPE mapper\n        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;\n        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;\n&lt;mapper namespace=&quot;EmpMapper2&quot;&gt;\n    &lt;!--\n    参数为一个基本数据类型\n    根据员工工号查询员工的全部信息,返回单个员工对象\n    public Emp findByEmpno(int empno);\n    parameterType 在有参数情况下也是可以省略不写  mybatis 可以根据实际情况自动判断\n    如果要写parameterType 那么就要写对\n    在SQL语句上可以使用$&#123;&#125;  #&#123;&#125; 代表参数的占位\n    如果参数是单个基本数据类型,&#123;&#125;中名字可以随便写,见名知意\n    $&#123;&#125; 代表mybatis底层使用Statment语句对象,参数是以字符串拼接的形式设置\n    #&#123;&#125; 代表mybatis底层使用的preparedStatment语句对象,参数使用?作为占位符处理\n    #&#123;&#125; 以后常用\n    --&gt;\n    &lt;select id=&quot;findByEmpno&quot; resultType=&quot;emp&quot; parameterType=&quot;int&quot;&gt;\n        select  * from emp where empno = #&#123;empno&#125;\n    &lt;/select&gt;\n    &lt;!--\n    参数为map集合\n    查询指定部门号和指定最低薪资的员工信息\n    20 号部门 且工资在1500以上的员工信息\n    public List&lt;Emp&gt; findEmpByDeptnoAndSal(int deptno,double sal);\n    &lt;  &gt;  最好要进行转译处理,参照HTML转译  w3school在线文档中有转译符号对应规则\n     Map&lt;String,Object&gt; args=new HashMap&lt;&gt;();\n        args.put(&quot;deptno&quot;, 20);\n        args.put(&quot;sal&quot;, 1500.0);\n    #&#123;&#125;中写的是map集合中,参数的键\n    --&gt;\n    &lt;select id=&quot;findEmpByDeptnoAndSal&quot; resultType=&quot;emp&quot; parameterType=&quot;map&quot;&gt;\n    &lt;/select&gt;\n    &lt;!--\n   参数为对象\n   emp &gt;&gt;&gt;  deptno   sal\n   参数是我们自定义的类型,那么 #&#123;&#125;中写的是参数的属性名\n   --&gt;\n    &lt;select id=&quot;findEmpByDeptnoAndSal2&quot; resultType=&quot;emp&quot; parameterType=&quot;emp&quot;&gt;\n    &lt;/select&gt;\n&lt;/mapper&gt;\n</code></pre>\n<p>测试代码</p>\n<pre><code class=\"java\"> package com.msb.test;\nimport com.msb.pojo.Emp;\nimport org.apache.ibatis.io.Resources;\nimport org.apache.ibatis.session.SqlSession;\nimport org.apache.ibatis.session.SqlSessionFactory;\nimport org.apache.ibatis.session.SqlSessionFactoryBuilder;\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Test;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n/**\n\n * @Author: Ma HaiYang\n * @Description: MircoMessage:Mark_7001\n    */\n    public class Test3 &#123;\n    private SqlSession sqlSession;\n    @Before\n    public void init()&#123;\n        SqlSessionFactoryBuilder ssfb =new SqlSessionFactoryBuilder();\n        InputStream resourceAsStream = null;\n        try &#123;\n            resourceAsStream = Resources.getResourceAsStream(&quot;sqlMapConfig.xml&quot;);\n        &#125; catch (IOException e) &#123;\n            e.printStackTrace();\n        &#125;\n        SqlSessionFactory factory=ssfb.build(resourceAsStream) ;\n        sqlSession=factory.openSession();\n    &#125;\n    @Test\n    public void testSingleArg()&#123;\n        // 测试单个基本数据类型作为参数\n        Emp emp = sqlSession.selectOne(&quot;findByEmpno&quot;, 7499);\n        System.out.println(emp);\n    &#125;\n    @Test\n    public void testMapArg()&#123;\n        // 测试Map集合作为参数\n        Map&lt;String,Object&gt; args=new HashMap&lt;&gt;();\n        args.put(&quot;deptno&quot;, 20);\n        args.put(&quot;sal&quot;, 3000.0);\n        List&lt;Emp&gt; emps = sqlSession.selectList(&quot;findEmpByDeptnoAndSal&quot;, args);\n        emps.forEach(System.out::println);\n    &#125;\n    @Test\n    public void testEmpArg()&#123;\n        // 测试Map集合作为参数\n        Emp arg =new Emp();\n        arg.setDeptno(10);\n        arg.setSal(2000.0);\n        List&lt;Emp&gt; emps = sqlSession.selectList(&quot;findEmpByDeptnoAndSal2&quot;, arg);\n        emps.forEach(System.out::println);\n    &#125;\n    @After\n    public void release()&#123;\n        // 关闭SQLSession\n        sqlSession.close();\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"3-sqlSession完成DML所有操作\"><a href=\"#3-sqlSession完成DML所有操作\" class=\"headerlink\" title=\"3_sqlSession完成DML所有操作\"></a>3_sqlSession完成DML所有操作</h2><p>Mapper映射文件</p>\n<pre><code class=\"xml\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;\n&lt;!DOCTYPE mapper\n        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;\n        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;\n&lt;mapper namespace=&quot;EmpMapper3&quot;&gt;\n    &lt;!--\n    增删方法的返回值类型都是int\n    resultType就无需指定了\n    insert update delete 标签中没有resultType\n    但是仍然可以有paramaterType\n    --&gt;\n    &lt;!-- 增加方法\n    public int addEmp(Emp emp);\n    --&gt;\n    &lt;insert id=&quot;addEmp&quot; parameterType=&quot;emp&quot;&gt;\n    &lt;/insert&gt;\n    &lt;!--修改\n    根据工号修改员工姓名\n    public int updateEmp(Emp emp);\n    --&gt;\n    &lt;update id=&quot;updateEmp&quot; parameterType=&quot;emp&quot;&gt;\n    &lt;/update&gt;\n    &lt;!-- 删除\n    删除大于给定工号的员工信息\n    public int deleteEmp(int empno)\n    --&gt;\n    &lt;delete id=&quot;deleteEmp&quot; parameterType=&quot;int&quot;&gt;\n        delete from emp where empno &gt;= #&#123;empno&#125;\n    &lt;/delete&gt;\n&lt;/mapper&gt;\n</code></pre>\n<p>测试代码</p>\n<pre><code class=\"java\">package com.msb.test;\nimport com.msb.pojo.Emp;\nimport org.apache.ibatis.io.Resources;\nimport org.apache.ibatis.session.SqlSession;\nimport org.apache.ibatis.session.SqlSessionFactory;\nimport org.apache.ibatis.session.SqlSessionFactoryBuilder;\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Test;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n/**\n * @Author: Ma HaiYang\n * @Description: MircoMessage:Mark_7001\n */\npublic class Test4 &#123;\n    private SqlSession sqlSession;\n    @Before\n    public void init()&#123;\n        SqlSessionFactoryBuilder ssfb =new SqlSessionFactoryBuilder();\n        InputStream resourceAsStream = null;\n        try &#123;\n            resourceAsStream = Resources.getResourceAsStream(&quot;sqlMapConfig.xml&quot;);\n        &#125; catch (IOException e) &#123;\n            e.printStackTrace();\n        &#125;\n        SqlSessionFactory factory=ssfb.build(resourceAsStream) ;\n        sqlSession=factory.openSession(true);\n    &#125;\n    @Test\n    public void testInsert()&#123;\n        Emp emp =new Emp(null,&quot;按住啦Baby&quot;,&quot;SALESMAN&quot;,7839,new Date(),3100.0, 200.0,10 );\n        int rows = sqlSession.insert(&quot;addEmp&quot;, emp);\n        System.out.println(rows);\n        // 手动提交事务\n        //sqlSession.commit();\n        /*增删改 要提交事务\n        * sqlSession.commit();手动提交事务\n        * sqlSession=factory.openSession(true); 设置事务自动提交\n        * */\n    &#125;\n    @Test\n    public void testUpdate()&#123;\n        Emp emp =new Emp( );\n        emp.setEname(&quot;晓明&quot;);\n        emp.setEmpno(7937);\n        int rows = sqlSession.update(&quot;updateEmp&quot;, emp);\n        System.out.println(rows);\n    &#125;\n    @Test\n    public void testDelete()&#123;\n        int rows = sqlSession.delete(&quot;deleteEmp&quot;, 7936);\n        System.out.println(rows);\n    &#125;\n    @After\n    public void release()&#123;\n        // 关闭SQLSession\n        sqlSession.close();\n    &#125;\n&#125;\n</code></pre>\n<h1 id=\"5-MyBatis代理模式开发\"><a href=\"#5-MyBatis代理模式开发\" class=\"headerlink\" title=\"5 MyBatis代理模式开发\"></a>5 MyBatis代理模式开发</h1><p>前面已经使用MyBatis完成了对Emp表的CRUD操作，都是由SqlSession调用自身方法发送SQL命令并得到结果的，实现了MyBatis的入门。</p>\n<p>但是却存在如下缺点：</p>\n<ol>\n<li><p>不管是selectList()、selectOne()、selectMap()，都是通过SQLSession对象的API完成增删改查,都只能提供一个查询参数。如果要多个参数，需要封装到JavaBean或者Map中，并不一定永远是一个好办法。</p>\n</li>\n<li><p>返回值类型较固定。</p>\n</li>\n<li><p>只提供了映射文件，没有提供数据库操作的接口，不利于后期的维护扩展。</p>\n</li>\n</ol>\n<p>在MyBatis中提供了另外一种成为<strong>Mapper代理（或称为接口绑定）</strong>的操作方式。在实际开发中也使用该方式。下面我们就是要Mapper代理的方式来实现对Emp表的CRUD操作吧，还有完成多个参数传递、模糊查询、自增主键回填等更多的技能实现。搭建好的项目框架如图所示，相比而言，增加了接口EmployeeMapper。但是却会引起映射文件和测试类的变化。</p>\n<p>优点:</p>\n<p>1有接口 模块之间有规范了</p>\n<p>2参数的处理多样了,接口中的方法参数列表由我们自己决定</p>\n<p>3通过代理模式由mybatis提供接口的实现类对象 我们不用写实现类了</p>\n<p>项目结构:注意文件路径和文件位置!!!</p>\n<img data-src=\"/2022/10/07/ORM/Mybatis/image-20220617195010768.png\" class=\"\" title=\"image-20220617195010768\">\n\n\n<p>准备接口和mapper映射文件</p>\n<p>EmpMapper接口</p>\n<pre><code class=\"java\">package com.msb.mapper;\nimport com.msb.pojo.Emp;\nimport java.util.List;\n/**\n\n * @Author: Ma HaiYang\n * @Description: MircoMessage:Mark_7001\n    */\npublic interface EmpMapper &#123;\n    /**\n     * 该方法用于查询全部的员工信息\n     * @return 全部员工信息封装的Emp对象的List集合\n        */\n    List&lt;Emp&gt; findAll();\n &#125;\n</code></pre>\n<p>EmpMapper.xml映射文件</p>\n<pre><code class=\"xml\"> &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;\n&lt;!DOCTYPE mapper\n        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;\n        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;\n&lt;mapper namespace=&quot;com.msb.mapper.EmpMapper&quot;&gt;\n    &lt;!--\n    1 接口的名字和Mapper映射为文件名字必须保持一致(不包含拓展名)\n    2 Mapper映射文件的namespace必须是接口的全路径名\n    3 sql语句的id必须是对应方法的名\n    4 DeptMapper映射文件应该和接口编译之后放在同一个目录下\n    --&gt;\n    &lt;!--List&lt;Emp&gt; findAll();--&gt;\n    &lt;select id=&quot;findAll&quot; resultType=&quot;emp&quot; &gt;\n        select * from emp\n    &lt;/select&gt;\n&lt;/mapper&gt;\n</code></pre>\n<p>在sqlMapConfig.xml核心配置文件中使用包扫描形式加载所有的映射文件</p>\n<pre><code class=\"xml\"> &lt;!--加载mapper映射文件--&gt;\n&lt;mappers&gt;\n    &lt;!--通过类的全路径去找mapper映射文件--&gt;\n    &lt;mapper class=&quot;com.msb.mapper.EmpMapper&quot;/&gt;\n&lt;/mappers&gt;\n</code></pre>\n<p> 测试代码</p>\n<pre><code class=\"java\">package com.msb.test;\nimport com.msb.mapper.EmpMapper;\nimport com.msb.pojo.Dept;\nimport com.msb.pojo.Emp;\nimport org.apache.ibatis.io.Resources;\nimport org.apache.ibatis.session.SqlSession;\nimport org.apache.ibatis.session.SqlSessionFactory;\nimport org.apache.ibatis.session.SqlSessionFactoryBuilder;\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Test;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.List;\n/**\n\n * @Author: Ma HaiYang\n * @Description: MircoMessage:Mark_7001\n    */\n    public class Test1 &#123;\n    private SqlSession sqlSession;\n    @Before\n    public void init()&#123;\n        SqlSessionFactoryBuilder ssfb =new SqlSessionFactoryBuilder();\n        InputStream resourceAsStream = null;\n        try &#123;\n            resourceAsStream = Resources.getResourceAsStream(&quot;sqlMapConfig.xml&quot;);\n        &#125; catch (IOException e) &#123;\n            e.printStackTrace();\n        &#125;\n        SqlSessionFactory factory=ssfb.build(resourceAsStream) ;\n        sqlSession=factory.openSession();\n    &#125;\n    @Test\n    public void testFindAll()&#123;\n        EmpMapper empMapper=sqlSession.getMapper(EmpMapper.class);\n        List&lt;Emp&gt; emps = empMapper.findAll();\n        emps.forEach(System.out::println);\n    &#125;\n    @After\n    public void release()&#123;\n        // 关闭SQLSession\n        sqlSession.close();\n    &#125;\n&#125;\n</code></pre>\n<p><strong>代理模式浅析</strong></p>\n<p>mybatis是如何通过代理模式实现查询的</p>\n<p>这条语句的底层使用了动态代理模式，动态创建一个EmployeeMapper的一个代理对象并赋给接口引用。所以在MyBatis中不需要显式提供Mapper接口的实现类，这也是简单的地方。</p>\n<h1 id=\"6-代理模式下开发各种功能\"><a href=\"#6-代理模式下开发各种功能\" class=\"headerlink\" title=\"6 代理模式下开发各种功能\"></a>6 代理模式下开发各种功能</h1><h2 id=\"1-多种参数传递问题\"><a href=\"#1-多种参数传递问题\" class=\"headerlink\" title=\"1_多种参数传递问题\"></a>1_多种参数传递问题</h2><blockquote>\n<p>1单个基本数据类型</p>\n<p>2多个基本数据类型</p>\n<p>3单个引用数据类型</p>\n<p>4map集合数据类型</p>\n<p>5多个引用数据类型</p>\n</blockquote>\n<p>接口</p>\n<pre><code class=\"java\">package com.msb.mapper;\nimport com.msb.pojo.Emp;\nimport org.apache.ibatis.annotations.Param;\nimport java.util.List;\nimport java.util.Map;\n/**\n * @Author: Ma HaiYang\n * @Description: MircoMessage:Mark_7001\n */\npublic interface EmpMapper &#123;\n    /**\n     * 该方法用于查询全部的员工信息\n     * @return 全部员工信息封装的Emp对象的List集合\n     */\n    List&lt;Emp&gt; findAll();\n    /**\n     * 根据员工编号查询单个员工信息的方法\n     * @param empno 员工编号\n     * @return 如果找到了返回Emp对象,找不到返回null\n     */\n    Emp findByEmpno(int empno);\n    /**\n     * 根据员工编号和薪资下限去查询员工信息\n     * @param empno 员工编号\n     * @param sal 薪资下限\n     * @return 多个Emp对象的List集合\n     */\n    List&lt;Emp&gt; findByDeptnoAndSal(@Param(&quot;deptno&quot;) int deptno,@Param(&quot;sal&quot;) double sal);\n    List&lt;Emp&gt; findByDeptnoAndSal2(Map&lt;String,Object&gt; map);\n    List&lt;Emp&gt; findByDeptnoAndSal3(Emp emp);\n    List&lt;Emp&gt; findByDeptnoAndSal4(@Param(&quot;empa&quot;) Emp empa,@Param(&quot;empb&quot;) Emp empb);\n&#125;\n</code></pre>\n<p>mapper映射文件</p>\n<pre><code class=\"xml\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;\n&lt;!DOCTYPE mapper\n        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;\n        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;\n&lt;mapper namespace=&quot;com.msb.mapper.EmpMapper&quot;&gt;\n    &lt;!--\n    1 接口的名字和Mapper映射为文件名字必须保持一致(不包含拓展名)\n    2 Mapper映射文件的namespace必须是接口的全路径名\n    3 sql语句的id必须是对应方法的名\n    4 DeptMapper映射文件应该和接口编译之后放在同一个目录下\n    --&gt;\n    &lt;!--List&lt;Emp&gt; findAll();--&gt;\n    &lt;select id=&quot;findAll&quot; resultType=&quot;emp&quot; &gt;\n        select * from emp\n    &lt;/select&gt;\n    &lt;!--\n    单个基本数据类型作为方法参数\n    #&#123;&#125;中可以随便写,遵循见名知意\n    Emp findByEmpno(int empno);\n    --&gt;\n    &lt;select id=&quot;findByEmpno&quot; resultType=&quot;emp&quot; &gt;\n        select * from emp where empno =#&#123;empno&#125;\n    &lt;/select&gt;\n    &lt;!--\n     多个基本数据类型作为方法参数\n     List&lt;Emp&gt; findByDeptnoAndSal(@Param(&quot;detpno&quot;) int deptno,@Param(&quot;sal&quot;) double sal);\n     方式1 arg*     arg0 arg1 arg2 数字是索引,从0开始\n     方式2 param*   param1 param2 param3 数字是编号,从1开始\n     使用别名\n     List&lt;Emp&gt; findByDeptnoAndSal(@Param(&quot;detpno&quot;) int deptno,@Param(&quot;sal&quot;) double sal);\n     通过@Param注解使用别名之后,就不能再使用arg* 但是可以继续使用param*\n    --&gt;\n    &lt;select id=&quot;findByDeptnoAndSal&quot; resultType=&quot;emp&quot;&gt;\n    &lt;/select&gt;\n    &lt;!--\n    参数是map,&#123;&#125;写键的名字\n    --&gt;\n    &lt;select id=&quot;findByDeptnoAndSal2&quot; resultType=&quot;emp&quot; parameterType=&quot;map&quot; &gt;\n    &lt;/select&gt;\n    &lt;!--单个引用类型,&#123;&#125;中写的使用对象的属性名--&gt;\n    &lt;select id=&quot;findByDeptnoAndSal3&quot; resultType=&quot;emp&quot; parameterType=&quot;emp&quot; &gt;\n    &lt;/select&gt;\n    &lt;!--\n    多个引用类型作为方法参数\n     List&lt;Emp&gt; findByDeptnoAndSal4(@Param(&quot;empa&quot;) Emp empa,@Param(&quot;empb&quot;) Emp empb);\n     如果用@Param定义了别名,那么就不能使用arg*.属性名,但是可以使用param*.属性名和别名.属性名\n    --&gt;\n    &lt;select id=&quot;findByDeptnoAndSal4&quot; resultType=&quot;emp&quot;  &gt;\n    &lt;/select&gt;\n&lt;/mapper&gt;\n</code></pre>\n<p>测试 代码</p>\n<pre><code class=\"java\">package com.msb.testDemo;\nimport com.msb.mapper.EmpMapper;\nimport com.msb.pojo.Emp;\nimport com.msb.util.SqlSessionUtil;\nimport org.apache.ibatis.session.SqlSession;\nimport java.util.List;\npublic class Test1 &#123;\n    public static void main(String[] args) &#123;\n        SqlSession sqlSession = SqlSessionUtil.getSqlSession(true);\n        /*\n        * 帮助我们生成一个接口下的实现类对象的\n        *\n        * */\n        EmpMapper mapper = sqlSession.getMapper(EmpMapper.class);\n        List&lt;Emp&gt; emps = mapper.getAllEmp();\n        for(Emp emp:emps) &#123;\n            System.out.println(emp);\n        &#125;\n        // 1单个基本数据类型作为方法参数\n        Emp emp = mapper.getByEmpno(7902);\n        System.out.println(emp);\n        // 2多个基本数据类型作为方法参数\n        List&lt;Emp&gt; emps2 = mapper.getByDeptnoAndSal(10, 1500);\n        for(Emp em:emps2) &#123;\n            System.out.println(em);\n        &#125;\n        // 3单个引用类型作为方法参数\n        Emp condition=new Emp();\n        condition.setDeptno(10);\n        condition.setSal(1500.0);\n        List&lt;Emp&gt; emps3 = mapper.getByDeptnoAndSal2(condition);\n        for(Emp em:emps3) &#123;\n            System.out.println(em);\n        &#125;\n        // 4多个引用类型作为方法参数\n        Emp condition1=new Emp();\n        condition1.setDeptno(10);\n        Emp condition2=new Emp();\n        condition2.setSal(1500.0);\n        List&lt;Emp&gt; emps4 = mapper.getByDeptnoAndSal3(condition1,condition2);\n        for(Emp em:emps4) &#123;\n            System.out.println(em);\n        &#125;\n        sqlSession.close();\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"2-模糊查询功能\"><a href=\"#2-模糊查询功能\" class=\"headerlink\" title=\"2 模糊查询功能\"></a>2 模糊查询功能</h2><pre><code>在进行模糊查询时，在映射文件中可以使用concat()函数来连接参数和通配符。另外注意对于特殊字符，比如&lt;，不能直接书写，应该使用字符实体替换。\n</code></pre>\n<p>接口</p>\n<pre><code class=\"java\">/**\n * 根据名字做模糊查询\n * @param name 模糊查询的文字\n * @return  Emp对象List集合\n */\nList&lt;Emp&gt; findByEname( String name);\n</code></pre>\n<p>mapper映射文件</p>\n<pre><code class=\"xml\">&lt;!--List&lt;Emp&gt; getByName(String name);--&gt;\n&lt;select id=&quot;findByEname&quot;  resultType=&quot;emp&quot; &gt;\n    select * from emp where ename like concat(&#39;%&#39;,#&#123;name&#125;,&#39;%&#39;)\n&lt;/select&gt;\n</code></pre>\n<h2 id=\"3-主键自增回填\"><a href=\"#3-主键自增回填\" class=\"headerlink\" title=\"3_主键自增回填\"></a>3_主键自增回填</h2><pre><code>MySQL支持主键自增。有时候完成添加后需要立刻获取刚刚自增的主键，由下一个操作来使用。比如结算构造车后，主订单的主键确定后，需要作为后续订单明细项的外键存在。如何拿到主键呢，MyBatis提供了支持，可以非常简单的获取。\n</code></pre>\n<p>接口</p>\n<pre><code class=\"java\">public interface DeptMapper &#123;\n    int addDept(Dept dept);\n    int addDept2(Dept dept);\n&#125;\n</code></pre>\n<p>mapper映射文件</p>\n<pre><code class=\"xml\">&lt;mapper namespace=&quot;com.msb.mapper.DeptMapper&quot;&gt;\n   &lt;!-- int addDept(Dept dept);\n   useGeneratedKeys=&quot;true&quot; 返回数据库帮我们生成的主键\n   keyProperty=&quot;deptno&quot; 生成的主键值用我们dept对象那个属性存储\n   --&gt;\n    &lt;insert id=&quot;addDept&quot; parameterType=&quot;dept&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;deptno&quot;&gt;\n    &lt;/insert&gt;\n    &lt;insert id=&quot;addDept2&quot; parameterType=&quot;dept&quot;&gt;\n        &lt;selectKey order=&quot;AFTER&quot; keyProperty=&quot;deptno&quot;  resultType=&quot;int&quot;&gt;\n            select @@identity\n        &lt;/selectKey&gt;\n    &lt;/insert&gt;\n&lt;/mapper&gt;\n</code></pre>\n<p>测试代码</p>\n<pre><code class=\"java\">SqlSession sqlSession = SqlSessionUtil.getSqlSession(true);\nDeptMapper mapper = sqlSession.getMapper(DeptMapper.class);\nDept dept =new Dept(null,&quot;AI学院&quot;,&quot;北京&quot;);\nint i = mapper.addDept2(dept);\nSystem.out.println(i);\nSystem.out.println(dept.getDeptno());\nsqlSession.close();\n</code></pre>\n<p>方式1</p>\n<p>useGeneratedKeys：表示要使用自增的主键</p>\n<p>keyProperty：表示把自增的主键赋给JavaBean的哪个成员变量。</p>\n<p>以添加Dept对象为例，添加前Dept对象的deptno是空的，添加完毕后可以通过getDeptno() 获取自增的主键。</p>\n<p>方式2</p>\n<p>order：取值AFTER|BEFORE，表示在新增之后|之前执行<selectKey>中的SQL命令</p>\n<p>keyProperty：执行select @@identity后结果填充到哪个属性中</p>\n<p>resultType：结果类型。</p>\n<p><strong>技术扩展</strong><br>在很多应用场景中需要新增数据后获取到新增数据的主键值，针对这样的需求一般由三种解决方式：</p>\n<ul>\n<li>主键自定义，用户通过UUID或时间戳等方式生成唯一主键，把这个值当做主键值。在分布式场景中应用较多。</li>\n<li>查询后通过select max(主键) from 表获取主键最大值。这种方式在多线程访问情况下可能出现问题。</li>\n<li>查询后通过select @@identity获取最新生成主键。要求这条SQL必须在insert操作之后，且数据库连接没有关闭。</li>\n</ul>\n<h2 id=\"4-实现DML操作\"><a href=\"#4-实现DML操作\" class=\"headerlink\" title=\"4_实现DML操作\"></a>4_实现DML操作</h2><p>EmpMapper接口</p>\n<pre><code class=\"java\">/**\n * 增加员工信息\n * @param emp 存储新增员工信息的Emp对象\n * @return 对数据库数据产生影响的行数\n */\nint addEmp(Emp emp);\n/**\n * 根据员工编号修改员工姓名的方法\n * @param empno 要修改的员工编号\n * @param ename 修改之后的新的员工名字\n * @return 对数据库数据产生影响的行数\n */\nint updateEnameByEmpno(@Param(&quot;empno&quot;) int empno,@Param(&quot;ename&quot;) String ename);\n/**\n * 根据员工编号删除员工信息\n * @param empno 要删除的员工编号\n * @return 对数据库数据产生影响的行数\n */\nint deleteByEmpno(int empno);\n</code></pre>\n<p>EmpMapper映射 文件</p>\n<pre><code class=\"xml\">&lt;!--int addEmp(Emp emp);--&gt;\n&lt;insert id=&quot;addEmp&quot; &gt;\n&lt;/insert&gt;\n&lt;!--int updateEnameByEmpno(@Param(&quot;empno&quot;) int empno,@Param(&quot;ename&quot;) String ename);--&gt;\n&lt;update id=&quot;updateEnameByEmpno&quot; &gt;\n&lt;/update&gt;\n&lt;!--int deleteByEmpno(int empno);--&gt;\n&lt;update id=&quot;deleteByEmpno&quot; &gt;\n    delete from emp where empno =#&#123;empno&#125;\n&lt;/update&gt;\n</code></pre>\n<p>测试代码</p>\n<pre><code class=\"java\">package com.msb.test;\nimport com.msb.mapper.DeptMapper;\nimport com.msb.mapper.EmpMapper;\nimport com.msb.pojo.Dept;\nimport com.msb.pojo.Emp;\nimport org.apache.ibatis.io.Resources;\nimport org.apache.ibatis.session.SqlSession;\nimport org.apache.ibatis.session.SqlSessionFactory;\nimport org.apache.ibatis.session.SqlSessionFactoryBuilder;\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Test;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.Date;\n/**\n * @Author: Ma HaiYang\n * @Description: MircoMessage:Mark_7001\n */\npublic class Test3 &#123;\n    private SqlSession sqlSession;\n    @Before\n    public void init()&#123;\n        SqlSessionFactoryBuilder ssfb =new SqlSessionFactoryBuilder();\n        InputStream resourceAsStream = null;\n        try &#123;\n            resourceAsStream = Resources.getResourceAsStream(&quot;sqlMapConfig.xml&quot;);\n        &#125; catch (IOException e) &#123;\n            e.printStackTrace();\n        &#125;\n        SqlSessionFactory factory=ssfb.build(resourceAsStream) ;\n        sqlSession=factory.openSession();\n    &#125;\n    @Test\n    public void testAddEmp()&#123;\n        EmpMapper mapper = sqlSession.getMapper(EmpMapper.class);\n        mapper.addEmp(new Emp(null, &quot;TOM&quot;, &quot;SALESMAN&quot;, 7521, new Date(), 2314.0, 100.0, 10));\n        sqlSession.commit();\n    &#125;\n    @Test\n    public void testUpdateEnameByEmpno()&#123;\n        EmpMapper mapper = sqlSession.getMapper(EmpMapper.class);\n        mapper.updateEnameByEmpno(7938, &quot;TOM&quot;);\n        sqlSession.commit();\n    &#125;\n    @Test\n    public void testDeletByEmpno()&#123;\n        EmpMapper mapper = sqlSession.getMapper(EmpMapper.class);\n        mapper.deleteByEmpno(7938);\n        sqlSession.commit();\n    &#125;\n    @After\n    public void release()&#123;\n        // 关闭SQLSession\n        sqlSession.close();\n    &#125;\n&#125;\n</code></pre>\n<h1 id=\"7-动态SQL\"><a href=\"#7-动态SQL\" class=\"headerlink\" title=\"7 动态SQL\"></a>7 动态SQL</h1><pre><code>经常遇到很多按照很多查询条件进行查询的情况，比如京东根据不同的条件筛选商品。其中经常出现很多条件不取值的情况，在后台应该如何完成最终的SQL语句呢？\n\n\n\n\n\n\n\n\n\n如果采用JDBC进行处理，需要根据条件是否取值进行SQL语句的拼接，一般情况下是使用StringBuilder类及其append方法实现，还是有些繁琐的。如果你有使用 JDBC 或其它类似框架的经验，你就能体会到根据不同条件拼接 SQL语句的痛苦。例如拼接时要确保不能忘记添加必要的空格，还要注意去掉列表最后一个列名的逗号。利用动态 SQL 这一特性可以彻底摆脱这种痛苦。\n\nMyBatis在简化操作方法提出了动态SQL功能，将使用Java代码拼接SQL语句，改变为在XML映射文件中截止标签拼接SQL语句。相比而言，大大减少了代码量，更灵活、高度可配置、利于后期维护。\n\nMyBatis中动态SQL是编写在mapper.xml中的，其语法和JSTL类似，但是却是基于强大的OGNL表达式实现的。\n\nMyBatis也可以在注解中配置SQL，但是由于注解功能受限，尤其是对于复杂的SQL语句，可读性很差，所以较少使用。\n</code></pre>\n<h2 id=\"1-if标签\"><a href=\"#1-if标签\" class=\"headerlink\" title=\"1_if标签\"></a>1_if标签</h2><p>接口</p>\n<pre><code class=\"java\">public interface EmpMapper2 &#123;\n  List&lt;Emp&gt; findByCondition(Emp emp);\n&#125;\n</code></pre>\n<p>映射文件</p>\n<pre><code class=\"xml\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;\n&lt;!DOCTYPE mapper\n        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;\n        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;\n&lt;mapper namespace=&quot;com.msb.mapper.EmpMapper2&quot;&gt;\n&lt;!--List&lt;Emp&gt; findByCondition(Emp emp);--&gt;\n    &lt;select id=&quot;findByCondition&quot; resultType=&quot;emp&quot;&gt;\n        select * from emp where 1=1\n        &lt;if test=&quot;empno != null&quot;&gt;\n            and empno =#&#123;empno&#125;\n        &lt;/if&gt;\n        &lt;if test=&quot;ename != null and ename != &#39;&#39;&quot;&gt;\n            and ename like concat(&#39;%&#39;,#&#123;ename&#125;,&#39;%&#39;)\n        &lt;/if&gt;\n        &lt;if test=&quot;job != null and job != &#39;&#39;&quot;&gt;\n            and job =#&#123;job&#125;\n        &lt;/if&gt;\n        &lt;if test=&quot;mgr != null&quot;&gt;\n            and mgr =#&#123;mgr&#125;\n        &lt;/if&gt;\n        &lt;if test=&quot;hiredate != null&quot;&gt;\n            and hiredate =#&#123;hiredate&#125;\n        &lt;/if&gt;\n        &lt;if test=&quot;sal != null&quot;&gt;\n            and sal =#&#123;sal&#125;\n        &lt;/if&gt;\n        &lt;if test=&quot;comm != null&quot;&gt;\n            and comm =#&#123;comm&#125;\n        &lt;/if&gt;\n        &lt;if test=&quot;deptno != null&quot;&gt;\n            and deptno =#&#123;deptno&#125;\n        &lt;/if&gt;\n    &lt;/select&gt;\n&lt;/mapper&gt;\n</code></pre>\n<p>测试代码</p>\n<pre><code class=\"java\">public static void main(String[] args) &#123;\n    SqlSession sqlSession = MyBatisUtil.getSqlSession(false);\n    EmpMapper2 mapper = sqlSession.getMapper(EmpMapper2.class);\n    Emp condition =new Emp();\n   /* condition.setDeptno(20);*/\n   /* condition.setSal(3000.0);*/\n   /*condition.setHiredate(new java.sql.Date(81,1,22));*/\n   condition.setComm(0.0);\n   condition.setDeptno(20);\n    List&lt;Emp&gt; emps = mapper.findEmpByCondition(condition);\n    for (Emp e:emps\n         ) &#123;\n        System.out.println(e);\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"2-where标签\"><a href=\"#2-where标签\" class=\"headerlink\" title=\"2_where标签\"></a>2_where标签</h2><blockquote>\n<p>用于处理where关键字和and</p>\n<p>默认删除第一个and逻辑连接符</p>\n</blockquote>\n<pre><code class=\"xml\">&lt;select id=&quot;findEmpByCondition&quot; resultType=&quot;emp&quot;&gt;\n    select * from emp\n    &lt;where&gt;\n        &lt;if test=&quot;empno != null&quot;&gt;\n            and empno= #&#123;empno&#125;\n        &lt;/if&gt;\n        &lt;if test=&quot;ename != null and ename != &#39;&#39;&quot;&gt;\n            and ename= #&#123;ename&#125;\n        &lt;/if&gt;\n        &lt;if test=&quot;job != null and job != &#39;&#39;&quot;&gt;\n            and job= #&#123;job&#125;\n        &lt;/if&gt;\n        &lt;if test=&quot;mgr != null &quot;&gt;\n            and mgr= #&#123;mgr&#125;\n        &lt;/if&gt;\n        &lt;if test=&quot;hiredate != null &quot;&gt;\n            and hiredate= #&#123;hiredate&#125;\n        &lt;/if&gt;\n        &lt;if test=&quot;sal != null&quot;&gt;\n            and sal= #&#123;sal&#125;\n        &lt;/if&gt;\n        &lt;if test=&quot;comm != null &quot;&gt;\n             and comm =#&#123;comm&#125;\n        &lt;/if&gt;\n        &lt;if test=&quot;deptno != null &quot;&gt;\n            and deptno= #&#123;deptno&#125;\n        &lt;/if&gt;\n    &lt;/where&gt;\n&lt;/select&gt;\n</code></pre>\n<h2 id=\"3-choose标签\"><a href=\"#3-choose标签\" class=\"headerlink\" title=\"3_choose标签\"></a>3_choose标签</h2><p>前面的when条件成立 后面的 when就不再判断了</p>\n<pre><code class=\"xml\"> &lt;select id=&quot;findEmpByCondition2&quot; resultType=&quot;emp&quot;&gt;\n    select * from emp\n    &lt;where&gt;\n        &lt;choose&gt;\n            &lt;when test=&quot;empno != null&quot;&gt;\n                and empno= #&#123;empno&#125;\n            &lt;/when&gt;\n            &lt;when test=&quot;ename != null and ename != &#39;&#39;&quot;&gt;\n                and ename= #&#123;ename&#125;\n            &lt;/when&gt;\n            &lt;when test=&quot;job != null and job != &#39;&#39;&quot;&gt;\n                and job= #&#123;job&#125;\n            &lt;/when&gt;\n            &lt;when test=&quot;mgr != null &quot;&gt;\n                and mgr= #&#123;mgr&#125;\n            &lt;/when&gt;\n            &lt;when test=&quot;hiredate != null &quot;&gt;\n                and hiredate= #&#123;hiredate&#125;\n            &lt;/when&gt;\n            &lt;when test=&quot;sal != null&quot;&gt;\n                and sal= #&#123;sal&#125;\n            &lt;/when&gt;\n            &lt;when test=&quot;comm != null &quot;&gt;\n                and comm =#&#123;comm&#125;\n            &lt;/when&gt;\n            &lt;when test=&quot;deptno != null &quot;&gt;\n                and deptno= #&#123;deptno&#125;\n            &lt;/when&gt;\n        &lt;/choose&gt;\n    &lt;/where&gt;\n&lt;/select&gt;\n</code></pre>\n<h2 id=\"4-set标签\"><a href=\"#4-set标签\" class=\"headerlink\" title=\"4_set标签\"></a>4_set标签</h2><p>接口</p>\n<pre><code class=\"java\"> int updateEmpByCondtion(Emp emp);\n</code></pre>\n<p>映射文件</p>\n<pre><code class=\"xml\"> &lt;!--int updateEmpByCondtion(Emp emp);--&gt;\n&lt;update id=&quot;updateEmpByCondtion&quot; &gt;\n    update emp\n    &lt;set&gt;\n        &lt;if test=&quot;ename != null and ename != &#39;&#39; &quot;&gt;\n            , ename =#&#123;ename&#125;\n        &lt;/if&gt;\n        &lt;if test=&quot;job != null and ename != &#39;&#39; &quot;&gt;\n            , job =#&#123;job&#125;\n        &lt;/if&gt;\n        &lt;if test=&quot;mgr != null &quot;&gt;\n            , mgr =#&#123;mgr&#125;\n        &lt;/if&gt;\n        &lt;if test=&quot;hiredate != null &quot;&gt;\n            , hiredate =#&#123;hiredate&#125;\n        &lt;/if&gt;\n        &lt;if test=&quot;sal != null &quot;&gt;\n            , sal =#&#123;sal&#125;\n        &lt;/if&gt;\n        &lt;if test=&quot;comm != null &quot;&gt;\n            , comm =#&#123;comm&#125;\n        &lt;/if&gt;\n        &lt;if test=&quot;deptno != null &quot;&gt;\n            , deptno =#&#123;deptno&#125;\n        &lt;/if&gt;\n    &lt;/set&gt;\n    where empno =#&#123;empno&#125;\n&lt;/update&gt;\n</code></pre>\n<h2 id=\"5-trim标签\"><a href=\"#5-trim标签\" class=\"headerlink\" title=\"5_trim标签\"></a>5_trim标签</h2><blockquote>\n<p>Trim 标签处理 set  ，可以为他包裹起来的SQL语句前后 增加&#x2F;删除 关键词&#x2F;固定字符</p>\n</blockquote>\n<pre><code class=\"xml\">&lt;update id=&quot;updateEmpByCondition2&quot; &gt;\n    update emp\n    &lt;!--prefix 要增加什么前缀\n    prefixOverrides 要去除什么前缀\n    suffix 要增加什么后缀\n    suffixOverrides 要去除什么后缀\n    set 是trim的一种特殊情况\n    --&gt;\n    &lt;trim prefix=&quot;set&quot;  suffixOverrides=&quot;,&quot; &gt;\n        &lt;if test=&quot;ename != null and ename != &#39;&#39;&quot;&gt;\n            ename= #&#123;ename&#125;,\n        &lt;/if&gt;\n        &lt;if test=&quot;job != null and job != &#39;&#39;&quot;&gt;\n            job= #&#123;job&#125;,\n        &lt;/if&gt;\n        &lt;if test=&quot;mgr != null &quot;&gt;\n            mgr= #&#123;mgr&#125;,\n        &lt;/if&gt;\n        &lt;if test=&quot;hiredate != null &quot;&gt;\n            hiredate= #&#123;hiredate&#125;,\n        &lt;/if&gt;\n        &lt;if test=&quot;sal != null&quot;&gt;\n            sal= #&#123;sal&#125;,\n        &lt;/if&gt;\n        &lt;if test=&quot;comm != null &quot;&gt;\n            comm =#&#123;comm&#125;,\n        &lt;/if&gt;\n        &lt;if test=&quot;deptno != null &quot;&gt;\n            deptno= #&#123;deptno&#125;,\n        &lt;/if&gt;\n    &lt;/trim&gt;\n    where  empno = #&#123;empno&#125;\n&lt;/update&gt;\n</code></pre>\n<p>Trim标签  处理where</p>\n<pre><code class=\"xml\">    &lt;select id=&quot;findByCondition&quot; resultMap=&quot;EmpMap&quot;&gt;\n        select * from emp \n        &lt;trim prefix=&quot;where&quot; prefixOverrides=&quot;and&quot;&gt;\n            &lt;if test=&quot;empno != null&quot;&gt;\n                and empno =#&#123;empno&#125;\n            &lt;/if&gt;\n            &lt;if test=&quot;ename != null and ename != &#39;&#39;&quot;&gt;\n                &lt;bind name=&quot;likePattern&quot; value=&quot;&#39;%&#39;+ename+&#39;%&#39;&quot;/&gt;\n                and ename like #&#123;likePattern&#125;\n            &lt;/if&gt;\n            &lt;if test=&quot;job != null and job != &#39;&#39;&quot;&gt;\n                and job =#&#123;job&#125;\n            &lt;/if&gt;\n            &lt;if test=&quot;mgr != null&quot;&gt;\n                and mgr =#&#123;mgr&#125;\n            &lt;/if&gt;\n            &lt;if test=&quot;hiredate != null&quot;&gt;\n                and hiredate =#&#123;hiredate&#125;\n            &lt;/if&gt;\n            &lt;if test=&quot;sal != null&quot;&gt;\n                and sal =#&#123;sal&#125;\n            &lt;/if&gt;\n            &lt;if test=&quot;comm != null&quot;&gt;\n                and comm =#&#123;comm&#125;\n            &lt;/if&gt;\n            &lt;if test=&quot;deptno != null&quot;&gt;\n                and deptno =#&#123;deptno&#125;\n            &lt;/if&gt;\n        &lt;/trim&gt;\n    &lt;/select&gt;\n</code></pre>\n<h2 id=\"6-bind标签\"><a href=\"#6-bind标签\" class=\"headerlink\" title=\"6_bind标签\"></a>6_bind标签</h2><p>一般用于处理模糊查询的模板</p>\n<p>接口</p>\n<img data-src=\"/2022/10/07/ORM/Mybatis/image-20220617200421440.png\" class=\"\" title=\"image-20220617200421440\">\n\n\n<p>SQL语句</p>\n<pre><code class=\"xml\">&lt;!-- bind 写一个局部SQL模板，模糊 like 常用--&gt;\n    &lt;select id=&quot;findEmpByEname&quot; resultMap=&quot;EmpMap&quot;&gt;\n        &lt;bind name=&quot;likePatten&quot; value=&quot;&#39;%&#39;+param1+&#39;%&#39;&quot;/&gt;\n        select * from emp where ename like #&#123;likePatten&#125;;\n    &lt;/select&gt;\n</code></pre>\n<h2 id=\"7-nclude\"><a href=\"#7-nclude\" class=\"headerlink\" title=\"7_nclude\"></a>7_nclude</h2><p>引用提前写好的 SQL 标签的SQL语句</p>\n<pre><code class=\"xml\">    &lt;sql id=&quot;empColumn&quot;&gt;empno,ename,job,mgr,hiredate,sal,comm,deptno&lt;/sql&gt;\n    &lt;sql id=&quot;baseSelect&quot;&gt;\n        select &lt;include refid=&quot;empColumn&quot;&gt;&lt;/include&gt; from emp\n    &lt;/sql&gt;\n</code></pre>\n<h2 id=\"8-sql标签\"><a href=\"#8-sql标签\" class=\"headerlink\" title=\"8_sql标签\"></a>8_sql标签</h2><pre><code class=\"xml\"> &lt;sql id=&quot;empColumn&quot;&gt;empno,ename,job,mgr,hiredate,sal,comm,deptno&lt;/sql&gt;\n&lt;sql id=&quot;baseSelect&quot;&gt;select &lt;include refid=&quot;empColumn&quot;&gt;&lt;/include&gt; from emp&lt;/sql&gt;\n&lt;!--List&lt;Emp&gt; findByCondition(Emp emp);--&gt;\n&lt;select id=&quot;findByCondition&quot; resultType=&quot;emp&quot;&gt;\n    &lt;include refid=&quot;baseSelect&quot;&gt;&lt;/include&gt;\n    &lt;trim prefix=&quot;where&quot; prefixOverrides=&quot;and&quot;&gt;\n        &lt;if test=&quot;empno != null&quot;&gt;\n            and empno =#&#123;empno&#125;\n        &lt;/if&gt;\n        &lt;if test=&quot;ename != null and ename != &#39;&#39;&quot;&gt;\n            &lt;bind name=&quot;likePattern&quot; value=&quot;&#39;%&#39;+ename+&#39;%&#39;&quot;/&gt;\n            and ename like #&#123;likePattern&#125;\n        &lt;/if&gt;\n        &lt;if test=&quot;job != null and job != &#39;&#39;&quot;&gt;\n            and job =#&#123;job&#125;\n        &lt;/if&gt;\n        &lt;if test=&quot;mgr != null&quot;&gt;\n            and mgr =#&#123;mgr&#125;\n        &lt;/if&gt;\n        &lt;if test=&quot;hiredate != null&quot;&gt;\n            and hiredate =#&#123;hiredate&#125;\n        &lt;/if&gt;\n        &lt;if test=&quot;sal != null&quot;&gt;\n            and sal =#&#123;sal&#125;\n        &lt;/if&gt;\n        &lt;if test=&quot;comm != null&quot;&gt;\n            and comm =#&#123;comm&#125;\n        &lt;/if&gt;\n        &lt;if test=&quot;deptno != null&quot;&gt;\n            and deptno =#&#123;deptno&#125;\n        &lt;/if&gt;\n    &lt;/trim&gt;\n&lt;/select&gt;\n</code></pre>\n<h2 id=\"9-foreach标签\"><a href=\"#9-foreach标签\" class=\"headerlink\" title=\"9_foreach标签\"></a>9_foreach标签</h2><pre><code class=\"xml\"> &lt;!--List&lt;Emp&gt; findByEmpnos1(int[] empnos);\n collection=&quot;&quot;  遍历的集合或者是数组\n                 参数是数组,collection中名字指定为array\n                 参数是List集合,collection中名字指定为list\n separator=&quot;&quot;   多个元素取出的时候 用什么文字分隔\n open=&quot;&quot;        以什么开头\n close=&quot;&quot;       以什么结尾\n item=&quot;&quot;        中间变量名\n for(Person per:PersonList)\n --&gt;\n &lt;select id=&quot;findByEmpnos1&quot; resultType=&quot;emp&quot;&gt;\n     select * from emp  where empno in\n     &lt;foreach collection=&quot;array&quot; separator=&quot;,&quot; open=&quot;(&quot; close=&quot;)&quot; item=&quot;deptno&quot;&gt;\n         #&#123;deptno&#125;\n     &lt;/foreach&gt;\n &lt;/select&gt;\n&lt;!-- List&lt;Emp&gt; findByEmpnos2(List&lt;Integer&gt; empnos);--&gt;\n &lt;select id=&quot;findByEmpnos2&quot; resultType=&quot;emp&quot;&gt;\n     select * from emp  where empno in\n     &lt;foreach collection=&quot;list&quot; separator=&quot;,&quot; open=&quot;(&quot; close=&quot;)&quot; item=&quot;deptno&quot;&gt;\n         #&#123;deptno&#125;\n     &lt;/foreach&gt;\n &lt;/select&gt;\n</code></pre>\n<h1 id=\"8-MyBatis实现多表查询\"><a href=\"#8-MyBatis实现多表查询\" class=\"headerlink\" title=\"8 MyBatis实现多表查询\"></a>8 MyBatis实现多表查询</h1><p>前面已经使用MyBatis完成了对Emp表的CRUD操作，不管是使用SqlSession直接操作，还是使用Mapper代理方式，都只是完成了对单个数据库表的操作。这肯定是远远不够的。</p>\n<p>在实际开发中，经常会将来自多张表的数据在一个位置显示。比如查询并显示的员工信息中会有来自部门表、岗位表的数据，而后台一般是定义一个方法</p>\n<h2 id=\"1-关联查询\"><a href=\"#1-关联查询\" class=\"headerlink\" title=\"1 关联查询\"></a>1 关联查询</h2><h3 id=\"1-手动处理映射关系\"><a href=\"#1-手动处理映射关系\" class=\"headerlink\" title=\"1 手动处理映射关系\"></a>1 手动处理映射关系</h3><p>实体类</p>\n<pre><code class=\"java\">public class Emp  implements Serializable &#123;\n    private Integer empno;\n    private String name;\n    private String job;\n    private Integer mgr;\n    private Date hiredate;\n    private Double sal;\n    private Double comm;\n    private Integer deptno;\n&#125;\n</code></pre>\n<p>映射文件</p>\n<pre><code class=\"xml\">&lt;mapper namespace=&quot;com.msb.mapper.EmpMapper&quot;&gt;\n    &lt;!--手动处理数据库查询字段和封装实体类属性之间的映射关系\n    1 主键一般使用id属性\n    2 当属性名和查询出的数据表字段名相同 可以不写映射关系\n    --&gt;\n    &lt;resultMap id=&quot;empMap&quot; type=&quot;emp&quot;&gt;\n        &lt;!--&lt;id property=&quot;empno&quot; column=&quot;empno&quot;&gt;&lt;/id&gt;--&gt;\n        &lt;result property=&quot;name&quot; column=&quot;ename&quot;&gt;&lt;/result&gt;\n        &lt;!--&lt;result property=&quot;job&quot; column=&quot;job&quot;&gt;&lt;/result&gt;\n        &lt;result property=&quot;sal&quot; column=&quot;sal&quot;&gt;&lt;/result&gt;\n        &lt;result property=&quot;hiredate&quot; column=&quot;hiredate&quot;&gt;&lt;/result&gt;\n        &lt;result property=&quot;mgr&quot; column=&quot;mgr&quot;&gt;&lt;/result&gt;\n        &lt;result property=&quot;comm&quot; column=&quot;comm&quot;&gt;&lt;/result&gt;\n        &lt;result property=&quot;deptno&quot; column=&quot;deptno&quot;&gt;&lt;/result&gt;--&gt;\n    &lt;/resultMap&gt;\n    &lt;select id=&quot;findByEmpno&quot; resultMap=&quot;empMap&quot; &gt;\n        select * from emp where empno =#&#123;empno&#125;\n    &lt;/select&gt;\n&lt;/mapper&gt;\n</code></pre>\n<h3 id=\"2-一对一关联查询\"><a href=\"#2-一对一关联查询\" class=\"headerlink\" title=\"2 一对一关联查询\"></a>2 一对一关联查询</h3><p>数据准备: 创建项目表和项目记录表</p>\n<img data-src=\"/2022/10/07/ORM/Mybatis/image-20220617200808312.png\" class=\"\" title=\"image-20220617200808312\">\n\n\n\n<pre><code class=\"sql\">CREATE TABLE `projects`  (\n  `pid` int(2) NOT NULL AUTO_INCREMENT,\n  `pname` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL,\n  `money` int(11) NULL DEFAULT NULL,\n  PRIMARY KEY (`pid`) USING BTREE\n) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = Dynamic;\nINSERT INTO `projects` VALUES (1, &#39; ***大学OA&#39;, 500000);\nINSERT INTO `projects` VALUES (2, &#39;学生选课系统&#39;, 100000);\nINSERT INTO `projects` VALUES (3, &#39;讲师测评系统&#39;, 20000);\nINSERT INTO `projects` VALUES (4, &#39;线上问答系统 &#39;, 20000);\nCREATE TABLE `projectrecord`  (\n  `empno` int(4) NOT NULL,\n  `pid` int(2) NOT NULL,\n  PRIMARY KEY (`empno`, `pid`) USING BTREE,\n  INDEX `fk_project_pro`(`pid`) USING BTREE,\n  CONSTRAINT `fk_emp_pro` FOREIGN KEY (`empno`) REFERENCES `emp` (`EMPNO`) ON DELETE CASCADE ON UPDATE CASCADE,\n  CONSTRAINT `fk_project_pro` FOREIGN KEY (`pid`) REFERENCES `projects` (`pid`) ON DELETE CASCADE ON UPDATE CASCADE\n) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = Dynamic;\nINSERT INTO `projectrecord` VALUES (7369, 1);\nINSERT INTO `projectrecord` VALUES (7521, 1);\nINSERT INTO `projectrecord` VALUES (7369, 2);\nINSERT INTO `projectrecord` VALUES (7499, 2);\nINSERT INTO `projectrecord` VALUES (7521, 2);\nINSERT INTO `projectrecord` VALUES (7369, 3);\nINSERT INTO `projectrecord` VALUES (7499, 3);\nINSERT INTO `projectrecord` VALUES (7521, 3);\nINSERT INTO `projectrecord` VALUES (7369, 4);\nINSERT INTO `projectrecord` VALUES (7499, 4);\n</code></pre>\n<p>需求:根据编号查询员工信息及所在的部门信息</p>\n<p>实体类添加一个部门作为属性</p>\n<p>实体类</p>\n<pre><code class=\"java\">@AllArgsConstructor\n@NoArgsConstructor\n@Data\npublic class Emp implements Serializable &#123;\n    private Integer empno;\n    private String ename;\n    private String job;\n    private Integer mgr;\n    private Date hiredate;\n    private Double sal;\n    private Double comm;\n    private Integer deptno;\n    // 组合一个Dept对象作为自己的属性\n    private Dept dept;\n&#125;\n</code></pre>\n<p>接口</p>\n<pre><code class=\"java\">public interface EmpMapper &#123;\n    /**\n     * 根据员工编号查询员工的所有信息并携带所在的部门信息\n     * @param empno 要查询的员工编号\n     * @return Emp对象,组合了Dept对象作为属性,对部门信息进行存储\n     */\n    Emp findEmpJoinDeptByEmpno(int empno);\n&#125;\n</code></pre>\n<p>映射文件</p>\n<pre><code class=\"xml\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;\n&lt;!DOCTYPE mapper\n        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;\n        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;\n&lt;mapper namespace=&quot;com.msb.mapper.EmpMapper&quot;&gt;\n    &lt;!--Emp findEmpJoinDeptByEmpno(int empno);--&gt;\n    &lt;resultMap id=&quot;empJoinDept&quot; type=&quot;emp&quot;&gt;\n        &lt;!--设置emp本身的八个属性的映射关系--&gt;\n        &lt;id property=&quot;empno&quot; column=&quot;empno&quot;&gt;&lt;/id&gt;\n        &lt;result property=&quot;ename&quot; column=&quot;ename&quot;&gt;&lt;/result&gt;\n        &lt;result property=&quot;job&quot; column=&quot;job&quot;&gt;&lt;/result&gt;\n        &lt;result property=&quot;sal&quot; column=&quot;sal&quot;&gt;&lt;/result&gt;\n        &lt;result property=&quot;hiredate&quot; column=&quot;hiredate&quot;&gt;&lt;/result&gt;\n        &lt;result property=&quot;mgr&quot; column=&quot;mgr&quot;&gt;&lt;/result&gt;\n        &lt;result property=&quot;comm&quot; column=&quot;comm&quot;&gt;&lt;/result&gt;\n        &lt;result property=&quot;deptno&quot; column=&quot;deptno&quot;&gt;&lt;/result&gt;\n        &lt;!--\n        association 处理一对一\n        封装一对一信息关系的标签\n        property  emp类的属性名\n        javaType  用哪个类的对象给属性赋值\n        --&gt;\n        &lt;association property=&quot;dept&quot; javaType=&quot;dept&quot;&gt;\n            &lt;id column=&quot;deptno&quot; property=&quot;deptno&quot;&gt;&lt;/id&gt;\n            &lt;result column=&quot;dname&quot; property=&quot;dname&quot;&gt;&lt;/result&gt;\n            &lt;result column=&quot;loc&quot; property=&quot;loc&quot;&gt;&lt;/result&gt;\n        &lt;/association&gt;\n    &lt;/resultMap&gt;\n    &lt;select id=&quot;findEmpJoinDeptByEmpno&quot; resultMap=&quot;empJoinDept&quot; &gt;\n        select * from\n        emp e\n        left join dept  d\n        on e.deptno =d.deptno\n        where empno = #&#123;empno&#125;\n    &lt;/select&gt;\n&lt;/mapper&gt;\n</code></pre>\n<p>测试代码</p>\n<pre><code class=\"java\">@Test\npublic void testOneToOne() throws ParseException &#123;\n    EmpMapper mapper = sqlSession.getMapper(EmpMapper.class);\n    Emp emp = mapper.findEmpJoinDeptByEmpno(7499);\n    System.out.println(emp);\n&#125;\n</code></pre>\n<p>3 一对多关联查询</p>\n<p>根据部门号查询部门信息及该部门的所有员工信息</p>\n<p>实体类</p>\n<pre><code class=\"java\">@Data\n@AllArgsConstructor\n@NoArgsConstructor\npublic class Dept implements Serializable &#123;\n    private Integer deptno;\n    private String dname;\n    private String loc;\n    // 组合一个Emp的List集合作为属性\n    private List&lt;Emp&gt; empList;\n&#125;\n</code></pre>\n<p>接口</p>\n<pre><code class=\"java\">package com.msb.mapper;\nimport com.msb.pojo.Dept;\n/**\n * @Author: Ma HaiYang\n * @Description: MircoMessage:Mark_7001\n */\npublic interface DeptMapper &#123;\n    /**\n     * 根据部门编号查询部门信息及该部分的所有员工信息\n     * @param deptno 要查询的部门编号\n     * @return Dept对象,内部组合了一个Emp的List属性用于封装部门的所有员工信息\n     */\n    Dept findDeptJoinEmpsByDeptno(int deptno);\n&#125;\n</code></pre>\n<p>映射文件</p>\n<pre><code class=\"xml\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;\n&lt;!DOCTYPE mapper\n        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;\n        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;\n&lt;mapper namespace=&quot;com.msb.mapper.DeptMapper&quot;&gt;\n    &lt;!--Dept findDeptJoinEmpsByDeptno(int deptno);--&gt;\n    &lt;resultMap id=&quot;deptJoinEmps&quot; type=&quot;dept&quot;&gt;\n        &lt;id column=&quot;deptno&quot; property=&quot;deptno&quot;&gt;&lt;/id&gt;\n        &lt;result column=&quot;dname&quot; property=&quot;dname&quot;&gt;&lt;/result&gt;\n        &lt;result column=&quot;loc&quot; property=&quot;loc&quot;&gt;&lt;/result&gt;\n        &lt;!--处理一对多关系的标签--&gt;\n        &lt;collection property=&quot;empList&quot; ofType=&quot;emp&quot; &gt;\n            &lt;!--设置emp本身的八个属性的映射关系--&gt;\n            &lt;id property=&quot;empno&quot; column=&quot;empno&quot;&gt;&lt;/id&gt;\n            &lt;result property=&quot;ename&quot; column=&quot;ename&quot;&gt;&lt;/result&gt;\n            &lt;result property=&quot;job&quot; column=&quot;job&quot;&gt;&lt;/result&gt;\n            &lt;result property=&quot;sal&quot; column=&quot;sal&quot;&gt;&lt;/result&gt;\n            &lt;result property=&quot;hiredate&quot; column=&quot;hiredate&quot;&gt;&lt;/result&gt;\n            &lt;result property=&quot;mgr&quot; column=&quot;mgr&quot;&gt;&lt;/result&gt;\n            &lt;result property=&quot;comm&quot; column=&quot;comm&quot;&gt;&lt;/result&gt;\n            &lt;result property=&quot;deptno&quot; column=&quot;deptno&quot;&gt;&lt;/result&gt;\n        &lt;/collection&gt;\n    &lt;/resultMap&gt;\n    &lt;select id=&quot;findDeptJoinEmpsByDeptno&quot; resultMap=&quot;deptJoinEmps&quot;&gt;\n        select * from dept d left join emp e on d.deptno =e.deptno where d.deptno =#&#123;deptno&#125;\n    &lt;/select&gt;\n&lt;/mapper&gt;\n</code></pre>\n<p>测试代码</p>\n<pre><code class=\"java\">@Test\npublic void testOneToMany() throws ParseException &#123;\n    DeptMapper mapper = sqlSession.getMapper(DeptMapper.class);\n    Dept dept = mapper.findDeptJoinEmpsByDeptno(20);\n    System.out.println(dept);\n    System.out.println(&quot;---------&quot;);\n    List&lt;Emp&gt; empList = dept.getEmpList();\n    empList.forEach(System.out::println);\n&#125;\n</code></pre>\n<p>4 多对多关联查询</p>\n<p>根据项目编号查询项目信息,以及参与到该项目之中的所有的员工信息</p>\n<p>实体类</p>\n<pre><code class=\"java\">@NoArgsConstructor\n@AllArgsConstructor\n@Data\npublic class Project  implements Serializable &#123;\n    private Integer pid;\n    private String pname;\n    private Integer money;\n    // 组合一个ProjectRecord对象集合作为属性\n    private List&lt;ProjectRecord&gt; projectRecords;\n&#125;\n@Data\n@AllArgsConstructor\n@NoArgsConstructor\npublic class ProjectRecord implements Serializable &#123;\n    private Integer empno;\n    private Integer pid;\n    // 组合一个Emp对象作为属性\n    private Emp emp;\n&#125;\n</code></pre>\n<p>接口</p>\n<pre><code class=\"java\">package com.msb.mapper;\nimport com.msb.pojo.Emp;\nimport com.msb.pojo.Project;\n/**\n * @Author: Ma HaiYang\n * @Description: MircoMessage:Mark_7001\n */\npublic interface ProjectMapper &#123;\n    /**\n     * 根据项目编号查询一个项目信息及参与该项目的所有员工信息\n     * @param pid 项目编号\n     * @return 所有信息封装的Project对象\n     */\n    Project findProjectJoinEmpsByPid(int pid);\n&#125;\n</code></pre>\n<p>映射文件</p>\n<pre><code class=\"xml\">&lt;!DOCTYPE mapper\n        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;\n        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;\n&lt;mapper namespace=&quot;com.msb.mapper.ProjectMapper&quot;&gt;\n    &lt;!--Project findProjectJoinEmpsByPid(int pid);--&gt;\n    &lt;resultMap id=&quot;projectJoinEmps&quot; type=&quot;project&quot;&gt;\n        &lt;id column=&quot;pid&quot; property=&quot;pid&quot;&gt;&lt;/id&gt;\n        &lt;result column=&quot;pname&quot; property=&quot;pname&quot;&gt;&lt;/result&gt;\n        &lt;result column=&quot;money&quot; property=&quot;money&quot;&gt;&lt;/result&gt;\n        &lt;!--一对多 集合属性 collection--&gt;\n        &lt;collection property=&quot;projectRecords&quot; ofType=&quot;projectRecord&quot;&gt;\n            &lt;id column=&quot;empno&quot; property=&quot;empno&quot;&gt;&lt;/id&gt;\n            &lt;id column=&quot;pid&quot; property=&quot;pid&quot;&gt;&lt;/id&gt;\n            &lt;!--一对一 --&gt;\n            &lt;association property=&quot;emp&quot; javaType=&quot;emp&quot;&gt;\n                &lt;id property=&quot;empno&quot; column=&quot;empno&quot;&gt;&lt;/id&gt;\n                &lt;result property=&quot;ename&quot; column=&quot;ename&quot;&gt;&lt;/result&gt;\n                &lt;result property=&quot;job&quot; column=&quot;job&quot;&gt;&lt;/result&gt;\n                &lt;result property=&quot;sal&quot; column=&quot;sal&quot;&gt;&lt;/result&gt;\n                &lt;result property=&quot;hiredate&quot; column=&quot;hiredate&quot;&gt;&lt;/result&gt;\n                &lt;result property=&quot;mgr&quot; column=&quot;mgr&quot;&gt;&lt;/result&gt;\n                &lt;result property=&quot;comm&quot; column=&quot;comm&quot;&gt;&lt;/result&gt;\n                &lt;result property=&quot;deptno&quot; column=&quot;deptno&quot;&gt;&lt;/result&gt;\n            &lt;/association&gt;\n        &lt;/collection&gt;\n    &lt;/resultMap&gt;\n    &lt;select id=&quot;findProjectJoinEmpsByPid&quot;  resultMap=&quot;projectJoinEmps&quot;&gt;\n        select * from\n        project p\n        left join projectrecord pr\n        on p.pid = pr.pid\n        left join emp e\n        on e.empno = pr.empno\n        where p.pid= #&#123;pid&#125;\n    &lt;/select&gt;\n&lt;/mapper&gt;\n</code></pre>\n<p>测试代码</p>\n<pre><code class=\"java\">@Test\npublic void testManyToMany() throws ParseException &#123;\n    ProjectMapper mapper = sqlSession.getMapper(ProjectMapper.class);\n    Project project = mapper.findProjectJoinEmpsByPid(2);\n    System.out.println(project.getPid());\n    System.out.println(project.getPname());\n    System.out.println(project.getMoney());\n    List&lt;ProjectRecord&gt; projectRecords = project.getProjectRecords();\n    for (ProjectRecord projectRecord : projectRecords) &#123;\n        Emp emp = projectRecord.getEmp();\n        System.out.println(emp);\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"2-级联查询\"><a href=\"#2-级联查询\" class=\"headerlink\" title=\"2 级联查询\"></a>2 级联查询</h2><p>级联查询，顾名思义，就是利于数据库表间的外键关联关系进行自动的级联查询操作。使用MyBatis实现级联查询，除了实体类增加关联属性外，还需要在映射文件中进行配置。</p>\n<h3 id=\"1-立即加载\"><a href=\"#1-立即加载\" class=\"headerlink\" title=\"1 立即加载\"></a>1 立即加载</h3><h3 id=\"2-延迟加载\"><a href=\"#2-延迟加载\" class=\"headerlink\" title=\"2 延迟加载\"></a>2 延迟加载</h3><p><strong>延迟加载，又称按需加载</strong>。延迟加载的内容等到真正使用时才去进行加载（查询）。多用在关联对象或集合中。</p>\n<p>延迟加载的好处：先从单表查询、需要时再从关联表去关联查询，大大降低数据库在单位时间内的查询工作量,将工作在时间上的分配更加均匀，而且单表要比关联查询多张表速度要快。</p>\n<p>延迟加载的设置</p>\n<p>第一步：全局开关：在sqlMapConfig.xml中打开延迟加载的开关。配置完成后所有的association和collection元素都生效</p>\n<pre><code class=\"xml\">  &lt;settings&gt;\n      &lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot;/&gt;\n      &lt;setting name=&quot;aggressiveLazyLoading&quot; value=&quot;true&quot;/&gt;\n  &lt;/settings&gt;\n</code></pre>\n<p><font color=#008000>lazyLoadingEnabled</font>:是否开启延迟加载。是Mybatis是否启用懒加载的全局开关。当开启时，所有关联对象都会延迟加载。特定关联关系中可通过设置fetchType属性来覆盖该项的开关状态</p>\n<p><font color=#008000 >aggressiveLazyLoading</font>：当开启时，任何方法的调用都会懒加载对象的所有属性。否则，每个属性会按需加载,</p>\n<p>第二步：分开关：指定的association和collection元素中配置<font color=#0000FF>fetchType</font>属性。eager：表示立刻加载；lazy：表示延迟加载。<strong>将覆盖全局延迟设置。</strong></p>\n<h2 id=\"3-总结\"><a href=\"#3-总结\" class=\"headerlink\" title=\"3 总结\"></a>3 总结</h2><h4 id=\"resultMap中的常见属性\"><a href=\"#resultMap中的常见属性\" class=\"headerlink\" title=\"resultMap中的常见属性\"></a>resultMap中的常见属性</h4><table style=\"text-align: center;\" cellpadding=\"30\" >\n    <tr style=\"background-color:#E2EFD9 ;\">\n            <td>property</td>\n            <td>需要映射到JavaBean 的属性名称</td>\n        </tr>\n        <tr>\n            <td >javaType</td>\n            <td>property的类型，一个完整的类名，或者是一个类型别名。如果你匹配的是一个JavaBean，那MyBatis 通常会自行检测到</td>\n        </tr>\n        <tr style=\"background-color:#E2EFD9 ;\">\n            <td>column</td>\n            <td>数据表的列名或者列别名</td>\n        </tr>\n        <tr>\n            <td>jdbcType</td>\n            <td>column在数据库表中的类型。这个属性只在insert,update   或delete 的时候针对允许空的列有用。JDBC 需要这项，但MyBatis 不需要</td>\n        </tr>\n        <tr style=\"background-color:#E2EFD9 ;\">\n            <td>typeHandler</td>\n            <td>使用这个属性可以覆写类型处理器，实现javaType、jdbcType之间的相互转换。一般可以省略，会探测到使用的什么类型的typeHandler进行处理</td>\n        </tr>\n        <tr>\n            <td>fetchType</td>\n            <td>自动延迟加载</td>\n        </tr>\n        <tr style=\"background-color:#E2EFD9 ;\">\n            <td>select</td>\n            <td>association、collection的属性，使用哪个查询查询属性的值，要求指定namespace+id的全名称</td>\n        </tr>\n        <tr>\n            <td>ofType</td>\n            <td>collection的属性，指明集合中元素的类型（即泛型类型）</td>\n        </tr>\n    </table>\n\n\n\n\n<h4 id=\"级联查询和多表查询的比较及其选择\"><a href=\"#级联查询和多表查询的比较及其选择\" class=\"headerlink\" title=\"级联查询和多表查询的比较及其选择\"></a>级联查询和多表查询的比较及其选择</h4><table style=\"text-align: center;\" cellpadding=\"30\" >\n    <tr style=\"background-color:#E2EFD9 ;\">\n            <td>SQL语句数量</td>\n        <td>多条</td>\n        <td>一条</td>\n    </tr>\n    <tr>\n        <td >性能</td>\n        <td>性能低</td>\n        <td>性能高</td>\n    </tr>\n    <tr style=\"background-color:#E2EFD9 ;\">\n        <td>延迟加载</td>\n        <td>立即加载、延迟加载</td>\n        <td>只有立即加载</td>\n    </tr>\n    <tr>\n        <td>灵活性</td>\n        <td>更灵活</td>\n        <td>不灵活</td>\n    </tr>\n    <tr style=\"background-color:#E2EFD9 ;\">\n        <td>SQL难易度</td>\n        <td>简单</td>\n        <td>复杂</td>\n    </tr>\n    <tr>\n        <td>选择依据</td>\n        <td>简单、灵活</td>\n        <td>高性能</td>\n    </tr>\n</table>\n\n\n\n\n<p><strong>ResultType和ResultMap使用场景</strong></p>\n<ol>\n<li><pre><code>如果你做的是单表的查询并且封装的实体和数据库的字段一一对应   resultType\n</code></pre>\n</li>\n<li><pre><code>如果实体封装的属性和数据库的字段不一致  resultMap\n</code></pre>\n</li>\n<li><pre><code> 使用N+1级联查询的时候  resultMap\n</code></pre>\n</li>\n<li><pre><code>使用的是多表的连接查询  resultMap\n</code></pre>\n</li>\n</ol>\n<p><strong>一对一关联映射的实现</strong></p>\n<ol>\n<li><pre><code>实例：学生和学生证、雇员和工牌\n</code></pre>\n</li>\n<li><pre><code>数据库层次：主键关联或者外键关联（参看之前内容）\n</code></pre>\n</li>\n<li><pre><code> MyBatis层次：在映射文件的设置双方均使用association即可，用法相同\n</code></pre>\n</li>\n</ol>\n<p><strong>多对多映射的实现</strong></p>\n<ol>\n<li><pre><code>实例：学生和课程、用户和角色\n</code></pre>\n</li>\n<li><pre><code> 数据库层次：引入一个中间表将一个多对多转为两个一对多\n</code></pre>\n</li>\n<li><pre><code> MyBatis层次\n</code></pre>\n</li>\n</ol>\n<p>方法1：在映射文件的设置双方均使用collection即可，不用引入中间类</p>\n<p>方法2：引入中间类和中间类的映射文件，按照两个一对多处理</p>\n<p><strong>自关联映射</strong></p>\n<ol>\n<li><pre><code>实例：Emp表中的员工和上级。一般是一对多关联\n</code></pre>\n</li>\n<li><pre><code>数据库层次：外键参考当前表的主键（比如mgr参考empno）\n</code></pre>\n</li>\n<li><p>MyBatis层次：按照一对多处理，但是增加的属性都写到一个实体类中，增加的映射也都写到一个映射文件中</p>\n</li>\n</ol>\n<h1 id=\"9-MyBatis注解开发\"><a href=\"#9-MyBatis注解开发\" class=\"headerlink\" title=\"9 MyBatis注解开发\"></a>9 MyBatis注解开发</h1><pre><code class=\"java\">public interface DeptMapper &#123;\n    Dept findDeptByDeptno(int deptno);\n    @Select(&quot;select * from dept where deptno =#&#123;deptno&#125;&quot;)\n    Dept findByDeptno(int deptno);\n    int updateDept(Dept dept);\n    int addDept(Dept dept);\n    @Delete(&quot;delete from dept where deptno =#&#123;deptno&#125;&quot;)\n    int removeDept(int deptno);\n&#125;\n</code></pre>\n<p>1.使用注解没有实现Java代码和SQL语句的解耦</p>\n<p>2.无法实现SQL语句的动态拼接</p>\n<p>3.进行多表的查询时定制ResultMap比较麻烦</p>\n<p><strong>注解和XML的优缺点</strong></p>\n<table style=\"text-align: center;\" cellpadding=\"30\" >\n    <tr style=\"background-color:#E2EFD9 ;\">\n            <td>优点</td>\n        <td>类和类之间的解耦</td>\n        <td>简化配置</td>\n    </tr>\n    <tr>\n        <td > </td>\n        <td>利于修改。直接修改XML文件，无需到源代码中修改。</td>\n        <td>使用起来直观且容易，提升开发效率</td>\n    </tr>\n    <tr style=\"background-color:#E2EFD9 ;\">\n        <td></td>\n        <td>配置集中在XML中，对象间关系一目了然，利于快速了解项目和维护</td>\n        <td>类型安全，编译器进行校验，不用等到运行期才会发现错误</td>\n    </tr>\n    <tr>\n        <td></td>\n        <td>容易和其他系统进行数据交交换</td>\n        <td>注解的解析可以不依赖于第三方库，可以直接使用Java自带的反射</td>\n    </tr>\n</table>\n\n\n\n\n\n\n<h1 id=\"10-缓存\"><a href=\"#10-缓存\" class=\"headerlink\" title=\"10 缓存\"></a>10 缓存</h1><img data-src=\"/2022/10/07/ORM/Mybatis/image-20220617211853352.png\" class=\"\" title=\"image-20220617211853352\">\n\n<blockquote>\n<p>​\t是一种临时存储少量数据至内存或者是磁盘的一种技术.减少数据的加载次数,可以降低工作量,提高程序响应速度</p>\n<p>​\t缓存的重要性是不言而喻的。mybatis的缓存将相同查询条件的SQL语句执行一遍后所得到的结果存在内存或者某种缓存介质当中，当下次遇到一模一样的查询SQL时候不在执行SQL与数据库交互，而是直接从缓存中获取结果，减少服务器的压力；尤其是在查询越多、缓存命中率越高的情况下，使用缓存对性能的提高更明显。</p>\n<p>​\tMyBatis允许使用缓存，缓存一般放置在高速读&#x2F;写的存储器上，比如服务器的内存，能够有效的提供系统性能。MyBatis分为<font color=#FF0000>一级缓存和二级缓存</font>，同时也可配置关于缓存设置。</p>\n<p>​\t一级存储是SqlSession上的缓存，二级缓存是在SqlSessionFactory(namespace)上的缓存。默认情况下，MyBatis开启一级缓存，没有开启二级缓存。当数据量大的时候可以借助一些第三方缓存框架或Redis缓存来协助保存Mybatis的二级缓存数据。</p>\n</blockquote>\n<img data-src=\"/2022/10/07/ORM/Mybatis/image-20220617211938471.png\" class=\"\" title=\"image-20220617211938471\">\n\n\n\n<h2 id=\"1-一级缓存\"><a href=\"#1-一级缓存\" class=\"headerlink\" title=\"1 一级缓存\"></a>1 一级缓存</h2><p>一级存储是SqlSession上的缓存，默认开启，是一种内存型缓存,不要求实体类对象实现Serializable接口。</p>\n<p>缓存中的数据使用键值对形式存储数据</p>\n<p>&#x3D;&#x3D;namespace + sqlid + args + offset     &gt;&gt;&gt;   hash 值作为键,查询出的结果作为值&#x3D;&#x3D;</p>\n<img data-src=\"/2022/10/07/ORM/Mybatis/image-20220617212008075.png\" class=\"\" title=\"image-20220617212008075\">\n\n<p>测试 代码</p>\n<pre><code class=\"java\">@Test\npublic void testFindDeptByDetpno()   &#123;\n    EmpMapper mapper = sqlSession.getMapper(EmpMapper.class);\n    Emp emp = mapper.findByEmpno(7521);\n    System.out.println(emp);\n    // 中间发生了增删改或者是调用了SqlSession调用了commit,会自动清空缓存\n    sqlSession.commit();// 增删改的时候调用\n    EmpMapper mapper2 = sqlSession.getMapper(EmpMapper.class);\n    Emp emp2 = mapper2.findByEmpno(7521);\n    System.out.println(emp2); \n    \n    System.out.println(emp==emp2);// 没有commit之前为True\n    System.out.println(mapper==mapper2);// false 表示确实产生了两个代理对象\n&#125;\n</code></pre>\n<h2 id=\"2-二级缓存\"><a href=\"#2-二级缓存\" class=\"headerlink\" title=\"2 二级缓存\"></a>2 二级缓存</h2><p>二级缓存是以namespace为标记的缓存，可以是由一个SqlSessionFactory创建的SqlSession之间共享缓存数据。默认并不开启。下面的代码中创建了两个SqlSession，执行相同的SQL语句，尝试让第二个SqlSession使用第一个SqlSession查询后缓存的数据。要求实体类必须实现序列化接口</p>\n<img data-src=\"/2022/10/07/ORM/Mybatis/image-20220617212052512.png\" class=\"\" title=\"image-20220617212052512\">\n\n\n\n<p>接口</p>\n<pre><code class=\"java\">public interface EmpMapper &#123;\n    Emp findByEmpno(int empno);\n&#125;\n</code></pre>\n<p>映射文件</p>\n<pre><code class=\"xml\">&lt;mapper namespace=&quot;com.msb.mapper.EmpMapper&quot;&gt;\n    &lt;cache/&gt;\n    &lt;select id=&quot;findByEmpno&quot; resultType=&quot;emp&quot; useCache=&quot;true&quot; flushCache=&quot;false&quot;&gt;\n        select * from emp where empno =#&#123;empno&#125;\n    &lt;/select&gt;\n&lt;/mapper&gt;\n</code></pre>\n<p>测试 代码</p>\n<pre><code class=\"java\">package com.msb.test;\nimport com.msb.mapper.EmpMapper;\nimport com.msb.pojo.Emp;\nimport org.apache.ibatis.io.Resources;\nimport org.apache.ibatis.session.SqlSession;\nimport org.apache.ibatis.session.SqlSessionFactory;\nimport org.apache.ibatis.session.SqlSessionFactoryBuilder;\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Test;\nimport java.io.IOException;\nimport java.io.InputStream;\n/**\n * @Author: Ma HaiYang\n * @Description: MircoMessage:Mark_7001\n */\npublic class Test3 &#123;\n    private SqlSession sqlSession;\n    private SqlSession sqlSession2;\n    @Before\n    public void init()&#123;\n        SqlSessionFactoryBuilder ssfb =new SqlSessionFactoryBuilder();\n        InputStream resourceAsStream = null;\n        try &#123;\n            resourceAsStream = Resources.getResourceAsStream(&quot;sqlMapConfig.xml&quot;);\n        &#125; catch (IOException e) &#123;\n            e.printStackTrace();\n        &#125;\n        SqlSessionFactory factory=ssfb.build(resourceAsStream) ;\n        sqlSession=factory.openSession();\n        sqlSession2=factory.openSession();\n    &#125;\n    @Test\n    public void testFindDeptByDetpno()   &#123;\n        EmpMapper mapper = sqlSession.getMapper(EmpMapper.class);\n        Emp emp = mapper.findByEmpno(7521);\n        System.out.println(emp);\n        // SqlSession提交之后,才会将查询的结果放入二级缓存\n        sqlSession.commit();\n        EmpMapper mapper2 = sqlSession2.getMapper(EmpMapper.class);\n        Emp emp2 = mapper2.findByEmpno(7521);\n        System.out.println(emp2);\n    &#125;\n    @After\n    public void release()&#123;\n        // 关闭SQLSession\n        sqlSession.close();\n        sqlSession2.close();\n    &#125;\n&#125;\n</code></pre>\n<p><strong>注意：</strong></p>\n<p>​\t其中的commit()，执行该命令后才会将该SqlSession的查询结果从一级缓存中放入二级缓存，供其他SqlSession使用。另外执行SqlSession的close()也会将该SqlSession的查询结果从一级缓存中放入二级缓存。两种方式区别在当前SqlSession是否关闭了。</p>\n<p>执行结果显示进行了两次对数据库的SQL查询，说明二级缓存并没有开启。需要进行如下步骤完成开启。</p>\n<ol>\n<li>全局开关：在sqlMapConfig.xml文件中的<font color=blue><settings></font>标签配置开启二级缓存</li>\n</ol>\n<pre><code class=\"xml\">&lt;settings&gt;\n    &lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt;\n&lt;/settings&gt;\n</code></pre>\n<p>cacheEnabled的默认值就是true，所以这步的设置可以省略。</p>\n<ol start=\"2\">\n<li>分开关：在要开启二级缓存的mapper文件中开启缓存：</li>\n</ol>\n<pre><code class=\"xml\">&lt;mapper namespace=&quot;com.msb.mapper.EmployeeMapper&quot;&gt;\n    &lt;cache/&gt;\n&lt;/mapper&gt;\n</code></pre>\n<ol start=\"3\">\n<li>二级缓存未必完全使用内存,有可能占用硬盘存储,缓存中存储的JavaBean对象必须实现序列化接口,</li>\n</ol>\n<pre><code class=\"java\">public class Emp implements  Serializable &#123;  &#125;\n</code></pre>\n<p>经过设置后，查询结果如图所示。发现第一个SqlSession会首先去二级缓存中查找，如果不存在，就查询数据库，<font color=#FF0000>在commit()或者close()的时候将数据放入到二级缓存</font>。第二个SqlSession执行相同SQL语句查询时就直接从二级缓存中获取了。</p>\n<p><strong>注意：</strong></p>\n<p>​\t1)    MyBatis的二级缓存的缓存介质有多种多样，而并不一定是在内存中，所以需要对JavaBean对象实现序列化接口。</p>\n<ol start=\"2\">\n<li>二级缓存是以 namespace 为单位的，不同 namespace 下的操作互不影响</li>\n</ol>\n<p>​\t3)    加入Cache元素后，会对相应命名空间所有的select元素查询结果进行缓存，而其中的insert、update、delete在操作是会清空整个namespace的缓存。</p>\n<p>​\t4)    cache 有一些可选的属性 type, eviction, flushInterval, size, readOnly, blocking。</p>\n<pre><code class=\"xml\">&lt;cache type=&quot;&quot; readOnly=&quot;&quot; eviction=&quot;&quot;flushInterval=&quot;&quot;size=&quot;&quot;blocking=&quot;&quot;/&gt;\n</code></pre>\n<p>&lt;cache type&#x3D;”” readOnly&#x3D;”” eviction&#x3D;””flushInterval&#x3D;””size&#x3D;””blocking&#x3D;””&#x2F;&gt;</p>\n<table style=\"text-align: center;\" cellpadding=\"30\" >\n    <style>\n        td {\n            text-align:center;\n        }\n        p {\n          text-align:center;\n        }\n    </style>\n    <tr style=\"background-color:#E2EFD9 ;\">\n            <td>type</td>\n         <td><p>自定义缓存类，要求实现org.apache.ibatis.cache.Cache接口</p></td>\n            <td>null</td>\n        </tr>\n        <tr>\n            <td>readOnly</td>\n            <td ><p>是否只读</p>\n                <p> true:给所有调用者返回缓存对象的相同实例。因此这些对象不能被修改。 </p>\n                <span> 这提供了很重要的性能优势。</span>\n                <p>false:会返回缓存对象的拷贝(通过序列化)。</p>\n                <p> 这会慢一些,但是安全</p>\n            </td>\n            <td>false</td>\n        </tr>\n        <tr style=\"background-color:#E2EFD9 ;\">\n            <td>eviction</td>\n            <td>\t \n                <p>缓存策略<br>LRU（默认） – 最近最少使用：移除最长时间不被使用的对象。</p>\n                <p>FIFO – 先进先出：按对象进入缓存的顺序来移除它们。</p>\n                <p>SOFT – 软引用：基于垃圾回收器状态和软引用规则移除对象。</p>\n                <p>WEAK – 弱引用：更积极地基于垃圾收集器状态和弱引用规则移除对象。</p>\n            </td>\n            <td>LRU</td>\n        </tr>\n        <tr>\n            <td>flushInterval</td>\n            <td><p>\n                    刷新间隔，毫秒为单位。默认为null，也就是没有刷新间隔，\n                </p>\n                <p>\n                    只有执行update、insert、delete语句才会刷新\n                </p>\n            </td>\n            <td>null</td>\n        </tr>\n        <tr style=\"background-color:#E2EFD9 ;\">\n             <td>size</td>\n            <td><p>缓存对象个数<p></td>\n            <td>1024</td>\n        </tr>\n        <tr>\n            <td>blocking</td>\n            <td>\n                <p>是否使用阻塞性缓存BlockingCache</p>\n                <p>true：在查询缓存时锁住对应的Key，如果缓存命中了则会释放对应的锁，</p>\n                <span>否则会在查询数据库以后再释放锁，</span>\n                <p>保证只有一个线程到数据库中查找指定key对应的数据</p>\n                <p>false：不使用阻塞性缓存，性能更好</p>\n            </td>\n            <td>false</td>\n        </tr>\n</table>\n\n\n\n\n\n<ol start=\"5\">\n<li>如果在加入Cache元素的前提下让个别select 元素不使用缓存，可以使用useCache属性，设置为false。useCache控制当前sql语句是否启用缓存  flushCache控制当前sql执行一次后是否刷新缓存</li>\n</ol>\n<pre><code class=\"xml\">&lt;select id=&quot;findByEmpno&quot; resultType=&quot;emp&quot; useCache=&quot;true&quot; flushCache=&quot;false&quot;&gt;\n</code></pre>\n<h2 id=\"3-三方缓存\"><a href=\"#3-三方缓存\" class=\"headerlink\" title=\"3 三方缓存\"></a>3 三方缓存</h2><blockquote>\n<p>分布式缓存框架：我们系统为了提高系统并发和性能，一般对系统进行分布式部署（集群部署方式）不适用分布缓存， 缓存的数据在各个服务单独存储，不方便系统开发。所以要使用分布式缓存对缓存数据进行集中管理.ehcache,redis ,memcache缓存框架。</p>\n</blockquote>\n<p>Ehcache：是一种广泛使用的开源java分布式缓存。主要面向通用缓存，javaEE 和 轻量级容器。它具有内存和磁盘存储功能。被用于大型复杂分布式web application的</p>\n<p>这里的三方缓存是作为二级缓存使用的</p>\n<p>导入依赖的jar文件</p>\n<pre><code class=\"xml\"> &lt;dependency&gt;\n    &lt;groupId&gt;org.mybatis.caches&lt;/groupId&gt;\n    &lt;artifactId&gt;mybatis-ehcache&lt;/artifactId&gt;\n    &lt;version&gt;1.0.2&lt;/version&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;net.sf.ehcache&lt;/groupId&gt;\n    &lt;artifactId&gt;ehcache&lt;/artifactId&gt;\n    &lt;version&gt;2.10.1&lt;/version&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.slf4j&lt;/groupId&gt;\n    &lt;artifactId&gt;slf4j-nop&lt;/artifactId&gt;\n    &lt;version&gt;1.7.2&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>\n<p>去各自的sql映射文件里,开启二级缓存,并把缓存类型指定为EhcacheCache</p>\n<pre><code class=\"xml\"> &lt;cache type=&quot;org.mybatis.caches.ehcache.EhcacheCache&quot;/&gt;\n</code></pre>\n<p>在资源目录下放置一个缓存配置文件,文件名为: ehcache.xml 内容如下</p>\n<pre><code class=\"xml\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;ehcache xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n         xsi:noNamespaceSchemaLocation=&quot;ehcache.xsd&quot;\n         updateCheck=&quot;true&quot; monitoring=&quot;autodetect&quot;\n         dynamicConfig=&quot;true&quot;&gt;\n    &lt;diskStore path=&quot;D:\\msb\\ehcache&quot; /&gt;\n    &lt;defaultCache\n            maxElementsInMemory=&quot;1000&quot;\n            maxElementsOnDisk=&quot;10000000&quot;\n            eternal=&quot;false&quot;\n            overflowToDisk=&quot;true&quot;\n            timeToIdleSeconds=&quot;120&quot;\n            timeToLiveSeconds=&quot;120&quot;\n            diskExpiryThreadIntervalSeconds=&quot;120&quot;\n            memoryStoreEvictionPolicy=&quot;LRU&quot;&gt;\n    &lt;/defaultCache&gt;\n&lt;/ehcache&gt;\n        &lt;!--  Cache配置\n        ·           name：Cache的唯一标识\n        ·           maxElementsInMemory：内存中最大缓存对象数。\n        ·           maxElementsOnDisk：磁盘中最大缓存对象数，若是0表示无穷大。\n        ·           eternal：Element是否永久有效，一但设置了，timeout将不起作用。\n        ·           overflowToDisk：配置此属性，当内存中Element数量达到maxElementsInMemory时，Ehcache将会Element写到磁盘中。\n        ·           timeToIdleSeconds：设置Element在失效前的允许闲置时间。仅当element不是永久有效时使用，可选属性，默认值是0，也就是可闲置时间无穷大。\n        ·           timeToLiveSeconds：设置Element在失效前允许存活时间。最大时间介于创建时间和失效时间之间。仅当element不是永久有效时使用，默认是0.，也就是element存活时间无穷大。\n        ·           diskExpiryThreadIntervalSeconds：磁盘失效线程运行时间间隔，默认是120秒。\n        ·           diskSpoolBufferSizeMB：这个参数设置DiskStore（磁盘缓存）的缓存区大小。默认是30MB。每个Cache都应该有自己的一个缓冲区。\n        ·           memoryStoreEvictionPolicy：当达到maxElementsInMemory限制时，Ehcache将会根据指定的策略去清理内存。默认策略是LRU（最近最少使用）。你可以设置为FIFO（先进先出）或是LFU（较少使用）。     --&gt;\n</code></pre>\n<h1 id=\"11-逆向工程\"><a href=\"#11-逆向工程\" class=\"headerlink\" title=\"11 逆向工程\"></a>11 逆向工程</h1><blockquote>\n<p>MyBatisPlus 内容，简略分析，可以参考后面具体内容</p>\n</blockquote>\n<p>MyBatis的一个主要的特点就是需要程序员自己编写SQL，那么如果表太多的话，难免会很麻烦，所以MyBatis官方提供了一个逆向工程，可以针对单表自动生成MyBatis执行所需要的代码（包括mapper.xml，mapper.java，pojo）。一般在开发中，常用的逆向工程方式是通过数据库的表生成代码。</p>\n<p>创建maven项目导入逆向工程依赖</p>\n<img data-src=\"/2022/10/07/ORM/Mybatis/image-20220617221042957.png\" class=\"\" title=\"image-20220617221042957\">\n\n<pre><code class=\"xml\">&lt;dependencies&gt;\n  \n    &lt;!-- mysql驱动包 --&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;mysql&lt;/groupId&gt;\n        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;\n        &lt;version&gt;8.0.16&lt;/version&gt;\n    &lt;/dependency&gt;\n    &lt;!-- 日志包，方便查看执行信息--&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.slf4j&lt;/groupId&gt;\n        &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;\n        &lt;version&gt;1.6.1&lt;/version&gt;\n    &lt;/dependency&gt;\n    &lt;!-- 代码生成工具jar --&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt;\n        &lt;artifactId&gt;mybatis-generator-core&lt;/artifactId&gt;\n        &lt;version&gt;1.3.2&lt;/version&gt;\n    &lt;/dependency&gt;\n&lt;/dependencies&gt;\n</code></pre>\n<p>配置逆向工程配置文件 在resources目录下放置一个名为generatorConfig.xml的配置文件,文件内容如下</p>\n<pre><code class=\"xml\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;!DOCTYPE generatorConfiguration\n  PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;\n  &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt;\n&lt;generatorConfiguration&gt;\n   &lt;context id=&quot;testTables&quot; targetRuntime=&quot;MyBatis3&quot;&gt;\n      &lt;commentGenerator&gt;\n         &lt;!-- 是否去除自动生成的注释 true：是 ： false:否 --&gt;\n         &lt;property name=&quot;suppressAllComments&quot; value=&quot;true&quot; /&gt;\n      &lt;/commentGenerator&gt;\n      &lt;!--数据库连接的信息：驱动类、连接地址、用户名、密码 --&gt;\n      &lt;!-- &lt;jdbcConnection driverClass=&quot;com.mysql.jdbc.Driver&quot;\n         connectionURL=&quot;jdbc:mysql://localhost:3306/mybatis&quot; userId=&quot;root&quot;\n         password=&quot;123&quot;&gt;\n      &lt;/jdbcConnection&gt; --&gt;\n       &lt;jdbcConnection driverClass=&quot;com.mysql.cj.jdbc.Driver&quot;\n         connectionURL=&quot;jdbc:mysql://127.0.0.1:3306/mydb?useSSL=false&amp;amp;useUnicode=true&amp;amp;characterEncoding=UTF-8&amp;amp;serverTimezone=Asia/Shanghai&amp;amp;allowPublicKeyRetrieval=true&quot;\n         userId=&quot;root&quot;\n         password=&quot;root&quot;&gt;\n      &lt;/jdbcConnection&gt; \n      &lt;!-- 默认false，把JDBC DECIMAL 和 NUMERIC 类型解析为 Integer，为 true时把JDBC DECIMAL 和 \n         NUMERIC 类型解析为java.math.BigDecimal --&gt;\n      &lt;javaTypeResolver&gt;\n         &lt;property name=&quot;forceBigDecimals&quot; value=&quot;false&quot; /&gt;\n      &lt;/javaTypeResolver&gt;\n      &lt;!-- targetProject:生成PO类的位置 --&gt;\n      &lt;javaModelGenerator targetPackage=&quot;com.msb.pojo&quot;\n         targetProject=&quot;.\\src&quot;&gt;\n         &lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt;\n         &lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot; /&gt;\n         &lt;!-- 从数据库返回的值被清理前后的空格 --&gt;\n         &lt;property name=&quot;trimStrings&quot; value=&quot;true&quot; /&gt;\n      &lt;/javaModelGenerator&gt;\n        &lt;!-- targetProject:mapper映射文件生成的位置 --&gt;\n      &lt;sqlMapGenerator targetPackage=&quot;com.msb.mapper&quot;\n         targetProject=&quot;.\\src&quot;&gt;\n         &lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt;\n         &lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot; /&gt;\n      &lt;/sqlMapGenerator&gt;\n      &lt;!-- targetPackage：mapper接口生成的位置 --&gt;\n      &lt;javaClientGenerator type=&quot;XMLMAPPER&quot;\n         targetPackage=&quot;com.msb.mapper&quot;\n         targetProject=&quot;.\\src&quot;&gt;\n         &lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt;\n         &lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot; /&gt;\n      &lt;/javaClientGenerator&gt;\n      &lt;!-- 指定数据库表 --&gt;\n      \n      &lt;table tableName=&quot;dept&quot; domainObjectName=&quot;Dept&quot;\n       enableCountByExample=&quot;false&quot; enableUpdateByExample=&quot;false&quot; enableDeleteByExample=&quot;false&quot;    \n               enableSelectByExample=&quot;false&quot; selectByExampleQueryId=&quot;false&quot; &gt;\n               &lt;columnOverride column=&quot;id&quot; javaType=&quot;Integer&quot; /&gt;\n         &lt;/table&gt;\n      \n   &lt;/context&gt;\n&lt;/generatorConfiguration&gt;\n</code></pre>\n<p>在resources目录下放置一个名为log4j.properties的配置文件,文件内容如下</p>\n<pre><code class=\"properties\">log4j.rootLogger=debug,stdout\nlog4j.appender.stdout=org.apache.log4j.ConsoleAppender\nlog4j.appender.stdout.Target=System.err\nlog4j.appender.stdout.layout=org.apache.log4j.SimpleLayout\nlog4j.appender.logfile=org.apache.log4j.FileAppender\nlog4j.appender.logfile.File=d:/msb.log\nlog4j.appender.logfile.layout=org.apache.log4j.PatternLayout\nlog4j.appender.logfile.layout.ConversionPattern=%d&#123;yyyy-MM-dd HH:mm:ss&#125; %l %F %p %m%n\n</code></pre>\n<p>运行逆向工程代码</p>\n<pre><code class=\"java\">package com.msb.gennerator;\nimport org.mybatis.generator.api.MyBatisGenerator;\nimport org.mybatis.generator.config.Configuration;\nimport org.mybatis.generator.config.xml.ConfigurationParser;\nimport org.mybatis.generator.internal.DefaultShellCallback;\nimport java.io.File;\nimport java.util.ArrayList;\nimport java.util.List;\n/**\n *\n */\npublic class GeneratorSqlmap &#123;\n    public void generator() throws Exception&#123;\n        List&lt;String&gt; warnings = new ArrayList&lt;String&gt;();\n        boolean overwrite = true;\n        File configFile = new File(&quot;D:\\\\ideaProjects\\\\reverse\\\\target\\\\classes\\\\generatorConfig.xml&quot;);\n        ConfigurationParser cp = new ConfigurationParser(warnings);\n        Configuration config = cp.parseConfiguration(configFile);\n        DefaultShellCallback callback = new DefaultShellCallback(overwrite);\n        MyBatisGenerator myBatisGenerator = new MyBatisGenerator(config,\n                callback, warnings);\n        myBatisGenerator.generate(null);\n    &#125;\n    public static void main(String[] args) throws Exception &#123;\n        try &#123;\n            GeneratorSqlmap generatorSqlmap = new GeneratorSqlmap();\n            generatorSqlmap.generator();\n        &#125; catch (Exception e) &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>生成的实体类和Mapper接口和Mapper映射文件,包含了基本的CURD功能,哪里需要文件就放哪里</p>\n<img data-src=\"/2022/10/07/ORM/Mybatis/image-20220617221208040-1665157666426.png\" class=\"\" title=\"image-20220617221208040\">\n\n<h1 id=\"12-main目录下配置文件打包问题\"><a href=\"#12-main目录下配置文件打包问题\" class=\"headerlink\" title=\"12 main目录下配置文件打包问题\"></a>12 main目录下配置文件打包问题</h1><pre><code class=\"xml\">&lt;build&gt;\n    &lt;!--告诉maven将项目源码中的xml文件也进行编译，并放到编译目录中--&gt;\n    &lt;resources&gt;\n        &lt;resource&gt;\n            &lt;directory&gt;src/main/java&lt;/directory&gt;\n            &lt;includes&gt;\n                &lt;include&gt;**/*.xml&lt;/include&gt;\n            &lt;/includes&gt;\n            &lt;filtering&gt;true&lt;/filtering&gt;\n        &lt;/resource&gt;\n        &lt;resource&gt;\n            &lt;directory&gt;src/main/resources&lt;/directory&gt;\n            &lt;filtering&gt;true&lt;/filtering&gt;\n        &lt;/resource&gt;\n    &lt;/resources&gt;\n&lt;/build&gt;\n</code></pre>\n",
            "tags": [
                "框架",
                "ORM"
            ]
        }
    ]
}