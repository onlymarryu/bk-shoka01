{
    "version": "https://jsonfeed.org/version/1",
    "title": "记录“美食”每刻 • All posts by \"中间件\" tag",
    "description": "记录“美食”每刻",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/2022/10/07/RabbitMQ/",
            "url": "http://example.com/2022/10/07/RabbitMQ/",
            "title": "RabbitMQ",
            "date_published": "2022-10-06T16:00:00.000Z",
            "content_html": "<h2 id=\"主要内容\"><a href=\"#主要内容\" class=\"headerlink\" title=\"主要内容\"></a><strong>主要内容</strong></h2><ol>\n<li><p>AMQP简介</p>\n</li>\n<li><p>RabbitMQ简介</p>\n</li>\n<li><p>RabbitMQ原理</p>\n</li>\n<li><p>Erlang安装</p>\n</li>\n<li><p>安装RabbitMQ</p>\n</li>\n<li><p>RabbitMQ账户管理</p>\n</li>\n<li><p>交换器</p>\n</li>\n</ol>\n<h2 id=\"学习目标\"><a href=\"#学习目标\" class=\"headerlink\" title=\"学习目标\"></a><strong>学习目标</strong></h2><table>\n<thead>\n<tr>\n<th>知识点</th>\n<th>要求</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>AMQP简介</td>\n<td>掌握</td>\n</tr>\n<tr>\n<td>RabbmitMQ简介</td>\n<td>掌握</td>\n</tr>\n<tr>\n<td>RabbitMQ原理</td>\n<td>掌握</td>\n</tr>\n<tr>\n<td>Erlang安装</td>\n<td>掌握</td>\n</tr>\n<tr>\n<td>安装RabbitMQ</td>\n<td>掌握</td>\n</tr>\n<tr>\n<td>RabbitMQ账户管理</td>\n<td>掌握</td>\n</tr>\n<tr>\n<td>交换器</td>\n<td>掌握</td>\n</tr>\n</tbody></table>\n<h3 id=\"一、-AMQP简介\"><a href=\"#一、-AMQP简介\" class=\"headerlink\" title=\"一、 AMQP简介\"></a>一、 <strong>AMQP简介</strong></h3><h4 id=\"1-AMQP是什么\"><a href=\"#1-AMQP是什么\" class=\"headerlink\" title=\"1 AMQP是什么?\"></a>1 <strong>AMQP是什么?</strong></h4><p>​\tAMQP(Advanced Message Queuing Protocol,高级消息队列协议)是进程之间传递异步消息的网络协议。</p>\n<h3 id=\"2-AMQP工作过程\"><a href=\"#2-AMQP工作过程\" class=\"headerlink\" title=\"2 AMQP工作过程\"></a>2 <strong>AMQP工作过程</strong></h3><p>​\t发布者(Publisher)发布消息(Message),经过交换机(Exchange)，交换机根据路由规则将收到消息分发给交换机绑定的队列(Queue)，最后AMQP代理会将消息投递给订阅了此队列的消费者，或者消费者按照需求自行获取。</p>\n<img data-src=\"/2022/10/07/RabbitMQ/RabbitMQ-01.jpg\" class=\"\">\n\n\n<h3 id=\"3-队列\"><a href=\"#3-队列\" class=\"headerlink\" title=\"3 队列\"></a>3 <strong>队列</strong></h3><p>​\t队列是数据结构中概念。数据存储在一个队列中，数据是有顺序的，先进的先出，后进后出。其中一侧负责进数据，另一侧负责出数据。</p>\n<p>MQ（消息队列）很多功能都是基于此队列结构实现的!</p>\n<h3 id=\"二、-RabbitMQ简介\"><a href=\"#二、-RabbitMQ简介\" class=\"headerlink\" title=\"二、 RabbitMQ简介\"></a>二、 <strong>RabbitMQ简介</strong></h3><h4 id=\"1-RabbitMQ介绍\"><a href=\"#1-RabbitMQ介绍\" class=\"headerlink\" title=\"1 RabbitMQ介绍\"></a>1 <strong>RabbitMQ介绍</strong></h4><p>​\tRabbitMQ是由Erlang语言编写的基于AMQP的消息中间件。而消息中间件作为分布式系统重要组件之一，可以解决应用耦合，异步消息，流量削峰等问题。</p>\n<h5 id=\"1-1-解决应用耦合\"><a href=\"#1-1-解决应用耦合\" class=\"headerlink\" title=\"1.1 解决应用耦合\"></a>1.1 <strong>解决应用耦合</strong></h5><h6 id=\"1-1-1-不使用MQ时\"><a href=\"#1-1-1-不使用MQ时\" class=\"headerlink\" title=\"1.1.1 不使用MQ时\"></a>1.1.1 <strong>不使用MQ时</strong></h6><img data-src=\"/2022/10/07/RabbitMQ/RabbitMQ-03.jpg\" class=\"\">\n\n\n<h6 id=\"1-1-2-使用MQ解决耦合\"><a href=\"#1-1-2-使用MQ解决耦合\" class=\"headerlink\" title=\"1.1.2 使用MQ解决耦合\"></a>1.1.2 <strong>使用MQ解决耦合</strong></h6><img data-src=\"/2022/10/07/RabbitMQ/RabbitMQ-04.jpg\" class=\"\">\n\n\n<h4 id=\"2-RabbitMQ适用场景\"><a href=\"#2-RabbitMQ适用场景\" class=\"headerlink\" title=\"2 RabbitMQ适用场景\"></a>2 <strong>RabbitMQ适用场景</strong></h4><p>​\t排队算法 : 使用消息队列特性</p>\n<p>​\t秒杀活动 : 使用消息队列特性</p>\n<p>​\t消息分发 : 使用消息异步特性</p>\n<p>​\t异步处理 : 使用消息异步特性</p>\n<p>​\t数据同步 : 使用消息异步特性</p>\n<p>​\t处理耗时任务 : 使用消息异步特性</p>\n<p>​\t流量销峰</p>\n<h3 id=\"三、-RabbitMQ原理\"><a href=\"#三、-RabbitMQ原理\" class=\"headerlink\" title=\"三、 RabbitMQ原理\"></a>三、 <strong>RabbitMQ原理</strong></h3><img data-src=\"/2022/10/07/RabbitMQ/RabbitMQ-05.jpg\" class=\"\">\n\n\n<table>\n<thead>\n<tr>\n<th>1.Message</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>消息。消息是不具名的，它由消息头消息体组成。消息体是不透明的，而消息头则由一系列可选属性组成，这些属性包括：routing-key(路由键)、priority(相对于其他消息的优先权)、delivery-mode(指出消息可能持久性存储)等。</td>\n</tr>\n<tr>\n<td><strong>2</strong>.<strong>Publisher</strong></td>\n</tr>\n<tr>\n<td>消息的生产者。也是一个向交换器发布消息的客户端应用程序。</td>\n</tr>\n<tr>\n<td><strong>3</strong>.<strong>Consumer</strong></td>\n</tr>\n<tr>\n<td>消息的消费者。表示一个从消息队列中取得消息的客户端应用程序。</td>\n</tr>\n<tr>\n<td><strong>4.Exchange</strong></td>\n</tr>\n<tr>\n<td>交换器。用来接收生产者发送的消息并将这些消息路由给服务器中的队列。三种常用的交换器类型1. direct(发布与订阅 完全匹配)2. fanout(广播)3. topic(主题，规则匹配)</td>\n</tr>\n<tr>\n<td><strong>5.Binding</strong></td>\n</tr>\n<tr>\n<td>绑定。用于消息队列和交换器之间的关联。一个绑定就是基于路由键将交换器和消息队列连接起来的路由规则，所以可以将交换器理解成一个由绑定构成的路由表。</td>\n</tr>\n<tr>\n<td><strong>6.Queue</strong></td>\n</tr>\n<tr>\n<td>消息队列。用来保存消息直到发送给消费者。它是消息的容器，也是消息的终点。一个消息可投入一个或多个队列。消息一直在队列里面，等待消费者链接到这个队列将其取走。</td>\n</tr>\n<tr>\n<td><strong>7.Routing-key</strong></td>\n</tr>\n<tr>\n<td>路由键。RabbitMQ决定消息该投递到哪个队列的规则。（也可以理解为队列的名称，路由键是key，队列是value）队列通过路由键绑定到交换器。消息发送到MQ服务器时，消息将拥有一个路由键，即便是空的，RabbitMQ也会将其和绑定使用的路由键进行匹配。如果相匹配，消息将会投递到该队列。如果不匹配，消息将会进入黑洞。</td>\n</tr>\n<tr>\n<td><strong>8.Connection</strong></td>\n</tr>\n<tr>\n<td>链接。指rabbit服务器和服务建立的TCP链接。</td>\n</tr>\n<tr>\n<td><strong>9.Channel</strong></td>\n</tr>\n<tr>\n<td>信道。1，Channel中文叫做信道，是TCP里面的虚拟链接。例如：电缆相当于TCP，信道是一个独立光纤束，一条TCP连接上创建多条信道是没有问题的。2，TCP一旦打开，就会创建AMQP信道。3，无论是发布消息、接收消息、订阅队列，这些动作都是通过信道完成的。</td>\n</tr>\n<tr>\n<td><strong>10.Virtual Host</strong></td>\n</tr>\n<tr>\n<td>虚拟主机。表示一批交换器，消息队列和相关对象。虚拟主机是共享相同的身份认证和加密环境的独立服务器域。每个vhost本质上就是一个mini版的RabbitMQ服务器，拥有自己的队列、交换器、绑定和权限机制。vhost是AMQP概念的基础，必须在链接时指定，RabbitMQ默认的vhost是**&#x2F;**</td>\n</tr>\n<tr>\n<td><strong>11.Borker</strong></td>\n</tr>\n<tr>\n<td>表示消息队列服务器实体。</td>\n</tr>\n<tr>\n<td><strong>12.交换器和队列的关系</strong></td>\n</tr>\n<tr>\n<td>交换器是通过路由键和队列绑定在一起的，如果消息拥有的路由键跟队列和交换器的路由键匹配，那么消息就会被路由到该绑定的队列中。     也就是说，消息到队列的过程中，消息首先会经过交换器，接下来交换器在通过路由键匹配分发消息到具体的队列中。     路由键可以理解为匹配的规则。</td>\n</tr>\n<tr>\n<td><strong>13.RabbitMQ为什么需要信道？为什么不是TCP直接通信？</strong></td>\n</tr>\n<tr>\n<td>1. TCP的创建和销毁开销特别大。创建需要3次握手，销毁需要4次分手。2. 如果不用信道，那应用程序就会以TCP链接Rabbit，高峰时每秒成千上万条链接会造成资源巨大的浪费，而且操作系统每秒处理TCP链接数也是有限制的，必定造成性能瓶颈。3. 信道的原理是一条线程一条通道，多条线程多条通道同用一条TCP链接。一条TCP链接可以容纳无限的信道，即使每秒成千上万的请求也不会成为性能的瓶颈。</td>\n</tr>\n</tbody></table>\n<h3 id=\"四、-Erlang安装\"><a href=\"#四、-Erlang安装\" class=\"headerlink\" title=\"四、 Erlang安装\"></a>四、 <strong>Erlang安装</strong></h3><p>​\tRabbitMQ是使用Erlang语言编写的，所以需要先配置Erlang</p>\n<h4 id=\"1-修改主机名\"><a href=\"#1-修改主机名\" class=\"headerlink\" title=\"1 修改主机名\"></a>1 <strong>修改主机名</strong></h4><p>​\tRabbitMQ是通过主机名进行访问的，必须指定能访问的主机名。</p>\n<pre><code>  vim /etc/sysconfig/network\n</code></pre>\n<img data-src=\"/2022/10/07/RabbitMQ/RabbitMQ-06.jpg\" class=\"\">\n\n\n<pre><code>  vim /etc/hosts\n</code></pre>\n<p>​\t新添加了一行，前面为服务器ip，空格后面添加计算机主机名</p>\n<img data-src=\"/2022/10/07/RabbitMQ/RabbitMQ-07.jpg\" class=\"\">\n\n\n<h4 id=\"2-安装依赖\"><a href=\"#2-安装依赖\" class=\"headerlink\" title=\"2 安装依赖\"></a>2 <strong>安装依赖</strong></h4><pre><code>  yum -y install make gcc gcc-c++ kernel-devel m4 ncurses-devel openssl-devel unixODBC unixODBC-devel\n</code></pre>\n<h4 id=\"3-上传并解压\"><a href=\"#3-上传并解压\" class=\"headerlink\" title=\"3 上传并解压\"></a>3 <strong>上传并解压</strong></h4><p>​\t上传otp_src_22.0.tar.gz到&#x2F;usr&#x2F;local&#x2F;tmp目录中，进入目录并解压。</p>\n<pre><code> 解压时注意，此压缩包不具有gzip属性，解压参数没有z，只有xf\n</code></pre>\n<pre><code>  cd /usr/local/tmp\n  tar xf otp_src_22.0.tar.gz -C /usr/local/tmp\n</code></pre>\n<h4 id=\"4-配置参数\"><a href=\"#4-配置参数\" class=\"headerlink\" title=\"4 配置参数\"></a>4 <strong>配置参数</strong></h4><p>​\t先新建&#x2F;usr&#x2F;local&#x2F;erlang文件夹，作为安装文件夹</p>\n<pre><code>  mkdir -p /usr/local/erlang\n</code></pre>\n<p>​\t 进入文件夹</p>\n<pre><code>  cd otp_src_22.0\n</code></pre>\n<p>​\t 配置参数</p>\n<pre><code>  ./configure --prefix=/usr/local/erlang --with-ssl --enable-threads --enable-smp-support --enable-kernel-poll --enable-hipe --without-javac\n</code></pre>\n<h4 id=\"5-编译并安装\"><a href=\"#5-编译并安装\" class=\"headerlink\" title=\"5 编译并安装\"></a>5 <strong>编译并安装</strong></h4><p>​\t编译 </p>\n<pre><code>  make\n</code></pre>\n<p>​\t 安装</p>\n<pre><code>  make install\n</code></pre>\n<h4 id=\"6-修改环境变量\"><a href=\"#6-修改环境变量\" class=\"headerlink\" title=\"6 修改环境变量\"></a>6 <strong>修改环境变量</strong></h4><p>​\t修改&#x2F;etc&#x2F;profile文件</p>\n<pre><code> vim /etc/profile\n</code></pre>\n<p>​\t 在文件中添加下面代码 </p>\n<pre><code>export PATH=$PATH:/usr/local/erlang/bin\n</code></pre>\n<p>​\t运行文件，让修改内容生效</p>\n<pre><code>  source /etc/profile\n</code></pre>\n<h4 id=\"7-查看配置是否成功\"><a href=\"#7-查看配置是否成功\" class=\"headerlink\" title=\"7 查看配置是否成功\"></a>7 <strong>查看配置是否成功</strong></h4><pre><code>  erl -version\n</code></pre>\n<img data-src=\"/2022/10/07/RabbitMQ/RabbitMQ-08.jpg\" class=\"\">\n\n\n<h3 id=\"五、-安装RabbitMQ\"><a href=\"#五、-安装RabbitMQ\" class=\"headerlink\" title=\"五、 安装RabbitMQ\"></a>五、 <strong>安装RabbitMQ</strong></h3><h4 id=\"1-上传并解压\"><a href=\"#1-上传并解压\" class=\"headerlink\" title=\"1 上传并解压\"></a>1 <strong>上传并解压</strong></h4><p>​\t上传rabbitmq-server-generic-unix-3.7.18.tar.xz到&#x2F;usr&#x2F;loca&#x2F;tmp中</p>\n<pre><code>  cd /usr/local/tmp\n  tar xf rabbitmq-server-generic-unix-3.7.18.tar.xz\n</code></pre>\n<h4 id=\"2-复制到local下\"><a href=\"#2-复制到local下\" class=\"headerlink\" title=\"2 复制到local下\"></a>2 <strong>复制到local下</strong></h4><p>​\t复制解压文件到&#x2F;usr&#x2F;local下，命名为rabbitmq</p>\n<pre><code>  cp -r rabbitmq_server-3.7.18 /usr/local/rabbitmq\n</code></pre>\n<h4 id=\"3-配置环境变量\"><a href=\"#3-配置环境变量\" class=\"headerlink\" title=\"3 配置环境变量\"></a>3 <strong>配置环境变量</strong></h4><pre><code>  vim /etc/profile\n</code></pre>\n<p>​\t在文件中添加 </p>\n<pre><code>export PATH=$PATH:/usr/local/rabbitmq/sbin\n</code></pre>\n<p>​\t解析文件</p>\n<pre><code># source /etc/profile\n</code></pre>\n<h4 id=\"4-开启web管理插件\"><a href=\"#4-开启web管理插件\" class=\"headerlink\" title=\"4 开启web管理插件\"></a>4 <strong>开启web管理插件</strong></h4><p>​\t进入rabbitmq&#x2F;sbin目录</p>\n<pre><code># cd /usr/local/rabbitmq/sbin\n</code></pre>\n<pre><code> 查看插件列表\n</code></pre>\n<pre><code># ./rabbitmq-plugins list\n</code></pre>\n<pre><code> 生效管理插件\n</code></pre>\n<pre><code># ./rabbitmq-plugins enable rabbitmq_management\n</code></pre>\n<h4 id=\"5-后台运行\"><a href=\"#5-后台运行\" class=\"headerlink\" title=\"5 后台运行\"></a>5 <strong>后台运行</strong></h4><p>​\t启动rabbitmq。</p>\n<pre><code># ./rabbitmq-server -detached\n</code></pre>\n<p>​\t停止命令，如果无法停止，使用kill -9 进程号进行关闭</p>\n<pre><code># ./rabbitmqctl stop_app\n</code></pre>\n<h4 id=\"6-查看web管理界面\"><a href=\"#6-查看web管理界面\" class=\"headerlink\" title=\"6 查看web管理界面\"></a>6 <strong>查看web管理界面</strong></h4><p>​\t默认可以在安装rabbitmq的电脑上通过用户名：guest密码guest进行访问web管理界面</p>\n<p>​\t端口号：15672（放行端口，或关闭防火墙）</p>\n<p>​\t在虚拟机浏览器中输入：</p>\n<p>​\t<span class=\"exturl\" data-url=\"aHR0cDovL2xvY2FsaG9zdDoxNTY3Mi8=\">http://localhost:15672</span></p>\n<h3 id=\"六、-RabbitMq账户管理\"><a href=\"#六、-RabbitMq账户管理\" class=\"headerlink\" title=\"六、 RabbitMq账户管理\"></a>六、 <strong>RabbitMq账户管理</strong></h3><h4 id=\"1-创建账户\"><a href=\"#1-创建账户\" class=\"headerlink\" title=\"1 创建账户\"></a>1 <strong>创建账户</strong></h4><p>​\t语法：.&#x2F;rabbitmqctl add_user username password</p>\n<pre><code># cd /usr/local/rabbitmq/sbin\n# ./rabbitmqctl add_user mashibing mashibing\n</code></pre>\n<h4 id=\"2-给用户授予管理员角色\"><a href=\"#2-给用户授予管理员角色\" class=\"headerlink\" title=\"2 给用户授予管理员角色\"></a>2 <strong>给用户授予管理员角色</strong></h4><p>​\t其中smallming为新建用户的用户名</p>\n<pre><code># ./rabbitmqctl set_user_tags mashibing administrator\n</code></pre>\n<h4 id=\"3-给用户授权\"><a href=\"#3-给用户授权\" class=\"headerlink\" title=\"3 给用户授权\"></a>3 <strong>给用户授权</strong></h4><p>​\t“&#x2F;” 表示虚拟机</p>\n<p>​\tmashibing 表示用户名</p>\n<p>​\t“.<em>“ “.</em>“ “.*” 表示完整权限</p>\n<pre><code># ./rabbitmqctl set_permissions -p &quot;/&quot; mashibing &quot;.*&quot; &quot;.*&quot; &quot;.*&quot;\n</code></pre>\n<h4 id=\"4-登录\"><a href=\"#4-登录\" class=\"headerlink\" title=\"4 登录\"></a>4 <strong>登录</strong></h4><p>​\t使用新建账户和密码在windows中访问rabbitmq并登录 </p>\n<p>​\t在浏览器地址栏输入：</p>\n<p>​\t<span class=\"exturl\" data-url=\"aHR0cDovL2lwOjE1NjcyLw==\">http://ip:15672/</span></p>\n<pre><code> 用户名：mashibing\n</code></pre>\n<p>​\t密码：mashibing</p>\n<h3 id=\"七、-交换器（交换机）\"><a href=\"#七、-交换器（交换机）\" class=\"headerlink\" title=\"七、 交换器（交换机）\"></a>七、 <strong>交换器（交换机）</strong></h3><p>​\t交换器负责接收客户端传递过来的消息，并转发到对应的队列中。在RabbitMQ中支持四种交换器</p>\n<p>​\t1.Direct Exchange：直连交换器（默认）</p>\n<p>​\t2.Fanout Exchange：扇形交换器</p>\n<p>​\t3.Topic Exchange：主题交换器</p>\n<p>​\t4.Header Exchange：首部交换器。</p>\n<p>​\t在RabbitMq的Web管理界面中Exchanges选项卡就可以看见这四个交换器。</p>\n<img data-src=\"/2022/10/07/RabbitMQ/RabbitMQ-09.jpg\" class=\"\">\n\n\n<h4 id=\"1-direct交换器\"><a href=\"#1-direct交换器\" class=\"headerlink\" title=\"1 direct交换器\"></a>1 <strong>direct交换器</strong></h4><p>​\tdirect交换器是RabbitMQ默认交换器。默认会进行公平调度。所有接受者依次从消息队列中获取值。Publisher给哪个队列发消息，就一定是给哪个队列发送消息。对交换器绑定的其他队列没有任何影响。</p>\n<p>​\t（代码演示）一个队列需要绑定多个消费者</p>\n<p>​\t需要使用注解&#x2F;API：</p>\n<p>​\torg.springframework.amqp.core.Queue:队列</p>\n<p>​\tAmqpTemplate：操作RabbitMQ的接口。负责发送或接收消息</p>\n<p>​\t@RabbitListener(queues &#x3D; “”) 注解某个方法为接收消息方法</p>\n<h4 id=\"1-1-代码实现\"><a href=\"#1-1-代码实现\" class=\"headerlink\" title=\"1.1 代码实现\"></a>1.1 <strong>代码实现</strong></h4><h5 id=\"1-1-1-新建项目Publisher\"><a href=\"#1-1-1-新建项目Publisher\" class=\"headerlink\" title=\"1.1.1 新建项目Publisher\"></a>1.1.1 <strong>新建项目Publisher</strong></h5><h6 id=\"1-1-1-1-添加依赖\"><a href=\"#1-1-1-1-添加依赖\" class=\"headerlink\" title=\"1.1.1.1 添加依赖\"></a>1.1.1.1 <strong>添加依赖</strong></h6><pre><code>&lt;parent&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;\n    &lt;version&gt;2.2.2.RELEASE&lt;/version&gt;\n&lt;/parent&gt;\n\n&lt;dependencies&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;\n    &lt;/dependency&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;\n    &lt;/dependency&gt;\n&lt;/dependencies&gt;\n</code></pre>\n<h6 id=\"1-1-1-2-编写配置文件\"><a href=\"#1-1-1-2-编写配置文件\" class=\"headerlink\" title=\"1.1.1.2 编写配置文件\"></a>1.1.1.2 <strong>编写配置文件</strong></h6><p>​\t新建application.yml.</p>\n<p>​\thost:默认值localhost</p>\n<p>​\tusername默认值：guest</p>\n<p>​\tpassword默认值：guest\t</p>\n<pre><code>spring:\n  rabbitmq:\n    host: 192.168.1.195\n    username: mashibing\n    password: mashibing\n</code></pre>\n<h6 id=\"1-1-1-3-编写配置类\"><a href=\"#1-1-1-3-编写配置类\" class=\"headerlink\" title=\"1.1.1.3 编写配置类\"></a>1.1.1.3 <strong>编写配置类</strong></h6><p>新建com.config.RabbitmqConfig</p>\n<p>​\t队列的创建只有没有这个队列的时候需要编写。以后没有这个queue()方法也可以。</p>\n<pre><code>@Configuration\npublic class RabbitmqConfig &#123;\n    @Bean\n    protected Queue queue()&#123;\n        Queue queue = new Queue(&quot;myqueue&quot;);\n        return queue;\n    &#125;\n&#125;\n</code></pre>\n<h6 id=\"1-1-1-4-编写启动类\"><a href=\"#1-1-1-4-编写启动类\" class=\"headerlink\" title=\"1.1.1.4 编写启动类\"></a>1.1.1.4 <strong>编写启动类</strong></h6><p>略</p>\n<h6 id=\"1-1-1-5-编写测试类\"><a href=\"#1-1-1-5-编写测试类\" class=\"headerlink\" title=\"1.1.1.5 编写测试类\"></a>1.1.1.5 <strong>编写测试类</strong></h6><p>SpringBoot整合Spring-AMQP后包含内置对象AmqpTemplate</p>\n<pre><code>@SpringBootTest(classes = PublisherApplication.class)\n@RunWith(SpringJUnit4ClassRunner.class)\npublic class MyTest &#123;\n    @Autowired\n    private AmqpTemplate amqpTemplate;\n\n    @Test\n    public void test()&#123;\n        amqpTemplate.convertAndSend(&quot;myqueue&quot;,&quot;这是内容1&quot;);\n        System.out.println(&quot;发送成功&quot;);\n    &#125;\n&#125;\n</code></pre>\n<h5 id=\"1-1-2-创建Consumer\"><a href=\"#1-1-2-创建Consumer\" class=\"headerlink\" title=\"1.1.2 创建Consumer\"></a>1.1.2 <strong>创建Consumer</strong></h5><p>​\t新建项目consumer</p>\n<h6 id=\"1-1-2-1-添加依赖\"><a href=\"#1-1-2-1-添加依赖\" class=\"headerlink\" title=\"1.1.2.1 添加依赖\"></a>1.1.2.1 <strong>添加依赖</strong></h6><p>​\t和Publisher一样</p>\n<h6 id=\"1-1-2-2-编写配置文件\"><a href=\"#1-1-2-2-编写配置文件\" class=\"headerlink\" title=\"1.1.2.2 编写配置文件\"></a>1.1.2.2 <strong>编写配置文件</strong></h6><p>​\t和Publisher一样</p>\n<h6 id=\"1-1-2-3-编写监听器方法\"><a href=\"#1-1-2-3-编写监听器方法\" class=\"headerlink\" title=\"1.1.2.3 编写监听器方法\"></a>1.1.2.3 <strong>编写监听器方法</strong></h6><p>​\t注意：</p>\n<p>​\t类上要有@Componet，项目启动时此类生效。</p>\n<p>​\t@RabbitListener 监听指定队列。</p>\n<pre><code>@Component\npublic class DemoReceive &#123;\n\n    @RabbitListener(queues = &quot;myqueue&quot;)\n    public void demo(String msg)&#123;\n        System.out.println(&quot;获取到的消息1111：&quot;+msg);\n    &#125;\n\n    @RabbitListener(queues = &quot;myqueue&quot;)\n    public void demo2(String msg)&#123;\n        System.out.println(&quot;获取到的消息2222：&quot;+msg);\n    &#125;\n&#125;\n</code></pre>\n<h6 id=\"1-1-2-4-新建启动类\"><a href=\"#1-1-2-4-新建启动类\" class=\"headerlink\" title=\"1.1.2.4 新建启动类\"></a>1.1.2.4 <strong>新建启动类</strong></h6><p>​\t略。启动后此项目一直处于运行状态。属于长连接。</p>\n<h4 id=\"2-fanout交换器\"><a href=\"#2-fanout交换器\" class=\"headerlink\" title=\"2 fanout交换器\"></a>2 <strong>fanout交换器</strong></h4><p>​\t扇形交换器，实际上做的事情就是广播，fanout会把消息发送给所有的绑定在当前交换器上的队列。且每个队列消息中第一个Consumer能收到消息。</p>\n<p>​\t（代码演示）一个交换器需要绑定多个队列</p>\n<p>​\t需要使用注解&#x2F;API：</p>\n<p>​\tFanoutExchange：fanout交换器</p>\n<p>​\tBinding：绑定交换器和队列</p>\n<p>​\tBindingBuilder：Binding的构建器</p>\n<p>​\tamq.fanout:内置fanout交换器名称</p>\n<h4 id=\"2-1-代码\"><a href=\"#2-1-代码\" class=\"headerlink\" title=\"2.1 代码\"></a>2.1 <strong>代码</strong></h4><h5 id=\"2-1-1-Publisher\"><a href=\"#2-1-1-Publisher\" class=\"headerlink\" title=\"2.1.1 Publisher\"></a>2.1.1 <strong>Publisher</strong></h5><h6 id=\"2-1-1-1-修改配置类\"><a href=\"#2-1-1-1-修改配置类\" class=\"headerlink\" title=\"2.1.1.1 修改配置类\"></a>2.1.1.1 <strong>修改配置类</strong></h6><pre><code>@Bean\nprotected Queue fanoutQuque1()&#123;\n    return new Queue(&quot;fanout1&quot;);\n&#125;\n\n@Bean\nprotected Queue fanoutQuque2()&#123;\n    return new Queue(&quot;fanout2&quot;);\n&#125;\n\n@Bean\nprotected FanoutExchange fanoutExchange()&#123;\n    return new FanoutExchange(&quot;amq.fanout&quot;);\n&#125;\n\n@Bean\nprotected Binding fanoutBinding(Queue fanoutQuque1,FanoutExchange fanoutExchange)&#123;\n    return BindingBuilder.bind(fanoutQuque1).to(fanoutExchange);\n&#125;\n\n@Bean\nprotected Binding fanoutBinding2(Queue fanoutQuque2,FanoutExchange fanoutExchange)&#123;\n    return BindingBuilder.bind(fanoutQuque2).to(fanoutExchange);\n&#125;\n</code></pre>\n<h5 id=\"2-1-2-编写发送方法\"><a href=\"#2-1-2-编写发送方法\" class=\"headerlink\" title=\"2.1.2 编写发送方法****\"></a>2.1.2 <strong>编写发送方法</strong>****</h5><p>​\t第二个参数routingKey对于fanout没有意义的</p>\n<pre><code>@Test\npublic void test2()&#123;\n    amqpTemplate.convertAndSend(&quot;amq.fanout&quot;,&quot;asdfadsf&quot;,&quot;fanout msg&quot;);\n    System.out.println(&quot;发送成功&quot;);\n&#125;\n</code></pre>\n<h5 id=\"2-1-3-Consumer\"><a href=\"#2-1-3-Consumer\" class=\"headerlink\" title=\"2.1.3 Consumer\"></a>2.1.3 <strong>Consumer</strong></h5><p>​\tConsumer代码和Direct完全相同。一个队列给一个监听方法即可。</p>\n<h4 id=\"3-topic交换器\"><a href=\"#3-topic交换器\" class=\"headerlink\" title=\"3 topic交换器\"></a>3 <strong>topic交换器</strong></h4><p>​\t允许在路由键（RoutingKey）中出现匹配规则。</p>\n<p>​\t路由键的写法和包写法相同。com.msb.xxxx.xxx格式。</p>\n<p>​\t在绑定时可以带有下面特殊符号，中间可以出现:</p>\n<p>​\t* : 代表一个单词（两个.之间内容）</p>\n<p>​\t# : 0个或多个字符</p>\n<p>​\t接收方依然是公平调度，同一个队列中内容轮换获取值。</p>\n<p>​\t需要使用注解&#x2F;API：</p>\n<p>​\tTopicExchange：Topic交换器</p>\n<p>​\tamq.topic:内置topic交换器名称</p>\n<h4 id=\"3-1-代码\"><a href=\"#3-1-代码\" class=\"headerlink\" title=\"3.1 代码\"></a>3.1 <strong>代码</strong></h4><h5 id=\"3-1-1-Publisher\"><a href=\"#3-1-1-Publisher\" class=\"headerlink\" title=\"3.1.1 Publisher\"></a>3.1.1 <strong>Publisher</strong></h5><h6 id=\"3-1-1-1-配置类。\"><a href=\"#3-1-1-1-配置类。\" class=\"headerlink\" title=\"3.1.1.1 配置类。\"></a>3.1.1.1 <strong>配置类。</strong></h6><p>​\t之所以建立两个队列目的是为了演示使用Topic完成Fanout效果。</p>\n<pre><code>@Bean\nprotected Queue topicQueue() &#123;\n    return new Queue(&quot;topic1&quot;);\n&#125;\n\n@Bean\nprotected Queue topicQueue2() &#123;\n    return new Queue(&quot;topic2&quot;);\n&#125;\n\n@Bean\nprotected TopicExchange topicExchange() &#123;\n    return new TopicExchange(&quot;amq.topic&quot;);\n&#125;\n\n@Bean\nprotected Binding topicBinding(Queue topicQueue, TopicExchange topicExchange) &#123;\n    return BindingBuilder.bind(topicQueue).to(topicExchange).with(&quot;com.a&quot;);\n&#125;\n\n@Bean\nprotected Binding topicBinding2(Queue topicQueue2, TopicExchange topicExchange) &#123;\n    return BindingBuilder.bind(topicQueue2).to(topicExchange).with(&quot;com.#&quot;);\n&#125;\n</code></pre>\n<h6 id=\"3-1-1-2-发送消息\"><a href=\"#3-1-1-2-发送消息\" class=\"headerlink\" title=\"3.1.1.2 发送消息\"></a>3.1.1.2 <strong>发送消息</strong></h6><p>​\t第二个参数为路由键，匹配配置类中绑定时的路由规则。</p>\n<pre><code>@Test\npublic void test3()&#123;\n    amqpTemplate.convertAndSend(&quot;amq.topic&quot;,&quot;com.bjsxt.a.b&quot;,&quot;topic msg&quot;);\n    System.out.println(&quot;发送成功&quot;);\n&#125;\n</code></pre>\n<p> 3.1.2 <strong>Consumer</strong></p>\n<p>​\tConsumer代码与以前一样，注意队列名称topic1,topic2不要写路由键名称。( queues取值)</p>\n<pre><code>@RabbitListener(queues = &quot;topic2&quot;)\npublic void demo10(String msg)&#123;\n    System.out.println(&quot;topic2-2:&quot;+msg);\n&#125;\n</code></pre>\n<h3 id=\"八、-传递对象类型参数\"><a href=\"#八、-传递对象类型参数\" class=\"headerlink\" title=\"八、 传递对象类型参数\"></a>八、 <strong>传递对象类型参数</strong></h3><p>​\t如果消息是对象类型，此对象的类型必须进行序列化，且需要给定序列化值</p>\n<pre><code>public class People implements Serializable \n&#123;\n    public static final long serialVersionUID=1L;\n&#125;\n</code></pre>\n",
            "tags": [
                "分布式",
                "中间件",
                "RabbitMQ"
            ]
        },
        {
            "id": "http://example.com/2022/10/07/Solr/",
            "url": "http://example.com/2022/10/07/Solr/",
            "title": "Solr",
            "date_published": "2022-10-06T16:00:00.000Z",
            "content_html": "<h1 id=\"Solr\"><a href=\"#Solr\" class=\"headerlink\" title=\"Solr\"></a>Solr</h1><h3 id=\"主要内容\"><a href=\"#主要内容\" class=\"headerlink\" title=\"主要内容\"></a>主要内容</h3><ol>\n<li><p>Solr简介</p>\n</li>\n<li><p>Solr搜索原理</p>\n</li>\n<li><p>Solr单机版安装</p>\n</li>\n<li><p>可视化管理界面</p>\n</li>\n<li><p>新建核心</p>\n</li>\n<li><p>分词</p>\n</li>\n<li><p>Dataimport</p>\n</li>\n<li><p>使用SolrJ操作Solr</p>\n</li>\n<li><p>Spring Data for Apache Solr</p>\n<ol start=\"10\">\n<li>SolrCloud</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"学习目标\"><a href=\"#学习目标\" class=\"headerlink\" title=\"学习目标\"></a>学习目标</h3><table>\n<thead>\n<tr>\n<th>知识点</th>\n<th>要求</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Solr简介</td>\n<td>掌握</td>\n</tr>\n<tr>\n<td>Solr搜索原理</td>\n<td>掌握</td>\n</tr>\n<tr>\n<td>Solr单机版安装</td>\n<td>掌握</td>\n</tr>\n<tr>\n<td>可视化管理界面</td>\n<td>掌握</td>\n</tr>\n<tr>\n<td>新建核心</td>\n<td>掌握</td>\n</tr>\n<tr>\n<td>分词</td>\n<td>掌握</td>\n</tr>\n<tr>\n<td>Dataimport</td>\n<td>掌握</td>\n</tr>\n<tr>\n<td>使用SolrJ操作Solr</td>\n<td>掌握</td>\n</tr>\n<tr>\n<td>SolrCloud</td>\n<td>掌握</td>\n</tr>\n<tr>\n<td>Spring Data for Apache Solr</td>\n<td>掌握</td>\n</tr>\n</tbody></table>\n<h3 id=\"一、Solr简介\"><a href=\"#一、Solr简介\" class=\"headerlink\" title=\"一、Solr简介\"></a>一、Solr简介</h3><h4 id=\"1-为什么使用Solr\"><a href=\"#1-为什么使用Solr\" class=\"headerlink\" title=\"1.为什么使用Solr\"></a>1.为什么使用Solr</h4><p>​\t在海量数据下，对MySQL或Oracle进行模糊查询或条件查询的效率是很低的。而搜索功能在绝大多数项目中都是必须的，如何提升搜索效率是很多互联网项目必须要考虑的问题。</p>\n<p>​\t既然使用关系型数据库进行搜索效率比较低，最直接的解决方案就是使用专用搜索工具进行搜索，从而提升搜索效率。</p>\n<h4 id=\"2-常见搜索解决方案\"><a href=\"#2-常见搜索解决方案\" class=\"headerlink\" title=\"2.常见搜索解决方案\"></a>2.常见搜索解决方案</h4><p>​\t基于Apache Lucene（全文检索工具库）实现搜索。但是Lucene的使用对于绝大多数的程序员都是“噩梦级”的。</p>\n<p>​\t基于谷歌API实现搜索。</p>\n<p>​\t基于百度API实现搜索。</p>\n<h4 id=\"3-Solr简介\"><a href=\"#3-Solr简介\" class=\"headerlink\" title=\"3.Solr简介\"></a>3.Solr简介</h4><p>​\tSolr是基于Apache Lucene构建的用于搜索和分析的开源解决方案。可提供可扩展索引、搜索功能、高亮显示和文字解析功能。</p>\n<p>​\tSolr本质就是一个Java web 项目，且内嵌了Jetty服务器，所以安装起来非常方便。客户端操作Solr的过程和平时我们所写项目一样，就是请求Solr中控制器，处理完数据后把结果响应给客户端。</p>\n<h4 id=\"4-正向索引和反向索引\"><a href=\"#4-正向索引和反向索引\" class=\"headerlink\" title=\"4.正向索引和反向索引\"></a>4.正向索引和反向索引</h4><p>​\t只要讨论搜索就不得不提的两个概念：正向索引（forward index）和反向索引(inverted index)。</p>\n<p>​\t正向索引：从文档内容到词组的过程。每次搜索的实收需要搜索所有文档，每个文档比较搜索条件和词组。</p>\n<table>\n<thead>\n<tr>\n<th>文档</th>\n<th>词组</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>I am a chinese</td>\n<td>I,am,a,chinese</td>\n</tr>\n</tbody></table>\n<p>​\t反向索引：是正向索引的逆向。建立词组和文档的映射关系。通过找到词组就能找到文档内容。（和新华字典找字很像）</p>\n<table>\n<thead>\n<tr>\n<th>词组</th>\n<th>文档</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>I,am,a,chinese</td>\n<td>I am a chinese</td>\n</tr>\n</tbody></table>\n<h3 id=\"二、Solr搜索原理\"><a href=\"#二、Solr搜索原理\" class=\"headerlink\" title=\"二、Solr搜索原理\"></a>二、Solr搜索原理</h3><h4 id=\"1-搜索原理\"><a href=\"#1-搜索原理\" class=\"headerlink\" title=\"1.搜索原理\"></a>1.搜索原理</h4><p>​\tSolr能够提升检索效率的主要原因就是分词和索引（反向索引，通过）。</p>\n<p>​\t分词：会对搜索条件&#x2F;存储内容进行分词，分成日常所使用的词语。</p>\n<p>​\t索引：存储在Solr中内容会按照程序员的要求来是否建立索引。如果要求建立索引会把存储内容中关键字（分词）建立索引。</p>\n<img data-src=\"/2022/10/07/Solr/solr-01.JPG\" class=\"\">\n\n<h4 id=\"2-Solr中数据存储说明\"><a href=\"#2-Solr中数据存储说明\" class=\"headerlink\" title=\"2.Solr中数据存储说明\"></a>2.Solr中数据存储说明</h4><p>​\tSolr为了给内容建立索引，所以Solr就必须具备数据存储能力。所有需要被搜索的内容都需要存储在Solr中，在开发中需要把数据库中数据添加到Solr中进行初始化，每次修改数据库中数据还需要同步Solr中的数据。</p>\n<p>​\tSolr中数据存储是存储在Document对象中，对象中可以包含的属性和属性类型都定义在scheme.xml中。如果需要自定义属性或自定义属性类型都需要修改scheme.xml配置文件。从Solr5开始schema.xml更改名称为managed-scheme(没有扩展名)</p>\n<h3 id=\"三、Solr单机版安装\"><a href=\"#三、Solr单机版安装\" class=\"headerlink\" title=\"三、Solr单机版安装\"></a>三、Solr单机版安装</h3><p>​\tSolr是使用Java编写，所以必选先安装JDK。</p>\n<h4 id=\"1-上传并解压\"><a href=\"#1-上传并解压\" class=\"headerlink\" title=\"1.上传并解压\"></a>1.上传并解压</h4><p>​\t上传压缩包solr-7.7.2.tgz到&#x2F;usr&#x2F;local&#x2F;tmp中。</p>\n<p>解压</p>\n<pre><code># cd /usr/local/tmp\n# tar zxf solr-7.7.2.tgz\n</code></pre>\n<h4 id=\"2-复制到-x2F-usr-x2F-local中\"><a href=\"#2-复制到-x2F-usr-x2F-local中\" class=\"headerlink\" title=\"2.复制到&#x2F;usr&#x2F;local中\"></a>2.复制到&#x2F;usr&#x2F;local中</h4><pre><code># cp -r solr-7.7.2 ../solr\n</code></pre>\n<h4 id=\"3-修改启动参数\"><a href=\"#3-修改启动参数\" class=\"headerlink\" title=\"3.修改启动参数\"></a>3.修改启动参数</h4><p>​\t修改启动参数，否则启动时报警告。提示设置SOLR_ULIMIT_CHECKS&#x3D;false</p>\n<pre><code># cd /usr/local/solr/bin\n# vim solr.in.sh\n</code></pre>\n<img data-src=\"/2022/10/07/Solr/solr-02.jpg\" class=\"\">\n\n<h4 id=\"4-启动Solr\"><a href=\"#4-启动Solr\" class=\"headerlink\" title=\"4.启动Solr\"></a>4.启动Solr</h4><p>​\tSolr内嵌Jetty，直接启动即可。监听8983端口。</p>\n<p>​\tsolr默认不推荐root账户启动，如果是root账户启动需要添加-force参数。</p>\n<pre><code># ./solr start -force\n</code></pre>\n<h3 id=\"四、可视化管理界面\"><a href=\"#四、可视化管理界面\" class=\"headerlink\" title=\"四、可视化管理界面\"></a>四、可视化管理界面</h3><p>​\t在关闭防火墙的前提下，可以在windows的浏览器中访问Solr。</p>\n<p>​\t输入: <span class=\"exturl\" data-url=\"aHR0cDovLzE5Mi4xNjguOTMuMTA6ODk4My8=\">http://192.168.93.10:8983</span> 就可以访问Solr的可视化管理界面。</p>\n<p>​\t左侧有5个菜单。分别是：</p>\n<p>​\t（1）Dashboard：面板显示Solr的总体信息。</p>\n<p>​\t（2）Logging：日志</p>\n<p>​\t（3）Core Admin：Solr的核心。类似于数据的Database</p>\n<p>​\t（4）Java Perperties：所有Java相关属性。</p>\n<p>​\t（5）Thread Dump：线程相关信息。</p>\n<p>​\t（6）如果有Core，将显示在此处。</p>\n<img data-src=\"/2022/10/07/Solr/solr-03.JPG\" class=\"\">\n\n<h3 id=\"五、新建核心\"><a href=\"#五、新建核心\" class=\"headerlink\" title=\"五、新建核心\"></a>五、新建核心</h3><p>​\tSolr安装完成后默认是没有核心的。需要手动配置。</p>\n<p>​\t需要在solr&#x2F;server&#x2F;solr下新建文件夹，并给定配置文件，否则无法建立。</p>\n<img data-src=\"/2022/10/07/Solr/solr-04.JPG\" class=\"\">\n\n<h4 id=\"1-新建目录\"><a href=\"#1-新建目录\" class=\"headerlink\" title=\"1.新建目录\"></a>1.新建目录</h4><p>​\t在&#x2F;usr&#x2F;local&#x2F;solr&#x2F;server&#x2F;solr中新建自定义名称目录。此处示例名称为testcore。</p>\n<pre><code># cd /usr/local/solr/server/solr\n# mkdir testcore\n</code></pre>\n<h4 id=\"2-复制配置文件\"><a href=\"#2-复制配置文件\" class=\"headerlink\" title=\"2.复制配置文件\"></a>2.复制配置文件</h4><p>​\t在configsets里面包含了_default和sample_techproducts_configs。里面都是配置文件示例。_default属于默认配置，较纯净。sample_techproducts_configs是带有了一些配置示例。</p>\n<pre><code># cp -r configsets/_default/conf/ testcore/\n</code></pre>\n<h4 id=\"3-填写Core信息\"><a href=\"#3-填写Core信息\" class=\"headerlink\" title=\"3.填写Core信息\"></a>3.填写Core信息</h4><p>​\t在可视化管理界面中Core Admin中编写信息后点击Add Core后，短暂延迟后testcore就会创建成功。schema处不用更改。</p>\n<img data-src=\"/2022/10/07/Solr/solr-05.JPG\" class=\"\">\n\n<h4 id=\"4-出现testcore\"><a href=\"#4-出现testcore\" class=\"headerlink\" title=\"4.出现testcore\"></a>4.出现testcore</h4><p>​\t在客户端管理界面中，选择新建的Core后，就可以按照自己项目的需求进行操作了。</p>\n<img data-src=\"/2022/10/07/Solr/solr-06.jpg\" class=\"\">\n\n<h3 id=\"六、分词Analysis\"><a href=\"#六、分词Analysis\" class=\"headerlink\" title=\"六、分词Analysis\"></a>六、分词Analysis</h3><p>​\t在Solr可视化管理界面中，Core的管理菜单项中都会有Analysis。表示根据Scheme.xml(managed-schema)中配置要求进行解析。</p>\n<p>​\t对英文解析就比较简单了，只要按照空格把英文语句拆分成英文单词即可。</p>\n<img data-src=\"/2022/10/07/Solr/solr-07.jpg\" class=\"\">\n\n<p>​\t但是如果条件是中文时，把一句话按照字进行拆分就不是很合理了。正确的方式是按照合理的词组进行拆分。<img data-src=\"/2022/10/07/Solr/solr-08.jpg\" class=\"\"></p>\n<h4 id=\"1-配置步骤\"><a href=\"#1-配置步骤\" class=\"headerlink\" title=\"1.配置步骤\"></a>1.配置步骤</h4><p>​\t上传ik-analyzer.jar到webapps中。</p>\n<p>​\t去<span class=\"exturl\" data-url=\"aHR0cHM6Ly9zZWFyY2gubWF2ZW4ub3JnL3NlYXJjaD9xPWNvbS5naXRodWIubWFnZXNlJUU0JUI4JThCJUU4JUJEJUJEJUU1JUFGJUI5JUU1JUJBJTk0JUU3JTg5JTg4JUU2JTlDJUFDJUU3JTlBJTg0aWstYW5hbHl6ZXIlRTMlODAlODIlRTUlOEYlQUYlRTQlQkIlQTUlRTUlOUMlQTglRTglQjUlODQlRTYlOTYlOTklRTQlQjglQUQlRTclOUIlQjQlRTYlOEUlQTUlRTglOEUlQjclRTUlOEYlOTYlRTMlODAlODI=\">https://search.maven.org/search?q=com.github.magese下载对应版本的ik-analyzer。可以在资料中直接获取。</span></p>\n<h5 id=\"1-1上传jar到指定目录\"><a href=\"#1-1上传jar到指定目录\" class=\"headerlink\" title=\"1.1上传jar到指定目录\"></a>1.1上传jar到指定目录</h5><p>​\t上传ik-analyzer-7.7.0.jar到</p>\n<p>​\t&#x2F;usr&#x2F;local&#x2F;solr&#x2F;server&#x2F;solr-webapp&#x2F;webapp&#x2F;WEB-INF&#x2F;lib目录中</p>\n<h5 id=\"1-2修改配置文件\"><a href=\"#1-2修改配置文件\" class=\"headerlink\" title=\"1.2修改配置文件\"></a>1.2修改配置文件</h5><p>​\t修改&#x2F;usr&#x2F;local&#x2F;solr&#x2F;server&#x2F;solr&#x2F;testcore&#x2F;conf&#x2F;managed-schema</p>\n<pre><code class=\"sh\">vim /usr/local/solr/server/solr/testcore/conf/managed-schema\n</code></pre>\n<p>​\t添加下面内容。</p>\n<p>​\t排版：Esc 退出编辑状态下：gg&#x3D;G</p>\n<pre><code>&lt;field name=&quot;myfield&quot; type=&quot;text_ik&quot; indexed=&quot;true&quot; stored=&quot;true&quot; /&gt;\n    &lt;fieldType name=&quot;text_ik&quot; class=&quot;solr.TextField&quot;&gt;\n            &lt;analyzer type=&quot;index&quot;&gt;\n                    &lt;tokenizer class=&quot;org.wltea.analyzer.lucene.IKTokenizerFactory&quot; useSmart=&quot;false&quot; conf=&quot;ik.conf&quot;/&gt;\n                    &lt;filter class=&quot;solr.LowerCaseFilterFactory&quot;/&gt;\n            &lt;/analyzer&gt;\n            &lt;analyzer type=&quot;query&quot;&gt;\n                    &lt;tokenizer class=&quot;org.wltea.analyzer.lucene.IKTokenizerFactory&quot; useSmart=&quot;true&quot; conf=&quot;ik.conf&quot;/&gt;\n                    &lt;filter class=&quot;solr.LowerCaseFilterFactory&quot;/&gt;\n            &lt;/analyzer&gt;\n    &lt;/fieldType&gt;\n</code></pre>\n<h5 id=\"1-3重启\"><a href=\"#1-3重启\" class=\"headerlink\" title=\"1.3重启\"></a>1.3重启</h5><pre><code># cd /usr/local/solr/bin\n# ./solr stop -all\n# ./solr start -force\n</code></pre>\n<h5 id=\"1-4验证\"><a href=\"#1-4验证\" class=\"headerlink\" title=\"1.4验证\"></a>1.4验证</h5><p>​\t可以在可视化管理界面中找到myfield属性进行验证。</p>\n<img data-src=\"/2022/10/07/Solr/solr-09.jpg\" class=\"\">\n\n<h4 id=\"2-managed-schema配置说明\"><a href=\"#2-managed-schema配置说明\" class=\"headerlink\" title=\"2.managed-schema配置说明\"></a>2.managed-schema配置说明</h4><h5 id=\"2-1-lt-fieldType-x2F-gt\"><a href=\"#2-1-lt-fieldType-x2F-gt\" class=\"headerlink\" title=\"2.1&lt; fieldType&#x2F;&gt;\"></a>2.1&lt; fieldType&#x2F;&gt;</h5><p>​\t表示定义一个属性类型。在Solr中属性类型都是自定义的。在上面配置中name&#x3D;”text_ik”为自定义类型。当某个属性取值为text_ik时IK Analyzer才能生效。</p>\n<h5 id=\"2-2-lt-field-x2F-gt\"><a href=\"#2-2-lt-field-x2F-gt\" class=\"headerlink\" title=\"2.2&lt; field&#x2F;&gt;\"></a>2.2&lt; field&#x2F;&gt;</h5><p>​\t表示向Document中添加一个属性。</p>\n<p>​\t常用属性：</p>\n<p>​\t\tname: 属性名</p>\n<p>​\t\ttype:属性类型。所有类型都是solr使用<fieldType>配置的</p>\n<p>​\t\tindexed: 是否建立索引</p>\n<p>​\t\tstored: solr是否把该属性值响应给搜索用户。</p>\n<p>​\t\trequired：该属性是否是必须的。默认id是必须的。</p>\n<p>​\t\tmultiValued：如果为true，表示该属性为复合属性，此属性中包含了多个其他的属性。常用在多个列作为搜索条件时，把这些列定义定义成一个新的复合属性，通过搜索一个复合属性就可以实现搜索多个列。当设置为true时与&lt; copyField source&#x3D;”” dest&#x3D;””&#x2F;&gt;结合使用</p>\n<h5 id=\"2-3-lt-uniqueKey-gt\"><a href=\"#2-3-lt-uniqueKey-gt\" class=\"headerlink\" title=\"2.3&lt; uniqueKey&gt;\"></a>2.3&lt; uniqueKey&gt;</h5><p>​\t唯一主键，Solr中默认定义id属性为唯一主键。ID的值是不允许重复的。</p>\n<h5 id=\"2-4-lt-dynamicField-gt\"><a href=\"#2-4-lt-dynamicField-gt\" class=\"headerlink\" title=\"2.4&lt; dynamicField&gt;\"></a>2.4&lt; dynamicField&gt;</h5><p>​\t名称中允许*进行通配。代表满足特定名称要求的一组属性。</p>\n<pre><code> msb_java    \n</code></pre>\n<p>​\tmsb_bigdata</p>\n<p>​\tmsb_UI</p>\n<p>​        msb_*</p>\n<h3 id=\"七、Dataimport\"><a href=\"#七、Dataimport\" class=\"headerlink\" title=\"七、Dataimport\"></a>七、Dataimport</h3><p>​\t可以使用Solr自带的Dataimport功能把数据库中数据快速导入到solr中.</p>\n<p>​\t<strong>必须保证managed-schema和数据库中表的列对应。，添加配置</strong></p>\n<h4 id=\"1-修改配置文件\"><a href=\"#1-修改配置文件\" class=\"headerlink\" title=\"1.修改配置文件\"></a>1.修改配置文件</h4><p>​\t修改solrconfig.xml，添加下面内容</p>\n<pre><code> &lt;!-- 配置数据导入的处理器 --&gt;\n  &lt;requestHandler name=&quot;/dataimport&quot; class=&quot;org.apache.solr.handler.dataimport.DataImportHandler&quot;&gt;\n    &lt;lst name=&quot;defaults&quot;&gt;\n      &lt;!--  加载data-config.xml  --&gt;\n      &lt;str name=&quot;config&quot;&gt;data-config.xml&lt;/str&gt;\n     &lt;/lst&gt;\n  &lt;/requestHandler&gt;\n</code></pre>\n<h4 id=\"2-新建data-config-xml\"><a href=\"#2-新建data-config-xml\" class=\"headerlink\" title=\"2.新建data-config.xml\"></a>2.新建data-config.xml</h4><p>​\t和solrconfig.xml同一目录下新建data-config.xml</p>\n<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;dataConfig&gt;\n        &lt;dataSource type=&quot;JdbcDataSource&quot;   \n                driver=&quot;com.mysql.jdbc.Driver&quot;   \n                url=&quot;jdbc:mysql://192.168.1.135:3306/mytest&quot;   \n                user=&quot;root&quot;   \n                password=&quot;root&quot;/&gt;\n        &lt;document&gt;\n            &lt;entity name=&quot;product&quot; query=&quot;SELECT id,name,price from t_product&quot;&gt;\n                &lt;!-- \n                 实现数据库的列和索引库的字段的映射\n                 column 指定数据库的列表\n                 name  指定索引库的字段名字，必须和schema.xml中定义的一样\n                 --&gt;\n                 &lt;field column=&quot;id&quot; name=&quot;id&quot;/&gt;\n                 &lt;field column=&quot;name&quot; name=&quot;name&quot;/&gt;\n                 &lt;field column=&quot;price&quot; name=&quot;price&quot;/&gt;\n            &lt;/entity&gt;\n         &lt;/document&gt;\n&lt;/dataConfig&gt;\n</code></pre>\n<h4 id=\"3-添加jar\"><a href=\"#3-添加jar\" class=\"headerlink\" title=\"3.添加jar\"></a>3.添加jar</h4><p>​\t向solr-webapp中添加三个jar。在dist中两个还有一个数据库驱动。</p>\n<img data-src=\"/2022/10/07/Solr/solr-10.jpg\" class=\"\">\n\n<h4 id=\"4-操作\"><a href=\"#4-操作\" class=\"headerlink\" title=\"4.操作\"></a>4.操作</h4><p>​\t重启solr后，在可视化管理页面中进行数据导入。</p>\n<p>​\t注意：</p>\n<p>​\t点击导入按钮后，要记得点击刷新按钮。</p>\n<h3 id=\"八、菜单项目Documents使用办法\"><a href=\"#八、菜单项目Documents使用办法\" class=\"headerlink\" title=\"八、菜单项目Documents使用办法\"></a>八、菜单项目Documents使用办法</h3><p>​\t以XML格式举例</p>\n<h4 id=\"1-新增-x2F-修改\"><a href=\"#1-新增-x2F-修改\" class=\"headerlink\" title=\"1.新增&#x2F;修改\"></a>1.新增&#x2F;修改</h4><p>​\t当id不存在时新增，当id存在修改。</p>\n<pre><code>&lt;doc&gt;\n&lt;field name=&quot;id&quot;&gt;8&lt;/field&gt;\n&lt;field name=&quot;name&quot;&gt;明天更大卖&lt;/field&gt;\n&lt;field name=&quot;price&quot;&gt;98&lt;/field&gt;\n&lt;/doc&gt;\n</code></pre>\n<h4 id=\"2-删除\"><a href=\"#2-删除\" class=\"headerlink\" title=\"2.删除\"></a>2.删除</h4><h5 id=\"2-1根据主键删除\"><a href=\"#2-1根据主键删除\" class=\"headerlink\" title=\"2.1根据主键删除\"></a>2.1根据主键删除</h5><pre><code>&lt;delete&gt;\n    &lt;id&gt;8&lt;/id&gt;\n&lt;/delete&gt;\n&lt;commit/&gt;\n</code></pre>\n<h5 id=\"2-2根据条件删除\"><a href=\"#2-2根据条件删除\" class=\"headerlink\" title=\"2.2根据条件删除\"></a>2.2根据条件删除</h5><pre><code>&lt;delete&gt;\n    &lt;query&gt;*:*&lt;/query&gt;\n&lt;/delete&gt;\n</code></pre>\n<h4 id=\"3-solr可视化界面使用（QUERY）\"><a href=\"#3-solr可视化界面使用（QUERY）\" class=\"headerlink\" title=\"3.solr可视化界面使用（QUERY）\"></a>3.solr可视化界面使用（QUERY）</h4><p><img data-src=\"C:\\Users\\Lenovo\\AppData\\Roaming\\Typora\\typora-user-images\\1645693120964.png\" alt=\"1645693120964\"></p>\n<p>参数：</p>\n<p>​\t<strong>q：</strong>query，等于。格式  ——&gt; parameter&#x2F;columns : value\t<strong>具有分词时，相当于模糊查询–like</strong></p>\n<p>​\t<strong>fq：</strong>【在 q 的情况下再加条件】（要有分词功能）注意这里的keyword是用来检索的字段，他包含name、address、gender、expert_skill，这几个属性，所以我搜索“海”能够查询出来有海字的记录。</p>\n<p>​\t<strong>sort：</strong>排序 。 parameter&#x2F;columns    desc逆序&#x2F;asc</p>\n<p>​\t<strong>start,rows：</strong>从查询结果的start开始，显示到rows结束【下标】</p>\n<p>​\t<strong>fl：</strong>想显示的属性。</p>\n<p>​\t<strong>df：</strong>不想显示的属性。</p>\n<p>​\t<strong>wt：</strong>返回值类型</p>\n<p>​\t<strong>hl：</strong>高亮</p>\n<pre><code>    *  hl.fl\t\t\t\t\t\t value\n    *  hl.simple.pre        &lt;font color=&#39;red&#39;&gt;\n    *  hl.simple.post     &lt;/font&gt;\n</code></pre>\n<p>​\t</p>\n<h3 id=\"九、使用SolrJ操作Solr\"><a href=\"#九、使用SolrJ操作Solr\" class=\"headerlink\" title=\"九、使用SolrJ操作Solr\"></a>九、使用SolrJ操作Solr</h3><p>​\tSolrJ是Solr提供的Java客户端API。通过SolrJ可以实现Java程序对Solr中数据的操作。</p>\n<p>​\t大前提：添加SolrJ依赖。依赖版本和Solr版本严格对应</p>\n<pre><code>&lt;dependencies&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.apache.solr&lt;/groupId&gt;\n            &lt;artifactId&gt;solr-solrj&lt;/artifactId&gt;\n        &lt;version&gt;7.7.2&lt;/version&gt;\n    &lt;/dependency&gt;\n&lt;/dependencies&gt;\n</code></pre>\n<h4 id=\"1-新增-x2F-修改实现\"><a href=\"#1-新增-x2F-修改实现\" class=\"headerlink\" title=\"1.新增&#x2F;修改实现\"></a>1.新增&#x2F;修改实现</h4><pre><code>String url = &quot;http://192.168.93.10:8983/solr/testcore&quot;;\nHttpSolrClient solrClient =  new HttpSolrClient.Builder(url).build();\nSolrInputDocument inputDocument = new SolrInputDocument();\ninputDocument.addField(&quot;id&quot;,&quot;3&quot;);\ninputDocument.addField(&quot;myfield&quot;,&quot;myfield3&quot;);\nsolrClient.add(inputDocument);\nsolrClient.commit();\n</code></pre>\n<ul>\n<li>使用solrj进行索引的添加<ul>\n<li><ul>\n<li><strong>每个索引的添加必须要ID</strong><ul>\n<li><strong>添加key值要和schema.xml文件内的field域保持一致</strong></li>\n<li><strong>添加数据后一定要提交数据，不然是不存在数据的</strong></li>\n<li><strong>连接Solr的对象需要连接到项目名</strong></li>\n<li><strong>每个document是一组Json数据对象</strong></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"2-删除实现\"><a href=\"#2-删除实现\" class=\"headerlink\" title=\"2.删除实现\"></a>2.删除实现</h4><pre><code>String url = &quot;http://192.168.93.10:8983/solr/testcore&quot;;\nHttpSolrClient solrClient =  new HttpSolrClient.Builder(url).build();\nsolrClient.deleteById(&quot;3&quot;);\nsolrClient.commit();\n</code></pre>\n<ul>\n<li><strong>删除</strong></li>\n<li>删除支持两种删除方式<ul>\n<li><ul>\n<li><strong>1.根据ID</strong><ul>\n<li>2.执行查询删除<ul>\n<li><ul>\n<li><strong>查询删除的格式：查询的域:值</strong></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"3-查询实现\"><a href=\"#3-查询实现\" class=\"headerlink\" title=\"3.查询实现\"></a>3.查询实现</h4><pre><code>public void testQuery()&#123;\n    try &#123;\n        String url = &quot;http://192.168.93.10:8983/solr/testcore&quot;;\n        HttpSolrClient solrClient = new HttpSolrClient.Builder(url).build();\n\n        //封装了所有查询条件\n        SolrQuery params = new SolrQuery();\n        params.setQuery(&quot;name:丰富的&quot;);\n        //排序\n        params.setSort(&quot;price&quot;, SolrQuery.ORDER.desc);\n        //分页\n        params.setStart(0);\n params.setRows(1);\n        //高亮\n        params.setHighlight(true);\n        params.addHighlightField(&quot;name&quot;);\n        params.setHighlightSimplePre(&quot;&lt;span&gt;&quot;);\n        params.setHighlightSimplePost(&quot;&lt;/span&gt;&quot;);\n\n        QueryResponse response = solrClient.query(params);\n        SolrDocumentList list = response.getResults();\n        System.out.println(&quot;总条数：&quot;+list.getNumFound());\n\n        //高亮数据\n        Map&lt;String, Map&lt;String, List&lt;String&gt;&gt;&gt; highlighting = response.getHighlighting();\n\n        for(SolrDocument doc :list)&#123;\n            System.out.println(doc.get(&quot;id&quot;));\n            Map&lt;String, List&lt;String&gt;&gt; map = highlighting.get(doc.get(&quot;id&quot;));\n            List&lt;String&gt; HLList = map.get(&quot;name&quot;);\n            if(HLList!=null&amp;&amp;HLList.size()&gt;0)&#123;//显示高亮数据\n                System.out.println(HLList.get(0));\n            &#125;else&#123;\n                System.out.println(doc.get(&quot;name&quot;));\n            &#125;\n            System.out.println(doc.get(&quot;price&quot;));\n            System.out.println(&quot;===================&quot;);\n        &#125;\n        solrClient.close();\n    &#125; catch (SolrServerException e) &#123;\n        e.printStackTrace();\n    &#125; catch (IOException e) &#123;\n        e.printStackTrace();\n    &#125;\n&#125;\n</code></pre>\n<p><strong>使用到的对象</strong></p>\n<ul>\n<li>1.SolrQuery查询对象<ul>\n<li>1.setQuery()：设置查询的关键字<br>  2.set（）:设置查询的域<br>  3.setStart():设置开始<br>  4.setRows（）：设置结束</li>\n</ul>\n</li>\n</ul>\n<hr>\n<ul>\n<li><p>2.QueryResponse：响应结果集</p>\n<ul>\n<li>1.getNumFound():返回查询到的数量<br>  2.getResults（）；返回封装的list集合</li>\n</ul>\n</li>\n<li><p>3.SolrDocumentList：结果集合</p>\n<ul>\n<li>1.get():获取指定域的值</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"十、Spring-Data-for-Apache-Solr\"><a href=\"#十、Spring-Data-for-Apache-Solr\" class=\"headerlink\" title=\"十、Spring Data for Apache Solr\"></a>十、Spring Data for Apache Solr</h3><h4 id=\"1-Spring-Data简介\"><a href=\"#1-Spring-Data简介\" class=\"headerlink\" title=\"1.Spring Data简介\"></a>1.Spring Data简介</h4><p>​\tSpring Data 是Spring的顶级项目。里面包含了N多个二级子项目，每个子项目对应一种技术或工具。其目的为了让数据访问更加简单，更加方便的和Spring进行整合。</p>\n<p>​\tSpring Data 项目如果单独使用是还需要配置XML配置文件的，当和Spring Boot整合后使用起来非常方便。spring-boot-starter-data-xx就是对应的启动器。</p>\n<h4 id=\"2-实现步骤\"><a href=\"#2-实现步骤\" class=\"headerlink\" title=\"2.实现步骤\"></a>2.实现步骤</h4><h5 id=\"2-1添加依赖\"><a href=\"#2-1添加依赖\" class=\"headerlink\" title=\"2.1添加依赖\"></a>2.1添加依赖</h5><pre><code> &lt;dependencies&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-data-solr&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n    &lt;/dependencies&gt;\n</code></pre>\n<h5 id=\"2-2编写配置文件\"><a href=\"#2-2编写配置文件\" class=\"headerlink\" title=\"2.2编写配置文件\"></a>2.2编写配置文件</h5><pre><code>spring:\n  data:\n    solr:\n      host: http://192.168.9.132:8080/solr\n      # zk-host: 192.168.9.132:2181,192.168.9.132:2182,192.168.9.132:2183\n</code></pre>\n<h5 id=\"2-3编写测试类\"><a href=\"#2-3编写测试类\" class=\"headerlink\" title=\"2.3编写测试类\"></a>2.3编写测试类</h5><pre><code>@RunWith(SpringJUnit4ClassRunner.class)\n@SpringBootTest(classes = MyApplication.class)\npublic class MyTest &#123;\n    @Autowired\n    private SolrTemplate solrTemplate;\n\n    public void testInsert()&#123;\n        SolrInputDocument doc = new SolrInputDocument();\n        doc.setField(&quot;id&quot;,&quot;002&quot;);\n        doc.setField(&quot;item_title&quot;,&quot;这是一个手机3&quot;);\n        UpdateResponse ur = solrTemplate.saveBean(&quot;collection1&quot;, doc);\n        if(ur.getStatus()==0)&#123;\n            System.out.println(&quot;成功&quot;);\n        &#125;else&#123;\n            System.out.println(&quot;失败&quot;);\n        &#125;\n        solrTemplate.commit(&quot;collection1&quot;);\n    &#125;\n\n    public void testDelete()&#123;\n        UpdateResponse ur = solrTemplate.deleteByIds(&quot;collection1&quot;, &quot;change.me&quot;);\n        if(ur.getStatus()==0)&#123;\n            System.out.println(&quot;成功&quot;);\n        &#125;else&#123;\n            System.out.println(&quot;失败&quot;);\n        &#125;\n        solrTemplate.commit(&quot;collection1&quot;);\n    &#125;\n\n\n    public void query()&#123;\n        SimpleQuery query = new SimpleQuery();\n        Criteria c = new Criteria(&quot;item_keywords&quot;);\n        c.is(&quot;手机&quot;);\n        query.addCriteria(c);\n        query.setOffset(1L);\n        query.setRows(1);\n        ScoredPage&lt;DemoPojo&gt; sp = solrTemplate.queryForPage(&quot;collection1&quot;, query, DemoPojo.class);\n        System.out.println(sp.getContent());\n    &#125;\n\n    @Test\n    public void queryHL()&#123;\n\n        List&lt;DemoPojo&gt; listResult = new ArrayList&lt;&gt;();\n        SimpleHighlightQuery query = new SimpleHighlightQuery();\n        //设置查询条件\n        Criteria c = new Criteria(&quot;item_keywords&quot;);\n        c.is(&quot;手机&quot;);\n        query.addCriteria(c);\n        //分页\n        query.setOffset(0L);\n        query.setRows(10);\n        //排序\n        Sort sort = new Sort(Sort.Direction.DESC,&quot;id&quot;);\n        query.addSort(sort);\n        //高亮设置\n        HighlightOptions hlo = new HighlightOptions();\n        hlo.addField(&quot;item_title item_sell_point&quot;);\n        hlo.setSimplePrefix(&quot;&lt;span style=&#39;color:red;&#39;&gt;&quot;);\n        hlo.setSimplePostfix(&quot;&lt;/span&gt;&quot;);\n        query.setHighlightOptions(hlo);\n        HighlightPage&lt;DemoPojo&gt; hl = solrTemplate.queryForHighlightPage(&quot;collection1&quot;, query, DemoPojo.class);\n//        System.out.println(hl.getContent());\n        List&lt;HighlightEntry&lt;DemoPojo&gt;&gt; highlighted = hl.getHighlighted();\n        for(HighlightEntry&lt;DemoPojo&gt; hle : highlighted)&#123;\n            List&lt;HighlightEntry.Highlight&gt; list = hle.getHighlights();\n            DemoPojo dp = hle.getEntity();\n            for (HighlightEntry.Highlight h : list)&#123;//一个对象里面可能多个属性是高亮属性\n                if(h.getField().getName().equals(&quot;item_title&quot;))&#123;\n                    dp.setItem_title( h.getSnipplets().get(0));\n                &#125;\n            &#125;\n            listResult.add(dp);\n        &#125;\n        System.out.println(listResult);\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"十一-使用zookeepr管理solr集群\"><a href=\"#十一-使用zookeepr管理solr集群\" class=\"headerlink\" title=\"十一. 使用zookeepr管理solr集群\"></a>十一. 使用zookeepr管理solr集群</h3><p>1.上传压缩包到&#x2F;usr&#x2F;local&#x2F;tmp 下 并解压。</p>\n<p>2.在 &#x2F;usr&#x2F;local下新建文件夹 zookeeper</p>\n<pre><code># mkdir /usr/local/zookeeper\n</code></pre>\n<p>3.把解压的所有文件复制到zookeeper下， 并命名为zk1</p>\n<pre><code># cp -r /usr/local/temp/zookeeper-3.4.8 /usr/local/zookeeper/zk1\n</code></pre>\n<p>4.在zk1下新建文件夹 data</p>\n<p>5.在data下新建文件 myid, 里面写上 1</p>\n<pre><code># vim myid\n</code></pre>\n<p>6.进入到zk1&#x2F;conf 下 把 zoo_sample.cfg 复制一份叫做 zoo.cfg</p>\n<p>7.编辑 zoo.cfg 内容，设置 dataDIR为 data文件夹， 并在文件最下面添加下面内容</p>\n<pre><code>server.1=192.168.93.10:2688:3888\nserver.2=192.168.93.10:2689:3889\nserver.3=192.168.93.10:2690:3890\n</code></pre>\n<p> 7.1 server.1中的1是myid的内容</p>\n<p> 7.2 2688 2689 2690 是 zookeeper内部端口</p>\n<p> 7.3 3888 3889 3890 是 leader端口</p>\n<p>8.把zk1复制两份，分部叫做 zk2  zk3  并修改 myid 的值为 2，3 修改zoo.cfg中 dataDIR和clientPort</p>\n<p>9.启动三个zookeeper</p>\n<pre><code># ./zkServer.sh start\n</code></pre>\n<p>10.查看状态</p>\n<pre><code># ./zkServer.sh status\n</code></pre>\n<h3 id=\"十一-使用zookeepr管理solr集群-Dokcer\"><a href=\"#十一-使用zookeepr管理solr集群-Dokcer\" class=\"headerlink\" title=\"十一. 使用zookeepr管理solr集群(Dokcer )\"></a>十一. 使用zookeepr管理solr集群(Dokcer )</h3><h4 id=\"1、准备docker-compose-yml文件\"><a href=\"#1、准备docker-compose-yml文件\" class=\"headerlink\" title=\"1、准备docker-compose.yml文件\"></a><strong>1、准备</strong>docker-compose.yml<strong>文件</strong></h4><pre><code class=\"shell\">version: &#39;2&#39;\nservices:\n  zoo1:\n    image: zookeeper:3.5\n    restart: always\n    container_name: zoo1\n    ports:\n      - &quot;2181:2181&quot;\n    environment:\n      ZOO_MY_ID: 1\n      ZOO_SERVERS: server.1=0.0.0.0:2688:3888 server.2=zoo2:2689:3888 server.3=zoo3:2690:3888\n\n  zoo2:\n    image: zookeeper:3.5\n    restart: always\n    container_name: zoo2\n    ports:\n      - &quot;2182:2181&quot;\n    environment:\n      ZOO_MY_ID: 2\n      ZOO_SERVERS: server.1=zoo1:2688:3888 server.2=0.0.0.0:2689:3888 server.3=zoo3:2690:3888\n\n  zoo3:\n    image: zookeeper:3.5\n    restart: always\n    container_name: zoo3\n    ports:\n      - &quot;2183:2181&quot;\n    environment:\n      ZOO_MY_ID: 3\n      ZOO_SERVERS: server.1=zoo1:2688:3888 server.2=zoo2:2689:3888 server.3=0.0.0.0:2690:3888\n\n</code></pre>\n<h4 id=\"2、创建镜像\"><a href=\"#2、创建镜像\" class=\"headerlink\" title=\"2、创建镜像\"></a><strong>2、创建镜像</strong></h4><ul>\n<li>要在创建的docker-compose.yml文件中使用命令</li>\n</ul>\n<pre><code class=\"shell\">docker-compose up -d\n</code></pre>\n<h4 id=\"3、进入容器\"><a href=\"#3、进入容器\" class=\"headerlink\" title=\"3、进入容器\"></a><strong>3、进入容器</strong></h4><pre><code class=\"shell\">docker exec -it zoo1 /bin/bash\n\n#查看zoo1 的状态\ncd bin\n./zkServer.sh status\n</code></pre>\n<ul>\n<li>如果出现，以下情况：</li>\n</ul>\n<pre><code>ZooKeeper JMX enabled by default\nUsing config: /conf/zoo.cfg\nClient port not found in static config file. Looking in dynamic config file.\ngrep: : No such file or directory\nClient port not found in the server configs\nClient port not found. Looking for secureClientPort in the static config.\nUnable to find either secure or unsecure client port in any configs. Terminating.\n</code></pre>\n<p>​\t通过阅读我们知道他在conf中的zoo.cfg文件中缺少 **clientPort **我们只需要自行添加即可</p>\n<pre><code class=\"shell\">#修改之前我们先装一下 vim\napt-get update\n\napt-get install -y vim \n\n#修改zoo.fcg文件\nvim /conf/zoo.fcg\n\nclientPort=2181\n</code></pre>\n<ul>\n<li><p>完事之后<strong>重启</strong>zoo1</p>\n<p>  <img data-src=\"C:\\Users\\Lenovo\\AppData\\Roaming\\Typora\\typora-user-images\\1645780920291.png\" alt=\"1645780920291\"></p>\n<p>  成功！！</p>\n</li>\n</ul>\n<h4 id=\"4、查看所有zookeeper的状态\"><a href=\"#4、查看所有zookeeper的状态\" class=\"headerlink\" title=\"4、查看所有zookeeper的状态\"></a>4、查看所有zookeeper的状态</h4><pre><code class=\"shell\">docker exec -it zoo3 bash ./bin/zkServer.sh status\n</code></pre>\n<h4 id=\"5、进去客户端\"><a href=\"#5、进去客户端\" class=\"headerlink\" title=\"5、进去客户端\"></a>5、进去客户端</h4><pre><code class=\"shell\">docker exec -it zoo3 zkCli.sh\n</code></pre>\n<h3 id=\"十二、SolrCloud\"><a href=\"#十二、SolrCloud\" class=\"headerlink\" title=\"十二、SolrCloud\"></a>十二、SolrCloud</h3><p>​\tSolr可以搭建具备容错能力和高可用的Solr集群。集群中集群配置、自动负载均衡和查询故障转移、\t\t\tZookeeper集群实现集群协调管理，这些全部功能统称为SolrCloud。</p>\n<p>​\tSolrCloud是基于Zookeeper进行管理的。在Solr中已经内置了Zookeeper相关内容，当执行集群创建命令会自动创建Zookeeper相关内容。这个使用的是Zookeeper的集群管理功能实现的。</p>\n<h4 id=\"1-搭建\"><a href=\"#1-搭建\" class=\"headerlink\" title=\"1.搭建\"></a>1.搭建</h4><h5 id=\"1-1创建\"><a href=\"#1-1创建\" class=\"headerlink\" title=\"1.1创建\"></a>1.1创建</h5><p>​\tSolrCloud已经包含在了Solr中，可以直接启动Solr集群。</p>\n<pre><code> ./solr -e cloud -noprompt -force\n</code></pre>\n<p>​\t此命令等同于# .&#x2F;solr -e cloud -force全部参数为默认值。</p>\n<p>​\t运行成功后会在example文件夹多出cloud文件夹。</p>\n<h5 id=\"1-2停止\"><a href=\"#1-2停止\" class=\"headerlink\" title=\"1.2停止\"></a>1.2停止</h5><pre><code> ./solr stop -all\n</code></pre>\n<h5 id=\"1-3重新运行\"><a href=\"#1-3重新运行\" class=\"headerlink\" title=\"1.3重新运行\"></a>1.3重新运行</h5><pre><code> ./solr start -c -p 8983 -s ../example/cloud/node1/solr/ -force\n ./solr start -c -p 7574 -z localhost:9983 -s ../example/cloud/node2/solr/ -force\n</code></pre>\n",
            "tags": [
                "分布式",
                "中间件",
                "Solr",
                "快速搜索"
            ]
        },
        {
            "id": "http://example.com/2022/10/07/Redis/",
            "url": "http://example.com/2022/10/07/Redis/",
            "title": "Redis基础",
            "date_published": "2022-10-06T16:00:00.000Z",
            "content_html": "<h1 id=\"Redis\"><a href=\"#Redis\" class=\"headerlink\" title=\"Redis\"></a>Redis</h1><h3 id=\"一-Redis简介\"><a href=\"#一-Redis简介\" class=\"headerlink\" title=\"一.Redis简介\"></a>一.Redis简介</h3><h4 id=\"1-NoSQL简介\"><a href=\"#1-NoSQL简介\" class=\"headerlink\" title=\"1.NoSQL简介\"></a>1.NoSQL简介</h4><p>​\t目前市场主流数据存储都是使用关系型数据库。每次操作关系型数据库时都是I&#x2F;O操作，I&#x2F;O操作是主要影响程序执行性能原因之一，连接数据库关闭数据库都是消耗性能的过程。尽量减少对数据库的操作，能够明显的提升程序运行效率。</p>\n<p>​\t针对上面的问题，市场上就出现了各种NoSQL(Not Only SQL,不仅仅可以使用关系型数据库)数据库，它们的宣传口号：不是什么样的场景都必须使用关系型数据库，一些特定的场景使用NoSQL数据库更好。</p>\n<p>常见NoSQL数据库：</p>\n<p>​\tmemcached ：键值对，内存型数据库，所有数据都在内存中。</p>\n<p>​\tRedis:和Memcached类似，还具备持久化能力。</p>\n<p>​\tHBase：以列作为存储。</p>\n<p>​\tMongoDB：以Document做存储。</p>\n<h4 id=\"2-Redis简介\"><a href=\"#2-Redis简介\" class=\"headerlink\" title=\"2.Redis简介\"></a>2.<strong>Redis简介</strong></h4><p>​\tRedis是以Key-Value形式进行存储的NoSQL数据库。</p>\n<p>​\tRedis是使用C语言进行编写的。</p>\n<p>​\t平时操作的数据都在内存中，效率特高，读的效率110000&#x2F;s，写81000&#x2F;s，所以多把Redis当做缓存工具使用。</p>\n<p>​\tRedis以solt（槽）作为数据存储单元，每个槽中可以存储N多个键值对。Redis中固定具有16384。理论上可以实现一个槽是一个Redis。每个向Redis存储数据的key都会进行crc16算法得出一个值后对16384取余就是这个key存放的solt位置。</p>\n<p>​\t同时通过Redis Sentinel提供高可用，通过Redis Cluster提供自动分区。</p>\n<h3 id=\"二-Redis单机版安装\"><a href=\"#二-Redis单机版安装\" class=\"headerlink\" title=\"二. Redis单机版安装\"></a>二. Redis单机版安装</h3><p>​\t1.安装依赖C语言依赖</p>\n<p>​\tredis使用C语言编写，所以需要安装C语言库</p>\n<pre><code># yum install -y gcc-c++ automake autoconf libtool make tcl \n</code></pre>\n<p>​\t</p>\n<p>​\t2.上传并解压</p>\n<p>​\t把redis-5.0.5.tar.gz上传到&#x2F;usr&#x2F;local&#x2F;tmp中</p>\n<p>​\t解压文件</p>\n<pre><code># cd /usr/local/tmp\n\n# tar zxf redis-5.0.5.tar.gz\n</code></pre>\n<p>​\t3.编译并安装</p>\n<p>​\t进入解压文件夹</p>\n<pre><code># cd /usr/local/tmp/redis-5.0.5/\n</code></pre>\n<p>​\t编译</p>\n<pre><code># make\n</code></pre>\n<p>​\t安装\t</p>\n<pre><code># make install PREFIX=/usr/local/redis\n</code></pre>\n<p>​\t4.开启守护进程</p>\n<p>​\t复制cd &#x2F;usr&#x2F;local&#x2F;tmp&#x2F;redis-5.0.5&#x2F;中redis.conf配置文件\t</p>\n<pre><code># cp redis.conf /usr/local/redis/bin/\n</code></pre>\n<p>​\t修改配置文件\t</p>\n<pre><code># cd /usr/local/redis/bin/\n\n# vim redis.conf\n</code></pre>\n<p>​\t把daemonize的值由no修改为yes</p>\n<img data-src=\"/2022/10/07/Redis/Redis-01.jpg\" class=\"\">\n\n<p>​\t5.修改外部访问</p>\n<p>​\t在redis5中需要修改配置文件redis.conf允许外部访问。需要修改两处。</p>\n<p>​\t注释掉下面</p>\n<p>​\tbind 127.0.0.1</p>\n<pre><code>#bind 127.0.0.1\n</code></pre>\n<p>​\tprotected-mode yes 改成 no</p>\n<img data-src=\"/2022/10/07/Redis/Redis-02.jpg\" class=\"\">\n\n<p>​\t6.启动并测试</p>\n<p>​\t启动redis</p>\n<pre><code class=\"shell\">./redis-server redis.conf\n</code></pre>\n<p>​\t重启redis</p>\n<pre><code>./redis-cli shutdown\n./redis-server redis.conf\n</code></pre>\n<p>​\t启动客户端工具</p>\n<p>​\t在redis5中客户端工具对命令会有提供功能。</p>\n<pre><code class=\"shell\">./redis-cli \n</code></pre>\n<h3 id=\"二-、docker安装Redis\"><a href=\"#二-、docker安装Redis\" class=\"headerlink\" title=\"二.、docker安装Redis\"></a>二.、docker安装Redis</h3><p>1、拉取镜像文件</p>\n<pre><code class=\"shell\">docker pull redis[:(版本号)]\n</code></pre>\n<p>2、去gitee库中下载redis配置文件（docker不自带配置文件）【也可不进行此步骤】</p>\n<p><strong>建议看完，先别操作，再看三，看完三之后再决定如何操作</strong></p>\n<p>然后按照文章内容进行，忽略下载。</p>\n<p>文章地址： <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuamI1MS5uZXQvYXJ0aWNsZS8yMDMyNzQuaHRt\">https://www.jb51.net/article/203274.htm</span> </p>\n<p>、</p>\n<p><img data-src=\"C:\\Users\\Lenovo\\AppData\\Roaming\\Typora\\typora-user-images\\1645177895314.png\" alt=\"1645177895314\"></p>\n<p>3、创建一个redis 服务容器 </p>\n<p><strong>第二步进行了的</strong></p>\n<pre><code class=\"shell\">docker run -p 6379:6379 --name myredis -v /usr/local/docker/redis.conf:/etc/redis/redis.conf -v /usr/local/docker/data:/data -d redis redis-server /etc/redis/redis.conf --appendonly yes\n</code></pre>\n<p><strong>第二步没有进行的</strong></p>\n<pre><code class=\"shell\">docker run -p 6379:6379 --name myredis -v /root/myredis/data:/data -v /root/myredis/conf/redis.conf:/usr/local/etc/redis/redis.conf -d redis redis-server /usr/local/etc/redis/redis.conf --appendonly yes\n</code></pre>\n<p><strong>区别：</strong></p>\n<p>​\t其实也没有什么区别，只是映射的文件不同，也可以将第二步的文件直接创建到第二种创建服务容器的配置文件地址中去，这样也可使用第二个创建方式。</p>\n<p><img data-src=\"C:\\Users\\Lenovo\\AppData\\Roaming\\Typora\\typora-user-images\\1645177877202.png\" alt=\"1645177877202\"></p>\n<p><img data-src=\"C:\\Users\\Lenovo\\AppData\\Roaming\\Typora\\typora-user-images\\1645177918077.png\" alt=\"1645177918077\"></p>\n<h3 id=\"三-Redis常用的五大类型\"><a href=\"#三-Redis常用的五大类型\" class=\"headerlink\" title=\"三.Redis常用的五大类型\"></a>三.Redis常用的五大类型</h3><p>​\t Redis不仅仅支持简单的k&#x2F;v类型的数据，同时还提供list，set，zset，hash等数据结构的存储，它还支持数据的备份，即master-slave模式的数据备份，同样Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用。</p>\n<p>​        Redis支持的五大数据类型包括String（字符串  用法： 键  值），Hash（哈希 类似Java中的 map  用法： 键  键值对），List（列表  用法：键 集合 不可以重复），Set（集合 用法：键 集合 可以重复），Zset（sorted set 有序集合    用法： 键  值 值）</p>\n<h4 id=\"String（字符串）\"><a href=\"#String（字符串）\" class=\"headerlink\" title=\"String（字符串）\"></a>String（字符串）</h4><p>​\tstring 是 redis 最基本的类型，你可以理解成与 Memcached 一模一样的类型，一个 key 对应一个 value。string 类型是二进制安全的。意思是 redis 的 string 可以包含任何数据。比如jpg图片或者序列化的对象。string 类型是 Redis 最基本的数据类型，string 类型的值最大能存储 512MB。</p>\n<p>应用场景：  </p>\n<p>​\tString是最常用的一种数据类型，普通的key&#x2F;value存储都可以归为此类，value其实不仅是String，  </p>\n<p>也可以是数字：比如想知道什么时候封锁一个IP地址(访问超过几次)。</p>\n<h4 id=\"Hash（哈希）\"><a href=\"#Hash（哈希）\" class=\"headerlink\" title=\"Hash（哈希）\"></a>Hash（哈希）</h4><p>​\tRedis hash 是一个键值(key&#x3D;&gt;value)对集合。</p>\n<p>​\tRedis hash 是一个 string 类型的 field 和 value 的映射表，hash 特别适合用于存储对象。</p>\n<p>​\t使用场景：存储、读取、修改用户属性</p>\n<p>​\t我们简单举个实例来描述下Hash的应用场景，比如我们要存储一个用户信息对象数据，包含以下信息：    用户ID，为查找的key，  </p>\n<p>​    \t存储的value用户对象包含姓名name，年龄age，生日birthday 等信息，  如果用普通的key&#x2F;value结构来存储，主要有以下2种存储方式：  </p>\n<p>​    \t第一种方式将用户ID作为查找key,把其他信息封装成一个对象以序列化的方式存储，  </p>\n<p>​           如：set u001 “李三,18,20010101”  </p>\n<p>​     \t这种方式的缺点是，增加了序列化&#x2F;反序列化的开销，并且在需要修改其中一项信息时，需要把整个对象取回，并且修改操作需要对并发进行保护，引入CAS等复杂问题。  </p>\n<p>​     \t第二种方法是这个用户信息对象有多少成员就存成多少个key-value对儿，用用户ID+对应属性的名称作为唯一标识来取得对应属性的值，  </p>\n<p>​       \t如：mset user:001:name “李三 “user:001:age18 user:001:birthday “20010101”  虽然省去了序列化开销和并发问题，但是用户ID为重复存储，如果存在大量这样的数据，内存浪费还是非常可观的。  </p>\n<p>​    \t那么Redis提供的Hash很好的解决了这个问题。</p>\n<h4 id=\"List（列表）\"><a href=\"#List（列表）\" class=\"headerlink\" title=\"List（列表）\"></a>List（列表）</h4><p>​\tRedis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）。</p>\n<p>应用场景：  </p>\n<pre><code>    Redis list的应用场景非常多，也是Redis最重要的数据结构之一。  \n</code></pre>\n<p>​    \t我们可以轻松地实现最新消息排行等功能。  </p>\n<pre><code>   Lists的另一个应用就是消息队列，可以利用Lists的PUSH操作，将任务存在Lists中，然后工作线程再用POP操作将任务取出进行执行。  \n</code></pre>\n<h4 id=\"Set（集合）\"><a href=\"#Set（集合）\" class=\"headerlink\" title=\"Set（集合）\"></a>Set（集合）</h4><p>​\tRedis的Set是string类型的无序集合。</p>\n<p>​\t使用场景：1.共同好友、二度好友 </p>\n<p>​\t\t\t   2. 利用唯一性，可以统计访问网站的所有独立 IP </p>\n<pre><code>  Redis set对外提供的功能与list类似是一个列表的功能，特殊之处在于set是可以自动排重的，当你需要存储一个列表数据，又不希望出现重复数据时，set是一个很好的选择，并且set提供了判断某个成员是否在一个set集合内的重要接口，这个也是list所不能提供的。  \n \n  比如在微博应用中，每个人的好友存在一个集合（set）中，这样求两个人的共同好友的操作，可能就只需要用求交集命令即可。  \n</code></pre>\n<p>​    \tRedis还为集合提供了求交集、并集、差集等操作，可以非常方便的实  </p>\n<pre><code>  实现方式：  \n</code></pre>\n<p>​    \tset 的内部实现是一个 value永远为null的HashMap，实际就是通过计算hash的方式来快速排重的，这也是set能提供判断一个成员是否在集合内的原因。 </p>\n<h4 id=\"zset-sorted-set：有序集合\"><a href=\"#zset-sorted-set：有序集合\" class=\"headerlink\" title=\"zset(sorted set：有序集合)\"></a>zset(sorted set：有序集合)</h4><pre><code> Redis zset 和 set 一样也是string类型元素的集合,且不允许重复的成员。不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。zset的成员是唯一的,但分数(score)却可以重复。\n</code></pre>\n<p>使用场景：1.带有权重的元素，比如一个游戏的用户得分排行榜 </p>\n<p>​\t\t   2.比较复杂的数据结构，一般用到的场景不算太多</p>\n<h3 id=\"四-Redis常用命令\"><a href=\"#四-Redis常用命令\" class=\"headerlink\" title=\"四. Redis常用命令\"></a>四. Redis常用命令</h3><p>Redis命令相关手册有很多，下面为其中比较好用的两个</p>\n<p>  1.<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cucmVkaXMubmV0LmNuL29yZGVyLw==\">https://www.redis.net.cn/order/</span></p>\n<p>  2.<span class=\"exturl\" data-url=\"aHR0cDovL2RvYy5yZWRpc2ZhbnMuY29tL3RleHQtaW4=\">http://doc.redisfans.com/text-in</span></p>\n<h4 id=\"1-Key操作\"><a href=\"#1-Key操作\" class=\"headerlink\" title=\"1. Key操作\"></a>1. Key操作</h4><h5 id=\"1-1-exists\"><a href=\"#1-1-exists\" class=\"headerlink\" title=\"1.1  exists\"></a>1.1  exists</h5><p>​\t判断key是否存在。</p>\n<p>​\t语法：exists key名称</p>\n<p>​\t返回值：存在返回数字，不存在返回0</p>\n<h5 id=\"1-2-expire\"><a href=\"#1-2-expire\" class=\"headerlink\" title=\"1.2 expire\"></a>1.2 expire</h5><p>​\t设置key的过期时间，单位秒</p>\n<p>​\t语法：expire key 秒数</p>\n<p>​\t返回值：成功返回1，失败返回0</p>\n<h5 id=\"1-3-ttl\"><a href=\"#1-3-ttl\" class=\"headerlink\" title=\"1.3 ttl\"></a>1.3 ttl</h5><p>​\t查看key的剩余过期时间</p>\n<p>​\t语法：ttl key</p>\n<p>​\t返回值：返回剩余时间，如果不过期返回-1</p>\n<h5 id=\"1-4-del\"><a href=\"#1-4-del\" class=\"headerlink\" title=\"1.4 del\"></a>1.4 del</h5><p>​\t根据key删除键值对。</p>\n<p>​\t语法：del key</p>\n<p>​\t返回值：被删除key的数量</p>\n<h4 id=\"2-字符串值-String\"><a href=\"#2-字符串值-String\" class=\"headerlink\" title=\"2. 字符串值(String)\"></a>2. <strong>字符串值(String)</strong></h4><h5 id=\"2-1-set\"><a href=\"#2-1-set\" class=\"headerlink\" title=\"2.1 set\"></a>2.1 <strong>set</strong></h5><p>​\t设置指定key的值</p>\n<p>​\t语法：set key value</p>\n<p>​\t返回值：成功OK</p>\n<h5 id=\"2-2-get\"><a href=\"#2-2-get\" class=\"headerlink\" title=\"2.2 get\"></a>2.2 <strong>get</strong></h5><p>​\t获取指定key的值</p>\n<p>​\t语法：get key</p>\n<p>​\t返回值：key的值。不存在返回nil</p>\n<h5 id=\"2-3-setnx\"><a href=\"#2-3-setnx\" class=\"headerlink\" title=\"2.3 setnx\"></a>2.3 <strong>setnx</strong></h5><p>​\t当且仅当key不存在时才新增。</p>\n<p>​\t语法：setnx key value</p>\n<p>​\t返回值：不存在时返回1，存在返回0</p>\n<h5 id=\"2-4-setex\"><a href=\"#2-4-setex\" class=\"headerlink\" title=\"2.4 setex\"></a>2.4 <strong>setex</strong></h5><p>​\t设置key的存活时间，无论是否存在指定key都能新增，如果存在key覆盖旧值。同时必须指定过期时间。</p>\n<p>​\t语法：setex key seconds value</p>\n<p>​\t返回值：OK</p>\n<h4 id=\"3-哈希表-Hash\"><a href=\"#3-哈希表-Hash\" class=\"headerlink\" title=\"3.哈希表(Hash)\"></a>3.<strong>哈希表(Hash)</strong></h4><p>​\tHash类型的值中包含多组field value。</p>\n<img data-src=\"/2022/10/07/Redis/Redis-03.jpg\" class=\"\">\n\n<h5 id=\"3-1-hset\"><a href=\"#3-1-hset\" class=\"headerlink\" title=\"3.1 hset\"></a>3.1 <strong>hset</strong></h5><p>​\t给key中field设置值。</p>\n<p>​\t语法：hset key field value</p>\n<p>​\t返回值：成功1，失败0</p>\n<h5 id=\"3-2-hget\"><a href=\"#3-2-hget\" class=\"headerlink\" title=\"3.2 hget\"></a>3.2 <strong>hget</strong></h5><p>​\t获取key中某个field的值</p>\n<p>​\t语法：hget key field </p>\n<p>​\t返回值：返回field的内容</p>\n<h5 id=\"3-3-hmset\"><a href=\"#3-3-hmset\" class=\"headerlink\" title=\"3.3 hmset\"></a>3.3 <strong>hmset</strong></h5><p>​\t给key中多个filed设置值</p>\n<p>​\t语法：hmset key field value field value</p>\n<p>​\t返回值：成功OK</p>\n<h5 id=\"3-4-hmget\"><a href=\"#3-4-hmget\" class=\"headerlink\" title=\"3.4 hmget\"></a>3.4 <strong>hmget</strong></h5><p>​\t一次获取key中多个field的值</p>\n<p>​\t语法：hmget key field field</p>\n<p>​\t返回值：value列表</p>\n<h5 id=\"3-5-hvals\"><a href=\"#3-5-hvals\" class=\"headerlink\" title=\"3.5 hvals\"></a>3.5 <strong>hvals</strong></h5><p>​\t获取key中所有field的值</p>\n<p>​\t语法：hvals key</p>\n<p>​\t返回值：value列表</p>\n<h5 id=\"3-6-hgetall\"><a href=\"#3-6-hgetall\" class=\"headerlink\" title=\"3.6 hgetall\"></a>3.6 <strong>hgetall</strong></h5><p>​\t获取所有field和value</p>\n<p>​\t语法：hgetall key</p>\n<p>​\t返回值：field和value交替显示列表</p>\n<h5 id=\"3-7-hdel\"><a href=\"#3-7-hdel\" class=\"headerlink\" title=\"3.7 hdel\"></a>3.7 <strong>hdel</strong></h5><p>​\t删除key中任意个field</p>\n<p>​\t语法：hdel key field field</p>\n<p>​\t返回值：成功删除field的数量</p>\n<h4 id=\"4-列表（List）\"><a href=\"#4-列表（List）\" class=\"headerlink\" title=\"4. 列表（List）\"></a>4. <strong>列表（List）</strong></h4><h5 id=\"4-1-Rpush\"><a href=\"#4-1-Rpush\" class=\"headerlink\" title=\"4.1 Rpush\"></a>4.1 <strong>Rpush</strong></h5><p>​\t向列表末尾中插入一个或多个值</p>\n<p>​\t语法；rpush key value value</p>\n<p>​\t返回值：列表长度</p>\n<h5 id=\"4-2-lrange\"><a href=\"#4-2-lrange\" class=\"headerlink\" title=\"4.2 lrange\"></a>4.2 <strong>lrange</strong></h5><p>​\t返回列表中指定区间内的值。可以使用-1代表列表末尾</p>\n<p>​\t语法：lrange list 0 -1</p>\n<p>​\t返回值：查询到的值</p>\n<h5 id=\"4-3-lpush\"><a href=\"#4-3-lpush\" class=\"headerlink\" title=\"4.3 lpush\"></a>4.3 <strong>lpush</strong></h5><p>​\t将一个或多个值插入到列表前面</p>\n<p>​\t语法：lpush key value value</p>\n<p>​\t返回值：列表长度</p>\n<h5 id=\"4-4-llen\"><a href=\"#4-4-llen\" class=\"headerlink\" title=\"4.4 llen\"></a>4.4 <strong>llen</strong></h5><p>​\t获取列表长度</p>\n<p>​\t语法：llen key</p>\n<p>​\t返回值：列表长度</p>\n<h5 id=\"4-5-lrem\"><a href=\"#4-5-lrem\" class=\"headerlink\" title=\"4.5 lrem\"></a>4.5 <strong>lrem</strong></h5><p>​\t删除列表中元素。count为正数表示从左往右删除的数量。负数从右往左删除的数量。</p>\n<p>​\t语法：lrem key count value</p>\n<p>​\t返回值：删除数量。</p>\n<h4 id=\"5-集合-Set\"><a href=\"#5-集合-Set\" class=\"headerlink\" title=\"5 集合(Set)\"></a>5 <strong>集合(Set)</strong></h4><p>​\tset和java中集合一样。</p>\n<h5 id=\"5-1-sadd\"><a href=\"#5-1-sadd\" class=\"headerlink\" title=\"5.1 sadd\"></a>5.1 <strong>sadd</strong></h5><p>​\t向集合中添加内容。不允许重复。</p>\n<p>​\t语法：sadd key value value value</p>\n<p>​\t返回值：集合长度</p>\n<h5 id=\"5-2-scard\"><a href=\"#5-2-scard\" class=\"headerlink\" title=\"5.2 scard\"></a>5.2 <strong>scard</strong></h5><p>​\t返回集合元素数量</p>\n<p>​\t语法：scard key</p>\n<p>​\t返回值：集合长度</p>\n<h5 id=\"5-3-smembers\"><a href=\"#5-3-smembers\" class=\"headerlink\" title=\"5.3 **smembers **\"></a>5.3 **smembers **</h5><p>​\t查看集合中元素内容</p>\n<p>​\t语法：smembers key</p>\n<p>​\t返回值：集合中元素</p>\n<h4 id=\"6-有序集合（Sorted-Set）\"><a href=\"#6-有序集合（Sorted-Set）\" class=\"headerlink\" title=\"6 .有序集合（Sorted Set）\"></a>6 .<strong>有序集合（Sorted Set）</strong></h4><p>​\t有序集合中每个value都有一个分数（score），根据分数进行排序。</p>\n<h5 id=\"6-1-zadd\"><a href=\"#6-1-zadd\" class=\"headerlink\" title=\"6.1 zadd\"></a>6.1 <strong>zadd</strong></h5><p>​\t向有序集合中添加数据</p>\n<p>​\t语法：zadd key score value score value</p>\n<p>​\t返回值：长度</p>\n<p><img data-src=\"C:\\Users\\Lenovo\\AppData\\Roaming\\Typora\\typora-user-images\\1645195960858.png\" alt=\"1645195960858\"></p>\n<h5 id=\"6-2-zrange\"><a href=\"#6-2-zrange\" class=\"headerlink\" title=\"6.2 zrange\"></a>6.2 <strong>zrange</strong></h5><p>​\t返回区间内容想·，withscores表示带有分数</p>\n<p>​\t语法：zrange key 区间 [withscores]</p>\n<p>​\t返回值：值列表</p>\n<p><img data-src=\"C:\\Users\\Lenovo\\AppData\\Roaming\\Typora\\typora-user-images\\1645195940696.png\" alt=\"1645195940696\"></p>\n<p><img data-src=\"C:\\Users\\Lenovo\\AppData\\Roaming\\Typora\\typora-user-images\\1645195926902.png\" alt=\"1645195926902\"></p>\n<h3 id=\"五、-Redis持久化策略\"><a href=\"#五、-Redis持久化策略\" class=\"headerlink\" title=\"五、 Redis持久化策略\"></a>五、 <strong>Redis持久化策略</strong></h3><p>​\tRedis不仅仅是一个内存型数据库，还具备持久化能力。</p>\n<h4 id=\"1-RDB\"><a href=\"#1-RDB\" class=\"headerlink\" title=\"1. RDB\"></a>1. <strong>RDB</strong></h4><p>​\trdb模式是默认模式，可以在指定的时间间隔内生成数据快照（snapshot），默认保存到dump.rdb文件中。当redis重启后会自动加载dump.rdb文件中内容到内存中。</p>\n<p>​\t用户可以使用SAVE（同步）或BGSAVE（异步）手动保存数据。</p>\n<p>​\t可以设置服务器配置的save选项，让服务器每隔一段时间自动执行一次BGSAVE命令，可以通过save选项设置多个保存条件，但只要其中任意一个条件被满足，服务器就会执行BGSAVE命令。<br>　　\t例如：<br>　　\tsave 900 1<br>　　\tsave 300 10<br>　　\tsave 60 10000<br>　　那么只要满足以下三个条件中的任意一个，BGSAVE命令就会被执行<br>　　服务器在900秒之内，对数据库进行了至少1次修改<br>　　服务器在300秒之内，对数据库进行了至少10次修改<br>　　服务器在60秒之内，对数据库进行了至少10000次修改</p>\n<h5 id=\"1-1-优点\"><a href=\"#1-1-优点\" class=\"headerlink\" title=\"1.1 优点\"></a>1.1 <strong>优点</strong></h5><p>​\trdb文件是一个紧凑文件，直接使用rdb文件就可以还原数据。</p>\n<p>​\t数据保存会由一个子进程进行保存，不影响父进程。</p>\n<p>​\t恢复数据的效率要高于aof</p>\n<h5 id=\"1-2-缺点\"><a href=\"#1-2-缺点\" class=\"headerlink\" title=\"1.2 缺点\"></a>1.2 <strong>缺点</strong></h5><p>​\t每次保存点之间导致redis不可意料的关闭，可能会丢失数据。</p>\n<p>​\t由于每次保存数据都需要fork()子进程，在数据量比较大时可能会比较耗费性能。</p>\n<h4 id=\"2-AOF\"><a href=\"#2-AOF\" class=\"headerlink\" title=\"2 AOF\"></a>2 <strong>AOF</strong></h4><p>​\tAOF默认是关闭的，需要在配置文件中开启AOF。Redis支持AOF和RDB同时生效，如果同时存在，AOF优先级高于RDB（Redis重新启动时会使用AOF进行数据恢复）</p>\n<p>​\t监听执行的命令，如果发现执行了修改数据的操作，同时直接同步到数据库文件中。</p>\n<h5 id=\"2-1-优点\"><a href=\"#2-1-优点\" class=\"headerlink\" title=\"2.1 优点\"></a>2.1 <strong>优点</strong></h5><p>​\t相对RDB数据更加安全。</p>\n<h5 id=\"2-2-缺点\"><a href=\"#2-2-缺点\" class=\"headerlink\" title=\"2.2 缺点\"></a>2.2 <strong>缺点</strong></h5><p>​\t相同数据集AOF要大于RDB。</p>\n<p>​\t相对RDB可能会慢一些。</p>\n<h5 id=\"2-3-开启办法\"><a href=\"#2-3-开启办法\" class=\"headerlink\" title=\"2.3 开启办法\"></a>2.3 <strong>开启办法</strong></h5><p>​\t修改redis.conf中</p>\n<pre><code># 默认no\nappendonly yes\n# aof文件名\nappendfilename &quot;appendonly.aof&quot;\n</code></pre>\n<h3 id=\"六-Redis主从复制\"><a href=\"#六-Redis主从复制\" class=\"headerlink\" title=\"六. Redis主从复制\"></a>六. <strong>Redis主从复制</strong></h3><p>​\tRedis支持集群功能。为了保证单一节点可用性，redis支持主从复制功能。每个节点有N个复制品（replica），其中一个复制品是主（master），另外N-1个复制品是从（Slave），也就是说Redis支持一主多从。</p>\n<p>​\t一个主可有多个从，而一个从又可以看成主，它还可以有多个从。</p>\n<img data-src=\"/2022/10/07/Redis/Redis-04.jpg\" class=\"\">\n\n<h4 id=\"1-主从优点\"><a href=\"#1-主从优点\" class=\"headerlink\" title=\"1. 主从优点\"></a>1. <strong>主从优点</strong></h4><p>​\t增加单一节点的健壮性，从而提升整个集群的稳定性。（Redis中当超过1&#x2F;2节点不可用时，整个集群不可用）</p>\n<p>​\t从节点可以对主节点数据备份，提升容灾能力。</p>\n<p>​\t读写分离。在redis主从中，主节点一般用作写（具备读的能力），从节点只能读，利用这个特性实现读写分离，写用主，读用从。</p>\n<h5 id=\"1-1-一主多从搭建\"><a href=\"#1-1-一主多从搭建\" class=\"headerlink\" title=\"1.1 一主多从搭建\"></a>1.1 <strong>一主多从搭建</strong></h5><p>​\t在已经搭建的单机版redis基础上进行操作。</p>\n<p>​\t并且关闭redis单机版</p>\n<pre><code>./redis-cli shutdown\n</code></pre>\n<h5 id=\"1-2-新建目录\"><a href=\"#1-2-新建目录\" class=\"headerlink\" title=\"1.2 新建目录\"></a>1.2 <strong>新建目录</strong></h5><pre><code># mkdir /usr/local/replica\n</code></pre>\n<h5 id=\"1-3-复制目录\"><a href=\"#1-3-复制目录\" class=\"headerlink\" title=\"1.3 复制目录\"></a>1.3 <strong>复制目录</strong></h5><p>​\t把之前安装的redis单机版中bin目录复制三份，分别叫做：master、slave1、slave2</p>\n<pre><code># cp -r /usr/local/redis/bin /usr/local/replica/master\n# cp -r /usr/local/redis/bin /usr/local/replica/slave1\n# cp -r /usr/local/redis/bin /usr/local/replica/slave2\n</code></pre>\n<h5 id=\"1-4-修改从的配置文件\"><a href=\"#1-4-修改从的配置文件\" class=\"headerlink\" title=\"1.4 修改从的配置文件\"></a>1.4 <strong>修改从的配置文件</strong></h5><p>​\t修改2个从的redis.conf，指定主节点ip和端口。并修改自身端口号防止和其他redis冲突。</p>\n<pre><code># vim /usr/local/replica/slave1/redis.conf\n</code></pre>\n<p>​\t指定主节点ip和端口</p>\n<pre><code>replicaof 192.168.93.10 6379\n</code></pre>\n<p>​\t修改自己端口</p>\n<pre><code>port 6380\n</code></pre>\n<pre><code># vim /usr/local/replica/slave2/redis.conf\n</code></pre>\n<p>​\t指定主节点ip和端口</p>\n<pre><code>replicaof 192.168.93.10 6379\n</code></pre>\n<p>​\t修改自己端口</p>\n<pre><code>port 6381\n</code></pre>\n<h5 id=\"1-5-启动三个redis实例\"><a href=\"#1-5-启动三个redis实例\" class=\"headerlink\" title=\"1.5 启动三个redis实例\"></a>1.5 <strong>启动三个redis实例</strong></h5><p>​\t注意：一定要关闭单机的redis，否则端口冲突。</p>\n<pre><code># cd /usr/local/replica\n# vim startup.sh\n</code></pre>\n<p>​\t在文件中添加下面内容</p>\n<pre><code>cd /usr/local/replica/master/\n./redis-server redis.conf\n  cd /usr/local/replica/slave1\n./redis-server redis.conf\n  cd /usr/local/replica/slave2\n./redis-server redis.conf\n</code></pre>\n<pre><code> 赋予权限\n</code></pre>\n<pre><code># chmod a+x startup.sh\n</code></pre>\n<p>​\t开启</p>\n<pre><code># ./startup.sh\n</code></pre>\n<h5 id=\"1-6-查看启动状态\"><a href=\"#1-6-查看启动状态\" class=\"headerlink\" title=\"1.6 查看启动状态\"></a>1.6 <strong>查看启动状态</strong></h5><pre><code># ps aux|grep redis\n</code></pre>\n<img data-src=\"/2022/10/07/Redis/Redis-05.jpg\" class=\"\">\n\n<h5 id=\"1-7-测试\"><a href=\"#1-7-测试\" class=\"headerlink\" title=\"1.7 测试*\"></a>1.7 <strong>测试</strong>*</h5><pre><code># cd /usr/local/replica/master/\n# ./redis-cli \n</code></pre>\n<img data-src=\"/2022/10/07/Redis/Redis-06.jpg\" class=\"\">\n\n<p>​\t在客户端命令行模式下，添加一条数据：</p>\n<img data-src=\"/2022/10/07/Redis/Redis-07.jpg\" class=\"\">\n\n<p>​\t进去slave查看数据是否同步。</p>\n<pre><code># cd /usr/local/replica/slave1\n# ./redis-cli -p 6380\n</code></pre>\n<img data-src=\"/2022/10/07/Redis/Redis-08.jpg\" class=\"\">\n\n<h4 id=\"2、docker下操作\"><a href=\"#2、docker下操作\" class=\"headerlink\" title=\"2、docker下操作\"></a>2、docker下操作</h4><p>​\t可以自定义<strong>redis.conf</strong>文件只写要修改的，不改的就别写，这里主要是要书写<strong>新的端口号</strong>以及<strong>父节点</strong>的<strong>ip和端口</strong></p>\n<p><strong>注意：</strong>所有修改必须在容器外，容器内修改无效，在退出重启的那一刻就已经还原了</p>\n<p>我们通常使用  CP 来修改</p>\n<pre><code class=\"shell\">docker  cp  本机文件路径   容器id: 容器内文件路径\n#所有路径是所在文件夹路径，并不是文件的路径，简单来说就是写到文件夹所在路径即可，不需要指定特定文件\n</code></pre>\n<h5 id=\"1、修改端口号\"><a href=\"#1、修改端口号\" class=\"headerlink\" title=\"1、修改端口号\"></a>1、修改端口号</h5><p>同上</p>\n<h5 id=\"2、指定父节点\"><a href=\"#2、指定父节点\" class=\"headerlink\" title=\"2、指定父节点\"></a>2、指定父节点</h5><p>同上</p>\n<h5 id=\"3、重启\"><a href=\"#3、重启\" class=\"headerlink\" title=\"3、重启\"></a>3、重启</h5><p><strong>（如果在启动前修改不需要，这里是指已经启动了的容器，在修改之后的操作）</strong></p>\n<pre><code class=\"shell\">docker restart 容器id\n</code></pre>\n<h5 id=\"4、测试并查看\"><a href=\"#4、测试并查看\" class=\"headerlink\" title=\"4、测试并查看\"></a>4、测试并查看</h5><p>·同上</p>\n<pre><code class=\"shell\">role\n\n或者\n\ninfo replication\n</code></pre>\n<h3 id=\"七-哨兵（Sentinel）\"><a href=\"#七-哨兵（Sentinel）\" class=\"headerlink\" title=\"七.  哨兵（Sentinel）\"></a>七.  <strong>哨兵（Sentinel）</strong></h3><p>​\t在redis主从默认是只有主具备写的能力，而从只能读。如果主宕机，整个节点不具备写能力。但是如果这是让一个从变成主，整个节点就可以继续工作。即使之前的主恢复过来也当做这个节点的从即可。</p>\n<p>​\tRedis的哨兵就是帮助监控整个节点的，当节点主宕机等情况下，帮助重新选取主。</p>\n<p>​\tRedis中哨兵支持单哨兵和多哨兵。单哨兵是只要这个哨兵发现master宕机了，就直接选取另一个master。而多哨兵是根据我们设定，达到一定数量哨兵认为master宕机后才会进行重新选取主。我们以多哨兵演示。</p>\n<h4 id=\"1-没有哨兵下主从效果\"><a href=\"#1-没有哨兵下主从效果\" class=\"headerlink\" title=\"1. 没有哨兵下主从效果\"></a>1. <strong>没有哨兵下主从效果</strong></h4><p>​\t只要杀掉主，整个节点无法在写数据，从身份不会变化，主的信息还是以前的信息。</p>\n<img data-src=\"/2022/10/07/Redis/Redis-09.jpg\" class=\"\">\n\n<h4 id=\"2-搭建多哨兵\"><a href=\"#2-搭建多哨兵\" class=\"headerlink\" title=\"2.搭建多哨兵\"></a>2.<strong>搭建多哨兵</strong></h4><p>​\t前提：安装了单机的redis</p>\n<h5 id=\"2-1-新建目录\"><a href=\"#2-1-新建目录\" class=\"headerlink\" title=\"2.1 新建目录\"></a>2.1 <strong>新建目录</strong></h5><pre><code># mkdir /usr/local/sentinel\n</code></pre>\n<h5 id=\"2-2-复制redis\"><a href=\"#2-2-复制redis\" class=\"headerlink\" title=\"2.2 复制redis\"></a>2.2 <strong>复制redis</strong></h5><pre><code># cp -r /usr/local/redis/bin/* /usr/local/sentinel\n</code></pre>\n<h5 id=\"2-3-复制配置文件\"><a href=\"#2-3-复制配置文件\" class=\"headerlink\" title=\"2.3 复制配置文件\"></a>2.3 <strong>复制配置文件</strong></h5><p>​\t从redis解压目录中复制sentinel配置文件</p>\n<pre><code># cd /usr/local/tmp/redis-5.0.5/\n# cp sentinel.conf /usr/local/sentinel/\n</code></pre>\n<h5 id=\"2-4-修改配置文件\"><a href=\"#2-4-修改配置文件\" class=\"headerlink\" title=\"2.4 修改配置文件\"></a>2.4 <strong>修改配置文件</strong></h5><pre><code># cd /usr/local/sentinel\n# vim sentinel.conf\n\nport 26379\ndaemonize yes\n#这个提示里面的/var/log/redis/redis.log日志文件指的是容器中的文件，千万别理解为宿主机中的路径，如果你在宿主机创建此文件并授权，最后结果也是一样的，理解这一点很重要。\nlogfile “/usr/local/sentinel/26379.log”\n\nsentinel monitor mymaster 192.168.93.10 6379 2\n</code></pre>\n<p>​\t复制sentinel.conf，命名为sentinel-26380.conf</p>\n<pre><code># cp sentinel.conf sentinel-26380.conf\n# vim sentinel-26380.conf\n\nport 26380\ndaemonize yes\nlogfile “/usr/local/sentinel/26380.log”\nsentinel monitor mymaster 192.168.93.10 6379 2\n</code></pre>\n<p>复制sentinel.conf，命名为sentinel-26381.conf</p>\n<pre><code># cp sentinel.conf sentinel-26381.conf\n# vim sentinel-26381.conf\n\nport 26381\ndaemonize yes\nlogfile “/usr/local/sentinel/26381.log”\nsentinel monitor mymaster 192.168.93.10 6379 2\n</code></pre>\n<h5 id=\"2-5-启动主从\"><a href=\"#2-5-启动主从\" class=\"headerlink\" title=\"2.5 启动主从\"></a>2.5 <strong>启动主从</strong></h5><p>​\t如果已经启动状态，忽略下面命令。如果启动部分，全部kill后重新启动。</p>\n<p>​\t使用kill杀死全部redis</p>\n<pre><code># ps aux|grep redis\n# kill -9 进程号\n</code></pre>\n<p>​\t启动redis主从</p>\n<pre><code># cd /usr/local/replica\n# ./startup.sh\n</code></pre>\n<h5 id=\"2-6-启动三个哨兵\"><a href=\"#2-6-启动三个哨兵\" class=\"headerlink\" title=\"2.6 启动三个哨兵\"></a>2.6 <strong>启动三个哨兵</strong></h5><pre><code># cd /usr/local/sentinel\n# ./redis-sentinel sentinel.conf\n# ./redis-sentinel sentinel-26380.conf\n# ./redis-sentinel sentinel-26381.conf\n</code></pre>\n<h5 id=\"2-7-查看日志\"><a href=\"#2-7-查看日志\" class=\"headerlink\" title=\"2.7 查看日志\"></a>2.7 <strong>查看日志</strong></h5><pre><code># cat 26379.log\n</code></pre>\n<h5 id=\"2-8-测试宕机\"><a href=\"#2-8-测试宕机\" class=\"headerlink\" title=\"2.8 测试宕机\"></a>2.8 <strong>测试宕机</strong></h5><p>​\t查看redis进程号</p>\n<pre><code># ps aux|grep redis\n</code></pre>\n<p>​\t杀死主进程号</p>\n<pre><code># kill -9 进程号\n</code></pre>\n<p>​\t查看日志，短暂延迟后会发现，出现新的主。</p>\n<pre><code># cat 26379.log\n</code></pre>\n<h3 id=\"八-集群-Cluster-–nt-have-doc\"><a href=\"#八-集群-Cluster-–nt-have-doc\" class=\"headerlink\" title=\"八. 集群(Cluster)–nt have doc\"></a>八. 集群(Cluster)–nt have doc</h3><p>​\t前提：已经安装好redis单机版。</p>\n<p>​\t当集群中超过或等于1&#x2F;2节点不可用时，整个集群不可用。为了搭建稳定集群，都采用奇数节点。</p>\n<h4 id=\"1-复制redis配置文件\"><a href=\"#1-复制redis配置文件\" class=\"headerlink\" title=\"1 .复制redis配置文件\"></a>1 .<strong>复制redis配置文件</strong></h4><p>​\t从&#x2F;usr&#x2F;local&#x2F;redis&#x2F;bin下把redis.conf复制到当前目录中，命名为redis-7001.conf</p>\n<pre><code># cp /usr/local/redis/bin/redis.conf /usr/local/redis/bin/redis-7001.conf\n</code></pre>\n<h4 id=\"2-修改redis-7001-conf\"><a href=\"#2-修改redis-7001-conf\" class=\"headerlink\" title=\"2. 修改redis-7001.conf\"></a>2. <strong>修改redis-7001.conf</strong></h4><pre><code># cd /usr/local/redis/bin\n# vim redis-7001.conf\n</code></pre>\n<p>​\t需要修改如下</p>\n<pre><code>port 7001\ncluster-enabled yes\ncluster-config-file nodes-7001.conf\ncluster-node-timeout 15000\n# appendonly yes 如果开启aof默认，需要修改为yes。如果使用rdb，此处不需要修改\ndaemonize yes\nprotected-mode no\npidfile /var/run/redis_7001.pid\n</code></pre>\n<h3 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h3><h4 id=\"3-复制配置文件，并修改内容\"><a href=\"#3-复制配置文件，并修改内容\" class=\"headerlink\" title=\"3 .复制配置文件，并修改内容\"></a>3 .<strong>复制配置文件，并修改内容</strong></h4><p>​\t把redis-7001.conf 复制5份，分别叫做redis-7002.conf、redis-7003.conf、redis-7004.conf、redis-7005.conf、redis-7006.conf </p>\n<pre><code># cp redis-7001.conf redis-7002.conf\n# cp redis-7001.conf redis-7003.conf\n# cp redis-7001.conf redis-7004.conf\n# cp redis-7001.conf redis-7005.conf\n# cp redis-7001.conf redis-7006.conf\n</code></pre>\n<pre><code> 新复制的5个配置文件都需要需改三处。\n</code></pre>\n<p>​\t例如nodes-7002.conf中需要把所有7001都换成7002。</p>\n<p>​\t可以使用 :%s&#x2F;7001&#x2F;7002&#x2F;g 进行全局修改。 </p>\n<pre><code>port 7002\ncluster-config-file nodes-7002.conf\npidfile /var/run/redis_7002.pid\n</code></pre>\n<h4 id=\"4-启动6个redis\"><a href=\"#4-启动6个redis\" class=\"headerlink\" title=\"4 .启动6个redis\"></a>4 .<strong>启动6个redis</strong></h4><p>​\t可以使用redis-server结合6个配置文件进行启动6个实例。</p>\n<p>​\t执行之前一定要先删除dump.rdb</p>\n<pre><code># rm -f dump.rdb\n# vim startup.sh\n\n./redis-server redis-7001.conf\n./redis-server redis-7002.conf\n./redis-server redis-7003.conf\n./redis-server redis-7004.conf\n./redis-server redis-7005.conf\n./redis-server redis-7006.conf\n\n\n# chmod a+x startup.sh\n# ./startup.sh\n</code></pre>\n<h4 id=\"5-查看启动状态\"><a href=\"#5-查看启动状态\" class=\"headerlink\" title=\"5. 查看启动状态\"></a>5. <strong>查看启动状态</strong></h4><img data-src=\"/2022/10/07/Redis/Redis-10.jpg\" class=\"\">\n\n<h4 id=\"6-建立集群\"><a href=\"#6-建立集群\" class=\"headerlink\" title=\"6. 建立集群\"></a>6. <strong>建立集群</strong></h4><p>​\t在redis3的时候需要借助ruby脚本实现集群。在redis5中可以使用自带的redis-cli实现集群功能，比redis3的时候更加方便了。</p>\n<p>​\t建议配置静态ip，ip改变集群失效</p>\n<pre><code>./redis-cli --cluster create 192.168.93.10:7001 192.168.93.10:7002 192.168.93.10:7003 192.168.93.10:7004 192.168.93.10:7005 192.168.93.10:7006 --cluster-replicas 1\n</code></pre>\n<h4 id=\"7-测试\"><a href=\"#7-测试\" class=\"headerlink\" title=\"7. 测试\"></a>7. <strong>测试</strong></h4><p>​\t集群测试时，千万不要忘记最后一个-c参数。</p>\n<pre><code># ./redis-cli -p 7001 -c\n# set age 18\n</code></pre>\n<h4 id=\"8-编写关闭脚本\"><a href=\"#8-编写关闭脚本\" class=\"headerlink\" title=\"8 .编写关闭脚本\"></a>8 .<strong>编写关闭脚本</strong></h4><pre><code># vim stop.sh\n# chmod a+x stop.sh\n\n./redis-cli -p 7001 shutdown\n./redis-cli -p 7002 shutdown\n./redis-cli -p 7003 shutdown\n./redis-cli -p 7004 shutdown\n./redis-cli -p 7005 shutdown\n./redis-cli -p 7006 shutdown\n</code></pre>\n<h3 id=\"八-集群-Cluster-PATH-docker\"><a href=\"#八-集群-Cluster-PATH-docker\" class=\"headerlink\" title=\"八. 集群(Cluster)-PATH:docker\"></a>八. 集群(Cluster)-PATH:docker</h3><p>​\t<strong>注：</strong>1.如果是配置修改之前<strong>已经创建过的集群时</strong>，要先进行第七步操作。</p>\n<p>​\t\t\t2.要是想重启集群可以省略第一步，但是得<strong>先删除已经创建的容器</strong>，重新进行2、3（合并也行）</p>\n<h4 id=\"0、创建网络\"><a href=\"#0、创建网络\" class=\"headerlink\" title=\"0、创建网络\"></a>0、创建网络</h4><p><strong>目的：</strong>让宿主机可以访问到自身</p>\n<pre><code class=\"shell\">docker network create net-redis --subnet 172.38.0.0/16\n</code></pre>\n<p>补充：关于虚拟机的三种网路连接方式区别</p>\n<p> <span class=\"exturl\" data-url=\"aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYmlmZW5nbWlhb3podWFuL2FydGljbGUvZGV0YWlscy83OTg4NzY5Mj9zcG09MTAwMS4yMTAxLjMwMDEuNjY2MS4xJmFtcDt1dG1fbWVkaXVtPWRpc3RyaWJ1dGUucGNfcmVsZXZhbnRfdDAubm9uZS10YXNrLWJsb2ctMn5kZWZhdWx0fkNUUkxJU1R+UmF0ZS0xLnBjX3JlbGV2YW50X2RlZmF1bHQmYW1wO2RlcHRoXzEtdXRtX3NvdXJjZT1kaXN0cmlidXRlLnBjX3JlbGV2YW50X3QwLm5vbmUtdGFzay1ibG9nLTJ+ZGVmYXVsdH5DVFJMSVNUflJhdGUtMS5wY19yZWxldmFudF9kZWZhdWx0JmFtcDt1dG1fcmVsZXZhbnRfaW5kZXg9MQ==\">http://blog.csdn.net/bifengmiaozhuan/article/details/79887692?spm=1001.2101.3001.6661.1&amp;utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1.pc_relevant_default&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1.pc_relevant_default&amp;utm_relevant_index=1</span> </p>\n<p><img data-src=\"C:\\Users\\Lenovo\\AppData\\Roaming\\Typora\\typora-user-images\\1645532994890.png\" alt=\"1645532994890\"></p>\n<h4 id=\"1、创建并修改配置文件\"><a href=\"#1、创建并修改配置文件\" class=\"headerlink\" title=\"1、创建并修改配置文件\"></a>1、创建并修改配置文件</h4><p><strong>注：</strong></p>\n<pre><code>In certain deployments, Redis Cluster nodes address discovery fails, because addresses are NAT-ted or because ports are forwarded (the typical case is Docker and other containers).\n\n在某些部署中，Redis群集节点地址发现失败，因为地址是NAT，或者端口是转发的（典型情况是Docker和其他容器）。\n\nIn order to make Redis Cluster working in such environments, a static configuration where each node knows its public address is needed. The following two options are used for this scope, and are:\n\n为了让Redis集群在这样的环境中工作，需要一种静态配置，其中每个节点都知道自己的公共地址。以下两个选项用于此范围，分别是：\n\ncluster-announce-ip\n\ncluster-announce-port\n---------------------------------------------------------------------------------------\n你的docker内网是172，你宿主的IP是192网段\n\n根据redis的配置文件中的解释\n\n要在你的配置文件上加上上面的2个配置\n</code></pre>\n<p><strong>方法一：</strong>参考上面的方法一样行。</p>\n<p><strong>方法二：</strong>使用脚本</p>\n<pre><code class=\"shell\">#cat &lt;&lt;EOF EOF在这里没有特殊的含义，你可以使用FOE或000等;\n#表示以cat &lt;&lt;EOF 开始输入以 EOF 结束结束输入\n#cat&gt;创建文件，并把标准输入输出到后面的filename文件\n\n\n# * cluster-announce-ip\t\t\t\t\t192.168.1.195\t#*群集ip\n# * cluster-announce-port\t\t\t\t700$&#123;port&#125;\t\t#*群集总线端口\n# * cluster-announce-bus-port#*群集ip    1700$&#123;port&#125;\t   #*群集公布端口\n# 集群 ip 是固定+10000\n\n# 可以使用 :  %s/7001/7002/g     进行全局修改。 ---将全局的7001修改成7002\n\nfor port in $(seq 1 6); \\ \ndo \\\nmkdir  -p  /root/myredis/conf700$&#123;port&#125;\ntouch  /root/myredis/conf700$&#123;port&#125;/redis.conf\ncat &lt;&lt;TTT &gt; /root/myredis/conf700$&#123;port&#125;/redis.conf port 6379\nbind 0.0.0.0\nport 700$&#123;port&#125;\ncluster-enabled yes\ncluster-config-file nodes-700$&#123;port&#125;.conf\ncluster-node-timeout 15000\nprotected-mode no\npidfile /var/run/redis_ 700$&#123;port&#125;.pid\ncluster-announce-ip  192.168.1.195 \ncluster-announce-port  700$&#123;port) \ncluster-announce-bus-port 1700$&#123;port) \nappendonly yes \nTTT \ndone\n</code></pre>\n<h4 id=\"2、创建容器\"><a href=\"#2、创建容器\" class=\"headerlink\" title=\"2、创建容器\"></a>2、创建容器</h4><p><strong>方法一：</strong>手动创建容器，并启动</p>\n<pre><code class=\"shell\">docker run -p 7001:7001   -p 17001:17001  --name redis7001  -v /root/myredis/conf7001/redis.conf:/etc/redis/redis.conf -v /root/myredis/data7001:/data -d redis redis-server /etc/redis/redis.conf --appendonly yes\n</code></pre>\n<p>​\t7002 ~~~7006同上，自行修改参数</p>\n<p><strong>方法二：</strong>脚本一键启动，效果同上</p>\n<p>​\t<strong>注意：</strong></p>\n<ul>\n<li>其中要指定两个端口号**-p 1700${port}:1700${port}**不要忘记，否则会在创建几群的时候出现  **Waiting for the cluster to join   ** 。【具体原因，我还没查出来，后面补充】</li>\n<li>在docker创建集群容器的时候，<strong>一定要</strong> 指定  ip</li>\n</ul>\n<p><strong>补充：</strong></p>\n<ul>\n<li>那肯定是你端口没有开启，不要质疑，这里的端口不是7000-7005，而是17000-17005，因为redis设置集群的端口号是”redis端口+10000“，这个非常重要。并且7001:7006也是必须打开的。</li>\n</ul>\n<pre><code class=\"shell\">for port in $(seq 1 6);  \\\ndo \\\ndocker run -p 700$&#123;port&#125;:700$&#123;port&#125;   -p 1700$&#123;port&#125;:1700$&#123;port&#125;  --name redis700$&#123;port&#125;  \\\n-v /root/redis/redis700$&#123;port&#125;.conf:/etc/redis/redis.conf \\\n-v /root/redis/data700$&#123;port&#125;:/data \\\n-d --ip 192.168.1.195 redis redis-server /etc/redis/redis.conf \ndone\n</code></pre>\n<h4 id=\"3、进入容器\"><a href=\"#3、进入容器\" class=\"headerlink\" title=\"3、进入容器\"></a>3、进入容器</h4><pre><code class=\"shell\">docker exec -it redis7001 /bin/bash\n</code></pre>\n<h4 id=\"4、创建集群\"><a href=\"#4、创建集群\" class=\"headerlink\" title=\"4、创建集群\"></a>4、创建集群</h4><p>​\t<strong>注：</strong>有一步操作，要自行进行确认，一定要输入 <strong>yes</strong> 而不是 <strong>y</strong> 或者其他之类的，除了 yes一律视为 <strong>no</strong> 。</p>\n<pre><code class=\"shell\">redis-cli --cluster create 192.168.1.195:7001 192.168.1.195:7002 192.168.1.195:7003 192.168.1.195:7004 192.168.1.195:7005 192.168.1.195:7006 --cluster-replicas 1\n</code></pre>\n<h4 id=\"5、测试\"><a href=\"#5、测试\" class=\"headerlink\" title=\"5、测试\"></a>5、测试</h4><p>​\t集群测试时，千万不要忘记最后一个-c参数。</p>\n<pre><code class=\"shel\">redis-cli -p 7001 -c\n</code></pre>\n<h4 id=\"6、关闭集群\"><a href=\"#6、关闭集群\" class=\"headerlink\" title=\"6、关闭集群\"></a>6、关闭集群</h4><p><strong>方法一：</strong></p>\n<p>​\t自行手动一个一个停止，并且删除容器</p>\n<pre><code class=\"shell\">docker stop redis7001 #7002 ~~~7006\n\ndocker rm -f redis7001\n</code></pre>\n<p><strong>方法二：</strong></p>\n<p>​\t脚本程序，一劳永逸</p>\n<pre><code class=\"shell\">for port in $(seq 1 6);  \\\ndo \\\ndocker stop redis700$&#123;port&#125;\ndocker rm -f redis700$&#123;port&#125;\ndone\n</code></pre>\n<h4 id=\"7、清空集群文件\"><a href=\"#7、清空集群文件\" class=\"headerlink\" title=\"7、清空集群文件\"></a>7、清空集群文件</h4><pre><code class=\"shell\">for port in $(seq 1 6);  \\\ndo \\\nrm  -rf  ./data700$&#123;port&#125;/* \ndone\n</code></pre>\n<h3 id=\"九-Jedis\"><a href=\"#九-Jedis\" class=\"headerlink\" title=\"九. Jedis\"></a>九. <strong>Jedis</strong></h3><p>​\tRedis给Java语言提供了客户端API，称之为Jedis。</p>\n<p>​\tJedis API和Redis 命令几乎是一样的。</p>\n<p>​\t例如：Redis对String值新增时set命令，Jedis中也是set方法。所以本课程中没有重点把所有方法进行演示，重要演示Jedis如何使用。</p>\n<p>​\tJedis API特别简单，基本上都是创建对象调用方法即可。</p>\n<h4 id=\"1-单机版\"><a href=\"#1-单机版\" class=\"headerlink\" title=\"1. 单机版\"></a>1. <strong>单机版</strong></h4><pre><code>public void testStandalone()&#123;\n    Jedis jedis = new Jedis(&quot;192.168.93.10&quot;,6379);\n    jedis.set(&quot;name&quot;,&quot;msb-standalone&quot;);\n    String value = jedis.get(&quot;name&quot;);\n    System.out.println(value);\n&#125;\n</code></pre>\n<h4 id=\"2-带有连接池\"><a href=\"#2-带有连接池\" class=\"headerlink\" title=\"2. 带有连接池\"></a>2. <strong>带有连接池</strong></h4><pre><code>public void testPool()&#123;\n    JedisPoolConfig jedisPoolConfig = new JedisPoolConfig();\n    jedisPoolConfig.setMaxTotal(20);\n    jedisPoolConfig.setMaxIdle(5);\n    jedisPoolConfig.setMinIdle(3);\n    JedisPool jedisPool = new JedisPool(jedisPoolConfig,&quot;192.168.93.10&quot;,6379);\n    Jedis jedis = jedisPool.getResource();\n    jedis.set(&quot;name&quot;,&quot;msb-pool&quot;);\n    String value = jedis.get(&quot;name&quot;);\n    System.out.println(value);\n&#125;\n</code></pre>\n<h4 id=\"3-集群\"><a href=\"#3-集群\" class=\"headerlink\" title=\"3. 集群\"></a>3. <strong>集群</strong></h4><pre><code>public void testCluster()&#123;\n    Set&lt;HostAndPort&gt; set = new HashSet&lt;&gt;();\n    set.add(new HostAndPort(&quot;192.168.93.10&quot;,7001));\n    set.add(new HostAndPort(&quot;192.168.93.10&quot;,7002));\n    set.add(new HostAndPort(&quot;192.168.93.10&quot;,7003));\n    set.add(new HostAndPort(&quot;192.168.93.10&quot;,7004));\n    set.add(new HostAndPort(&quot;192.168.93.10&quot;,7005));\n    set.add(new HostAndPort(&quot;192.168.93.10&quot;,7006));\n    JedisCluster jedisCluster = new JedisCluster(set);\n    jedisCluster.set(&quot;name&quot;,&quot;bjmsb&quot;);\n    String value = jedisCluster.get(&quot;name&quot;);\n    System.out.println(value);\n&#125;\n</code></pre>\n<h3 id=\"十-使用SpringBoot整合SpringDataRedis操作redis\"><a href=\"#十-使用SpringBoot整合SpringDataRedis操作redis\" class=\"headerlink\" title=\"十. 使用SpringBoot整合SpringDataRedis操作redis\"></a>十. <strong>使用SpringBoot整合SpringDataRedis操作redis</strong></h3><p>​\tSpring Data是Spring公司的顶级项目，里面包含了N多个二级子项目，这些子项目都是相对独立的项目。每个子项目是对不同API的封装。</p>\n<p>​\t所有Spring Boot整合Spring Data xxxx的启动器都叫做spring-boot-starter-data-xxxx</p>\n<p>​\tSpring Data 好处很方便操作对象类型。</p>\n<p>​\t把Redis不同值得类型放到一个opsForXXX方法中。</p>\n<p>​\t\topsForValue : String值</p>\n<p>​\t\topsForList : 列表List</p>\n<p>​\t\topsForHash: 哈希表Hash</p>\n<p>​\t\topsForZSet: 有序集合Sorted Set</p>\n<p>​\t\topsForSet : 集合</p>\n<h4 id=\"1-添加依赖\"><a href=\"#1-添加依赖\" class=\"headerlink\" title=\"1. 添加依赖\"></a>1. <strong>添加依赖</strong></h4><pre><code>     &lt;parent&gt;\n        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;\n        &lt;version&gt;2.2.2.RELEASE&lt;/version&gt;\n    &lt;/parent&gt;\n\n    &lt;dependencies&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;\n            &lt;version&gt;2.2.5.RELEASE&lt;/version&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;\n            &lt;version&gt;2.1.1&lt;/version&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;mysql&lt;/groupId&gt;\n            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;\n            &lt;version&gt;5.1.47&lt;/version&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;\n            &lt;version&gt;2.2.2.RELEASE&lt;/version&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;\n            &lt;artifactId&gt;lombok&lt;/artifactId&gt;\n            &lt;version&gt;1.18.20&lt;/version&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;redis.clients&lt;/groupId&gt;\n            &lt;artifactId&gt;jedis&lt;/artifactId&gt;\n            &lt;version&gt;3.3.0&lt;/version&gt;\n        &lt;/dependency&gt;\n    &lt;/dependencies&gt;\n</code></pre>\n<h4 id=\"2-配置配置文件\"><a href=\"#2-配置配置文件\" class=\"headerlink\" title=\"2. 配置配置文件\"></a>2. <strong>配置配置文件</strong></h4><p><strong>注：</strong></p>\n<ul>\n<li><p>spring.redis.host&#x3D;localhost 默认值</p>\n</li>\n<li><p>spring.redis.port&#x3D;6379 端口号默认值</p>\n</li>\n</ul>\n<pre><code>mybatis:\n  mapper-locations: classpath:mybatis/*\n  type-aliases-package: com.msb.pojo\nspring:\n  datasource:\n    url: jdbc:mysql://localhost:3306/mydb\n    username: root\n    password: root\n    driver-class-name: com.mysql.jdbc.Driver\n  redis:\n    host: 192.168.1.195\n    cluster:\n      nodes: 192.168.1.195:7001,192.168.1.195:7002,192.168.1.195:7003,192.168.1.195:7004,192.168.1.195:7005,192.168.1.195:7006\n</code></pre>\n<h4 id=\"3-编写配置类（可直接复制）\"><a href=\"#3-编写配置类（可直接复制）\" class=\"headerlink\" title=\"3.编写配置类（可直接复制）\"></a>3.<strong>编写配置类</strong>（可直接复制）</h4><pre><code>@Configuration\npublic class RedisConfig &#123;\n    @Bean\n    public RedisTemplate&lt;String,Object&gt; redisTemplate(RedisConnectionFactory \t\t  factory)&#123;\n        RedisTemplate&lt;String,Object&gt; redisTemplate = new RedisTemplate&lt;&gt;();\n        redisTemplate.setConnectionFactory(factory);\n        redisTemplate.setKeySerializer(new StringRedisSerializer());\n        redisTemplate.setValueSerializer(new Jackson2JsonRedisSerializer&lt;Object&gt;(Object.class));\n        return redisTemplate;\n    &#125;\n&#125;\n</code></pre>\n<h4 id=\"4-编写代码\"><a href=\"#4-编写代码\" class=\"headerlink\" title=\"4. 编写代码\"></a>4. <strong>编写代码</strong></h4><h5 id=\"4-1-编写对象新增\"><a href=\"#4-1-编写对象新增\" class=\"headerlink\" title=\"4.1 编写对象新增\"></a>4.1 <strong>编写对象新增</strong></h5><pre><code>@Autowired\nprivate RedisTemplate&lt;String, Object&gt; redisTemplate;\n\n@Test\npublic void testString() &#123;\n    People peo = new People(1, &quot;张三&quot;);\n    redisTemplate.opsForValue().set(&quot;peo1&quot;, peo);\n&#125;\n</code></pre>\n<h5 id=\"4-2-编写对象获取\"><a href=\"#4-2-编写对象获取\" class=\"headerlink\" title=\"4.2 编写对象获取\"></a>4.2 <strong>编写对象获取</strong></h5><p>此处必须编写值序列化器。不指定时返回类型为LinkedHashMap</p>\n<pre><code>@Test\npublic void testGetString() &#123;\n    redisTemplate.setValueSerializer(new Jackson2JsonRedisSerializer&lt;People&gt;(People.class));\n    People peo = (People) redisTemplate.opsForValue().get(&quot;peo1&quot;);\n    System.out.println(peo);\n&#125;\n</code></pre>\n<h5 id=\"4-3-编写List\"><a href=\"#4-3-编写List\" class=\"headerlink\" title=\"4.3 编写List\"></a>4.3 <strong>编写List</strong></h5><pre><code>@Test\npublic void testList() &#123;\n    List&lt;People&gt; list = new ArrayList&lt;&gt;();\n    list.add(new People(1, &quot;张三&quot;));\n    list.add(new People(2, &quot;李四&quot;));\n    redisTemplate.opsForValue().set(&quot;list2&quot;, list);\n&#125;\n</code></pre>\n<h5 id=\"4-4-编写List取值\"><a href=\"#4-4-编写List取值\" class=\"headerlink\" title=\"4.4 编写List取值\"></a>4.4 <strong>编写List取值</strong></h5><pre><code>@Test\npublic void testGetList()&#123;\n    redisTemplate.setValueSerializer(new Jackson2JsonRedisSerializer&lt;List&gt;(List.class));\n    List&lt;People&gt; list2 = (List&lt;People&gt;) redisTemplate.opsForValue().get(&quot;list2&quot;);\n    System.out.println(list2);\n&#125;\n</code></pre>\n<h3 id=\"十一-使用Redis效果\"><a href=\"#十一-使用Redis效果\" class=\"headerlink\" title=\"十一. 使用Redis效果\"></a>十一. <strong>使用Redis效果</strong></h3><p>​\t使用缓存流程</p>\n<p>​\t1. 先判断缓存中是否存在。如果存在直接从缓存中取出数据。不执行2，3步骤</p>\n<p>​\t2. 如果不存在，从mysql中获取数据</p>\n<p>​\t3. 获取数据后，把数据缓存到redis中</p>\n<img data-src=\"/2022/10/07/Redis/Redis-11.jpg\" class=\"\">",
            "tags": [
                "分布式",
                "中间件",
                "Redis基础",
                "NoSQL数据库"
            ]
        }
    ]
}